<?xml version="1.0" encoding="UTF-8" standalone="no"?><templates><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="template for application examples" enabled="true" name="appexample">// include example header
#include "example.h"

// include the header of the class which this example is for
#include "${app_directory}/bcl_app_${class_file_name}.h"

// includes from bcl - sorted alphabetically
#include "example_application_example_helper.h"

// external includes - sorted alphabetically

namespace bcl
{
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //!
  //! @example ${file}
  //! @brief TODO: add an detailed description for this example
  //!
  //! @author ${user}
  //! @date ${date}
  //! @remarks status empty
  //!
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  class ExampleApp${example_name} :
    public ExampleInterface
  {
  public:
  
    ExampleApp${example_name} *Clone() const
    { 
      return new ExampleApp${example_name}( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &amp;GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    int Run() const
    {
    ////////////////
    // unit tests //
    ////////////////
      
      // unit tests of application class functions, if applicable, go here

    ////////////////////
    // initialization //
    ////////////////////
      
      // create a helper to run this application
      ApplicationExampleHelper ${class_file_name}( app::${example_name}::${example_name}_Instance);
      
    ///////////
    // files //
    ///////////
      
      // create filenames for any input/output files used/generated by the test
      ${cursor}

    ///////////////////////
    // integration tests //
    ///////////////////////
      
      // set flags; check valid and invalid command lines; check results

      return 0;
    }
  
    static const ExampleClass::EnumType s_Instance;

  }; //end ExampleApp${example_name}

  const ExampleClass::EnumType ExampleApp${example_name}::s_Instance
  (
    GetExamples().AddEnum( ExampleApp${example_name}())
  );
  
} // namespace bcl
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="code template for bcl class declarations" enabled="true" id="org.eclipse.cdt.ui.text.templates.cpp.class" name="class">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//!
//! @class ${class_name} 
//! @brief TODO: add a brief comment
//! @details TODO: add an detailed description to this class
//!
//! @see @link example_${namespace}_${class_name}.cpp @endlink
//! @author ${user}
//! @date ${date}
//!
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class BCL_API ${class_name} :
  public util::ObjectInterface
{

private:

//////////
// data //
//////////
${cursor}
public:

  //! single instance of that class
  static const util::SiPtr&lt; const util::ObjectInterface&gt; s_Instance;

//////////////////////////////////
// construction and destruction //
//////////////////////////////////

  //! @brief default constructor
  ${class_name}();
  
  //! @brief Clone function
  //! @return pointer to new ${class_name}
  ${class_name} *Clone() const;

/////////////////
// data access //
/////////////////

  //! @brief returns class name
  //! @return the class name as const ref std::string
  const std::string &amp;GetClassIdentifier() const;

////////////////
// operations //
////////////////

///////////////
// operators //
///////////////

//////////////////////
// input and output //
//////////////////////

protected:

  //! @brief read from std::istream
  //! @param ISTREAM input stream
  //! @return istream which was read from
  std::istream &amp;Read( std::istream &amp;ISTREAM);
  
  //! @brief write to std::ostream
  //! @param OSTREAM outputstream to write to
  //! @param INDENT number of indentations
  //! @return outputstream which was written to
  std::ostream &amp;Write( std::ostream &amp;OSTREAM, const size_t INDENT) const;

//////////////////////
// helper functions //
//////////////////////

private:

}; // class ${class_name}
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="template for the source code of a class" enabled="true" name="classsource">//////////
// data //
//////////
  
  //! single instance of that class
  const util::SiPtr&lt; const util::ObjectInterface&gt; ${class_name}::s_Instance
  (
    GetObjectInstances().AddInstance( new ${class_name}())
  );

//////////////////////////////////
// construction and destruction //
//////////////////////////////////
  
  //! @brief default constructor
  ${class_name}::${class_name}()${cursor}
  {
  }

  //! @brief Clone function
  //! @return pointer to new ${class_name}
  ${class_name} *${class_name}::Clone() const
  {
    return new ${class_name}( *this);
  }

/////////////////
// data access //
/////////////////

  //! @brief returns class name
  //! @return the class name as const ref std::string
  const std::string &amp;${class_name}::GetClassIdentifier() const
  {
    return GetStaticClassName( *this);
  }

////////////////
// operations //
////////////////

///////////////
// operators //
///////////////

//////////////////////
// input and output //
//////////////////////

  //! @brief read from std::istream
  //! @param ISTREAM input stream
  //! @return istream which was read from
  std::istream &amp;${class_name}::Read( std::istream &amp;ISTREAM)
  {
    // read members
    
    // return the stream
    return ISTREAM;
  }

  //! @brief write to std::ostream
  //! @param OSTREAM output stream to write to
  //! @param INDENT number of indentations
  //! @return outputstream which was written to
  std::ostream &amp;${class_name}::Write( std::ostream &amp;OSTREAM, const size_t INDENT) const
  {
    // write members
    
    // return the stream
    return OSTREAM;
  }

//////////////////////
// helper functions //
//////////////////////
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="code template for example class" enabled="true" name="example">// include example header
#include "example.h"

// include the header of the class which this example is for
#include "${namespace_name}/bcl_${namespace_name}_${class_file_name}.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //!
  //! @example ${file}
  //! @brief TODO: add an detailed description for this example
  //!
  //! @author ${user}
  //! @date ${date}
  //! @remarks status empty
  //!
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  class Example${example_name} :
    public ExampleInterface
  {
  public:
  
    Example${example_name} *Clone() const
    { 
      return new Example${example_name}( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &amp;GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    int Run() const
    {
    //////////////////////////////////
    // construction and destruction //
    //////////////////////////////////
      ${cursor}

    /////////////////
    // data access //
    /////////////////

    ////////////////
    // operations //
    ////////////////

    ///////////////
    // operators //
    ///////////////

    //////////////////////
    // input and output //
    //////////////////////

    //////////////////////
    // helper functions //
    //////////////////////

      return 0;
    }
  
    static const ExampleClass::EnumType s_Instance;

  }; //end Example${example_name}

  const ExampleClass::EnumType Example${example_name}::s_Instance
  (
    GetExamples().AddEnum( Example${example_name}())
  );
  
} // namespace bcl
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="function declaration" enabled="true" name="function">//! @brief ${function_name}&#13;
//! TODO: add a description for the function&#13;
//! @param ${arg_name_a} TODO: add comment&#13;
//! @return TODO: add comment&#13;
${return_type} ${function_name}( ${arg_type_a} ${arg_name_a})&#13;
{&#13;
  ${cursor}&#13;
  //end&#13;
  return ;&#13;
} </template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="namespace declaration" enabled="true" id="org.eclipse.cdt.ui.text.templates.cpp.namespace" name="namespace">namespace ${namespace_name}
{
  ${cursor}
} // namespace ${namespace_name}</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="content of source file" enabled="true" name="source">// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "${namespace_name}/${file_base}.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace ${namespace_name}
  {
    ${cursor}
  } // namespace ${namespace_name}
} // namespace bcl
</template><template autoinsert="true" context="org.eclipse.cdt.ui.text.templates.c" deleted="false" description="this is a code template for bcl template classes with one template argument" enabled="true" name="template class">//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////&#13;
//!&#13;
//! @class ${class_name} &#13;
//! @brief TODO: add a brief comment&#13;
//! @details TODO: add an detailed description to this class&#13;
//!&#13;
//! @tparam t_${typename_a} TODO: add a description for the template parameter&#13;
//!&#13;
//! @see @link example_${namespace}_${class_name}.cpp @endlink&#13;
//! @author ${user}&#13;
//! @date ${date}&#13;
//!&#13;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////&#13;
&#13;
template&lt; typename t_${typename_a}&gt;&#13;
class ${class_name} :&#13;
  public util::ObjectInterface&#13;
{&#13;
&#13;
private:&#13;
&#13;
//////////&#13;
// data //&#13;
//////////&#13;
  ${cursor}&#13;
public:&#13;
&#13;
  //! single instance of that class&#13;
  static const util::SiPtr&lt; const util::ObjectInterface&gt; s_Instance;&#13;
&#13;
//////////////////////////////////&#13;
// construction and destruction //&#13;
//////////////////////////////////&#13;
  &#13;
  //! @brief default constructor&#13;
  ${class_name}()&#13;
  {&#13;
  }&#13;
&#13;
  //! @brief Clone function&#13;
  //! @return pointer to new ${class_name}&lt; t_${typename_a}&gt;&#13;
  ${class_name}&lt; t_${typename_a}&gt; *Clone() const&#13;
  {&#13;
    return new ${class_name}&lt; t_${typename_a}&gt;( *this);&#13;
  }&#13;
&#13;
/////////////////&#13;
// data access //&#13;
/////////////////&#13;
&#13;
  //! @brief returns class name&#13;
  //! @return the class name as const ref std::string&#13;
  const std::string &amp;GetClassIdentifier() const&#13;
  {&#13;
    return GetStaticClassName( *this);&#13;
  }&#13;
&#13;
////////////////&#13;
// operations //&#13;
////////////////&#13;
&#13;
///////////////&#13;
// operators //&#13;
///////////////&#13;
&#13;
//////////////////////&#13;
// input and output //&#13;
//////////////////////&#13;
&#13;
protected:&#13;
&#13;
  //! @brief read from std::istream&#13;
  //! @param ISTREAM input stream&#13;
  //! @return istream which was read from&#13;
  std::istream &amp;Read( std::istream &amp;ISTREAM)&#13;
  {&#13;
    // read members&#13;
    &#13;
    // return the stream&#13;
    return ISTREAM;&#13;
  }&#13;
&#13;
  //! @brief write to std::ostream&#13;
  //! @param OSTREAM output stream to write to&#13;
  //! @param INDENT number of indentations&#13;
  //! @return outputstream which was written to&#13;
  std::ostream &amp;Write( std::ostream &amp;OSTREAM, const size_t INDENT) const&#13;
  {&#13;
    // write members&#13;
    &#13;
    // return the stream&#13;
    return OSTREAM;&#13;
  }&#13;
&#13;
//////////////////////&#13;
// helper functions //&#13;
//////////////////////&#13;
&#13;
private:&#13;
&#13;
}; // template class ${class_name}&#13;
&#13;
// instantiate s_Instance&#13;
template&lt; typename t_${typename_a}&gt;&#13;
const util::ObjectInterface *${class_name}&lt; t_${typename_a}&gt;::s_Instance&#13;
(&#13;
  GetObjectInstances().AddInstance( new ${class_name}&lt; t_${typename_a}&gt;())&#13;
);&#13;
</template></templates>
