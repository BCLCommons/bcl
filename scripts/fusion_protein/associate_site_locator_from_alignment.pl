#!/usr/bin/perl
use Getopt::Long;
use File::Basename;

my $usage =
"
\t from a fasta alignment with the header \">1ubi_A:\" and a loop definition file, draft fragment replacement
   experiments for BCL::FusionProtein

\t-b  or -bcl                \tthe bcl executable
\t-g  or -general_flags      \tthe general flags file shared by all commandlines
\t-o  or -output_prefix      \tthe output prefix
\t-lp or -locators_path      \tthe path pointing to the locators generated by 'make_locators.pl' script
\t-sp or -sites_path         \tthe path pointing to the sites generated by 'make_locators.pl' script
\t-a  or -alignment          \tthe aligment input file in fasta format
\t-s  or -scaffold_file      \tthe scaffold pdb file
\t-d  or -donor_file         \tthe donor pdb file
\t-sl or -scaffold_loop_file \tthe scaffold loop file
\t-dl or -donor_loop_file    \tthe donor loop file
\t-v  or -verbose            \tverbose mode

author\t Nils Woetzel
date\t   10/28/2013\n
";

## initialize command line variables
$bcl_exe             = "";
$bcl_general_flags   = "";
$output_prefix       = "";
$locators_path       = "";
$sites_path          = "";
$alignment_file = "";
$scaffold_loop_file = "";
$donor_loop_file = "";

## print help if no argument is given
die $usage if( $#ARGV == -1);

## set the options form the command line
GetOptions
(
  "b|bcl=s"                 => \$bcl_exe,
  "g|general_flags=s"       => \$bcl_general_flags,
  "o|output_prefix=s"       => \$output_prefix,
  "lp|locators_path=s"      => \$locators_path,
  "sp|sites_path=s"         => \$sites_path,
  "a|alignment=s"           => \$alignment_file,
  "sl|scaffold_loop_file=s" => \$scaffold_loop_file,
  "dl|donor_loop_file=s"    => \$donor_loop_file,
  "s|scaffold_file=s"       => \$scaffold_file,
  "d|donor_file=s"          => \$donor_file,
  "v|verbose"               => \$verbose
) or die "invalid command line!\n";


## display the variables
if( defined $verbose)
{
  print "b|bcl                 = $bcl_exe\n";
  print "g|general_flags       = $bcl_general_flags\n";
  print "o|output_prefix       = $output_prefix\n";
  print "lp|locators_path      = $locators_path\n";
  print "sp|sites_path         = $sites_path\n";
  print "a|alginment           = $alignment_file\n";
  print "sl|scaffold_loop_file = $scaffold_loop_file\n";
  print "dl|donor_loop_file    = $donor_loop_file\n";
  print "s|scaffold_file       = $scaffold_file\n";
  print "d|donor_file          = $donor_file\n";
}

# open the alignment file
open( IN, "<", $alignment_file) or die "cannot open alignment file\n";
%sequences = {};

my $pdbid;
while( $line = <IN>)
{
  if( $line =~ /^>/)
  {
    $pdbid = lc( substr( $line, 1, 4).substr( $line, 6, 1));
    $verbose && print "parsing fasta sequence for: $pdbid\n";
    next;
  }
  # skip all lines until the first pdbid was found
  if( not defined $pdbid)
  {
    next;
  }
  chomp( $line);
  $sequences{$pdbid}.=$line;
}
close( IN);

## determine the actual seqid of each residue
my %seqids;

foreach my $key (sort keys(%sequences))
{
  my $count = 0;
  my $sequence = $sequences{$key};
  for( my $i = 0; $i < length( $sequence); ++$i)
  {
    if( substr( $sequence, $i, 1) ne "-")
    {
      ++$count;
      push( @{$seqids{$key}},$count);
    }
    else
    {
      push( @{$seqids{$key}}, "-");
    }
  }
  $verbose && print "$key : $sequence\n";
  $verbose && print "$key : @{$seqids{$key}}\n";
}

my @suffixlist = ( ".loops", ".loop");
my $scaffold = fileparse( $scaffold_loop_file, @suffixlist);
my $donor    = fileparse( $donor_loop_file, @suffixlist);

if( length( $scaffold) != 5){( my $tmp, $scaffold) = split( /_/, $scaffold);}
if( length( $donor) != 5)   {( my $tmp, $donor) = split( /_/, $donor);}

$verbose && print "scaffold : $scaffold\n";
$verbose && print "donor    : $donor\n";

# open scaffold loop file
open( IN, "<", $scaffold_loop_file) or die "cannot open scaffold loop file\n";
@scaffold_loops = ();

while( $line = <IN>)
{
  ( my $pdbid, my $chainid, my $loopid1, my $sse1, my $resn1, my $resi1, my $loopid2, my $sse2, my $resn2, my $resi2) = split( /\s+/, $line);
  push( @scaffold_loops, $resi1."_".$resi2);
}
close( IN);

# open donor loop file
open( IN, "<", $donor_loop_file) or die "cannot open donor loop file\n";
@donor_loops =();

while( $line = <IN>)
{
  ( my $pdbid, my $chainid, my $loopid1, my $sse1, my $resn1, my $resi1, my $loopid2, my $sse2, my $resn2, my $resi2) = split( /\s+/, $line);
  push( @donor_loops, $resi1."_".$resi2);
}
close( IN);

## debugging
$verbose && print "scaffold loops: @scaffold_loops\n";
$verbose && print "donor    loops: @donor_loops\n";

# iterate through all donor loops
my @donor_seq_ids = @{$seqids{lc($donor)}};
my @scaffold_seq_ids = @{$seqids{lc($scaffold)}};

foreach my $donor_loop (@donor_loops)
{
  ( my $donor_loop_start, my $donor_loop_end) = split( /_/, $donor_loop);
#  print "donor: |$donor_loop_start|$donor_loop_end|\n";
  # search for the residue index in the alignment for start and end residue of the loop
  for( $index_s = 0       ; $index_s < scalar( @donor_seq_ids) && $donor_seq_ids[$index_s] != $donor_loop_start ; ++$index_s){}
  for( $index_e = $index_s; $index_e < scalar( @donor_seq_ids) && $donor_seq_ids[$index_e] != $donor_loop_end   ; ++$index_e){}

  # search for closest residue according to alignment in the scaffold
  for( ; $scaffold_seq_ids[$index_s] eq "-" && $index_s >= 0; --$index_s){}
  for( ; $scaffold_seq_ids[$index_e] eq "-" && $index_e < scalar( @scaffold_seq_ids); ++$index_e){}

  if( $index_s < 0 || $index_e > scalar( @scaffold_seq_ids))
  {
    next;
  }

  # seqid of the scaffold residues
  my $scaffold_start = $scaffold_seq_ids[$index_s];
  my $scaffold_end   = $scaffold_seq_ids[$index_e];
#  print "scaffold_align: |$scaffold_start|$scaffold_end|\n";
  
#  $verbose && print "searching for best scaffold loop for donor loop:\t$donor_loop_start\t$donor_loop_end\twith corresponding scaffold residues:$scaffold_start\t$scaffold_end\n";

  my $scaffold_loop_start;
  my $scaffold_loop_end;

  # search for the loop that contains these residues in the scaffold
  my $best_dist_start = 1000;
  my $best_dist_end = 1000;

  # iterate through all scaffold loops to find the one closest to the donor
  foreach my $scaffold_loop (@scaffold_loops)
  {
    ( my $start, my $end) = split( /_/, $scaffold_loop);
#    print "current_scaf: |$start|$end|\n";
    my $curr_dist_start = $scaffold_start - $start;
    my $curr_dist_end   = $end - $scaffold_end;
    if( $curr_dist_start >= 0 && $curr_dist_start < $best_dist_start)
    {
      $best_dist_start = $curr_dist_start;
      $scaffold_loop_start = $start;
    }
    if( $curr_dist_end >= 0 && $curr_dist_end < $best_dist_end)
    {
      $best_dist_end = $curr_dist_end;
      $scaffold_loop_end = $end;
    }
  }
  my $prefix = "${scaffold}_${scaffold_loop_start}_${scaffold_loop_end}_${donor}_${donor_loop_start}_${donor_loop_end}";
#  print "scaffold: |$scaffold_loop_start|$scaffold_loop_end|\n";

#  print "donor:\t$donor_loop_start\t$donor_loop_end\tscaffold:\t$scaffold_loop_start\t$scaffold_loop_end\n";
  if( !defined( $scaffold_loop_start) || !defined( $scaffold_loop_end) || !defined( $donor_loop_start) || !defined( $donor_loop_end))
  {
  	next;
  }
  my $command = "$bcl_exe protein:FusionProtein";
  $command .= " \@$bcl_general_flags";
  $command .= " -output_prefix ${output_prefix}${prefix}";
  $command .= " -scaffold $scaffold_file";
  $command .= " -donor $donor_file";
  $command .= " -scaffold_fragment ${locators_path}*${scaffold}_*_${scaffold_loop_start}_${scaffold_loop_end}.locators";
  $command .= " -donor_sites ${sites_path}*${donor}_*_${donor_loop_start}_${donor_loop_end}.site";
  $command .= " > ${output_prefix}${prefix}_run.log";
  print "$command\n";
}
