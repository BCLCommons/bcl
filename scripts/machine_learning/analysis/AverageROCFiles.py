#!/usr/bin/env python2.7
'''
Script to average ROC files generated by the BCL
Created Dec 2014
@author: mendenjl

'''

import os
import sys
import os.path
import multiprocessing, commands
import argparse, datetime
import uuid
from curses.ascii import isdigit
from time import gmtime, strftime, sleep
import shutil, threading, Queue, random, math, collections, shlex
import numpy as np
from scipy.interpolate import InterpolatedUnivariateSpline

# specify delimiter if not whitespace
def loadCSVFileWithHeader(filename, delimiter=None):
  x = open(filename,'r')
  header_cols = shlex.split(x.readline().strip())
  each_col = np.loadtxt(x,dtype=[(x,float) for x in header_cols], unpack = True, delimiter=delimiter)
  return header_cols, each_col

def StrictlyIncreasing(L):
  return all(x<y for x, y in zip(L, L[1:]))

def NonDecreasing(L):
  return all(x<=y for x, y in zip(L, L[1:]))

def fixSameX(ls):
  if len(ls) == 0:
    return ls
  nlist = [ls[0]]
  i = 1
  av_diff = (ls[-1]-ls[0])/float(len(ls))
  while i < len(ls):
    if nlist[-1] != ls[i]:
      nlist.append(ls[i])
      i += 1
      continue
    run_start = i - 1
    while i < len(ls) and nlist[-1] == ls[i]:
      i += 1
    run_end = i
    run_size = run_end-run_start
    ave_shift = (ls[run_end]-ls[run_start])/float(run_size) if i < len(ls) else av_diff
    for j in range(run_start+1,run_end):
      ls[j] = ls[j-1]+ave_shift
      nlist.append(ls[j])
  return np.array(nlist)

class ROCAverager:

  @staticmethod
  def getParser():
    parser = argparse.ArgumentParser()

    parser.add_argument\
    (\
      '-i',  '--input', \
      help = "Set of directories or .txt.data files to use (if directories are given, all files with .txt.data suffix will be used from within those directories) ", \
      dest = 'inputs', \
      required = True, \
      nargs = '+', \
      metavar = '<txt.data file or containing directory>' \
    )
    parser.add_argument\
    (\
      '-o', '--output-data', \
      help = "Where to write the interpolated, averaged ROC curves", \
      dest = 'output_data', \
      required = True \
    )
    parser.add_argument\
    (\
      '-x', '--xaxis', \
      help = "independent variable to use for interpolation", \
      dest = 'x', \
      default = "FPR", \
      choices = ['FPR', 'Cutoff'] \
    )
    parser.add_argument\
    (\
      '--ignore', \
      help = "dependent variables to skip for plotting averaged values for", \
      dest = 'ignore', \
      default = [], \
      choices = ['InformationGainRatio', 'TPR', 'PPV', 'Ideal-PPV', 'Enrichment', 'Accuracy', 'Ideal-PPV_FPRelative', 'FPR', 'Cutoff', 'MCC', 'Precision', 'Recall', 'Specificity', 'NPR'] \
    )
    return parser

  def __init__(self, option_args):
    self.options = option_args
    self.input_files = []
    for i in self.options.inputs:
      if os.path.isfile(i):
        self.input_files.append(i)
      elif os.path.isdir(i):
        this_dir_files = []
        for root, dirs, files in os.walk(i):
          new_files = [ str(root) + os.sep + str(f) for f in files if os.path.isfile(root + os.sep + f) and f.endswith('.txt.data')]
          if len(new_files) > 0:
            this_dir_files.extend(new_files)
        if len(this_dir_files) == 0:
          print "Directory contained no .txt.data files: " + i + ", skipping"
        else:
          self.input_files.extend(this_dir_files)
      else:
        print "Error, invalid input path: ",i
        sys.exit(-1)
    if len(self.input_files) == 0:
      print "Error: no valid .txt.data files found in given input paths!"
      sys.exit(-1)
      
    self.input_data_arrays = [loadCSVFileWithHeader(x) for x in self.input_files]
    header_columns = [x[0] for x in self.input_data_arrays]
    if header_columns.count(header_columns[0]) != len(header_columns):
      print "Cannot combine files with different headers at this time"
      sys.exit(-1)
    self.header = header_columns[0]
    self.header_dict = dict([(self.header[i],i) for i in range(len(self.header))])
    if self.options.x not in self.header_dict:
      print "Requested X axis: ", self.options.x, " was not present in the data files"
      sys.exit(-1)
    x_index = self.header_dict[self.options.x]
    ignore_set = set(self.options.ignore)
    ignore_set.add( self.options.x)
    if self.options.x == "FPR":
      ignore_set.add( "Ideal-PPV")
    else:
      ignore_set.add( "Ideal-PPV_FPRelative")
    y_indices = [x for x in range(len(self.header)) if self.header[x] not in ignore_set]
    if self.options.x == "FPR" and "Ideal-PPV_FPRelative" in self.header:
      self.header[self.header_dict["Ideal-PPV_FPRelative"]] = "Ideal-PPV"
    # print "X: ", x_index, " Y: ",y_indices
    self.header = [self.header[x] for x in y_indices]
    self.x_vars = [fixSameX(x[1][x_index]) for x in self.input_data_arrays]
    max_min_xvalue = max([min(x[0],x[-1]) for x in self.x_vars])
    min_max_xvalue = min([max(x[0],x[-1]) for x in self.x_vars])
    self.y_vars = [[x[1][y] for y in y_indices] for x in self.input_data_arrays]
    n_inputs = len(self.x_vars)
    n_y_vals = len(self.header)
    all_x_vals = sorted(set([y for x in self.x_vars for y in x]))
    n_x_values = len(all_x_vals)
    output_vectors = []
    bbox = [0.0,1.0] if self.options.x == "FPR" else None
    for y_value_index in range(n_y_vals):
      new_vec = np.zeros(n_x_values)
      for dataset_index in range(n_inputs):
        s = InterpolatedUnivariateSpline(self.x_vars[dataset_index],self.y_vars[dataset_index][y_value_index])
        new_vec += np.nan_to_num(s(all_x_vals))
      new_vec /= float(n_inputs)
      output_vectors.append(new_vec)
    if self.options.output_data:
      ou = open(self.options.output_data,'w')
      ou.write(self.options.x + '\t' + '\t'.join(self.header) + '\n')
      for x in range(n_x_values):
        if all_x_vals[x] >= max_min_xvalue and all_x_vals[x] <= min_max_xvalue:
          ou.write(str(all_x_vals[x]) + '\t' + '\t'.join([str(output_vectors[y][x]) for y in range(n_y_vals)]) + '\n')
      ou.close()
    print "Independent: ",self.header

def main():

  parser = ROCAverager.getParser()
  averager = ROCAverager(parser.parse_args())

if __name__ == '__main__':
    main()
