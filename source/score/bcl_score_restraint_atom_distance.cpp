// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_atom_distance.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "restraint/bcl_restraint_atom_distance_assignment.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintAtomDistance::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "distance_restraint");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    RestraintAtomDistance::RestraintAtomDistance() :
      m_ScoringFunction(),
      m_FinalFraction( 1.0),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief construct from a scoring function and scheme
    //! @param SCORING_FUNCTION scoring function to be used
    //! @param FRACTION fraction of total restraints to be used for final score calculation
    //! @param SCHEME scheme to be used
    //! @param RESTRAINTS the restraints to use
    RestraintAtomDistance::RestraintAtomDistance
    (
      const RestraintAtomDistanceAssignment &SCORING_FUNCTION,
      const double &FRACTION,
      const std::string SCHEME,
      const util::ShPtr< Container> &RESTRAINTS
    ) :
      m_ScoringFunction( SCORING_FUNCTION),
      m_Restraints( RESTRAINTS),
      m_FinalFraction( FRACTION),
      m_Scheme( SCHEME)
    {
      BCL_Assert( m_FinalFraction <= 1.0 && m_FinalFraction >= 0.0, "Restraint fraction is not between zero and one.");
    }

    //! @brief Clone function
    //! @return pointer to new RestraintAtomDistance
    RestraintAtomDistance *RestraintAtomDistance::Clone() const
    {
      return new RestraintAtomDistance( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &RestraintAtomDistance::GetAlias() const
    {
      return this->GetScheme();
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintAtomDistance::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief () operator scores the protein model and associated restraints using the member scoring function
    //! @param PROTEIN_MODEL protein model to be scored
    //! @return distance restraint score
    double RestraintAtomDistance::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // initialize score
      double score( 0.0);

      // if no restraints were found
      if( !m_Restraints.IsDefined())
      {
        // return a score of 0
        BCL_MessageDbg( "No distance restraints found, not scoring the model");
        return score;
      }

      // calculate the number of restraints to consider
      const size_t nr_final_restraints( m_Restraints->GetSize() * m_FinalFraction);

      // if all restraints are requested
      if( m_FinalFraction == 1.0)
      {
        // iterate through the restraints
        for
        (
          Container::const_iterator restraint_itr( m_Restraints->Begin()), restraint_itr_end( m_Restraints->End());
          restraint_itr != restraint_itr_end; ++restraint_itr
        )
        {
          // score the assignment generated by the restraint multiplied by the restraint confidence
          double confidence = ( *restraint_itr)->GetConfidence();
          score += m_ScoringFunction->operator ()( ( *restraint_itr)->GenerateAssignment( PROTEIN_MODEL)) * confidence;
        }
      }
      else
      {
        // create vector to hold all scores
        storage::Vector< double> all_scores;

        // iterate through the restraints
        for
        (
          util::ShPtrVector< restraint::AtomDistance>::const_iterator restraint_itr( m_Restraints->Begin()),
            restraint_itr_end( m_Restraints->End());
          restraint_itr != restraint_itr_end; ++restraint_itr
        )
        {
          // score the assignment generated by the restraint multiplied by the restraint confidence
          double confidence = ( *restraint_itr)->GetConfidence();
          all_scores.PushBack( m_ScoringFunction->operator ()( ( *restraint_itr)->GenerateAssignment( PROTEIN_MODEL)) * confidence);
        }

        // sort the vector
        all_scores.Sort( std::less< double>());

        // iterate over number requested
        for( size_t i( 0); i != nr_final_restraints; ++i)
        {
          score += all_scores( i);
        }
      }

      const double average( score / double( m_Restraints->GetSize()));

      // iterate over the sequences to sum up the # of residues
      double nr_residues( 0.0);
      const util::SiPtrVector< const biol::AASequence> sequences( PROTEIN_MODEL.GetSequences());
      for
      (
        util::SiPtrVector< const biol::AASequence>::const_iterator seq_itr( sequences.Begin()),
          seq_itr_end( sequences.End());
        seq_itr != seq_itr_end; ++seq_itr
      )
      {
        nr_residues += ( *seq_itr)->GetSize();
      }

      // weight average by log(#restraints + 1) * (#AAs)
      return average * log10( double( nr_final_restraints + 1)) * nr_residues;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintAtomDistance::GetSerializer() const
    {
      io::Serializer serializer;
      const bool is_named_instance( m_Scheme != GetDefaultScheme());
      serializer.SetClassDescription
      (
        is_named_instance
        ? "A type of atom distance restraint. Scoring function info: " + m_ScoringFunction->GetCompleteSerializer().GetClassDescription()
        : "An atom distance restraint"
      );
      serializer.AddInitializer
      (
        "fraction",
        "Fraction of best restraints to consider during the score. All restraint scores are calculated, weighted by "
        "confidence, but only this fraction of the best satisfied restraints will be included in the final score",
        io::Serialization::GetAgentWithRange( &m_FinalFraction, 0.0, 1.0),
        is_named_instance ? util::Format()( m_FinalFraction) : "1.0"
      );
      if( !is_named_instance)
      {
        serializer.AddInitializer
        (
          "scoring function",
          "scoring function to use on each restraint",
          io::Serialization::GetAgent( &m_ScoringFunction)
        );
      }
      return serializer;
    }

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL protein model to be evaluated
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &RestraintAtomDistance::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      BCL_MessageDbg( "RestraintAtomDistance::WriteDetailedSchemeAndValues start");
      BCL_Assert( !PROTEIN_MODEL.GetProteinModelData()->GetKeys().IsEmpty(), "protein model data now is " + util::Format()( PROTEIN_MODEL.GetProteinModelData()->GetKeys()));
      // write the scheme of the scoring function used
      OSTREAM << m_ScoringFunction->GetScheme() << '\n';

      // if no restraints were found
      if( !m_Restraints.IsDefined())
      {
        return OSTREAM;
      }

      // initialize violated restraint counter
      size_t violated_restrants( 0);

      // iterate through the restraints
      for
      (
        util::ShPtrVector< restraint::AtomDistance>::const_iterator restraint_itr( m_Restraints->Begin()),
          restraint_itr_end( m_Restraints->End());
        restraint_itr != restraint_itr_end; ++restraint_itr
      )
      {
        // generate the assignment
        const restraint::AtomDistanceAssignment assignment( ( *restraint_itr)->GenerateAssignment( PROTEIN_MODEL));

        // get the score
        const double current_score( m_ScoringFunction->operator ()( assignment));

        // if the score is positive
        if( current_score >= 0.0)
        {
          // the restraint is violated so increment the counter
          ++violated_restrants;
        }

        // write the identification and score
        OSTREAM << ( *restraint_itr)->GetIdentification() << " : "
                << util::Format()( assignment.CalculateAtomDistance()) << '\t'
                << util::Format()( current_score) << '\n';
      }

      // write the # of violated restraints
      OSTREAM << "# violated : # total restraints: " << violated_restrants
              << " : " << m_Restraints->GetSize() << '\n';

      BCL_MessageDbg( "RestraintAtomDistance::WriteDetailedSchemeAndValues end");
      // end
      return OSTREAM;
    }

  } // namespace score

} // namespace bcl
