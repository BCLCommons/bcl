// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "model/bcl_model_retrieve_data_set_base.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_directory_entry.h"
#include "io/bcl_io_file.h"
#include "linal/bcl_linal_vector_reference.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace model
  {

    //! @brief Set the code / label for the feature (1st part) of the data set
    //! @param CODE the new code
    //! @return the code / label for the feature (1st part) of the data set
    void RetrieveDataSetBase::SelectFeatures( const util::ObjectDataLabel &CODE)
    {
      m_FeatureCodeLabel = CODE;
    }

    //! @brief Set the code / label for the result (2nd part) of the data set
    //! @return the code / label for the result (2nd part) of the data set
    void RetrieveDataSetBase::SelectResults( const util::ObjectDataLabel &CODE)
    {
      m_ResultCodeLabel = CODE;
    }

    //! @brief Set the code / label for the ids (3rd part) of the data set
    //! @param CODE the new code
    void RetrieveDataSetBase::SelectIds( const util::ObjectDataLabel &CODE)
    {
      m_IdCodeLabel = CODE;
    }

    //! @brief Convenience function for apps that use implementations of this interface
    //! This function checks loads the feature labels and/or columns from the given filename flag
    //! and asserts if the filename flag was not given but was needed
    //! @param FLAG flag which can contain filename of the features and/or feature indices
    void RetrieveDataSetBase::SelectFeaturesGivenFilenameFlag( const command::FlagInterface &FLAG)
    {
      if( FLAG.GetFlag() && !FLAG.GetParameterList().IsEmpty())
      {
        const std::string label_or_filename( FLAG.GetFirstParameter()->GetValue());
        if( io::DirectoryEntry( label_or_filename).DoesExist())
        {
          io::IFStream input;
          io::File::MustOpenIFStream( input, FLAG.GetFirstParameter()->GetValue());
          util::ObjectDataLabel label( input);
          this->SelectFeatures( label);
          io::File::CloseClearFStream( input);

          // data set retrievers for primary sources (like SdfFile or SdfDb)
          util::ObjectDataLabel canonicalized_label( this->GetFeatureLabelsWithSizes().GetLabel());

          // handle the case that this is a bin file generated by an older bcl, in which case the name on the label will
          // be wrong
          if( canonicalized_label.GetValue() == "Features" || label.GetValue() == "Features")
          {
            canonicalized_label = util::ObjectDataLabel( label.GetValue(), canonicalized_label.GetArguments());
          }
          // handle the case that the user enters a descriptor that is not surrounded by a Combine.  This is commonly
          // the case when the user asks for help, or where the result label is really trivial and does not need its own
          // file
          else if
          (
            canonicalized_label.GetValue() != label.GetValue()
            && canonicalized_label.GetNumberArguments() == 1
            && canonicalized_label.GetArgument( 0).GetValue() == label.GetValue()
          )
          {
            canonicalized_label = canonicalized_label.GetArgument( 0);
          }

          // check whether the feature labels are different; usually due to internal canonicalization
          if( canonicalized_label != label)
          {
            if( canonicalized_label.GetNumberArguments() == label.GetNumberArguments())
            {
              BCL_MessageCrt
              (
                "The given feature descriptors file uses default values for some descriptors. This isn't a problem for "
                "most common workflows, however, there is one exception. "
                "If you're creating a bin file, and manually selecting descriptors (e.g. deleting descriptors from the "
                "file to test their relevance when training models), then you will need to use the version of this file"
                " with the .updated postfix, which was written out for your convenience"
              );
              io::OFStream output;
              io::File::MustOpenOFStream( output, FLAG.GetFirstParameter()->GetValue() + ".updated");
              output << canonicalized_label.ToStringDefaultWidth();
              io::File::CloseClearFStream( output);
              this->SelectFeatures( canonicalized_label);
            }
            else
            {
              BCL_MessageCrt
              (
                "Bad label, canonicalized: " + canonicalized_label.ToStringDefaultWidth()
                + "; given: " + label.ToStringDefaultWidth()
              );
            }
          }
        }
        else
        {
          // look for an extension
          const size_t extension_pos( label_or_filename.rfind( '.'));
          size_t close_parens_pos( label_or_filename.rfind( ')'));
          if( close_parens_pos == std::string::npos)
          {
            close_parens_pos = 0;
          }
          // if the label looks more like an extension than a descriptor, just issue the filename error message
          if( extension_pos != std::string::npos && extension_pos >= close_parens_pos)
          {
            BCL_Exit
            (
              this->GetClassIdentifier()
              + " requires a valid file containing descriptors or a valid descriptor",
              -1
            );
          }
          std::ostringstream output_err_stream;
          util::ObjectDataLabel label;
          if( label.TryAssign( label_or_filename, output_err_stream))
          {
            this->SelectFeatures( label);
          }
          else
          {
            BCL_Exit
            (
              this->GetClassIdentifier()
              + " requires feature descriptors but was given neither a file with labels nor a parseable descriptor, error "
              "from parsing: " + output_err_stream.str(),
              -1
            );
          }
        }
      }
      else
      {
        BCL_Assert( !this->RequiresFeatureLabels(), this->GetClassIdentifier() + " requires feature labels!");
      }
    }

    //! @brief Convenience function for apps that use implementations of this interface
    //! This function checks loads the result labels and/or columns from the given filename flag
    //! and asserts if the filename flag was not given but was needed
    //! @param LABELS_ flag which can contain filename of the feature labels, if they are needed
    void RetrieveDataSetBase::SelectResultsGivenFilenameFlag( const command::FlagInterface &FLAG)
    {
      if( FLAG.GetFlag() && !FLAG.GetParameterList().IsEmpty())
      {
        const std::string label_or_filename( FLAG.GetFirstParameter()->GetValue());
        if( io::DirectoryEntry( label_or_filename).DoesExist())
        {
          io::IFStream input;
          io::File::MustOpenIFStream( input, FLAG.GetFirstParameter()->GetValue());
          util::ObjectDataLabel label( input);
          this->SelectResults( label);
          io::File::CloseClearFStream( input);

          // data set retrievers for primary sources (like SdfFile or SdfDb)
          util::ObjectDataLabel canonicalized_label( this->GetResultCodeWithSizes().GetLabel());

          // handle the case that this is a bin file generated by an older bcl, in which case the name on the label will
          // be wrong
          if( canonicalized_label.GetValue() == "Features" || label.GetValue() == "Features")
          {
            canonicalized_label = util::ObjectDataLabel( label.GetValue(), canonicalized_label.GetArguments());
          }
          // handle the case that the user enters a descriptor that is not surrounded by a Combine.  This is commonly
          // the case when the user asks for help, or where the result label is really trivial and does not need its own
          // file
          else if
          (
            canonicalized_label.GetValue() != label.GetValue()
            && canonicalized_label.GetNumberArguments() == 1
            && canonicalized_label.GetArgument( 0).GetValue() == label.GetValue()
          )
          {
            label = canonicalized_label;
          }

          // check whether the feature labels are different; usually due to internal canonicalization
          if( canonicalized_label != label)
          {
            if( canonicalized_label.GetNumberArguments() == label.GetNumberArguments())
            {
              BCL_MessageCrt
              (
                "The given results descriptors file uses default values for some descriptors. This isn't a problem for "
                "most common workflows, however, there is one exception. "
                "If you're creating a bin file, and will be manually selecting which result descriptors to train on for "
                "a model, then you will need to use the version of this file with the .updated postfix, which was "
                "written out for your convenience"
              );
              io::OFStream output;
              io::File::MustOpenOFStream( output, FLAG.GetFirstParameter()->GetValue() + ".updated");
              output << canonicalized_label.ToStringDefaultWidth();
              io::File::CloseClearFStream( output);
              this->SelectResults( canonicalized_label);
            }
            else
            {
              BCL_MessageCrt
              (
                "Bad label, canonicalized: " + canonicalized_label.ToStringDefaultWidth()
                + "; given: " + label.ToStringDefaultWidth()
              );
            }
          }
        }
        else
        {
          // look for an extension
          const size_t extension_pos( label_or_filename.rfind( '.'));
          size_t close_parens_pos( label_or_filename.rfind( ')'));
          if( close_parens_pos == std::string::npos)
          {
            close_parens_pos = 0;
          }
          // if the label looks more like an extension than a descriptor, just issue the filename error message
          if( extension_pos != std::string::npos && extension_pos >= close_parens_pos)
          {
            BCL_Exit
            (
              this->GetClassIdentifier()
              + " requires a valid file containing descriptors or a valid descriptor",
              -1
            );
          }
          std::ostringstream output_err_stream;
          util::ObjectDataLabel label;
          if( label.TryAssign( label_or_filename, output_err_stream))
          {
            this->SelectResults( label);
          }
          else
          {
            BCL_Exit
            (
              this->GetClassIdentifier()
              + " was given result descriptors flag with neither a file with labels nor a parseable descriptor, error "
              "from parsing: " + output_err_stream.str(),
              -1
            );
          }
        }
      }
      else
      {
        BCL_Assert( !this->RequiresResultLabels(), this->GetClassIdentifier() + " requires result labels!");
      }
    }

    //! @brief Convenience function for apps that use implementations of this interface
    //! This function checks loads the ids labels and/or columns from the given filename flag
    //! and asserts if the filename flag was not given but was needed
    //! @param FLAG which can contain filename of the id labels, if they are needed
    void RetrieveDataSetBase::SelectIdsGivenFilenameFlag( const command::FlagInterface &FLAG)
    {
      if( FLAG.GetFlag() && !FLAG.GetParameterList().IsEmpty())
      {
        const std::string label_or_filename( FLAG.GetFirstParameter()->GetValue());
        if( io::DirectoryEntry( label_or_filename).DoesExist())
        {
          io::IFStream input;
          io::File::MustOpenIFStream( input, FLAG.GetFirstParameter()->GetValue());
          util::ObjectDataLabel label( input);
          this->SelectIds( label);
          io::File::CloseClearFStream( input);

          // data set retrievers for primary sources (like SdfFile or SdfDb)
          util::ObjectDataLabel canonicalized_label( this->GetIdCodeWithSizes().GetLabel());

          // handle the case that this is a bin file generated by an older bcl, in which case the name on the label will
          // be wrong
          if( canonicalized_label.GetValue() == "Features" || label.GetValue() == "Features")
          {
            canonicalized_label = util::ObjectDataLabel( label.GetValue(), canonicalized_label.GetArguments());
          }
          // handle the case that the user enters a descriptor that is not surrounded by a Combine.  This is commonly
          // the case when the user asks for help, or where the result label is really trivial and does not need its own
          // file
          else if
          (
            canonicalized_label.GetValue() != label.GetValue()
            && canonicalized_label.GetNumberArguments() == 1
            && canonicalized_label.GetArgument( 0).GetValue() == label.GetValue()
          )
          {
            canonicalized_label = canonicalized_label.GetArgument( 0);
          }

          // check whether the feature labels are different; usually due to internal canonicalization
          if( canonicalized_label != label)
          {
            if( canonicalized_label.GetNumberArguments() == label.GetNumberArguments())
            {
              BCL_MessageCrt
              (
                "The given ids descriptor file used default values for some descriptors. This isn't a problem for "
                "most common workflows, however, there is one exception. "
                "If you're creating a bin file, and will be manually changing the id descriptors for use in the "
                "-id_labels flag on any application, then you will need to use the version of this file with the "
                ".updated postfix, which was written out for your convenience. Applications will generally load all ids"
                " given in the bin file unless told otherwise, so this should not be necessary except when some of the "
                "ids are not desired"
              );
              io::OFStream output;
              io::File::MustOpenOFStream( output, FLAG.GetFirstParameter()->GetValue() + ".updated");
              output << canonicalized_label.ToStringDefaultWidth();
              io::File::CloseClearFStream( output);
              this->SelectIds( canonicalized_label);
            }
            else
            {
              BCL_MessageCrt
              (
                "Bad label, canonicalized: " + canonicalized_label.ToStringDefaultWidth()
                + "; given: " + label.ToStringDefaultWidth()
              );
            }
          }
        }
        else
        {
          // look for an extension
          const size_t extension_pos( label_or_filename.rfind( '.'));
          size_t close_parens_pos( label_or_filename.rfind( ')'));
          if( close_parens_pos == std::string::npos)
          {
            close_parens_pos = 0;
          }
          // if the label looks more like an extension than a descriptor, just issue the filename error message
          if( extension_pos != std::string::npos && extension_pos >= close_parens_pos)
          {
            BCL_Exit
            (
              this->GetClassIdentifier()
              + " was given id labels flag but was not given a valid file containing descriptors or a valid descriptor",
              -1
            );
          }
          std::ostringstream output_err_stream;
          util::ObjectDataLabel label;
          if( label.TryAssign( label_or_filename, output_err_stream))
          {
            this->SelectIds( label);
          }
          else
          {
            BCL_Exit
            (
              this->GetClassIdentifier()
              + " was given id descriptors flag with neither a file with labels nor a parseable descriptor, error "
              "from parsing: " + output_err_stream.str(),
              -1
            );
          }
        }
      }
    }

    //! @brief Set the code / label for the feature (1st part) of the data set
    //! @return the code / label for the feature (1st part) of the data set
    const util::ObjectDataLabel &RetrieveDataSetBase::GetFeatureCode() const
    {
      return m_FeatureCodeLabel;
    }

    //! @brief Set the code / label for the result (2nd part) of the data set
    //! @return the code / label for the result (2nd part) of the data set
    const util::ObjectDataLabel &RetrieveDataSetBase::GetResultCode() const
    {
      return m_ResultCodeLabel;
    }

    //! @brief Get the code / label for the ids (3rd part) of the data set
    //! @return the code / label for the ids (3rd part) of the data set
    const util::ObjectDataLabel &RetrieveDataSetBase::GetIdCode() const
    {
      return m_IdCodeLabel;
    }

    //! @brief determine the start and end index position given the size, the range id and the number of ranges
    //! @param RANGE_OF_IDS range of range ids
    //! @param NUMBER_RANGES number of total ranges
    //! @param TOTAL_SIZE_OF_DATASET total size of dataset
    //! @return range with start and end position
    math::Range< size_t> RetrieveDataSetBase::GetStartEndPositionOfRange
    (
      const math::Range< size_t> RANGE_OF_IDS,
      const size_t NUMBER_RANGES,
      const size_t TOTAL_SIZE_OF_DATASET
    )
    {
      math::Range< size_t> closed_range( RANGE_OF_IDS.CloseBorders());
      BCL_MessageDbg
      (
        "Param: RANGES: " + closed_range.GetString()
        + " NUMBER_RANGES: " + util::Format()( NUMBER_RANGES)
        + " TOTAL_SIZE_OF_DATASET: " + util::Format()( TOTAL_SIZE_OF_DATASET)
      );

      BCL_Assert( NUMBER_RANGES > 0, "Must have at least one range");

      BCL_Assert
      (
        closed_range.GetMax() < NUMBER_RANGES,
        "range given to GetStartEndPositionOfRange is larger or equal then the number of ranges!"
      );

      // size of range
      const size_t min_size_of_range( TOTAL_SIZE_OF_DATASET / NUMBER_RANGES);
      const size_t number_ranges_with_max_size( TOTAL_SIZE_OF_DATASET % NUMBER_RANGES);

      // range start
      const size_t range_start
      (
        closed_range.GetMin() * min_size_of_range
        + std::min( closed_range.GetMin(), number_ranges_with_max_size)
      );
      // range end
      const size_t range_end
      (
        ( closed_range.GetMax() + 1) * min_size_of_range
        + std::min( ( closed_range.GetMax() + 1), number_ranges_with_max_size)
      );

      // return start and end position of range
      return math::Range< size_t>
             (
               math::RangeBorders::e_LeftClosed,
               range_start,
               range_end,
               math::RangeBorders::e_RightOpen
             );
    }

    //! @brief load a range of data from the dataset
    //! @param SUBSET the range of data to load
    //! @param FEATURES_STORAGE where to store features that are loaded
    //! @param RESULTS_STORAGE where to store the corresponding results
    //! @param IDS_STORAGE wehre to put the corresponding ids
    //! @param START_FEATURE_NUMBER position to store the first feature in FEATURES_STORAGE
    //! @return # of features actually loaded
    //! Note: Implementations should overload this and SupportsEfficientSubsetLoading together
    size_t RetrieveDataSetBase::GenerateDataSubset
    (
      const math::Range< size_t> &SUBSET,
      linal::MatrixInterface< float> &FEATURES_STORAGE,
      linal::MatrixInterface< float> &RESULTS_STORAGE,
      linal::MatrixInterface< char> &IDS_STORAGE,
      const size_t &START_FEATURE_NUMBER
    )
    {
      // ensure that features and results are the same size
      BCL_Assert
      (
        FEATURES_STORAGE.GetNumberRows() == RESULTS_STORAGE.GetNumberRows(),
        "Different number of features and results"
      );
      BCL_Assert
      (
        FEATURES_STORAGE.GetNumberRows() == IDS_STORAGE.GetNumberRows() || IDS_STORAGE.GetNumberRows() == size_t( 0),
        "Different number of features and ids"
      );

      // ensure that the start position is within the storage matrix
      BCL_Assert
      (
        START_FEATURE_NUMBER <= FEATURES_STORAGE.GetNumberRows(),
        "start feature was higher than storage"
      );

      // standardize the range, so the left side of it has a closed border and the right has an open border
      const math::Range< size_t> standard_subset( SUBSET.StandardizeRange());

      // ensure that the end position is within the storage matrix
      BCL_Assert
      (
        START_FEATURE_NUMBER + standard_subset.GetWidth() <= FEATURES_STORAGE.GetNumberRows(),
        "Storage was too small to contain entire subset"
      );

      // this is the naive implementation, only used if the data set retriever does not provide a better way
      util::ShPtr< descriptor::Dataset> dataset( GenerateDataSet());

      // determine the end feature # for the copy
      const size_t end_chosen_features
      (
        std::max( standard_subset.GetMin(), std::min( standard_subset.GetMax(), dataset->GetSize()))
      );

      // select the desired elements
      std::copy
      (
        dataset->GetFeaturesReference()[ standard_subset.GetMin()],
        dataset->GetFeaturesReference()[ end_chosen_features],
        FEATURES_STORAGE[ START_FEATURE_NUMBER]
      );

      std::copy
      (
        dataset->GetResultsReference()[ standard_subset.GetMin()],
        dataset->GetResultsReference()[ end_chosen_features],
        RESULTS_STORAGE[ START_FEATURE_NUMBER]
      );
      std::copy
      (
        dataset->GetIdsReference()[ standard_subset.GetMin()],
        dataset->GetIdsReference()[ end_chosen_features],
        IDS_STORAGE[ START_FEATURE_NUMBER]
      );

      return end_chosen_features - standard_subset.GetMin();
    }

    //! @brief get the size of the dataset resulting from a selected range of chunks of a dataset with a given size
    //! @param RANGES_OF_IDS range of range ids
    //! @param NUMBER_RANGES number of total ranges
    //! @param TOTAL_SIZE_OF_DATASET total size of dataset
    //! @return the size of the dataset resulting from a selected range of chunks of a dataset with a given size
    size_t RetrieveDataSetBase::GetSubsetSize
    (
      const math::RangeSet< size_t> RANGES_OF_IDS,
      const size_t NUMBER_RANGES,
      const size_t TOTAL_SIZE_OF_DATASET
    )
    {
      // if there are no ranges, then return the total size
      if( RANGES_OF_IDS.IsEmpty())
      {
        return TOTAL_SIZE_OF_DATASET;
      }

      size_t size_so_far( 0);
      // add up the sizes for each range in the rangeset
      for
      (
        storage::Set< math::Range< size_t> >::const_iterator
          itr( RANGES_OF_IDS.GetRanges().Begin()), itr_end( RANGES_OF_IDS.GetRanges().End());
        itr != itr_end;
        ++itr
      )
      {
        size_so_far += GetStartEndPositionOfRange( *itr, NUMBER_RANGES, TOTAL_SIZE_OF_DATASET).GetWidth();
      }

      return size_so_far;
    }

  } // namespace model
} // namespace bcl
