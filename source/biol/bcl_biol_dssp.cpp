// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// This code is adapted from Pteros; see http://pteros.sourceforge.net/dssp_8h_source.html
// Pteros' copyright, applies solely to this file:
// Portions Copyright Maarten L. Hekkelman, Radboud University 2008-2011.
//   Distributed under the Boost Software License, Version 1.0.
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "biol/bcl_biol_dssp.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_aa_back_bone_completer.h"
#include "biol/bcl_biol_atom.h"
#include "math/bcl_math_mutate_result.h"
#include "sspred/bcl_sspred_pdb.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace biol
  {

    //! @brief compare bridge by chainid and seqid of residues in bridge
    //! @param BRIDGE bridge to comparet his to
    //! @return true if this bridge comes before the argument BRIDGE in sequence
    bool DSSP::Bridge::operator<( const Bridge &BRIDGE) const
    {
      return m_ChainI < BRIDGE.m_ChainI || ( m_ChainI == BRIDGE.m_ChainI && m_I.front()->GetSeqID() < BRIDGE.m_I.front()->GetSeqID());
    }

    //! @brief constructor from members
    DSSP::BridgePartner::BridgePartner() :
      m_Partner(),
      m_Ladder(),
      m_Parallel()
    {
    }

    //! @brief constructor from members
    DSSP::BridgePartner::BridgePartner( const util::SiPtr< const AABase> &PARTNER, const size_t LADDER, const bool PARALLEL) :
      m_Partner( PARTNER),
      m_Ladder( LADDER),
      m_Parallel( PARALLEL)
    {
    }

  //////////
  // data //
  //////////

    //! @brief default max HBond energy for an HBond to be considered
    //! @return default max energy
    const double &DSSP::GetDefaultHBondMaxEnergy()
    {
      static const double s_max_hydrogen_bond_energy( -0.45);
      return s_max_hydrogen_bond_energy;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @param MAX_HYDROGEN_BOND_ENERGY maximal hydrogen bond energy to be considered an H-bond
    DSSP::DSSP( const double MAX_HYDROGEN_BOND_ENERGY) :
      m_MaxHydrogenBondEnergy( MAX_HYDROGEN_BOND_ENERGY),
      m_NrOfHydrogenBondsInParallelBridges( 0),
      m_NrOfHydrogenBondsInAntiparallelBridges( 0)
    {
      Reset();
    }

    //! @brief Clone function
    //! @return pointer to new DSSP
    DSSP *DSSP::Clone() const
    {
      return new DSSP( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DSSP::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &DSSP::GetScheme() const
    {
      static const std::string s_scheme( "dssp");
      return s_scheme;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief get various statistics
    void DSSP::GetStatistics
    (
      size_t &NR_OF_RESIDUES,
      size_t &NR_OF_CHAINS,
      size_t &NR_OF_SS_BRIDGES,
      size_t &NR_OF_INTRA_CHAIN_SS_BRIDGES,
      size_t &NR_OF_HYDROGEN_BONDS,
      size_t NR_OF_HYDROGEN_BONDS_PER_DISTANCE[ s_HistogramSize],
      size_t NR_RES_PER_ALPHA_HELIX_HISTOGRAM[ s_HistogramSize]
    ) const
    {
      const double max_hydrogen_bond_energy( -0.5);
      NR_OF_RESIDUES = m_SecondaryStructure.size();
      NR_OF_CHAINS   = 0;
      NR_OF_SS_BRIDGES = 0;
      NR_OF_INTRA_CHAIN_SS_BRIDGES = 0;
      NR_OF_HYDROGEN_BONDS = 0;
      std::fill_n( NR_OF_HYDROGEN_BONDS_PER_DISTANCE, 11, 0.0);

      for
      (
        HydrogenBondContainerType::const_iterator
          itr( m_HydrogenBondAcceptor.Begin()), itr_end( m_HydrogenBondAcceptor.End());
        itr != itr_end;
        ++itr
      )
      {
        if( itr->second.First().Second() < max_hydrogen_bond_energy)
        {
          ++NR_OF_HYDROGEN_BONDS;
          const int seq_sep( itr->first->GetSeqID() - itr->second.First().First()->GetSeqID());
          if( seq_sep >= -5 && seq_sep <= 5 && itr->first->GetChainID() == itr->second.First().First()->GetChainID())
          {
            ++NR_OF_HYDROGEN_BONDS_PER_DISTANCE[ seq_sep + 5];
          }
        }
      }

      // iterate through chains
      std::fill_n( NR_RES_PER_ALPHA_HELIX_HISTOGRAM, s_HistogramSize, 0);
      for
      (
        assemble::ProteinModel::const_iterator chain_itr( m_Model->GetChains().Begin()), chain_itr_end( m_Model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        size_t helix_length( 0);
        const util::SiPtrVector< const AABase> res( ( *chain_itr)->GetAminoAcids());
        for
        (
          util::SiPtrVector< const AABase>::const_iterator aa_itr( res.Begin()), aa_itr_end( res.End());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          if( m_SecondaryStructure.find( *aa_itr)->second == e_Alphahelix)
          {
            ++helix_length;
          }
          else if( helix_length > 0)
          {
            helix_length = std::min( helix_length, size_t( s_HistogramSize));
            NR_RES_PER_ALPHA_HELIX_HISTOGRAM[ helix_length - 1] += 1;
            helix_length = 0;
          }
        }
      }
    }

    //! @brief reset all members
    void DSSP::Reset() const
    {
      m_Model = util::ShPtr< assemble::ProteinModel>();

      m_HydrogenBondDonor.Reset();
      m_HydrogenBondAcceptor.Reset();

      m_BridgePartner.Reset();

      m_Sheet.Reset();

      m_SecondaryStructure.clear();

      for( size_t stride( 3); stride <= 5; ++stride)
      {
        m_HelixFlag[ stride - 3].clear();
      }

      m_Bend.Reset();

      m_Alpha.clear();

      m_Kappa.clear();
      m_Phi.clear();
      m_Psi.clear();
      m_TCO.clear();

      m_NrOfHydrogenBondsInParallelBridges = 0;
      m_NrOfHydrogenBondsInAntiparallelBridges = 0;
      std::fill_n( m_ParallelBridgesPerLadderHistogram, s_HistogramSize, 0);
      std::fill_n( m_AntiparallelBridgesPerLadderHistogram, s_HistogramSize, 0);
      std::fill_n( m_LaddersPerSheetHistogram, s_HistogramSize, 0);
    }

    //! @brief Set PDB SS Predictions using the DSSP algorithm
    //! @param PROTEIN_MODEL the protein model with sses (can be just one single loop)
    void DSSP::SetPDBSSPred( assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // construct a new model with the dssp algorithm
      util::ShPtr< assemble::ProteinModel> sp_dssp_model( operator()( PROTEIN_MODEL).GetArgument());

      // iterate through the chains
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()),
          dssp_chain_itr( sp_dssp_model->GetChains().Begin()),
          chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr, ++dssp_chain_itr
      )
      {
        // get all the sses from the dssp-fixed chain
        util::SiPtrVector< const assemble::SSE> dssp_sses( ( *dssp_chain_itr)->GetSSEs());

        // make a map from AASeqID to dssp-related SSType
        storage::Map< int, SSType> seq_id_to_dssp_type;
        for
        (
          util::SiPtrVector< const assemble::SSE>::const_iterator
            sse_itr( dssp_sses.Begin()), sse_itr_end( dssp_sses.End());
          sse_itr != sse_itr_end;
          ++sse_itr
        )
        {
          const assemble::SSE &dssp_sse( **sse_itr);
          // get the type of this sse
          SSType ss_type( dssp_sse.GetType());
          // get start and finish

          for
          (
            int seq_id( dssp_sse.GetFirstAA()->GetSeqID()), end_seq_id( dssp_sse.GetLastAA()->GetSeqID() + 1);
            seq_id < end_seq_id;
            ++seq_id
          )
          {
            seq_id_to_dssp_type[ seq_id] = ss_type;
          }
        }

        // iterate through the sequence
        for
        (
          AASequence::const_iterator
            aa_itr( ( *chain_itr)->GetSequence()->Begin()),
            aa_itr_end( ( *chain_itr)->GetSequence()->End());
          aa_itr != aa_itr_end; ++aa_itr
        )
        {
          // create a pointer to the data
          util::ShPtr< AABase> sp_aa( *aa_itr);
          const util::SiPtr< const sspred::MethodInterface> sp_aa_ss_pdb( sp_aa->GetSSPrediction( sspred::GetMethods().e_PDB));
          SSType existing_ss_type( GetSSTypes().COIL), ss_type( GetSSTypes().COIL);
          EnvironmentType existing_environment( GetEnvironmentTypes().e_Solution);
          if( !sp_aa_ss_pdb.IsDefined())
          {
            BCL_MessageCrt
            (
              "Warning: AA with id: " + sp_aa->GetIdentification() + " had no secondary structure from the pdb file, "
              "setting it to type coil"
            );
          }
          else
          {
            existing_ss_type = sp_aa_ss_pdb->GetOneStateSSPrediction();
            existing_environment = sp_aa_ss_pdb->GetOneStateTMPrediction();
          }

          // look for this seq id in the map
          storage::Map< int, SSType>::const_iterator itr_type_map( seq_id_to_dssp_type.Find( sp_aa->GetSeqID()));
          if( itr_type_map == seq_id_to_dssp_type.End())
          {
            // no type, set it to coil
            ss_type = GetSSTypes().COIL;
          }
          else
          {
            ss_type = itr_type_map->second;
          }
          if( existing_ss_type != ss_type)
          {
            // update the secondary structure prediction for the AA
            sp_aa->SetSSPrediction( sspred::GetMethods().e_PDB, sspred::PDB( ss_type, existing_environment));
          }
        }
      }
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that uses the coordinates of the secondary structure elements within them to generate a new
    //!        new secondary structure assignment using DSSP
    //! @param PROTEIN_MODEL the protein model with sses (can be just one single loop)
    //! @return a mutate result with a protein model that has new secondary structure elements based on dssp
    math::MutateResult< assemble::ProteinModel> DSSP::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      Reset();
      AABackBoneCompleter completer( true, false, false);
      m_Model = completer.CompleteProteinModel( PROTEIN_MODEL);

      CalculateHydrogenBondEnergies();
      CalculateBetaSheets();
      CalculateAlphaHelices();

      util::ShPtrVector< assemble::Chain> new_chains;

      for
      (
        assemble::ProteinModel::const_iterator chain_itr( m_Model->GetChains().Begin()), chain_itr_end( m_Model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        util::ShPtr< assemble::Chain> sp_chain( new assemble::Chain( ( *chain_itr)->GetSequence()));

        const util::SiPtrVector< const AABase> res( ( *chain_itr)->GetAminoAcids());

        util::ShPtrVector< AABase> new_aas;
        SSType last_ss_type( GetSSTypes().COIL);

        int last_seq_id( 0);

        for
        (
          util::SiPtrVector< const AABase>::const_iterator aa_itr( res.Begin()), aa_itr_end( res.End());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          const SecondaryStructureType ss_type( m_SecondaryStructure.find( *aa_itr)->second);
          SSType new_ss_type( GetSSTypes().COIL);
          switch( ss_type)
          {
            case e_Loop:       new_ss_type = GetSSTypes().COIL; break;
            case e_Alphahelix: new_ss_type = GetSSTypes().HELIX; break;
            case e_Helix_3:    new_ss_type = GetSSTypes().e_HelixRight310; break;
            case e_Helix_5:    new_ss_type = GetSSTypes().e_HelixRightPi; break;
            case e_Strand:     new_ss_type = GetSSTypes().STRAND; break;
            default:           new_ss_type = GetSSTypes().COIL; break;
          }
          if
          (
               ( new_ss_type == last_ss_type && last_seq_id + 1 == ( *aa_itr)->GetSeqID())
            || new_aas.IsEmpty()
          )
          {
            new_aas.PushBack( util::ShPtr< AABase>( ( *aa_itr)->Clone()));
          }
          else
          {
            util::ShPtr< assemble::SSE> sp_new_sse( new assemble::SSE( AASequence( new_aas, sp_chain->GetChainID()), last_ss_type));
            sp_chain->Insert( sp_new_sse);
            new_aas.Reset();
            new_aas.PushBack( util::ShPtr< AABase>( ( *aa_itr)->Clone()));
          }

          last_ss_type = new_ss_type;
          last_seq_id = ( *aa_itr)->GetSeqID();
        } // amino acids

        if( !new_aas.IsEmpty())
        {
          util::ShPtr< assemble::SSE> sp_new_sse( new assemble::SSE( AASequence( new_aas, sp_chain->GetChainID()), last_ss_type));
          sp_chain->Insert( sp_new_sse);
        }

        new_chains.PushBack( sp_chain);
      } // chains

      util::ShPtr< assemble::ProteinModel> sp_new_model( new assemble::ProteinModel( new_chains));

      return math::MutateResult< assemble::ProteinModel>( sp_new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to file in standard DSSP format
    //! @param OSTREAM stream to write to
    //! @return the ostream written to
    std::ostream &DSSP::WriteToFile( std::ostream &OSTREAM) const
    {
      OSTREAM << "==== Secondary Structure Definition by the program DSSP, BCL version ==== \n";

      size_t nr_of_residues;
      size_t nr_of_chains;
      size_t nr_of_ss_bridges;
      size_t nr_of_intra_chain_ss_bridges;
      size_t nr_of_hydrogen_bonds;
      size_t nr_of_hydrogen_bonds_per_distance[ 11] = {};

      size_t nr_res_per_alpha_helix_histogram[ s_HistogramSize];
      GetStatistics
      (
        nr_of_residues,
        nr_of_chains,
        nr_of_ss_bridges,
        nr_of_intra_chain_ss_bridges,
        nr_of_hydrogen_bonds,
        nr_of_hydrogen_bonds_per_distance,
        nr_res_per_alpha_helix_histogram
      );

      OSTREAM << "REFERENCE W. KABSCH AND C.SANDER, BIOPOLYMERS 22 (1983) 2577-2637\n";

      const util::Format count_format( util::Format().W( 3).Fill( ' ').R());
      const util::Format per100_format( util::Format().W( 5).Fill( ' ').R().FFP( 1));

      OSTREAM << "  " << count_format( nr_of_residues)
              << count_format( nr_of_chains)
              << count_format( nr_of_ss_bridges)
              << count_format( nr_of_intra_chain_ss_bridges)
              << count_format( nr_of_ss_bridges - nr_of_intra_chain_ss_bridges)
              << "   TOTAL NUMBER OF RESIDUES, NUMBER OF CHAINS, NUMBER OF SS-BRIDGES(TOTAL,INTRACHAIN,INTERCHAIN)\n";

      // hydrogenbond summary
      OSTREAM << "  " << count_format( nr_of_hydrogen_bonds)
              << per100_format( nr_of_hydrogen_bonds * 100.0 / nr_of_residues)
              << "   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(J)  , SAME NUMBER PER 100 RESIDUES\n";

      OSTREAM << "  " << count_format( m_NrOfHydrogenBondsInParallelBridges)
              << per100_format( m_NrOfHydrogenBondsInParallelBridges * 100.0 / nr_of_residues)
              << "   TOTAL NUMBER OF HYDROGEN BONDS IN     PARALLEL BRIDGES, SAME NUMBER PER 100 RESIDUES\n";

      OSTREAM << "  " << count_format( m_NrOfHydrogenBondsInAntiparallelBridges)
              << per100_format( m_NrOfHydrogenBondsInAntiparallelBridges * 100.0 / nr_of_residues)
              << "   TOTAL NUMBER OF HYDROGEN BONDS IN ANTIPARALLEL BRIDGES, SAME NUMBER PER 100 RESIDUES\n";

      for( int k( -5); k <= 5; ++k)
      {
        OSTREAM << "  " << count_format( nr_of_hydrogen_bonds_per_distance[ k + 5])
                << per100_format( nr_of_hydrogen_bonds_per_distance[ k + 5] * 100.0 / nr_of_residues)
                << "   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I" << k << "), SAME NUMBER PER 100 RESIDUES5\n";
      }

      // histograms...
      for( size_t i( 1); i <= s_HistogramSize; ++i)
      {
        OSTREAM << count_format( i);
      }
      OSTREAM << "    *** HISTOGRAMS OF ***\n";

      for( size_t i( 0); i < s_HistogramSize; ++i)
      {
        OSTREAM << count_format( nr_res_per_alpha_helix_histogram[ i]);
      }
      OSTREAM << "    RESIDUES PER ALPHA HELIX\n";

      for( size_t i( 0); i < s_HistogramSize; ++i)
      {
        OSTREAM << count_format( m_ParallelBridgesPerLadderHistogram[ i]);
      }
      OSTREAM << "    PARALLEL BRIDGES PER LADDER\n";

      for( size_t i( 0); i < s_HistogramSize; ++i)
      {
        OSTREAM << count_format( m_AntiparallelBridgesPerLadderHistogram[ i]);
      }
      OSTREAM << "    ANTIPARALLEL BRIDGES PER LADDER\n";

      for( size_t i( 0); i < s_HistogramSize; ++i)
      {
        OSTREAM << count_format( m_LaddersPerSheetHistogram[ i]);
      }
      OSTREAM << "    LADDERS PER SHEET\n";

      // per residue information

      OSTREAM << "  #  RESIDUE AA STRUCTURE BP1 BP2  ACC     N-H-->O    O-->H-N    N-H-->O    O-->H-N    TCO  KAPPA ALPHA  PHI   PSI    X-CA   Y-CA   Z-CA\n";

      // iterate through chains
      for
      (
        assemble::ProteinModel::const_iterator chain_itr( m_Model->GetChains().Begin()), chain_itr_end( m_Model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        const util::SiPtrVector< const AABase> res( ( *chain_itr)->GetAminoAcids());
        for
        (
          util::SiPtrVector< const AABase>::const_iterator aa_itr( res.Begin()), aa_itr_end( res.End());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          WriteResidue( *aa_itr, OSTREAM);
        }
      }

      return OSTREAM;
    }

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DSSP::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DSSP::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

    //! @brief write information for a single residue
    //! @param SP_AMINO_ACID SiPtr to amino acid residue
    //! @param OSTREAM stream to write to
    //! @return the stream written to
    std::ostream &DSSP::WriteResidue( const util::SiPtr< const AABase> &SP_AMINO_ACID, std::ostream &OSTREAM) const
    {
      const Atom &ca( SP_AMINO_ACID->GetAtom( GetAtomTypes().CA));
      const char code( SP_AMINO_ACID->GetType()->GetOneLetterCode());
      char ss( ' ');
      switch( m_SecondaryStructure.find( SP_AMINO_ACID)->second)
      {
        case e_Alphahelix: ss = 'H'; break;
        case e_Betabridge: ss = 'B'; break;
        case e_Strand    : ss = 'E'; break;
        case e_Helix_3   : ss = 'G'; break;
        case e_Helix_5   : ss = 'I'; break;
        case e_Turn      : ss = 'T'; break;
        case e_Bend      : ss = 'S'; break;
        case e_Loop      : ss = ' '; break;
      }

      char helix[ 3];
      for( size_t stride = 3; stride <= 5; ++stride)
      {
        switch( m_HelixFlag[ stride - 3].find( SP_AMINO_ACID)->second)
        {
          case e_HelixNone:        helix[ stride - 3] = ' '; break;
          case e_HelixStart:       helix[ stride - 3] = '>'; break;
          case e_HelixEnd:         helix[ stride - 3] = '<'; break;
          case e_HelixStartAndEnd: helix[ stride - 3] = 'X'; break;
          case e_HelixMiddle:      helix[ stride - 3] = '0' + stride; break;
        }
      }

      const char bend( m_Bend.Contains( SP_AMINO_ACID) ? 'S' : ' ');

      std::pair< double, char> alpha_chirality( 360, ' ');
      if( m_Alpha.find( SP_AMINO_ACID) != m_Alpha.end())
      {
        alpha_chirality = m_Alpha.find( SP_AMINO_ACID)->second;
      }
//      tr1::tie(alpha,chirality) = residue.Alpha();

      size_t bp[ 2] = {};
      char bridgelabel[ 2] = { ' ', ' '};
      for( size_t i( 0); i < 2; ++i)
      {
        const BridgePartner &p( m_BridgePartner.Find( SP_AMINO_ACID)->second( i));
        if( p.m_Partner.IsDefined())
        {
          bp[ i] = p.m_Partner->GetSeqID();
          bp[ i] %= 10000; // won't fit otherwise...
          bridgelabel[ i] = 'A' + p.m_Ladder % 26;
          if( p.m_Parallel)
          {
            bridgelabel[ i] = tolower( bridgelabel[ i]);
          }
        }
      }

      char sheet = ' ';
      if( m_Sheet.Find( SP_AMINO_ACID)->second != 0)
      {
        sheet = 'A' + ( m_Sheet.Find( SP_AMINO_ACID)->second - 1) % 26;
      }

      std::string NHO[ 2], ONH[ 2];
      const storage::VectorND< 2, storage::Pair< util::SiPtr< const AABase>, double> > &acceptors( m_HydrogenBondAcceptor.Find( SP_AMINO_ACID)->second);
      const storage::VectorND< 2, storage::Pair< util::SiPtr< const AABase>, double> > &donors( m_HydrogenBondDonor.Find( SP_AMINO_ACID)->second);
      for( size_t i( 0); i < 2; ++i)
      {
        NHO[ i] = ONH[ i] = "     0, 0.0";

        if( acceptors( i).First().IsDefined())
        {
          const int d( acceptors( i).First()->GetSeqID() - SP_AMINO_ACID->GetSeqID());
          NHO[ i] = util::Format().W( 6).Fill( ' ')( d) + ',' + util::Format().W( 4).FFP( 1)( acceptors( i).Second());
        }

        if( donors( i).First().IsDefined())
        {
          const int d( donors( i).First()->GetSeqID() - SP_AMINO_ACID->GetSeqID());
          ONH[ i] = util::Format().W( 6).Fill( ' ')( d) + ',' + util::Format().W( 4).FFP( 1)( donors( i).Second());
        }
      }

      double kappa( 360);
      if( m_Kappa.find( SP_AMINO_ACID) != m_Kappa.end())
      {
        kappa = m_Kappa.find( SP_AMINO_ACID)->second;
      }

      double phi( 360);
      double psi( 360);
      if( m_Phi.find( SP_AMINO_ACID) != m_Phi.end())
      {
        phi = m_Phi.find( SP_AMINO_ACID)->second;
      }
      if( m_Psi.find( SP_AMINO_ACID) != m_Psi.end())
      {
        psi = m_Psi.find( SP_AMINO_ACID)->second;
      }
      double tco( 0);
      if( m_TCO.find( SP_AMINO_ACID) != m_TCO.end())
      {
        tco = m_TCO.find( SP_AMINO_ACID)->second;
      }

      const util::Format seq_nr_format( util::Format().W( 5).Fill( ' ').R());
      const util::Format bridge_partner_format( util::Format().W( 4).Fill( ' ').R());
      const util::Format coord_format( util::Format().W( 7).Fill( ' ').R().FFP( 1));
      const util::Format angle_format( util::Format().W( 6).Fill( ' ').R().FFP( 1));
      const util::Format tco_format( util::Format().W( 8).Fill( ' ').R().FFP( 3));
      const util::Format acc_format( util::Format().W( 5).Fill( ' ').R());

      OSTREAM << seq_nr_format( SP_AMINO_ACID->GetSeqID())
              << seq_nr_format( SP_AMINO_ACID->GetPdbID())
              << SP_AMINO_ACID->GetPdbICode()
              << SP_AMINO_ACID->GetChainID() << ' '
              << code << "  "
              << ss << ' '
              << helix[ 0] << helix[ 1] << helix[ 2]
              << bend << alpha_chirality.second
              << bridgelabel[ 0] << bridgelabel[ 1]
              << bridge_partner_format( bp[ 0]) << bridge_partner_format( bp[ 1])
              << sheet
              << acc_format( 0)
              << NHO[ 0]
              << ONH[ 0]
              << NHO[ 1]
              << ONH[ 1]
              << tco_format( tco)
              << angle_format( kappa)
              << angle_format( alpha_chirality.first)
              << angle_format( phi)
              << angle_format( psi)
              << coord_format( ca.GetCoordinates().X())
              << coord_format( ca.GetCoordinates().Y())
              << coord_format( ca.GetCoordinates().Z())
              << '\n';

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculate all pairwise hydrogen bonding terms
    void DSSP::CalculateHydrogenBondEnergies() const
    {
      const double minimal_ca_distance( 9.0);
      BCL_MessageDbg( "calculate hbond energies");

      const util::SiPtrVector< const AABase> amino_acids( m_Model->GetAminoAcids());

      for( util::SiPtrVector< const AABase>::const_iterator itr_a( amino_acids.Begin()), itr_end( amino_acids.End()); itr_a != itr_end; ++itr_a)
      {
        for( size_t stride( 3); stride <= 5; ++stride)
        {
          m_HelixFlag[ stride - 3][ *itr_a] = e_HelixNone;
        }
        m_BridgePartner[ *itr_a];
        m_SecondaryStructure[ *itr_a] = e_Loop;
        m_Sheet[ *itr_a] = 0;

        for( util::SiPtrVector< const AABase>::const_iterator itr_b( itr_a + 1); itr_b != itr_end; ++itr_b)
        {
          if( Distance( ( *itr_a)->GetAtom( GetAtomTypes().CA), ( *itr_b)->GetAtom( GetAtomTypes().CA)) >= minimal_ca_distance)
          {
            continue;
          }
          CalculateHydrogenBondEnergy( **itr_a, **itr_b);
          if( ( *itr_b)->GetSeqID() != ( *itr_a)->GetSeqID() + 1)
          {
            CalculateHydrogenBondEnergy( **itr_b, **itr_a);
          }
        }

        util::SiPtrVector< const AABase>::const_iterator itr_prev( itr_a);
        util::SiPtrVector< const AABase>::const_iterator itr_current( itr_a + 1);
        if( itr_current == itr_end)
        {
          continue;
        }
        const double phi( ( *itr_current)->CalculatePhi( ( *itr_prev)->GetAtom( GetAtomTypes().C)));
        m_Phi[ *itr_current] = math::Angle::Degree( phi);
        const double psi( ( *itr_prev)->CalculatePsi( ( *itr_current)->GetAtom( GetAtomTypes().N)));
        m_Psi[ *itr_prev] = math::Angle::Degree( psi);

        const double tco
        (
          linal::ProjAngleCosinus
          (
            ( *itr_current)->GetAtom( GetAtomTypes().O).GetCoordinates(),
            ( *itr_current)->GetAtom( GetAtomTypes().C).GetCoordinates(),
            ( *itr_prev)->GetAtom( GetAtomTypes().O).GetCoordinates(),
            ( *itr_prev)->GetAtom( GetAtomTypes().C).GetCoordinates()
          )
        );
        m_TCO[ *itr_current] = tco;

        util::SiPtrVector< const AABase>::const_iterator itr_next( itr_a + 2);
        if( itr_next == itr_end)
        {
          continue;
        }

        util::SiPtrVector< const AABase>::const_iterator itr_next_next( itr_a + 3);
        if( itr_next_next == itr_end)
        {
          continue;
        }

        CalculateAlpha( **itr_prev, **itr_current, **itr_next, **itr_next_next);
      }
    }

    //! @brief using all hydrogen bonds, determine all beta sheets
    void DSSP::CalculateBetaSheets() const
    {
      BCL_MessageDbg( "Calculate beta sheets");
      const util::SiPtrVector< const AABase> amino_acids( m_Model->GetAminoAcids());

      // Calculate Bridges
      std::list< Bridge> bridges;

      if( amino_acids.GetSize() > 4)
      {
        for
        (
          util::SiPtrVector< const AABase>::const_iterator
            itr_i( amino_acids.Begin() + 1), itr_i_end( amino_acids.End() - 4);
          itr_i != itr_i_end;
          ++itr_i
        )
        {
          util::SiPtrVector< const AABase>::const_iterator itr_i_prev( itr_i - 1), itr_i_next( itr_i + 1);

          for
          (
            util::SiPtrVector< const AABase>::const_iterator itr_j( itr_i + 3), itr_j_end( amino_acids.End() - 1);
            itr_j != itr_j_end;
            ++itr_j
          )
          {
            util::SiPtrVector< const AABase>::const_iterator itr_j_prev( itr_j - 1), itr_j_next( itr_j + 1);

            const BridgeType type( TestBridge( **itr_i_prev, **itr_i, **itr_i_next, **itr_j_prev, **itr_j, **itr_j_next));
            if( type == e_BTNoBridge)
            {
              continue;
            }

            bool found( false);
            for
            (
              std::list< Bridge>::iterator bridge_itr( bridges.begin()), bridge_itr_end( bridges.end());
              bridge_itr != bridge_itr_end;
              ++bridge_itr
            )
            {
              Bridge &bridge( *bridge_itr);

              if( type != bridge.m_Type || ( *itr_i)->GetSeqID() != bridge.m_I.back()->GetSeqID() + 1)
              {
                continue;
              }

              if( type == e_BTParallel && bridge.m_J.back()->GetSeqID() + 1 == ( *itr_j)->GetSeqID())
              {
                bridge.m_I.push_back( *itr_i);
                bridge.m_J.push_back( *itr_j);
                found = true;
                break;
              }

              if( type == e_BTAntiParallel && bridge.m_J.front()->GetSeqID() - 1 == ( *itr_j)->GetSeqID())
              {
                bridge.m_I.push_back( *itr_i);
                bridge.m_J.push_front( *itr_j);
                found = true;
                break;
              }
            }

            if( !found)
            {
              Bridge bridge;

              bridge.m_Type = type;
              bridge.m_I.push_back( *itr_i);
              bridge.m_ChainI = ( *itr_i)->GetChainID();
              bridge.m_J.push_back( *itr_j);
              bridge.m_ChainJ = ( *itr_j)->GetChainID();

              bridges.push_back( bridge);
            }
          }
        }
      }

      // extend ladders
      bridges.sort();

      for
      (
        std::list< Bridge>::iterator itr_i( bridges.begin()), itr_end( bridges.end());
        itr_i != itr_end;
        ++itr_i
      )
      {
        std::list< Bridge>::iterator itr_j( itr_i);
        ++itr_j;
        for( ; itr_j != itr_end; ++itr_j)
        {
          const int ibi( itr_i->m_I.front()->GetSeqID());
          const int iei( itr_i->m_I.back()->GetSeqID());
          const int jbi( itr_i->m_J.front()->GetSeqID());
          const int jei( itr_i->m_J.back()->GetSeqID());
          const int ibj( itr_j->m_I.front()->GetSeqID());
          const int iej( itr_j->m_I.back()->GetSeqID());
          const int jbj( itr_j->m_J.front()->GetSeqID());
          const int jej( itr_j->m_J.back()->GetSeqID());

          if
          (
            itr_i->m_Type != itr_j->m_Type ||
//            MResidue::NoChainBreak( inResidues[ min( ibi, ibj)], inResidues[ max( iei, iej)]) == false ||
//            MResidue::NoChainBreak( inResidues[ min( jbi, jbj)], inResidues[ max( jei, jej)]) == false ||
            ibj - iei >= 6 ||
            ( iei >= ibj && ibi <= iej)
          )
          {
            continue;
          }

          bool bulge;
          if( itr_i->m_Type == e_BTParallel)
          {
            bulge = ( ( jbj - jei < 6 && ibj - iei < 3) || ( jbj - jei < 3));
          }
          else
          {
            bulge = ( ( jbi - jej < 6 && ibj - iei < 3) || ( jbi - jej < 3));
          }

          if( bulge)
          {
            itr_i->m_I.insert( itr_i->m_I.end(), itr_j->m_I.begin(), itr_j->m_I.end());
            if( itr_i->m_Type == e_BTParallel)
            {
              itr_i->m_J.insert( itr_i->m_J.end(), itr_j->m_J.begin(), itr_j->m_J.end());
            }
            else
            {
              itr_i->m_J.insert( itr_i->m_J.begin(), itr_j->m_J.begin(), itr_j->m_J.end());
            }
            std::list< Bridge>::iterator itr_erase( itr_j);
            --itr_j;

            bridges.erase( itr_erase);
          }
        }
      }

      // Sheet
      std::list< Bridge *> ladders;
      for( std::list< Bridge>::iterator itr( bridges.begin()), itr_end( bridges.end()); itr != itr_end; ++itr)
      {
        Bridge &bridge( *itr);
        ladders.push_back( &bridge);

        size_t n( bridge.m_I.size());
        if( n > s_HistogramSize)
        {
          n = s_HistogramSize;
        }

        if( bridge.m_Type == e_BTParallel)
        {
          m_ParallelBridgesPerLadderHistogram[ n - 1] += 1;
        }
        else
        {
          m_AntiparallelBridgesPerLadderHistogram[ n - 1] += 1;
        }
      }

      size_t sheet( 1);
      size_t ladder( 0);

      while( !ladders.empty())
      {
        std::list< Bridge *> sheets;
        sheets.splice( sheets.begin(), ladders, ladders.begin());

        bool done( false);
        while( !done)
        {
          done = true;
          for
          (
            std::list< Bridge *>::iterator itr_s( sheets.begin()), itr_s_end( sheets.end());
            itr_s != itr_s_end;
            ++itr_s
          )
          {
            for
            (
              std::list< Bridge *>::iterator itr_l( ladders.begin()), itr_l_end( ladders.end());
              itr_l != itr_l_end;
              ++itr_l
            )
            {
              if( Linked( **itr_s, **itr_l))
              {
                sheets.splice( sheets.end(), ladders, itr_l);
                done = false;
                break;
              }
            }
            if( !done)
            {
              break;
            }
          }
        }

        // create a set of sheets, to store on the bridges
        std::set< Bridge *> sheetset( sheets.begin(), sheets.end());

        for
        (
          std::list< Bridge *>::iterator itr_s( sheets.begin()), itr_s_end( sheets.end());
          itr_s != itr_s_end;
          ++itr_s, ++ladder
        )
        {
          Bridge &bridge( **itr_s);
          bridge.m_Ladder = ladder;
          bridge.m_Sheet = sheet;
          bridge.m_Link = sheetset;
        }

        size_t nr_of_ladders_per_sheet( sheets.size());
        if( nr_of_ladders_per_sheet > s_HistogramSize)
        {
          nr_of_ladders_per_sheet = s_HistogramSize;
        }
        if( nr_of_ladders_per_sheet == 1 && ( *sheets.begin())->m_I.size() > 1)
        {
          m_LaddersPerSheetHistogram[ 0] += 1;
        }
        else if( nr_of_ladders_per_sheet > 1)
        {
          m_LaddersPerSheetHistogram[ nr_of_ladders_per_sheet - 1] += 1;
        }

        ++sheet;
      }

      for( std::list< Bridge>::iterator itr( bridges.begin()), itr_end( bridges.end()); itr != itr_end; ++itr)
      {
        Bridge &bridge( *itr);
        // find out if any of the i and j set members already have
        // a bridge assigned, if so, we're assigning bridge 2

        size_t beta_i( 0);
        size_t beta_j( 0);

        for( std::deque< util::SiPtr< const AABase> >::const_iterator aa_itr( bridge.m_I.begin()), aa_itr_end( bridge.m_I.end()); aa_itr != aa_itr_end; ++aa_itr)
        {
          const BridgePartnerContainerType::const_iterator partner_itr( m_BridgePartner.Find( *aa_itr));
          if( partner_itr != m_BridgePartner.End() && partner_itr->second.First().m_Partner.IsDefined())
          {
            beta_i = 1;
            break;
          }
        }

        for( std::deque< util::SiPtr< const AABase> >::const_iterator aa_itr( bridge.m_J.begin()), aa_itr_end( bridge.m_J.end()); aa_itr != aa_itr_end; ++aa_itr)
        {
          const BridgePartnerContainerType::const_iterator partner_itr( m_BridgePartner.Find( *aa_itr));
          if( partner_itr != m_BridgePartner.End() && partner_itr->second.First().m_Partner.IsDefined())
          {
            beta_j = 1;
            break;
          }
        }

        SecondaryStructureType ss( e_Betabridge);
        if( bridge.m_I.size() > 1)
        {
          ss = e_Strand;
        }

        if( bridge.m_Type == e_BTParallel)
        {
          m_NrOfHydrogenBondsInParallelBridges += bridge.m_I.back()->GetSeqID() - bridge.m_I.front()->GetSeqID() + 2;

          for
          (
            std::deque< util::SiPtr< const AABase> >::const_iterator
              itr_i( bridge.m_I.begin()), itr_j( bridge.m_J.begin()), itr_i_end( bridge.m_I.end());
            itr_i != itr_i_end;
            ++itr_i, ++itr_j
          )
          {
            m_BridgePartner[ *itr_i]( beta_i) = BridgePartner( *itr_j, bridge.m_Ladder, true);
          }

          for
          (
            std::deque< util::SiPtr< const AABase> >::const_iterator
              itr_i( bridge.m_J.begin()), itr_j( bridge.m_I.begin()), itr_i_end( bridge.m_J.end());
            itr_i != itr_i_end;
            ++itr_i, ++itr_j
          )
          {
            m_BridgePartner[ *itr_i]( beta_j) = BridgePartner( *itr_j, bridge.m_Ladder, true);
          }
        }
        else
        {
          m_NrOfHydrogenBondsInAntiparallelBridges += bridge.m_I.back()->GetSeqID() - bridge.m_I.front()->GetSeqID() + 2;

          std::deque< util::SiPtr< const AABase> >::const_reverse_iterator itr_j( bridge.m_J.rbegin());
          for
          (
            std::deque< util::SiPtr< const AABase> >::const_iterator
              itr_i( bridge.m_I.begin()), itr_i_end( bridge.m_I.end());
            itr_i != itr_i_end;
            ++itr_i, ++itr_j
          )
          {
            m_BridgePartner[ *itr_i]( beta_i) = BridgePartner( *itr_j, bridge.m_Ladder, false);
          }

          itr_j = bridge.m_I.rbegin();
          for
          (
            std::deque< util::SiPtr< const AABase> >::const_iterator
              itr_i( bridge.m_J.begin()), itr_i_end( bridge.m_J.end());
            itr_i != itr_i_end;
            ++itr_i, ++itr_j
          )
          {
            m_BridgePartner[ *itr_i]( beta_j) = BridgePartner( *itr_j, bridge.m_Ladder, false);
          }
        }

        for
        (
          std::deque< util::SiPtr< const AABase> >::const_iterator
            aa_itr( bridge.m_I.begin()), aa_itr_end( bridge.m_I.end());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          if( m_SecondaryStructure[ *aa_itr] != e_Strand)
          {
            m_SecondaryStructure[ *aa_itr] = ss;
          }
          m_Sheet[ *aa_itr] = bridge.m_Sheet;
        }

        for
        (
          std::deque< util::SiPtr< const AABase> >::const_iterator
            aa_itr( bridge.m_J.begin()), aa_itr_end( bridge.m_J.end());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          if( m_SecondaryStructure[ *aa_itr] != e_Strand)
          {
            m_SecondaryStructure[ *aa_itr] = ss;
          }
          m_Sheet[ *aa_itr] = bridge.m_Sheet;
        }
      }
    }

    //! @brief using all hydrogen bonds, determine all helix types
    void DSSP::CalculateAlphaHelices() const
    {
      BCL_MessageDbg( "Calculate alpha helices");

      // Helix and Turn
      for
      (
        assemble::ProteinModel::const_iterator chain_itr( m_Model->GetChains().Begin()), chain_itr_end( m_Model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        for( size_t stride( 3); stride <= 5; ++stride)
        {
          const util::SiPtrVector< const AABase> res( ( *chain_itr)->GetAminoAcids());
          if( res.GetSize() < stride)
          {
            continue;
          }

          for
          (
            util::SiPtrVector< const AABase>::const_iterator aa_itr( res.Begin()), aa_itr_end( res.End() - stride);
            aa_itr != aa_itr_end;
            ++aa_itr
          )
          {
            if( TestBond( **( aa_itr + stride), **aa_itr)) // and MResidue::NoChainBreak(res[i], res[i + stride]))
            {
              m_HelixFlag[ stride - 3][ *( aa_itr + stride)] = e_HelixEnd;
              for
              (
                util::SiPtrVector< const AABase>::const_iterator aa_j_itr( aa_itr + 1), aa_j_itr_end( aa_itr + stride);
                aa_j_itr != aa_j_itr_end;
                ++aa_j_itr
              )
              {
                if( m_HelixFlag[ stride - 3][ *aa_j_itr] == e_HelixNone)
                {
                  m_HelixFlag[ stride - 3][ *aa_j_itr] = e_HelixMiddle;
                }
              }

              if( m_HelixFlag[ stride - 3][ *aa_itr] == e_HelixEnd)
              {
                m_HelixFlag[ stride - 3][ *aa_itr] = e_HelixStartAndEnd;
              }
              else
              {
                m_HelixFlag[ stride - 3][ *aa_itr] = e_HelixStart;
              }
            }
          }
        }
      }

      // iterate through chains
      for
      (
        assemble::ProteinModel::const_iterator
          chain_itr( m_Model->GetChains().Begin()), chain_itr_end( m_Model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        const util::SiPtrVector< const AABase> res( ( *chain_itr)->GetAminoAcids());
        if( res.GetSize() < 5)
        {
          continue;
        }

        for
        (
          util::SiPtrVector< const AABase>::const_iterator aa_itr( res.Begin()), aa_itr_end( res.End() - 4);
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          const AABase &prev_prev( **aa_itr);
          const AABase &center( **( aa_itr + 2));
          const AABase &next_next( **( aa_itr + 4));

          const double kappa( math::Angle::Degree( Kappa( prev_prev, center, next_next)));
          m_Kappa[ util::ToSiPtr( center)] = kappa;
          if( kappa > 70)
          {
            m_Bend.Insert( util::ToSiPtr( center));
          }
        }
      }

      // iterate through chains
      for
      (
        assemble::ProteinModel::const_iterator
          chain_itr( m_Model->GetChains().Begin()), chain_itr_end( m_Model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        const util::SiPtrVector< const AABase> res( ( *chain_itr)->GetAminoAcids());
        if( res.GetSize() < 6)
        {
          continue;
        }

        for
        (
          util::SiPtrVector< const AABase>::const_iterator aa_itr( res.Begin()), aa_itr_end( res.End());
          aa_itr + 5 != aa_itr_end;
          ++aa_itr
        )
        {
          if( IsHelixStart( **aa_itr, 4) && IsHelixStart( **( aa_itr + 1), 4))
          {
            for
            (
              util::SiPtrVector< const AABase>::const_iterator aa_j_itr( aa_itr + 1), aa_j_itr_end( aa_j_itr + 4);
              aa_j_itr != aa_j_itr_end;
              ++aa_j_itr
            )
            {
              m_SecondaryStructure[ *aa_j_itr] = e_Alphahelix;
            }
          }
        }
      }

      // iterate through chains
      for
      (
        assemble::ProteinModel::const_iterator
          chain_itr( m_Model->GetChains().Begin()), chain_itr_end( m_Model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        const util::SiPtrVector< const AABase> res( ( *chain_itr)->GetAminoAcids());
        if( res.GetSize() < 4)
        {
          continue;
        }

        for
        (
          util::SiPtrVector< const AABase>::const_iterator aa_itr( res.Begin()), aa_itr_end( res.End());
          aa_itr + 4 != aa_itr_end;
          ++aa_itr
        )
        {
          if( IsHelixStart( **aa_itr, 3) && IsHelixStart( **( aa_itr + 1), 3))
          {
            bool empty( true);
            for
            (
              util::SiPtrVector< const AABase>::const_iterator aa_j_itr( aa_itr + 1), aa_j_itr_end( aa_j_itr + 3);
              empty && aa_j_itr != aa_j_itr_end;
              ++aa_j_itr
            )
            {
              empty = m_SecondaryStructure[ *aa_j_itr] == e_Loop || m_SecondaryStructure[ *aa_j_itr] == e_Helix_3;
            }
            if( empty)
            {
              for
              (
                util::SiPtrVector< const AABase>::const_iterator aa_j_itr( aa_itr + 1), aa_j_itr_end( aa_j_itr + 3);
                empty && aa_j_itr != aa_j_itr_end;
                ++aa_j_itr
              )
              {
                m_SecondaryStructure[ *aa_j_itr] = e_Helix_3;
              }
            }
          }
        }
      }

      // iterate through chains
      for
      (
        assemble::ProteinModel::const_iterator chain_itr( m_Model->GetChains().Begin()), chain_itr_end( m_Model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        const util::SiPtrVector< const AABase> res( ( *chain_itr)->GetAminoAcids());
        if( res.GetSize() < 6)
        {
          continue;
        }
        for
        (
          util::SiPtrVector< const AABase>::const_iterator aa_itr( res.Begin()), aa_itr_end( res.End());
          aa_itr + 7 != aa_itr_end;
          ++aa_itr
        )
        {
          if( IsHelixStart( **aa_itr, 5) && IsHelixStart( **( aa_itr + 1), 5))
          {
            bool empty( true);
            for
            (
              util::SiPtrVector< const AABase>::const_iterator aa_j_itr( aa_itr + 1), aa_j_itr_end( aa_j_itr + 5);
              empty && aa_j_itr != aa_j_itr_end;
              ++aa_j_itr
            )
            {
              empty = m_SecondaryStructure[ *aa_j_itr] == e_Loop || m_SecondaryStructure[ *aa_j_itr] == e_Helix_5;
            }
            if( empty)
            {
              for
              (
                util::SiPtrVector< const AABase>::const_iterator aa_j_itr( aa_itr + 1), aa_j_itr_end( aa_j_itr + 5);
                empty && aa_j_itr != aa_j_itr_end;
                ++aa_j_itr
              )
              {
                m_SecondaryStructure[ *aa_j_itr] = e_Helix_5;
              }
            }
          }
        }
      }

      // iterate through chains
      for
      (
        assemble::ProteinModel::const_iterator chain_itr( m_Model->GetChains().Begin()), chain_itr_end( m_Model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        const util::SiPtrVector< const AABase> res( ( *chain_itr)->GetAminoAcids());
        if( res.GetSize() < 3)
        {
          continue;
        }
        for
        (
          util::SiPtrVector< const AABase>::const_iterator aa_itr( res.Begin() + 1), aa_itr_end( res.End() - 1);
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          if( m_SecondaryStructure[ *aa_itr] != e_Loop)
          {
            continue;
          }
          bool is_turn( false);
          for( size_t stride( 3); stride <= 5 && !is_turn; ++stride)
          {
            for( size_t k( 1); k < stride && !is_turn; ++k)
            {
              is_turn = ( aa_itr >= res.Begin() + k) && IsHelixStart( **( aa_itr - k), stride);
            }
          }

          if( is_turn)
          {
            m_SecondaryStructure[ *aa_itr] = e_Turn;
          }
          else if( m_Bend.Contains( *aa_itr))
          {
            m_SecondaryStructure[ *aa_itr] = e_Bend;
          }
        }
      }
    }

    //! @brief test and calculate hydrogen bond energy between donor and acceptor, store in member
    //! @param AA_DONOR (hydrogen, nitrogen)
    //! @param AA_ACCEPTOR (oxygen, carbon)
    //! @return the energy calculated - if relevant interaction was found
    double DSSP::CalculateHydrogenBondEnergy( const AABase &AA_DONOR, const AABase &AA_ACCEPTOR) const
    {
      const double min_hydrogen_bond_energy( -9.9);
      const double coupling_constant( -27.888); //  = -332 * 0.42 * 0.2
      const double min_distance( 0.5);

      double energy( 0.0);

      const Atom &dh
      (
        AA_DONOR.GetAtom( GetAtomTypes().H).GetCoordinates().IsDefined() ?
            AA_DONOR.GetAtom( GetAtomTypes().H) : AA_DONOR.GetAtom( GetAtomTypes().N)
      );

      if( AA_DONOR.GetType() != GetAATypes().PRO)
      {
        const Atom &dn( AA_DONOR.GetAtom( GetAtomTypes().N));
        const Atom &ao( AA_ACCEPTOR.GetAtom( GetAtomTypes().O));
        const Atom &ac( AA_ACCEPTOR.GetAtom( GetAtomTypes().C));

        const double dist_ho( Distance( dh, ao));
        const double dist_hc( Distance( dh, ac));
        const double dist_nc( Distance( dn, ac));
        const double dist_no( Distance( dn, ao));

        if( dist_ho < min_distance || dist_hc < min_distance || dist_nc < min_distance || dist_no < min_distance)
        {
          energy = min_hydrogen_bond_energy;
        }
        else
        {
          energy = coupling_constant / dist_ho - coupling_constant / dist_hc + coupling_constant / dist_nc - coupling_constant / dist_no;
        }

        // DSSP compatibility mode:
        energy = round( energy * 1000) / 1000;

        if( energy < min_hydrogen_bond_energy)
        {
          energy = min_hydrogen_bond_energy;
        }
      }

      // update donor
      {
        HydrogenBondContainerType::iterator itr( m_HydrogenBondAcceptor.Find( util::ToSiPtr( AA_DONOR)));
        if( itr == m_HydrogenBondAcceptor.End())
        {
          itr = m_HydrogenBondAcceptor.Insert
              (
                std::make_pair
                (
                  util::ToSiPtr( AA_DONOR),
                  storage::VectorND< 2, storage::Pair< util::SiPtr< const AABase>, double> >
                  (
                    storage::Pair< util::SiPtr< const AABase>, double>( util::SiPtr< const AABase>(), 0.0),
                    storage::Pair< util::SiPtr< const AABase>, double>( util::SiPtr< const AABase>(), 0.0)
                  )
                )
              ).first;
        }

        if( energy < itr->second.First().Second())
        {
          itr->second.Second() = itr->second.First();
          itr->second.First() = storage::Pair< util::SiPtr< const AABase>, double>( util::ToSiPtr( AA_ACCEPTOR), energy);
        }
        else if( energy < itr->second.Second().Second())
        {
          itr->second.Second() = storage::Pair< util::SiPtr< const AABase>, double>( util::ToSiPtr( AA_ACCEPTOR), energy);
        }
      }

      // update acceptor
      {
        HydrogenBondContainerType::iterator itr( m_HydrogenBondDonor.Find( util::ToSiPtr( AA_ACCEPTOR)));
        if( itr == m_HydrogenBondDonor.End())
        {
          itr = m_HydrogenBondDonor.Insert
              (
                std::make_pair
                (
                  util::ToSiPtr( AA_ACCEPTOR),
                  storage::VectorND< 2, storage::Pair< util::SiPtr< const AABase>, double> >
                  (
                    storage::Pair< util::SiPtr< const AABase>, double>( util::SiPtr< const AABase>(), 0.0),
                    storage::Pair< util::SiPtr< const AABase>, double>( util::SiPtr< const AABase>(), 0.0)
                  )
                )
              ).first;
        }

        if( energy < itr->second.First().Second())
        {
          itr->second.Second() = itr->second.First();
          itr->second.First() = storage::Pair< util::SiPtr< const AABase>, double>( util::ToSiPtr( AA_DONOR), energy);
        }
        else if( energy < itr->second.Second().Second())
        {
          itr->second.Second() = storage::Pair< util::SiPtr< const AABase>, double>( util::ToSiPtr( AA_DONOR), energy);
        }
      }

      // end
      return energy;
    }

    //! @brief calculate alpha angle, store in member
    //! @param PREV previous amino acid
    //! @param CENTER center amino acid
    //! @param NEXT next amino acid
    //! @param NEXT_NEXT next amino acid after NEXT
    std::pair< double, char> DSSP::CalculateAlpha
    (
      const AABase &PREV, const AABase &CENTER, const AABase &NEXT, const AABase &NEXT_NEXT
    ) const
    {
      const Atom &ca_prev(      PREV.GetAtom(      GetAtomTypes().CA));
      const Atom &ca_current(   CENTER.GetAtom(    GetAtomTypes().CA));
      const Atom &ca_next(      NEXT.GetAtom(      GetAtomTypes().CA));
      const Atom &ca_next_next( NEXT_NEXT.GetAtom( GetAtomTypes().CA));

      const double alpha( math::Angle::Degree( Dihedral( ca_prev, ca_current, ca_next, ca_next_next)));
      char chirality( alpha < 0 ? '-' : '+');

      return m_Alpha[ util::ToSiPtr( CENTER)] = std::make_pair( alpha, chirality);
    }

    //! @brief test if three amino acids in one stretch - I is interacting via a beta bridge with a second stretch - J
    //! @param I_PREV previous amino acid in i
    //! @param I_CURRENT center amino acid in i
    //! @param I_NEXT next amino acid in i
    //! @param J_PREV previous amino acid in j
    //! @param J_CURRENT center amino acid in j
    //! @param J_NEXT next amino acid in j
    //! @return parallel or anti parallel or no bridge was found
    DSSP::BridgeType DSSP::TestBridge
    (
      const AABase &I_PREV, const AABase &I_CURR, const AABase &I_NEXT,
      const AABase &J_PREV, const AABase &J_CURR, const AABase &J_NEXT
    ) const
    {
      // I. a   d II. a   d   parallel
      //      \         /
      //    b   e     b   e
      //      /         \                      ..
      //    c   f     c   f
      //
      // III. a <- f  IV. a   f   antiparallel
      //
      //    b  e      b<->e
      //
      //    c->d      c   d

      BridgeType type( e_BTNoBridge);

//      if( NoChainBreak( A, C) && NoChainBreak( D, F))
      if( I_PREV.GetChainID() == I_NEXT.GetChainID() && J_PREV.GetChainID() == J_NEXT.GetChainID())
      {
        if( ( TestBond( I_NEXT, J_CURR) && TestBond( J_CURR, I_PREV)) || ( TestBond( J_NEXT, I_CURR) && TestBond( I_CURR, J_PREV)))
        {
          type = e_BTParallel;
        }
        else if( ( TestBond( I_NEXT, J_PREV) && TestBond( J_NEXT, I_PREV)) || ( TestBond( J_CURR, I_CURR) && TestBond( I_CURR, J_CURR)))
        {
          type = e_BTAntiParallel;
        }
      }

      return type;
    }

    //! @brief test if donor and acceptor are connected through a hydrogen bond
    //! @param AA_DONOR donor amino acid
    //! @param AA_ACCEPTOR acceptor amino acid
    //! @return true if acceptor is forming a hydrogen bond to donor
    bool DSSP::TestBond( const AABase &AA_DONOR, const AABase &AA_ACCEPTOR) const
    {
      // find the donor entry
      const HydrogenBondContainerType::const_iterator itr( m_HydrogenBondAcceptor.Find( util::ToSiPtr( AA_DONOR)));
      if( itr == m_HydrogenBondAcceptor.End())
      {
        return false;
      }

      return
        ( itr->second.First().First() == util::ToSiPtr( AA_ACCEPTOR) && itr->second.First().Second() < m_MaxHydrogenBondEnergy) ||
        ( itr->second.Second().First() == util::ToSiPtr( AA_ACCEPTOR) && itr->second.Second().Second() < m_MaxHydrogenBondEnergy);
    }

    //! @brief test if any of the residues in bridge a is identical to any of the residues in bridge b in case they
    //!        need to be joined
    //! @param BRIDGE_A bridge a potentially containing any AA of bridge b
    //! @param BRIDGE_B bridge b potentially containing any AA of bridge a
    //! @return true, if bridge and b are overlapping
    bool DSSP::Linked( const Bridge &BRIDGE_A, const Bridge &BRIDGE_B)
    {
      return
        find_first_of( BRIDGE_A.m_I.begin(), BRIDGE_A.m_I.end(), BRIDGE_B.m_I.begin(), BRIDGE_B.m_I.end()) != BRIDGE_A.m_I.end() ||
        find_first_of( BRIDGE_A.m_I.begin(), BRIDGE_A.m_I.end(), BRIDGE_B.m_J.begin(), BRIDGE_B.m_J.end()) != BRIDGE_A.m_I.end() ||
        find_first_of( BRIDGE_A.m_J.begin(), BRIDGE_A.m_J.end(), BRIDGE_B.m_I.begin(), BRIDGE_B.m_I.end()) != BRIDGE_A.m_J.end() ||
        find_first_of( BRIDGE_A.m_J.begin(), BRIDGE_A.m_J.end(), BRIDGE_B.m_J.begin(), BRIDGE_B.m_J.end()) != BRIDGE_A.m_J.end();
    }

    //! @brief calculate kappa angle over 5 residues
    //! @param PREV_PREV center - 2 amino acid
    //! @param CENTER center amino acid
    //! @param NEXT_NEXT center + 2 amino acid
    //! @return the kappa angle
    double DSSP::Kappa( const AABase &PREV_PREV, const AABase &CENTER, const AABase &NEXT_NEXT)
    {
      double result( 2 * math::g_Pi);

      const double ckap
      (
        linal::ProjAngleCosinus
        (
          NEXT_NEXT.GetCA().GetCoordinates(),
          CENTER.GetCA().GetCoordinates(),
          CENTER.GetCA().GetCoordinates(),
          PREV_PREV.GetCA().GetCoordinates()
        )
      );

      const double skap( sqrt( 1.0 - ckap * ckap));

      result = atan2( skap, ckap);

      return result;
    }

    //! @brief test if given amino acid is a start residue for given helix stride
    //! @param AMINO_ACID the amino acid in question
    //! @param STRIDE the stride of the helix
    //! @return true if amino acid was flagged start compatible for the stride
    bool DSSP::IsHelixStart( const AABase &AMINO_ACID, const size_t STRIDE) const
    {
      HelixFlagContainerType::const_iterator itr( m_HelixFlag[ STRIDE - 3].find( util::ToSiPtr( AMINO_ACID)));
      if( itr == m_HelixFlag[ STRIDE - 3].end())
      {
        return false;
      }
      return itr->second == e_HelixStart || itr->second == e_HelixStartAndEnd;
    }

  } // namespace biol
} // namespace bcl
