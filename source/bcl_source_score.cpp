// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_assignment_blast_profile.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "linal/bcl_linal_vector_operations.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AAAssignmentBlastProfile::s_Instance
    (
      GetObjectInstances().AddInstance( new AAAssignmentBlastProfile())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor
    AAAssignmentBlastProfile::AAAssignmentBlastProfile()
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAAssignmentBlastProfile copied from this one
    AAAssignmentBlastProfile *AAAssignmentBlastProfile::Clone() const
    {
      return new AAAssignmentBlastProfile( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAAssignmentBlastProfile::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator that calculates the score between two assigned members
    //! @param MEMBER_A amino acid A that is compared
    //! @param MEMBER_B amino acid A that is compared
    //! @return logarithm of the scalar product of the blast profiles multiplied by the blastprofile length
    double AAAssignmentBlastProfile::operator()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
    {
      // check definition
      BCL_Assert
      (
        MEMBER_A.GetBlastProfilePtr().IsDefined() && MEMBER_B.GetBlastProfilePtr().IsDefined(),
        "blast profile is not stored for amino acid!"
      );

      const biol::BlastProfile &profile_a( MEMBER_A.GetBlastProfile());
      const biol::BlastProfile &profile_b( MEMBER_B.GetBlastProfile());

      // compute scalar product of vectors
      double scalar
      (
        profile_a.GetProfile().GetSize() * ( profile_a.GetProbabilities() * profile_b.GetProbabilities())
      );

      // ensure scalar > 0 and scale scalar between GetSize() and 1 / GetSize()
      scalar = std::max< double>( scalar, double( 1) / profile_a.GetProfile().GetSize());
      return std::log10( scalar);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAAssignmentBlastProfile::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAAssignmentBlastProfile::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_assignment_blosum.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "linal/bcl_linal_vector_const_reference.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

    //! @brief TableType as string
    //! @param TABLE_TYPE the TableType
    //! @return the string for the TableType
    const std::string &AAAssignmentBLOSUM::GetTableDescriptor( const TableType &TABLE_TYPE)
    {
      static const std::string s_descriptors[] =
      {
        "BLOSUM_90",
        "BLOSUM_80",
        "BLOSUM_62",
        "BLOSUM_45",
        GetStaticClassName< TableType>()
      };

      return s_descriptors[ TABLE_TYPE];
    }

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AAAssignmentBLOSUM::s_Instance
    (
      GetObjectInstances().AddInstance( new AAAssignmentBLOSUM())
    );

    //! Pam and Blosum scoring matrices for amino acid replacement. Given is
    //! the log of probability of replacing aa i with aa j divided by freqency of aa i
    //! NOT mutiplied by 10 (as usually done). Note that with increasing sequence
    //! diversity move from Pam100 (45% sequence identity) to Pam250 (20% sequence identity)
    //! or from Blosum90 to Blosum45.
    //!
    //! Differences between PAM and BLOSSUM:
    //! PAM matrices are based on an explicit evolutionary model (that is, replacements
    //! are counted on the branches of a phylogenetic tree), whereas the Blosum matrices
    //! are based on an implicit rather than explicit model of evolution.
    //! The sequence variability in the alignments used to count replacements. The PAM
    //! matrices are based on mutations observed throughout a global alignment, this
    //! includes both highly conserved and highly mutable regions. The Blosum matrices
    //! are based only on highly conserved regions in series of alignments forbidden to
    //! contain gaps.
    //! The method used to count the replacements is different, unlike the PAM matrix,
    //! the Blosum procedure uses groups of sequences within which not all mutations are
    //! counted the same.
    //!
    //! Equivalent PAM and Blossum matrices: The following matrices are roughly equivalent...
    //! PAM100 <==> BLOSUM90
    //! PAM120 <==> BLOSUM80
    //! PAM160 <==> BLOSUM62
    //! PAM250 <==> BLOSUM45
    //!
    //! Generally speaking...
    //! The BLOSUM matrices are best for detecting local alignments.
    //! The BLOSUM62 matrix is the best for detecting the majority of weak protein similarities.
    //! The BLOSUM45 matrix is the best for detecting long and weak alignments.
    //!
    //! BLOSUM (Blocks Substitution Matrix):
    //! The BLOSUM matrices, also used for protein database search scoring (the default in
    //! blastp), are divided into statistical significance degrees which, in a way, are
    //! reminiscent of PAM distances. BLOSSUM matrices are most sensitive for local
    //! alignment of related sequences. The BLOSUM matrices are therefore ideal when trying
    //! to identify an unknown nucleotide sequence.
    const double AAAssignmentBLOSUM::s_BLOSUMTable[][ biol::AATypes::s_NumberStandardAATypes + 4][ biol::AATypes::s_NumberStandardAATypes + 4] =
    {
      //BLOSUM_90
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.5,-0.2,-0.2,-0.3,-0.1,-0.1,-0.1, 0.0,-0.2,-0.2,-0.2,-0.1,-0.2,-0.3,-0.1, 0.1, 0.0,-0.4,-0.3,-0.1,-0.2,-0.1,-0.1,-0.6}, //ALA
        {-0.2, 0.6,-0.1,-0.3,-0.5, 0.1,-0.1,-0.3, 0.0,-0.4,-0.3, 0.2,-0.2,-0.4,-0.3,-0.1,-0.2,-0.4,-0.3,-0.3,-0.2, 0.0,-0.2,-0.6}, //ARG
        {-0.2,-0.1, 0.7, 0.1,-0.4, 0.0,-0.1,-0.1, 0.0,-0.4,-0.4, 0.0,-0.3,-0.4,-0.3, 0.0, 0.0,-0.5,-0.3,-0.4, 0.4,-0.1,-0.2,-0.6}, //ASN
        {-0.3,-0.3, 0.1, 0.7,-0.5,-0.1, 0.1,-0.2,-0.2,-0.5,-0.5,-0.1,-0.4,-0.5,-0.3,-0.1,-0.2,-0.6,-0.4,-0.5, 0.4, 0.0,-0.2,-0.6}, //ASP
        {-0.1,-0.5,-0.4,-0.5, 0.9,-0.4,-0.6,-0.4,-0.5,-0.2,-0.2,-0.4,-0.2,-0.3,-0.4,-0.2,-0.2,-0.4,-0.4,-0.2,-0.4,-0.5,-0.3,-0.6}, //CYS
        {-0.1, 0.1, 0.0,-0.1,-0.4, 0.7, 0.2,-0.3, 0.1,-0.4,-0.3, 0.1, 0.0,-0.4,-0.2,-0.1,-0.1,-0.3,-0.3,-0.3,-0.1, 0.4,-0.1,-0.6}, //GLN
        {-0.1,-0.1,-0.1, 0.1,-0.6, 0.2, 0.6,-0.3,-0.1,-0.4,-0.4, 0.0,-0.3,-0.5,-0.2,-0.1,-0.1,-0.5,-0.4,-0.3, 0.0, 0.4,-0.2,-0.6}, //GLU
        { 0.0,-0.3,-0.1,-0.2,-0.4,-0.3,-0.3, 0.6,-0.3,-0.5,-0.5,-0.2,-0.4,-0.5,-0.3,-0.1,-0.3,-0.4,-0.5,-0.5,-0.2,-0.3,-0.2,-0.6}, //GLY
        {-0.2, 0.0, 0.0,-0.2,-0.5, 0.1,-0.1,-0.3, 0.8,-0.4,-0.4,-0.1,-0.3,-0.2,-0.3,-0.2,-0.2,-0.3, 0.1,-0.4,-0.1, 0.0,-0.2,-0.6}, //HIS
        {-0.2,-0.4,-0.4,-0.5,-0.2,-0.4,-0.4,-0.5,-0.4, 0.5, 0.1,-0.4, 0.1,-0.1,-0.4,-0.3,-0.1,-0.4,-0.2, 0.3,-0.5,-0.4,-0.2,-0.6}, //ILE
        {-0.2,-0.3,-0.4,-0.5,-0.2,-0.3,-0.4,-0.5,-0.4, 0.1, 0.5,-0.3, 0.2, 0.0,-0.4,-0.3,-0.2,-0.3,-0.2, 0.0,-0.5,-0.4,-0.2,-0.6}, //LEU
        {-0.1, 0.2, 0.0,-0.1,-0.4, 0.1, 0.0,-0.2,-0.1,-0.4,-0.3, 0.6,-0.2,-0.4,-0.2,-0.1,-0.1,-0.5,-0.3,-0.3,-0.1, 0.1,-0.1,-0.6}, //LYS
        {-0.2,-0.2,-0.3,-0.4,-0.2, 0.0,-0.3,-0.4,-0.3, 0.1, 0.2,-0.2, 0.7,-0.1,-0.3,-0.2,-0.1,-0.2,-0.2, 0.0,-0.4,-0.2,-0.1,-0.6}, //MET
        {-0.3,-0.4,-0.4,-0.5,-0.3,-0.4,-0.5,-0.5,-0.2,-0.1, 0.0,-0.4,-0.1, 0.7,-0.4,-0.3,-0.3, 0.0, 0.3,-0.2,-0.4,-0.4,-0.2,-0.6}, //PHE
        {-0.1,-0.3,-0.3,-0.3,-0.4,-0.2,-0.2,-0.3,-0.3,-0.4,-0.4,-0.2,-0.3,-0.4, 0.8,-0.2,-0.2,-0.5,-0.4,-0.3,-0.3,-0.2,-0.2,-0.6}, //PRO
        { 0.1,-0.1, 0.0,-0.1,-0.2,-0.1,-0.1,-0.1,-0.2,-0.3,-0.3,-0.1,-0.2,-0.3,-0.2, 0.5, 0.1,-0.4,-0.3,-0.2, 0.0,-0.1,-0.1,-0.6}, //SER
        { 0.0,-0.2, 0.0,-0.2,-0.2,-0.1,-0.1,-0.3,-0.2,-0.1,-0.2,-0.1,-0.1,-0.3,-0.2, 0.1, 0.6,-0.4,-0.2,-0.1,-0.1,-0.1,-0.1,-0.6}, //THR
        {-0.4,-0.4,-0.5,-0.6,-0.4,-0.3,-0.5,-0.4,-0.3,-0.4,-0.3,-0.5,-0.2, 0.0,-0.5,-0.4,-0.4, 1.1, 0.2,-0.3,-0.6,-0.4,-0.3,-0.6}, //TRP
        {-0.3,-0.3,-0.3,-0.4,-0.4,-0.3,-0.4,-0.5, 0.1,-0.2,-0.2,-0.3,-0.2, 0.3,-0.4,-0.3,-0.2, 0.2, 0.8,-0.3,-0.4,-0.3,-0.2,-0.6}, //TYR
        {-0.1,-0.3,-0.4,-0.5,-0.2,-0.3,-0.3,-0.5,-0.4, 0.3, 0.0,-0.3, 0.0,-0.2,-0.3,-0.2,-0.1,-0.3,-0.3, 0.5,-0.4,-0.3,-0.2,-0.6}, //VAL
        {-0.2,-0.2, 0.4, 0.4,-0.4,-0.1, 0.0,-0.2,-0.1,-0.5,-0.5,-0.1,-0.4,-0.4,-0.3, 0.0,-0.1,-0.6,-0.4,-0.4, 0.4, 0.0,-0.2,-0.6}, //ASX
        {-0.1, 0.0,-0.1, 0.0,-0.5, 0.4, 0.4,-0.3, 0.0,-0.4,-0.4, 0.1,-0.2,-0.4,-0.2,-0.1,-0.1,-0.4,-0.3,-0.3, 0.0, 0.4,-0.1,-0.6}, //GLX
        {-0.1,-0.2,-0.2,-0.2,-0.3,-0.1,-0.2,-0.2,-0.2,-0.2,-0.2,-0.1,-0.1,-0.2,-0.2,-0.1,-0.1,-0.3,-0.2,-0.2,-0.2,-0.1,-0.2,-0.6}, //XXX
        {-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6,-0.6, 0.1}  //GAP
      },
      //BLOSUM_80
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.7,-0.3,-0.3,-0.3,-0.1,-0.2,-0.2, 0.0,-0.3,-0.3,-0.3,-0.1,-0.2,-0.4,-0.1, 0.2, 0.0,-0.5,-0.4,-0.1,-0.3,-0.2,-0.1,-0.8}, //ALA
        {-0.3, 0.9,-0.1,-0.3,-0.6, 0.1,-0.1,-0.4, 0.0,-0.5,-0.4, 0.3,-0.3,-0.5,-0.3,-0.2,-0.2,-0.5,-0.4,-0.4,-0.2, 0.0,-0.2,-0.8}, //ARG
        {-0.3,-0.1, 0.9, 0.2,-0.5, 0.0,-0.1,-0.1, 0.1,-0.6,-0.6, 0.0,-0.4,-0.6,-0.4, 0.1, 0.0,-0.7,-0.4,-0.5, 0.5,-0.1,-0.2,-0.8}, //ASN
        {-0.3,-0.3, 0.2, 1.0,-0.7,-0.1, 0.2,-0.3,-0.2,-0.7,-0.7,-0.2,-0.6,-0.6,-0.3,-0.1,-0.2,-0.8,-0.6,-0.6, 0.6, 0.1,-0.3,-0.8}, //ASP
        {-0.1,-0.6,-0.5,-0.7, 1.3,-0.5,-0.7,-0.6,-0.7,-0.2,-0.3,-0.6,-0.3,-0.4,-0.6,-0.2,-0.2,-0.5,-0.5,-0.2,-0.6,-0.7,-0.4,-0.8}, //CYS
        {-0.2, 0.1, 0.0,-0.1,-0.5, 0.9, 0.3,-0.4, 0.1,-0.5,-0.4, 0.2,-0.1,-0.5,-0.3,-0.1,-0.1,-0.4,-0.3,-0.4,-0.1, 0.5,-0.2,-0.8}, //GLN
        {-0.2,-0.1,-0.1, 0.2,-0.7, 0.3, 0.8,-0.4, 0.0,-0.6,-0.6, 0.1,-0.4,-0.6,-0.2,-0.1,-0.2,-0.6,-0.5,-0.4, 0.1, 0.6,-0.2,-0.8}, //GLU
        { 0.0,-0.4,-0.1,-0.3,-0.6,-0.4,-0.4, 0.9,-0.4,-0.7,-0.7,-0.3,-0.5,-0.6,-0.5,-0.1,-0.3,-0.6,-0.6,-0.6,-0.2,-0.4,-0.3,-0.8}, //GLY
        {-0.3, 0.0, 0.1,-0.2,-0.7, 0.1, 0.0,-0.4, 1.2,-0.6,-0.5,-0.1,-0.4,-0.2,-0.4,-0.2,-0.3,-0.4, 0.3,-0.5,-0.1, 0.0,-0.2,-0.8}, //HIS
        {-0.3,-0.5,-0.6,-0.7,-0.2,-0.5,-0.6,-0.7,-0.6, 0.7, 0.2,-0.5, 0.2,-0.1,-0.5,-0.4,-0.2,-0.5,-0.3, 0.4,-0.6,-0.6,-0.2,-0.8}, //ILE
        {-0.3,-0.4,-0.6,-0.7,-0.3,-0.4,-0.6,-0.7,-0.5, 0.2, 0.6,-0.4, 0.3, 0.0,-0.5,-0.4,-0.3,-0.4,-0.2, 0.1,-0.7,-0.5,-0.2,-0.8}, //LEU
        {-0.1, 0.3, 0.0,-0.2,-0.6, 0.2, 0.1,-0.3,-0.1,-0.5,-0.4, 0.8,-0.3,-0.5,-0.2,-0.1,-0.1,-0.6,-0.4,-0.4,-0.1, 0.1,-0.2,-0.8}, //LYS
        {-0.2,-0.3,-0.4,-0.6,-0.3,-0.1,-0.4,-0.5,-0.4, 0.2, 0.3,-0.3, 0.9, 0.0,-0.4,-0.3,-0.1,-0.3,-0.3, 0.1,-0.5,-0.3,-0.2,-0.8}, //MET
        {-0.4,-0.5,-0.6,-0.6,-0.4,-0.5,-0.6,-0.6,-0.2,-0.1, 0.0,-0.5, 0.0, 1.0,-0.6,-0.4,-0.4, 0.0, 0.4,-0.2,-0.6,-0.6,-0.3,-0.8}, //PHE
        {-0.1,-0.3,-0.4,-0.3,-0.6,-0.3,-0.2,-0.5,-0.4,-0.5,-0.5,-0.2,-0.4,-0.6, 1.2,-0.2,-0.3,-0.7,-0.6,-0.4,-0.4,-0.2,-0.3,-0.8}, //PRO
        { 0.2,-0.2, 0.1,-0.1,-0.2,-0.1,-0.1,-0.1,-0.2,-0.4,-0.4,-0.1,-0.3,-0.4,-0.2, 0.7, 0.2,-0.6,-0.3,-0.3, 0.0,-0.1,-0.1,-0.8}, //SER
        { 0.0,-0.2, 0.0,-0.2,-0.2,-0.1,-0.2,-0.3,-0.3,-0.2,-0.3,-0.1,-0.1,-0.4,-0.3, 0.2, 0.8,-0.5,-0.3, 0.0,-0.1,-0.2,-0.1,-0.8}, //THR
        {-0.5,-0.5,-0.7,-0.8,-0.5,-0.4,-0.6,-0.6,-0.4,-0.5,-0.4,-0.6,-0.3, 0.0,-0.7,-0.6,-0.5, 1.6, 0.3,-0.5,-0.8,-0.5,-0.5,-0.8}, //TRP
        {-0.4,-0.4,-0.4,-0.6,-0.5,-0.3,-0.5,-0.6, 0.3,-0.3,-0.2,-0.4,-0.3, 0.4,-0.6,-0.3,-0.3, 0.3, 1.1,-0.3,-0.5,-0.4,-0.3,-0.8}, //TYR
        {-0.1,-0.4,-0.5,-0.6,-0.2,-0.4,-0.4,-0.6,-0.5, 0.4, 0.1,-0.4, 0.1,-0.2,-0.4,-0.3, 0.0,-0.5,-0.3, 0.7,-0.6,-0.4,-0.2,-0.8}, //VAL
        {-0.3,-0.2, 0.5, 0.6,-0.6,-0.1, 0.1,-0.2,-0.1,-0.6,-0.7,-0.1,-0.5,-0.6,-0.4, 0.0,-0.1,-0.8,-0.5,-0.6, 0.6, 0.0,-0.3,-0.8}, //ASX
        {-0.2, 0.0,-0.1, 0.1,-0.7, 0.5, 0.6,-0.4, 0.0,-0.6,-0.5, 0.1,-0.3,-0.6,-0.2,-0.1,-0.2,-0.5,-0.4,-0.4, 0.0, 0.6,-0.1,-0.8}, //GLX
        {-0.1,-0.2,-0.2,-0.3,-0.4,-0.2,-0.2,-0.3,-0.2,-0.2,-0.2,-0.2,-0.2,-0.3,-0.3,-0.1,-0.1,-0.5,-0.3,-0.2,-0.3,-0.1,-0.2,-0.8}, //XXX
        {-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8, 0.1}  //GAP
      },
      //BLOSUM_62
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.4,-0.1,-0.2,-0.2, 0.0,-0.1,-0.1, 0.0,-0.2,-0.1,-0.1,-0.1,-0.1,-0.2,-0.1, 0.1, 0.0,-0.3,-0.2, 0.0,-0.2,-0.1, 0.0,-0.4}, //ALA
        {-0.1, 0.5, 0.0,-0.2,-0.3, 0.1, 0.0,-0.2, 0.0,-0.3,-0.2, 0.2,-0.1,-0.3,-0.2,-0.1,-0.1,-0.3,-0.2,-0.3,-0.1, 0.0,-0.1,-0.4}, //ARG
        {-0.2, 0.0, 0.6, 0.1,-0.3, 0.0, 0.0, 0.0, 0.1,-0.3,-0.3, 0.0,-0.2,-0.3,-0.2, 0.1, 0.0,-0.4,-0.2,-0.3, 0.3, 0.0,-0.1,-0.4}, //ASN
        {-0.2,-0.2, 0.1, 0.6,-0.3, 0.0, 0.2,-0.1,-0.1,-0.3,-0.4,-0.1,-0.3,-0.3,-0.1, 0.0,-0.1,-0.4,-0.3,-0.3, 0.4, 0.1,-0.1,-0.4}, //ASP
        { 0.0,-0.3,-0.3,-0.3, 0.9,-0.3,-0.4,-0.3,-0.3,-0.1,-0.1,-0.3,-0.1,-0.2,-0.3,-0.1,-0.1,-0.2,-0.2,-0.1,-0.3,-0.3,-0.2,-0.4}, //CYS
        {-0.1, 0.1, 0.0, 0.0,-0.3, 0.5, 0.2,-0.2, 0.0,-0.3,-0.2, 0.1, 0.0,-0.3,-0.1, 0.0,-0.1,-0.2,-0.1,-0.2, 0.0, 0.3,-0.1,-0.4}, //GLN
        {-0.1, 0.0, 0.0, 0.2,-0.4, 0.2, 0.5,-0.2, 0.0,-0.3,-0.3, 0.1,-0.2,-0.3,-0.1, 0.0,-0.1,-0.3,-0.2,-0.2, 0.1, 0.4,-0.1,-0.4}, //GLU
        { 0.0,-0.2, 0.0,-0.1,-0.3,-0.2,-0.2, 0.6,-0.2,-0.4,-0.4,-0.2,-0.3,-0.3,-0.2, 0.0,-0.2,-0.2,-0.3,-0.3,-0.1,-0.2,-0.1,-0.4}, //GLY
        {-0.2, 0.0, 0.1,-0.1,-0.3, 0.0, 0.0,-0.2, 0.8,-0.3,-0.3,-0.1,-0.2,-0.1,-0.2,-0.1,-0.2,-0.2, 0.2,-0.3, 0.0, 0.0,-0.1,-0.4}, //HIS
        {-0.1,-0.3,-0.3,-0.3,-0.1,-0.3,-0.3,-0.4,-0.3, 0.4, 0.2,-0.3, 0.1, 0.0,-0.3,-0.2,-0.1,-0.3,-0.1, 0.3,-0.3,-0.3,-0.1,-0.4}, //ILE
        {-0.1,-0.2,-0.3,-0.4,-0.1,-0.2,-0.3,-0.4,-0.3, 0.2, 0.4,-0.2, 0.2, 0.0,-0.3,-0.2,-0.1,-0.2,-0.1, 0.1,-0.4,-0.3,-0.1,-0.4}, //LEU
        {-0.1, 0.2, 0.0,-0.1,-0.3, 0.1, 0.1,-0.2,-0.1,-0.3,-0.2, 0.5,-0.1,-0.3,-0.1, 0.0,-0.1,-0.3,-0.2,-0.2, 0.0, 0.1,-0.1,-0.4}, //LYS
        {-0.1,-0.1,-0.2,-0.3,-0.1, 0.0,-0.2,-0.3,-0.2, 0.1, 0.2,-0.1, 0.5, 0.0,-0.2,-0.1,-0.1,-0.1,-0.1, 0.1,-0.3,-0.1,-0.1,-0.4}, //MET
        {-0.2,-0.3,-0.3,-0.3,-0.2,-0.3,-0.3,-0.3,-0.1, 0.0, 0.0,-0.3, 0.0, 0.6,-0.4,-0.2,-0.2, 0.1, 0.3,-0.1,-0.3,-0.3,-0.1,-0.4}, //PHE
        {-0.1,-0.2,-0.2,-0.1,-0.3,-0.1,-0.1,-0.2,-0.2,-0.3,-0.3,-0.1,-0.2,-0.4, 0.7,-0.1,-0.1,-0.4,-0.3,-0.2,-0.2,-0.1,-0.2,-0.4}, //PRO
        { 0.1,-0.1, 0.1, 0.0,-0.1, 0.0, 0.0, 0.0,-0.1,-0.2,-0.2, 0.0,-0.1,-0.2,-0.1, 0.4, 0.1,-0.3,-0.2,-0.2, 0.0, 0.0, 0.0,-0.4}, //SER
        { 0.0,-0.1, 0.0,-0.1,-0.1,-0.1,-0.1,-0.2,-0.2,-0.1,-0.1,-0.1,-0.1,-0.2,-0.1, 0.1, 0.5,-0.2,-0.2, 0.0,-0.1,-0.1, 0.0,-0.4}, //THR
        {-0.3,-0.3,-0.4,-0.4,-0.2,-0.2,-0.3,-0.2,-0.2,-0.3,-0.2,-0.3,-0.1, 0.1,-0.4,-0.3,-0.2, 1.1, 0.2,-0.3,-0.4,-0.3,-0.2,-0.4}, //TRP
        {-0.2,-0.2,-0.2,-0.3,-0.2,-0.1,-0.2,-0.3, 0.2,-0.1,-0.1,-0.2,-0.1, 0.3,-0.3,-0.2,-0.2, 0.2, 0.7,-0.1,-0.3,-0.2,-0.1,-0.4}, //TYR
        { 0.0,-0.3,-0.3,-0.3,-0.1,-0.2,-0.2,-0.3,-0.3, 0.3, 0.1,-0.2, 0.1,-0.1,-0.2,-0.2, 0.0,-0.3,-0.1, 0.4,-0.3,-0.2,-0.1,-0.4}, //VAL
        {-0.2,-0.1, 0.3, 0.4,-0.3, 0.0, 0.1,-0.1, 0.0,-0.3,-0.4, 0.0,-0.3,-0.3,-0.2, 0.0,-0.1,-0.4,-0.3,-0.3, 0.4, 0.1,-0.1,-0.4}, //ASX
        {-0.1, 0.0, 0.0, 0.1,-0.3, 0.3, 0.4,-0.2, 0.0,-0.3,-0.3, 0.1,-0.1,-0.3,-0.1, 0.0,-0.1,-0.3,-0.2,-0.2, 0.1, 0.4,-0.1,-0.4}, //GLX
        { 0.0,-0.1,-0.1,-0.1,-0.2,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.2, 0.0, 0.0,-0.2,-0.1,-0.1,-0.1,-0.1,-0.1,-0.4}, //XXX
        {-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4, 0.1}  //GAP
      },
      //BLOSUM_45
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.5,-0.2,-0.1,-0.2,-0.1,-0.1,-0.1, 0.0,-0.2,-0.1,-0.1,-0.1,-0.1,-0.2,-0.1, 0.1, 0.0,-0.2,-0.2, 0.0,-0.1,-0.1, 0.0,-0.5}, //ALA
        {-0.2, 0.7, 0.0,-0.1,-0.3, 0.1, 0.0,-0.2, 0.0,-0.3,-0.2, 0.3,-0.1,-0.2,-0.2,-0.1,-0.1,-0.2,-0.1,-0.2,-0.1, 0.0,-0.1,-0.5}, //ARG
        {-0.1, 0.0, 0.6, 0.2,-0.2, 0.0, 0.0, 0.0, 0.1,-0.2,-0.3, 0.0,-0.2,-0.2,-0.2, 0.1, 0.0,-0.4,-0.2,-0.3, 0.4, 0.0,-0.1,-0.5}, //ASN
        {-0.2,-0.1, 0.2, 0.7,-0.3, 0.0, 0.2,-0.1, 0.0,-0.4,-0.3, 0.0,-0.3,-0.4,-0.1, 0.0,-0.1,-0.4,-0.2,-0.3, 0.5, 0.1,-0.1,-0.5}, //ASP
        {-0.1,-0.3,-0.2,-0.3, 1.2,-0.3,-0.3,-0.3,-0.3,-0.3,-0.2,-0.3,-0.2,-0.2,-0.4,-0.1,-0.1,-0.5,-0.3,-0.1,-0.2,-0.3,-0.2,-0.5}, //CYS
        {-0.1, 0.1, 0.0, 0.0,-0.3, 0.6, 0.2,-0.2, 0.1,-0.2,-0.2, 0.1, 0.0,-0.4,-0.1, 0.0,-0.1,-0.2,-0.1,-0.3, 0.0, 0.4,-0.1,-0.5}, //GLN
        {-0.1, 0.0, 0.0, 0.2,-0.3, 0.2, 0.6,-0.2, 0.0,-0.3,-0.2, 0.1,-0.2,-0.3, 0.0, 0.0,-0.1,-0.3,-0.2,-0.3, 0.1, 0.4,-0.1,-0.5}, //GLU
        { 0.0,-0.2, 0.0,-0.1,-0.3,-0.2,-0.2, 0.7,-0.2,-0.4,-0.3,-0.2,-0.2,-0.3,-0.2, 0.0,-0.2,-0.2,-0.3,-0.3,-0.1,-0.2,-0.1,-0.5}, //GLY
        {-0.2, 0.0, 0.1, 0.0,-0.3, 0.1, 0.0,-0.2, 1.0,-0.3,-0.2,-0.1, 0.0,-0.2,-0.2,-0.1,-0.2,-0.3, 0.2,-0.3, 0.0, 0.0,-0.1,-0.5}, //HIS
        {-0.1,-0.3,-0.2,-0.4,-0.3,-0.2,-0.3,-0.4,-0.3, 0.5, 0.2,-0.3, 0.2, 0.0,-0.2,-0.2,-0.1,-0.2, 0.0, 0.3,-0.3,-0.3,-0.1,-0.5}, //ILE
        {-0.1,-0.2,-0.3,-0.3,-0.2,-0.2,-0.2,-0.3,-0.2, 0.2, 0.5,-0.3, 0.2, 0.1,-0.3,-0.3,-0.1,-0.2, 0.0, 0.1,-0.3,-0.2,-0.1,-0.5}, //LEU
        {-0.1, 0.3, 0.0, 0.0,-0.3, 0.1, 0.1,-0.2,-0.1,-0.3,-0.3, 0.5,-0.1,-0.3,-0.1,-0.1,-0.1,-0.2,-0.1,-0.2, 0.0, 0.1,-0.1,-0.5}, //LYS
        {-0.1,-0.1,-0.2,-0.3,-0.2, 0.0,-0.2,-0.2, 0.0, 0.2, 0.2,-0.1, 0.6, 0.0,-0.2,-0.2,-0.1,-0.2, 0.0, 0.1,-0.2,-0.1,-0.1,-0.5}, //MET
        {-0.2,-0.2,-0.2,-0.4,-0.2,-0.4,-0.3,-0.3,-0.2, 0.0, 0.1,-0.3, 0.0, 0.8,-0.3,-0.2,-0.1, 0.1, 0.3, 0.0,-0.3,-0.3,-0.1,-0.5}, //PHE
        {-0.1,-0.2,-0.2,-0.1,-0.4,-0.1, 0.0,-0.2,-0.2,-0.2,-0.3,-0.1,-0.2,-0.3, 0.9,-0.1,-0.1,-0.3,-0.3,-0.3,-0.2,-0.1,-0.1,-0.5}, //PRO
        { 0.1,-0.1, 0.1, 0.0,-0.1, 0.0, 0.0, 0.0,-0.1,-0.2,-0.3,-0.1,-0.2,-0.2,-0.1, 0.4, 0.2,-0.4,-0.2,-0.1, 0.0, 0.0, 0.0,-0.5}, //SER
        { 0.0,-0.1, 0.0,-0.1,-0.1,-0.1,-0.1,-0.2,-0.2,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1, 0.2, 0.5,-0.3,-0.1, 0.0, 0.0,-0.1, 0.0,-0.5}, //THR
        {-0.2,-0.2,-0.4,-0.4,-0.5,-0.2,-0.3,-0.2,-0.3,-0.2,-0.2,-0.2,-0.2, 0.1,-0.3,-0.4,-0.3, 1.5, 0.3,-0.3,-0.4,-0.2,-0.2,-0.5}, //TRP
        {-0.2,-0.1,-0.2,-0.2,-0.3,-0.1,-0.2,-0.3, 0.2, 0.0, 0.0,-0.1, 0.0, 0.3,-0.3,-0.2,-0.1, 0.3, 0.8,-0.1,-0.2,-0.2,-0.1,-0.5}, //TYR
        { 0.0,-0.2,-0.3,-0.3,-0.1,-0.3,-0.3,-0.3,-0.3, 0.3, 0.1,-0.2, 0.1, 0.0,-0.3,-0.1, 0.0,-0.3,-0.1, 0.5,-0.3,-0.3,-0.1,-0.5}, //VAL
        {-0.1,-0.1, 0.4, 0.5,-0.2, 0.0, 0.1,-0.1, 0.0,-0.3,-0.3, 0.0,-0.2,-0.3,-0.2, 0.0, 0.0,-0.4,-0.2,-0.3, 0.4, 0.2,-0.1,-0.5}, //ASX
        {-0.1, 0.0, 0.0, 0.1,-0.3, 0.4, 0.4,-0.2, 0.0,-0.3,-0.2, 0.1,-0.1,-0.3,-0.1, 0.0,-0.1,-0.2,-0.2,-0.3, 0.2, 0.4,-0.1,-0.5}, //GLX
        { 0.0,-0.1,-0.1,-0.1,-0.2,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1, 0.0, 0.0,-0.2,-0.1,-0.1,-0.1,-0.1,-0.1,-0.5}, //XXX
        {-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5, 0.1}  //GAP
      }
    };

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a BLOSUM table
    //! @param BLOSUM_TABLE TableType to be used
    AAAssignmentBLOSUM::AAAssignmentBLOSUM( const TableType &BLOSUM_TABLE) :
      m_BLOSUMTable( BLOSUM_TABLE)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAAssignmentBLOSUM copied from this one
    AAAssignmentBLOSUM *AAAssignmentBLOSUM::Clone() const
    {
      return new AAAssignmentBLOSUM( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAAssignmentBLOSUM::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief return the mutation probability for two AAs given a table
    //! @param BLOSUM_TABLE TableType to be used
    //! @param AA_TYPE_A first AAType of interest
    //! @param AA_TYPE_B second AAType of interest
    //! @return the mutation probability for two AAs given a table
    double AAAssignmentBLOSUM::Probability
    (
      const TableType BLOSUM_TABLE,
      const biol::AAType &AA_TYPE_A,
      const biol::AAType &AA_TYPE_B
    )
    {
      return pow( 10, s_BLOSUMTable[ BLOSUM_TABLE][ AA_TYPE_A][ AA_TYPE_B]) / double( 20);
    }

    //! @brief returns the requested BLOSUM table as a matrix
    //! @param BLOSUM_TABLE requested BLOSUM table name
    //! @return the requested BLOSUM table as a matrix
    linal::Matrix< double> AAAssignmentBLOSUM::GetBLOSUMMatrix( const TableType &BLOSUM_TABLE)
    {
      // construct the matrix and return it
      return linal::Matrix< double>
      (
        biol::AATypes::s_NumberStandardAATypes + 4,
        biol::AATypes::s_NumberStandardAATypes + 4,
        &s_BLOSUMTable[ BLOSUM_TABLE][ 0][ 0]
      );
    }

    //! @brief returns the requested BLOSUM table as a matrix
    //! @param BLOSUM_TABLE requested BLOSUM table name
    //! @return the requested BLOSUM table as a matrix
    linal::VectorConstReference< double> AAAssignmentBLOSUM::GetBLOSUMRow
    (
      const TableType &BLOSUM_TABLE,
      const biol::AAType &AATYPE
    )
    {
      return
        linal::VectorConstReference< double>
        (
          biol::AATypes::s_NumberStandardAATypes + 4,
          s_BLOSUMTable[ BLOSUM_TABLE][ AATYPE]
        );
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates the score between two assigned members
    //! @param MEMBER_A amino acid A that is compared
    //! @param MEMBER_B amino acid A that is compared
    //! @return value from the m_BLOSUMTable for this combination of amino acids
    double AAAssignmentBLOSUM::operator()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
    {
      static const size_t matrix_dim( biol::AATypes::s_NumberStandardAATypes + 4);

      // check that the types are valid, if not, return undefined
      if( MEMBER_A.GetType() >= matrix_dim || MEMBER_B.GetType() >= matrix_dim)
      {
        return util::GetUndefined< double>();
      }

      return s_BLOSUMTable[ m_BLOSUMTable][ MEMBER_A.GetType()][ MEMBER_B.GetType()];
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAAssignmentBLOSUM::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_BLOSUMTable, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAAssignmentBLOSUM::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_BLOSUMTable, ISTREAM);

      // end
      return ISTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_assignment_identity.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AAAssignmentIdentity::s_Instance
    (
      GetObjectInstances().AddInstance( new AAAssignmentIdentity())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AAAssignmentIdentity::AAAssignmentIdentity()
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAAssignmentIdentity copied from this one
    AAAssignmentIdentity *AAAssignmentIdentity::Clone() const
    {
      return new AAAssignmentIdentity( *this);
    }

    //! @brief destructor
    AAAssignmentIdentity::~AAAssignmentIdentity()
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAAssignmentIdentity::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates the score between two assigned members
    //! @param MEMBER_A amino acid A that is compared
    //! @param MEMBER_B amino acid A that is compared
    //! @return 1.0 if they are identical - 0 if they are not
    double AAAssignmentIdentity::operator()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
    {
      return double( MEMBER_A.GetType() == MEMBER_B.GetType());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAAssignmentIdentity::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAAssignmentIdentity::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_assignment_mean_similarity_matrix.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_assignment_pam.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  ///////////
  // enums //
  ///////////

    //! @brief TableType as string
    //! @param TABLE_TYPE the TableType
    //! @return the string for the TableType
    const std::string &AAAssignmentPAM::GetTableDescriptor( const TableType &TABLE_TYPE)
    {
      static const std::string s_descriptors[] =
      {
        "PAM_100",
        "PAM_120",
        "PAM_160",
        "PAM_250",
        GetStaticClassName< TableType>()
      };

      return s_descriptors[ TABLE_TYPE];
    }

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AAAssignmentPAM::s_Instance
    (
      GetObjectInstances().AddInstance( new AAAssignmentPAM())
    );

    //! Pam and Blosum scoring matrices for amino acid replacement. Given is
    //! the log of probability of replacing aa i with aa j divided by freqency of aa i
    //! NOT mutiplied by 10 (as usually done). Note that with increasing sequence
    //! diversity move from Pam100 (45% sequence identity) to Pam250 (20% sequence identity)
    //! or from Blosum90 to Blosum45.
    //!
    //! Differences between PAM and BLOSSUM:
    //! PAM matrices are based on an explicit evolutionary model (that is, replacements
    //! are counted on the branches of a phylogenetic tree), whereas the Blosum matrices
    //! are based on an implicit rather than explicit model of evolution.
    //! The sequence variability in the alignments used to count replacements. The PAM
    //! matrices are based on mutations observed throughout a global alignment, this
    //! includes both highly conserved and highly mutable regions. The Blosum matrices
    //! are based only on highly conserved regions in series of alignments forbidden to
    //! contain gaps.
    //! The method used to count the replacements is different, unlike the PAM matrix,
    //! the Blosum procedure uses groups of sequences within which not all mutations are
    //! counted the same.
    //!
    //! Equivalent PAM and Blossum matrices: The following matrices are roughly equivalent...
    //! PAM100 <==> BLOSUM90
    //! PAM120 <==> BLOSUM80
    //! PAM160 <==> BLOSUM62
    //! PAM250 <==> BLOSUM45
    //!
    //! Generally speaking...
    //! The BLOSUM matrices are best for detecting local alignments.
    //! The BLOSUM62 matrix is the best for detecting the majority of weak protein similarities.
    //! The BLOSUM45 matrix is the best for detecting long and weak alignments.
    //!
    //! PAM (Point Accepted Mutation) matrix:
    //! Amino acid scoring matrices are traditionally PAM (Point Accepted Mutation)
    //! matrices which refer to various degrees of sensitivity depending on the evolutionary distance
    //! between sequence pairs. In this manner PAM40 is most sensitive for sequences 40 PAMs
    //! apart. PAM250 is for more distantly related sequences and is considered a good general matrix
    //! for protein database searching. For nucleotide sequence searching a simpler approach is used which either
    //! convert a PAM40 matrix into match/mismatch values which takes into consideration that a purine may be
    //! replaced by a purine and a pyrimidine by a pyrimidine.
    const double AAAssignmentPAM::s_PAMTable[][ biol::AATypes::s_NumberStandardAATypes + 4][ biol::AATypes::s_NumberStandardAATypes + 4] =
    {
      //PAM_100
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.4,-0.3,-0.1,-0.1,-0.3,-0.2, 0.0, 0.1,-0.3,-0.2,-0.3,-0.3,-0.2,-0.5, 0.1, 0.1, 0.1,-0.7,-0.4, 0.0,-0.1,-0.1,-0.1,-0.9},//ALA
        {-0.3, 0.7,-0.2,-0.4,-0.5, 0.1,-0.3,-0.5, 0.1,-0.3,-0.5, 0.2,-0.1,-0.6,-0.1,-0.1,-0.3, 0.1,-0.6,-0.4,-0.3,-0.1,-0.2,-0.9},//ARG
        {-0.1,-0.2, 0.5, 0.3,-0.5,-0.1, 0.1,-0.1, 0.2,-0.3,-0.4, 0.1,-0.4,-0.5,-0.2, 0.1, 0.0,-0.5,-0.2,-0.3, 0.4, 0.0,-0.1,-0.9},//ASN
        {-0.1,-0.4, 0.3, 0.5,-0.7, 0.0, 0.4,-0.1,-0.1,-0.4,-0.6,-0.1,-0.5,-0.8,-0.3,-0.1,-0.2,-0.9,-0.6,-0.4, 0.4, 0.3,-0.2,-0.9},//ASP
        {-0.3,-0.5,-0.5,-0.7, 0.9,-0.8,-0.8,-0.5,-0.4,-0.3,-0.8,-0.8,-0.7,-0.7,-0.4,-0.1,-0.4,-0.9,-0.1,-0.3,-0.6,-0.8,-0.5,-0.9},//CYS
        {-0.2, 0.1,-0.1, 0.0,-0.8, 0.6, 0.2,-0.3, 0.3,-0.4,-0.2, 0.0,-0.2,-0.7,-0.1,-0.2,-0.2,-0.7,-0.6,-0.3, 0.0, 0.5,-0.2,-0.9},//GLN
        { 0.0,-0.3, 0.1, 0.4,-0.8, 0.2, 0.5,-0.1,-0.1,-0.3,-0.5,-0.1,-0.4,-0.8,-0.2,-0.1,-0.2,-0.9,-0.5,-0.3, 0.3, 0.4,-0.2,-0.9},//GLU
        { 0.1,-0.5,-0.1,-0.1,-0.5,-0.3,-0.1, 0.5,-0.4,-0.5,-0.6,-0.3,-0.4,-0.6,-0.2, 0.0,-0.2,-0.9,-0.7,-0.3,-0.1,-0.2,-0.2,-0.9},//GLY
        {-0.3, 0.1, 0.2,-0.1,-0.4, 0.3,-0.1,-0.4, 0.7,-0.4,-0.3,-0.2,-0.4,-0.3,-0.1,-0.2,-0.3,-0.4,-0.1,-0.3, 0.1, 0.1,-0.2,-0.9},//HIS
        {-0.2,-0.3,-0.3,-0.4,-0.3,-0.4,-0.3,-0.5,-0.4, 0.6, 0.1,-0.3, 0.1, 0.0,-0.4,-0.3, 0.0,-0.7,-0.3, 0.3,-0.3,-0.3,-0.2,-0.9},//ILE
        {-0.3,-0.5,-0.4,-0.6,-0.8,-0.2,-0.5,-0.6,-0.3, 0.1, 0.6,-0.4, 0.3, 0.0,-0.4,-0.4,-0.3,-0.3,-0.3, 0.0,-0.5,-0.4,-0.3,-0.9},//LEU
        {-0.3, 0.2, 0.1,-0.1,-0.8, 0.0,-0.1,-0.3,-0.2,-0.3,-0.4, 0.5, 0.0,-0.7,-0.3,-0.1,-0.1,-0.6,-0.6,-0.4, 0.0,-0.1,-0.2,-0.9},//LYS
        {-0.2,-0.1,-0.4,-0.5,-0.7,-0.2,-0.4,-0.4,-0.4, 0.1, 0.3, 0.0, 0.9,-0.1,-0.4,-0.3,-0.1,-0.6,-0.5, 0.1,-0.4,-0.2,-0.2,-0.9},//MET
        {-0.5,-0.6,-0.5,-0.8,-0.7,-0.7,-0.8,-0.6,-0.3, 0.0, 0.0,-0.7,-0.1, 0.8,-0.6,-0.4,-0.5,-0.1, 0.4,-0.3,-0.6,-0.7,-0.4,-0.9},//PHE
        { 0.1,-0.1,-0.2,-0.3,-0.4,-0.1,-0.2,-0.2,-0.1,-0.4,-0.4,-0.3,-0.4,-0.6, 0.7, 0.0,-0.1,-0.7,-0.7,-0.3,-0.3,-0.1,-0.2,-0.9},//PRO
        { 0.1,-0.1, 0.1,-0.1,-0.1,-0.2,-0.1, 0.0,-0.2,-0.3,-0.4,-0.1,-0.3,-0.4, 0.0, 0.4, 0.2,-0.3,-0.4,-0.2, 0.0,-0.2,-0.1,-0.9},//SER
        { 0.1,-0.3, 0.0,-0.2,-0.4,-0.2,-0.2,-0.2,-0.3, 0.0,-0.3,-0.1,-0.1,-0.5,-0.1, 0.2, 0.5,-0.7,-0.4, 0.0,-0.1,-0.2,-0.1,-0.9},//THR
        {-0.7, 0.1,-0.5,-0.9,-0.9,-0.7,-0.9,-0.9,-0.4,-0.7,-0.3,-0.6,-0.6,-0.1,-0.7,-0.3,-0.7, 1.2,-0.2,-0.9,-0.6,-0.8,-0.6,-0.9},//TRP
        {-0.4,-0.6,-0.2,-0.6,-0.1,-0.6,-0.5,-0.7,-0.1,-0.3,-0.3,-0.6,-0.5, 0.4,-0.7,-0.4,-0.4,-0.2, 0.9,-0.4,-0.4,-0.6,-0.4,-0.9},//TYR
        { 0.0,-0.4,-0.3,-0.4,-0.3,-0.3,-0.3,-0.3,-0.3, 0.3, 0.0,-0.4, 0.1,-0.3,-0.3,-0.2, 0.0,-0.9,-0.4, 0.5,-0.4,-0.3,-0.2,-0.9},//VAL
        {-0.1,-0.3, 0.4, 0.4,-0.6, 0.0, 0.3,-0.1, 0.1,-0.3,-0.5, 0.0,-0.4,-0.6,-0.3, 0.0,-0.1,-0.6,-0.4,-0.4, 0.4, 0.2,-0.2,-0.9},//ASX
        {-0.1,-0.1, 0.0, 0.3,-0.8, 0.5, 0.4,-0.2, 0.1,-0.3,-0.4,-0.1,-0.2,-0.7,-0.1,-0.2,-0.2,-0.8,-0.6,-0.3, 0.2, 0.5,-0.2,-0.9},//GLX
        {-0.1,-0.2,-0.1,-0.2,-0.5,-0.2,-0.2,-0.2,-0.2,-0.2,-0.3,-0.2,-0.2,-0.4,-0.2,-0.1,-0.1,-0.6,-0.4,-0.2,-0.2,-0.2,-0.2,-0.9},//XXX
        {-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9, 0.1} //GAP
      },
      //PAM_120
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.3,-0.3,-0.1, 0.0,-0.3,-0.1, 0.0, 0.1,-0.3,-0.1,-0.3,-0.2,-0.2,-0.4, 0.1, 0.1, 0.1,-0.7,-0.4, 0.0, 0.0,-0.1,-0.1,-0.8},//ALA
        {-0.3, 0.6,-0.1,-0.3,-0.4, 0.1,-0.3,-0.4, 0.1,-0.2,-0.4, 0.2,-0.1,-0.5,-0.1,-0.1,-0.2, 0.1,-0.5,-0.3,-0.2,-0.1,-0.2,-0.8},//ARG
        {-0.1,-0.1, 0.4, 0.2,-0.5, 0.0, 0.1, 0.0, 0.2,-0.2,-0.4, 0.1,-0.3,-0.4,-0.2, 0.1, 0.0,-0.4,-0.2,-0.3, 0.3, 0.0,-0.1,-0.8},//ASN
        { 0.0,-0.3, 0.2, 0.5,-0.7, 0.1, 0.3, 0.0, 0.0,-0.3,-0.5,-0.1,-0.4,-0.7,-0.3, 0.0,-0.1,-0.8,-0.5,-0.3, 0.4, 0.3,-0.2,-0.8},//ASP
        {-0.3,-0.4,-0.5,-0.7, 0.9,-0.7,-0.7,-0.4,-0.4,-0.3,-0.7,-0.7,-0.6,-0.6,-0.4, 0.0,-0.3,-0.8,-0.1,-0.3,-0.6,-0.7,-0.4,-0.8},//CYS
        {-0.1, 0.1, 0.0, 0.1,-0.7, 0.6, 0.2,-0.3, 0.3,-0.3,-0.2, 0.0,-0.1,-0.6, 0.0,-0.2,-0.2,-0.6,-0.5,-0.3, 0.0, 0.4,-0.1,-0.8},//GLN
        { 0.0,-0.3, 0.1, 0.3,-0.7, 0.2, 0.5,-0.1,-0.1,-0.3,-0.4,-0.1,-0.3,-0.7,-0.2,-0.1,-0.2,-0.8,-0.5,-0.3, 0.3, 0.4,-0.1,-0.8},//GLU
        { 0.1,-0.4, 0.0, 0.0,-0.4,-0.3,-0.1, 0.5,-0.4,-0.4,-0.5,-0.3,-0.4,-0.5,-0.2, 0.1,-0.1,-0.8,-0.6,-0.2, 0.0,-0.2,-0.2,-0.8},//GLY
        {-0.3, 0.1, 0.2, 0.0,-0.4, 0.3,-0.1,-0.4, 0.7,-0.4,-0.3,-0.2,-0.4,-0.3,-0.1,-0.2,-0.3,-0.3,-0.1,-0.3, 0.1, 0.1,-0.2,-0.8},//HIS
        {-0.1,-0.2,-0.2,-0.3,-0.3,-0.3,-0.3,-0.4,-0.4, 0.6, 0.1,-0.3, 0.1, 0.0,-0.3,-0.2, 0.0,-0.6,-0.2, 0.3,-0.3,-0.3,-0.1,-0.8},//ILE
        {-0.3,-0.4,-0.4,-0.5,-0.7,-0.2,-0.4,-0.5,-0.3, 0.1, 0.5,-0.4, 0.3, 0.0,-0.3,-0.4,-0.3,-0.3,-0.2, 0.1,-0.4,-0.3,-0.2,-0.8},//LEU
        {-0.2, 0.2, 0.1,-0.1,-0.7, 0.0,-0.1,-0.3,-0.2,-0.3,-0.4, 0.5, 0.0,-0.7,-0.2,-0.1,-0.1,-0.5,-0.5,-0.4, 0.0,-0.1,-0.2,-0.8},//LYS
        {-0.2,-0.1,-0.3,-0.4,-0.6,-0.1,-0.3,-0.4,-0.4, 0.1, 0.3, 0.0, 0.8,-0.1,-0.3,-0.2,-0.1,-0.6,-0.4, 0.1,-0.4,-0.2,-0.2,-0.8},//MET
        {-0.4,-0.5,-0.4,-0.7,-0.6,-0.6,-0.7,-0.5,-0.3, 0.0, 0.0,-0.7,-0.1, 0.8,-0.5,-0.3,-0.4,-0.1, 0.4,-0.3,-0.5,-0.6,-0.3,-0.8},//PHE
        { 0.1,-0.1,-0.2,-0.3,-0.4, 0.0,-0.2,-0.2,-0.1,-0.3,-0.3,-0.2,-0.3,-0.5, 0.6, 0.1,-0.1,-0.7,-0.6,-0.2,-0.2,-0.1,-0.2,-0.8},//PRO
        { 0.1,-0.1, 0.1, 0.0, 0.0,-0.2,-0.1, 0.1,-0.2,-0.2,-0.4,-0.1,-0.2,-0.3, 0.1, 0.3, 0.2,-0.2,-0.3,-0.2, 0.0,-0.1,-0.1,-0.8},//SER
        { 0.1,-0.2, 0.0,-0.1,-0.3,-0.2,-0.2,-0.1,-0.3, 0.0,-0.3,-0.1,-0.1,-0.4,-0.1, 0.2, 0.4,-0.6,-0.3, 0.0, 0.0,-0.2,-0.1,-0.8},//THR
        {-0.7, 0.1,-0.4,-0.8,-0.8,-0.6,-0.8,-0.8,-0.3,-0.6,-0.3,-0.5,-0.6,-0.1,-0.7,-0.2,-0.6, 1.2,-0.2,-0.8,-0.6,-0.7,-0.5,-0.8},//TRP
        {-0.4,-0.5,-0.2,-0.5,-0.1,-0.5,-0.5,-0.6,-0.1,-0.2,-0.2,-0.5,-0.4, 0.4,-0.6,-0.3,-0.3,-0.2, 0.8,-0.3,-0.3,-0.5,-0.3,-0.8},//TYR
        { 0.0,-0.3,-0.3,-0.3,-0.3,-0.3,-0.3,-0.2,-0.3, 0.3, 0.1,-0.4, 0.1,-0.3,-0.2,-0.2, 0.0,-0.8,-0.3, 0.5,-0.3,-0.3,-0.1,-0.8},//VAL
        { 0.0,-0.2, 0.3, 0.4,-0.6, 0.0, 0.3, 0.0, 0.1,-0.3,-0.4, 0.0,-0.4,-0.5,-0.2, 0.0, 0.0,-0.6,-0.3,-0.3, 0.4, 0.2,-0.1,-0.8},//ASX
        {-0.1,-0.1, 0.0, 0.3,-0.7, 0.4, 0.4,-0.2, 0.1,-0.3,-0.3,-0.1,-0.2,-0.6,-0.1,-0.1,-0.2,-0.7,-0.5,-0.3, 0.2, 0.4,-0.1,-0.8},//GLX
        {-0.1,-0.2,-0.1,-0.2,-0.4,-0.1,-0.1,-0.2,-0.2,-0.1,-0.2,-0.2,-0.2,-0.3,-0.2,-0.1,-0.1,-0.5,-0.3,-0.1,-0.1,-0.1,-0.2,-0.8},//XXX
        {-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8, 0.1} //GAP
      },
      //PAM_160
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.2,-0.2, 0.0, 0.0,-0.2,-0.1, 0.0, 0.1,-0.2,-0.1,-0.2,-0.2,-0.1,-0.3, 0.1, 0.1, 0.1,-0.5,-0.3, 0.0, 0.0, 0.0, 0.0,-0.7},//ALA
        {-0.2, 0.6,-0.1,-0.2,-0.3, 0.1,-0.2,-0.3, 0.1,-0.2,-0.3, 0.3,-0.1,-0.4,-0.1,-0.1,-0.1, 0.1,-0.4,-0.3,-0.1, 0.0,-0.1,-0.7},//ARG
        { 0.0,-0.1, 0.3, 0.2,-0.4, 0.0, 0.1, 0.0, 0.2,-0.2,-0.3, 0.1,-0.2,-0.3,-0.1, 0.1, 0.0,-0.4,-0.2,-0.2, 0.2, 0.1, 0.0,-0.7},//ASN
        { 0.0,-0.2, 0.2, 0.4,-0.5, 0.1, 0.3, 0.0, 0.0,-0.3,-0.4, 0.0,-0.3,-0.6,-0.2, 0.0,-0.1,-0.6,-0.4,-0.3, 0.3, 0.2,-0.1,-0.7},//ASP
        {-0.2,-0.3,-0.4,-0.5, 0.9,-0.5,-0.5,-0.3,-0.3,-0.2,-0.6,-0.5,-0.5,-0.5,-0.3, 0.0,-0.2,-0.7, 0.0,-0.2,-0.4,-0.5,-0.3,-0.7},//CYS
        {-0.1, 0.1, 0.0, 0.1,-0.5, 0.5, 0.2,-0.2, 0.2,-0.2,-0.2, 0.0,-0.1,-0.5, 0.0,-0.1,-0.1,-0.5,-0.4,-0.2, 0.1, 0.3,-0.1,-0.7},//GLN
        { 0.0,-0.2, 0.1, 0.3,-0.5, 0.2, 0.4, 0.0, 0.0,-0.2,-0.3,-0.1,-0.2,-0.5,-0.1, 0.0,-0.1,-0.7,-0.4,-0.2, 0.2, 0.3,-0.1,-0.7},//GLU
        { 0.1,-0.3, 0.0, 0.0,-0.3,-0.2, 0.0, 0.4,-0.3,-0.3,-0.4,-0.2,-0.3,-0.4,-0.1, 0.1,-0.1,-0.7,-0.5,-0.2, 0.0,-0.1,-0.1,-0.7},//GLY
        {-0.2, 0.1, 0.2, 0.0,-0.3, 0.2, 0.0,-0.3, 0.6,-0.3,-0.2,-0.1,-0.3,-0.2,-0.1,-0.1,-0.2,-0.3, 0.0,-0.2, 0.1, 0.1,-0.1,-0.7},//HIS
        {-0.1,-0.2,-0.2,-0.3,-0.2,-0.2,-0.2,-0.3,-0.3, 0.5, 0.2,-0.2, 0.2, 0.0,-0.2,-0.2, 0.0,-0.5,-0.2, 0.3,-0.2,-0.2,-0.1,-0.7},//ILE
        {-0.2,-0.3,-0.3,-0.4,-0.6,-0.2,-0.3,-0.4,-0.2, 0.2, 0.5,-0.3, 0.3, 0.1,-0.3,-0.3,-0.2,-0.2,-0.2, 0.1,-0.4,-0.3,-0.2,-0.7},//LEU
        {-0.2, 0.3, 0.1, 0.0,-0.5, 0.0,-0.1,-0.2,-0.1,-0.2,-0.3, 0.4, 0.0,-0.5,-0.2,-0.1, 0.0,-0.4,-0.4,-0.3, 0.0, 0.0,-0.1,-0.7},//LYS
        {-0.1,-0.1,-0.2,-0.3,-0.5,-0.1,-0.2,-0.3,-0.3, 0.2, 0.3, 0.0, 0.7, 0.0,-0.2,-0.2,-0.1,-0.4,-0.3, 0.1,-0.3,-0.2,-0.1,-0.7},//MET
        {-0.3,-0.4,-0.3,-0.6,-0.5,-0.5,-0.5,-0.4,-0.2, 0.0, 0.1,-0.5, 0.0, 0.7,-0.4,-0.3,-0.3,-0.1, 0.5,-0.2,-0.4,-0.5,-0.3,-0.7},//PHE
        { 0.1,-0.1,-0.1,-0.2,-0.3, 0.0,-0.1,-0.1,-0.1,-0.2,-0.3,-0.2,-0.2,-0.4, 0.5, 0.1, 0.0,-0.5,-0.5,-0.2,-0.1,-0.1,-0.1,-0.7},//PRO
        { 0.1,-0.1, 0.1, 0.0, 0.0,-0.1, 0.0, 0.1,-0.1,-0.2,-0.3,-0.1,-0.2,-0.3, 0.1, 0.2, 0.1,-0.2,-0.3,-0.1, 0.0,-0.1, 0.0,-0.7},//SER
        { 0.1,-0.1, 0.0,-0.1,-0.2,-0.1,-0.1,-0.1,-0.2, 0.0,-0.2, 0.0,-0.1,-0.3, 0.0, 0.1, 0.3,-0.5,-0.3, 0.0, 0.0,-0.1, 0.0,-0.7},//THR
        {-0.5, 0.1,-0.4,-0.6,-0.7,-0.5,-0.7,-0.7,-0.3,-0.5,-0.2,-0.4,-0.4,-0.1,-0.5,-0.2,-0.5, 1.2,-0.1,-0.6,-0.5,-0.6,-0.4,-0.7},//TRP
        {-0.3,-0.4,-0.2,-0.4, 0.0,-0.4,-0.4,-0.5, 0.0,-0.2,-0.2,-0.4,-0.3, 0.5,-0.5,-0.3,-0.3,-0.1, 0.8,-0.3,-0.3,-0.4,-0.3,-0.7},//TYR
        { 0.0,-0.3,-0.2,-0.3,-0.2,-0.2,-0.2,-0.2,-0.2, 0.3, 0.1,-0.3, 0.1,-0.2,-0.2,-0.1, 0.0,-0.6,-0.3, 0.4,-0.2,-0.2,-0.1,-0.7},//VAL
        { 0.0,-0.1, 0.2, 0.3,-0.4, 0.1, 0.2, 0.0, 0.1,-0.2,-0.4, 0.0,-0.3,-0.4,-0.1, 0.0, 0.0,-0.5,-0.3,-0.2, 0.3, 0.2,-0.1,-0.7},//ASX
        { 0.0, 0.0, 0.1, 0.2,-0.5, 0.3, 0.3,-0.1, 0.1,-0.2,-0.3, 0.0,-0.2,-0.5,-0.1,-0.1,-0.1,-0.6,-0.4,-0.2, 0.2, 0.3,-0.1,-0.7},//GLX
        { 0.0,-0.1, 0.0,-0.1,-0.3,-0.1,-0.1,-0.1,-0.1,-0.1,-0.2,-0.1,-0.1,-0.3,-0.1, 0.0, 0.0,-0.4,-0.3,-0.1,-0.1,-0.1,-0.1,-0.7},//XXX
        {-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7,-0.7, 0.1} //GAP
      },
      //PAM_250
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.2,-0.2, 0.0, 0.0,-0.2, 0.0, 0.0, 0.1,-0.1,-0.1,-0.2,-0.1,-0.1,-0.3, 0.1, 0.1, 0.1,-0.6,-0.3, 0.0, 0.0, 0.0, 0.0,-0.8},//ALA
        {-0.2, 0.6, 0.0,-0.1,-0.4, 0.1,-0.1,-0.3, 0.2,-0.2,-0.3, 0.3, 0.0,-0.4, 0.0, 0.0,-0.1, 0.2,-0.4,-0.2,-0.1, 0.0,-0.1,-0.8},//ARG
        { 0.0, 0.0, 0.2, 0.2,-0.4, 0.1, 0.1, 0.0, 0.2,-0.2,-0.3, 0.1,-0.2,-0.3, 0.0, 0.1, 0.0,-0.4,-0.2,-0.2, 0.2, 0.1, 0.0,-0.8},//ASN
        { 0.0,-0.1, 0.2, 0.4,-0.5, 0.2, 0.3, 0.1, 0.1,-0.2,-0.4, 0.0,-0.3,-0.6,-0.1, 0.0, 0.0,-0.7,-0.4,-0.2, 0.3, 0.3,-0.1,-0.8},//ASP
        {-0.2,-0.4,-0.4,-0.5, 1.2,-0.5,-0.5,-0.3,-0.3,-0.2,-0.6,-0.5,-0.5,-0.4,-0.3, 0.0,-0.2,-0.8, 0.0,-0.2,-0.4,-0.5,-0.3,-0.8},//CYS
        { 0.0, 0.1, 0.1, 0.2,-0.5, 0.4, 0.2,-0.1, 0.3,-0.2,-0.2, 0.1,-0.1,-0.5, 0.0,-0.1,-0.1,-0.5,-0.4,-0.2, 0.1, 0.3,-0.1,-0.8},//GLN
        { 0.0,-0.1, 0.1, 0.3,-0.5, 0.2, 0.4, 0.0, 0.1,-0.2,-0.3, 0.0,-0.2,-0.5,-0.1, 0.0, 0.0,-0.7,-0.4,-0.2, 0.3, 0.3,-0.1,-0.8},//GLU
        { 0.1,-0.3, 0.0, 0.1,-0.3,-0.1, 0.0, 0.5,-0.2,-0.3,-0.4,-0.2,-0.3,-0.5, 0.0, 0.1, 0.0,-0.7,-0.5,-0.1, 0.0, 0.0,-0.1,-0.8},//GLY
        {-0.1, 0.2, 0.2, 0.1,-0.3, 0.3, 0.1,-0.2, 0.6,-0.2,-0.2, 0.0,-0.2,-0.2, 0.0,-0.1,-0.1,-0.3, 0.0,-0.2, 0.1, 0.2,-0.1,-0.8},//HIS
        {-0.1,-0.2,-0.2,-0.2,-0.2,-0.2,-0.2,-0.3,-0.2, 0.5, 0.2,-0.2, 0.2, 0.1,-0.2,-0.1, 0.0,-0.5,-0.1, 0.4,-0.2,-0.2,-0.1,-0.8},//ILE
        {-0.2,-0.3,-0.3,-0.4,-0.6,-0.2,-0.3,-0.4,-0.2, 0.2, 0.6,-0.3, 0.4, 0.2,-0.3,-0.3,-0.2,-0.2,-0.1, 0.2,-0.3,-0.3,-0.1,-0.8},//LEU
        {-0.1, 0.3, 0.1, 0.0,-0.5, 0.1, 0.0,-0.2, 0.0,-0.2,-0.3, 0.5, 0.0,-0.5,-0.1, 0.0, 0.0,-0.3,-0.4,-0.2, 0.1, 0.0,-0.1,-0.8},//LYS
        {-0.1, 0.0,-0.2,-0.3,-0.5,-0.1,-0.2,-0.3,-0.2, 0.2, 0.4, 0.0, 0.6, 0.0,-0.2,-0.2,-0.1,-0.4,-0.2, 0.2,-0.2,-0.2,-0.1,-0.8},//MET
        {-0.3,-0.4,-0.3,-0.6,-0.4,-0.5,-0.5,-0.5,-0.2, 0.1, 0.2,-0.5, 0.0, 0.9,-0.5,-0.3,-0.3, 0.0, 0.7,-0.1,-0.4,-0.5,-0.2,-0.8},//PHE
        { 0.1, 0.0, 0.0,-0.1,-0.3, 0.0,-0.1, 0.0, 0.0,-0.2,-0.3,-0.1,-0.2,-0.5, 0.6, 0.1, 0.0,-0.6,-0.5,-0.1,-0.1, 0.0,-0.1,-0.8},//PRO
        { 0.1, 0.0, 0.1, 0.0, 0.0,-0.1, 0.0, 0.1,-0.1,-0.1,-0.3, 0.0,-0.2,-0.3, 0.1, 0.2, 0.1,-0.2,-0.3,-0.1, 0.0, 0.0, 0.0,-0.8},//SER
        { 0.1,-0.1, 0.0, 0.0,-0.2,-0.1, 0.0, 0.0,-0.1, 0.0,-0.2, 0.0,-0.1,-0.3, 0.0, 0.1, 0.3,-0.5,-0.3, 0.0, 0.0,-0.1, 0.0,-0.8},//THR
        {-0.6, 0.2,-0.4,-0.7,-0.8,-0.5,-0.7,-0.7,-0.3,-0.5,-0.2,-0.3,-0.4, 0.0,-0.6,-0.2,-0.5, 1.7, 0.0,-0.6,-0.5,-0.6,-0.4,-0.8},//TRP
        {-0.3,-0.4,-0.2,-0.4, 0.0,-0.4,-0.4,-0.5, 0.0,-0.1,-0.1,-0.4,-0.2, 0.7,-0.5,-0.3,-0.3, 0.0, 1.0,-0.2,-0.3,-0.4,-0.2,-0.8},//TYR
        { 0.0,-0.2,-0.2,-0.2,-0.2,-0.2,-0.2,-0.1,-0.2, 0.4, 0.2,-0.2, 0.2,-0.1,-0.1,-0.1, 0.0,-0.6,-0.2, 0.4,-0.2,-0.2,-0.1,-0.8},//VAL
        { 0.0,-0.1, 0.2, 0.3,-0.4, 0.1, 0.3, 0.0, 0.1,-0.2,-0.3, 0.1,-0.2,-0.4,-0.1, 0.0, 0.0,-0.5,-0.3,-0.2, 0.3, 0.2,-0.1,-0.8},//ASX
        { 0.0, 0.0, 0.1, 0.3,-0.5, 0.3, 0.3, 0.0, 0.2,-0.2,-0.3, 0.0,-0.2,-0.5, 0.0, 0.0,-0.1,-0.6,-0.4,-0.2, 0.2, 0.3,-0.1,-0.8},//GLX
        { 0.0,-0.1, 0.0,-0.1,-0.3,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.1,-0.2,-0.1, 0.0, 0.0,-0.4,-0.2,-0.1,-0.1,-0.1,-0.1,-0.8},//XXX
        {-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8, 0.1} //GAP
      }
    };

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a PAM_TABLE
    //! @param PAM_TABLE Pam table to be used
    AAAssignmentPAM::AAAssignmentPAM( const TableType PAM_TABLE) :
      m_PAMTable( PAM_TABLE)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAAssignmentPAM copied from this one
    AAAssignmentPAM *AAAssignmentPAM::Clone() const
    {
      return new AAAssignmentPAM( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAAssignmentPAM::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the requested PAM table as a matrix
    //! @param PAM_TABLE requested PAM table name
    //! @return the requested PAM table as a matrix
    linal::Matrix< double> AAAssignmentPAM::GetPAMMatrix( const TableType PAM_TABLE)
    {
      // construct the matrix and return it
      return linal::Matrix< double>
      (
        biol::AATypes::s_NumberStandardAATypes + 4,
        biol::AATypes::s_NumberStandardAATypes + 4,
        &s_PAMTable[ PAM_TABLE][ 0][ 0]
      );
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates the score between two assigned members
    //! @param MEMBER_A amino acid A that is compared
    //! @param MEMBER_B amino acid A that is compared
    //! @return value from the m_PAMTable for this combination of amino acids
    double AAAssignmentPAM::operator()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
    {
      static const size_t matrix_dim( biol::AATypes::s_NumberStandardAATypes + 4);

      // check that the types are valid, if not, return undefined
      if( MEMBER_A.GetType() >= matrix_dim || MEMBER_B.GetType() >= matrix_dim)
      {
        return util::GetUndefined< double>();
      }

      // return matrix value for non-gaps
      return s_PAMTable[ m_PAMTable][ MEMBER_A.GetType()][ MEMBER_B.GetType()];
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAAssignmentPAM::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_PAMTable, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAAssignmentPAM::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_PAMTable, ISTREAM);

      // end
      return ISTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_assignment_phat.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  ///////////
  // enums //
  ///////////

    //! @brief TableType as string
    //! @param PHAT_TABLE the message level
    //! @return the TableType as string
    const std::string &AAAssignmentPHAT::GetTableTypeString( const AAAssignmentPHAT::TableType &PHAT_TABLE)
    {
      static const std::string s_phat_table_strings[] =
      {
        "PHAT_85",
        "PHAT_80",
        "PHAT_75",
        "PHAT_70",
        GetStaticClassName< TableType>()
      };

      return s_phat_table_strings[ PHAT_TABLE];
    }

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AAAssignmentPHAT::s_Instance
    (
      GetObjectInstances().AddInstance( new AAAssignmentPHAT())
    );

    //! The PHAT (Predicted Hydrophobic And Transmembrane) scoring matrices are built from predicted
    //! hydrophobic and transmembrane regions.
    //! It has been shown to perform better than BLOSUM (Henikoff and Henikoff, 1992),
    //! JTT-modified PAM (Jones, Taylor, Thornton, 1992) and other transmembrane matrices (Jones, Taylor,
    //! Thornton, 1994) at aligning transmembrane regions of proteins.
    //!
    //! The PHAT matrices are built from target frequencies obtained from BLOCKS predicted to be
    //! transmembrane by PHDhtm and background frequencies from hydrophobic and transmembrane
    //! regions as determined by Persson-Argos transmembrane propensity values.
    //! There are four matrices built on different levels of sequence identity attributed to
    //! PHDhtm (T) and Persson-Argos (B):
    //!
    //! PHAT T=85 (H = 0.5937), B=82 (H = 0.5949): Entropy =   0.6899, Expected =  -0.6002
    //! PHAT T=80 (H = 0.5550), B=78 (H = 0.5556): Entropy =   0.6124, Expected =  -0.5269
    //! PHAT T=75 (H = 0.5007), B=73 (H = 0.5038): Entropy =   0.5605, Expected =  -0.4732
    //! PHAT T=70 (H = 0.4318), B=66 (H = 0.4311): Entropy =   0.4795, Expected =  -0.3933
    //!
    //! It was found that PHAT T=75, B=73 worked best for transmembrane regions, although all
    //! PHAT matrices showed significant improvement over BLOSUM64, JTT-modified PAM and the
    //! JTT transmembrane matrix.
    //!
    //! Note: On the website, the values for amino acid X are different in the *.iij and *.bla files.
    //! The ones used here are the values from the *.iij files, which are a more accurate representation
    //! of the average values over                                                                                                                                                                                                     all the amino acids.
    //!
    //! http://blocks.fhcrc.org/sift/PHAT.html
    //! PHAT: a transmembrane-specific substitution matrix
    //! (Ng, Henikoff, Henikoff 2000 Bioinformatics 16: 760-766 + Errata in Bioinformatics 17:290)

    const double AAAssignmentPHAT::s_PHATTable[][ biol::AATypes::s_NumberStandardAATypes + 4][ biol::AATypes::s_NumberStandardAATypes + 4] =
    {
      //PHAT_85
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.3,-0.5,-0.1,-0.4, 0.0,-0.2,-0.4, 0.1,-0.2, 0.0, 0.0,-0.5,-0.1,-0.1,-0.3, 0.1, 0.0,-0.4,-0.3, 0.1,-0.2,-0.3, 0.0,-0.8}, //ALA
        {-0.5, 0.6,-0.2,-0.6,-0.6,-0.1,-0.5,-0.4,-0.3,-0.5,-0.4,-0.1,-0.4,-0.5,-0.6,-0.4,-0.4,-0.5,-0.5,-0.5,-0.3,-0.3,-0.1,-0.8}, //ARG
        {-0.1,-0.2, 0.8, 0.2,-0.1, 0.1,-0.1,-0.1, 0.3,-0.3,-0.2,-0.2,-0.2,-0.1,-0.3, 0.1, 0.0,-0.3, 0.1,-0.3, 0.7, 0.1,-0.1,-0.8}, //ASN
        {-0.4,-0.6, 0.2, 0.8,-0.6, 0.0, 0.4,-0.2,-0.1,-0.5,-0.5,-0.4,-0.4,-0.4,-0.5,-0.3,-0.4,-0.6,-0.3,-0.4, 0.4, 0.2,-0.1,-0.8}, //ASP
        { 0.0,-0.6,-0.1,-0.6, 0.5,-0.4,-0.6,-0.2,-0.5,-0.2,-0.1,-0.8,-0.1,-0.1,-0.7, 0.1, 0.0,-0.3,-0.2,-0.1,-0.2,-0.5,-0.2,-0.8}, //CYS
        {-0.2,-0.1, 0.1, 0.0,-0.4, 0.7, 0.0,-0.2, 0.1,-0.2,-0.2,-0.1,-0.1,-0.2,-0.3,-0.1,-0.2, 0.0,-0.1,-0.2, 0.1, 0.4,-0.1,-0.8}, //GLN
        {-0.4,-0.5,-0.1, 0.4,-0.6, 0.0, 0.8,-0.3,-0.1,-0.4,-0.4,-0.3,-0.4,-0.4,-0.4,-0.2,-0.4,-0.4,-0.3,-0.4, 0.1, 0.4,-0.1,-0.8}, //GLU
        { 0.1,-0.4,-0.1,-0.2,-0.2,-0.2,-0.3, 0.6,-0.3,-0.2,-0.2,-0.4,-0.1,-0.2,-0.3, 0.1,-0.1,-0.4,-0.3,-0.1,-0.1,-0.2,-0.1,-0.8}, //GLY
        {-0.2,-0.3, 0.3,-0.1,-0.5, 0.1,-0.1,-0.3, 0.8,-0.4,-0.3,-0.4,-0.3,-0.1,-0.6,-0.2,-0.2,-0.2, 0.1,-0.4, 0.2, 0.0,-0.1,-0.8}, //HIS
        { 0.0,-0.5,-0.3,-0.5,-0.2,-0.2,-0.4,-0.2,-0.4, 0.3, 0.1,-0.6, 0.2, 0.0,-0.4,-0.2, 0.0,-0.3,-0.2, 0.2,-0.3,-0.3,-0.1,-0.8}, //ILE
        { 0.0,-0.4,-0.2,-0.5,-0.1,-0.2,-0.4,-0.2,-0.3, 0.1, 0.3,-0.6, 0.2, 0.0,-0.4,-0.2, 0.0,-0.2,-0.2, 0.1,-0.3,-0.3,-0.1,-0.8}, //LEU
        {-0.5,-0.1,-0.2,-0.4,-0.8,-0.1,-0.3,-0.4,-0.4,-0.6,-0.6, 0.3,-0.4,-0.6,-0.3,-0.4,-0.4,-0.5,-0.4,-0.6,-0.2,-0.2,-0.1,-0.8}, //LYS
        {-0.1,-0.4,-0.2,-0.4,-0.1,-0.1,-0.4,-0.1,-0.3, 0.2, 0.2,-0.4, 0.5, 0.0,-0.3,-0.1, 0.1,-0.3,-0.2, 0.1,-0.2,-0.2,-0.1,-0.8}, //MET
        {-0.1,-0.5,-0.1,-0.4,-0.1,-0.2,-0.4,-0.2,-0.1, 0.0, 0.0,-0.6, 0.0, 0.4,-0.5,-0.1,-0.1, 0.0, 0.2,-0.1,-0.2,-0.3,-0.1,-0.8}, //PHE
        {-0.3,-0.6,-0.3,-0.5,-0.7,-0.3,-0.4,-0.3,-0.6,-0.4,-0.4,-0.3,-0.3,-0.5, 0.9,-0.3,-0.3,-0.5,-0.5,-0.4,-0.4,-0.4,-0.2,-0.8}, //PRO
        { 0.1,-0.4, 0.1,-0.3, 0.1,-0.1,-0.2, 0.1,-0.2,-0.2,-0.2,-0.4,-0.1,-0.1,-0.3, 0.4, 0.1,-0.4,-0.2,-0.1, 0.0,-0.2, 0.0,-0.8}, //SER
        { 0.0,-0.4, 0.0,-0.4, 0.0,-0.2,-0.4,-0.1,-0.2, 0.0, 0.0,-0.4, 0.1,-0.1,-0.3, 0.1, 0.3,-0.5,-0.2, 0.0,-0.1,-0.3, 0.0,-0.8}, //THR
        {-0.4,-0.5,-0.3,-0.6,-0.3, 0.0,-0.4,-0.4,-0.2,-0.3,-0.2,-0.5,-0.3, 0.0,-0.5,-0.4,-0.5, 0.8, 0.0,-0.3,-0.4,-0.2,-0.2,-0.8}, //TRP
        {-0.3,-0.5, 0.1,-0.3,-0.2,-0.1,-0.3,-0.3, 0.1,-0.2,-0.2,-0.4,-0.2, 0.2,-0.5,-0.2,-0.2, 0.0, 0.7,-0.2, 0.0,-0.2,-0.1,-0.8}, //TYR
        { 0.1,-0.5,-0.3,-0.4,-0.1,-0.2,-0.4,-0.1,-0.4, 0.2, 0.1,-0.6, 0.1,-0.1,-0.4,-0.1, 0.0,-0.3,-0.2, 0.3,-0.3,-0.3,-0.1,-0.8}, //VAL
        {-0.2,-0.3, 0.7, 0.4,-0.2, 0.1, 0.1,-0.1, 0.2,-0.3,-0.3,-0.2,-0.2,-0.2,-0.4, 0.0,-0.1,-0.4, 0.0,-0.3, 0.6, 0.0,-0.1,-0.8}, //ASX
        {-0.3,-0.3, 0.1, 0.2,-0.5, 0.4, 0.4,-0.2, 0.0,-0.3,-0.3,-0.2,-0.2,-0.3,-0.4,-0.2,-0.3,-0.2,-0.2,-0.3, 0.0, 0.4,-0.1,-0.8}, //GLX
        { 0.0,-0.4,-0.1,-0.4,-0.1,-0.2,-0.4,-0.1,-0.2, 0.0, 0.0,-0.5, 0.0, 0.0,-0.3,-0.1,-0.1,-0.3,-0.1, 0.0,-0.2,-0.4,-0.1,-0.8}, //XXX
        {-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8,-0.8, 0.1}  //GAP
      },
      //PHAT_80
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.5,-0.6,-0.2,-0.5, 0.0,-0.3,-0.5, 0.2,-0.3,-0.1,-0.1,-0.7,-0.1,-0.2,-0.4, 0.2, 0.1,-0.5,-0.3, 0.1,-0.3,-0.4, 0.0,-1.1}, //ALA
        {-0.6, 1.0,-0.3,-0.7,-0.8,-0.2,-0.6,-0.6,-0.5,-0.7,-0.6,-0.1,-0.6,-0.8,-0.8,-0.6,-0.6,-0.7,-0.6,-0.7,-0.4,-0.4,-0.1,-1.1}, //ARG
        {-0.2,-0.3, 1.1, 0.2,-0.2, 0.2, 0.0,-0.1, 0.4,-0.3,-0.3,-0.2,-0.2,-0.1,-0.4, 0.2, 0.0,-0.4, 0.1,-0.4, 0.8, 0.1,-0.1,-1.1}, //ASN
        {-0.5,-0.7, 0.2, 1.3,-0.7, 0.1, 0.7,-0.2,-0.1,-0.6,-0.6,-0.5,-0.5,-0.5,-0.6,-0.3,-0.5,-0.8,-0.4,-0.5, 0.6, 0.3,-0.1,-1.1}, //ASP
        { 0.0,-0.8,-0.2,-0.7, 0.7,-0.5,-0.7,-0.2,-0.7,-0.3,-0.2,-1.1,-0.2,-0.1,-1.0, 0.1,-0.1,-0.5,-0.2,-0.2,-0.4,-0.6,-0.2,-1.1}, //CYS
        {-0.3,-0.2, 0.2, 0.1,-0.5, 1.0, 0.1,-0.2, 0.2,-0.3,-0.3,-0.1,-0.1,-0.2,-0.4,-0.1,-0.3, 0.1, 0.0,-0.3, 0.1, 0.6,-0.1,-1.1}, //GLN
        {-0.5,-0.6, 0.0, 0.7,-0.7, 0.1, 1.2,-0.3,-0.1,-0.5,-0.6,-0.4,-0.5,-0.6,-0.5,-0.3,-0.5,-0.7,-0.3,-0.5, 0.2, 0.6,-0.1,-1.1}, //GLU
        { 0.2,-0.6,-0.1,-0.2,-0.2,-0.2,-0.3, 0.9,-0.4,-0.2,-0.2,-0.5,-0.1,-0.2,-0.4, 0.2,-0.1,-0.6,-0.3,-0.2,-0.1,-0.3,-0.1,-1.1}, //GLY
        {-0.3,-0.5, 0.4,-0.1,-0.7, 0.2,-0.1,-0.4, 1.1,-0.5,-0.4,-0.6,-0.4,-0.1,-0.7,-0.2,-0.3,-0.3, 0.3,-0.5, 0.3, 0.1,-0.1,-1.1}, //HIS
        {-0.1,-0.7,-0.3,-0.6,-0.3,-0.3,-0.5,-0.2,-0.5, 0.5, 0.2,-0.8, 0.3,-0.1,-0.5,-0.2,-0.1,-0.4,-0.3, 0.3,-0.4,-0.4,-0.1,-1.1}, //ILE
        {-0.1,-0.6,-0.3,-0.6,-0.2,-0.3,-0.6,-0.2,-0.4, 0.2, 0.4,-0.8, 0.2, 0.0,-0.5,-0.2,-0.1,-0.3,-0.2, 0.1,-0.4,-0.4,-0.1,-1.1}, //LEU
        {-0.7,-0.1,-0.2,-0.5,-1.1,-0.1,-0.4,-0.5,-0.6,-0.8,-0.8, 0.5,-0.6,-0.8,-0.5,-0.5,-0.6,-0.8,-0.5,-0.8,-0.3,-0.3,-0.1,-1.1}, //LYS
        {-0.1,-0.6,-0.2,-0.5,-0.2,-0.1,-0.5,-0.1,-0.4, 0.3, 0.2,-0.6, 0.6, 0.0,-0.6,-0.2, 0.0,-0.4,-0.3, 0.1,-0.3,-0.3,-0.1,-1.1}, //MET
        {-0.2,-0.8,-0.1,-0.5,-0.1,-0.2,-0.6,-0.2,-0.1,-0.1, 0.0,-0.8, 0.0, 0.6,-0.6,-0.2,-0.2, 0.0, 0.4,-0.1,-0.2,-0.4,-0.1,-1.1}, //PHE
        {-0.4,-0.8,-0.4,-0.6,-1.0,-0.4,-0.5,-0.4,-0.7,-0.5,-0.5,-0.5,-0.6,-0.6, 1.2,-0.4,-0.4,-0.7,-0.6,-0.5,-0.5,-0.5,-0.2,-1.1}, //PRO
        { 0.2,-0.6, 0.2,-0.3, 0.1,-0.1,-0.3, 0.2,-0.2,-0.2,-0.2,-0.5,-0.2,-0.2,-0.4, 0.6, 0.1,-0.5,-0.2,-0.2, 0.0,-0.2, 0.0,-1.1}, //SER
        { 0.1,-0.6, 0.0,-0.5,-0.1,-0.3,-0.5,-0.1,-0.3,-0.1,-0.1,-0.6, 0.0,-0.2,-0.4, 0.1, 0.4,-0.7,-0.3, 0.0,-0.2,-0.4, 0.0,-1.1}, //THR
        {-0.5,-0.7,-0.4,-0.8,-0.5, 0.1,-0.7,-0.6,-0.3,-0.4,-0.3,-0.8,-0.4, 0.0,-0.7,-0.5,-0.7, 1.2, 0.1,-0.5,-0.5,-0.3,-0.2,-1.1}, //TRP
        {-0.3,-0.6, 0.1,-0.4,-0.2, 0.0,-0.3,-0.3, 0.3,-0.3,-0.2,-0.5,-0.3, 0.4,-0.6,-0.2,-0.3, 0.1, 1.0,-0.3,-0.1,-0.2,-0.1,-1.1}, //TYR
        { 0.1,-0.7,-0.4,-0.5,-0.2,-0.3,-0.5,-0.2,-0.5, 0.3, 0.1,-0.8, 0.1,-0.1,-0.5,-0.2, 0.0,-0.5,-0.3, 0.4,-0.4,-0.4,-0.1,-1.1}, //VAL
        {-0.3,-0.4, 0.8, 0.6,-0.4, 0.1, 0.2,-0.1, 0.3,-0.4,-0.4,-0.3,-0.3,-0.2,-0.5, 0.0,-0.2,-0.5,-0.1,-0.4, 0.8, 0.1,-0.1,-1.1}, //ASX
        {-0.4,-0.4, 0.1, 0.3,-0.6, 0.6, 0.6,-0.3, 0.1,-0.4,-0.4,-0.3,-0.3,-0.4,-0.5,-0.2,-0.4,-0.3,-0.2,-0.4, 0.1, 0.6,-0.1,-1.1}, //GLX
        { 0.0,-0.6,-0.1,-0.4,-0.2,-0.2,-0.4,-0.1,-0.3, 0.0, 0.0,-0.7, 0.0, 0.0,-0.5,-0.1,-0.1,-0.4,-0.2, 0.0,-0.2,-0.5,-0.1,-1.1}, //XXX
        {-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1,-1.1, 0.1}  //GAP
      },
      //PHAT_75
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.5,-0.6,-0.2,-0.5, 0.1,-0.3,-0.5, 0.1,-0.3, 0.0,-0.1,-0.7,-0.1,-0.1,-0.3, 0.2, 0.0,-0.4,-0.3, 0.1,-0.3,-0.4, 0.0,-1.0}, //ALA
        {-0.6, 0.9,-0.3,-0.7,-0.8,-0.2,-0.6,-0.5,-0.4,-0.6,-0.6,-0.1,-0.6,-0.7,-0.7,-0.6,-0.6,-0.7,-0.6,-0.7,-0.4,-0.4,-0.6,-1.0}, //ARG
        {-0.2,-0.3, 1.1, 0.2,-0.2, 0.2, 0.0,-0.1, 0.4,-0.3,-0.3,-0.2,-0.2,-0.1,-0.4, 0.1,-0.1,-0.5, 0.2,-0.3, 0.8, 0.1,-0.1,-1.0}, //ASN
        {-0.5,-0.7, 0.2, 1.2,-0.7, 0.0, 0.6,-0.2,-0.1,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.4,-0.5,-0.7,-0.4,-0.5, 0.5, 0.3,-0.4,-1.0}, //ASP
        { 0.1,-0.8,-0.2,-0.7, 0.7,-0.5,-0.7,-0.2,-0.7,-0.3,-0.2,-1.0,-0.2, 0.0,-0.8, 0.1,-0.1,-0.4,-0.1,-0.2,-0.4,-0.6,-0.2,-1.0}, //CYS
        {-0.3,-0.2, 0.2, 0.0,-0.5, 0.9, 0.1,-0.2, 0.2,-0.3,-0.3,-0.1,-0.1,-0.2,-0.3,-0.1,-0.3, 0.1, 0.0,-0.3, 0.1, 0.6,-0.2,-1.0}, //GLN
        {-0.5,-0.6, 0.0, 0.6,-0.7, 0.1, 1.2,-0.3,-0.1,-0.5,-0.5,-0.4,-0.5,-0.5,-0.5,-0.3,-0.5,-0.7,-0.2,-0.5, 0.2, 0.6,-0.4,-1.0}, //GLU
        { 0.1,-0.5,-0.1,-0.2,-0.2,-0.2,-0.3, 0.9,-0.4,-0.2,-0.2,-0.5,-0.1,-0.2,-0.3, 0.1,-0.1,-0.5,-0.3,-0.2,-0.1,-0.2,-0.1,-1.0}, //GLY
        {-0.3,-0.4, 0.4,-0.1,-0.7, 0.2,-0.1,-0.4, 1.1,-0.5,-0.4,-0.5,-0.4,-0.2,-0.6,-0.2,-0.4,-0.3, 0.3,-0.5, 0.2, 0.1,-0.3,-1.0}, //HIS
        { 0.0,-0.6,-0.3,-0.5,-0.3,-0.3,-0.5,-0.2,-0.5, 0.5, 0.2,-0.7, 0.3, 0.0,-0.4,-0.2,-0.1,-0.4,-0.3, 0.3,-0.4,-0.4, 0.0,-1.0}, //ILE
        {-0.1,-0.6,-0.3,-0.5,-0.2,-0.3,-0.5,-0.2,-0.4, 0.2, 0.4,-0.7, 0.2, 0.1,-0.5,-0.2,-0.1,-0.3,-0.2, 0.1,-0.3,-0.4, 0.0,-1.0}, //LEU
        {-0.7,-0.1,-0.2,-0.5,-1.0,-0.1,-0.4,-0.5,-0.5,-0.7,-0.7, 0.5,-0.6,-0.7,-0.4,-0.5,-0.6,-0.8,-0.4,-0.8,-0.3,-0.3,-0.6,-1.0}, //LYS
        {-0.1,-0.6,-0.2,-0.5,-0.2,-0.1,-0.5,-0.1,-0.4, 0.3, 0.2,-0.6, 0.6, 0.0,-0.5,-0.2, 0.0,-0.4,-0.2, 0.1,-0.3,-0.3, 0.0,-1.0}, //MET
        {-0.1,-0.7,-0.1,-0.5, 0.0,-0.2,-0.5,-0.2,-0.2, 0.0, 0.1,-0.7, 0.0, 0.6,-0.5,-0.2,-0.2, 0.0, 0.4,-0.1,-0.3,-0.3, 0.0,-1.0}, //PHE
        {-0.3,-0.7,-0.4,-0.5,-0.8,-0.3,-0.5,-0.3,-0.6,-0.4,-0.5,-0.4,-0.5,-0.5, 1.3,-0.3,-0.4,-0.6,-0.5,-0.4,-0.4,-0.4,-0.4,-1.0}, //PRO
        { 0.2,-0.6, 0.1,-0.4, 0.1,-0.1,-0.3, 0.1,-0.2,-0.2,-0.2,-0.5,-0.2,-0.2,-0.3, 0.6, 0.1,-0.5,-0.2,-0.2, 0.0,-0.2,-0.1,-1.0}, //SER
        { 0.0,-0.6,-0.1,-0.5,-0.1,-0.3,-0.5,-0.1,-0.4,-0.1,-0.1,-0.6, 0.0,-0.2,-0.4, 0.1, 0.3,-0.7,-0.3, 0.0,-0.2,-0.4,-0.1,-1.0}, //THR
        {-0.4,-0.7,-0.5,-0.7,-0.4, 0.1,-0.7,-0.5,-0.3,-0.4,-0.3,-0.8,-0.4, 0.0,-0.6,-0.5,-0.7, 1.1, 0.1,-0.4,-0.5,-0.3,-0.3,-1.0}, //TRP
        {-0.3,-0.6, 0.2,-0.4,-0.1, 0.0,-0.2,-0.3, 0.3,-0.3,-0.2,-0.4,-0.2, 0.4,-0.5,-0.2,-0.3, 0.1, 1.1,-0.3, 0.0,-0.1,-0.1,-1.0}, //TYR
        { 0.1,-0.7,-0.3,-0.5,-0.2,-0.3,-0.5,-0.2,-0.5, 0.3, 0.1,-0.8, 0.1,-0.1,-0.4,-0.2, 0.0,-0.4,-0.3, 0.4,-0.4,-0.4, 0.0,-1.0}, //VAL
        {-0.3,-0.4, 0.8, 0.5,-0.4, 0.1, 0.2,-0.1, 0.2,-0.4,-0.3,-0.3,-0.3,-0.3,-0.4, 0.0,-0.2,-0.5, 0.0,-0.4, 0.7, 0.1,-0.2,-1.0}, //ASX
        {-0.4,-0.4, 0.1, 0.3,-0.6, 0.6, 0.6,-0.2, 0.1,-0.4,-0.4,-0.3,-0.3,-0.3,-0.4,-0.2,-0.4,-0.3,-0.1,-0.4, 0.1, 0.6,-0.4,-1.0}, //GLX
        { 0.0,-0.6,-0.1,-0.4,-0.2,-0.2,-0.4,-0.1,-0.3, 0.0, 0.0,-0.6, 0.0, 0.0,-0.4,-0.1,-0.1,-0.3,-0.1, 0.0,-0.2,-0.4,-0.1,-1.0}, //XXX
        {-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0, 0.1}  //GAP
      },
      //PHAT_70
      {
//        ALA  ARG  ASN  ASP  CYS  GLN  GLU  GLY  HIS  ILE  LEU  LYS  MET  PHE  PRO  SER  THR  TRP  TYR  VAL  ASX  GLX  XXX  GAP
        { 0.5,-0.5,-0.1,-0.4, 0.1,-0.2,-0.3, 0.2,-0.3, 0.0,-0.1,-0.5, 0.0,-0.1,-0.2, 0.2, 0.0,-0.3,-0.2, 0.1,-0.2,-0.3, 0.0,-0.9}, //ALA
        {-0.5, 0.9,-0.2,-0.6,-0.7,-0.1,-0.5,-0.4,-0.3,-0.6,-0.5, 0.0,-0.5,-0.6,-0.6,-0.5,-0.6,-0.6,-0.5,-0.6,-0.3,-0.3,-0.5,-0.9}, //ARG
        {-0.1,-0.2, 1.0, 0.2,-0.3, 0.2, 0.1, 0.0, 0.4,-0.3,-0.3,-0.2,-0.2,-0.2,-0.3, 0.2, 0.0,-0.3, 0.0,-0.3, 0.8, 0.1,-0.1,-0.9}, //ASN
        {-0.4,-0.6, 0.2, 1.2,-0.6, 0.0, 0.7,-0.1,-0.1,-0.5,-0.5,-0.4,-0.5,-0.4,-0.4,-0.3,-0.5,-0.5,-0.3,-0.4, 0.5, 0.3,-0.4,-0.9}, //ASP
        { 0.1,-0.7,-0.3,-0.6, 0.7,-0.5,-0.6,-0.2,-0.6,-0.3,-0.2,-0.9,-0.2,-0.1,-0.8, 0.1,-0.2,-0.4,-0.1,-0.1,-0.4,-0.5,-0.2,-0.9}, //CYS
        {-0.2,-0.1, 0.2, 0.0,-0.5, 0.9, 0.2,-0.1, 0.2,-0.2,-0.2,-0.1, 0.0,-0.2,-0.2,-0.1,-0.2, 0.0, 0.0,-0.3, 0.1, 0.6,-0.1,-0.9}, //GLN
        {-0.3,-0.5, 0.1, 0.7,-0.6, 0.2, 1.3,-0.2, 0.0,-0.4,-0.4,-0.4,-0.4,-0.4,-0.4,-0.2,-0.4,-0.5,-0.2,-0.4, 0.2, 0.7,-0.3,-0.9}, //GLU
        { 0.2,-0.4, 0.0,-0.1,-0.2,-0.1,-0.2, 0.9,-0.3,-0.2,-0.2,-0.4,-0.1,-0.1,-0.2, 0.2,-0.1,-0.4,-0.2,-0.2,-0.1,-0.1,-0.1,-0.9}, //GLY
        {-0.3,-0.3, 0.4,-0.1,-0.6, 0.2, 0.0,-0.3, 1.0,-0.4,-0.4,-0.4,-0.4,-0.2,-0.5,-0.2,-0.4,-0.2, 0.4,-0.4, 0.3, 0.1,-0.3,-0.9}, //HIS
        { 0.0,-0.6,-0.3,-0.5,-0.3,-0.2,-0.4,-0.2,-0.4, 0.5, 0.2,-0.6, 0.2, 0.0,-0.4,-0.2,-0.1,-0.3,-0.2, 0.3,-0.3,-0.3, 0.0,-0.9}, //ILE
        {-0.1,-0.5,-0.3,-0.5,-0.2,-0.2,-0.4,-0.2,-0.4, 0.2, 0.3,-0.6, 0.2, 0.0,-0.4,-0.2,-0.2,-0.3,-0.2, 0.1,-0.3,-0.3, 0.0,-0.9}, //LEU
        {-0.5, 0.0,-0.2,-0.4,-0.9,-0.1,-0.4,-0.4,-0.4,-0.6,-0.6, 0.5,-0.5,-0.6,-0.3,-0.4,-0.5,-0.6,-0.4,-0.7,-0.2,-0.2,-0.5,-0.9}, //LYS
        { 0.0,-0.5,-0.2,-0.5,-0.2, 0.0,-0.4,-0.1,-0.4, 0.2, 0.2,-0.5, 0.6, 0.0,-0.4,-0.1, 0.0,-0.3,-0.2, 0.1,-0.3,-0.2, 0.0,-0.9}, //MET
        {-0.1,-0.6,-0.2,-0.4,-0.1,-0.2,-0.4,-0.1,-0.2, 0.0, 0.0,-0.6, 0.0, 0.6,-0.5,-0.1,-0.2, 0.1, 0.4,-0.1,-0.2,-0.3, 0.0,-0.9}, //PHE
        {-0.2,-0.6,-0.3,-0.4,-0.8,-0.2,-0.4,-0.2,-0.5,-0.4,-0.4,-0.3,-0.4,-0.5, 1.2,-0.3,-0.3,-0.5,-0.4,-0.4,-0.3,-0.3,-0.3,-0.9}, //PRO
        { 0.2,-0.5, 0.2,-0.3, 0.1,-0.1,-0.2, 0.2,-0.2,-0.2,-0.2,-0.4,-0.1,-0.1,-0.3, 0.6, 0.1,-0.4,-0.1,-0.1, 0.0,-0.1,-0.1,-0.9}, //SER
        { 0.0,-0.6, 0.0,-0.5,-0.2,-0.2,-0.4,-0.1,-0.4,-0.1,-0.2,-0.5, 0.0,-0.2,-0.3, 0.1, 0.2,-0.6,-0.3,-0.1,-0.2,-0.3,-0.1,-0.9}, //THR
        {-0.3,-0.6,-0.3,-0.5,-0.4, 0.0,-0.5,-0.4,-0.2,-0.3,-0.3,-0.6,-0.3, 0.1,-0.5,-0.4,-0.6, 1.1, 0.1,-0.3,-0.4,-0.2,-0.3,-0.9}, //TRP
        {-0.2,-0.5, 0.0,-0.3,-0.1, 0.0,-0.2,-0.2, 0.4,-0.2,-0.2,-0.4,-0.2, 0.4,-0.4,-0.1,-0.3, 0.1, 1.0,-0.3,-0.1,-0.1,-0.1,-0.9}, //TYR
        { 0.1,-0.6,-0.3,-0.4,-0.1,-0.3,-0.4,-0.2,-0.4, 0.3, 0.1,-0.7, 0.1,-0.1,-0.4,-0.1,-0.1,-0.3,-0.3, 0.3,-0.3,-0.3, 0.0,-0.9}, //VAL
        {-0.2,-0.3, 0.8, 0.5,-0.4, 0.1, 0.2,-0.1, 0.3,-0.3,-0.3,-0.2,-0.3,-0.2,-0.3, 0.0,-0.2,-0.4,-0.1,-0.3, 0.7, 0.1,-0.2,-0.9}, //ASX
        {-0.3,-0.3, 0.1, 0.3,-0.5, 0.6, 0.7,-0.1, 0.1,-0.3,-0.3,-0.2,-0.2,-0.3,-0.3,-0.1,-0.3,-0.2,-0.1,-0.3, 0.1, 0.6,-0.3,-0.9}, //GLX
        { 0.0,-0.5,-0.1,-0.4,-0.2,-0.1,-0.3,-0.1,-0.3, 0.0, 0.0,-0.5, 0.0, 0.0,-0.3,-0.1,-0.1,-0.3,-0.1, 0.0,-0.2,-0.3,-0.1,-0.9}, //XXX
        {-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9,-0.9, 0.1}  //GAP
      }
    };

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a PHAT table
    //! @param PHAT_TABLE TableType to be used
    AAAssignmentPHAT::AAAssignmentPHAT( const TableType &PHAT_TABLE) :
      m_PHATTable( PHAT_TABLE)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAAssignmentPHAT copied from this one
    AAAssignmentPHAT *AAAssignmentPHAT::Clone() const
    {
      return new AAAssignmentPHAT( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAAssignmentPHAT::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the requested PHAT table as a matrix
    //! @param PHAT_TABLE requested Phat table name
    //! @return the requested PHAT table as a matrix
    linal::Matrix< double> AAAssignmentPHAT::GetPHATMatrix( const TableType &PHAT_TABLE)
    {
      // construct the matrix and return it
      return linal::Matrix< double>
      (
        biol::AATypes::s_NumberStandardAATypes + 4,
        biol::AATypes::s_NumberStandardAATypes + 4,
        &s_PHATTable[ PHAT_TABLE][ 0][ 0]
      );
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief return the mutation probability for two AAs given a table
    //! @param PHAT_TABLE TableType to be used
    //! @param AA_TYPE_A first AAType of interest
    //! @param AA_TYPE_B second AAType of interest
    //! @return the mutation probability for two AAs given a table
    double AAAssignmentPHAT::Probability
    (
      const TableType &PHAT_TABLE,
      const biol::AAType &AA_TYPE_A,
      const biol::AAType &AA_TYPE_B
    )
    {
      return pow( 10, s_PHATTable[ PHAT_TABLE][ AA_TYPE_A][ AA_TYPE_B]) / double( 20);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates the score between two assigned members
    //! @param MEMBER_A amino acid A that is compared
    //! @param MEMBER_B amino acid A that is compared
    //! @return value from the m_PHATTable for this combination of amino acids
    double AAAssignmentPHAT::operator()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
    {
      static const size_t matrix_dim( biol::AATypes::s_NumberStandardAATypes + 4);

      // check that the types are valid, if not, return undefined
      if( MEMBER_A.GetType() >= matrix_dim || MEMBER_B.GetType() >= matrix_dim)
      {
        return util::GetUndefined< double>();
      }

      return s_PHATTable[ m_PHATTable][ MEMBER_A.GetType()][ MEMBER_B.GetType()];
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAAssignmentPHAT::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_PHATTable, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAAssignmentPHAT::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_PHATTable, ISTREAM);

      // end
      return ISTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_assignment_property.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AAAssignmentProperty::s_Instance
    (
      GetObjectInstances().AddInstance( new AAAssignmentProperty())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor
    //! @param PROPERTY property that will be compared
    AAAssignmentProperty::AAAssignmentProperty( const biol::AATypeData::PropertyType PROPERTY) :
      m_Property( PROPERTY)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAAssignmentProperty copied from this one
    AAAssignmentProperty *AAAssignmentProperty::Clone() const
    {
      return new AAAssignmentProperty( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAAssignmentProperty::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator that calculates the score between two assigned members
    //! @param MEMBER_A amino acid A that is compared
    //! @param MEMBER_B amino acid A that is compared
    //! @return difference of property values of the two aminoacids < 0.0
    double AAAssignmentProperty::operator()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
    {
      return -math::Absolute( MEMBER_A.GetType()->GetAAProperty( m_Property) - MEMBER_B.GetType()->GetAAProperty( m_Property));
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAAssignmentProperty::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Property, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAAssignmentProperty::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Property, ISTREAM);

      // end
      return ISTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_assignments.h"

// includes from bcl - sorted alphabetically
#include "math/bcl_math_z_score.h"
#include "score/bcl_score_aa_assignment_blast_profile.h"
#include "score/bcl_score_aa_assignment_blosum.h"
#include "score/bcl_score_aa_assignment_identity.h"
#include "score/bcl_score_aa_assignment_pam.h"
#include "score/bcl_score_aa_assignment_phat.h"
#include "score/bcl_score_aa_assignment_property.h"
#include "score/bcl_score_aa_assignment_ss_prediction.h"
#include "util/bcl_util_enumerate.hpp"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AAAssignments::AAAssignments() :
      e_IDENTITY(           AddEnum( "identity"      , util::CloneToShPtr( score::AAAssignmentIdentity()                                                           ))),
      e_PAM100(             AddEnum( "pam100"        , util::CloneToShPtr( score::AAAssignmentPAM( score::AAAssignmentPAM::e_PAM_100)                              ))),
      e_PAM120(             AddEnum( "pam120"        , util::CloneToShPtr( score::AAAssignmentPAM( score::AAAssignmentPAM::e_PAM_120)                              ))),
      e_PAM160(             AddEnum( "pam160"        , util::CloneToShPtr( score::AAAssignmentPAM( score::AAAssignmentPAM::e_PAM_160)                              ))),
      e_PAM250(             AddEnum( "pam250"        , util::CloneToShPtr( score::AAAssignmentPAM( score::AAAssignmentPAM::e_PAM_250)                              ))),
      e_BLOSUM90(           AddEnum( "blosum90"      , util::CloneToShPtr( score::AAAssignmentBLOSUM( score::AAAssignmentBLOSUM::e_BLOSUM_90)                      ))),
      e_BLOSUM80(           AddEnum( "blosum80"      , util::CloneToShPtr( score::AAAssignmentBLOSUM( score::AAAssignmentBLOSUM::e_BLOSUM_80)                      ))),
      e_BLOSUM62(           AddEnum( "blosum62"      , util::CloneToShPtr( score::AAAssignmentBLOSUM( score::AAAssignmentBLOSUM::e_BLOSUM_62)                      ))),
      e_BLOSUM45(           AddEnum( "blosum45"      , util::CloneToShPtr( score::AAAssignmentBLOSUM( score::AAAssignmentBLOSUM::e_BLOSUM_45)                      ))),
      e_PHAT85(             AddEnum( "phat85"        , util::CloneToShPtr( score::AAAssignmentPHAT( score::AAAssignmentPHAT::e_PHAT_85)                            ))),
      e_PHAT80(             AddEnum( "phat80"        , util::CloneToShPtr( score::AAAssignmentPHAT( score::AAAssignmentPHAT::e_PHAT_80)                            ))),
      e_PHAT75(             AddEnum( "phat75"        , util::CloneToShPtr( score::AAAssignmentPHAT( score::AAAssignmentPHAT::e_PHAT_75)                            ))),
      e_PHAT70(             AddEnum( "phat70"        , util::CloneToShPtr( score::AAAssignmentPHAT( score::AAAssignmentPHAT::e_PHAT_70)                            ))),
      e_BLAST(              AddEnum( "blast"         , util::CloneToShPtr( score::AAAssignmentBlastProfile()                                                       ))),
      e_PSIPRED(            AddEnum( "psipred"       , util::CloneToShPtr( score::AAAssignmentSSPrediction( sspred::GetMethods().e_PSIPRED)                        ))),
      e_JUFO(               AddEnum( "jufo"          , util::CloneToShPtr( score::AAAssignmentSSPrediction( sspred::GetMethods().e_JUFO9D)                         ))),
      e_SAM(                AddEnum( "sam"           , util::CloneToShPtr( score::AAAssignmentSSPrediction( sspred::GetMethods().e_SAM)                            ))),
      e_TMHMM(              AddEnum( "tmhmm"         , util::CloneToShPtr( score::AAAssignmentSSPrediction( sspred::GetMethods().e_TMHMM)                          ))),
      e_TMMOD(              AddEnum( "tmmod"         , util::CloneToShPtr( score::AAAssignmentSSPrediction( sspred::GetMethods().e_TMMOD)                          ))),
      e_B2TMPRED(           AddEnum( "b2tmpred"      , util::CloneToShPtr( score::AAAssignmentSSPrediction( sspred::GetMethods().e_B2TMPRED)                       ))),
      e_PROFTMB(            AddEnum( "proftmb"       , util::CloneToShPtr( score::AAAssignmentSSPrediction( sspred::GetMethods().e_PROFTMB)                        ))),
      e_CONPRED(            AddEnum( "conpred"       , util::CloneToShPtr( score::AAAssignmentSSPrediction( sspred::GetMethods().e_CONPRED)                        ))),
      e_STERICAL_PARAMETER( AddEnum( "steric"        , util::CloneToShPtr( score::AAAssignmentProperty( biol::AATypeData::e_StericalParameter)                     ))),
      e_POLARIZABILITY(     AddEnum( "polarizability", util::CloneToShPtr( score::AAAssignmentProperty( biol::AATypeData::e_Polarizability)                        ))),
      e_VOLUME(             AddEnum( "volume"        , util::CloneToShPtr( score::AAAssignmentProperty( biol::AATypeData::e_Volume)                                ))),
      e_HYDROPHOBICITY(     AddEnum( "hydrophobicity", util::CloneToShPtr( score::AAAssignmentProperty( biol::AATypeData::e_Hydrophobicity)                        ))),
      e_ISOELECTRIC_POINT(  AddEnum( "isoelectric"   , util::CloneToShPtr( score::AAAssignmentProperty( biol::AATypeData::e_IsoelectricPoint)                      ))),
      e_TFE_WHITE(          AddEnum( "tfe_white"     , util::CloneToShPtr( score::AAAssignmentProperty( biol::AATypeData::e_TransferFreeEnergyWhimleyWhite)        ))),
      e_TFE_ENGELMAN(       AddEnum( "tfe_engelman"  , util::CloneToShPtr( score::AAAssignmentProperty( biol::AATypeData::e_TransferFreeEnergyEngelmanSeitzGoldman))))
    {
      m_ZScores[ e_IDENTITY          ] = util::ShPtr< math::ZScore>( new math::ZScore(  0.0000, 1.0000));
      m_ZScores[ e_PAM100            ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.1951, 0.3109));
      m_ZScores[ e_PAM120            ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.1581, 0.2803));
      m_ZScores[ e_PAM160            ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.1108, 0.2340));
      m_ZScores[ e_PAM250            ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.0824, 0.2498));
      m_ZScores[ e_BLOSUM90          ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.1698, 0.2586));
      m_ZScores[ e_BLOSUM80          ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.2111, 0.3580));
      m_ZScores[ e_BLOSUM62          ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.0967, 0.2088));
      m_ZScores[ e_BLOSUM45          ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.0821, 0.2273));
      m_ZScores[ e_PHAT85            ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.1431, 0.3114));
      m_ZScores[ e_PHAT80            ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.1676, 0.4248));
      m_ZScores[ e_PHAT75            ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.1469, 0.3990));
      m_ZScores[ e_PHAT70            ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.0895, 0.3552));
      m_ZScores[ e_BLAST             ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.0072, 0.0881));
      m_ZScores[ e_PSIPRED           ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.1431, 0.4728));
      m_ZScores[ e_JUFO              ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.0388, 0.2451));
      m_ZScores[ e_SAM               ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.0056, 0.2076));
      m_ZScores[ e_TMHMM             ] = util::ShPtr< math::ZScore>( new math::ZScore(  0.0000, 0.5000));
      m_ZScores[ e_TMMOD             ] = util::ShPtr< math::ZScore>( new math::ZScore(  0.0000, 0.5000));
      m_ZScores[ e_B2TMPRED          ] = util::ShPtr< math::ZScore>( new math::ZScore(  0.0000, 0.5000));
      m_ZScores[ e_PROFTMB           ] = util::ShPtr< math::ZScore>( new math::ZScore(  0.0000, 0.5000));
      m_ZScores[ e_CONPRED           ] = util::ShPtr< math::ZScore>( new math::ZScore(  0.0000, 0.5000));
      m_ZScores[ e_STERICAL_PARAMETER] = util::ShPtr< math::ZScore>( new math::ZScore( -1.1514, 0.8981));
      m_ZScores[ e_POLARIZABILITY    ] = util::ShPtr< math::ZScore>( new math::ZScore( -0.1061, 0.0814));
      m_ZScores[ e_VOLUME            ] = util::ShPtr< math::ZScore>( new math::ZScore( -1.9938, 1.5660));
      m_ZScores[ e_HYDROPHOBICITY    ] = util::ShPtr< math::ZScore>( new math::ZScore( -1.0737, 0.7871));
      m_ZScores[ e_ISOELECTRIC_POINT ] = util::ShPtr< math::ZScore>( new math::ZScore( -1.6180, 1.8058));
      m_ZScores[ e_TFE_WHITE         ] = util::ShPtr< math::ZScore>( new math::ZScore( -1.8252, 1.4175));
      m_ZScores[ e_TFE_ENGELMAN      ] = util::ShPtr< math::ZScore>( new math::ZScore( -5.3870, 4.7486));

      m_ScoreFile[ e_BLAST   ] = ".ascii";
      m_ScoreFile[ e_PSIPRED ] = ".psipred_ss2";
      m_ScoreFile[ e_JUFO    ] = ".jufo";
      m_ScoreFile[ e_SAM     ] = ".rdb6";
      m_ScoreFile[ e_TMHMM   ] = ".tmhmm";
      m_ScoreFile[ e_TMMOD   ] = ".tmmod";
      m_ScoreFile[ e_B2TMPRED] = ".tmpdb";
      m_ScoreFile[ e_PROFTMB ] = ".proftmb";
      m_ScoreFile[ e_CONPRED ] = ".conpred";
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAAssignments::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief z-score associated with that enum
    //! @param ASSIGNMENT_ENUM score
    //! @return z-score to normalize the result of the energy function
    const util::ShPtr< math::ZScore> &AAAssignments::GetZScore( const AAAssignment &ASSIGNMENT_ENUM) const
    {
      // find the zscore for given enum
      const storage::Map< AAAssignment, util::ShPtr< math::ZScore> >::const_iterator itr( m_ZScores.Find( ASSIGNMENT_ENUM));
      if( itr == m_ZScores.End())
      {
        static const util::ShPtr< math::ZScore> s_empty;
        return s_empty;
      }

      // end
      return itr->second;
    }

    //! @brief score file extension, if score requires file to be read
    //! @param ASSIGNMENT_ENUM score
    //! @return the file extension required for the score - empty if non is required
    const std::string &AAAssignments::GetFileExtension( const AAAssignment &ASSIGNMENT_ENUM) const
    {
      // find the file extension
      const storage::Map< AAAssignment, std::string>::const_iterator itr( m_ScoreFile.Find( ASSIGNMENT_ENUM));

      // check that it exists
      if( itr == m_ScoreFile.End())
      {
        static const std::string s_empty;
        return s_empty;
      }

      // return the string
      return itr->second;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief construct on access function for all AAAssignments
    //! @return reference to only instances of AAAssignments
    AAAssignments &GetAAAssignments()
    {
      return AAAssignments::GetEnums();
    }

  } // namespace score

  namespace util
  {

  /////////////////////////////
  // explicit instantiations //
  /////////////////////////////

    template class BCL_API Enumerate< ShPtr< function::BinaryInterface< const biol::AABase, const biol::AABase, double> >, score::AAAssignments>;

  } // namespace util
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_assignment_ss_prediction.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "linal/bcl_linal_vector_operations.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AAAssignmentSSPrediction::s_Instance
    (
      GetObjectInstances().AddInstance( new AAAssignmentSSPrediction())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AAAssignmentSSPrediction::AAAssignmentSSPrediction() :
      m_SSMethod( sspred::GetMethods().e_Undefined)
    {
    }

    //! @brief construct from SSMethod
    //! @param SS_METHOD method to be scored
    AAAssignmentSSPrediction::AAAssignmentSSPrediction( const sspred::Method SS_METHOD) :
      m_SSMethod( SS_METHOD)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAAssignmentSSPrediction copied from this one
    AAAssignmentSSPrediction *AAAssignmentSSPrediction::Clone() const
    {
      return new AAAssignmentSSPrediction( *this);
    }

    //! @brief destructor
    AAAssignmentSSPrediction::~AAAssignmentSSPrediction()
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAAssignmentSSPrediction::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator that calculates the score between two assigned members
    //! @param MEMBER_A amino acid A that is compared
    //! @param MEMBER_B amino acid A that is compared
    //! @return logarithm of the scalar product of the consensus SSPrediction for the given m_SSMethod normalized by the NumberSSTypes - at least 1
    double AAAssignmentSSPrediction::operator()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
    {
      util::SiPtr< const sspred::MethodInterface> prediction_a( MEMBER_A.GetSSPrediction( m_SSMethod));
      util::SiPtr< const sspred::MethodInterface> prediction_b( MEMBER_B.GetSSPrediction( m_SSMethod));

      // check definition
      BCL_Assert
      (
        prediction_a.IsDefined() && prediction_b.IsDefined(),
        "secondary structure prediction (" + m_SSMethod.GetName() + ") is not stored for amino acids!"
      );

      // compute scalar product of vectors
      double scalar
      (
        ( biol::GetSSTypes().COIL.GetIndex() + 1) *
        ( prediction_a->GetThreeStatePrediction() * prediction_b->GetThreeStatePrediction())
      );

      // ensure scalar > 0 and scale scalar between GetSize() and 1 / GetSize()
      scalar = std::max< double>( scalar, double( 1) / ( biol::GetSSTypes().COIL.GetIndex() + 1));

      // logarithmize and return
      return std::log10( scalar);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAAssignmentSSPrediction::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSMethod, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAAssignmentSSPrediction::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSMethod, ISTREAM);

      // end
      return ISTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_neighborhood_distances.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list.h"
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_implementation.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AANeighborhoodDistances::s_Instance
    (
      util::Enumerated< AANeighborhoodInterface>::AddInstance( new AANeighborhoodDistances())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AANeighborhoodDistances::AANeighborhoodDistances() :
      m_ScoreDistance()
    {
    }

    //! @brief constructor from a distance score
    //! @param SP_AA_PAIR_DISTANCE_SCORE aa pair distance score
    AANeighborhoodDistances::AANeighborhoodDistances
    (
      const AAPairDistanceInterface &SP_AA_PAIR_DISTANCE_SCORE
    ) :
      m_ScoreDistance( SP_AA_PAIR_DISTANCE_SCORE)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AANeighborhoodDistances object copied from this one
    AANeighborhoodDistances *AANeighborhoodDistances::Clone() const
    {
      return new AANeighborhoodDistances( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AANeighborhoodDistances::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AANeighborhoodDistances::GetScheme() const
    {
      return m_ScoreDistance->GetScheme();
    }

    //! @brief access to the minimal sequence separation
    //! @return minimal sequence separation for neighbors of that exposure score between amino acids in the same chain
    size_t AANeighborhoodDistances::GetMinimalSequenceSeparation() const
    {
      return m_ScoreDistance->GetMinimalSequenceSeparation();
    }

    //! @brief access to the distance cutoff
    //! @return distance cutoff above which the neighbor does not have influence on the score anymore
    double AANeighborhoodDistances::GetDistanceCutoff() const
    {
      return m_ScoreDistance->GetDistanceCutoff();
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &AANeighborhoodDistances::GetAlias() const
    {
      static const std::string s_name( "AANeighborhoodDistances");
      return s_name;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate neighbor potential for a given amino acid and its AANeighborList
    //! @param MEMBRANE if it is defined, the score can be determined based on the membrane environment
    //! @return neighbor potential for a given amino acid and its AANeighborList
    double AANeighborhoodDistances::operator()
    (
      const assemble::AANeighborList &AA_NEIGHBOR_LIST,
      const util::SiPtr< const biol::Membrane> &MEMBRANE
    ) const
    {
      // check that the given neighbor list has the proper parameters
      BCL_Assert
      (
        AA_NEIGHBOR_LIST.GetDistanceCutoff() == m_ScoreDistance->GetDistanceCutoff() &&
        AA_NEIGHBOR_LIST.GetMinimalSequenceSeparation() == m_ScoreDistance->GetMinimalSequenceSeparation(),
        "given neighbor list does not have the proper distance cutoff or sequence separation: " +
        util::Format()( AA_NEIGHBOR_LIST.GetDistanceCutoff()) + " == " + util::Format()( m_ScoreDistance->GetDistanceCutoff()) + " && " +
        util::Format()( AA_NEIGHBOR_LIST.GetMinimalSequenceSeparation()) = " != " + util::Format()( m_ScoreDistance->GetMinimalSequenceSeparation())
      );

      // store the address of the current aa
      const biol::AABase &current_aa( *AA_NEIGHBOR_LIST.GetCenterAminoAcid());

      // check that the current amino acid has a defined coordinate
      if( !current_aa.GetFirstSidechainAtom().GetCoordinates().IsDefined())
      {
        return 0.0;
      }

      double score( 0);
      size_t count( 0);

      // iterate over all neighbors
      for
      (
        assemble::AANeighborList::const_iterator itr( AA_NEIGHBOR_LIST.Begin()), itr_end( AA_NEIGHBOR_LIST.End());
        itr != itr_end;
        ++itr
      )
      {
        score += m_ScoreDistance->operator ()( current_aa, *itr->First(), itr->Second());
        ++count;
      }

      // normalize by number of neighbors
      if( count > 0)
      {
        score /= count;
      }

      // end
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AANeighborhoodDistances::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ScoreDistance, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @return returns the output stream
    std::ostream &AANeighborhoodDistances::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ScoreDistance, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AA_NEIGHBOR_LIST AANeighborList to be used for a single AABase
    //! @param MEMBRANE if it is defined, the score can be determined based on the membrane environment
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AANeighborhoodDistances::WriteDetailedSchemeAndValues
    (
      const assemble::AANeighborList &AA_NEIGHBOR_LIST,
      const util::SiPtr< const biol::Membrane> &MEMBRANE,
      std::ostream &OSTREAM
    ) const
    {
      // check that the given neighbor list has the proper parameters
      BCL_Assert
      (
        AA_NEIGHBOR_LIST.GetDistanceCutoff() == m_ScoreDistance->GetDistanceCutoff() &&
        AA_NEIGHBOR_LIST.GetMinimalSequenceSeparation() == m_ScoreDistance->GetMinimalSequenceSeparation(),
        "given neighbor list does not have the proper distance cutoff or sequence separation: " +
        util::Format()( AA_NEIGHBOR_LIST.GetDistanceCutoff()) + " == " + util::Format()( m_ScoreDistance->GetDistanceCutoff()) + " && " +
        util::Format()( AA_NEIGHBOR_LIST.GetMinimalSequenceSeparation()) = " != " + util::Format()( m_ScoreDistance->GetMinimalSequenceSeparation())
      );

      // store the address of the current aa
      const biol::AABase &current_aa( *AA_NEIGHBOR_LIST.GetCenterAminoAcid());

      // check that the current aminoacid has a defined coordinate
      if( !current_aa.GetFirstSidechainAtom().GetCoordinates().IsDefined())
      {
        return OSTREAM;
      }

      // iterate over all neighbors
      for
      (
        assemble::AANeighborList::const_iterator itr( AA_NEIGHBOR_LIST.Begin()), itr_end( AA_NEIGHBOR_LIST.End());
        itr != itr_end;
        ++itr
      )
      {
        m_ScoreDistance->WriteDetailedSchemeAndValues( current_aa, *itr->First(), OSTREAM) << '\n';
      }

      // end
      return OSTREAM;
    }

    //! @brief return parameters for data members that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AANeighborhoodDistances::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Scores the neighbors by adding all aa pair distance scores");
      return serializer;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_neighborhood_exposure.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"
#include "biol/bcl_biol_membrane.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_histogram.h"
#include "score/bcl_score_energy_distribution.h"
#include "score/bcl_score_read_histograms.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AANeighborhoodExposure::s_Instance
    (
      util::Enumerated< AANeighborhoodInterface>::AddInstance( new AANeighborhoodExposure())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AANeighborhoodExposure::AANeighborhoodExposure() :
      m_AAExposure()
    {
    }

    //! @brief constructor from aa exposure function
    //! @param SP_AA_EXPOSURE ShPtr to AA exposure function to be used for aa exposure measure and scoring
    AANeighborhoodExposure::AANeighborhoodExposure
    (
      const assemble::AAExposureInterface &SP_AA_EXPOSURE
    ) :
      m_AAExposure( SP_AA_EXPOSURE)
    {
      ReadEnergyVector();
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AANeighborhoodExposure copied from this one
    AANeighborhoodExposure *AANeighborhoodExposure::Clone() const
    {
      return new AANeighborhoodExposure( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AANeighborhoodExposure::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AANeighborhoodExposure::GetScheme() const
    {
      // write the scheme of the aa exposure function being used
      return m_AAExposure->GetScheme();
    }

    //! @brief access to the minimal sequence separation
    //! @return minimal sequence separation for neighbors of that exposure score between amino acids in the same chain
    size_t AANeighborhoodExposure::GetMinimalSequenceSeparation() const
    {
      return m_AAExposure->GetMinimalSequenceSeparation();
    }

    //! @brief access to the distance cutoff
    //! @return distance cutoff above which the neighbor does not have influence on the score anymore
    double AANeighborhoodExposure::GetDistanceCutoff() const
    {
      return m_AAExposure->GetDistanceCutoff();
    }

    //! @brief access to the membrane potentials for given environment
    //! @param ENVIRONMENT environment for the potentials
    //! @return reference to membrane environment potentials
    const storage::Map< biol::AAType, math::CubicSplineDamped> &AANeighborhoodExposure::GetMembranePotentials
    (
      const biol::EnvironmentType &ENVIRONMENT
    ) const
    {
      return m_EnergyFunctionsMembrane.GetValue( ENVIRONMENT);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculates the sum of exposures of all amino acids for the given ProteinModel
    //! @param AA_NEIGHBOR_LIST neighbor list which's center amino acid is scored in the context
    //! @param MEMBRANE if it is defined, the score can be determined based on the membrane environment
    //! @return the exposure score for this neighbor list
    double AANeighborhoodExposure::operator()
    (
      const assemble::AANeighborList &AA_NEIGHBOR_LIST,
      const util::SiPtr< const biol::Membrane> &MEMBRANE
    ) const
    {
      const biol::AABase &current_aa( *AA_NEIGHBOR_LIST.GetCenterAminoAcid());

      // skip undefined aa types
      if( !current_aa.GetType().IsDefined() || !current_aa.GetType()->IsNaturalAminoAcid())
      {
        return 0.0;
      }

      // check that the current aminoacid has a defined coordinate
      if( !current_aa.GetFirstSidechainAtom().GetCoordinates().IsDefined())
      {
        return 0.0;
      }

      // calculate exposure for the current amino acid
      const double current_exposure( m_AAExposure->operator()( AA_NEIGHBOR_LIST));

      // score the exposure
      if( MEMBRANE.IsDefined())
      {
        const storage::Pair< biol::EnvironmentType, double> environment_weight
        (
          MEMBRANE->DetermineEnvironmentTypeAndWeight( current_aa.GetFirstSidechainAtom().GetCoordinates())
        );

        // for non-gap regions use the energy functions
        if( !environment_weight.First()->IsGap())
        {
          return m_EnergyFunctionsMembrane.Find( environment_weight.First())->second.Find( current_aa.GetType())->second( current_exposure);
        }
        // for gaps use a combination of bordering regions depending on the given weight

        // if it is a gap type, energy for adjacent env type have to be determined
        const biol::EnvironmentType env_type_left( environment_weight.First().GetIndex() - 1);
        const biol::EnvironmentType env_type_right( environment_weight.First().GetIndex() + 1);

        const double energy_left( m_EnergyFunctionsMembrane.Find( env_type_left)->second.Find( current_aa.GetType())->second( current_exposure));
        const double energy_right( m_EnergyFunctionsMembrane.Find( env_type_right)->second.Find( current_aa.GetType())->second( current_exposure));

        // weight the two energies depending on how close the z-coordinate is to left or right
        return   energy_left * environment_weight.Second()
               + energy_right * ( 1.0 - environment_weight.Second());
      }

      // soluble protein
      return m_EnergyFunctionsSoluble.Find( current_aa.GetType())->second( current_exposure);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AANeighborhoodExposure::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_AAExposure, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AANeighborhoodExposure::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_AAExposure, ISTREAM);

      ReadEnergyVector();

      // end
      return ISTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AA_NEIGHBOR_LIST neighbor list which's center amino acid is scored in the context
    //! @param OSTREAM the std::ostream to be written to
    //! @param MEMBRANE if it is defined, the score can be determined based on the membrane environment
    //! @return std::ostream which was written to
    std::ostream &
    AANeighborhoodExposure::WriteDetailedSchemeAndValues
    (
      const assemble::AANeighborList &AA_NEIGHBOR_LIST,
      const util::SiPtr< const biol::Membrane> &MEMBRANE,
      std::ostream &OSTREAM
    ) const
    {
      const biol::AABase &current_aa( *AA_NEIGHBOR_LIST.GetCenterAminoAcid());

      // skip undefined aa types
      if( !current_aa.GetType().IsDefined() || !current_aa.GetType()->IsNaturalAminoAcid())
      {
        return OSTREAM;
      }

      // check that the current aminoacid has a defined coordinate
      if( !current_aa.GetFirstSidechainAtom().GetCoordinates().IsDefined())
      {
        return OSTREAM;
      }

      // calculate exposure for the current amino acid
      const double current_exposure( m_AAExposure->operator()( AA_NEIGHBOR_LIST));

      // write seq id of current AA
      OSTREAM << current_aa.GetIdentification() << '\t';
      // write exposure
      OSTREAM << current_exposure << ": ";

      // score the exposure
      if( MEMBRANE.IsDefined())
      {
        const storage::Pair< biol::EnvironmentType, double> environment_weight
        (
          MEMBRANE->DetermineEnvironmentTypeAndWeight( current_aa.GetFirstSidechainAtom().GetCoordinates())
        );

        double current_score( 0.0);
        // for non-gap regions use the energy functions
        if( !environment_weight.First()->IsGap())
        {
          current_score = m_EnergyFunctionsMembrane.Find( environment_weight.First())->second.Find( current_aa.GetType())->second( current_exposure);
        }
        // for gaps use a combination of bordering regions depending on the given weight
        else
        {
          // if it is a gap type, energy for adjacent env type have to be determined
          const biol::EnvironmentType env_type_left( environment_weight.First().GetIndex() - 1);
          const biol::EnvironmentType env_type_right( environment_weight.First().GetIndex() + 1);

          const double energy_left( m_EnergyFunctionsMembrane.Find( env_type_left)->second.Find( current_aa.GetType())->second( current_exposure));
          const double energy_right( m_EnergyFunctionsMembrane.Find( env_type_right)->second.Find( current_aa.GetType())->second( current_exposure));

          // weight the two energies depending on how close the z-coordinate is to left or right
          current_score =   energy_left * environment_weight.Second()
                          + energy_right * ( 1.0 - environment_weight.Second());
        }

        // write according score
        OSTREAM << current_score << '\t'
                // write z-coordinate
                << current_aa.GetFirstSidechainAtom().GetCoordinates().Z() << '\t'
                // write environment
                << environment_weight.First().GetName() << '\t'
                // write weight
                << environment_weight.Second() << '\n';

        // end
        return OSTREAM;
      }

      // soluble protein
      return OSTREAM << m_EnergyFunctionsSoluble.Find( current_aa.GetType())->second( current_exposure) << '\n';
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AANeighborhoodExposure::GetSerializer() const
    {
      io::Serializer serializer;

      serializer.SetClassDescription( "Scores the exposure of an amino acid in the context of its neighbors.");
      serializer.AddInitializer
      (
        "aa exposure",
        "AAExposure function to be used for calculations",
        io::Serialization::GetAgent( &m_AAExposure)
      );

      return serializer;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief read the energy vector for the AminoAcid neighbor counts
    void
    AANeighborhoodExposure::ReadEnergyVector()
    {
      // initialize read
      io::IFStream read;
      const std::string filename( Score::AddHistogramPath( m_AAExposure->GetHistogramFileName()));
      io::File::MustOpenIFStream( read, filename);

      // read boundaries
      math::Range< double> threshold_low_high;
      read >> threshold_low_high;

      // read sequence separation
      size_t minimal_sequence_separation( 0);
      read >> minimal_sequence_separation;

      m_AAExposure->SetThresholdRange( threshold_low_high);
      m_AAExposure->SetMinimalSequenceSeparation( minimal_sequence_separation);

      // read membrane and environment dependent potential
      const storage::Vector< storage::Vector< math::Histogram> >
        membrane_aa_histograms( ReadHistograms::ReadMembraneDependentEnvironmentHistograms( read));

      // close and clear stream
      io::File::CloseClearFStream( read);

      // derive energy distribution for membrane aa environment potential and store it
      m_EnergyFunctionsMembrane = EnergyDistribution::AAMembraneEnvironmentPotential( membrane_aa_histograms);
      m_EnergyFunctionsSoluble = EnergyDistribution::AAEnvironmentPotential( membrane_aa_histograms( biol::GetEnvironmentTypes().e_Solution));
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_neighborhood_exposure_prediction.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_count.h"
#include "assemble/bcl_assemble_aa_neighbor_list.h"
#include "biol/bcl_biol_aa_base.h"
#include "command/bcl_command_flag_static.h"
#include "fold/bcl_fold_default_flags.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AANeighborhoodExposurePrediction::s_Instance
    (
      util::Enumerated< AANeighborhoodInterface>::AddInstance( new AANeighborhoodExposurePrediction())
    );

    //! @brief return command line flag for using exposure score
    //! @return command line flag for using exposure score
    util::ShPtr< command::FlagInterface> &AANeighborhoodExposurePrediction::GetFlagScoreExposure()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "score_exposure",
          "\tflag to enable use of exposure scores, requires a prediction file given by " +
            fold::DefaultFlags::GetFlagReadSequenceDataPath()->GetName() + " flag"
        )
      );
      // end
      return s_flag;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AANeighborhoodExposurePrediction::AANeighborhoodExposurePrediction()
    {
    }

    //! @brief Clone function
    //! @return pointer to new AANeighborhoodExposurePrediction
    AANeighborhoodExposurePrediction *AANeighborhoodExposurePrediction::Clone() const
    {
      return new AANeighborhoodExposurePrediction( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AANeighborhoodExposurePrediction::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief access to the minimal sequence separation
    //! @return minimal sequence separation for neighbors of that exposure score between amino acids in the same chain
    size_t AANeighborhoodExposurePrediction::GetMinimalSequenceSeparation() const
    {
      return GetAANeighborCount().GetMinimalSequenceSeparation();
    }

    //! @brief access to the distance cutoff
    //! @return distance cutoff above which the neighbor does not have influence on the score anymore
    double AANeighborhoodExposurePrediction::GetDistanceCutoff() const
    {
      return GetAANeighborCount().GetDistanceCutoff();
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AANeighborhoodExposurePrediction::GetScheme() const
    {
      static const std::string s_scheme( "exposure_prediction");
      return s_scheme;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &AANeighborhoodExposurePrediction::GetAlias() const
    {
      static const std::string s_name( "ExposurePrediction");
      return s_name;
    }
  ///////////////
  // operators //
  ///////////////

    //! @brief calculates the score for the passed neighborhood
    //! @param NEIGHBOR_LIST AA neighbor list
    //! @param MEMBRANE membrane object
    //! @return exposure score based on the prediction
    double AANeighborhoodExposurePrediction::operator()
    (
      const assemble::AANeighborList &NEIGHBOR_LIST,
      const util::SiPtr< const biol::Membrane> &MEMBRANE
    ) const
    {
      // get predicted neighbor count
      const double predicted_exposure( NEIGHBOR_LIST.GetCenterAminoAcid()->GetExposurePrediction());

      // if undefined, return score of 0
      if( !util::IsDefined( predicted_exposure))
      {
        return 0.0;
      }

      // return the absolute neighbor count difference
      return math::Absolute( GetAANeighborCount()( NEIGHBOR_LIST) - predicted_exposure);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AANeighborhoodExposurePrediction::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AANeighborhoodExposurePrediction::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

    //! @brief write detailed scheme and values to OSTREAM
    //! @param NEIGHBOR_LIST AA neighbor list
    //! @param MEMBRANE membrane object
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &AANeighborhoodExposurePrediction::WriteDetailedSchemeAndValues
    (
      const assemble::AANeighborList &NEIGHBOR_LIST,
      const util::SiPtr< const biol::Membrane> &MEMBRANE,
      std::ostream &OSTREAM
    ) const
    {
      // get the predicted neighbor count
      const double predicted_exposure( NEIGHBOR_LIST.GetCenterAminoAcid()->GetExposurePrediction());

      // get the calculated neighbor count
      const double model_exposure( GetAANeighborCount()( NEIGHBOR_LIST));

      // compare calculated neighbor count to predicted neighbor count
      const double this_score( math::Absolute( model_exposure - predicted_exposure));

      // write information bcl
      OSTREAM << NEIGHBOR_LIST.GetCenterAminoAcid()->GetSeqID() << '\t' << predicted_exposure << '\t'
              << model_exposure << '\t' << this_score;

      // end
      return OSTREAM;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AANeighborhoodExposurePrediction::GetSerializer() const
    {
      io::Serializer serializer;

      serializer.SetClassDescription( "Scores the deviation of exposure in the model from given exposure.");

      return serializer;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief gets the static AANeighborCount object
    //! @return the static AANeighborCount object
    const assemble::AANeighborCount &AANeighborhoodExposurePrediction::GetAANeighborCount()
    {
      // create neighbor count object
      static const assemble::AANeighborCount s_neighbor_count;

      return s_neighbor_count;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_pair_atom_clash.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AAPairAtomClash::s_Instance
    (
      GetObjectInstances().AddInstance( new AAPairAtomClash())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &AAPairAtomClash::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "atomclash");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AAPairAtomClash::AAPairAtomClash() :
      m_SigmoidWidth( 1.0),
      m_DistanceCutoff( 12.0),
      m_MinimalSequenceSeparation( 0),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief constructor from a specified histogram file
    //! @param SIGMOID_WIDTH width of the sigmoid repulsive term, before it reaches 1.0
    //! @param MINIMAL_SEQUENCE_SEPARATION minimal sequence separation
    //! @param SCHEME scheme to be used
    AAPairAtomClash::AAPairAtomClash
    (
      const double SIGMOID_WIDTH,
      const size_t MINIMAL_SEQUENCE_SEPARATION,
      const std::string &SCHEME
    ) :
      m_SigmoidWidth( SIGMOID_WIDTH),
      m_DistanceCutoff( 12.0),
      m_MinimalSequenceSeparation( MINIMAL_SEQUENCE_SEPARATION),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new AAPairAtomClash
    AAPairAtomClash *AAPairAtomClash::Clone() const
    {
      return new AAPairAtomClash( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAPairAtomClash::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief evaluate clashes for given atom pair
    //! @param ATOM_A first atom of interest
    //! @param ATOM_B second atom of interest
    //! @return clash score for the given atom pair
    double AAPairAtomClash::operator()
    (
      const biol::Atom &ATOM_A,
      const biol::Atom &ATOM_B
    ) const
    {
      // calculate the sum covalent radius
      // van der waals radius would consider N-C-CA N-CA distance as clash (2.4 < 3.39)
      const double clash_distance
      (
        1.25 *
        (
          ATOM_A.GetType()->GetElementType()->GetProperty( chemistry::ElementTypeData::e_CovalentRadius) +
          ATOM_B.GetType()->GetElementType()->GetProperty( chemistry::ElementTypeData::e_CovalentRadius)
        )
      );

//      const linal::Vector3D &coord_a( ATOM_A.GetCoordinates());
//      const linal::Vector3D &coord_b( ATOM_B.GetCoordinates());
//
//      // check if at least all individual coordinates are too close, only then calculation of actual distance is required
//      for
//      (
//        const double *ptr_a( coord_a.Begin()), *ptr_b( coord_b.Begin()), *ptr_a_end( coord_a.End());
//        ptr_a != ptr_a_end;
//        ++ptr_a, ++ptr_b
//      )
//      {
//        if( math::Absolute( *ptr_a - *ptr_b) > clash_distance)
//        {
//          return 0.0;
//        }
//      }

      // calculate the distance between these two atoms
      const double distance( biol::Distance( ATOM_A, ATOM_B));

      // calculate and return score
      return CalculateRepulsiveTerm( distance, clash_distance);
    }

    //! @brief evaluate clashes for all atoms pairs and return it
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @return pair of clash score and the number of scored entities
    double AAPairAtomClash::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B
    ) const
    {
      // initialize score
      double score( 0.0);

      const int seq_dist( AMINO_ACID_A.GetSeqID() - AMINO_ACID_B.GetSeqID());

      // iterate over the atoms of the first amino acid
      for
      (
        util::SiPtrVector< const biol::Atom>::const_iterator
          atom_itr_a( AMINO_ACID_A.GetAtoms().Begin()), atom_itr_a_end( AMINO_ACID_A.GetAtoms().End());
        atom_itr_a != atom_itr_a_end; ++atom_itr_a
      )
      {
        const biol::Atom &atom_a( **atom_itr_a);
        const biol::AtomType &type_a( atom_a.GetType());

        for
        (
          util::SiPtrVector< const biol::Atom>::const_iterator
            atom_itr_b( AMINO_ACID_B.GetAtoms().Begin()), atom_itr_b_end( AMINO_ACID_B.GetAtoms().End());
          atom_itr_b != atom_itr_b_end; ++atom_itr_b
        )
        {
          const biol::Atom &atom_b( **atom_itr_b);
          const biol::AtomType &type_b( atom_b.GetType());

          // B following A allows peptide bond
          if( seq_dist == -1 && type_a == biol::GetAtomTypes().C && type_b == biol::GetAtomTypes().N)
          {
            continue;
          }

          // A following B allows peptide bond
          if( seq_dist == 1 && type_a == biol::GetAtomTypes().N && type_b == biol::GetAtomTypes().C)
          {
            continue;
          }

          // calculate and sum up the score
          const double current_repulsive( operator()( atom_a, atom_b));
          score += current_repulsive;
        }
      }

      return score;
    }

    //! @brief evaluate clashes for all atoms pairs and return it
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param DISTANCE distance between the amino acid pair
    //! @return pair of clash score and the number of scored entities
    double AAPairAtomClash::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      double DISTANCE
    ) const
    {
      // call the other operator since CB distance by itself is not enough to calculate the score
      return operator()( AMINO_ACID_A, AMINO_ACID_B);
    }

    //! @brief calculate clash score for a protein model
    //! @param MODEL the protein model of interest
    //! @return amino acid pairing potential for given protein
    double AAPairAtomClash::operator()( const assemble::ProteinModel &MODEL) const
    {
      // first, hash the structured SSE index of each
      return 0.0;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AAPairAtomClash::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SigmoidWidth, ISTREAM);
      io::Serialize::Read( m_MinimalSequenceSeparation, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AAPairAtomClash::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SigmoidWidth, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MinimalSequenceSeparation, OSTREAM, INDENT);
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << '\n';

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairAtomClash::WriteDetailedSchemeAndValues
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      std::ostream &OSTREAM
    ) const
    {
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief repulsive term from distance and sum of van der waals radii
    //! @param DISTANCE the actual distance between atoms of interest
    //! @param VDW_DISTANCE sum of van der waals radii
    //! @return repulsive term
    double AAPairAtomClash::CalculateRepulsiveTerm
    (
      const double DISTANCE,
      const double VDW_DISTANCE
    ) const
    {
      const double difference( VDW_DISTANCE - DISTANCE);

      // no repulsion
      if( difference <= 0.0)
      {
        return 0.0;
      }
      // full repulsion
      else if( difference >= m_SigmoidWidth)
      {
        return 1.0;
      }

      return math::WeightBetweenZeroAndPi( ( ( m_SigmoidWidth - difference) / m_SigmoidWidth) * math::g_Pi);
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_pair_clash.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "biol/bcl_biol_aa_base.h"
#include "command/bcl_command_command_state.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_histogram.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &AAPairClash::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "aa_distances_0.05.histograms");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &AAPairClash::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "aaclash");

      // end
      return s_default_scheme;
    }

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AAPairClash::s_Instance
    (
      util::Enumerated< AAPairDistanceInterface>::AddInstance( new AAPairClash)
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param SIGMOID_WIDTH width of the sigmoid repulsive term, before it reaches 1.0
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param SCHEME scheme to be used
    AAPairClash::AAPairClash
    (
      const double SIGMOID_WIDTH, // = 1.0,
      const std::string &HISTOGRAM_FILENAME, // = GetDefaultHistogramFilename(),
      const std::string &SCHEME // = GetDefaultScheme()
    ) :
      m_ShortestObservedDistance(),
      m_ShortestObservedDistanceMatrix( biol::AATypes::s_NumberStandardAATypes, biol::AATypes::s_NumberStandardAATypes, double( 0.0)),
      m_SigmoidWidth( SIGMOID_WIDTH),
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_Scheme( SCHEME),
      m_DistanceCutoff( 0.0)
    {
      // read the histogram file and store the distances
      ReadDistanceMap();
    }

    //! @brief constructor from a specified histogram file
    //! @param SIGMOID_WIDTH width of the sigmoid repulsive term, before it reaches 1.0
    //! @param MINIMAL_SEQUENCE_SEPARATION minimal sequence separation
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param SCHEME scheme to be used
    AAPairClash::AAPairClash
    (
      const double SIGMOID_WIDTH,
      const size_t MINIMAL_SEQUENCE_SEPARATION,
      const std::string &HISTOGRAM_FILENAME,
      const std::string &SCHEME
    ) :
      m_ShortestObservedDistance(),
      m_ShortestObservedDistanceMatrix( biol::AATypes::s_NumberStandardAATypes, biol::AATypes::s_NumberStandardAATypes, double( 0.0)),
      m_SigmoidWidth( SIGMOID_WIDTH),
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_Scheme( SCHEME),
      m_DistanceCutoff( 0.0)
    {
      // read the histogram file and store the distances
      ReadDistanceMap();
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAPairClash object that is copied from this one
    AAPairClash *AAPairClash::Clone() const
    {
      return new AAPairClash( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAPairClash::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief create a matrix of all amino acid pair min distances
    //! @return matrix with minimal distances observed for every amino acid pair
    const linal::Matrix< double> &AAPairClash::GetShortestObservedDistanceMatrix() const
    {
      // end
      return m_ShortestObservedDistanceMatrix;
    }

  ///////////////
  // operators //
  ///////////////

    //! Get the closest observed distance between two AAs in the PDB
    double AAPairClash::GetClosestDistance( const biol::AAType &A, const biol::AAType &B) const
    {
      return A->IsNaturalAminoAcid() && B->IsNaturalAminoAcid() ? m_ShortestObservedDistanceMatrix( A, B) : 0.0;
    }

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairClash::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B
    ) const
    {
      // calculate the CB Distance
      const double distance
      (
        biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B)
      );

      // return the clash score
      return operator()( AMINO_ACID_A, AMINO_ACID_B, distance);
    }

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param DISTANCE distance between the amino acid pair
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairClash::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      const double DISTANCE
    ) const
    {
      // if distance is not defined return 0
      if( !util::IsDefined( DISTANCE))
      {
        return double( 0.0);
      }

      if( AMINO_ACID_A.GetType()->IsNaturalAminoAcid() && AMINO_ACID_B.GetType()->IsNaturalAminoAcid())
      {
        if( AMINO_ACID_A.GetSeqID() != AMINO_ACID_B.GetSeqID() || AMINO_ACID_A.GetChainID() != AMINO_ACID_B.GetChainID())
        {
          return CalculateRepulsiveTerm
                 (
                   DISTANCE,
                   m_ShortestObservedDistanceMatrix( AMINO_ACID_A.GetType(), AMINO_ACID_B.GetType())
                 );
        }
      }

      // shortest observed distance for this aa pair type
      const storage::Map< storage::Pair< biol::AAType, biol::AAType>, double>::const_iterator
      itr
      (
        m_ShortestObservedDistance.Find
        (
          storage::Pair< biol::AAType, biol::AAType>( AMINO_ACID_A.GetType(), AMINO_ACID_B.GetType())
        )
      );

      if( itr == m_ShortestObservedDistance.End())
      {
        return double( 0.0);
      }

      // calculate the actual repulsive term
      return CalculateRepulsiveTerm( DISTANCE, itr->second);
    }

    //! @brief calculate clash score for a protein model
    //! @param MODEL the protein model of interest
    //! @return amino acid pairing potential for given protein
    double AAPairClash::operator()( const assemble::ProteinModel &MODEL) const
    {
      assemble::VoxelGridAA s_voxel_grid( m_DistanceCutoff);

      auto aas( MODEL.GetAminoAcids());
      s_voxel_grid.SetObjects( aas);
      double score( 0.0);

      storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> >
        res( s_voxel_grid.GetNeighbors( m_DistanceCutoff));
      for( auto itr( res.Begin()), itr_end( res.End()); itr != itr_end; ++itr)
      {
        const auto &triplet( *itr);
        const double closest_distance( GetClosestDistance( triplet.First()->GetType(), triplet.Second()->GetType()));
        score += CalculateRepulsiveTerm( triplet.Third(), closest_distance);
      }
      return score;
    }

    //! @brief calculate clash score for SSEs
    //! @param SSE_A, SSE_B the SSEs to check for clashes
    //! @return clash score
    double AAPairClash::operator()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      assemble::VoxelGridAA voxel_grid_a( m_DistanceCutoff);
      voxel_grid_a.SetObjects( util::SiPtrVector< const biol::AABase>( SSE_A.Begin(), SSE_A.End()));
      double score( 0.0);
      for( auto itr_b( SSE_B.Begin()), itr_b_end( SSE_B.End()); itr_b != itr_b_end; ++itr_b)
      {
        storage::Vector< storage::Pair< util::SiPtr< const biol::AABase>, double> >
          res( voxel_grid_a.GetNeighbors( **itr_b, m_DistanceCutoff));
        for( auto itr( res.Begin()), itr_end( res.End()); itr != itr_end; ++itr)
        {
          const auto &pr( *itr);
          const double closest_distance( GetClosestDistance( ( *itr_b)->GetType(), pr.First()->GetType()));
          score += CalculateRepulsiveTerm( pr.Second(), closest_distance);
        }
      }
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairClash::WriteDetailedSchemeAndValues
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      std::ostream &OSTREAM
    ) const
    {
      // calculate the aa distance
      const double aa_distance( biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B));

      // if distance is not defined return 0
      if( !util::IsDefined( aa_distance))
      {
        return OSTREAM;
      }

      // write Scheme
      OSTREAM << AMINO_ACID_A.GetSeqID() << '\t'
              << AMINO_ACID_A.GetType()->GetThreeLetterCode() << '\t'
              << AMINO_ACID_B.GetSeqID() << '\t'
              << AMINO_ACID_B.GetType()->GetThreeLetterCode() << '\t'
              << aa_distance << '\t'
              << operator()( AMINO_ACID_A, AMINO_ACID_B) << '\n';

      // end
      return OSTREAM;
    }

    //! @brief return parameters for data members that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AAPairClash::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Scores whether two amino acids clash");
      serializer.AddInitializer
      (
        "sigmoid width",
        "width of the sigmoidal function to be used",
        io::Serialization::GetAgent( &m_SigmoidWidth),
        "1.0"
      );
      serializer.AddInitializer
      (
        "histogram file name",
        "path to file where the statistics and in consequence the energy potentials are read from",
        io::Serialization::GetAgent( &m_HistogramFileName),
        GetDefaultHistogramFilename()
      );

      return serializer;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief repulsive term from distance and shortest observed distance
    //! @param DISTANCE the actual distance between amino acids of interest
    //! @param SHORTEST_OBSERVED_DISTANCE shortest distance observed
    double AAPairClash::CalculateRepulsiveTerm
    (
      const double DISTANCE,
      const double SHORTEST_OBSERVED_DISTANCE
    ) const
    {
      const double difference( SHORTEST_OBSERVED_DISTANCE - DISTANCE);

      // no repulsion
      if( difference <= 0.0)
      {
        return 0.0;
      }
      // full repulsion
      else if( difference >= m_SigmoidWidth)
      {
        return 1.0;
      }

      return math::WeightBetweenZeroAndPi( ( ( m_SigmoidWidth - difference) / m_SigmoidWidth) * math::g_Pi);
    }

    //! @brief read map of amino acid pair observed distanced from histogram file
    void AAPairClash::ReadDistanceMap()
    {
      m_DistanceCutoff = 0.0;
      // during static initialization, this histogram path is not available. Moreover, the static instance does not need
      // the histograms available
      if( command::CommandState::GetGlobalCommandState().IsInStaticInitialization())
      {
        return;
      }
      // read file with all histograms for each pair of aa types
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      // initialize temporary strings to read
      std::string tmp_a, tmp_b;

      // number of natural pairs seen
      size_t n_natural_seen( 0);

      // while reading the aatype pair and until reaching the end of the file
      while( read >> tmp_a >> tmp_b && !read.eof())
      {
        // read the string and convert it to first aa type
        storage::Pair< biol::AAType, biol::AAType> aa_type_pair
        (
          biol::GetAATypes().AATypeFromOneLetterCode( tmp_a[0]),
          biol::GetAATypes().AATypeFromOneLetterCode( tmp_b[0])
        );

        // abort if any of the aatypes if unknown
        if
        (
          aa_type_pair.First() == biol::GetAATypes().e_Undefined ||
          aa_type_pair.Second() == biol::GetAATypes().e_Undefined
        )
        {
          // alert user and break
          BCL_MessageCrt
          (
            "undefined AAType found in the histogram " + util::Format()( aa_type_pair)
          );
          break;
        }

        // read the histogram
        math::Histogram current_histogram;
        read >> current_histogram;

        // identify the first non 0 bin
        const size_t shortest_observed_index( current_histogram.GetIndexOfFirstInformationContainingBin( 1.5));
        const double shortest_observed_distance
        (
          shortest_observed_index * current_histogram.GetBinSize() + current_histogram.GetBoundaries().First()
        );

        if( aa_type_pair.First()->IsNaturalAminoAcid() && aa_type_pair.Second()->IsNaturalAminoAcid())
        {
          m_ShortestObservedDistanceMatrix( aa_type_pair.First(), aa_type_pair.Second()) = shortest_observed_distance;
          m_ShortestObservedDistanceMatrix( aa_type_pair.Second(), aa_type_pair.First()) = shortest_observed_distance;
          ++n_natural_seen;
        }
        else
        {
          // insert into map
          m_ShortestObservedDistance[ aa_type_pair] = shortest_observed_distance;
          std::swap( aa_type_pair.First(), aa_type_pair.Second());
          m_ShortestObservedDistance[ aa_type_pair] = shortest_observed_distance;
        }

        // update distance cutoff
        m_DistanceCutoff = std::max( m_DistanceCutoff, shortest_observed_distance);
      }
      BCL_Assert( n_natural_seen == size_t( 210), "Not all natural AAs were in the distance map!");

      // close the stream
      io::File::CloseClearFStream( read);
    }

    //! @brief set the members of this object from the given label
    //! @param LABEL the label containing members that should be read of this class
    //! @return ERROR_STREAM stream with which to write errors
    bool AAPairClash::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
    {
      ReadDistanceMap();
      return true;
    }

    //! @brief get the static instance of this class
    const AAPairClash &AAPairClash::GetInstance()
    {
      static AAPairClash s_aa_clash;
      return s_aa_clash;
    }
  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_pair_contact.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_sequence.h"
#include "contact/bcl_contact_prediction_map.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AAPairContact::s_Instance
    (
      GetObjectInstances().AddInstance( new AAPairContact())
    );

    //! lower and higher range of CB distance to be considered as a contact
    const storage::Pair< double, double> AAPairContact::s_CBDistanceRange = storage::Pair< double, double>( 4.0, 12.0);

    //! probability shift for each contact type
    const double AAPairContact::s_ProbabilityShift[ contact::Types::s_NumberValidTypes] = { 0.5, 0.5, 0.5, 0.5, 0.5};

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AAPairContact::AAPairContact()
    {
    }

    //! @brief constructor from a contact type and a PredictionMap
    //! @param CONTACT_TYPE corresponding contact type
    //! @param SP_PREDICTION_MAP ShPtr to PredictionMap of interest
    AAPairContact::AAPairContact
    (
      const contact::Type &CONTACT_TYPE,
      const util::ShPtr< contact::PredictionMap> &SP_PREDICTION_MAP
    ) :
      m_ContactType( CONTACT_TYPE),
      m_PredictionMap( SP_PREDICTION_MAP)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAPairContact copied from this one
    AAPairContact *AAPairContact::Clone() const
    {
      return new AAPairContact( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAPairContact::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator to calculate the contact score for the given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @return the contact score for the given amino acid pair
    double AAPairContact::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B
    ) const
    {
      BCL_MessageDbg( "score aa pair contact");
      // retrieve and store the CB distance between AA pair.
      const double cb_distance( biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B));

      // if the CB distance is greater then right side of CB range, there is no contact so energy contribution is 0.
      if( cb_distance >= s_CBDistanceRange.Second())
      {
        return double( 0);
      }

      // store the iterator in the map that corresponds to these two amino acids
      const double energy
      (
        s_ProbabilityShift[ m_ContactType] -
        m_PredictionMap->GetPredictions
                         (
                           storage::VectorND< 2, util::SiPtr< const biol::AAData> >
                           (
                             ( *AMINO_ACID_A.GetData()),
                             ( *AMINO_ACID_B.GetData())
                           )
                         ).First()( m_ContactType)
      );

      // if there is no available prediction for these aapairs ( probably they are in the border or close neighbors) return 0
      if( !util::IsDefined( energy))
      {
        return double( 0);
      }

      // if the CB distance is smaller than the left side of CB range, return -prediction;
      else if( cb_distance <= s_CBDistanceRange.First())
      {
        return energy;
      }

      // if the CB distance is within range, calculate a score and return it
      return CalculateScore( cb_distance, energy);
    }

  ////////////////
  // operations //
  ////////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAPairContact::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_ContactType, ISTREAM);
      io::Serialize::Read( m_PredictionMap, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @return returns the output stream
    std::ostream &AAPairContact::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_ContactType, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PredictionMap, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairContact::WriteDetailedSchemeAndValues
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      std::ostream &OSTREAM
    ) const
    {
      //write both amino acids, cb distance, contacttype and value
      OSTREAM << AMINO_ACID_A.GetSeqID() << '\t'
              << AMINO_ACID_A.GetType()->GetThreeLetterCode() << '\t'
              << AMINO_ACID_B.GetSeqID() << '\t'
              << AMINO_ACID_B.GetType()->GetThreeLetterCode() << '\t'
              << biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B) << '\t'
              << m_ContactType << '\t' << operator()( AMINO_ACID_A, AMINO_ACID_B) << '\n';

      //end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculates the score given a distance and a prediction vaue from the ANNs
    //! @param DISTANCE Distance between amino acids
    //! @param ENERGY energy value from the ANN
    //! @return the score given a distance and a prediction vaue from the ANNs
    double AAPairContact::CalculateScore( const double DISTANCE, const double ENERGY) const
    {
      // calculate the angle
      const double x
      (
        ( DISTANCE - s_CBDistanceRange.First()) *
        ( math::g_Pi) /
        ( s_CBDistanceRange.Second() - s_CBDistanceRange.First())
      );

      //  Cosine of the calculated value is multiplied with the prediction and returned
      return ENERGY * ( cos( x) + 1) / 2;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_pair_contact_energy.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"
#include "command/bcl_command_command_state.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "linal/bcl_linal_vector_3d_operations.h"
#include "math/bcl_math_gnuplot_heatmap.h"
#include "math/bcl_math_histogram.h"
#include "math/bcl_math_histogram_2d.h"
#include "math/bcl_math_histogram_3d.h"
#include "score/bcl_score_aa_pair_hi_res_clash.h"
#include "score/bcl_score_energy_distribution.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_logger_interface.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    const util::SiPtr< const util::ObjectInterface> AAPairContactEnergy::s_InteractionInstance
    (
      util::Enumerated< ProteinModel>::AddInstance( new AAPairContactEnergy())
    );

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &AAPairContactEnergy::GetAlias() const
    {
      static const std::string s_name( "AAPairInteractionE");
      return s_name;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    AAPairContactEnergy::AAPairContactEnergy() :
      m_HistogramFileName( "aapair_contact_energies.histograms3D"),
      m_Scheme( "aa_pair_interaction"),
      m_Histograms(),
      m_DistanceCutoff( 0.0),
      m_ContactProbabilityCutoff( 0.01),
      m_ConsiderLoops( true),
      m_InterfaceOnly( true)
    {
      // read the histogram file and store the energy functions
      ReadInitializerSuccessHook( util::ObjectDataLabel(), util::GetLogger());
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAPairContactEnergy object that is copied from this one
    AAPairContactEnergy *AAPairContactEnergy::Clone() const
    {
      return new AAPairContactEnergy( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAPairContactEnergy::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param DISTANCE distance between the amino acid pair
    //! @param TYPE_A, TYPE_B SS-type for AMINO_ACID_A/B
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairContactEnergy::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      const double DISTANCE,
      const biol::SSType &TYPE_A,
      const biol::SSType &TYPE_B
    ) const
    {
      if( AMINO_ACID_A.GetType() > AMINO_ACID_B.GetType())
      {
        return operator()( AMINO_ACID_B, AMINO_ACID_A, DISTANCE, TYPE_B, TYPE_A);
      }

      // calculate the angles distance
      const linal::Vector3D &ca_a( AMINO_ACID_A.GetCA().GetCoordinates());
      const linal::Vector3D &cb_a( AMINO_ACID_A.GetFirstSidechainAtom().GetCoordinates());
      const linal::Vector3D &ca_b( AMINO_ACID_B.GetCA().GetCoordinates());
      const linal::Vector3D &cb_b( AMINO_ACID_B.GetFirstSidechainAtom().GetCoordinates());

      // check that distance is defined
      if
      (
        !util::IsDefined( DISTANCE)
        || !ca_a.IsDefined()
        || !ca_b.IsDefined()
        || !cb_a.IsDefined()
        || !cb_b.IsDefined()
        || !AMINO_ACID_A.GetType()->IsNaturalAminoAcid()
        || !AMINO_ACID_B.GetType()->IsNaturalAminoAcid()
        || TYPE_A->GetIndex() > size_t( 2)
        || TYPE_B->GetIndex() > size_t( 2)
      )
      {
        return 0.0;
      }

      const double angle_b1_a1_a2( linal::ProjAngleCosinus( ca_a, cb_a, cb_b));
      const double angle_b2_a2_a1( linal::ProjAngleCosinus( ca_b, cb_b, cb_a));

      double f
      (
        ( *m_Histograms)( TYPE_A->GetIndex())( TYPE_B->GetIndex())
                        ( AMINO_ACID_A.GetType())( AMINO_ACID_B.GetType())
                        ->Value( DISTANCE, angle_b2_a2_a1, angle_b1_a1_a2)
      );

      // return the score
      return f;
    }

    //! @brief calculate clash score for a protein model
    //! @param MODEL the protein model of interest
    //! @return amino acid pairing potential for given protein
    double AAPairContactEnergy::operator()( const assemble::ProteinModel &MODEL) const
    {
      assemble::VoxelGridAA s_voxel_grid( m_DistanceCutoff);

      s_voxel_grid.SetObjects( MODEL.GetAminoAcids());
      double score( 0.0);

      // hash sses for all amino acid ids
      storage::Vector< storage::Vector< size_t> > sse_id( size_t( 128));
      storage::Vector< storage::Vector< size_t> > sse_type( size_t( 128));
      size_t current_sse_id( 0);
      for
      (
        auto itr_chain( MODEL.GetChains().Begin()), itr_chain_end( MODEL.GetChains().End());
        itr_chain != itr_chain_end;
        ++itr_chain
      )
      {
        storage::Vector< size_t> &chain_vec( sse_id( size_t( ( *itr_chain)->GetChainID())));
        chain_vec.Resize
        (
          size_t
          (
            ( *itr_chain)->GetSequence()->GetLastMember()->GetSeqID()
            + 1
          ),
          util::GetUndefined< size_t>()
        );
        storage::Vector< size_t> &chain_type_vec( sse_type( size_t( ( *itr_chain)->GetChainID())));
        chain_type_vec.Resize
        (
          size_t
          (
            ( *itr_chain)->GetSequence()->GetLastMember()->GetSeqID()
            + 1
          ),
          biol::GetSSTypes().COIL
        );
        util::SiPtrVector< const assemble::SSE> sses( ( *itr_chain)->GetSSEs());
        for( auto itr_sses( sses.Begin()), itr_sses_end( sses.End()); itr_sses != itr_sses_end; ++itr_sses)
        {
          // whether to consider loops
          if( !m_ConsiderLoops)
          {
            // for now, we aren't considering coils, though the data for this exists in the histogram file
            if( !( *itr_sses)->GetType()->IsStructured())
            {
              continue;
            }
          }
          int seq_id_start( ( *itr_sses)->GetFirstAA()->GetSeqID());
          int seq_id_end( ( *itr_sses)->GetLastAA()->GetSeqID());
          for( int pos( seq_id_start); pos <= seq_id_end; ++pos)
          {
            chain_vec( pos) = current_sse_id;
            chain_type_vec( pos) = ( *itr_sses)->GetType();
          }
          ++current_sse_id;
        }
      }
      storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> >
        res( s_voxel_grid.GetNeighbors( m_DistanceCutoff));
      for( auto itr( res.Begin()), itr_end( res.End()); itr != itr_end; ++itr)
      {
        const auto &triplet( *itr);
        const size_t sse1( sse_id( size_t( triplet.First()->GetChainID()))( triplet.First()->GetSeqID()));
        const size_t sse2( sse_id( size_t( triplet.Second()->GetChainID()))( triplet.Second()->GetSeqID()));
        const biol::SSType sse1_type( sse_type( size_t( triplet.First()->GetChainID()))( triplet.First()->GetSeqID()));
        const biol::SSType sse2_type( sse_type( size_t( triplet.Second()->GetChainID()))( triplet.Second()->GetSeqID()));
        if( !util::IsDefined( sse1) || !util::IsDefined( sse2))
        {
          continue;
        }
        if( sse1 == sse2 && util::IsDefined( sse1))
        {
          continue;
        }
        if( biol::SequenceSeparation( *triplet.First(), *triplet.Second()) < 2)
        {
          // ignore adjacent aas
          continue;
        }
        if( m_InterfaceOnly)
        {
          // ignore residue pairs in the same chain
          if( triplet.First()->GetChainID() == triplet.Second()->GetChainID())
          {
            continue;
          }
        }
        score += this->operator()( *triplet.First(), *triplet.Second(), triplet.Third(), sse1_type, sse2_type);
      }
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairContactEnergy::WriteDetailedSchemeAndValues
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      const biol::SSType &TYPE_A,
      const biol::SSType &TYPE_B,
      std::ostream &OSTREAM
    ) const
    {
      // calculate the CB Distance
      const double cb_distance( biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B));

      // if distance is not defined return 0
      if( !util::IsDefined( cb_distance))
      {
        return OSTREAM;
      }
      // calculate the angles distance
      const linal::Vector3D &ca_a( AMINO_ACID_A.GetCA().GetCoordinates());
      const linal::Vector3D &cb_a( AMINO_ACID_A.GetFirstSidechainAtom().GetCoordinates());
      const linal::Vector3D &ca_b( AMINO_ACID_B.GetCA().GetCoordinates());
      const linal::Vector3D &cb_b( AMINO_ACID_B.GetFirstSidechainAtom().GetCoordinates());

      // check that distance is defined
      if
      (
        !ca_a.IsDefined()
        || !ca_b.IsDefined()
        || !cb_a.IsDefined()
        || !cb_b.IsDefined()
        || !AMINO_ACID_A.GetType()->IsNaturalAminoAcid()
        || !AMINO_ACID_B.GetType()->IsNaturalAminoAcid()
      )
      {
        return OSTREAM;
      }

      const double angle_b1_a1_a2( linal::ProjAngleCosinus( ca_a, cb_a, cb_b));
      const double angle_b2_a2_a1( linal::ProjAngleCosinus( ca_b, cb_b, cb_a));

      // write Scheme
      OSTREAM << AMINO_ACID_A.GetSeqID() << '\t'
              << AMINO_ACID_A.GetType()->GetThreeLetterCode() << '\t'
              << AMINO_ACID_B.GetSeqID() << '\t'
              << AMINO_ACID_B.GetType()->GetThreeLetterCode() << '\t'
              << cb_distance << '\t'
              << angle_b2_a2_a1 << '\t'
              << angle_b1_a1_a2 << '\t'
              << operator()( AMINO_ACID_A, AMINO_ACID_B, cb_distance, TYPE_A, TYPE_B) << '\n';

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param MODEL model of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairContactEnergy::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &MODEL,
      std::ostream &OSTREAM
    ) const
    {
      assemble::VoxelGridAA s_voxel_grid( m_DistanceCutoff);

      s_voxel_grid.SetObjects( MODEL.GetAminoAcids());

      // hash sses for all amino acid ids
      // hash sses for all amino acid ids
      storage::Vector< storage::Vector< size_t> > sse_id( size_t( 128));
      storage::Vector< storage::Vector< size_t> > sse_type( size_t( 128));
      size_t current_sse_id( 0);
      for
      (
        auto itr_chain( MODEL.GetChains().Begin()), itr_chain_end( MODEL.GetChains().End());
        itr_chain != itr_chain_end;
        ++itr_chain
      )
      {
        storage::Vector< size_t> &chain_vec( sse_id( size_t( ( *itr_chain)->GetChainID())));
        chain_vec.Resize
        (
          size_t
          (
            ( *itr_chain)->GetSequence()->GetLastMember()->GetSeqID()
            + 1
          ),
          util::GetUndefined< size_t>()
        );
        storage::Vector< size_t> &chain_type_vec( sse_type( size_t( ( *itr_chain)->GetChainID())));
        chain_type_vec.Resize
        (
          size_t
          (
            ( *itr_chain)->GetSequence()->GetLastMember()->GetSeqID()
            + 1
          ),
          biol::GetSSTypes().COIL
        );
        util::SiPtrVector< const assemble::SSE> sses( ( *itr_chain)->GetSSEs());
        for( auto itr_sses( sses.Begin()), itr_sses_end( sses.End()); itr_sses != itr_sses_end; ++itr_sses)
        {
          // for now, we aren't considering coils, though the data for this exists in the histogram file
          if( !( *itr_sses)->GetType()->IsStructured())
          {
            continue;
          }
          int seq_id_start( ( *itr_sses)->GetFirstAA()->GetSeqID());
          int seq_id_end( ( *itr_sses)->GetLastAA()->GetSeqID());
          for( int pos( seq_id_start); pos <= seq_id_end; ++pos)
          {
            chain_vec( pos) = current_sse_id;
            chain_type_vec( pos) = ( *itr_sses)->GetType();
          }
          ++current_sse_id;
        }
      }
      storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> >
        res( s_voxel_grid.GetNeighbors( m_DistanceCutoff));
      for( auto itr( res.Begin()), itr_end( res.End()); itr != itr_end; ++itr)
      {
        const auto &triplet( *itr);
        const size_t sse1( sse_id( size_t( triplet.First()->GetChainID()))( triplet.First()->GetSeqID()));
        const size_t sse2( sse_id( size_t( triplet.Second()->GetChainID()))( triplet.Second()->GetSeqID()));
        const biol::SSType sse1_type( sse_type( size_t( triplet.First()->GetChainID()))( triplet.First()->GetSeqID()));
        const biol::SSType sse2_type( sse_type( size_t( triplet.Second()->GetChainID()))( triplet.Second()->GetSeqID()));
        if( !util::IsDefined( sse1) || !util::IsDefined( sse2))
        {
          continue;
        }
        if( sse1 == sse2 && util::IsDefined( sse1))
        {
          continue;
        }
        if( biol::SequenceSeparation( *triplet.First(), *triplet.Second()) < 2)
        {
          // ignore adjacent aas
          continue;
        }
        this->WriteDetailedSchemeAndValues( *triplet.First(), *triplet.Second(), sse1_type, sse2_type, OSTREAM);
      }
      return OSTREAM;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AAPairContactEnergy::GetSerializer() const
    {
      io::Serializer serializer;

      serializer.SetClassDescription
      (
        "Scores amino acid pair distance and angles for interaction energy (neglecting clash) "
        "Uses probability of interaction (based on distance and angles) computed from the pdb and contact energies from "
        "http://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-4-8"
      );
      serializer.AddInitializer
      (
        "contact p cutoff",
        "if two residues are less than this % likely to be interacting at their current distance/orientation, use 0 for "
        "this score rather than the computed propensity",
        io::Serialization::GetAgent( &m_ContactProbabilityCutoff),
        "0.01"
      );
      serializer.AddInitializer
      (
        "consider loops",
        "whether consider loops when computing contact energy and clashes",
        io::Serialization::GetAgent( &m_ConsiderLoops),
        "True"
      );
      serializer.AddInitializer
      (
        "interface only",
        "whether to score interface only",
        io::Serialization::GetAgent( &m_InterfaceOnly),
        "True"
      );

      return serializer;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief read map of amino acid pair energies based on distance from histogram files
    void AAPairContactEnergy::ReadEnergyFunctionMap()
    {
      m_Histograms = util::ToSiPtr( GetHistograms( m_HistogramFileName));

      // static distance cutoff
      // might want to shorten this. Beyond 8A, only charged or aromatic types have a significant
      // chance of interacting, and even then only if directly facing each other. Having it at
      // 12 A costs a lot of extra computation
      m_DistanceCutoff = 12.0;
    }

    //! @brief set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @return ERROR_STREAM stream with which to write errors
    bool AAPairContactEnergy::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERROR_STREAM
    )
    {
      if( !command::CommandState::IsInStaticInitialization())
      {
        ReadEnergyFunctionMap();
      }
      return true;
    }

    //! @brief Get histograms from a particular file. Caches histograms so they need only be read in once
    const AAPairContactEnergy::SSEPairAAPairHistogramType &AAPairContactEnergy::GetHistograms( const std::string &FILENAME) const
    {
      static storage::Map< std::string, SSEPairAAPairHistogramType> s_histograms;
      SSEPairAAPairHistogramType &histogram_vec( s_histograms[ FILENAME]);
      if( !histogram_vec( 0)( 0).IsEmpty() || command::CommandState::IsInStaticInitialization())
      {
        return histogram_vec;
      }

      const size_t n_sse_types( 3);
      // store map of all aa pairs with their histogram
      for( size_t i( 0); i < n_sse_types; ++i)
      {
        for( size_t j( 0); j < n_sse_types; ++j)
        {
          histogram_vec( i)( j).Reset();
          histogram_vec( i)( j).Resize
          (
            biol::AATypes::s_NumberStandardAATypes,
            util::ShPtrVector< math::Histogram3D>( biol::AATypes::s_NumberStandardAATypes)
          );
        }
      }

      AAPairHiResClash clash;
      auto clash_hist( clash.GetHistograms());

      // read file with all histograms for each pair of aa types
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( FILENAME));

      size_t outer_ss_type( 0), inner_ss_type( 0);

      // initialize temporary strings to read
      std::string tmp_a, tmp_b;

      // while reading the aatype pair and until reaching the end of the file
      while( read >> tmp_a >> tmp_b && !read.eof())
      {
        // read the string and convert it to first aa type
        biol::AAType a( biol::GetAATypes().AATypeFromOneLetterCode( tmp_a[0]));
        biol::AAType b( biol::GetAATypes().AATypeFromOneLetterCode( tmp_b[0]));

        // read the histogram
        util::ShPtr< math::Histogram3D> histogram( new math::Histogram3D);
        read >> *histogram;
        if( histogram_vec( outer_ss_type)( inner_ss_type)( a)( b).IsDefined())
        {
          ++inner_ss_type;
          if( inner_ss_type == n_sse_types)
          {
            inner_ss_type = 0;
            ++outer_ss_type;
          }
        }
        auto binning( histogram->GetBinningXYZ());
        const size_t n_bins_x( histogram->GetNumberOfBinsX()),
                     n_bins_y( histogram->GetNumberOfBinsY()),
                     n_bins_z( histogram->GetNumberOfBinsZ());
        auto clash_hist_ab( *clash_hist( a)( b));
        for( size_t i( 0); i < n_bins_x; ++i)
        {
          for( size_t j( 0); j < n_bins_y; ++j)
          {
            for( size_t k( 0); k < n_bins_z; ++k)
            {
              if( clash_hist_ab.Interpolate( binning( 0)( i), binning( 1)( j), binning( 2)( k)) < m_ContactProbabilityCutoff)
              {
                histogram->GetChangeableHistogram()( i, j, k) = 0.0;
              }
            }
          }
        }
        histogram_vec( outer_ss_type)( inner_ss_type)( a)( b)
          = histogram_vec( outer_ss_type)( inner_ss_type)( b)( a) = histogram;
      }

      // close the stream
      io::File::CloseClearFStream( read);
      return histogram_vec;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_pair_distance.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "biol/bcl_biol_aa_base.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_gnuplot_heatmap.h"
#include "math/bcl_math_histogram.h"
#include "score/bcl_score_energy_distribution.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &AAPairDistance::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "aa_distances.histograms");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &AAPairDistance::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "aadist");

      // end
      return s_default_scheme;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &AAPairDistance::GetAlias() const
    {
      static const std::string s_name( "AAPairDistance");
      return s_name;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param SCHEME scheme to be used
    AAPairDistance::AAPairDistance
    (
      const std::string &HISTOGRAM_FILENAME,
      const std::string &SCHEME
    ) :
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_Scheme( SCHEME),
      m_EnergyFunctionMap(),
      m_DistanceCutoff( 0.0)
    {
      // read the histogram file and store the energy functions
      ReadEnergyFunctionMap();
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAPairDistance object that is copied from this one
    AAPairDistance *AAPairDistance::Clone() const
    {
      return new AAPairDistance( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAPairDistance::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairDistance::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B
    ) const
    {
      // calculate the distance
      const double distance( biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B));

      // return the score
      return operator()( AMINO_ACID_A, AMINO_ACID_B, distance);
    }

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param DISTANCE distance between the amino acid pair
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairDistance::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      const double DISTANCE
    ) const
    {
      // check that distance is defined
      if( !util::IsDefined( DISTANCE))
      {
        return 0.0;
      }

      // construct biol::AAType pair
      storage::Pair< biol::AAType, biol::AAType> type_pair( AMINO_ACID_A.GetType(), AMINO_ACID_B.GetType());

      // search the map for this aa type pair and store the iterator
      storage::Map
      <
        storage::Pair< biol::AAType, biol::AAType>,
        util::ShPtr< math::CubicSplineDamped>
      >::const_iterator
      itr_find
      (
        m_EnergyFunctionMap.Find( type_pair)
      );

      // if the itr is not valid
      if( itr_find == m_EnergyFunctionMap.End())
      {
        // return undefined
        return double( 0);
      }

      // now call the scoring function for the found energy function
      return itr_find->second->operator()( DISTANCE);
    }

    //! @brief calculate clash score for a protein model
    //! @param MODEL the protein model of interest
    //! @return amino acid pairing potential for given protein
    double AAPairDistance::operator()( const assemble::ProteinModel &MODEL) const
    {
      assemble::VoxelGridAA s_voxel_grid( m_DistanceCutoff);

      s_voxel_grid.SetObjects( MODEL.GetAminoAcids());
      double score( 0.0);

      storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> >
        res( s_voxel_grid.GetNeighbors( m_DistanceCutoff));
      for( auto itr( res.Begin()), itr_end( res.End()); itr != itr_end; ++itr)
      {
        score += operator()( *itr->First(), *itr->Second(), itr->Third());
      }
      return score;
    }

    //! @brief calculate clash score for SSEs
    //! @param SSE_A, SSE_B the SSEs to check for clashes
    //! @return clash score
    double AAPairDistance::operator()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      assemble::VoxelGridAA voxel_grid_a( m_DistanceCutoff);
      voxel_grid_a.SetObjects( util::SiPtrVector< const biol::AABase>( SSE_A.Begin(), SSE_A.End()));
      double score( 0.0);
      for( auto itr_b( SSE_B.Begin()), itr_b_end( SSE_B.End()); itr_b != itr_b_end; ++itr_b)
      {
        storage::Vector< storage::Pair< util::SiPtr< const biol::AABase>, double> >
          res( voxel_grid_a.GetNeighbors( **itr_b, m_DistanceCutoff));
        for( auto itr( res.Begin()), itr_end( res.End()); itr != itr_end; ++itr)
        {
          const auto &pr( *itr);
          score += this->operator()( **itr_b, *pr.First(), pr.Second());
        }
      }
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAPairDistance::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_HistogramFileName, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // read the histogram file and store the energy functions
      ReadEnergyFunctionMap();

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAPairDistance::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_HistogramFileName, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairDistance::WriteDetailedSchemeAndValues
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      std::ostream &OSTREAM
    ) const
    {
      // calculate the CB Distance
      const double cb_distance( biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B));

      // if distance is not defined return 0
      if( !util::IsDefined( cb_distance))
      {
        return OSTREAM;
      }

      // write Scheme
      OSTREAM << AMINO_ACID_A.GetSeqID() << '\t'
              << AMINO_ACID_A.GetType()->GetThreeLetterCode() << '\t'
              << AMINO_ACID_B.GetSeqID() << '\t'
              << AMINO_ACID_B.GetType()->GetThreeLetterCode() << '\t'
              << cb_distance << '\t'
              << operator()( AMINO_ACID_A, AMINO_ACID_B) << '\n';

      // end
      return OSTREAM;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AAPairDistance::GetSerializer() const
    {
      io::Serializer serializer;

      serializer.SetClassDescription( "Scores amino acid pair distances.");
      serializer.AddInitializer
      (
        "histogram filename",
        "path to file where the statistics and in consequence the energy potentials are read from",
        io::Serialization::GetAgent( &m_HistogramFileName),
        GetDefaultHistogramFilename()
      );
      serializer.AddInitializer
      (
        "distance cutoff",
        "distance cutoff above which score will always be 0",
        io::Serialization::GetAgent( &m_DistanceCutoff),
        "0.0"
      );

      return serializer;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief read map of amino acid pair energies based on distance from histogram files
    void AAPairDistance::ReadEnergyFunctionMap()
    {
      // reset distance cutoff to 0
      m_DistanceCutoff = 0.0;

      // store map of all aa pairs with their histogram
      storage::Map
      <
        storage::Pair< biol::AAType, biol::AAType>,
        math::Histogram
      > histogram_map;

      // read file with all histograms for each pair of aa types
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      // initialize temporary strings to read
      std::string tmp_a, tmp_b;

      // while reading the aatype pair and until reaching the end of the file
      while( read >> tmp_a >> tmp_b && !read.eof())
      {
        // read the string and convert it to first aa type
        storage::Pair< biol::AAType, biol::AAType> aa_type_pair
        (
          biol::GetAATypes().AATypeFromOneLetterCode( tmp_a[0]),
          biol::GetAATypes().AATypeFromOneLetterCode( tmp_b[0])
        );

        // abort if any of the aatypes if unknown
        if
        (
          aa_type_pair.First() == biol::GetAATypes().e_Undefined ||
          aa_type_pair.Second() == biol::GetAATypes().e_Undefined
        )
        {
          // alert user and break
          BCL_MessageCrt
          (
            "undefined AAType found in the histogram " + util::Format()( aa_type_pair)
          );
          break;
        }

        // read the histogram
        read >> histogram_map[ aa_type_pair];
      }

      // keep track of sum of normalized distributions of first aa with all other aas and second aa with all other aas
      storage::Map
      <
        storage::Pair< biol::AAType, biol::AAType>,
        math::Histogram
      > histogram_sum_map;

      for
      (
        storage::Map
        <
          storage::Pair< biol::AAType, biol::AAType>,
          math::Histogram
        >::const_iterator itr( histogram_map.Begin()), itr_end( histogram_map.End());
        itr != itr_end;
        ++itr
      )
      {
        // normalize the histogram before combining, to remove bias to certain aa types
        math::Histogram current_histogram( itr->second);
        current_histogram.Normalize();

        // sum all distributions for each amino acid pair to all other amino acid pairs - for each pair this should add up to a sum to 40 histogram combinations
        for
        (
          biol::AATypes::const_iterator
            aa_type_itr( biol::GetAATypes().Begin()), aa_type_itr_end( biol::GetAATypes().VAL.GetIterator());
          aa_type_itr <= aa_type_itr_end;
          ++aa_type_itr
        )
        {
          // sum for the first amino acid to all other
          if( *aa_type_itr <= itr->first.First())
          {
            BCL_Assert
            (
              ( histogram_sum_map[ storage::Pair< biol::AAType, biol::AAType>( *aa_type_itr, itr->first.First())]).Combine( current_histogram),
              "unable to combine histograms of different parameters"
            );
          }
          else
          {
            BCL_Assert
            (
              ( histogram_sum_map[ storage::Pair< biol::AAType, biol::AAType>( itr->first.First(), *aa_type_itr)]).Combine( current_histogram),
              "unable to combine histograms of different parameters"
            );
          }

          // sum for the second amino acid to all other
          if( *aa_type_itr <= itr->first.Second())
          {
            BCL_Assert
            (
              ( histogram_sum_map[ storage::Pair< biol::AAType, biol::AAType>( *aa_type_itr, itr->first.Second())]).Combine( current_histogram),
              "unable to combine histograms of different parameters"
            );
          }
          else
          {
            BCL_Assert
            (
              ( histogram_sum_map[ storage::Pair< biol::AAType, biol::AAType>( itr->first.Second(), *aa_type_itr)]).Combine( current_histogram),
              "unable to combine histograms of different parameters"
            );
          }
        }
      }

      // normalize the histogram sum
      for
      (
        storage::Map
        <
          storage::Pair< biol::AAType, biol::AAType>,
          math::Histogram
        >::iterator itr( histogram_sum_map.Begin()), itr_end( histogram_sum_map.End());
        itr != itr_end;
        ++itr
      )
      {
        itr->second.Normalize();
      }

      // write background distributions
      if( util::GetMessenger().IsSmallerEqualCurrentMessageLevel( util::Message::e_Debug))
      {
        util::SiPtrVector< const math::Histogram> histograms;
        storage::Vector< std::string> histograms_descriptors;

        for
        (
          storage::Map
          <
            storage::Pair< biol::AAType, biol::AAType>,
            math::Histogram
          >::const_iterator itr( histogram_sum_map.Begin()), itr_end( histogram_sum_map.End());
          itr != itr_end;
          ++itr
        )
        {
          // skip redundant pairs
          if( itr->first.First() > itr->first.Second())
          {
            continue;
          }
          histograms.PushBack( itr->second);
          histograms_descriptors.PushBack( itr->first.First()->GetThreeLetterCode() + " " + itr->first.Second()->GetThreeLetterCode());
        }

        // write splines to gnuplot file
        io::OFStream write;
        io::File::MustOpenOFStream( write, "aa_pair_distance_background.gnuplot");
        math::GnuplotHeatmap heatmap;
        heatmap.SetFromHistograms( histograms, false, false);
        heatmap.SetTicsY( histograms_descriptors, true, 1);
        heatmap.SetPixelAndRatio( 1080, 8000, util::GetUndefined< double>());
        heatmap.SetTitleAndLabel( "amino acid pair distance background", "distance [" + math::GnuplotHeatmap::s_AngstromSymbolGnuplot + "]", "amino acid pair type", "SUM(p)");
        heatmap.SetFont( "arialbd", 16);
        heatmap.SetFilename( "aa_pair_distance_background");
        heatmap.WriteScript( write);
        io::File::CloseClearFStream( write);
      }

      // generate energy distribution for all possible amino acid pairs
      for
      (
        biol::AATypes::const_iterator
          aa_type_itr1( biol::GetAATypes().Begin()), aa_type_itr_end( biol::GetAATypes().VAL.GetIterator());
        aa_type_itr1 <= aa_type_itr_end;
        ++aa_type_itr1
      )
      {
        for
        (
          biol::AATypes::const_iterator aa_type_itr2( aa_type_itr1);
          aa_type_itr2 <= aa_type_itr_end;
          ++aa_type_itr2
        )
        {
          const storage::Pair< biol::AAType, biol::AAType> current_aa_pair( *aa_type_itr1, *aa_type_itr2);

          // create spline for the current distribution
          util::ShPtr< math::CubicSplineDamped> current_spline
          (
            new math::CubicSplineDamped
            (
              EnergyDistribution::AAPairPotential( histogram_map[ current_aa_pair], histogram_sum_map[ current_aa_pair], true)
//              EnergyDistribution::AAPairPotential( histogram_map[ current_aa_pair], histogram_sum_map[ current_aa_pair], false)
            )
          );

          // store the spline in the map
          m_EnergyFunctionMap[ storage::Pair< biol::AAType, biol::AAType>( *aa_type_itr1, *aa_type_itr2)] = current_spline;

          // reverse the pair and insert it
          m_EnergyFunctionMap[ storage::Pair< biol::AAType, biol::AAType>( *aa_type_itr2, *aa_type_itr1)] = current_spline;
        }
      }
      m_DistanceCutoff = 8.0;

      // close the stream
      io::File::CloseClearFStream( read);
    }

    //! @brief set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @return ERROR_STREAM stream with which to write errors
    bool AAPairDistance::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERROR_STREAM
    )
    {
      ReadEnergyFunctionMap();
      return true;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_pair_distance_fitted_function.h"

// includes from bcl - sorted alphabetically
#include "math/bcl_math_histogram.h"
#include "math/bcl_math_statistics.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  ///////////
  // data //
  //////////

    //! default start values for the start of the repulsion term for the fitted aapairenergy distribution
    const storage::VectorND< 2, double> AAPairDistanceFittedFunction::s_DefaultRepulsionStartXY( 2.0, 10.0);

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AAPairDistanceFittedFunction::AAPairDistanceFittedFunction() :
      m_RepulsionStartXY( s_DefaultRepulsionStartXY)
    {
    }

    //! @brief constructor from a given histogram
    //! @param AA_PAIR_DISTANCE_DISTRIBUTION Histogram that containes aa pair distance distribution
    AAPairDistanceFittedFunction::AAPairDistanceFittedFunction
    (
      const math::Histogram &AA_PAIR_DISTANCE_DISTRIBUTION
    ) :
      m_RepulsionStartXY( s_DefaultRepulsionStartXY)
    {
      linal::Vector< double> aa_distance_counts( AA_PAIR_DISTANCE_DISTRIBUTION.GetHistogram());
      const linal::Vector< double> distance_bins( AA_PAIR_DISTANCE_DISTRIBUTION.GetBinning());

      const size_t usedbins( 20);

      //divide by the total number of all pairs
      double totalcounts( 0);

      //divide each count in bin by distance distribution square
      const double *bins( distance_bins.Begin()), *bins_end( distance_bins.End());
      size_t i( 0);
      for
      (
        double *counts( aa_distance_counts.Begin()), *counts_end( aa_distance_counts.End());
        counts != counts_end && bins != bins_end && i < usedbins; ++counts, ++bins, ++i
      )
      {
        //divide by distance^2
        *counts /= math::Sqr( *bins);

        //add pseudo count
        *counts += 1;

        totalcounts += ( *counts);
      }
//      totalcounts += AA_PAIR_DISTANCE_DISTRIBUTION.GetBoundariesCounts().Second() / Sqr( AA_PAIR_DISTANCE_DISTRIBUTION.GetBoundaries().Second());

      linal::Vector< double> energydistributionvector( 20, aa_distance_counts.Begin());

      //-log of every bin to have the energy
      for
      (
        double *ptr( energydistributionvector.Begin()), *ptr_end( energydistributionvector.End());
        ptr != ptr_end; ++ptr
      )
      {
        ( *ptr) /= totalcounts / 20;
        ( *ptr) = -log( *ptr);
      }

//      const double shift = -1.5;

      // shift all values but the last by shift, last value set to zero
//      aa_distance_counts -= shift;
      *( energydistributionvector.End() - 1) = 0;

      //determine minimal value and index;
      const size_t index_energy_minima
      (
        math::Statistics::MinimumIndex( energydistributionvector.Begin(), energydistributionvector.End())
      );
      m_AttractionMinimumXY.First() = double( distance_bins( index_energy_minima));
      m_AttractionMinimumXY.Second() = energydistributionvector( index_energy_minima);

      //determine index of last positive value which is the Repulsion End
      for( size_t i( 0); i < energydistributionvector.GetSize(); ++i)
      {
        if( energydistributionvector( i) < 0)
        {
          m_RepulsionEndXY.First() = distance_bins( i);
          break;
        }
      }
      m_RepulsionEndXY.Second() = 0.0;

      m_AttractionStartXY = storage::VectorND< 2, double>( m_RepulsionStartXY.First(), 0);
      m_AttractionEndXY = storage::VectorND< 2, double>( std::min( 20.0, 2 * m_AttractionMinimumXY.First() - m_RepulsionStartXY.First()), 0);

//        BCL_MessageStd( "m_RepulsionStartXY:    " + util::Format()( m_RepulsionStartXY   ));
//        BCL_MessageStd( "m_RepulsionEndXY:      " + util::Format()( m_RepulsionEndXY     ));
//        BCL_MessageStd( "m_AttractionStartXY:   " + util::Format()( m_AttractionStartXY  ));
//        BCL_MessageStd( "m_AttractionMinimumXY: " + util::Format()( m_AttractionMinimumXY));
//        BCL_MessageStd( "m_AttractionEndXY:     " + util::Format()( m_AttractionEndXY    ));
//
//        for( double dist = 0.0; dist < 25; dist += 1.0)
//        {
//          BCL_MessageStd( util::Format()( dist) + "\t|\t" + util::Format()( Repulsion( dist)) + "\t|\t" + util::Format()( Attraction( dist)) + "\t|\t" + util::Format()( F( dist)));
//        }
    }

    //! @brief construct from a vector of bins and a given energy distribution
    //! @param BINNING binning to be used
    //! @param ENERGY_DISTRIBUTION energy distribution to be used
    AAPairDistanceFittedFunction::AAPairDistanceFittedFunction
    (
      const linal::Vector< double> &BINNING,
      const linal::Vector< double> &ENERGY_DISTRIBUTION
    ) :
      m_RepulsionStartXY( s_DefaultRepulsionStartXY)
    {
      const size_t index_energy_minima
      (
        math::Statistics::MinimumIndex( ENERGY_DISTRIBUTION.Begin(), ENERGY_DISTRIBUTION.End())
      );
      //determine minimal value and index;
      m_AttractionMinimumXY.First() = double( BINNING( index_energy_minima));
      m_AttractionMinimumXY.Second() = ENERGY_DISTRIBUTION( index_energy_minima);

      //determine index of last positive value which is the Repulsion End
      for( size_t i( 0); i < ENERGY_DISTRIBUTION.GetSize(); ++i)
      {
        if( ENERGY_DISTRIBUTION( i) < 0)
        {
          m_RepulsionEndXY.First() = BINNING( i);
          break;
        }
      }

      m_AttractionStartXY = storage::VectorND< 2, double>( m_RepulsionStartXY.First(), 0);
      m_AttractionEndXY = storage::VectorND< 2, double>( std::min( 20.0, 2 * m_AttractionMinimumXY.First() - m_RepulsionStartXY.First()), 0);
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAPairDistanceFittedFunction copied from this one
    AAPairDistanceFittedFunction *AAPairDistanceFittedFunction::Clone() const
    {
      return new AAPairDistanceFittedFunction( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAPairDistanceFittedFunction::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculate the energy according to the distance
    //! @param DISTANCE distance to be used
    //! @return the energy calculated for the given distance
    double AAPairDistanceFittedFunction::operator()( const double &DISTANCE) const
    {
//      if( DISTANCE < 15.0)
//      {
//        BCL_Message
//        (
//          util::Message::e_Standard,
//          util::Format()( DISTANCE) + "|" + util::Format()( Repulsion( DISTANCE)) +
//            "|" + util::Format()( Attraction( DISTANCE))
//        );
//      }
      return Repulsion( DISTANCE) + Attraction( DISTANCE);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAPairDistanceFittedFunction::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_RepulsionStartXY, ISTREAM);
      io::Serialize::Read( m_RepulsionEndXY, ISTREAM);
      io::Serialize::Read( m_AttractionStartXY, ISTREAM);
      io::Serialize::Read( m_AttractionMinimumXY, ISTREAM);
      io::Serialize::Read( m_AttractionEndXY, ISTREAM);

      //end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAPairDistanceFittedFunction::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      //write member
      io::Serialize::Write( m_RepulsionStartXY, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_RepulsionEndXY, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AttractionStartXY, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AttractionMinimumXY, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AttractionEndXY, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculates the repulsion for the given distance
    //! @param DISTANCE distance to be used
    //! @return the repulsion for the given distance
    double AAPairDistanceFittedFunction::Repulsion( const double &DISTANCE) const
    {
      if( DISTANCE <= m_RepulsionStartXY.First())
      {
        return m_RepulsionStartXY.Second();
      }

      else if( DISTANCE >= m_RepulsionEndXY.First())
      {
        return m_RepulsionEndXY.Second();
      }

      else
      {
        return
        0.5 * ( m_RepulsionStartXY.Second() - m_RepulsionEndXY.Second()) *
        std::cos
        (
          math::g_Pi *
          ( DISTANCE - m_RepulsionStartXY.First())
          / ( m_RepulsionEndXY.First() - m_RepulsionStartXY.First())
        ) + 0.5 * ( m_RepulsionStartXY.Second() - m_RepulsionEndXY.Second());
      }
    }

    //! @brief calculates the attraction for the given distance
    //! @param DISTANCE distance to be used
    //! @return the attraction for the given distance
    double AAPairDistanceFittedFunction::Attraction( const double &DISTANCE) const
    {
      //if argument is smaller than begin of attraction return start
      if( DISTANCE <= m_AttractionStartXY.First())
      {
        return m_AttractionStartXY.Second();
      }

      //if argument is larger than begin of attraction return end
      else if( DISTANCE >= m_AttractionEndXY.First())
      {
        return m_AttractionEndXY.Second();
      }

      else
      {
        return
        m_AttractionStartXY.Second() +
          ( m_AttractionStartXY.Second() - m_AttractionMinimumXY.Second()) *
          0.5 *
          (
            std::cos
            (
              2 * math::g_Pi *
              (
                ( DISTANCE - m_AttractionStartXY.First()) /
                ( m_AttractionEndXY.First() - m_AttractionStartXY.First())
              )
             ) - 1
          );
      }
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_pair_distance_smooth.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_histogram.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &AAPairDistanceSmooth::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "aa_distances.histograms");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &AAPairDistanceSmooth::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "aasmooth");

      // end
      return s_default_scheme;

    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param SCHEME scheme to be used
    AAPairDistanceSmooth::AAPairDistanceSmooth
    (
      const std::string &HISTOGRAM_FILENAME, // = GetDefaultHistogramFilename(),
      const std::string &SCHEME// = GetDefaultScheme()
    ) :
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_Scheme( SCHEME),
      m_EnergyFunctionMap(),
      m_DistanceCutoff( 0.0)
    {
      // read the histogram file and store the energy functions
      ReadEnergyFunctionMap();
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAPairDistanceSmooth object that is copied from this one
    AAPairDistanceSmooth *AAPairDistanceSmooth::Clone() const
    {
      return new AAPairDistanceSmooth( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAPairDistanceSmooth::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AAPairDistanceSmooth::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &AAPairDistanceSmooth::GetAlias() const
    {
      static const std::string s_name( "AAPairDistanceSmooth");
      return s_name;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairDistanceSmooth::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B
    ) const
    {
      // calculate the distance
      const double distance( biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B));

      // return the score
      return operator()( AMINO_ACID_A, AMINO_ACID_B, distance);
    }

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param DISTANCE distance between the amino acid pair
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairDistanceSmooth::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      const double DISTANCE
    ) const
    {
      // check that distance is defined
      if( !util::IsDefined( DISTANCE))
      {
        return 0.0;
      }

      // construct biol::AAType pair
      storage::Pair< biol::AAType, biol::AAType> type_pair( AMINO_ACID_A.GetType(), AMINO_ACID_B.GetType());

      // search the map for this aa type pair and store the iterator
      auto itr_find( m_EnergyFunctionMap.Find( type_pair));

      // if the itr is not valid
      if( itr_find == m_EnergyFunctionMap.End())
      {
        // return undefined
        return double( 0);
      }

      // now call the scoring function for the found energy function
      return itr_find->second->operator()( DISTANCE);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAPairDistanceSmooth::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_HistogramFileName, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // read the histogram file and store the energy functions
      ReadEnergyFunctionMap();

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAPairDistanceSmooth::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_HistogramFileName, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairDistanceSmooth::WriteDetailedSchemeAndValues
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      std::ostream &OSTREAM
    ) const
    {
      //write Scheme
      OSTREAM << AMINO_ACID_A.GetSeqID() << '\t'
              << AMINO_ACID_A.GetType()->GetThreeLetterCode() << '\t'
              << AMINO_ACID_B.GetSeqID() << '\t'
              << AMINO_ACID_B.GetType()->GetThreeLetterCode() << '\t'
              << biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B) << '\t'
              << operator()( AMINO_ACID_A, AMINO_ACID_B) << '\n';

      //end
      return OSTREAM;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AAPairDistanceSmooth::GetSerializer() const
    {
      io::Serializer serializer;

      serializer.SetClassDescription( "Scoring AA pair distances with a fitted function.");
      serializer.AddInitializer
      (
        "histogram filename",
        "path to file where the statistics and in consequence the energy potentials are read from",
        io::Serialization::GetAgent( &m_HistogramFileName),
        GetDefaultHistogramFilename()
      );

      return serializer;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief read map of amino acid pair energies based on distance from histogram files
    void AAPairDistanceSmooth::ReadEnergyFunctionMap()
    {
      // reset distance cutoff to 0
      m_DistanceCutoff = 0.0;

      // read file with all histograms for each pair of sstypes
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      std::map< std::pair< biol::AAType, biol::AAType>, util::ShPtr< AAPairDistanceFittedFunction> > energymap;

      // read the two first amino acid types
      std::string tmp_a, tmp_b;
      while( read >> tmp_a >> tmp_b && !read.eof())
      {
        // initialize the variable that are going to be read
        math::Histogram current_aa_distance_histogram;
        storage::Pair< biol::AAType, biol::AAType> aa_type_pair
        (
          biol::GetAATypes().AATypeFromOneLetterCode( tmp_a[0]),
          biol::GetAATypes().AATypeFromOneLetterCode( tmp_b[0])
        );

        // abort if any of the aatypes if unknown
        if
        (
          aa_type_pair.First() == biol::GetAATypes().e_Undefined ||
          aa_type_pair.Second() == biol::GetAATypes().e_Undefined
        )
        {
          // alert user and break
          BCL_MessageCrt
          (
            "undefined AAType found in the histogram " + util::Format()( aa_type_pair)
          );
          break;
        }

        // read the histogram
        read >> current_aa_distance_histogram;

        //create spline for the current distribution and store it in map also as swapped pair
        util::ShPtr< AAPairDistanceFittedFunction> current_energy_function
        (
          new AAPairDistanceFittedFunction( current_aa_distance_histogram)
        );

        m_DistanceCutoff = std::max( m_DistanceCutoff, current_energy_function->GetDistanceCutoff());

        // store the spline in the map
        m_EnergyFunctionMap[ aa_type_pair] = current_energy_function;

        // reverse the pair and insert it
        storage::Pair< biol::AAType, biol::AAType> swapped_aa_type_pair( aa_type_pair.Second(), aa_type_pair.First());
        m_EnergyFunctionMap[ swapped_aa_type_pair] = current_energy_function;
      }

      // close the stream
      io::File::CloseClearFStream( read);
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_pair_hi_res_clash.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"
#include "command/bcl_command_command_state.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "linal/bcl_linal_vector_3d_operations.h"
#include "math/bcl_math_gnuplot_heatmap.h"
#include "math/bcl_math_histogram.h"
#include "math/bcl_math_histogram_2d.h"
#include "math/bcl_math_histogram_3d.h"
#include "score/bcl_score_energy_distribution.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_logger_interface.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    const util::SiPtr< const util::ObjectInterface> AAPairHiResClash::s_ClashInstance
    (
      util::Enumerated< AAPairDistanceInterface>::AddInstance( new AAPairHiResClash())
    );
    const util::SiPtr< const util::ObjectInterface> AAPairHiResClash::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new AAPairHiResClash())
    );

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &AAPairHiResClash::GetAlias() const
    {
      static const std::string s_name( "AAPairHiResClash");
      return s_name;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param SCHEME scheme to be used
    AAPairHiResClash::AAPairHiResClash() :
      m_HistogramFileName( "aapair_contact_probs.histograms3D"),
      m_Scheme( "aa_clash_hires"),
      m_Histograms(),
      m_AngularBinSize( 0.0),
      m_DistanceCutoff( 0.0),
      m_ConsiderLoops( true),
      m_InterfaceOnly( true)
    {
      // read the histogram file and store the energy functions
      ReadInitializerSuccessHook( util::ObjectDataLabel(), util::GetLogger());
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAPairHiResClash object that is copied from this one
    AAPairHiResClash *AAPairHiResClash::Clone() const
    {
      return new AAPairHiResClash( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAPairHiResClash::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairHiResClash::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B
    ) const
    {
      // calculate the Cb distances
      const double cb_cb_distance( biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B));

      // return the score
      return operator()( AMINO_ACID_A, AMINO_ACID_B, cb_cb_distance);
    }

    //! @brief Get the probability that two AAs have heavy atoms within 1A + VDW Radii of one another
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param DISTANCE distance between the amino acid pair
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairHiResClash::GetContactProbability
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      const double DISTANCE
    ) const
    {
      if( AMINO_ACID_A.GetType() > AMINO_ACID_B.GetType())
      {
        return GetContactProbability( AMINO_ACID_B, AMINO_ACID_A, DISTANCE);
      }

      // calculate the angles distance
      const linal::Vector3D &ca_a( AMINO_ACID_A.GetCA().GetCoordinates());
      const linal::Vector3D &cb_a( AMINO_ACID_A.GetFirstSidechainAtom().GetCoordinates());
      const linal::Vector3D &ca_b( AMINO_ACID_B.GetCA().GetCoordinates());
      const linal::Vector3D &cb_b( AMINO_ACID_B.GetFirstSidechainAtom().GetCoordinates());

      // check that distance is defined
      if
      (
        !util::IsDefined( DISTANCE)
        || !ca_a.IsDefined()
        || !ca_b.IsDefined()
        || !cb_a.IsDefined()
        || !cb_b.IsDefined()
        || !AMINO_ACID_A.GetType()->IsNaturalAminoAcid()
        || !AMINO_ACID_B.GetType()->IsNaturalAminoAcid()
      )
      {
        return 0.0;
      }

      const double angle_b1_a1_a2( linal::ProjAngleCosinus( ca_a, cb_a, cb_b));
      const double angle_b2_a2_a1( linal::ProjAngleCosinus( ca_b, cb_b, cb_a));

      double f
      (
        ( *m_Histograms)( AMINO_ACID_A.GetType())( AMINO_ACID_B.GetType())->Value( DISTANCE, angle_b2_a2_a1, angle_b1_a1_a2)
      );
      return std::max( f, 0.0);
    }

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param DISTANCE distance between the amino acid pair
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairHiResClash::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      const double DISTANCE
    ) const
    {
      if( AMINO_ACID_A.GetType() > AMINO_ACID_B.GetType())
      {
        return operator()( AMINO_ACID_B, AMINO_ACID_A, DISTANCE);
      }

      // calculate the angles distance
      const linal::Vector3D &ca_a( AMINO_ACID_A.GetCA().GetCoordinates());
      const linal::Vector3D &cb_a( AMINO_ACID_A.GetFirstSidechainAtom().GetCoordinates());
      const linal::Vector3D &ca_b( AMINO_ACID_B.GetCA().GetCoordinates());
      const linal::Vector3D &cb_b( AMINO_ACID_B.GetFirstSidechainAtom().GetCoordinates());

      // check that distance is defined
      if
      (
        !util::IsDefined( DISTANCE)
        || !ca_a.IsDefined()
        || !ca_b.IsDefined()
        || !cb_a.IsDefined()
        || !cb_b.IsDefined()
        || !AMINO_ACID_A.GetType()->IsNaturalAminoAcid()
        || !AMINO_ACID_B.GetType()->IsNaturalAminoAcid()
      )
      {
        return 0.0;
      }

      const linal::Matrix< double> &clash_matrix( *( *m_ClashDistances)( AMINO_ACID_A.GetType())( AMINO_ACID_B.GetType()));
      const size_t nr_angular_bins( clash_matrix.GetNumberRows() - 1);
      const size_t angle_b1_a1_a2
      (
        std::min( size_t( ( linal::ProjAngleCosinus( ca_a, cb_a, cb_b) + 1.0) / m_AngularBinSize), nr_angular_bins)
      );
      const size_t angle_b2_a2_a1
      (
        std::min( size_t( ( linal::ProjAngleCosinus( ca_b, cb_b, cb_a) + 1.0) / m_AngularBinSize), nr_angular_bins)
      );

      const double clash_distance( clash_matrix( angle_b2_a2_a1, angle_b1_a1_a2));

      double f( DISTANCE < clash_distance ? clash_distance - DISTANCE : 0.0);
      const biol::AAType type_a( AMINO_ACID_A.GetType()), type_b( AMINO_ACID_B.GetType());
      for( auto itr_a( AMINO_ACID_A.GetAtoms().Begin()), itr_a_end( AMINO_ACID_A.GetAtoms().End()); itr_a != itr_a_end; ++itr_a)
      {
        if( !( *itr_a)->GetCoordinates().IsDefined() || !( *itr_a)->GetType()->IsBackBone())
        {
          continue;
        }
        const chemistry::ElementType h_bond_partner
        (
          ( *itr_a)->GetType()->GetElementType() == chemistry::GetElementTypes().e_Hydrogen
          ? chemistry::GetElementTypes().e_Oxygen
          : ( *itr_a)->GetType()->GetElementType() == chemistry::GetElementTypes().e_Oxygen
            ? chemistry::GetElementTypes().e_Hydrogen
            : chemistry::ElementType()
        );
        const double vdw_a( type_a->GetVdwRadiusToOtherAA( ( *itr_a)->GetType()));
        for( auto itr_b( AMINO_ACID_B.GetAtoms().Begin()), itr_b_end( AMINO_ACID_B.GetAtoms().End()); itr_b != itr_b_end; ++itr_b)
        {
          if( !( *itr_b)->GetCoordinates().IsDefined() || !( *itr_b)->GetType()->IsBackBone())
          {
            continue;
          }
          double dist( linal::Distance( ( *itr_b)->GetCoordinates(), ( *itr_a)->GetCoordinates()));
          // Hydrogen bonds can (rarely) have shorter distance than allowed by VdW radii. Handle them specially; just
          // ensure that the distance is less than a covalent bond between the atoms
          if( ( *itr_b)->GetType()->GetElementType() == h_bond_partner)
          {
            if( dist < 1.2)
            {
              f = std::max( f, 1.2 - dist);
            }
          }
          else
          {
            f = std::max( f, std::max( type_b->GetVdwRadiusToOtherAA( ( *itr_b)->GetType()) + vdw_a - dist, 0.0));
          }
        }
      }
      if( f > 0.0)
      {
        BCL_MessageVrb
        (
          "Clash between " + AMINO_ACID_A.GetIdentification()
          + " and " + AMINO_ACID_B.GetIdentification() + " " + util::Format()( f)
        );
      }
      return std::min( f, 1.0);
    }

    //! @brief calculate clash score for a protein model
    //! @param MODEL the protein model of interest
    //! @return amino acid pairing potential for given protein
    double AAPairHiResClash::operator()( const assemble::ProteinModel &MODEL) const
    {
      assemble::VoxelGridAA s_voxel_grid( m_DistanceCutoff);

      auto inter_sse_contacts
      (
        s_voxel_grid.GetSSEConnections
        (
          MODEL.GetSSEs(),
          MODEL.GetAminoAcids(),
          2,
          m_DistanceCutoff,
          m_ConsiderLoops
        )
      );
      double score( 0.0);
      for( auto itr( inter_sse_contacts.Begin()), itr_end( inter_sse_contacts.End()); itr != itr_end; ++itr)
      {
        const auto &triplet( *itr);
        score += this->operator()( *triplet.First(), *triplet.Second(), triplet.Third());
      }
      return score;
    }

    //! @brief calculate clash score for SSEs
    //! @param SSE_A, SSE_B the SSEs to check for clashes
    //! @return clash score
    double AAPairHiResClash::operator()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      if( m_InterfaceOnly && SSE_A.GetChainID() == SSE_B.GetChainID())
      {
        return 0.0;
      }
      assemble::VoxelGridAA voxel_grid_a( m_DistanceCutoff);
      voxel_grid_a.SetObjects( util::SiPtrVector< const biol::AABase>( SSE_A.Begin(), SSE_A.End()));
      double score( 0.0);
      for( auto itr_b( SSE_B.Begin()), itr_b_end( SSE_B.End()); itr_b != itr_b_end; ++itr_b)
      {
        if( !( *itr_b)->GetType()->IsNaturalAminoAcid())
        {
          continue;
        }
        storage::Vector< storage::Pair< util::SiPtr< const biol::AABase>, double> >
          res( voxel_grid_a.GetNeighbors( **itr_b, m_DistanceCutoff));
        for( auto itr( res.Begin()), itr_end( res.End()); itr != itr_end; ++itr)
        {
          const auto &pr( *itr);
          score += this->operator()( **itr_b, *pr.First(), pr.Second());
        }
      }
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairHiResClash::WriteDetailedSchemeAndValues
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      std::ostream &OSTREAM
    ) const
    {
      // calculate the CB Distance
      const double cb_distance( biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B));

      // if distance is not defined return 0
      if( !util::IsDefined( cb_distance))
      {
        return OSTREAM;
      }
      // calculate the angles distance
      const linal::Vector3D &ca_a( AMINO_ACID_A.GetCA().GetCoordinates());
      const linal::Vector3D &cb_a( AMINO_ACID_A.GetFirstSidechainAtom().GetCoordinates());
      const linal::Vector3D &ca_b( AMINO_ACID_B.GetCA().GetCoordinates());
      const linal::Vector3D &cb_b( AMINO_ACID_B.GetFirstSidechainAtom().GetCoordinates());

      // check that distance is defined
      if
      (
        !ca_a.IsDefined()
        || !ca_b.IsDefined()
        || !cb_a.IsDefined()
        || !cb_b.IsDefined()
        || !AMINO_ACID_A.GetType()->IsNaturalAminoAcid()
        || !AMINO_ACID_B.GetType()->IsNaturalAminoAcid()
      )
      {
        return OSTREAM;
      }

      const double angle_b1_a1_a2( linal::ProjAngleCosinus( ca_a, cb_a, cb_b));
      const double angle_b2_a2_a1( linal::ProjAngleCosinus( ca_b, cb_b, cb_a));

      // write Scheme
      OSTREAM << AMINO_ACID_A.GetSeqID() << '\t'
              << AMINO_ACID_A.GetType()->GetThreeLetterCode() << '\t'
              << AMINO_ACID_B.GetSeqID() << '\t'
              << AMINO_ACID_B.GetType()->GetThreeLetterCode() << '\t'
              << cb_distance << '\t'
              << angle_b2_a2_a1 << '\t'
              << angle_b1_a1_a2 << '\t'
              << operator()( AMINO_ACID_A, AMINO_ACID_B, cb_distance) << '\n';

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param MODEL model of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairHiResClash::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &MODEL,
      std::ostream &OSTREAM
    ) const
    {
      assemble::VoxelGridAA s_voxel_grid( m_DistanceCutoff);
      auto inter_sse_contacts
      (
        s_voxel_grid.GetSSEConnections
        (
          MODEL.GetSSEs(),
          MODEL.GetAminoAcids(),
          2,
          m_DistanceCutoff,
          false
        )
      );
      for( auto itr( inter_sse_contacts.Begin()), itr_end( inter_sse_contacts.End()); itr != itr_end; ++itr)
      {
        const auto &triplet( *itr);
        this->WriteDetailedSchemeAndValues( *triplet.First(), *triplet.Second(), OSTREAM);
      }
      return OSTREAM;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AAPairHiResClash::GetSerializer() const
    {
      io::Serializer serializer;

      serializer.SetClassDescription
      (
        "Scores amino acid pair distance and angles for clash "
      );
      serializer.AddInitializer
      (
        "consider loops",
        "whether consider loops when computing contact energy and clashes",
        io::Serialization::GetAgent( &m_ConsiderLoops),
        "True"
      );
      serializer.AddInitializer
      (
        "interface only",
        "whether to score interface only",
        io::Serialization::GetAgent( &m_InterfaceOnly),
        "True"
      );

      return serializer;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    namespace
    {
      //! @brief get a cached clash distance map
      //! @param HISTOGRAMS the histogram3ds to use to derive the clash distances
      const storage::Vector< util::ShPtrVector< linal::Matrix< double> > > &GetClashDistances
      (
        const util::SiPtr< const storage::Vector< util::ShPtrVector< math::Histogram3D> > > &HISTOGRAM3DS
      )
      {
        static storage::Map
        <
          util::SiPtr< const storage::Vector< util::ShPtrVector< math::Histogram3D> > >,
          storage::Vector< util::ShPtrVector< linal::Matrix< double> > >
        > s_histograms;
        storage::Vector< util::ShPtrVector< linal::Matrix< double> > > &histogram_vec( s_histograms[ HISTOGRAM3DS]);
        if( !histogram_vec.IsEmpty())
        {
          return histogram_vec;
        }
        // store map of all aa pairs with their histogram
        histogram_vec.Reset();
        histogram_vec.Resize
        (
          biol::AATypes::s_NumberStandardAATypes,
          util::ShPtrVector< linal::Matrix< double> >( biol::AATypes::s_NumberStandardAATypes)
        );

        const size_t nr_angular_bins( ( *HISTOGRAM3DS)( 0)( 0)->GetNumberOfBinsY());
        const size_t nr_distance_bins( ( *HISTOGRAM3DS)( 0)( 0)->GetNumberOfBinsX());
        const double delta_x( ( *HISTOGRAM3DS)( 0)( 0)->GetBinSizeXYZ().First());
        const double start_x( ( *HISTOGRAM3DS)( 0)( 0)->GetBoundariesX().First());
        for( size_t type_a( 0), nr_aa_types( biol::AATypes::s_NumberStandardAATypes); type_a < nr_aa_types; ++type_a)
        {
          for( size_t type_b( 0); type_b <= type_a; ++type_b)
          {
            histogram_vec( type_a)( type_b) = histogram_vec( type_b)( type_a) =
              util::ShPtr< linal::Matrix< double> >( new linal::Matrix< double>( nr_angular_bins, nr_angular_bins, start_x + delta_x * nr_distance_bins));
            linal::Matrix< double> &matrix( *histogram_vec( type_a)( type_b));
            const math::Histogram3D &hist3d( *( *HISTOGRAM3DS)( type_a)( type_b));
            const math::Tensor< double> &tensor3d( hist3d.GetHistogram());
            for( size_t angle_a( 0); angle_a < nr_angular_bins; ++angle_a)
            {
              for( size_t angle_b( 0); angle_b < nr_angular_bins; ++angle_b)
              {
                for( size_t x_bin( 0); x_bin < nr_distance_bins; ++x_bin)
                {
                  if( tensor3d( x_bin, angle_a, angle_b) > 0.0)
                  {
                    matrix( angle_a, angle_b) = start_x + delta_x * x_bin;
                    break;
                  }
                }
              }
            }
          }
        }
        return histogram_vec;
      }
    }

    //! @brief read map of amino acid pair energies based on distance from histogram files
    void AAPairHiResClash::ReadEnergyFunctionMap()
    {
      m_Histograms = util::ToSiPtr( GetHistograms( m_HistogramFileName));
      m_DistanceCutoff = 5.5;
      m_ClashDistances = util::ToSiPtr( GetClashDistances( m_Histograms));
      m_AngularBinSize = ( *m_Histograms)( 0)( 0)->GetBinSizeXYZ()( 1);
    }

    //! @brief set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @return ERROR_STREAM stream with which to write errors
    bool AAPairHiResClash::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERROR_STREAM
    )
    {
      if( !command::CommandState::IsInStaticInitialization())
      {
        ReadEnergyFunctionMap();
      }
      return true;
    }

    //! @brief Get histograms from a particular file. Caches histograms so they need only be read in once
    const storage::Vector< util::ShPtrVector< math::Histogram3D> > &AAPairHiResClash::GetHistograms( const std::string &FILENAME)
    {
      static storage::Map< std::string, storage::Vector< util::ShPtrVector< math::Histogram3D> > > s_histograms;
      storage::Vector< util::ShPtrVector< math::Histogram3D> > &histogram_vec( s_histograms[ FILENAME]);
      if( !histogram_vec.IsEmpty() || command::CommandState::IsInStaticInitialization())
      {
        return histogram_vec;
      }

      // store map of all aa pairs with their histogram
      histogram_vec.Reset();
      histogram_vec.Resize
      (
        biol::AATypes::s_NumberStandardAATypes,
        util::ShPtrVector< math::Histogram3D>( biol::AATypes::s_NumberStandardAATypes)
      );

      // read file with all histograms for each pair of aa types
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( FILENAME));

      // initialize temporary strings to read
      std::string tmp_a, tmp_b;

      // while reading the aatype pair and until reaching the end of the file
      while( read >> tmp_a >> tmp_b && !read.eof())
      {
        // read the string and convert it to first aa type
        biol::AAType a( biol::GetAATypes().AATypeFromOneLetterCode( tmp_a[0]));
        biol::AAType b( biol::GetAATypes().AATypeFromOneLetterCode( tmp_b[0]));

        // read the histogram
        util::ShPtr< math::Histogram3D> histogram( new math::Histogram3D);
        read >> *histogram;
        histogram_vec( a)( b) = histogram_vec( b)( a) = histogram;
      }

      // close the stream
      io::File::CloseClearFStream( read);
      return histogram_vec;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_pair_sidechain_interaction.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"
#include "linal/bcl_linal_vector_3d_operations.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> AAPairSidechainInteraction::s_Instance
    (
      util::Enumerated< AAPairDistanceInterface>::AddInstance( new AAPairSidechainInteraction())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &AAPairSidechainInteraction::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_identifier( "aaside");

      // end
      return s_default_identifier;

    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param SCHEME scheme to be used
    AAPairSidechainInteraction::AAPairSidechainInteraction() :
        m_Scheme(),
        m_AAPairDistance()
    {
    }

    //! @brief constructor from a specified histogram file
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param SCHEME scheme to be used
    AAPairSidechainInteraction::AAPairSidechainInteraction
    (
      const std::string &HISTOGRAM_FILENAME,
      const std::string &SCHEME
    ) :
      m_Scheme( SCHEME),
      m_AAPairDistance( new AAPairDistance( HISTOGRAM_FILENAME))
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AAPairDistance object that is copied from this one
    AAPairSidechainInteraction *AAPairSidechainInteraction::Clone() const
    {
      return new AAPairSidechainInteraction( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAPairSidechainInteraction::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AAPairSidechainInteraction::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operators //
  ///////////////

    //! @brief calculate the weighted energy according to distance and AATypes for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @return the weighted energy according to distance and AATypes for given amino acid pair
    double AAPairSidechainInteraction::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B
    ) const
    {
      // return the weighted aa pair distance score
      return
        WeightOfInteraction( AMINO_ACID_A, AMINO_ACID_B) *
        m_AAPairDistance->operator()( AMINO_ACID_A, AMINO_ACID_B);
    }

    //! @brief calculate amino acid pairing potential for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param DISTANCE distance between the amino acid pair
    //! @return amino acid pairing potential for given amino acid pair
    double AAPairSidechainInteraction::operator()
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      const double DISTANCE
    ) const
    {
      // return the weighted aa pair distance score
      return
        WeightOfInteraction( AMINO_ACID_A, AMINO_ACID_B) *
        m_AAPairDistance->operator()( AMINO_ACID_A, AMINO_ACID_B, DISTANCE);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculate the weight of interaction for given amino acid pair
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @return the weight of interaction for given amino acid pair
    double AAPairSidechainInteraction::WeightOfInteraction
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B
    )
    {
      // calculate the angle and the corresponding weight for the first amino acid
      const double alpha_a
      (
        linal::ProjAngle
        (
          AMINO_ACID_A.GetCA().GetCoordinates(),
          AMINO_ACID_A.GetFirstSidechainAtom().GetCoordinates(),
          AMINO_ACID_B.GetCA().GetCoordinates()
        )
      );
      const double weight_a( Weight90To45Transition( alpha_a));

      // calculate the angle and the corresponding weight for the second amino acid
      const double alpha_b
      (
        linal::ProjAngle
        (
          AMINO_ACID_B.GetCA().GetCoordinates(),
          AMINO_ACID_B.GetFirstSidechainAtom().GetCoordinates(),
          AMINO_ACID_A.GetCA().GetCoordinates()
        )
      );
      const double weight_b( Weight90To45Transition( alpha_b));

      // return the multiplication of calculated weights
      return weight_a * weight_b;
    }

    //! @brief calculates a weight for the angle
    //! 0 - 45 returns 0; 45 - 90 is a cos transition to 0; larger 90 returns 0
    //! @param ANGLE_RAD angle in readians
    //! @return calculated weight for the angle
    double AAPairSidechainInteraction::Weight90To45Transition( const double ANGLE_RAD)
    {
      // if angle less than 45 return 1
      if( ANGLE_RAD <= math::g_Pi / 4)
      {
        return double( 1);
      }
      // if angle more than 90 return 1
      if( ANGLE_RAD >= math::g_Pi / 2)
      {
        return double( 0);
      }

      // otherwise ( if between 45 and 90) return a cosine transition value based on the angle
      return ( std::cos( ( ANGLE_RAD - math::g_Pi / 4) * 4) + 1) / 2;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AAPairSidechainInteraction::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_AAPairDistance, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &AAPairSidechainInteraction::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AAPairDistance, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param AMINO_ACID_A first amino acid of interest
    //! @param AMINO_ACID_B second amino acid of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    AAPairSidechainInteraction::WriteDetailedSchemeAndValues
    (
      const biol::AABase &AMINO_ACID_A,
      const biol::AABase &AMINO_ACID_B,
      std::ostream &OSTREAM
    ) const
    {
      //write Scheme
      OSTREAM << AMINO_ACID_A.GetSeqID() << '\t'
              << AMINO_ACID_A.GetType()->GetThreeLetterCode() << '\t'
              << AMINO_ACID_B.GetSeqID()<< '\t'
              << AMINO_ACID_B.GetType()->GetThreeLetterCode() << '\t'
              << biol::FirstSidechainAtomDistance( AMINO_ACID_A, AMINO_ACID_B) << '\t'
              << operator()( AMINO_ACID_A, AMINO_ACID_B) << '\n';

      //end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_sequence.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_sse.h"
#include "biol/bcl_biol_aa_base.h"
#include "fold/bcl_fold_default_flags.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AASequence::s_Instance
    (
      GetObjectInstances().AddInstance( new AASequence( util::ShPtr< AAPairDistanceInterface>(), true))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AASequence::AASequence() :
      m_ScoreAAPair(),
      m_Normalize( false),
      m_AANeighborListContainerGenerator()
    {
    }

    //! @brief construct from ShPtr to amino acid pair potential
    //! @param SP_AA_PAIR_POTENTIAL ShPtr to the amino acid potential to be used
    AASequence::AASequence
    (
      const util::ShPtr< AAPairDistanceInterface> &SP_AA_PAIR_POTENTIAL,
      const bool NORMALIZE
    ) :
      m_ScoreAAPair( SP_AA_PAIR_POTENTIAL),
      m_Normalize( NORMALIZE),
      m_AANeighborListContainerGenerator
      (
        SP_AA_PAIR_POTENTIAL.IsDefined() ?
          assemble::AANeighborListContainerGeneratorSSE::AANeighborListGenerator
          (
            SP_AA_PAIR_POTENTIAL->GetDistanceCutoff(),
            SP_AA_PAIR_POTENTIAL->GetMinimalSequenceSeparation(),
            SP_AA_PAIR_POTENTIAL->GetConsiderDifferentChain(),
            true
          )
          :
          util::ShPtr< math::FunctionInterfaceSerializable< assemble::SSE, assemble::AANeighborListContainer> >()
      )
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AASequence copied from this one
    AASequence *AASequence::Clone() const
    {
      return new AASequence( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AASequence::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AASequence::GetScheme() const
    {
      return m_ScoreAAPair->GetScheme();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief score aa distances between all pairs of amino acids within a single SSE
    //! @param THIS_SSE SSE of interest
    //! @param MEMBRANE membrane object
    //! @return pair of overall interaction potential and number of scored entities
    storage::Pair< double, size_t> AASequence::operator()
    (
      const assemble::SSE &THIS_SSE,
      const biol::Membrane &MEMBRANE
    ) const
    {
      double score( 0);

      size_t number_pair_scores( 0);

      // create neighborlistcontainer between both sequences
      const assemble::AANeighborListContainer neighbor_list_container( m_AANeighborListContainerGenerator->operator ()( THIS_SSE));

      // iterate over all amino acids
      for
      (
        assemble::AANeighborListContainer::const_iterator
          aa_itr( neighbor_list_container.Begin()), aa_itr_end( neighbor_list_container.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // current aa
        const biol::AABase &current_aa( *aa_itr->second.GetCenterAminoAcid());

        // iterate over all neighbors
        for
        (
          assemble::AANeighborList::const_iterator neigh_itr( aa_itr->second.Begin()), neigh_itr_end( aa_itr->second.End());
          neigh_itr != neigh_itr_end;
          ++neigh_itr
        )
        {
          const biol::AABase &neigh_aa( *neigh_itr->First());

          // score only one pair
          if( biol::AALessThanSeqID()( current_aa, neigh_aa))
          {
            continue;
          }

          // score distance between the two AAs
          const double current_score( m_ScoreAAPair->operator()( current_aa, neigh_aa, neigh_itr->Second()));

          if( util::IsDefined( current_score) && current_score != 0)
          {
            score += current_score;
            ++number_pair_scores;
          }
        }
      }

      // normalize
      if( m_Normalize && number_pair_scores > 0)
      {
        score /= double( number_pair_scores);
      }

      // end
      return storage::Pair< double, size_t>( score, number_pair_scores);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! read from std::istream
    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AASequence::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_ScoreAAPair, ISTREAM);
      io::Serialize::Read( m_Normalize, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @return returns the output stream
    std::ostream &AASequence::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_ScoreAAPair, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Normalize, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param THIS_SSE SSE of interest
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &AASequence::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &THIS_SSE,
      std::ostream &OSTREAM
    ) const
    {
      // create neighborlistcontainer between both sequences
      const assemble::AANeighborListContainer neighbor_list_container( m_AANeighborListContainerGenerator->operator ()( THIS_SSE));

      biol::AALessThanSeqID aa_lt;
      // iterate over all amino acids
      for
      (
        assemble::AANeighborListContainer::const_iterator
          aa_itr( neighbor_list_container.Begin()), aa_itr_end( neighbor_list_container.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // current aa
        const biol::AABase &current_aa( *aa_itr->second.GetCenterAminoAcid());

        // iterate over all neighbors
        for
        (
          assemble::AANeighborList::const_iterator neigh_itr( aa_itr->second.Begin()), neigh_itr_end( aa_itr->second.End());
          neigh_itr != neigh_itr_end;
          ++neigh_itr
        )
        {
          const biol::AABase &neigh_aa( *neigh_itr->First());

          // score only one pair
          if( aa_lt( current_aa, neigh_aa))
          {
            continue;
          }

          // score distance between the two AAs
          m_ScoreAAPair->WriteDetailedSchemeAndValues( current_aa, neigh_aa, OSTREAM);
        }
      }

      // end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_aa_sequence_pair.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_sse_pair.h"
#include "biol/bcl_biol_aa_base.h"
#include "fold/bcl_fold_default_flags.h"
#include "io/bcl_io_serialization.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AASequencePair::s_Instance
    (
      util::Enumerated< math::BinaryFunctionInterfaceSerializable< assemble::SSE, assemble::SSE, double> >::AddInstance
      (
        new AASequencePair
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AASequencePair::AASequencePair() :
      m_ScoreAAPair(),
      m_Normalize(),
      m_AANeighborListContainerGenerator()
    {
    }

    //! @brief construct from ShPtr to amino acid pair potential
    //! @param AA_PAIR_POTENTIAL the amino acid potential to be used
    AASequencePair::AASequencePair
    (
      const AAPairDistanceInterface &AA_PAIR_POTENTIAL,
      const bool NORMALIZE
    ) :
      m_ScoreAAPair( AA_PAIR_POTENTIAL),
      m_Normalize( NORMALIZE),
      m_AANeighborListContainerGenerator
      (
        assemble::AANeighborListContainerGeneratorSSEPair::AANeighborListGenerator
        (
          AA_PAIR_POTENTIAL.GetDistanceCutoff(),
          AA_PAIR_POTENTIAL.GetMinimalSequenceSeparation(),
          AA_PAIR_POTENTIAL.GetConsiderDifferentChain(),
          false
        )
      )
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AASequencePair copied from this one
    AASequencePair *AASequencePair::Clone() const
    {
      return new AASequencePair( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AASequencePair::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AASequencePair::GetScheme() const
    {
      return m_ScoreAAPair->GetScheme();
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &AASequencePair::GetAlias() const
    {
      static const std::string s_name( "AASequencePair");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AASequencePair::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Scores pairs of SSEs using pairwise residue interactions.");
      serializer.AddInitializer
      (
        "scoring function",
        "function to score the residue-residue interactions",
        io::Serialization::GetAgent( &m_ScoreAAPair)
      );
      serializer.AddInitializer
      (
        "normalize",
        "normalize by number of scored residue pairs",
        io::Serialization::GetAgent( &m_Normalize)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief set the members of this object from the given label
    //! @param LABEL the label containing members that should be read of this class
    //! @return ERROR_STREAM stream with which to write errors
    bool AASequencePair::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
    {
      m_AANeighborListContainerGenerator =
      (
        assemble::AANeighborListContainerGeneratorSSEPair::AANeighborListGenerator
        (
          m_ScoreAAPair->GetDistanceCutoff(),
          m_ScoreAAPair->GetMinimalSequenceSeparation(),
          m_ScoreAAPair->GetConsiderDifferentChain(),
          false
        )
       );

      return true;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief score aa distances between all pairs of amino acids between the two SSEs (not within either one)
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @return overall interaction potential
    double AASequencePair::operator()
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B
    ) const
    {
      double score( 0);

      size_t number_pair_scores( 0);

      // create neighborlistcontainer between both sequences
      const assemble::AANeighborListContainer neighbor_list_container
      (
        m_AANeighborListContainerGenerator->operator ()( SSE_A, SSE_B)
      );

      // iterate over all amino acids
      for
      (
        assemble::AANeighborListContainer::const_iterator
          aa_itr( neighbor_list_container.Begin()), aa_itr_end( neighbor_list_container.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // current aa
        const biol::AABase &current_aa( *aa_itr->second.GetCenterAminoAcid());

        // iterate over all neighbors
        for
        (
          assemble::AANeighborList::const_iterator neigh_itr( aa_itr->second.Begin()), neigh_itr_end( aa_itr->second.End());
          neigh_itr != neigh_itr_end;
          ++neigh_itr
        )
        {
          const biol::AABase &neigh_aa( *neigh_itr->First());

          // score only one pair
          if( biol::AALessThanSeqID()( current_aa, neigh_aa))
          {
            continue;
          }

          // score distance between the two AAs
          const double current_score( m_ScoreAAPair->operator()( current_aa, neigh_aa, neigh_itr->Second()));

          if( util::IsDefined( current_score) && current_score != 0)
          {
            score += current_score;
            ++number_pair_scores;
          }
        }
      }

      // normalize
      if( m_Normalize && number_pair_scores > 0)
      {
        score /= double( number_pair_scores);
      }

      // end
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! read from std::istream
    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AASequencePair::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_ScoreAAPair, ISTREAM);
      io::Serialize::Read( m_Normalize, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @return returns the output stream
    std::ostream &AASequencePair::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_ScoreAAPair, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Normalize, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &AASequencePair::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B,
      std::ostream &OSTREAM
    ) const
    {
      // create neighborlistcontainer between both sequences
      const assemble::AANeighborListContainer neighbor_list_container( m_AANeighborListContainerGenerator->operator ()( SSE_A, SSE_B));

      // iterate over all amino acids
      for
      (
        assemble::AANeighborListContainer::const_iterator
          aa_itr( neighbor_list_container.Begin()), aa_itr_end( neighbor_list_container.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // current aa
        const biol::AABase &current_aa( *aa_itr->second.GetCenterAminoAcid());

        // iterate over all neighbors
        for
        (
          assemble::AANeighborList::const_iterator neigh_itr( aa_itr->second.Begin()), neigh_itr_end( aa_itr->second.End());
          neigh_itr != neigh_itr_end;
          ++neigh_itr
        )
        {
          const biol::AABase &neigh_aa( *neigh_itr->First());

          // score only one pair
          if( biol::AALessThanSeqID()( current_aa, neigh_aa))
          {
            continue;
          }

          // score distance between the two AAs
          m_ScoreAAPair->WriteDetailedSchemeAndValues( current_aa, neigh_aa, OSTREAM);
        }
      }

      // end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_model.h"
#include "restraint/bcl_restraint_accessibility_profile.h"
#include "restraint/bcl_restraint_accessibility_profile_assignment.h"
#include "score/bcl_score_accessibility.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> Accessibility::s_Instance
    (
      GetObjectInstances().AddInstance( new Accessibility())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &Accessibility::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "access");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    Accessibility::Accessibility() :
      m_ScoringFunction(),
      m_Restraints(),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief construct from a scoring function and scheme
    //! @param SCORING_FUNCTION scoring function to be used
      //! @param RESTRAINTS the actual restraints
    //! @param SCHEME scheme to be used
    Accessibility::Accessibility
    (
      const util::ShPtr< math::FunctionInterfaceSerializable< restraint::AccessibilityProfileAssignment, double> > &SCORING_FUNCTION,
      const util::ShPtr< restraint::AccessibilityProfile> RESTRAINTS,
      const std::string SCHEME
    ) :
      m_ScoringFunction( SCORING_FUNCTION),
      m_Restraints( RESTRAINTS),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new Accessibility
    Accessibility *Accessibility::Clone() const
    {
      return new Accessibility( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &Accessibility::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief () operator scores the protein model and associated restraints using the member scoring function
    //! @param PROTEIN_MODEL protein model to be scored
    //! @return distance restraint score
    double Accessibility::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // if no restraints were found
      if( !m_Restraints.IsDefined())
      {
        // return a score of 0
        BCL_MessageDbg( "No accessibility restraints found, not scoring the model " + GetScheme());

        return 0;
      }

      const restraint::AccessibilityProfileAssignment assignment( m_Restraints->GenerateAssignment( PROTEIN_MODEL));

      // score the assignment generated by the restraint multiplied by the number of data points in sses
      const double score( m_ScoringFunction->operator()( assignment) * double( assignment.GetTotalNumberOfSSEAssignments()));

      BCL_MessageDbg( "score " + util::Format()( score));

      // return score
      return score;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &Accessibility::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &Accessibility::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL Argument to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &Accessibility::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      // if no restraints were found
      if( !m_Restraints.IsDefined())
      {
        // return a score of 0
        BCL_MessageDbg( "No accessibility restraints found, not scoring the model " + GetScheme());

        return OSTREAM;
      }

      const restraint::AccessibilityProfileAssignment assignment( m_Restraints->GenerateAssignment( PROTEIN_MODEL));

      // score the assignment generated by the restraint
      m_ScoringFunction->WriteDetailedSchemeAndValues( assignment, OSTREAM);

      return OSTREAM;
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_accessibility_hydrophobic_moment.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_atom.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_trigonometric_transition.h"
#include "util/bcl_util_colors.h"
#include "util/bcl_util_string_replacement.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AccessibilityHydrophobicMoment::s_Instance
    (
      GetObjectInstances().AddInstance( new AccessibilityHydrophobicMoment())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AccessibilityHydrophobicMoment::AccessibilityHydrophobicMoment() :
      m_AccessibilityType(),
      m_WindowSizes()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param ENVIRONMENT the type of environment the accessibility was measured in that should be scored
    //! @param WINDOW_SIZES for sstype, number of restraints included in each window the moment will be calculated for
    AccessibilityHydrophobicMoment::AccessibilityHydrophobicMoment
    (
      const restraint::AccessibilityAA::EnvironmentEnum &ENVIRONMENT,
      const storage::Map< biol::SSType, size_t> WINDOW_SIZES
    ) :
      m_AccessibilityType( ENVIRONMENT),
      m_WindowSizes( WINDOW_SIZES)
    {
    }

    //! @brief default constructor
    AccessibilityHydrophobicMoment::Window::Window() :
      m_CalculatedMoment( util::GetUndefinedDouble()),
      m_ExperimentalMoment( util::GetUndefinedDouble()),
      m_AccessibilityAssignments()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param CALCULATED_MOMENT the value of the moment calculated from structure
    //! @param EXPERIMENTAL_MOMENT the experimentally measured moment
    //! @param ACCESSIBILITY_ASSIGNMENTS the list of accessibilities associated with this window
    AccessibilityHydrophobicMoment::Window::Window
    (
      const linal::Vector3D &CALCULATED_MOMENT,
      const linal::Vector3D &EXPERIMENTAL_MOMENT,
      const storage::List< restraint::AccessibilityAAAssignment> &ACCESSIBILITY_ASSIGNMENTS
    ) :
      m_CalculatedMoment( CALCULATED_MOMENT),
      m_ExperimentalMoment( EXPERIMENTAL_MOMENT),
      m_AccessibilityAssignments( ACCESSIBILITY_ASSIGNMENTS)
    {
    }

    //! @brief Clone function
    //! @return pointer to new AccessibilityHydrophobicMoment
    AccessibilityHydrophobicMoment *AccessibilityHydrophobicMoment::Clone() const
    {
      return new AccessibilityHydrophobicMoment( *this);
    }

    //! @brief Clone function
    //! @return pointer to new AccessibilityHydrophobicMoment
    AccessibilityHydrophobicMoment::Window *AccessibilityHydrophobicMoment::Window::Clone() const
    {
      return new AccessibilityHydrophobicMoment::Window( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AccessibilityHydrophobicMoment::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AccessibilityHydrophobicMoment::Window::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief a string description of this class
    //! @return std::string which gives the data of this class
    std::string AccessibilityHydrophobicMoment::Window::GetIdentification() const
    {
      std::string identification( "StartWindow\n");

      // iterate over the assignments
      for
      (
        storage::List< restraint::AccessibilityAAAssignment>::const_iterator
          assignment_itr( m_AccessibilityAssignments.Begin()), assignment_itr_end( m_AccessibilityAssignments.End());
        assignment_itr != assignment_itr_end;
        ++assignment_itr
      )
      {
        identification +=
        (
          assignment_itr->GetAABase()->GetIdentification() + " exposure " +
          util::Format()( assignment_itr->GetExposureValue()) + " "
        );

        const storage::Map
        <
          restraint::AccessibilityAA::EnvironmentEnum, double
        > &accessibilities( assignment_itr->GetAccessibility());
        for
        (
          storage::Map
          <
            restraint::AccessibilityAA::EnvironmentEnum, double
          >::const_iterator itr( accessibilities.Begin()), itr_end( accessibilities.End());
          itr != itr_end;
          ++itr
        )
        {
          identification += ( util::Format()( itr->second) + " " + itr->first.GetString() + " ");
        }
        identification += '\n';
      }

      identification += ( "calculated_moment " + util::Format()( m_CalculatedMoment) + " length " + util::Format()( m_CalculatedMoment.Norm()) + '\n');
      identification += ( "experiment_moment " + util::Format()( m_ExperimentalMoment) + " length " + util::Format()( m_ExperimentalMoment.Norm()) + '\n');
      identification += "EndWindow\n";

      return identification;
    }

    //! @brief a string description of this class
    //! @return std::string which gives the data of this class
    std::string AccessibilityHydrophobicMoment::Window::GetIdentificationInLine() const
    {
      std::string identification( "|");

      // iterate over the assignments
      for
      (
        storage::List< restraint::AccessibilityAAAssignment>::const_iterator
          assignment_itr( m_AccessibilityAssignments.Begin()), assignment_itr_end( m_AccessibilityAssignments.End());
        assignment_itr != assignment_itr_end;
        ++assignment_itr
      )
      {
        identification += ( '<' + assignment_itr->GetAABase()->GetIdentification() + '>');
      }
      identification += "|";
      return identification;
    }

    //! @brief gives the moment calculated from structure
    //! @return vector 3d which is the moment calculated from structure
    const linal::Vector3D &AccessibilityHydrophobicMoment::Window::GetCalculatedMoment() const
    {
      return m_CalculatedMoment;
    }

    //! @brief gives the moment determined from experiment
    //! @return vector 3d which is the moment determined from experiment
    const linal::Vector3D &AccessibilityHydrophobicMoment::Window::GetExperimentMoment() const
    {
      return m_ExperimentalMoment;
    }

    //! @brief gives the list of accessibilities associated with this window
    //! @return storage::List< restraint::AccessibilityAAAssignment> which are the window's accessibilities
    const storage::List
    <
      restraint::AccessibilityAAAssignment
    > &AccessibilityHydrophobicMoment::Window::GetAccessibilities() const
    {
      return m_AccessibilityAssignments;
    }

  ////////////////
  // operations //
  ////////////////

    storage::List< AccessibilityHydrophobicMoment::Window>
    AccessibilityHydrophobicMoment::CalculateHydrophobicMomentWindows
    (
      const storage::List< restraint::AccessibilityAAAssignment> &ASSIGNMENTS, const size_t WINDOW_SIZE,
      const restraint::AccessibilityAA::EnvironmentEnum &ENVIRONMENT_TYPE
    )
    {
      storage::List< AccessibilityHydrophobicMoment::Window> sse_windows;

      // index into the list
      size_t assignment_index( 0);
      const size_t assignment_list_size( ASSIGNMENTS.GetSize());

      // iterate over all the assignments
      for
      (
        storage::List< restraint::AccessibilityAAAssignment>::const_iterator
          assignment_itr( ASSIGNMENTS.Begin()), assignment_itr_end( ASSIGNMENTS.End());
        assignment_itr != assignment_itr_end && assignment_index + WINDOW_SIZE <= assignment_list_size;
        ++assignment_itr, ++assignment_index
      )
      {
        const AccessibilityHydrophobicMoment::Window window
        (
          CalculateHydrophobicMomentWindow( assignment_itr, assignment_itr_end, WINDOW_SIZE, ENVIRONMENT_TYPE)
        );

        if( !window.GetAccessibilities().IsEmpty())
        {
          sse_windows.PushBack( window);
        }
      }

      return sse_windows;
    }

    AccessibilityHydrophobicMoment::Window AccessibilityHydrophobicMoment::CalculateHydrophobicMomentWindow
    (
      storage::List< restraint::AccessibilityAAAssignment>::const_iterator ITR,
      storage::List< restraint::AccessibilityAAAssignment>::const_iterator ITR_END,
      const size_t WINDOW_SIZE,
      const restraint::AccessibilityAA::EnvironmentEnum &ENVIRONMENT_TYPE
    )
    {
      // will keep track of the location in the current window
      size_t pane( 0);

      // to hold the moment of this window
      linal::Vector3D structural_moment( 0, 0 ,0);
      linal::Vector3D experiment_moment( 0, 0 ,0);

      storage::List< restraint::AccessibilityAAAssignment> assignments;

      // iterate over the current window of assignments
      for
      (
        storage::List< restraint::AccessibilityAAAssignment>::const_iterator assignment_itr( ITR);
        assignment_itr != ITR_END && pane < WINDOW_SIZE;
        ++assignment_itr, ++pane
      )
      {
        // try to find the accessibility in the data
        storage::Pair< bool, double> access
        (
          assignment_itr->GetAccessibilityByEnvironment( ENVIRONMENT_TYPE)
        );

        // true if the type of accessibility is not found in the current assignment or the residue is not defined
        if( !assignment_itr->GetAABase().IsDefined() || !access.First())
        {
          continue;
        }

        const linal::Vector3D exposure
        (
          CalculateSingleHydrophobicMoment( *assignment_itr->GetAABase(), assignment_itr->GetExposureValue())
        );
        const linal::Vector3D accessibility
        (
          CalculateSingleHydrophobicMoment( *assignment_itr->GetAABase(), access.Second())
        );

        structural_moment += exposure;
        experiment_moment += accessibility;
        assignments.PushBack( *assignment_itr);
      }

      const AccessibilityHydrophobicMoment::Window moment_window( structural_moment, experiment_moment, assignments);

      return moment_window;
    }

    linal::Vector3D AccessibilityHydrophobicMoment::CalculateSingleHydrophobicMoment
    (
      const biol::AABase &AA_BASE, const double HYDROPHOBICITY
    )
    {
      // get unit vector in direction of CA->(first side chain atom)
      const linal::Vector3D &ca_coords( AA_BASE.GetCA().GetCoordinates());
      const linal::Vector3D &cb_coords( AA_BASE.GetFirstSidechainAtom().GetCoordinates());
      const linal::Vector3D direction( ( cb_coords - ca_coords).Normalize());

      // calculate the moment
      const linal::Vector3D moment( direction * HYDROPHOBICITY);

      return moment;
    }

    linal::Vector3D AccessibilityHydrophobicMoment::CalculateMomentInXYPlane( const linal::Vector3D &MOMENT, const assemble::SSE &SSE)
    {
      // dihedral to x-axis
      const double x_dihedral
      (
        linal::Dihedral
        (
          MOMENT + SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_Z),
          SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_Z),
          SSE.GetCenter(),
          SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_X)
        )
      );

      BCL_MessageDbg( "dihedral angle between total moment and x-axis is " + util::Format()( x_dihedral));

      // dihedral to y-axis
      const double y_dihedral
      (
        linal::Dihedral
        (
          MOMENT + SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_Z),
          SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_Z),
          SSE.GetCenter(),
          SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_Y)
        )
      );

      BCL_MessageDbg( "dihedral angle between total moment and y-axis is " + util::Format()( y_dihedral));

      // moment in x-y plane
      const double distance( linal::Distance( SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_X), SSE.GetCenter()));
      BCL_MessageDbg( "distance is " + util::Format()( distance));

      const linal::Vector3D moment_in_xy_plane
      (
        linal::CoordinatesAngle
        (
          SSE.GetCenter(),
          SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_X),
          SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_Y),
          distance,
          x_dihedral,
          y_dihedral
        )
      );

      return moment_in_xy_plane;
    }

    std::ostream &AccessibilityHydrophobicMoment::ShowHydrophobicMomentWindows
    (
      const storage::List< AccessibilityHydrophobicMoment::Window> &WINDOW_LIST,
      std::ostream &OSTREAM,
      const assemble::SSE &SSE,
      const std::string &TAG,
      const util::Color &COLOR
    )
    {
      OSTREAM << "from pymol.cgo import *" << '\n';
      OSTREAM << "from pymol import cmd" << '\n';

      // iterate through the list
      for
      (
        storage::List< AccessibilityHydrophobicMoment::Window>::const_iterator
          window_itr( WINDOW_LIST.Begin()), window_itr_end( WINDOW_LIST.End());
        window_itr != window_itr_end;
        ++window_itr
      )
      {
        ShowHydrophobicMomentWindow( *window_itr, OSTREAM, SSE, TAG, COLOR);
      }
      const std::string radius( util::Format()( 0.1));
      {
        // x-axis
        const std::string x_start( util::Format()( SSE.GetCenter().X()));
        const std::string y_start( util::Format()( SSE.GetCenter().Y()));
        const std::string z_start( util::Format()( SSE.GetCenter().Z()));
        const linal::Vector3D xaxis( SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_X));
        const std::string x_end( util::Format()( xaxis.X()));
        const std::string y_end( util::Format()( xaxis.Y()));
        const std::string z_end( util::Format()( xaxis.Z()));
        const std::string x_axis
        (
          "xaxis" + TAG + "=[CYLINDER," + x_start + "," + y_start + "," + z_start + "," + x_end + "," + y_end + "," + z_end + ","
          + radius +
          "," + util::Format()( util::GetColors().e_Yellow->X()) +
          "," + util::Format()( util::GetColors().e_Yellow->Y()) +
          "," + util::Format()( util::GetColors().e_Yellow->Z()) +
          "," + util::Format()( util::GetColors().e_Yellow->X())   +
          "," + util::Format()( util::GetColors().e_Yellow->Y())   +
          "," + util::Format()( util::GetColors().e_Yellow->Z())   +
          "]\n"
        );
        OSTREAM << x_axis << '\n';
        OSTREAM << "cmd.load_cgo( xaxis" + TAG + ", 'x-axis" + TAG + "')" << '\n';
      }
      {
        // y-axis
        const std::string x_start( util::Format()( SSE.GetCenter().X()));
        const std::string y_start( util::Format()( SSE.GetCenter().Y()));
        const std::string z_start( util::Format()( SSE.GetCenter().Z()));
        const linal::Vector3D yaxis( SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_Y));
        const std::string x_end( util::Format()( yaxis.X()));
        const std::string y_end( util::Format()( yaxis.Y()));
        const std::string z_end( util::Format()( yaxis.Z()));
        const std::string y_axis
        (
          "yaxis" + TAG + "=[CYLINDER," + x_start + "," + y_start + "," + z_start + "," + x_end + "," + y_end + "," + z_end + ","
          + radius +
          "," + util::Format()( util::GetColors().e_Yellow->X()) +
          "," + util::Format()( util::GetColors().e_Yellow->Y()) +
          "," + util::Format()( util::GetColors().e_Yellow->Z()) +
          "," + util::Format()( util::GetColors().e_Yellow->X()) +
          "," + util::Format()( util::GetColors().e_Yellow->Y()) +
          "," + util::Format()( util::GetColors().e_Yellow->Z()) +
          "]\n"
        );
        OSTREAM << y_axis << '\n';
        OSTREAM << "cmd.load_cgo( yaxis" + TAG + ", 'y-axis" + TAG + "')" << '\n';
      }
      {
        // z-axis
        const std::string x_start( util::Format()( SSE.GetCenter().X()));
        const std::string y_start( util::Format()( SSE.GetCenter().Y()));
        const std::string z_start( util::Format()( SSE.GetCenter().Z()));
        const linal::Vector3D yaxis( SSE.GetCenter() + SSE.GetAxis( coord::GetAxes().e_Z));
        const std::string x_end( util::Format()( yaxis.X()));
        const std::string y_end( util::Format()( yaxis.Y()));
        const std::string z_end( util::Format()( yaxis.Z()));
        const std::string y_axis
        (
          "zaxis" + TAG + "=[CYLINDER," + x_start + "," + y_start + "," + z_start + "," + x_end + "," + y_end + "," + z_end + ","
          + radius +
          "," + util::Format()( util::GetColors().e_Yellow->X()) +
          "," + util::Format()( util::GetColors().e_Yellow->Y()) +
          "," + util::Format()( util::GetColors().e_Yellow->Z()) +
          "," + util::Format()( util::GetColors().e_Yellow->X()) +
          "," + util::Format()( util::GetColors().e_Yellow->Y()) +
          "," + util::Format()( util::GetColors().e_Yellow->Z()) +
          "]\n"
        );
        OSTREAM << y_axis << '\n';
        OSTREAM << "cmd.load_cgo( zaxis" + TAG + ", 'z-axis" + TAG + "')" << '\n';
      }

      return OSTREAM;
    }

    std::ostream &AccessibilityHydrophobicMoment::ShowHydrophobicMomentWindow
    (
      const AccessibilityHydrophobicMoment::Window &WINDOW,
      std::ostream &OSTREAM,
      const assemble::SSE &SSE,
      const std::string &TAG,
      const util::Color &COLOR
    )
    {
      BCL_MessageDbg( "num resis is " + util::Format()( WINDOW.GetAccessibilities().GetSize()));
      OSTREAM << "moments" + TAG + "=[]" << '\n';

      linal::Vector3D moment( 0, 0, 0);
      const std::string color_r_start( util::Format()( COLOR->X()));
      const std::string color_g_start( util::Format()( COLOR->Y()));
      const std::string color_b_start( util::Format()( COLOR->Z()));
      const std::string color_r_end(   util::Format()( COLOR->X()));
      const std::string color_g_end(   util::Format()( COLOR->Y()));
      const std::string color_b_end(   util::Format()( COLOR->Z()));

      // iterate through the assignments to show the total window moment on each residue
      for
      (
        storage::List< restraint::AccessibilityAAAssignment>::const_iterator
          itr( WINDOW.GetAccessibilities().Begin()), itr_end( WINDOW.GetAccessibilities().End());
        itr != itr_end; ++itr
      )
      {
        BCL_Assert( itr->GetAABase().IsDefined(), "aa ptr is not defined");
        const biol::AABase &aa( *itr->GetAABase());

        // moment line for calculated exposure
        {
          const std::string radius( util::Format()( 0.1));
          const std::string alpha_a( "ALPHA"), alpha_b( util::Format()( 1));
          const linal::Vector3D current_moment( WINDOW.GetCalculatedMoment());
          const linal::Vector3D end_point( current_moment + aa.GetCA().GetCoordinates());

          // draw line indicating moment
          const std::string x_start( util::Format()( aa.GetCA().GetCoordinates().X()));
          const std::string y_start( util::Format()( aa.GetCA().GetCoordinates().Y()));
          const std::string z_start( util::Format()( aa.GetCA().GetCoordinates().Z()));
          const std::string x_end(   util::Format()( end_point.X()));
          const std::string y_end(   util::Format()( end_point.Y()));
          const std::string z_end(   util::Format()( end_point.Z()));
          const std::string moment_string
          (
            "cur_mom=[ " + alpha_a + "," + alpha_b + ",CYLINDER," + x_start + "," + y_start + "," + z_start + ","
            + x_end + "," + y_end + "," + z_end + "," + radius +
            "," + color_r_start +
            "," + color_g_start +
            "," + color_b_start +
            "," + color_r_end +
            "," + color_g_end +
            "," + color_b_end +
            "]\n" +
            "moments" + TAG + ".extend(cur_mom)\n"
          );

          OSTREAM << moment_string << '\n';
        }
        // moment line for experimental accessibility
        {
          const std::string radius( util::Format()( 0.2));
          const std::string alpha_a( "ALPHA"), alpha_b( util::Format()( 0.5));
          const linal::Vector3D current_moment( WINDOW.GetExperimentMoment());
          const linal::Vector3D end_point( current_moment + aa.GetCA().GetCoordinates());

          // draw line indicating moment
          const std::string x_start( util::Format()( aa.GetCA().GetCoordinates().X()));
          const std::string y_start( util::Format()( aa.GetCA().GetCoordinates().Y()));
          const std::string z_start( util::Format()( aa.GetCA().GetCoordinates().Z()));
          const std::string x_end(   util::Format()( end_point.X()));
          const std::string y_end(   util::Format()( end_point.Y()));
          const std::string z_end(   util::Format()( end_point.Z()));
          const std::string moment_string
          (
            "cur_mom=[ " + alpha_a + "," + alpha_b + ",CYLINDER," + x_start + "," + y_start + "," + z_start + ","
            + x_end + "," + y_end + "," + z_end + "," + radius +
            "," + color_r_start +
            "," + color_g_start +
            "," + color_b_start +
            "," + color_r_end +
            "," + color_g_end +
            "," + color_b_end +
            "]\n" +
            "moments" + TAG + ".extend(cur_mom)\n"
          );

          OSTREAM << moment_string << '\n';
        }
      } //< end iteration
      OSTREAM << "cmd.load_cgo( moments" + TAG + ", 'moments" + TAG + "')" << '\n';

      // calculated exposure moment at sse center
      {
        OSTREAM << "calculated_exposure_centered" + TAG + "=[]" << '\n';
        const std::string radius( util::Format()( 0.1));
        const std::string alpha_a( "ALPHA"), alpha_b( util::Format()( 1));
        const linal::Vector3D current_moment( WINDOW.GetCalculatedMoment());
        const linal::Vector3D end_point( current_moment + SSE.GetCenter());

        // draw line indicating moment
        const std::string x_start( util::Format()( SSE.GetCenter().X()));
        const std::string y_start( util::Format()( SSE.GetCenter().Y()));
        const std::string z_start( util::Format()( SSE.GetCenter().Z()));
        const std::string x_end(   util::Format()( end_point.X()));
        const std::string y_end(   util::Format()( end_point.Y()));
        const std::string z_end(   util::Format()( end_point.Z()));
        const std::string moment_string
        (
          "cur_mom=[ " + alpha_a + "," + alpha_b + ",CYLINDER," + x_start + "," + y_start + "," + z_start + ","
          + x_end + "," + y_end + "," + z_end + "," + radius +
          "," + color_r_start +
          "," + color_g_start +
          "," + color_b_start +
          "," + color_r_end +
          "," + color_g_end +
          "," + color_b_end +
          "]\n" +
          "calculated_exposure_centered" + TAG + ".extend(cur_mom)\n"
        );

        OSTREAM << moment_string << '\n';

        OSTREAM << "cmd.load_cgo( calculated_exposure_centered" + TAG + ", 'calculated_exposure_centered" + TAG + "')" << '\n';
      }

      // experimental accessibility moment at sse center
      {
        OSTREAM << "experimental_access_centered" + TAG + "=[]" << '\n';
        const std::string radius( util::Format()( 0.2));
        const std::string alpha_a( "ALPHA"), alpha_b( util::Format()( 0.5));
        const linal::Vector3D current_moment( WINDOW.GetExperimentMoment());
        const linal::Vector3D end_point( current_moment + SSE.GetCenter());

        // draw line indicating moment
        const std::string x_start( util::Format()( SSE.GetCenter().X()));
        const std::string y_start( util::Format()( SSE.GetCenter().Y()));
        const std::string z_start( util::Format()( SSE.GetCenter().Z()));
        const std::string x_end(   util::Format()( end_point.X()));
        const std::string y_end(   util::Format()( end_point.Y()));
        const std::string z_end(   util::Format()( end_point.Z()));
        const std::string moment_string
        (
          "cur_mom=[ " + alpha_a + "," + alpha_b + ",CYLINDER," + x_start + "," + y_start + "," + z_start + ","
          + x_end + "," + y_end + "," + z_end + "," + radius +
          "," + color_r_start +
          "," + color_g_start +
          "," + color_b_start +
          "," + color_r_end +
          "," + color_g_end +
          "," + color_b_end +
          "]\n" +
          "experimental_access_centered" + TAG + ".extend(cur_mom)\n"
        );

        OSTREAM << moment_string << '\n';

        OSTREAM << "cmd.load_cgo( experimental_access_centered" + TAG + ", 'experimental_access_centered" + TAG + "')" << '\n';
      }

      // calculated exposure moment at sse center in x-y plane
      {
        OSTREAM << "calculated_exposure_xy" + TAG + "=[]" << '\n';
        const std::string radius( util::Format()( 0.1));
        const std::string alpha_a( "ALPHA"), alpha_b( util::Format()( 1));
        const linal::Vector3D current_moment( CalculateMomentInXYPlane( WINDOW.GetCalculatedMoment(), SSE));
        const linal::Vector3D end_point( current_moment);

        // draw line indicating moment
        const std::string x_start( util::Format()( SSE.GetCenter().X()));
        const std::string y_start( util::Format()( SSE.GetCenter().Y()));
        const std::string z_start( util::Format()( SSE.GetCenter().Z()));
        const std::string x_end(   util::Format()( end_point.X()));
        const std::string y_end(   util::Format()( end_point.Y()));
        const std::string z_end(   util::Format()( end_point.Z()));
        const std::string moment_string
        (
          "cur_mom=[ " + alpha_a + "," + alpha_b + ",CYLINDER," + x_start + "," + y_start + "," + z_start + ","
          + x_end + "," + y_end + "," + z_end + "," + radius +
          "," + color_r_start +
          "," + color_g_start +
          "," + color_b_start +
          "," + color_r_end +
          "," + color_g_end +
          "," + color_b_end +
          "]\n" +
          "calculated_exposure_xy" + TAG + ".extend(cur_mom)\n"
        );

        OSTREAM << moment_string << '\n';

        OSTREAM << "cmd.load_cgo( calculated_exposure_xy" + TAG + ", 'calculated_exposure_xy" + TAG + "')" << '\n';
      }

      // experimental accessibility moment at sse center in x-y plane
      {
        OSTREAM << "experimental_access_xy" + TAG + "=[]" << '\n';
        const std::string radius( util::Format()( 0.2));
        const std::string alpha_a( "ALPHA"), alpha_b( util::Format()( 0.5));
        const linal::Vector3D current_moment( CalculateMomentInXYPlane( WINDOW.GetExperimentMoment(), SSE));
        const linal::Vector3D end_point( current_moment);

        // draw line indicating moment
        const std::string x_start( util::Format()( SSE.GetCenter().X()));
        const std::string y_start( util::Format()( SSE.GetCenter().Y()));
        const std::string z_start( util::Format()( SSE.GetCenter().Z()));
        const std::string x_end(   util::Format()( end_point.X()));
        const std::string y_end(   util::Format()( end_point.Y()));
        const std::string z_end(   util::Format()( end_point.Z()));
        const std::string moment_string
        (
          "cur_mom=[ " + alpha_a + "," + alpha_b + ",CYLINDER," + x_start + "," + y_start + "," + z_start + ","
          + x_end + "," + y_end + "," + z_end + "," + radius +
          "," + color_r_start +
          "," + color_g_start +
          "," + color_b_start +
          "," + color_r_end +
          "," + color_g_end +
          "," + color_b_end +
          "]\n" +
          "experimental_access_xy" + TAG + ".extend(cur_mom)\n"
        );

        OSTREAM << moment_string << '\n';

        OSTREAM << "cmd.load_cgo( experimental_access_xy" + TAG + ", 'experimental_access_xy" + TAG + "')" << '\n';
      }

      return OSTREAM;
    }

    double AccessibilityHydrophobicMoment::CalculateMomentMagnitudeAgreement
    (
      const restraint::AccessibilityProfileAssignment &ASSIGNMENT
    ) const
    {
      // map for each chain a map that has for the moment/residue for a given sse
      // the order of the sses as ordered by the moment/residue should agree between the accessibility and espozure
      storage::Map< char, storage::Map< double, util::SiPtr< const assemble::SSE> > > exposure_chain_moment_sse;
      storage::Map< char, storage::Map< double, util::SiPtr< const assemble::SSE> > > accessibility_chain_moment_sse;

      for
      (
        storage::Map< util::SiPtr< const assemble::SSE>, storage::List< restraint::AccessibilityAAAssignment> >::const_iterator
          itr( ASSIGNMENT.GetSSEAssignments().Begin()), itr_end( ASSIGNMENT.GetSSEAssignments().End());
        itr != itr_end; ++itr
      )
      {
//        // make sure the siptr is defined
//        BCL_Assert( itr->first.IsDefined(), "SiPtr is not defined");
//        BCL_MessageDbg( m_AccessibilityType.GetName() + " scoring sse " + util::Format()( itr->first->GetIdentification()));
//
//        const util::SiPtr< const assemble::SSE> &current_sse( itr->first);
//        storage::VectorND< 2, storage::Map< util::SiPtr< const biol::AABase>, double> > exposure_accessibility( CalculateExposureAccessibility( itr->second, itr->first->GetType()));
//        BCL_Assert( exposure_accessibility.First().GetSize() == exposure_accessibility.Second().GetSize(), "sizes differ");
//        if( exposure_accessibility.First().IsEmpty())
//        {
//          BCL_MessageDbg( "no exposures of type " + m_AccessibilityType.GetName() + " to score");
//          continue;
//        }
//
//        const double num_data_aas( itr->second.GetSize());
//        linal::Vector3D exposure_moment( CalculateHydrophobicMoment( exposure_accessibility.First()).First());
//        BCL_Assert( exposure_chain_moment_sse[ current_sse->GetChainID()].Insert( std::pair< double, util::SiPtr< const assemble::SSE> >( exposure_moment.Norm() / num_data_aas, current_sse)).second, "could not insert moment, must already be same value");
//        linal::Vector3D accessibility_moment( CalculateHydrophobicMoment( exposure_accessibility.Second()).First());
//        BCL_Assert( accessibility_chain_moment_sse[ current_sse->GetChainID()].Insert( std::pair< double, util::SiPtr< const assemble::SSE> >( accessibility_moment.Norm() / num_data_aas, current_sse)).second, "could not insert moment, must already be same value");
      }

      double score( 0);
      // iterate through the chains
      for
      (
        storage::Map< char, storage::Map< double, util::SiPtr< const assemble::SSE> > >::const_iterator
          exp_itr( exposure_chain_moment_sse.Begin()),      exp_itr_end( exposure_chain_moment_sse.End()),
          epr_itr( accessibility_chain_moment_sse.Begin()), epr_itr_end( accessibility_chain_moment_sse.End());
        exp_itr != exp_itr_end && epr_itr != epr_itr_end;
        ++exp_itr, ++epr_itr
      )
      {
        // get reference on maps
        const storage::Map< double, util::SiPtr< const assemble::SSE> > &exp_map( exp_itr->second);
        const storage::Map< double, util::SiPtr< const assemble::SSE> > &epr_map( epr_itr->second);

        // iterate through the maps
        for
        (
          storage::Map< double, util::SiPtr< const assemble::SSE> >::const_iterator
            exp_map_itr( exp_map.Begin()), exp_map_itr_end( exp_map.End()),
            epr_map_itr( epr_map.Begin()), epr_map_itr_end( epr_map.End());
          exp_map_itr != exp_map_itr_end && epr_map_itr != epr_map_itr_end;
          ++exp_map_itr, ++epr_map_itr
        )
        {
          // sses are the same i.e. ordered the same
          if( exp_map_itr->second == epr_map_itr->second)
          {
            // give bonus
            --score;
          }
          else
          {
            // give penalty
            ++score;
          }
        }
      }

      return score;
    }

  ///////////////
  // operators //
  ///////////////

    double AccessibilityHydrophobicMoment::operator()( const restraint::AccessibilityProfileAssignment &ASSIGNMENT) const
    {
      // iterate through the profiles of the SSEs in ASSIGNMENT
      double score_sum( 0);

      // will hold the sum of the total number of restraint windows in the profile
      size_t window_sum( 0);

      // iterate over the sses and their associated restraints
      for
      (
        storage::Map
        <
          util::SiPtr< const assemble::SSE>, storage::List< restraint::AccessibilityAAAssignment>
        >::const_iterator
          itr( ASSIGNMENT.GetSSEAssignments().Begin()), itr_end( ASSIGNMENT.GetSSEAssignments().End());
        itr != itr_end;
        ++itr
      )
      {
        // make sure the sse siptr is defined and get a reference
        BCL_Assert( itr->first.IsDefined(), "SiPtr is not defined");
        const assemble::SSE &current_sse( *itr->first);
        BCL_MessageDbg( "scoring sse " + util::Format()( current_sse.GetIdentification()));

        // the list of assignments associated with the current sse
        const storage::List< restraint::AccessibilityAAAssignment> &current_sse_assignments( itr->second);

        // determine window size
        size_t window_size( util::GetUndefinedSize_t());
        storage::Map< biol::SSType, size_t>::const_iterator size_itr( m_WindowSizes.Find( current_sse.GetType()));
        if( size_itr != m_WindowSizes.End())
        {
          window_size = size_itr->second;
        }
        // true if the window size is not defined or is larger than the number of assignments
        if( !util::IsDefined( window_size) || window_size > current_sse_assignments.GetSize())
        {
          // set window size to the number of assignments for this sse
          window_size = current_sse_assignments.GetSize();
        }

        // get the list of moments for overlapping windows of the assignments
        const storage::List< AccessibilityHydrophobicMoment::Window> windows
        (
          CalculateHydrophobicMomentWindows( current_sse_assignments, window_size, m_AccessibilityType)
        );

        // no windows created
        if( windows.IsEmpty())
        {
          // go to next sse
          continue;
        }

        const size_t number_of_windows( windows.GetSize());
        BCL_MessageDbg( "number_of_windows " + util::Format()( number_of_windows));

        double current_score_sum( 0);

        // iterate through the list of overlapping windows of assignments
        for
        (
          storage::List< AccessibilityHydrophobicMoment::Window>::const_iterator
            window_itr( windows.Begin()), window_itr_end( windows.End());
          window_itr != window_itr_end;
          ++window_itr
        )
        {
          const double score( CalculateMomentAgreement( *window_itr, current_sse));
          BCL_MessageDbg
          (
            "current window " + util::Format()( window_itr->GetIdentification()) + " score is "
            + util::Format()( score)
          );
          current_score_sum += score;
        }

//        current_score_sum /= double( number_of_windows);

        score_sum += current_score_sum;
        window_sum += number_of_windows;
      }

      // normalize score_sum by the number of windows if there was at least 1 window
      if( window_sum != 0)
      {
        score_sum /= double( window_sum);
      }

      return score_sum;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AccessibilityHydrophobicMoment::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_AccessibilityType,       ISTREAM);
      io::Serialize::Read( m_WindowSizes      ,       ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AccessibilityHydrophobicMoment::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_AccessibilityType, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_WindowSizes,       OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AccessibilityHydrophobicMoment::Window::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_CalculatedMoment  ,       ISTREAM);
      io::Serialize::Read( m_ExperimentalMoment,       ISTREAM);
      io::Serialize::Read( m_AccessibilityAssignments, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AccessibilityHydrophobicMoment::Window::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // read members
      io::Serialize::Write( m_CalculatedMoment        , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ExperimentalMoment      , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AccessibilityAssignments, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param ARGUMENT Argument to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &AccessibilityHydrophobicMoment::WriteDetailedSchemeAndValues
    (
      const restraint::AccessibilityProfileAssignment &ASSIGNMENT,
      std::ostream &OSTREAM
    ) const
    {
      OSTREAM << "AccessibilityHydrophobicMoment::WriteDetailedSchemeAndValues\n";
      OSTREAM << "nr sses is " << ASSIGNMENT.GetSSEAssignments().GetSize() << '\n';
      for
      (
        storage::Map
        <
          util::SiPtr< const assemble::SSE>,
          storage::List< restraint::AccessibilityAAAssignment>,
          assemble::SSELessThanNoOverlap
        >::const_iterator
          sse_itr( ASSIGNMENT.GetSSEAssignments().Begin()), sse_itr_end( ASSIGNMENT.GetSSEAssignments().End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make sure the sse siptr is defined and get a reference
        BCL_Assert( sse_itr->first.IsDefined(), "SiPtr is not defined");
        const assemble::SSE &current_sse( *sse_itr->first);
        BCL_MessageDbg( "scoring sse " + util::Format()( current_sse.GetIdentification()));

        // the list of assignments associated with the current sse
        const storage::List< restraint::AccessibilityAAAssignment> &current_sse_assignments( sse_itr->second);

        // determine window size
        size_t window_size( util::GetUndefinedSize_t());
        storage::Map< biol::SSType, size_t>::const_iterator size_itr( m_WindowSizes.Find( current_sse.GetType()));
        if( size_itr != m_WindowSizes.End())
        {
          window_size = size_itr->second;
        }
        // true if the window size is not defined or is larger than the number of assignments
        if( !util::IsDefined( window_size) || window_size > current_sse_assignments.GetSize())
        {
          // set window size to the number of assignments for this sse
          window_size = current_sse_assignments.GetSize();
        }
        storage::List< AccessibilityHydrophobicMoment::Window> window_list
        (
          AccessibilityHydrophobicMoment::CalculateHydrophobicMomentWindows
          (
            current_sse_assignments, window_size, m_AccessibilityType
          )
        );

        std::string sse_id( sse_itr->first->GetIdentification());
        {
          util::StringReplacement space_replacer( util::StringReplacement::e_Any, " ", "");
          space_replacer.ReplaceEachIn( sse_id);
        }
        {
          util::StringReplacement space_replacer( util::StringReplacement::e_Any, "<==>", "");
          space_replacer.ReplaceEachIn( sse_id);
        }

        if( util::GetMessenger().GetCurrentMessageLevel() == util::Message::e_Debug)
        {
          io::OFStream write;
          io::File::MustOpenOFStream
          (
            write, "show_hydrophobic_moment_" + sse_id + "_" + m_AccessibilityType.GetString() + ".py"
          );

          AccessibilityHydrophobicMoment::ShowHydrophobicMomentWindows
          (
            window_list,
            write,
            *sse_itr->first,
            std::string( "sse_id"),
            util::GetColors().e_Cyan
          );
        }

        OSTREAM << "for sse " << current_sse.GetIdentification() << " nr assignments is "
                << ASSIGNMENT.GetSSEAssignments().GetSize() << " and nr windows is " << window_list.GetSize() << '\n';

        // iterate over the window list and print out the windows
        // iterate through the list of overlapping windows of assignments
        for
        (
          storage::List< AccessibilityHydrophobicMoment::Window>::const_iterator
            window_itr( window_list.Begin()), window_itr_end( window_list.End());
          window_itr != window_itr_end;
          ++window_itr
        )
        {
          const double score( CalculateMomentAgreement( *window_itr, current_sse));
          OSTREAM << window_itr->GetIdentification() << '\n';
          const linal::Vector3D exposure_moment_in_xyplane
          (
            CalculateMomentInXYPlane( window_itr->GetCalculatedMoment(), current_sse)
          );
          const linal::Vector3D accessibility_moment_in_xyplane
          (
            CalculateMomentInXYPlane( window_itr->GetExperimentMoment(), current_sse)
          );

          const double xaxis_moment_angle
          (
            linal::ProjAngle( current_sse.GetCenter(), exposure_moment_in_xyplane, accessibility_moment_in_xyplane)
          );
          OSTREAM << "exposure_moment_in_xyplane\n" << exposure_moment_in_xyplane
                  << "\naccessibility_moment_in_xyplane\n" << accessibility_moment_in_xyplane
                  << "\nxaxis_moment_angle " << xaxis_moment_angle
                  << " score: " << score << '\n';
        }
      }

      return OSTREAM;
    }

     double AccessibilityHydrophobicMoment::CalculateMomentAgreement
     (
       const AccessibilityHydrophobicMoment::Window &WINDOW, const assemble::SSE &SSE
     ) const
     {
       const linal::Vector3D exposure_moment_in_xyplane
       (
         CalculateMomentInXYPlane( WINDOW.GetCalculatedMoment(), SSE)
       );
       const linal::Vector3D accessibility_moment_in_xyplane
       (
         CalculateMomentInXYPlane( WINDOW.GetExperimentMoment(), SSE)
       );

       const double xaxis_moment_angle
       (
         linal::ProjAngle( SSE.GetCenter(), exposure_moment_in_xyplane, accessibility_moment_in_xyplane)
       ); //math::g_Pi - math::Absolute( exposure_xaxis_moment_angle - accessibility_xaxis_moment_angle));

       BCL_MessageDbg
       (
         "the angle between the exposure and accessibility moments is "
         + util::Format()( xaxis_moment_angle)
       );

       BCL_MessageDbg
       (
         "sse " + SSE.GetIdentification() + " moment angle : " +
         util::Format()( xaxis_moment_angle) + " current_score : " + util::Format()( ScoreAngle( xaxis_moment_angle))
       );
       return ScoreAngle( xaxis_moment_angle);
     }

     //! @brief scores the angle formed between the moments of the calculated and experimental exposures and a center
     //! @param CALC_CENTER_EXP_ANGLE the angle formed from the the calculated exposure moment in the x-y plane, the
     //!        center of the corresponding sse, and the experimental accessibility moment in the x-y plan.
     //!        calculated->center->experimental
     //! @return double which is the score for the angle between the calculated and experimental moments
     double AccessibilityHydrophobicMoment::ScoreAngle( const double CALC_CENTER_EXP_ANGLE)
     {
//       double current_score( util::GetUndefinedDouble());
       static const double min_score_cutoff( 0);
       static const double bonus_score_cutoff( math::g_Pi);

       static const math::TrigonometricTransition fnc( min_score_cutoff, bonus_score_cutoff, double( -1), double( 0));
       const double current_score( fnc( CALC_CENTER_EXP_ANGLE));

//       if( CALC_CENTER_EXP_ANGLE <= min_score_cutoff)
//       {
//         current_score = -1.0;
//       }
//       else if( CALC_CENTER_EXP_ANGLE > min_score_cutoff && CALC_CENTER_EXP_ANGLE < bonus_score_cutoff)
//       {
//         current_score = fnc( CALC_CENTER_EXP_ANGLE);
//       }
//       else
//       {
//         current_score = 0;
//       }

       return current_score;
     }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_accessibility_hydrophobic_moment_magnitude.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_file.h"
#include "math/bcl_math_statistics.h"
#include "util/bcl_util_colors.h"
#include "util/bcl_util_string_replacement.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AccessibilityHydrophobicMomentMagnitude::s_Instance
    (
      GetObjectInstances().AddInstance( new AccessibilityHydrophobicMomentMagnitude())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AccessibilityHydrophobicMomentMagnitude::AccessibilityHydrophobicMomentMagnitude() :
      AccessibilityHydrophobicMoment()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param ENVIRONMENT the type of environment the accessibility was measured in that should be scored
    //! @param WINDOW_SIZES for sstype, number of restraints included in each window the moment will be calculated for
    AccessibilityHydrophobicMomentMagnitude::AccessibilityHydrophobicMomentMagnitude
    (
      const restraint::AccessibilityAA::EnvironmentType &ENVIRONMENT,
      const storage::Map< biol::SSType, size_t> WINDOW_SIZES
    ) :
      AccessibilityHydrophobicMoment( ENVIRONMENT, WINDOW_SIZES)
    {
    }

    //! @brief Clone function
    //! @return pointer to new AccessibilityHydrophobicMomentMagnitude
    AccessibilityHydrophobicMomentMagnitude *AccessibilityHydrophobicMomentMagnitude::Clone() const
    {
      return new AccessibilityHydrophobicMomentMagnitude( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AccessibilityHydrophobicMomentMagnitude::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief takes an accessibility profile that has been assigned and scores it
    //! @param ASSIGNMENT the profile assignment that is going to be scored
    //! @return double that is the score of the accessibility profile assignment
    double AccessibilityHydrophobicMomentMagnitude::operator()
    (
      const restraint::AccessibilityProfileAssignment &ASSIGNMENT
    ) const
    {
      // exposures to hold the magnitudes of hydrophobic moments from structure
      // accessilities to hold the magnitudes of the hydrophobic moments from experiment
      storage::List< double> exposures, accessibilities;

      // iterate over the sses and their associated restraints
      for
      (
        storage::Map
        <
          util::SiPtr< const assemble::SSE>, storage::List< restraint::AccessibilityAAAssignment>
        >::const_iterator
          itr( ASSIGNMENT.GetSSEAssignments().Begin()), itr_end( ASSIGNMENT.GetSSEAssignments().End());
        itr != itr_end;
        ++itr
      )
      {
        // make sure the sse siptr is defined and get a reference
        BCL_Assert( itr->first.IsDefined(), "SiPtr is not defined");
        const assemble::SSE &current_sse( *itr->first);
        BCL_MessageDbg( "scoring sse " + util::Format()( current_sse.GetIdentification()));

        // the list of assignments associated with the current sse
        const storage::List< restraint::AccessibilityAAAssignment> &current_sse_assignments( itr->second);

        // determine window size
        size_t window_size( util::GetUndefinedSize_t());
        storage::Map< biol::SSType, size_t>::const_iterator size_itr( m_WindowSizes.Find( current_sse.GetType()));
        if( size_itr != m_WindowSizes.End())
        {
          window_size = size_itr->second;
        }
        // true if the window size is not defined or is larger than the number of assignments
        if( !util::IsDefined( window_size) || window_size > current_sse_assignments.GetSize())
        {
          // set window size to the number of assignments for this sse
          window_size = current_sse_assignments.GetSize();
        }

        // get the list of moments for overlapping windows of the assignments
        const storage::List< AccessibilityHydrophobicMoment::Window> windows
        (
          CalculateHydrophobicMomentWindows( current_sse_assignments, window_size, m_AccessibilityType)
        );

        // no windows created
        if( windows.IsEmpty())
        {
          // go to next sse
          continue;
        }

        const size_t number_of_windows( windows.GetSize());
        BCL_MessageDbg( "number_of_windows " + util::Format()( number_of_windows));

        // iterate through the list of overlapping windows of assignments
        for
        (
          storage::List< AccessibilityHydrophobicMoment::Window>::const_iterator
            window_itr( windows.Begin()), window_itr_end( windows.End());
          window_itr != window_itr_end;
          ++window_itr
        )
        {
          const double exposure_magnitude     ( window_itr->GetCalculatedMoment().Norm());
          const double accessibility_magnitude( window_itr->GetExperimentMoment().Norm());
          exposures.PushBack( exposure_magnitude);
          accessibilities.PushBack( accessibility_magnitude);
        }
      }

      BCL_MessageDbg( "exposures are\n" + util::Format()( exposures));
      BCL_MessageDbg( "accessibilities are\n" + util::Format()( accessibilities));

      // calculate score as negative of spearman correlation
      double score
      (
        -math::Statistics::CorrelationSpearman< storage::List< double>::const_iterator>
        (
          exposures.Begin(), exposures.End(), accessibilities.Begin(), accessibilities.End()
        )
      );
      BCL_MessageDbg( "CorrelationSpearman\n" + util::Format()( score));

      // if correlation is not defined
      if( !util::IsDefined( score))
      {
        // set score to zero
        score = 0;
      }

      BCL_MessageDbg( "returning score \n" + util::Format()( score));

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AccessibilityHydrophobicMomentMagnitude::Read( std::istream &ISTREAM)
    {
      // read members
      AccessibilityHydrophobicMoment::Read( ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AccessibilityHydrophobicMomentMagnitude::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      AccessibilityHydrophobicMoment::Write( OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param ARGUMENT Argument to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
     std::ostream &AccessibilityHydrophobicMomentMagnitude::WriteDetailedSchemeAndValues
    (
      const restraint::AccessibilityProfileAssignment &ASSIGNMENT,
      std::ostream &OSTREAM
    ) const
     {
       OSTREAM << "AccessibilityHydrophobicMomentMagnitude::WriteDetailedSchemeAndValues\n";
       OSTREAM << "nr sses is " << ASSIGNMENT.GetSSEAssignments().GetSize() << '\n';

       // exposures to hold the magnitudes of hydrophobic moments from structure
       // accessilities to hold the magnitudes of the hydrophobic moments from experiment
       storage::List< double> exposures, accessibilities;
       for
       (
         storage::Map
         <
           util::SiPtr< const assemble::SSE>,
           storage::List< restraint::AccessibilityAAAssignment>,
           assemble::SSELessThanNoOverlap
         >::const_iterator
           sse_itr( ASSIGNMENT.GetSSEAssignments().Begin()), sse_itr_end( ASSIGNMENT.GetSSEAssignments().End());
         sse_itr != sse_itr_end;
         ++sse_itr
       )
       {
         // make sure the sse siptr is defined and get a reference
         BCL_Assert( sse_itr->first.IsDefined(), "SiPtr is not defined");
         const assemble::SSE &current_sse( *sse_itr->first);
         BCL_MessageDbg( "scoring sse " + util::Format()( current_sse.GetIdentification()));

         // the list of assignments associated with the current sse
         const storage::List< restraint::AccessibilityAAAssignment> &current_sse_assignments( sse_itr->second);

         // determine window size
         size_t window_size( util::GetUndefinedSize_t());
         storage::Map< biol::SSType, size_t>::const_iterator size_itr( m_WindowSizes.Find( current_sse.GetType()));
         if( size_itr != m_WindowSizes.End())
         {
           window_size = size_itr->second;
         }
         // true if the window size is not defined or is larger than the number of assignments
         if( !util::IsDefined( window_size) || window_size > current_sse_assignments.GetSize())
         {
           // set window size to the number of assignments for this sse
           window_size = current_sse_assignments.GetSize();
         }
         storage::List< AccessibilityHydrophobicMoment::Window> window_list
         (
           AccessibilityHydrophobicMoment::CalculateHydrophobicMomentWindows
           (
             current_sse_assignments, window_size, m_AccessibilityType
           )
         );

         std::string sse_id( sse_itr->first->GetIdentification());
         {
           util::StringReplacement space_replacer( util::StringReplacement::e_Any, " ", "");
           space_replacer.ReplaceEachIn( sse_id);
         }
         {
           util::StringReplacement space_replacer( util::StringReplacement::e_Any, "<==>", "");
           space_replacer.ReplaceEachIn( sse_id);
         }

         if( util::GetMessenger().GetCurrentMessageLevel() == util::Message::e_Debug)
         {
           io::OFStream write;
           io::File::MustOpenOFStream
           (
             write, "show_hydrophobic_moment_" + sse_id + "_" + m_AccessibilityType.GetString() + ".py"
           );
           AccessibilityHydrophobicMoment::ShowHydrophobicMomentWindows
           (
             window_list,
             write,
             *sse_itr->first,
             std::string( "sse_id"),
             util::GetColors().e_Cyan
           );
           io::File::CloseClearFStream( write);
         }
         OSTREAM << "for sse " << current_sse.GetIdentification() << " nr assignments is "
                 << ASSIGNMENT.GetSSEAssignments().GetSize() << " and nr windows is " << window_list.GetSize() << '\n';

         // iterate over the window list and print out the windows
         // iterate through the list of overlapping windows of assignments
         for
         (
           storage::List< AccessibilityHydrophobicMoment::Window>::const_iterator
             window_itr( window_list.Begin()), window_itr_end( window_list.End());
           window_itr != window_itr_end;
           ++window_itr
         )
         {
           OSTREAM << window_itr->GetIdentification() << '\n';

           const double exposure_magnitude     ( window_itr->GetCalculatedMoment().Norm());
           const double accessibility_magnitude( window_itr->GetExperimentMoment().Norm());
           exposures.PushBack( exposure_magnitude);
           accessibilities.PushBack( accessibility_magnitude);

           OSTREAM << "exposure_magnitude " << exposure_magnitude
                   << "\naccessibility_magnitude " << accessibility_magnitude << '\n';
         }

       }

       const double score
       (
         -math::Statistics::CorrelationSpearman
         (
           exposures.Begin(), exposures.End(), accessibilities.Begin(), accessibilities.End()
         )
       );

       OSTREAM << "score: " << score << '\n';

       return OSTREAM;
     }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_alignment_quality.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_quality.h"
#include "util/bcl_util_si_ptr_vector.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AlignmentQuality::s_Instance
    ( GetObjectInstances().AddInstance( new AlignmentQuality()));

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AlignmentQuality::AlignmentQuality()
    {
    }

    //! @brief Clone function
    //! @return pointer to new AlignmentQuality
    AlignmentQuality *AlignmentQuality::Clone() const
    {
      return new AlignmentQuality( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AlignmentQuality::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief set the measure
    //! @param SP_MEASURE the measure to use
    void AlignmentQuality::SetMeasure( const util::ShPtr< quality::MeasureInterface> &SP_MEASURE)
    {
      m_QualityMeasure = SP_MEASURE;
    }

    //! @brief set the atoms to consider for the quality measure
    //! @param ATOM_TYPES storage set of atoms to use
    void AlignmentQuality::SetAtoms( const storage::Set< biol::AtomType> &ATOM_TYPES)
    {
      m_AtomTypes = ATOM_TYPES;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates the quality measure for the given alignment
    //! @param ALIGNMENT the alignment to consider
    //! @return the quality measure for all aligned atom coordinates
    double AlignmentQuality::operator()( const align::AlignmentInterface< biol::AABase> &ALIGNMENT) const
    {
      const storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > coords
      (
        assemble::Quality::CoordinatesFromAlignment( ALIGNMENT, m_AtomTypes)
      );
      return m_QualityMeasure->CalculateMeasure( coords.First(), coords.Second());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AlignmentQuality::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_QualityMeasure, ISTREAM);
      io::Serialize::Read( m_AtomTypes     , ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AlignmentQuality::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_QualityMeasure, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AtomTypes     , OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_assignment_gap_simple.h"

// includes from bcl - sorted alphabetically
#include "util/bcl_util_object_instances.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AssignmentGapSimple::s_Instance
    (
      GetObjectInstances().AddInstance( new AssignmentGapSimple( 0.0))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor from optional parameter
    AssignmentGapSimple::AssignmentGapSimple( const double GAP_PENALTY) :
      m_Penalty( GAP_PENALTY)
    {
    }

    //! @brief Clone is the virtual Clone constructor
    //! @return a pointer to new AssignmentGapSimple which is a copy of this
    AssignmentGapSimple *AssignmentGapSimple::Clone() const
    {
      return new AssignmentGapSimple( *this);
    }

    //! destructor
    AssignmentGapSimple::~AssignmentGapSimple()
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AssignmentGapSimple::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief function GetData returns "m_Penalty"
    //! @return "m_Penalty"
    double AssignmentGapSimple::GetPenalty() const
    {
      return m_Penalty;
    }

    //! @brief function SetData changes "m_Penalty" to a new penalty
    void AssignmentGapSimple::SetPenalty( const double &PENALTY)
    {
      m_Penalty = PENALTY;
    }

    //! @brief operator () overwritten for the FunctionInterface
    //! @param SIZE size_t which is the size of the gap
    //! @return double which is the score for a gap of size SIZE
    double AssignmentGapSimple::operator()( const size_t &SIZE) const
    {
      // return "m_Penalty" multiplied by SIZE
      return m_Penalty * SIZE;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AssignmentGapSimple::Read( std::istream &ISTREAM)
    {
      // read in member
      io::Serialize::Read( m_Penalty, ISTREAM);

      // return ISTREAM
      return ISTREAM;
    }

    //! @brief read from std::ostream
    //! @param OSTREAM input stream
    //! @param INDENT indentation
    //! @return ostream which was read from
    std::ostream &AssignmentGapSimple::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Penalty, OSTREAM, INDENT) << '\n';

      // return OSTREAM
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl

// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_body_assignment.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "io/bcl_io_serialization.h"
#include "restraint/bcl_restraint_assignment.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> BodyAssignment::s_Instance
    (
      GetObjectInstances().AddInstance( new BodyAssignment())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    BodyAssignment::BodyAssignment() :
      m_BodyAgreement()
    {
    }

    //! @brief construct from a ShPtr to FunctionInterface defining the measure of coord::GeometryInterface agreement
    //! @param BODY_AGREEMENT ShPtr to FunctionInterface defining the measure of coord::GeometryInterface agreement
    BodyAssignment::BodyAssignment
    (
      const util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSEGeometryInterface, assemble::SSE, double> > &BODY_AGREEMENT
    ) :
      m_BodyAgreement( *BODY_AGREEMENT)
    {
    }

    //! @brief construct from a FunctionInterface defining the measure of coord::GeometryInterface agreement
    //! @param BODY_AGREEMENT FunctionInterface defining the measure of coord::GeometryInterface agreement
    BodyAssignment::BodyAssignment
    (
      const math::BinaryFunctionInterfaceSerializable< assemble::SSEGeometryInterface, assemble::SSE, double> &BODY_AGREEMENT
    ) :
      m_BodyAgreement( BODY_AGREEMENT.Clone())
    {
    }

    //! @brief Clone is the virtual copy constructor
    BodyAssignment *BodyAssignment::Clone() const
    {
      return new BodyAssignment( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &BodyAssignment::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get scheme
    //! @return scheme
    const std::string &BodyAssignment::GetScheme() const
    {
      return m_BodyAgreement->GetScheme();
    }

    //! @brief get scheme
    //! @return scheme
    const std::string &BodyAssignment::GetAlias() const
    {
      return m_BodyAgreement.GetAlias();
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator() which takes an Assignment for calculating its score
    //! @param ASSIGNMENT the assignment which contains the coord::Bodies who will be scored
    //! @return return a double which is the score of the Assignment
    double BodyAssignment::operator()
    (
      const restraint::SSEAssignment &ASSIGNMENT
    ) const
    {
      // create double "score" for holding the score of "ASSIGNMENT"
      double score( 0);

      // iterate through the assigned Bodies in the Assignment
      for
      (
        restraint::GroupCollection< size_t, assemble::SSE>::const_iterator
          itr( ASSIGNMENT.GetGroupCollection().Begin()), itr_end( ASSIGNMENT.GetGroupCollection().End());
        itr != itr_end;
        ++itr
      )
      {
        // add the agreement of the two bodies indicated by "itr" to "score"
        const double agreement
        (
          m_BodyAgreement->operator()
          (
            *ASSIGNMENT.GetRestraint()->operator()( itr->first),
            *itr->second.FirstElement()
          )
        );
        BCL_MessageDbg
        (
          "score::BodyAssignment::operator() current assignment body agreement "
          + util::Format()( agreement)
        );
        score += agreement;
      }

      BCL_MessageDbg
      (
        "score::BodyAssignment::operator() assignment score "
        + util::Format()( score)
      );

      // return "score" which is the score of the assignment
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer BodyAssignment::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      (
        "computes body agreement for sses"
      );
      serializer.AddInitializer
      (
        "",
        "method used to compute body agreement",
        io::Serialization::GetAgent( &m_BodyAgreement)
      );
      return serializer;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_body_connectivity_density.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "math/bcl_math_running_average_sd.h"
#include "util/bcl_util_sh_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> BodyConnectivityDensity::s_Instance
    (
      GetObjectInstances().AddInstance( new BodyConnectivityDensity())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &BodyConnectivityDensity::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "connectivity");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    BodyConnectivityDensity::BodyConnectivityDensity() :
      m_Scores()
    {
    }

    //! @brief constructor taking a storage::Map and  ShPtr< restraint::Body>
    //! @param CONNECTIVITY_SCORES the storage::Map which will be "m_Scores"
    //! @param BODY_RESTRAINT util::ShPtr< restraint::Body> which will be "m_BodyRestraint"
    //! @param SCHEME
    BodyConnectivityDensity::BodyConnectivityDensity
    (
      const storage::Map< density::Connectivity, double, density::Connectivity::LessThan> &
        CONNECTIVITY_SCORES,
      const util::ShPtr< restraint::Body> &BODY_RESTRAINT,
      const std::string &SCHEME
    ) :
      m_Scores( CONNECTIVITY_SCORES),
      m_BodyRestraint( BODY_RESTRAINT),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking a restraint::Body and a Density Map
    //!        This constructor calculates the scores that go into "m_Scores" and fills "m_Scores"
    //! @param BODY_RESTRAINT contains the information about which bodies densities will be calculated between and
    //!        which will be "m_BodyRestraint"
    //! @param DENSITY_MAP experimental density map which is used to calculate the minimal density between each of
    //!        the bodies in "BODY_RESTRAINT"
    //! @param SCHEME
    BodyConnectivityDensity::BodyConnectivityDensity
    (
      const util::ShPtr< restraint::Body> &BODY_RESTRAINT,
      const util::ShPtr< density::Map> &DENSITY_MAP,
      const std::string &SCHEME
    ) :
      m_Scores( InitializeScores( BODY_RESTRAINT, DENSITY_MAP)),
      m_BodyRestraint( BODY_RESTRAINT),
      m_Scheme( SCHEME)
    {
      for
      (
        storage::Map< density::Connectivity, double, density::Connectivity::LessThan>::const_iterator
          list_itr( m_Scores.Begin()), list_itr_end( m_Scores.End());
        list_itr != list_itr_end; ++list_itr
      )
      {
        BCL_MessageDbg
        (
          "score found in map: " + util::Format()( list_itr->second) +
            " , distance: " + util::Format()( list_itr->first.GetDistance()) +
            " , connectivity: " + util::Format()( list_itr->first.GetConnectivity())
        );
      }

    }

    //! @brief virtual copy constructor
    BodyConnectivityDensity *BodyConnectivityDensity::Clone() const
    {
      return new BodyConnectivityDensity( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &BodyConnectivityDensity::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &BodyConnectivityDensity::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief GetScores gives a const reference to "m_Scores"
    //! @return a const reference to "m_Scores"
    const storage::Map< density::Connectivity, double, density::Connectivity::LessThan> &
    BodyConnectivityDensity::GetScores() const
    {
      return m_Scores;
    }

    //! @brief GetBodyRestraint returns a const reference to "m_BodyRestraint"
    //! @return a const reference to "m_BodyRestraint"
    const util::ShPtr< restraint::Body> &BodyConnectivityDensity::GetBodyRestraint() const
    {
      return m_BodyRestraint;
    }

  ///////////////
  // operators //
  ///////////////

    // use GetNeighborSSE function to get neighboring SSEs!!!!!!!!!!!!

    //! @brief operator() which takes an Assignment and returns the density connectivity score.
    //!        The assignment contains all the body restraints and the corresponding protein model bodies.
    //!        For each pair of restraint bodies which are related by sequence (i.e. would be connected by a loop)
    //!        according to the protein model bodies which fill them,
    //!        the two points between which the density needs to be calculated are determined. The score for the
    //!        density between the two points is then determined.
    //! @param PROTEIN_MODEL the ProteinModel which will be scored for agreement with the connectivity
    //! @return return a double which is the score of the agreement of the ProteinModel with the connectivity
    double BodyConnectivityDensity::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // create double "connectivity_score" and initialize with zero
      double connectivity_score( 0.0);

      // iterate over chains of "PROTEIN_MODEL"
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // if the number of SSEs in current chain is smaller than two, skip considering this chain
        if( ( *chain_itr)->GetData().GetSize() < 2)
        {
          BCL_MessageVrb( "Skip chain for BodyConnectivityDensity score, SSE count < 2");
          continue;
        }

        // Iterate over sse neighbors in the Set of SSEs which means they are also neighbors in sequence
        // i.e. sse1 and sse2; sse2 and sse3; sse3 and sse4... So that the connection points between the two SSEs
        // adjacent in sequence can be gotten and the density connectivity score between those two connection points
        // can be determined. No discrimination is taken to automatically exclude
        // connections between sses which are, in the protein model, adjacent in sequence, but, in space, very
        // far apart. The scores are left to take care of this.
        for
        (
          storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
            sse_iter_a( ( *chain_itr)->GetData().Begin()),
            sse_iter_b( ++( *chain_itr)->GetData().Begin()),
            sse_itr_end( ( *chain_itr)->GetData().End());
          sse_iter_b != sse_itr_end;
          ++sse_iter_a, ++sse_iter_b
        )
        {
          // create SiPtr to SSE "sse_a" initialize with the SSE denoted by "sse_iter_a"
          const util::SiPtr< const assemble::SSE> sse_a( **sse_iter_a);

          // create SiPtr to SSE "sse_b" initialize with the SSE denoted by "sse_iter_b"
          const util::SiPtr< const assemble::SSE> sse_b( **sse_iter_b);

          // in agreement with the implementation in the old BCL, only calculate scores for neighboring sses that
          // are not further than 10 aa in sequence apart
          if( sse_b->GetFirstAA()->GetSeqID() - sse_a->GetLastAA()->GetSeqID() > 10)
          {
            BCL_MessageVrb( "Skip this pair of SSEs, distance > 10AA");
            continue;
          }
          // create const VectorND "connection_points" initialize with the connection points between
          // the SSEs denoted by "sse_iter_a" and "sse_iter_b"
          const storage::Pair< storage::VectorND< 2, const util::ShPtr< coord::GeometryInterface> >, storage::VectorND< 2, bool> >
          restraint_bodies_and_orientation
          (
            GetRestraintBodiesandOrientations
            (
              storage::VectorND< 2, util::SiPtr< const assemble::SSE> >( sse_a, sse_b)
            )
          );

          if( !restraint_bodies_and_orientation.First().First().IsDefined() || !restraint_bodies_and_orientation.First().Second().IsDefined())
          {
            BCL_MessageVrb( "Skip this pair of SSEs, at least one does not occupy a body");
            continue;
          }

          if( restraint_bodies_and_orientation.First().First() == restraint_bodies_and_orientation.First().Second())
          {
            BCL_MessageVrb( "Skip this pair of SSEs, both occupy the same body");
            continue;
          }

          // create const double "current_score" and initialize with the score of the connectivity between
          // the points specified by restraint_bodies_and_orientation
          const double current_score( CalculateScore( restraint_bodies_and_orientation));

          // add "current_score" to "connectivity_score"
          connectivity_score += current_score;
        }
      }

      // return "connectivity_score" which is the total score of all the connectivities in "PROTEIN_MODEL"
      return connectivity_score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read distance from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &BodyConnectivityDensity::Read( std::istream &ISTREAM)
    {
      // read in members
      io::Serialize::Read( m_Scores, ISTREAM);
      io::Serialize::Read( m_BodyRestraint, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      return ISTREAM;
    }

    //! @brief write distance to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &BodyConnectivityDensity::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scores, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_BodyRestraint, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief InitializeScores initializes "m_Scores" upon construction
    //! @param BODY_RESTRAINT contains the information about which bodies densities will be calculated between and
    //!        which will be "m_BodyRestraint"
    //! @param DENSITY_MAP experimental density map which is used to calculate the minimal density between each of
    //!        the bodies in "BODY_RESTRAINT"
    //! @return storage::Map which will be "m_Scores"
    storage::Map< density::Connectivity, double, density::Connectivity::LessThan>
    BodyConnectivityDensity::InitializeScores
    (
      const util::ShPtr< restraint::Body> &BODY_RESTRAINT,
      const util::ShPtr< density::Map> &DENSITY_MAP
    ) const
    {
      const util::ShPtrList< assemble::SSEGeometryInterface> body_list
      (
        BODY_RESTRAINT->GetBody()->Begin(), BODY_RESTRAINT->GetBody()->End()
      );

      //initialize storage list to hold all the DensityConnectivity objects
      storage::List< density::Connectivity> all_connectivities
      (
        density::Connectivity::DetermineConnectivities( *DENSITY_MAP, body_list)
      );

      // create storage::Map "connection_intensities" to hold the raw intensities between all the bodies of
      // "BODY_RESTRAINT" by calculating the scores for all connectivities
      storage::Map< density::Connectivity, double, density::Connectivity::LessThan> connection_intensities
      (
        ConvertIntensitiesToScores( all_connectivities)
      );

      //  return the resulting map of all connectivities and scores in density map
      return connection_intensities;
    }

    //! @brief ConvertIntensitiesToScores takes the raw intensities determined between restraint::Bodies and
    //!        converts them into a Z-score
    //! @param CONNECTIVITIES a storage::List which has all the DensityConnectivity objects to be converted to scores.
    //! @return returns a storage::Map which has the Z-scores and will be "m_Scores"
    storage::Map< density::Connectivity, double, density::Connectivity::LessThan>
    BodyConnectivityDensity::ConvertIntensitiesToScores
    (
      const storage::List< density::Connectivity> &CONNECTIVITIES
    ) const
    {
      // initialize empty RunningAverageSD< double> object for sd and mean calculation
      math::RunningAverageSD< double> mean_sd;
      // calculate the sd and mean by iterating over all connectivity intensities
      for
      (
        storage::List< density::Connectivity>::const_iterator
          intensity_iter( CONNECTIVITIES.Begin()), intensity_iter_end( CONNECTIVITIES.End());
        intensity_iter != intensity_iter_end;
        ++intensity_iter
      )
      {
        // consider the current intensity
        mean_sd += intensity_iter->GetConnectivity();
      }

      // create double "mean" and initialize with the mean of the intensities in "intensities"
      const double mean( mean_sd.GetAverage());

      // create double std_dev and initialize with the std deviation of the intensities in "intensities"
      const double std_dev( mean_sd.GetStandardDeviation());

      BCL_MessageCrt( "mean: " + util::Format()( mean) + " , stddev: " + util::Format()( std_dev));

      // create storage::Map "scores" and initialize with "CONNECTIVITIES"
      storage::Map< density::Connectivity, double, density::Connectivity::LessThan> scores;

      // iterate through "CONNECTIVITIES" to convert the raw intensities into z-scores
      for
      (
        storage::List< density::Connectivity>::const_iterator
          score_iter( CONNECTIVITIES.Begin()), score_iter_end( CONNECTIVITIES.End());
        score_iter != score_iter_end;
        ++score_iter
      )
      {
        const double current_intensity( score_iter->GetConnectivity());
        const double score( ( mean - current_intensity) / std_dev);

        // assert when insert into map fails (because the same element is already in the map)
        BCL_Assert
        (
          scores.Insert( std::pair< density::Connectivity, double>( *score_iter, score)).second,
          "pair of connectivity object and z-score could not be inserted into map\nBody A bool" +
            util::Format()( score_iter->GetOrientationA()) +
            "Body B bool" + util::Format()( score_iter->GetOrientationB()) +
            "connectivity" + util::Format()( score_iter->GetConnectivity()) +
            "distance" + util::Format()( score_iter->GetDistance()) +
            "score:" + util::Format()( score)
        );

        const storage::Map< density::Connectivity, double, density::Connectivity::LessThan>::const_iterator
        connectivity_itr( scores.Find( *score_iter));
        BCL_Assert
        (
          connectivity_itr != scores.End(),
          "could not find particular DensityConnectivity object:" + util::Format()( *score_iter)
        );
      }

      // return "scores" which has the z-scores
      return scores;
    }

    //! @brief GetRestraintBodiesandOrientations determines the two restraint bodies (i.e. density rods) occupied by
    //!        two neighboring SSEs in the protein model and at which ends of the restraint bodies the protein model
    //!        connects them (in the form of two bools)
    //! @param SSES are the two SSEs for which the two points of connection are desired
    //! @return returns a storage::Pair of vector of two bodies and vector of two bools
    storage::Pair< storage::VectorND< 2, const util::ShPtr< coord::GeometryInterface> >, storage::VectorND< 2, bool> >
    BodyConnectivityDensity::GetRestraintBodiesandOrientations
    (
      const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > &SSES
    ) const
    {
      // obtain the bodies of the density rods that sses are occupying
      const util::ShPtr< assemble::SSEGeometryInterface> body_restraint_first( m_BodyRestraint->GetOccupiedBody( *SSES.First()));
      const util::ShPtr< assemble::SSEGeometryInterface> body_restraint_second( m_BodyRestraint->GetOccupiedBody( *SSES.Second()));

      if( !body_restraint_first.IsDefined() || !body_restraint_second.IsDefined())
      {
        return storage::Pair< storage::VectorND< 2, const util::ShPtr< coord::GeometryInterface> >, storage::VectorND< 2, bool> >();
      }

      bool orientation_first, orientation_second;

      // true if the first SSE comes before the second SSE in sequence
      if( assemble::SSELessThan().operator()( *SSES.First(), *SSES.Second()))
      {
        orientation_first = DetermineSSEOrientationInBodyRestraint( SSES.First()->EndOfZ(), *body_restraint_first);
        orientation_second = DetermineSSEOrientationInBodyRestraint( SSES.Second()->BeginOfZ(), *body_restraint_second);

        // return the end of the first SSE and the beginning of the second SSE
        return storage::Pair< storage::VectorND< 2, const util::ShPtr< coord::GeometryInterface> >, storage::VectorND< 2, bool> >
        (
          storage::VectorND< 2, const util::ShPtr< coord::GeometryInterface> > ( body_restraint_first, body_restraint_second),
          storage::VectorND< 2, bool>( orientation_first, orientation_second)
        );
      }

      // the first SSE comes after the second SSE in sequence so return the beginning of the first SSE and the end
      // of the second SSE
      orientation_first = DetermineSSEOrientationInBodyRestraint( SSES.First()->BeginOfZ(), *body_restraint_first);
      orientation_second = DetermineSSEOrientationInBodyRestraint( SSES.Second()->EndOfZ(), *body_restraint_second);

      // return the beginning of the first SSE and the end of the second SSE
      return storage::Pair< storage::VectorND< 2, const util::ShPtr< coord::GeometryInterface> >, storage::VectorND< 2, bool> >
      (
        storage::VectorND< 2, const util::ShPtr< coord::GeometryInterface> > ( body_restraint_first, body_restraint_second),
        storage::VectorND< 2, bool>( orientation_first, orientation_second)
      );
    }

    //! @brief DetermineSSEOrientationInBodyRestraint is used to match a coordinate with one of the end points of
    //!        a body by checking which end the coordinate is closer to. This is used to determine which
    //!        direction an SSE is pointing in a restraining body, for example.
    //! @param SSE_POINT is the coordinate for which its position in the restraining body is desired
    //! @param BODY the body for which the placement position of SSE_POINT is desired
    //! @return returns a bool to indicate to which of the ends of "BODY" "SSE_POINT" is closest (true for beginning
    //!         of BODY, false for end of BODY)
    bool BodyConnectivityDensity::DetermineSSEOrientationInBodyRestraint
    (
      const linal::Vector3D &SSE_POINT,
      const coord::GeometryInterface &BODY
    ) const
    {
      // get the end of "BODY"
      const linal::Vector3D body_end( BODY.GetGeometries().LastElement()->GetCenter());

      // get the beginning of "BODY"
      const linal::Vector3D body_begin( BODY.GetGeometries().FirstElement()->GetCenter());

      // true if "SSE_POINT" is closer to "body_end" than "body_begin", then return "false"
      // else return "true" because "SSE_POINT" is closer to "body_begin" than "body_end"
      return !( linal::SquareDistance( SSE_POINT, body_end) < linal::SquareDistance( SSE_POINT, body_begin));
    }

    //! @brief GetScore returns the calculated Z-score connectivity score for connecting two bodies (at specific ends)
    //! @param CONNECTIVITY_INFORMATION a storage::Pair of vector of two bodies and vector of two bools (specifying
    //!        which two bodies are to be connected and at which ends of the bodies)
    //! @return returns a double which is the Z-score associated with connecting CONNECTIVITY_INFORMATION
    double BodyConnectivityDensity::CalculateScore
    (
      const storage::Pair< storage::VectorND< 2, const util::ShPtr< coord::GeometryInterface> >, storage::VectorND< 2, bool> >
      &CONNECTIVITY_INFORMATION
    ) const
    {
      // initialize distance cutoff beyond which the connection will not be scored
      const double distance_cutoff( 10.0);

      // construct half filled DensityConnectivity object (in one specific order)
      density::Connectivity temp_connectivity
      (
        CONNECTIVITY_INFORMATION.First().First(),
        CONNECTIVITY_INFORMATION.Second().First(),
        CONNECTIVITY_INFORMATION.First().Second(),
        CONNECTIVITY_INFORMATION.Second().Second()
      );

      const storage::Map< density::Connectivity, double, density::Connectivity::LessThan>::const_iterator
      connectivity_itr( m_Scores.Find( temp_connectivity));

      // if that particular temporary density connectivity object could not be found in the map
      if( connectivity_itr == m_Scores.End())
      {
        // try constructing the swapped object and finding this in the map
        density::Connectivity temp_connectivity_swapped
        (
          CONNECTIVITY_INFORMATION.First().Second(),
          CONNECTIVITY_INFORMATION.Second().Second(),
          CONNECTIVITY_INFORMATION.First().First(),
          CONNECTIVITY_INFORMATION.Second().First()
        );

        const storage::Map< density::Connectivity, double, density::Connectivity::LessThan>::const_iterator
        connectivity_itr_swapped( m_Scores.Find( temp_connectivity_swapped));

        // if the swapped object also isn't found in the map, then something is seriously wrong
        BCL_Assert
        (
          connectivity_itr_swapped != m_Scores.End(),
          "could not find particular DensityConnectivity object:" + util::Format()( temp_connectivity_swapped)
        );

        // return the score of the identified connectivity object if the two points are within a certain distance
        if( connectivity_itr_swapped->first.GetDistance() <= distance_cutoff)
        {
          return connectivity_itr_swapped->second;
        }
        // if too far away, just return 0.0
        return double( 0.0);
      }

      // return the score of the identified connectivity object if the two points are within a certain distance
      if( connectivity_itr->first.GetDistance() <= distance_cutoff)
      {
        // return the score of the identified connectivity object
        return connectivity_itr->second;
      }
      // if too far away, just return 0.0
      return double( 0.0);
    }

  } // namespace score
} // namespace bcl

// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_body_extent_agreement.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> BodyExtentAgreement::s_Instance
    (
      GetObjectInstances().AddInstance( new BodyExtentAgreement())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    BodyExtentAgreement::BodyExtentAgreement() :
      m_LowerTolerance(),
      m_LowerTransitionWidth(),
      m_UpperTolerance(),
      m_UpperTransitionWidth(),
      m_EnergyWellDepth(),
      m_Axis()
    {
    }

    //! @brief constructor
    //! @param LOWER_TOLERANCE the amount an extent can be shorter than the restraint and still be considered perfect
    //! @param LOWER_TRANSITION_WIDTH width of range over which a too short extent goes from perfect to non-agreeing
    //! @param UPPER_TOLERANCE the amount an extent can be longer than the restraint and still be considered perfect
    //! @param UPPER_TRANSITION_WIDTH width of range over which a too long extent goes from perfect to non-agreeing
    //! @param ENERGY_WELL_DEPTH the amount that an agreeing restraint will give a bonus to the energy
    //! @param AXIS defines which extent (x, y, z) is being checked for restraint agreement
    BodyExtentAgreement::BodyExtentAgreement
    (
      const double LOWER_TOLERANCE, const double LOWER_TRANSITION_WIDTH, const double UPPER_TOLERANCE,
      const double UPPER_TRANSITION_WIDTH, const double ENERGY_WELL_DEPTH, const coord::Axis &AXIS
    ) :
      m_LowerTolerance( LOWER_TOLERANCE),
      m_LowerTransitionWidth( LOWER_TRANSITION_WIDTH),
      m_UpperTolerance( UPPER_TOLERANCE),
      m_UpperTransitionWidth( UPPER_TRANSITION_WIDTH),
      m_EnergyWellDepth( ENERGY_WELL_DEPTH),
      m_Axis( AXIS)
    {
    }

    //! @brief Clone is the virtual copy constructor
    BodyExtentAgreement *BodyExtentAgreement::Clone() const
    {
      return new BodyExtentAgreement( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &BodyExtentAgreement::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return the scheme
    //! @return string that describes that score
    const std::string &BodyExtentAgreement::GetScheme() const
    {
      static const std::string s_scheme( "body_agreement");
      return s_scheme;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &BodyExtentAgreement::GetAlias() const
    {
      static const std::string s_name( "BodyExtentAgreement");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer BodyExtentAgreement::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores agreement between two coord::Bodies");
      serializer.AddInitializer
      (
        "lower tolerance",
        "the amount an extent can be shorter than the restraint and still be considered perfect",
        io::Serialization::GetAgent( &m_LowerTolerance)
      );
      serializer.AddInitializer
      (
        "lower transition width",
        "range over which a too short extent goes from perfect to non-agreeing",
        io::Serialization::GetAgent( &m_LowerTransitionWidth)
      );
      serializer.AddInitializer
      (
        "upper tolerance",
        "the amount an extent can be longer than the restraint and still be considered perfect",
        io::Serialization::GetAgent( &m_UpperTolerance)
      );
      serializer.AddInitializer
      (
        "upper transition width",
        "range over which a too long extent goes from perfect to non-agreeing",
        io::Serialization::GetAgent( &m_UpperTransitionWidth)
      );
      serializer.AddInitializer
      (
        "energy well depth",
        "amount that an agreeing restraint will give a bonus to the energy",
        io::Serialization::GetAgent( &m_EnergyWellDepth)
      );
      serializer.AddInitializer
      (
        "axis",
        "which extent is being checked for restraint agreement",
        io::Serialization::GetAgent( &m_Axis)
      );

      return serializer;
    }
 
  ////////////////
  // operations //
  ////////////////

    //! @brief operator() which takes a density rod and an assigned SSE
    //! @param BODY the density rod
    //! @param SSE the secondary structure element assigned to that body
    //! @return return a double which is the agreement the body with the sse
    double BodyExtentAgreement::operator()( const assemble::SSEGeometryInterface &BODY, const assemble::SSE &SSE) const
    {
      // create double "deviation" initialize with the difference between extents of the restraint and the test body
      const double deviation( GetExtentDeviation( BODY, SSE));

      // true if extent completely outside of restraint
      if
      (
        deviation < -m_LowerTolerance - m_LowerTransitionWidth || deviation > m_UpperTolerance + m_UpperTransitionWidth
      )
      {
        BCL_MessageDbg
        (
          "completely outside of BodyExtentAgreement restraint : deviation : " + util::Format()( deviation)
        );
        BCL_MessageDbg
        (
          "-m_LowerTolerance - m_LowerTransitionWidth: " + util::Format()( -m_LowerTolerance - m_LowerTransitionWidth)
        );
        BCL_MessageDbg
        (
          "m_UpperTolerance + m_UpperTransitionWidth : " + util::Format()( m_UpperTolerance + m_UpperTransitionWidth)
        );

//        // no energy bonus given
//        return 0.0;

        // give penalty for large extent deviation (penalty is linearly proportional to extent deviation)
        // in case the length of the restraint body (density) is shorter than length of the test body (helix)
        if( deviation < -m_LowerTolerance - m_LowerTransitionWidth)
        {
          return ( math::Absolute( deviation) - m_LowerTolerance - m_LowerTransitionWidth);
        }
        // in case the length of the restraint body (density) is longer than length of the test body (helix)
        else if( deviation > m_UpperTolerance + m_UpperTransitionWidth)
        {
          return ( deviation - m_UpperTolerance - m_UpperTransitionWidth);
        }
      }
      // true if extent completely agrees with restraint
      else if( deviation >= -m_LowerTolerance && deviation <= m_UpperTolerance)
      {
        BCL_MessageDbg
        (
          "completely agreeing with BodyExtentAgreement restraint : deviation : " + util::Format()( deviation)
        );
        BCL_MessageDbg( "-m_LowerTolerance : " + util::Format()( -m_LowerTolerance));
        BCL_MessageDbg( "m_UpperTolerance  : " + util::Format()( m_UpperTolerance));

        // entire possible energy bonus given
        return m_EnergyWellDepth;
      }
      // true if extent is slightly less than restraint
      else if( deviation >= -m_LowerTolerance - m_LowerTransitionWidth && deviation < -m_LowerTolerance)
      {
        BCL_MessageDbg
        (
          "slightly less than restraint : deviation : " + util::Format()( deviation)
        );
        BCL_MessageDbg
        (
          "-m_LowerTolerance - m_LowerTransitionWidth: " + util::Format()( -m_LowerTolerance - m_LowerTransitionWidth)
        );
        BCL_MessageDbg
        (
          "m_LowerTolerance : " + util::Format()( m_LowerTolerance)
        );

        // create double "violation" and initialize with the difference between "m_LowerTolerance" and "deviation"
        double violation( -m_LowerTolerance - deviation);
        BCL_MessageDbg( "violation : " + util::Format()( violation));
        return 0.5 * m_EnergyWellDepth * cos( math::g_Pi * violation / m_LowerTransitionWidth) + 0.5 * m_EnergyWellDepth;
      }
      // true if slightly larger than restraint
      else if( deviation <= m_UpperTolerance + m_UpperTransitionWidth && deviation > m_UpperTolerance)
      {
        BCL_MessageDbg
        (
          "slightly larger than restraint : deviation : " + util::Format()( deviation)
        );
        BCL_MessageDbg
        (
          "m_UpperTolerance + m_UpperTransitionWidth : " + util::Format()( m_UpperTolerance + m_UpperTransitionWidth)
        );
        BCL_MessageDbg( "m_UpperTolerance : " + util::Format()( m_UpperTolerance));
        double violation( deviation - m_UpperTolerance);
        BCL_MessageDbg( "violation : " + util::Format()( violation));
        return 0.5 * m_EnergyWellDepth * cos( math::g_Pi * violation / m_UpperTransitionWidth) + 0.5 * m_EnergyWellDepth;
      }
      else
      {
        BCL_Exit( "could not determine the agreement of the to bodies", -1);
      }

      return 0.0;
    }

    //! @brief GetExtentDeviation gives the value of the extent position difference for an axis
    //!        between two bodies i.e. restraint body and test body
    //! @param BODY_A is the first coord::GeometryInterface used in the calculation
    //! @param BODY_B is the second coord::GeometryInterface used in the calculation
    //! @return returns the value of the difference in position of the extent of an axis
    double BodyExtentAgreement::GetExtentDeviation
    (
      const coord::GeometryInterface &BODY_A, const coord::GeometryInterface &BODY_B
    ) const
    {
      double body_a_extent( 2 * BODY_A.GetExtent( m_Axis));
      double body_b_extent( 2 * BODY_B.GetExtent( m_Axis));
      double difference( body_a_extent - body_b_extent);

      BCL_MessageDbg( "body_a_extent : " + util::Format()( body_a_extent));
      BCL_MessageDbg( "body_b_extent : " + util::Format()( body_b_extent));
      BCL_MessageDbg
      (
        "difference of extents: " + util::Format()( difference)
      );
      return difference;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &BodyExtentAgreement::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_LowerTolerance, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_LowerTransitionWidth, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_UpperTolerance, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_UpperTransitionWidth, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_EnergyWellDepth, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Axis, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &BodyExtentAgreement::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_LowerTolerance, ISTREAM);
      io::Serialize::Read( m_LowerTransitionWidth, ISTREAM);
      io::Serialize::Read( m_UpperTolerance, ISTREAM);
      io::Serialize::Read( m_UpperTransitionWidth, ISTREAM);
      io::Serialize::Read( m_EnergyWellDepth, ISTREAM);
      io::Serialize::Read( m_Axis, ISTREAM);

      // end
      return ISTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_body_extent_position_agreement.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> BodyExtentPositionAgreement::s_Instance
    (
      GetObjectInstances().AddInstance( new BodyExtentPositionAgreement())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    BodyExtentPositionAgreement::BodyExtentPositionAgreement() :
      m_LowerTolerance( 1.5),
      m_LowerTransitionWidth( 3.0),
      m_UpperTolerance( 1.5),
      m_UpperTransitionWidth( 3.0),
      m_EnergyWellDepth( -1.0)
    {
    }

    //! @brief Clone is the virtual copy constructor
    BodyExtentPositionAgreement *BodyExtentPositionAgreement::Clone() const
    {
      return new BodyExtentPositionAgreement( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &BodyExtentPositionAgreement::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object
    //! @return the name of the object
    const std::string &BodyExtentPositionAgreement::GetAlias() const
    {
      static const std::string s_name( "BodyExtentPositionAgreement");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer BodyExtentPositionAgreement::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores the agreement of two coord::Bodies based on the deviation between their x, y , and z extents");
      serializer.AddInitializer
      (
        "lower tolerance",
        "the amount an extent can be shorter than the restraint and still be considered perfect",
        io::Serialization::GetAgent( &m_LowerTolerance)
      );
      serializer.AddInitializer
      (
        "lower transition width",
        "range over which a too short extent goes from perfect to non-agreeing",
        io::Serialization::GetAgent( &m_LowerTransitionWidth)
      );
      serializer.AddInitializer
      (
        "upper tolerance",
        "the amount an extent can be longer than the restraint and still be considered perfect",
        io::Serialization::GetAgent( &m_UpperTolerance)
      );
      serializer.AddInitializer
      (
        "upper transition width",
        "range over which a too long extent goes from perfect to non-agreeing",
        io::Serialization::GetAgent( &m_UpperTransitionWidth)
      );
      serializer.AddInitializer
      (
        "energy well depth",
        "amount that an agreeing restraint will give a bonus to the energy",
        io::Serialization::GetAgent( &m_EnergyWellDepth)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator() which takes a density rod and an assigned SSE
    //! @param BODY the density rod
    //! @param SSE the secondary structure element assigned to that body
    //! @return return a double which is the agreement the body with the sse
    double BodyExtentPositionAgreement::operator()( const assemble::SSEGeometryInterface &BODY, const assemble::SSE &SSE) const
    {
      BCL_Assert( BODY.GetCenter() == SSE.GetCenter(), "origin of bodies is not the same");
//      cost double x_deviation( GetAbsoluteExtentDeviation( BODIES.First(), BODIES.Second(), coord::GetAxes().e_X));
//      const double y_deviation( GetAbsoluteExtentDeviation( BODIES.First(), BODIES.Second(), coord::GetAxes().e_Y));
      const double z_deviation( GetAbsoluteExtentDeviation( BODY, SSE, coord::GetAxes().e_Z));

      // true if completely outside of restraint
      if( z_deviation > m_LowerTolerance + m_LowerTransitionWidth || z_deviation > m_UpperTolerance + m_UpperTransitionWidth)
      {
        return 0;
      }
      // true if completely agreeing with restraint
      else if( z_deviation < m_LowerTolerance && z_deviation < m_UpperTolerance)
      {
        return m_EnergyWellDepth;
      }
      // true if slightly less than restraint
      else if( z_deviation < m_LowerTolerance + m_LowerTransitionWidth)
      {
        double violation( m_LowerTolerance - z_deviation);
        return 0.5 * m_EnergyWellDepth * cos( math::g_Pi * violation / m_LowerTransitionWidth) + 0.5 * m_EnergyWellDepth;
      }
      // true if slightly larger than restraint
      else if( z_deviation < m_UpperTolerance + m_UpperTransitionWidth)
      {
        double violation( z_deviation - m_UpperTolerance);
        return 0.5 * m_EnergyWellDepth * cos( math::g_Pi * violation / m_UpperTransitionWidth) + 0.5 * m_EnergyWellDepth;
      }
      else
      {
        BCL_Exit( "could not determine the agreement of the to bodies", -1);
      }

      return 0.0;
    }

    //! @brief GetAbsoluteExtentDeviation gives the absolute value of the extent position difference for an axis
    //! @param BODY_A is the first coord::GeometryInterface used in the calculation
    //! @param BODY_B is the second coord::GeometryInterface used in the calculation
    //! @param AXIS is the RotationAxis for which the calculation will be performed
    //! @return returns the absolute value of the difference in position of the extent of an axis
    double BodyExtentPositionAgreement::GetAbsoluteExtentDeviation
    (
      const coord::GeometryInterface &BODY_A, const coord::GeometryInterface &BODY_B, const coord::Axis &AXIS
    ) const
    {
      double body_a_extent_position( GetExtentPosition( BODY_A, AXIS));
      double body_b_extent_position( GetExtentPosition( BODY_B, AXIS));
      double difference( math::Absolute( body_a_extent_position - body_b_extent_position));
      BCL_MessageDbg( "body_a_extent_position : " + util::Format()( body_a_extent_position));
      BCL_MessageDbg( "body_b_extent_position : " + util::Format()( body_b_extent_position));
      BCL_MessageDbg
      (
        "BodyExtentPositionAgreement::GetAbsoluteExtentDeviation difference: "
        + util::Format()( difference)
      );
      return math::Absolute( body_a_extent_position - body_b_extent_position);
    }

    //! @brief GetExtentPosition calculates the position of an extent for a defined axis for a coord::GeometryInterface
    //! @param BODY the coord::GeometryInterface for which the position of its extent in a given axis will be calculated
    //! @param AXIS is the RotationAxis for which the extent position will be calculated
    //! @return double which is the value of the origin in the axis "XYZ" plus one half the extent of BODY in that
    //!         axis direction
    double BodyExtentPositionAgreement::GetExtentPosition( const coord::GeometryInterface &BODY, const coord::Axis &AXIS) const
    {
//      return BODY.GetOrigin()( XYZ) + BODY.GetExtent( XYZ) / 2;
        return BODY.GetExtent( AXIS);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &BodyExtentPositionAgreement::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &BodyExtentPositionAgreement::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_consensus_enrichment.h"

// includes from bcl - sorted alphabetically
#include "linal/bcl_linal_vector_operations.h"
#include "math/bcl_math_contingency_matrix.h"
#include "math/bcl_math_roc_curve.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &ConsensusEnrichment::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator
    //! @param WEIGHTS vector< double> containing weights to be used to calculate enrichment
    //! @return enrichment
    double ConsensusEnrichment::operator()( const linal::Vector< double> &WEIGHTS) const
    {
      storage::List< storage::Pair< double, bool> > classified_results;

      for
      (
        storage::Table< double>::const_iterator itr( m_ScoresRmsdTable.Begin()), itr_end( m_ScoresRmsdTable.End());
        itr != itr_end;
        ++itr
      )
      {
        const linal::Vector< double> scores( itr->Second().GetData());
        classified_results.PushBack
        (
          storage::Pair< double, bool>
          (
            scores * WEIGHTS,
            m_UnaryPredicate->operator()( itr->Second()( m_IndexEnrichmentCol))
          )
        );
      }

      classified_results.Sort
      (
        storage::PairBinaryPredicateFirst< double, bool>
        (
          util::BinaryFunctionSTLWrapper< std::less< double> >()
        )
      );

      const math::ROCCurve roc_curve( classified_results);
      switch( m_Property)
      {
        case e_Enrichment:
        {
          const double enrichment
          (
            roc_curve.ContingencyMatrixFraction
            (
              double( roc_curve.GetNumberActualPositives()) /
              double( roc_curve.GetNumberResults())
            ).GetEnrichment()
          );
          return util::IsDefined( enrichment) ? enrichment : 0.0;
        }
        case e_ROCIntegeral:
        {
          return roc_curve.Integral();
        }
        default:
        {
          return util::GetUndefinedDouble();
        }
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ConsensusEnrichment::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_ScoresRmsdTable   , ISTREAM);
      io::Serialize::Read( m_IndexEnrichmentCol, ISTREAM);
      io::Serialize::Read( m_UnaryPredicate    , ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &ConsensusEnrichment::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_ScoresRmsdTable   , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_IndexEnrichmentCol, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_UnaryPredicate    , OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_contact_order.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_histogram.h"
#include "math/bcl_math_running_average_sd.h"
#include "score/bcl_score_energy_distribution.h"
#include "storage/bcl_storage_table.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @param NORMALIZATION_TYPE type of contact order normalization used
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &ContactOrder::GetDefaultHistogramFilename( const contact::Order::NormalizationType &NORMALIZATION_TYPE)
    {
      // static string
      static const std::string s_default_histogram_filename[ contact::Order::s_NumberNormalizationType + 1] =
      {
        "", // nothing for absolute
        "contact_order_chain_relative_sses.histogram",
        "contact_order_chain_relative_sequence.histogram",
        "contact_order_chain_relative_sses_sqr.histogram",
        "contact_order_chain_relative_sequence_sqr.histogram",
        ""
      };

      // end
      return s_default_histogram_filename[ NORMALIZATION_TYPE];
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &ContactOrder::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "co_score");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ContactOrder::ContactOrder() :
      m_Normalize( false),
      m_Scheme(),
      m_HistogramFileName(),
      m_EnergyFunction(),
      m_ContactOrder( contact::Order::e_Absolute, "co", false)
    {
    }

    //! @brief default constructor
    //! @brief NORMALIZATION_TYPE normalization for contact order
    //! @param NORMALIZE flag to enable normalization
    //! @param SCHEME scheme to be used
    //! @param CACHE whether to cache neighbor list generation or not
    ContactOrder::ContactOrder
    (
      const contact::Order::NormalizationType NORMALIZATION_TYPE,
      const bool NORMALIZE,
      const std::string &SCHEME,
      const bool CACHE
    ) :
      m_Normalize( NORMALIZE),
      m_Scheme( SCHEME),
      m_HistogramFileName( GetDefaultHistogramFilename( NORMALIZATION_TYPE)),
      m_EnergyFunction(),
      m_ContactOrder( NORMALIZATION_TYPE, "co", CACHE)
    {
      // read energy function
      ReadEnergyFunction();
    }

    //! @brief virtual copy constructor
    ContactOrder *ContactOrder::Clone() const
    {
      return new ContactOrder( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ContactOrder::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ContactOrder::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief returns filename of the histogram being used
    //! @return filename of the histogram being used
    const std::string &ContactOrder::GetHistogramFilename() const
    {
      return m_HistogramFileName;
    }

    //! @brief returns the energy function
    //! @return energy function
    const util::ShPtr< math::CubicSplineDamped> &ContactOrder::GetEnergyFunction() const
    {
      return m_EnergyFunction;
    }

    //! @brief get a more readable score scheme
    //! @return a more readable score scheme
    const std::string &ContactOrder::GetReadableScheme() const
    {
      static const std::string s_readable_scheme( "Contact order");
      return s_readable_scheme;
    }

    //! @brief get score type
    //! @return score type
    ProteinModel::Type ContactOrder::GetType() const
    {
      return ProteinModel::e_Structure;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of radius of gyration for the given ProteinModel
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return the score of radius of gyration for the given ProteinModel
    double ContactOrder::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // if there is a single chain in the model
      if( PROTEIN_MODEL.GetChains().GetSize() == 1)
      {
        // then use the operator to calculate the contact order
        double rel_co( m_ContactOrder( PROTEIN_MODEL));

        // score the co
        double score( m_EnergyFunction->operator ()( rel_co));

        // normalize
        if( !m_Normalize)
        {
          score *= PROTEIN_MODEL.GetNumberAAs();
        }

        // end
        return score;
      }

      // if more than one chain, we need to iterate one by one over the chains and score them individually
      // initialize score
      double score( 0);

      // iterate over chains
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator itr( PROTEIN_MODEL.GetChains().Begin()),
        itr_end( PROTEIN_MODEL.GetChains().End());
        itr != itr_end;
        ++itr
      )
      {
        // calculate the contact order
        double rel_co( m_ContactOrder.ContactOrder( **itr));

        // score for chain
        double current_score( m_EnergyFunction->operator ()( rel_co));

        // normalize
        if( !m_Normalize)
        {
          current_score *= ( *itr)->GetNumberAAs();
        }

        // sum up the score
        score += current_score;
      }

      // end
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ContactOrder::GetSerializer() const
    {
      io::Serializer serial( m_ContactOrder.GetSerializer());
      serial.SetClassDescription
      (
        "Measure of locality of protein contacts, see https://en.wikipedia.org/wiki/Contact_order "
        "Higher values indicate more non-local structure"
      );
      serial.AddInitializer
      (
        "normalize",
        "True - score will be independent of the size of the protein. "
        "false - the score is multiplied by the number of AAs",
        io::Serialization::GetAgent( &m_Normalize),
        "false"
      );
      return serial;
    }

    //! @brief Set the members of this property from the given LABEL
    //! @param LABEL the label to parse
    //! @param ERR_STREAM stream to write out errors to
    bool ContactOrder::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
    {
      if( !m_ContactOrder.ReadInitializerSuccessHook( LABEL, ERR_STREAM))
      {
        return false;
      }
      m_HistogramFileName = GetDefaultHistogramFilename( m_ContactOrder.GetNormalization());
      ReadEnergyFunction();
      return true;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief generate histograms from a table of relative contact orders
    //! @param TABLE each col is a relative contact order
    //! @return Map of col names and histograms
    storage::Map< std::string, math::Histogram> ContactOrder::HistogramsFromColumns( const storage::Table< double> &TABLE)
    {
      storage::Vector< math::RunningAverageSD< double> > mean_sd( TABLE.GetHeader().GetSize());

      // iterate over rows
      for( storage::Table< double>::const_iterator itr( TABLE.Begin()), itr_end( TABLE.End()); itr != itr_end; ++itr)
      {
        // iterate over cols
        for( size_t i( 0), i_max( mean_sd.GetSize()); i < i_max; ++i)
        {
          if( util::IsDefined( itr->Second()( i)))
          {
            mean_sd( i) += itr->Second()( i);
          }
        }
      }

      storage::Vector< math::Histogram> histograms;

      const size_t nr_bins( 30);
      // iterate over mean sd
      for( size_t i( 0), i_max( mean_sd.GetSize()); i < i_max; ++i)
      {
        // binsize and start
        const double binsize( mean_sd( i).GetStandardDeviation() / ( nr_bins / 6));
        const double start( 0.0);

        histograms.PushBack( math::Histogram( start, binsize, nr_bins));
      }

      // iterate over rows
      for( storage::Table< double>::const_iterator itr( TABLE.Begin()), itr_end( TABLE.End()); itr != itr_end; ++itr)
      {
        // iterate over cols
        for( size_t i( 0), i_max( mean_sd.GetSize()); i < i_max; ++i)
        {
          histograms( i).PushBack( itr->Second()( i));
        }
      }

      // fill histograms into map
      storage::Map< std::string, math::Histogram> histogram_map;

      // iterate over histograms
      for( size_t i( 0), i_max( histograms.GetSize()); i < i_max; ++i)
      {
        histogram_map[ TABLE.GetHeader()( i)] = histograms( i);
      }

      // end
      return histogram_map;
    }

    //! @brief read energy function for scoring radius of gyration
    void ContactOrder::ReadEnergyFunction()
    {
      // initialize read
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      // read histogram and reset the stream
      math::Histogram rel_co_histogram;
      read >> rel_co_histogram;
      io::File::CloseClearFStream( read);

      // remove unnecessary bins
      BCL_MessageDbg( util::Format()( rel_co_histogram));
      rel_co_histogram.RemoveBinsAfterIndex( rel_co_histogram.GetIndexOfLastInformationContainingBin());
      BCL_MessageDbg( util::Format()( rel_co_histogram));
      rel_co_histogram.RemoveBinsBeforeIndex( rel_co_histogram.GetIndexOfFirstInformationContainingBin());
      BCL_MessageDbg( util::Format()( rel_co_histogram));
      if( rel_co_histogram.GetHistogram().IsEmpty())
      {
        return;
      }
      rel_co_histogram.SetCount( 0, rel_co_histogram.GetHistogram()( 1) / 2);

      // create a cubic spline from the histogram and store it in the data member m_EnergyFunction
      m_EnergyFunction =
        util::ShPtr< math::CubicSplineDamped>
        (
          new math::CubicSplineDamped
          (
            EnergyDistribution::GeneratePotentialFromHistogram
            (
              rel_co_histogram, 1.0, math::e_FirstDer, storage::Pair< double, double>( 0.0, 0.0)
            )
          )
        );
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score.h"

// includes from bcl - sorted alphabetically
#include "bcl_version.h"
#include "command/bcl_command_app_default_flags.h"
#include "command/bcl_command_command_state.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "command/bcl_command_parameter_check_file_in_search_path.h"
#include "util/bcl_util_runtime_environment_interface.h"

// external includes - sorted alphabetically

//path for histograms to calculate energy functions
#if defined (__MINGW32__)
  #define BCL_HISTOGRAM_PATH "histogram/"
#elif defined (__GNUC__)
  #define BCL_HISTOGRAM_PATH "/dors/meilerlab/apps/bcl/histograms/rev_5265/"
#elif defined (_MSC_VER)
  #define BCL_HISTOGRAM_PATH "../../../histogram/"
#endif

namespace bcl
{
  namespace score
  {

    //! flag to change histogram path
    util::ShPtr< command::FlagInterface> &GetHistogramPathFlag()
    {
      static util::ShPtr< command::FlagInterface> s_histogram_path_flag
      (
        new command::FlagStatic
        (
          "histogram_path",
          "change path for reading and writing histograms for scores",
          command::Parameter
          (
            "path",
            "relative or absolute path",
            command::ParameterCheckFileInSearchPath
            (
              "histogram",
              Score::GetDefaultHistogramPath(),
              io::Directory::e_Dir
            ),
            ""
          )
        )
      );

      return s_histogram_path_flag;
    }

    //! @brief get the default histogram path
    //! @return the default histogram path - depending on release vs license vs normal
    const std::string &Score::GetDefaultHistogramPath()
    {
      static const std::string s_default_histogram_path
      (
        GetVersion().IsLicense() ? GetVersion().GetInstallPrefix() + "/histogram/" : std::string( BCL_HISTOGRAM_PATH)
      );

      return s_default_histogram_path;
    }

    //! @brief enum, that adds histogram params flag to default app flags
    static const util::ShPtr< command::FlagInterface> e_HistogramPathFlag
    (
      command::GetAppDefaultFlags().AddDefaultFlag( GetHistogramPathFlag(), command::e_Score)
    );

    //! @brief identifier for the name space
    //! @return the name of the namespace
    const std::string &GetNamespaceIdentifier()
    {
      static const std::string *s_namespace_name( new std::string( util::ExtractNamespaceIdentifier( __PRETTY_FUNCTION__)));
      return *s_namespace_name;
    }

    //! @brief given a FILENAME, the histogram path is prepended to the filename
    //! @param FILENAME the filename to a histogram that is used in one of the scores
    //! @return string with histogrampath/FILENAME
    std::string Score::AddHistogramPath( const std::string &FILENAME)
    {
      if( command::CommandState::IsInStaticInitialization())
      {
        return "histogram/" + FILENAME;
      }
      static const std::string s_hist_dir
      (
        GetHistogramPathFlag()->GetFlag()
        ? GetHistogramPathFlag()->GetFirstParameter()->GetValue()
        : command::ParameterCheckFileInSearchPath
        (
          "histogram",
          Score::GetDefaultHistogramPath(),
          io::Directory::e_Dir
        ).FindFile( "")
      );
      const std::string resolved_filename
      (
        util::GetRuntimeEnvironment().ResolveFileName( s_hist_dir + FILENAME)
      );

      BCL_Assert
      (
        !resolved_filename.empty(),
        "unable to resolve filename: " + GetHistogramPathFlag()->GetFirstParameter()->GetValue() + FILENAME
      );

      return resolved_filename;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_bipolar.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "math/bcl_math_statistics.h"
#include "restraint/bcl_restraint_data_set_pairwise.h"
#include "restraint/bcl_restraint_locator_coordinates_first_side_chain_atom.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseBipolar::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseBipolar())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseBipolar::GetDefaultScheme()
    {
      static const std::string s_scheme( "bipolar");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    DataSetPairwiseBipolar::DataSetPairwiseBipolar( const std::string &SCHEME) :
      m_Data(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking pool
    //! @param SSE_POOL the pool the sse definitions will come from
    //! @param SCHEME optional scheme
    DataSetPairwiseBipolar::DataSetPairwiseBipolar( const assemble::SSEPool &SSE_POOL, const std::string &SCHEME) :
      m_Data(),
      m_Scheme( SCHEME)
    {
      m_Data = CalculateResiduePositionWeight( SSE_POOL);
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseBipolar
    DataSetPairwiseBipolar *DataSetPairwiseBipolar::Clone() const
    {
      return new DataSetPairwiseBipolar( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseBipolar::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseBipolar::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

      //! @brief calculate the score of a data set
      //! @param DATA data set to be scored
      //! @return the score of the current data set
      double DataSetPairwiseBipolar::operator()( const restraint::DataSetPairwise &DATA) const
      {
        if( DATA.IsEmpty())
        {
          return 0;
        }

        double score( 0);

        // to keep track of the number of restraint data points that are in each sse
        storage::Map< util::ShPtr< assemble::SSE>, storage::Pair< size_t, double> > sse_restraintcount;

        storage::Map
        <
          util::ShPtr< assemble::SSE>,
          storage::Map< util::ShPtr< assemble::SSE>, storage::Vector< double> >
        > sse_connectionweights;

        // iterate over the data pairs to score them
        for
        (
          restraint::DataSetPairwise::const_iterator itr( DATA.Begin()), itr_end( DATA.End());
          itr != itr_end;
          ++itr
        )
        {
          storage::Map
          <
            util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
            storage::Pair< double, util::ShPtr< assemble::SSE> >,
            assemble::LocatorAtomCoordinatesInterface::PtrResidueLessThan
          >::const_iterator resi_itr_a( m_Data.Find( itr->First()));

          storage::Map
          <
            util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
            storage::Pair< double, util::ShPtr< assemble::SSE> >,
            assemble::LocatorAtomCoordinatesInterface::PtrLessThan
          >::const_iterator resi_itr_b( m_Data.Find( itr->Second()));

          // if either residue could not found in the map
          if( resi_itr_a == m_Data.End() || resi_itr_b == m_Data.End())
          {
            ++score;
            continue;
          }

          // get the weights
          double weight_a( resi_itr_a->second.First());
          double weight_b( resi_itr_b->second.First());

          // optimal score here is zero, since that would mean the two residues are on the same position along their sse
          // relative to the membrane
          double current_score( math::Absolute( weight_a - weight_b));

          // want the residues to be away from the middle of their sses
          current_score += ( 1 - math::Absolute( weight_a - 0.5) - math::Absolute( weight_b - 0.5));

          // score goes from 0 to one at this point with 0 being best
          current_score /= double( 2);

          // add score to total score
          score += current_score;

          // add connection information
          sse_connectionweights[ resi_itr_a->second.Second()][ resi_itr_b->second.Second()].PushBack( weight_a + weight_b);
          sse_connectionweights[ resi_itr_b->second.Second()][ resi_itr_a->second.Second()].PushBack( weight_a + weight_b);

          // add count for the sses the two residues are in
          { // residue a
            storage::Map< util::ShPtr< assemble::SSE>, storage::Pair< size_t, double> >::const_iterator sse_itr
            (
              sse_restraintcount.Find( resi_itr_a->second.Second())
            );
            if( sse_itr != sse_restraintcount.End())
            {
              ++sse_restraintcount[ resi_itr_a->second.Second()].First();
              sse_restraintcount[ resi_itr_a->second.Second()].Second() += weight_a;
            }
            else
            {
              sse_restraintcount[ resi_itr_a->second.Second()].First() = 1;
              sse_restraintcount[ resi_itr_a->second.Second()].Second() = weight_a;
            }
          }
          { // residue b
            storage::Map< util::ShPtr< assemble::SSE>, storage::Pair< size_t, double> >::const_iterator sse_itr
            (
              sse_restraintcount.Find( resi_itr_b->second.Second())
            );
            if( sse_itr != sse_restraintcount.End())
            {
              ++sse_restraintcount[ resi_itr_b->second.Second()].First();
              sse_restraintcount[ resi_itr_b->second.Second()].Second() += weight_b;
            }
            else
            {
              sse_restraintcount[ resi_itr_b->second.Second()].First() = 1;
              sse_restraintcount[ resi_itr_b->second.Second()].Second() = weight_b;
            }
          }
        }

        score /= double( DATA.GetSize());

        // subtract one so best score will be -1 taking into account residues being towards end of sses and being on
        // the same side of the membrane. Does not take into account wanting residues within an sse to be on opposite
        // sides
        --score;

        double opposite_ends_score( 0);
        // iterate over the map of sses and the counts of datapoints and total residue weight in each sse
        for
        (
          storage::Map< util::ShPtr< assemble::SSE>, storage::Pair< size_t, double> >::const_iterator
            sse_itr( sse_restraintcount.Begin()), sse_itr_end( sse_restraintcount.End());
          sse_itr != sse_itr_end;
          ++sse_itr
        )
        {
          // count of data points in the current sse
          const size_t count( sse_itr->second.First());

          // sum of the residue weights of data points that are in the sse
          const double weight( sse_itr->second.Second());

          // calculate average weight
          const double average_weight( weight / double( count));

          // since weights of residues within sses go from 0 to 1, and we want residues to be on opposite sides of the
          // sse, optimal average weight is 0.5 i.e. every other data point has weight zero and every other data point
          // has weight 1
          // multiply by two so that it goes between 0 and 1
          opposite_ends_score += ( math::Absolute( average_weight - 0.5));
        }
        // this makes it go from 0 to 1 with 0 being best and 1 being worst
        opposite_ends_score = 2 * opposite_ends_score / double( sse_restraintcount.GetSize());

        // subtract one so score goes from -1 to 0
        --opposite_ends_score;

        // iterate over the connection information
        double total_connection_score( 0);
        size_t pair_count( 0);
        for
        (
          storage::Map
          <
            util::ShPtr< assemble::SSE>,
            storage::Map< util::ShPtr< assemble::SSE>, storage::Vector< double> >
          >::const_iterator sse_itr( sse_connectionweights.Begin()), sse_itr_end( sse_connectionweights.End());
          sse_itr != sse_itr_end;
          ++sse_itr
        )
        {
          const storage::Map< util::ShPtr< assemble::SSE>, storage::Vector< double> > &map_b( sse_itr->second);
          for
          (
            storage::Map< util::ShPtr< assemble::SSE>, storage::Vector< double> >::const_iterator
              sse_itr_b( map_b.Begin()), sse_itr_b_end( map_b.End());
            sse_itr_b != sse_itr_b_end;
            ++sse_itr_b
          )
          {
            const storage::Vector< double> &weights( sse_itr_b->second);
            const double weight_sum( math::Statistics::Sum( weights.Begin(), weights.End()));

            // divide the weightsum by the number of residues in it (i.e. 2 * the number of restraints)
            // optimal score is 0.5 so subtract the average restraint weight from 0.5
            // 0.5 is optimal since that would mean if you have two restraints involving four residues,
            // they would be on opposite sides of the sse (0 - 0, 1 - 1; 0 + 0 + 1 + 1 = 2; 2 / 2*2 = 0.5)
            const double current_score( math::Absolute( ( weight_sum / ( 2.0 * double( weights.GetSize()))) - 0.5));
            total_connection_score += current_score;
            ++pair_count;
          }
        }
        // since everything was entered in the map symmetrically by sse (i.e. twice) the scores are effectively
        // multiplied by 2, making them go from 0 to 1 with zero being best
        // divide by half the pair count and it will go between 0 and 1
        total_connection_score /= ( double( pair_count) / 2.0);
        // subtract 1 so it goes between -1 and 0
        --total_connection_score;

        // average scores
        score = ( 4 * score + opposite_ends_score + total_connection_score) / 6.0;

        return score;
      }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseBipolar::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Data, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseBipolar::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Data, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculates the weight of every residue in helical sses according to its position relative to the ends
    //!        The residue weights go from 0 to 1 along an sse. The end of the sse that has a 0 and the end that has
    //!        a 1 doesn't matter, as long as it is consistent for all sses (which it is). The weights are calculated
    //!        such that the ends of sses that are on the same side of the membrane have the same weight, and the
    //!        weight of residues along sses is the same for each sse as it goes from one side of the membrane to the
    //!        other.
    //! @param SSE_POOL the pool of sses that will be used to calculate the weights
    //! @return map that has for every residue in helical sses the weight associated according to its position relative
    //!         to the end of the sse
    storage::Map
    <
      util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, storage::Pair< double, util::ShPtr< assemble::SSE> >,
      assemble::LocatorAtomCoordinatesInterface::PtrResidueLessThan
    > DataSetPairwiseBipolar::CalculateResiduePositionWeight( const assemble::SSEPool &SSE_POOL)
    {
      // the sses from the pool
      storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> sses
      (
        SSE_POOL.GetRandomNonOverlappingSet()
      );

      // map to hold the residues and their weights
      storage::Map
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, storage::Pair< double, util::ShPtr< assemble::SSE> >,
        assemble::LocatorAtomCoordinatesInterface::PtrResidueLessThan
      > residue_weights;

      // keep track of if the nterminus should be weighted as 0 or 1, since it is assumed the sses alternatively
      // go through the membrane every other n-terminus of an sse will have a 0, and every other will be weight 1.
      size_t n_terminus( 0);

      // iterate through the sses
      for
      (
        storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr( sses.Begin()), sse_itr_end( sses.End());
          sse_itr != sse_itr_end;
          ++sse_itr
      )
      {
        // true if the sse is not helix, go to next sse
        if( ( *sse_itr)->GetType() != biol::GetSSTypes().HELIX)
        {
          continue;
        }

        // for keeping track of what sse each aa is in
        const util::ShPtr< assemble::SSE> sse_copy( ( *sse_itr)->Clone());

        // iterate over the residues of the sse to assign their weights
        for
        (
          biol::AASequence::const_iterator aa_itr( ( *sse_itr)->Begin()), aa_itr_end( ( *sse_itr)->End());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {

          util::ShPtr< assemble::LocatorAtomCoordinatesInterface> current_resi
          (
            new restraint::LocatorCoordinatesFirstSideChainAtom( ( *aa_itr)->GetChainID(), ( *aa_itr)->GetSeqID())
          );

          const bool nterminus_bool( n_terminus % 2);
          const double weight( CalculateWeight( **sse_itr, **aa_itr, nterminus_bool));

          bool success
          (
            residue_weights.Insert
            (
              std::pair
              <
                util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
                storage::Pair< double, util::ShPtr< assemble::SSE> >
              >
              (
                current_resi, storage::Pair< double, util::ShPtr< assemble::SSE> >( weight, sse_copy)
              )
            ).second
          );

          BCL_Assert( success, "was not able to insert residue " + current_resi->GetIdentification());
        }

        ++n_terminus;
      }

      return residue_weights;
    }

    //! @brief calculates the weight of the given residue according to its position away from the end of the given sse
    //! @param SSE the sse whose ends will be used to calculate the weight
    //! @param AA_BASE the residue of interest whose weight will be calculated
    //! @param N_TERMINUS indicates true if nterminus of the sse should have the largest weight - otherwise cterminus
    //! @return double which is the weight of the residue
    double DataSetPairwiseBipolar::CalculateWeight( const assemble::SSE &SSE, const biol::AABase &AA_BASE, const bool N_TERMINUS)
    {
      double aa_resi_num( AA_BASE.GetSeqID());
      double weight( double( aa_resi_num - SSE.GetFirstAA()->GetSeqID()) / double( SSE.GetSize() - 1));
      if( N_TERMINUS)
      {
        weight = double( 1) - weight;
      }

      return weight;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_coordinate_exclusion.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "restraint/bcl_restraint_data_set_pairwise.h"
#include "util/bcl_util_string_functions.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseCoordinateExclusion::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseCoordinateExclusion())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseCoordinateExclusion::GetDefaultScheme()
    {
      static const std::string s_scheme( "exclusion");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseCoordinateExclusion::DataSetPairwiseCoordinateExclusion( const std::string &SCHEME) :
      m_Radius(),
      m_DistanceMap(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking members
    //! @param EXCLUSION_RADIUS data with atoms inside this radius of any exclusion coordinates will be penalized
    //! @param READ the stream the coordinates will be read from
    //! @param X_COORD_COLUMN column in istream that has the x-coordinate - columns start at 0
    //! @param Y_COORD_COLUMN column in istream that has the y-coordinate - columns start at 0
    //! @param Z_COORD_COLUMN column in istream that has the z-coordinate - columns start at 0
    //! @param ALL_POSSIBLE_DATA_POINTS the set of data points that should be subjected to this filter
    //! @param ENSEMBLE ensemble for which coordinates will be checked to make sure they aren't near exclusion coords
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseCoordinateExclusion::DataSetPairwiseCoordinateExclusion
    (
      const double &EXCLUSION_RADIUS,
      std::istream &READ,
      const size_t X_COORD_COLUMN,
      const size_t Y_COORD_COLUMN,
      const size_t Z_COORD_COLUMN,
      const storage::Set
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
        assemble::LocatorAtomCoordinatesInterface::PtrLessThan
      > &ALL_POSSIBLE_DATA_POINTS,
      const assemble::ProteinEnsemble &ENSEMBLE,
      const std::string &SCHEME
    ) :
      m_Radius( EXCLUSION_RADIUS),
      m_DistanceMap(),
      m_Scheme( SCHEME)
    {
      m_DistanceMap =
        FillDistanceMap( READ, X_COORD_COLUMN, Y_COORD_COLUMN, Z_COORD_COLUMN, ALL_POSSIBLE_DATA_POINTS, ENSEMBLE);
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseCoordinateExclusion
    DataSetPairwiseCoordinateExclusion *DataSetPairwiseCoordinateExclusion::Clone() const
    {
      return new DataSetPairwiseCoordinateExclusion( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseCoordinateExclusion::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseCoordinateExclusion::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseCoordinateExclusion::operator()( const restraint::DataSetPairwise &DATA) const
    {
      double score( 0);

      // iterate through the data set
      for
      (
        restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
        data_itr != data_itr_end;
        ++data_itr
      )
      {
        // calculate exclusion scores for each data point
        const double score_first( CalculateExclusionScore( data_itr->First(), m_DistanceMap, m_Radius));
        const double score_second( CalculateExclusionScore( data_itr->Second(), m_DistanceMap, m_Radius));

        // true if the first data point is defined
        if( util::IsDefined( score_first))
        {
          score += score_first;
        }

        // true if the second data point is defined
        if( util::IsDefined( score_second))
        {
          score += score_second;
        }
      }

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseCoordinateExclusion::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Radius, ISTREAM);
      io::Serialize::Read( m_DistanceMap, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseCoordinateExclusion::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Radius, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_DistanceMap, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief fills the distance map of undesirable coordinates by calculating the distance between a set of data
    //!        points and undesirable coordinates that are read in from an istream.
    //! @param READ the stream from which undesirable coordinates will be read
    //! @param X_COORD_COLUMN the column the x coordinate are in - starts at 0
    //! @param Y_COORD_COLUMN the column the y coordinate are in - starts at 0
    //! @param Z_COORD_COLUMN the column the z coordinate are in - starts at 0
    //! @param ALL_POSSIBLE_DATA_POINTS the data points that should be subjected to this score
    //! @param ENSEMBLE the protein models for which distances will be calculated
    //! @return distance map of data point to vector of mean sd info calculated from ENSEMBLE from that data point to
    //!         each excluded coordinate
    DataSetPairwiseCoordinateExclusion::DistanceMap DataSetPairwiseCoordinateExclusion::FillDistanceMap
    (
      std::istream &READ,
      const size_t X_COORD_COLUMN,
      const size_t Y_COORD_COLUMN,
      const size_t Z_COORD_COLUMN,
      const storage::Set
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
        assemble::LocatorAtomCoordinatesInterface::PtrLessThan
      > &ALL_POSSIBLE_DATA_POINTS,
      const assemble::ProteinEnsemble &ENSEMBLE
    )
    {
      // get the exclusion coordinate from the stream
      const storage::List< linal::Vector3D> exclusion_coordinates
      (
        ReadCoordinates( READ, X_COORD_COLUMN, Y_COORD_COLUMN, Z_COORD_COLUMN)
      );

      // locate the coordinates of data points for each model
      storage::Map
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, //< data points
        storage::Vector< linal::Vector3D>, //< coodinates for each model
        assemble::LocatorAtomCoordinatesInterface::PtrLessThan
      > coordinate_map( LocateCoordinates( ALL_POSSIBLE_DATA_POINTS, ENSEMBLE));

      return CalculateAverageDistanceToExcludedCoordinates( coordinate_map, exclusion_coordinates);
    }

    //! @brief gives list of coordinates read from an istream
    //! @param READ the stream from which undesirable coordinates will be read
    //! @param X_COORD_COLUMN the column the x coordinate are in - starts at 0
    //! @param Y_COORD_COLUMN the column the y coordinate are in - starts at 0
    //! @param Z_COORD_COLUMN the column the z coordinate are in - starts at 0
    //! @return list of Vector3D which are the coordinates read from a file
    storage::List< linal::Vector3D> DataSetPairwiseCoordinateExclusion::ReadCoordinates
    (
      std::istream &READ,
      const size_t X_COORD_COLUMN,
      const size_t Y_COORD_COLUMN,
      const size_t Z_COORD_COLUMN
    )
    {
      // get the coord list from the file
      const storage::Vector< storage::Vector< std::string> >
        coord_lines( util::SplittedStringLineListFromIStream( READ));

      storage::List< linal::Vector3D> coordinates;

      // iterate through the lines to extract coordinates and build the coordinate list
      for
      (
        storage::Vector< storage::Vector< std::string> >::const_iterator
          itr( coord_lines.Begin()), itr_end( coord_lines.End());
        itr != itr_end; ++itr
      )
      {
        // get x, y, z coordinates
        const double x_coord( util::ConvertStringToNumericalValue< double>( itr->operator()( X_COORD_COLUMN)));
        const double y_coord( util::ConvertStringToNumericalValue< double>( itr->operator()( Y_COORD_COLUMN)));
        const double z_coord( util::ConvertStringToNumericalValue< double>( itr->operator()( Z_COORD_COLUMN)));

        // add vector to coordinates
        const linal::Vector3D coord( x_coord, y_coord, z_coord);
        coordinates.PushBack( coord);
      }

      return coordinates;
    }

    //! @brief locates coordinates for a set of locators for an ensemble of proteins
    //! @param ALL_POSSIBLE_DATA_POINTS the data points whose coordinates will be located
    //! @param ENSEMBLE the protein models from which coordinates will be found
    //! @return map of locator to its associated vector or coordinates, one coordinate for each model in the ensemble
    storage::Map
    <
      util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
      storage::Vector< linal::Vector3D>,
      assemble::LocatorAtomCoordinatesInterface::PtrLessThan
    > DataSetPairwiseCoordinateExclusion::LocateCoordinates
    (
      const storage::Set
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
        assemble::LocatorAtomCoordinatesInterface::PtrLessThan
      > &ALL_POSSIBLE_DATA_POINTS,
      const assemble::ProteinEnsemble &ENSEMBLE
    )
    {
      // map to hold the located coordinates of the ensemble
      storage::Map
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
        storage::Vector< linal::Vector3D>,
        assemble::LocatorAtomCoordinatesInterface::PtrLessThan
      > coord_map;

      // iterate through the data points
      for
      (
        storage::Set
        <
          util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
          assemble::LocatorAtomCoordinatesInterface::PtrLessThan
        >::const_iterator data_itr( ALL_POSSIBLE_DATA_POINTS.Begin()), data_itr_end( ALL_POSSIBLE_DATA_POINTS.End());
        data_itr != data_itr_end;
        ++data_itr
      )
      {
        // add the current locator to the distance map
        std::pair< storage::Map
          <
            util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
            storage::Vector< linal::Vector3D>,
            assemble::LocatorAtomCoordinatesInterface::PtrLessThan
          >::iterator, bool> insert_status
        (
          coord_map.Insert
          (
            std::pair< util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, storage::Vector< linal::Vector3D> >
            (
              *data_itr, storage::Vector< linal::Vector3D>()
            )
          )
        );

        // make sure data point can be inserted
        BCL_Assert( insert_status.second, "could not insert " + ( *data_itr)->GetIdentification());

        // iterate through the ensemble to calculate the coordinates and fill coordinate map
        for
        (
          assemble::ProteinEnsemble::const_iterator ensemble_itr( ENSEMBLE.Begin()), ensemble_itr_end( ENSEMBLE.End());
          ensemble_itr != ensemble_itr_end;
          ++ensemble_itr
        )
        {
          // locate coordinate
          const linal::Vector3D current_coords( ( *data_itr)->Locate( **ensemble_itr));

          // true if coordinate could not be found
          if( !current_coords.IsDefined())
          {
            // go to next protein model
            continue;
          }

          // add the current coords to the coordinate map
          insert_status.first->second.PushBack( current_coords);
        }
      }

      return coord_map;
    }

    //! @brief calculates the mean and sd info for data points distances to exclusion coordinates
    //! @param COORDINATE_MAP map of locator to associated vector of coords; 1 coord for each model in the ensemble
    //! @param EXCLUSION_COORDINATES list of coordinates which will be used to calculate distances to them
    //! @return distance map of data point to vector of mean sd info calculated from ENSEMBLE from that data point to
    //!         each excluded coordinate
    DataSetPairwiseCoordinateExclusion::DistanceMap
    DataSetPairwiseCoordinateExclusion::CalculateAverageDistanceToExcludedCoordinates
    (
      const storage::Map
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
        storage::Vector< linal::Vector3D>,
        assemble::LocatorAtomCoordinatesInterface::PtrLessThan
      > &COORDINATE_MAP,
      const storage::List< linal::Vector3D> &EXCLUSION_COORDINATES
    )
    {
      DistanceMap distance_map;

      // iterate through the coordinate map
      for
      (
        storage::Map
        <
          util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
          storage::Vector< linal::Vector3D>,
          assemble::LocatorAtomCoordinatesInterface::PtrLessThan
        >::const_iterator locator_itr( COORDINATE_MAP.Begin()), locator_itr_end( COORDINATE_MAP.End());
        locator_itr != locator_itr_end;
        ++locator_itr
      )
      {
        // the current vector of coordinates for the current atom
        const storage::Vector< linal::Vector3D> &coords( locator_itr->second);

        if( coords.IsEmpty())
        {
          continue;
        }

        // add the current locator to the distance map
        std::pair< storage::Map
          <
            util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
            storage::Vector< math::RunningAverageSD< double> >,
            assemble::LocatorAtomCoordinatesInterface::PtrLessThan
          >::iterator, bool> insert_status
        (
          distance_map.Insert
          (
            std::pair
            <
              util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, storage::Vector< math::RunningAverageSD< double> >
            >
            (
              locator_itr->first, storage::Vector< math::RunningAverageSD< double> >()
            )
          )
        );

        // make sure the data point could be inserted
        BCL_Assert( insert_status.second, "could not insert " + locator_itr->first->GetIdentification());

        // iterate through the excluded coordinates
        for
        (
          storage::List< linal::Vector3D>::const_iterator
            excluded_itr( EXCLUSION_COORDINATES.Begin()), excluded_itr_end( EXCLUSION_COORDINATES.End());
          excluded_itr != excluded_itr_end;
          ++excluded_itr
        )
        {
          const linal::Vector3D &exclusion_coord( *excluded_itr);

          // true if the excluded coordinate is undefined
          if( !exclusion_coord.IsDefined())
          {
            continue;
          }

          // to keep track of ensemble average distance to current exclusion coordinate
          math::RunningAverageSD< double> mean_sd;

          // iterate through the coordinates of the current locator of the ensemble to calculate average distance to
          // excluded coordinate
          for
          (
            storage::Vector< linal::Vector3D>::const_iterator coord_itr( coords.Begin()), coord_itr_end( coords.End());
            coord_itr != coord_itr_end;
            ++coord_itr
          )
          {
            const linal::Vector3D &coord( *coord_itr);

            // true if the coordinate is undefined
            if( !coord.IsDefined())
            {
              continue;
            }

            // calculate current distance between data point coord and exclusion coord
            const double current_distance( linal::Distance( coord, exclusion_coord));

            // true if the current distance is defined
            if( util::IsDefined( current_distance))
            {
              // add the distance to the considered distances
              mean_sd += current_distance;
            }
          } //< iterate through coordinates of current locator

          // add the average distance to the distance map
          insert_status.first->second.PushBack( mean_sd);
        } //< iterate through excluded coordinates
      } //< iterate through the data point locators

      return distance_map;
    }

    //! @brief for a given data point, calculates the score it has according to its distance from exclusion points
    //! @param LOCATOR the data point whose score will be calculated
    //! @param DISTANCE_MAP map of data point to vector of mean sd info calculated from ENSEMBLE from that data point
    //!        to each excluded coordinate
    //! @param RADIUS if either component of data pair is within this radius the data pair will be scored unfavorably
    //! @return double which is the score of LOCATOR according to its distances from exclusion coordinates
    double DataSetPairwiseCoordinateExclusion::CalculateExclusionScore
    (
      const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR,
      const DistanceMap &DISTANCE_MAP,
      const double RADIUS
    )
    {
      // try to find the datapoint in the distance map
      DistanceMap::const_iterator itr_first( DISTANCE_MAP.Find( LOCATOR));

      // true if the data point is not found in the exposure map
      if( itr_first == DISTANCE_MAP.End())
      {
        return util::GetUndefinedDouble();
      }

      // initialize score to zero
      double score( 0);

      // iterate through the distance statistics of the locator for all coordinate exclusions
      for
      (
        storage::Vector< math::RunningAverageSD< double> >::const_iterator
          stats_itr( itr_first->second.Begin()), stats_itr_end( itr_first->second.End());
        stats_itr != stats_itr_end;
        ++stats_itr
      )
      {
        const double distance_mean( stats_itr->GetAverage());

        // distance_mean should be greater than m_Radius - give penalty if it is not above the cutoff
        const double current_score( distance_mean > RADIUS ? 0 : RADIUS - distance_mean);

        // add current score to score
        score += current_score;
      }

      return score;
    }

  } // namespace score
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_coordinate_triangulation.h"

// includes from bcl - sorted alphabetically
#include "restraint/bcl_restraint_data_set_pairwise.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseCoordinateTriangulation::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseCoordinateTriangulation())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseCoordinateTriangulation::GetDefaultScheme()
    {
      static const std::string s_scheme( "triangulation");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseCoordinateTriangulation::DataSetPairwiseCoordinateTriangulation( const std::string &SCHEME) :
      m_RadiusCutoff(),
      m_Ensemble(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking members
    //! @param RADIUS_CUTOFF coordinates are considered far enough apart when above this distance
    //! @param ENSEMBLE ensemble for which exposures will be calculated
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseCoordinateTriangulation::DataSetPairwiseCoordinateTriangulation
    (
      const double &RADIUS_CUTOFF,
      const util::ShPtr< assemble::ProteinEnsemble> &ENSEMBLE,
      const std::string &SCHEME
    ) :
      m_RadiusCutoff( RADIUS_CUTOFF),
      m_Ensemble( ENSEMBLE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseCoordinateTriangulation
    DataSetPairwiseCoordinateTriangulation *DataSetPairwiseCoordinateTriangulation::Clone() const
    {
      return new DataSetPairwiseCoordinateTriangulation( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseCoordinateTriangulation::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseCoordinateTriangulation::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseCoordinateTriangulation::operator()( const restraint::DataSetPairwise &DATA) const
    {
      // initialize score to zero
      double score( 0);

      // will hold the data points that have already been used to help determine which new ones should be added
      storage::Set
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, assemble::LocatorAtomCoordinatesInterface::PtrLessThan
      > used_atoms;

      // iterate through the data set
      for
      (
        restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
        data_itr != data_itr_end;
        ++data_itr
      )
      {
        // check if the data pair is usable
        const bool usable_a_a( UsableLocator( used_atoms, *m_Ensemble, data_itr->First(), m_RadiusCutoff));
        const bool usable_a_b( UsableLocator( used_atoms, *m_Ensemble, data_itr->Second(), m_RadiusCutoff));

        // true if either aa or ab are not usable
        if( !usable_a_a || !usable_a_b)
        {
          // increment the score and go to next iteration
          ++score;
          continue;
        }

        // iterate through dataset again
        for
        (
          restraint::DataSetPairwise::const_iterator data_itr_b( ++restraint::DataSetPairwise::const_iterator( data_itr));
          data_itr_b != data_itr_end;
          ++data_itr_b
        )
        {
          // check if the data pair is usable
          const bool usable_b_a( UsableLocator( used_atoms, *m_Ensemble, data_itr_b->First(), m_RadiusCutoff));
          const bool usable_b_b( UsableLocator( used_atoms, *m_Ensemble, data_itr_b->Second(), m_RadiusCutoff));

          // true if either ba or bb are not usable
          if( !usable_b_a || !usable_b_b)
          {
            // increment the score and go to next iteration
            ++score;
            continue;
          }
        }
      }

      // return score
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseCoordinateTriangulation::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_RadiusCutoff, ISTREAM);
      io::Serialize::Read( m_Ensemble, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseCoordinateTriangulation::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_RadiusCutoff, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Ensemble, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief determines if a locator can be used or if one is already similar to it so don't use it
    //! @param USED_LOCATORS locators that already exist in a data set
    //! @param ENSEMBLE structures that will be used to determine average spatial proximity
    //! @param LOCATOR locator which will be checked to see if it can be used or not based on already used locators
    //! @param DISTANCE_THRESHOLD the minimum spatial distance allowed between LOCATOR and any other used locator
    bool DataSetPairwiseCoordinateTriangulation::UsableLocator
    (
      storage::Set
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, assemble::LocatorAtomCoordinatesInterface::PtrLessThan
      > &USED_LOCATORS,
      const assemble::ProteinEnsemble &ENSEMBLE,
      const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR,
      const double DISTANCE_THRESHOLD
    )
    {
      // check to see if the locator_a is in used atoms
      storage::Set
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, assemble::LocatorAtomCoordinatesInterface::PtrLessThan
      >::const_iterator used_itr_a( USED_LOCATORS.Find( LOCATOR));

      // assume at first that LOCATOR can be used
      bool usable( true);

      // true if LOCATOR is not in used atoms
      if( used_itr_a == USED_LOCATORS.End())
      {
        // check to see if it is too close to one of the other atoms already in used_atoms
        // iterate through used atoms
        for
        (
          storage::Set
          <
            util::ShPtr< assemble::LocatorAtomCoordinatesInterface>,
            assemble::LocatorAtomCoordinatesInterface::PtrLessThan
          >::const_iterator
            used_itr( USED_LOCATORS.Begin()), used_itr_end( USED_LOCATORS.End());
          used_itr != used_itr_end;
          ++used_itr
        )
        {
          // calculate the mean and standard deviation of distances between LOCATOR and used_itr over models in ENSEMBLE
          const math::RunningAverageSD< double> mean_sd( ENSEMBLE.GetDistanceStatistics( restraint::DataPairwise( LOCATOR, *used_itr)));

          // get the mean distance between the used locator and the current locator
          const double distance_mean( mean_sd.GetWeight() > 0 ? mean_sd.GetAverage() : util::GetUndefinedDouble());

          // true if the two locators are on average too close or the distance mean is undefined
          if( distance_mean < DISTANCE_THRESHOLD || !util::IsDefined( distance_mean))
          {
            usable = false;
          }

          BCL_MessageDbg
          (
            "data pair distance " +
            restraint::DataPairwise( LOCATOR, *used_itr).GetIdentification() + " is " + util::Format()( distance_mean)
          );
          BCL_Assert( util::IsDefined( distance_mean) && !usable, "unusable but is defined");
        }

        // true if current locator is not close to any other used coordinates so far
        if( usable)
        {
          // insert the locator into the set of used data points
          BCL_Assert( USED_LOCATORS.Insert( LOCATOR).second, "could not insert " + LOCATOR->GetIdentification());
        }
      }

      // return bool indicating if the data point LOCATOR is usable or not
      return usable;
    }

  } // namespace score
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_data_density.h"

// includes from bcl - sorted alphabetically
#include "restraint/bcl_restraint_data_set_pairwise.h"
#include "util/bcl_util_sh_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseDataDensity::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseDataDensity())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseDataDensity::GetDefaultScheme()
    {
      static const std::string s_scheme( "data_density");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseDataDensity::DataSetPairwiseDataDensity( const std::string &SCHEME) :
      m_SequenceLength(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking scheme
    //! @param SEQUENCE_SIZE the sequence size the score will be normalized against
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseDataDensity::DataSetPairwiseDataDensity
    (
      const size_t SEQUENCE_SIZE, const std::string &SCHEME
    ) :
      m_SequenceLength( SEQUENCE_SIZE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseDataDensity
    DataSetPairwiseDataDensity *DataSetPairwiseDataDensity::Clone() const
    {
      return new DataSetPairwiseDataDensity( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseDataDensity::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseDataDensity::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseDataDensity::operator()( const restraint::DataSetPairwise &DATA) const
    {
      // get the set of all unique individual data points
      util::ShPtrList< assemble::LocatorAtomCoordinatesInterface> data_points( DATA.GetDataPoints());

      // the number of unique data point positions (number of spin labels)
      const size_t l( data_points.GetSize());

      // the number of intervals
      const size_t n( l + 1);

      // optimal interval between spin labels
      const size_t I( m_SequenceLength / n);

      const double label_density_score( -CalculateDensityScore( data_points, I, n));

      return label_density_score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseDataDensity::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SequenceLength, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseDataDensity::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SequenceLength, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculates the density score
    //! @param DATA_POINTS the set of all unique individual data points
    //! @param INTERVAL optimal interval between individual data points, "I" in reference
    //! @param NUM_INTERVALS number of intervals between unique individual data points, "n" in reference
    //! @return double which is the density score
    double DataSetPairwiseDataDensity::CalculateDensityScore
    (
      const util::ShPtrList< assemble::LocatorAtomCoordinatesInterface> &DATA_POINTS,
      const size_t INTERVAL,
      const size_t NUM_INTERVALS
    ) const
    {
      double score( 0);

      if( DATA_POINTS.IsEmpty())
      {
        return 0;
      }

      BCL_Assert
      (
        DATA_POINTS.GetSize() > 1,
        "datapoints size should never be less than 2 at this point. The size is " + util::Format()( DATA_POINTS.GetSize())
      );

      // for nterminal interval
      {
        const size_t sequence_separation( ( *DATA_POINTS.Begin())->GetSeqID() - 1);
        const double current_score
        (
          math::Pow( double( math::Pow( sequence_separation - INTERVAL, size_t( 2)) + 1), double( -1))
        );
        score += current_score;
      }

      // for cterminal interval
      {
        const size_t sequence_separation( m_SequenceLength - ( *--DATA_POINTS.End())->GetSeqID());
        const double current_score
        (
          math::Pow( double( math::Pow( sequence_separation - INTERVAL, size_t( 2)) + 1), double( -1))
        );
        score += current_score;
      }

      // iterate through the data points two by two to sum up score
      for
      (
          util::ShPtrList< assemble::LocatorAtomCoordinatesInterface>::const_iterator
          data_itr( DATA_POINTS.Begin()),
          data_itr_b( ++DATA_POINTS.Begin()),
          data_itr_end( DATA_POINTS.End());
        data_itr != data_itr_end && data_itr_b != data_itr_end;
        ++data_itr, ++data_itr_b
      )
      {
        // get the current separation
        const size_t sequence_separation
        (
          restraint::DataPairwise::CalculateSequenceSeparation
          (
            ( *data_itr)->GetChainID(), ( *data_itr)->GetSeqID(),
            ( *data_itr_b)->GetChainID(), ( *data_itr_b)->GetSeqID()
          )
        );

        // true if the sequence separation is undefined
        if( !util::IsDefined( sequence_separation))
        {
          // continue to next pair
          continue;
        }

        const double current_score
        (
          math::Pow( double( math::Pow( sequence_separation - INTERVAL, size_t( 2)) + 1), double( -1))
        );

        score += current_score;
      }

      // divide by the number of intervals
      score /= double( NUM_INTERVALS);

      return score;
    }

  } // namespace score
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_distance_change_magnitude.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "restraint/bcl_restraint_data_set_pairwise.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseDistanceChangeMagnitude::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseDistanceChangeMagnitude())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseDistanceChangeMagnitude::GetDefaultScheme()
    {
      static const std::string s_scheme( "dist_change_magnitude");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseDistanceChangeMagnitude::DataSetPairwiseDistanceChangeMagnitude( const std::string &SCHEME) :
      m_DistanceChanges(),
      m_MaxMagnitudeChange(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking members
    //! @param ENSEMBLE_A ensemble for which distances will be calculated
    //! @param ENSEMBLE_B ensemble for which distances will be calculated
    //! @param FULL_DATA_SET data set distance changes should be calculated over
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseDistanceChangeMagnitude::DataSetPairwiseDistanceChangeMagnitude
    (
      const assemble::ProteinEnsemble &ENSEMBLE_A,
      const assemble::ProteinEnsemble &ENSEMBLE_B,
      const restraint::DataSetPairwise &FULL_DATA_SET,
      const std::string &SCHEME
    ) :
      m_DistanceChanges(),
      m_MaxMagnitudeChange(),
      m_Scheme( SCHEME)
    {
      // get distance change statistics
      const storage::Pair
      <
        storage::Map< restraint::DataPairwise, math::RunningAverageSD< double> >, math::RunningMinMax< double>
      > stats
      (
        GetDistanceChangeStatistics( ENSEMBLE_A, ENSEMBLE_B, FULL_DATA_SET)
      );

      m_DistanceChanges = stats.First();

      // the max magnitude is the absolute value of either the minimum or maximum distance change
      m_MaxMagnitudeChange =
          std::max( math::Absolute( stats.Second().GetMax()), math::Absolute( stats.Second().GetMin()));
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseDistanceChangeMagnitude
    DataSetPairwiseDistanceChangeMagnitude *DataSetPairwiseDistanceChangeMagnitude::Clone() const
    {
      return new DataSetPairwiseDistanceChangeMagnitude( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseDistanceChangeMagnitude::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseDistanceChangeMagnitude::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseDistanceChangeMagnitude::operator()( const restraint::DataSetPairwise &DATA) const
    {
      double score( 0);

      // iterate through the data set
      for
      (
        restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
        data_itr != data_itr_end;
        ++data_itr
      )
      {
        // find the pairwise data in m_DistanceChanges
        storage::Map< restraint::DataPairwise, math::RunningAverageSD< double> >::const_iterator
          found_data_itr( m_DistanceChanges.Find( *data_itr));

        // true if data was not found
        if( found_data_itr == m_DistanceChanges.End())
        {
          continue;
        }

        // get the current average distance change
        double mean_distance_change_magnitude( math::Absolute( found_data_itr->second.GetAverage()));

        // divide mean_distance_change by the maximum distance change
        mean_distance_change_magnitude /= m_MaxMagnitudeChange;

        // give bonus for changes that are larger fraction of m_MaxMagnitudeChange
        score -= mean_distance_change_magnitude;
      }

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseDistanceChangeMagnitude::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_DistanceChanges, ISTREAM);
      io::Serialize::Read( m_MaxMagnitudeChange, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseDistanceChangeMagnitude::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_DistanceChanges, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MaxMagnitudeChange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief for two ensembles calculates the mean and stddev distance changes observed for each data pair
    //! @param ENSEMBLE_A ensemble of first state of the protein
    //! @param ENSEMBLE_B ensemble of the second state of the protein
    //! @param DATA_SET the data set for which distance changes will be calculated
    //! @return pair of map with each datapair in DATA_SET and the associated mean and sd distance change observed in
    //!         the two ensembles
    //!         and a RunningMinMax< double> indicating the min and max mean distance change observed
    storage::Pair
    <
      storage::Map< restraint::DataPairwise, math::RunningAverageSD< double> >, math::RunningMinMax< double>
    > DataSetPairwiseDistanceChangeMagnitude::GetDistanceChangeStatistics
    (
      const assemble::ProteinEnsemble &ENSEMBLE_A, const assemble::ProteinEnsemble &ENSEMBLE_B,
      const restraint::DataSetPairwise &DATA_SET
    )
    {
      // hold mean and std dev distance change for each data pair as calculated from ENSEMBLE_A and ENSEMBLE_B
      storage::Map< restraint::DataPairwise, math::RunningAverageSD< double> > data_mean;

      // will hold the minimum and maximum distance change observed
      math::RunningMinMax< double> min_max;

      // iterate through the data set
      for
      (
        restraint::DataSetPairwise::const_iterator data_itr( DATA_SET.Begin()), data_itr_end( DATA_SET.End());
        data_itr != data_itr_end;
        ++data_itr
      )
      {
        // get the distance change mean and standard deviation for the current data pair
        const math::RunningAverageSD< double> distance_changes_mean_sd
        (
          ENSEMBLE_A.GetDistanceChangesMeanSD( *data_itr, ENSEMBLE_B)
        );

        // make a pair out of the current data pair and its statistics object
        const std::pair< restraint::DataPairwise, math::RunningAverageSD< double> > pair
        (
          *data_itr, distance_changes_mean_sd
        );

        // insert the current data pair and its statistics object and make sure insertion was successful
        const bool successful_insertion( data_mean.Insert( pair).second);
        BCL_Assert( successful_insertion, "could not insert");

        // add the mean distance change to min max statistics object
        min_max += distance_changes_mean_sd.GetAverage();
      }

      // return the data of mean, stddev for each data pair and min, max ever observed
      const storage::Pair
       <
         storage::Map< restraint::DataPairwise, math::RunningAverageSD< double> >, math::RunningMinMax< double>
       > pair( data_mean, min_max);

      return pair;
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_euclidian_distance.h"

// includes from bcl - sorted alphabetically
#include "restraint/bcl_restraint_data_set_pairwise.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseEuclidianDistance::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseEuclidianDistance())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseEuclidianDistance::GetDefaultScheme()
    {
      static const std::string s_scheme( "distance_range");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseEuclidianDistance::DataSetPairwiseEuclidianDistance( const std::string &SCHEME) :
      m_DistanceRange(),
      m_Ensemble(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking optional scheme
    //! @param RANGE desired range of euclidian separation between data points
    //! @param ENSEMBLE ensemble distances will be calculated from
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseEuclidianDistance::DataSetPairwiseEuclidianDistance
    (
      const math::Range< double> &RANGE,
      const util::ShPtr< assemble::ProteinEnsemble> &ENSEMBLE,
      const std::string &SCHEME
    ) :
      m_DistanceRange( RANGE),
      m_Ensemble( ENSEMBLE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking optional scheme
    //! @param RANGE desired range of euclidian separation between data points
    //! @param MODEL protein model distances will be calculated from
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseEuclidianDistance::DataSetPairwiseEuclidianDistance
    (
      const math::Range< double> &RANGE,
      const assemble::ProteinModel &MODEL,
      const std::string &SCHEME
    ) :
      m_DistanceRange( RANGE),
      m_Ensemble(),
      m_Scheme( SCHEME)
    {
      // make ensemble from single model and set m_Ensemble to it
      util::ShPtr< assemble::ProteinEnsemble> ensemble( new assemble::ProteinEnsemble());
      ensemble->InsertElement( util::ShPtr< assemble::ProteinModel>( MODEL.Clone()));
      m_Ensemble = ensemble;
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseEuclidianDistance
    DataSetPairwiseEuclidianDistance *DataSetPairwiseEuclidianDistance::Clone() const
    {
      return new DataSetPairwiseEuclidianDistance( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseEuclidianDistance::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseEuclidianDistance::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseEuclidianDistance::operator()( const restraint::DataSetPairwise &DATA) const
    {
      double score( 0);

      // iterate through the data set
      for
      (
        restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
        data_itr != data_itr_end;
        ++data_itr
      )
      {
        // get mean distance - it is undefined if no counts were available
        const math::RunningAverageSD< double> mean_sd( data_itr->EuclidianDistance( *m_Ensemble).First());
        const double mean_distance( mean_sd.GetWeight() ? mean_sd.GetAverage() : util::GetUndefinedDouble());

        // true if size is within the desired range and defined
        if( m_DistanceRange.IsWithin( mean_distance) || !util::IsDefined( mean_distance))
        {
          continue;
        }

        // score is the distance outside of the range
        const double current_score
        (
          math::Absolute( mean_distance - m_DistanceRange.GetMiddle()) - ( m_DistanceRange.GetWidth() * 0.5)
        );

        score += current_score;
      }

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseEuclidianDistance::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_DistanceRange, ISTREAM);
      io::Serialize::Read( m_Ensemble, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseEuclidianDistance::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_DistanceRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Ensemble, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace score
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_residue_type_exclusion.h"

// includes from bcl - sorted alphabetically
#include "restraint/bcl_restraint_data_set_pairwise.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseResidueTypeExclusion::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseResidueTypeExclusion())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseResidueTypeExclusion::GetDefaultScheme()
    {
      static const std::string s_scheme( "aa_type_excl");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    DataSetPairwiseResidueTypeExclusion::DataSetPairwiseResidueTypeExclusion( const std::string &SCHEME) :
      m_AATypesToExclude(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking scheme
    //! @param AA_TYPES the types of amino acids which are undesirable
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseResidueTypeExclusion::DataSetPairwiseResidueTypeExclusion
    (
      const storage::Set< biol::AAType> AA_TYPES, const std::string &SCHEME
    ) :
      m_AATypesToExclude( AA_TYPES),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseResidueTypeExclusion
    DataSetPairwiseResidueTypeExclusion *DataSetPairwiseResidueTypeExclusion::Clone() const
    {
      return new DataSetPairwiseResidueTypeExclusion( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseResidueTypeExclusion::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseResidueTypeExclusion::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseResidueTypeExclusion::operator()( const restraint::DataSetPairwise &DATA) const
    {
      double score( 0);

      // iterate through the data set
      for
      (
        restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
        data_itr != data_itr_end;
        ++data_itr
      )
      {
        // get the aa types of the current residues
        const biol::AAType &aa_type_a( data_itr->First()->GetAAType());
        const biol::AAType &aa_type_b( data_itr->Second()->GetAAType());

        // add the number of times the aa type is found in m_AATypesToExclude to the score
        // this should be either 1 or 0 since the aa types in the set are unique
        score += m_AATypesToExclude.Count( aa_type_a);
        score += m_AATypesToExclude.Count( aa_type_b);
      }

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseResidueTypeExclusion::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_AATypesToExclude, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseResidueTypeExclusion::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_AATypesToExclude, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace score
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_sequence_separation.h"

// includes from bcl - sorted alphabetically
#include "restraint/bcl_restraint_data_set_pairwise.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseSequenceSeparation::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseSequenceSeparation())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseSequenceSeparation::GetDefaultScheme()
    {
      static const std::string s_scheme( "seq_sep");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSequenceSeparation::DataSetPairwiseSequenceSeparation( const std::string &SCHEME) :
      m_SequenceLength(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking scheme
    //! @param SEQUENCE_SIZE the sequence size the score will be normalized against
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSequenceSeparation::DataSetPairwiseSequenceSeparation
    (
      const size_t SEQUENCE_SIZE, const std::string &SCHEME
    ) :
      m_SequenceLength( SEQUENCE_SIZE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseSequenceSeparation
    DataSetPairwiseSequenceSeparation *DataSetPairwiseSequenceSeparation::Clone() const
    {
      return new DataSetPairwiseSequenceSeparation( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseSequenceSeparation::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseSequenceSeparation::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseSequenceSeparation::operator()( const restraint::DataSetPairwise &DATA) const
    {
      double seq_sep_sum( 0);

      if( DATA.IsEmpty())
      {
        return seq_sep_sum;
      }

      // will keep track of the number of data pairs whose sequence separations can be calculated
      // sequence separation is undefined for pairs on different chains
      size_t count( 0);

      // iterate through the data set
      for
      (
        restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
        data_itr != data_itr_end;
        ++data_itr
      )
      {
        // get sequence separation
        const size_t sequence_separation( data_itr->SequenceSeparation());

        // true if the sequence separation is defined
        if( util::IsDefined( sequence_separation))
        {
          // take the log of the sequence separation and add it to the running sum
          seq_sep_sum += std::log( double( sequence_separation));

          // increment the count of pairs being considered
          ++count;
        }
      }

      // calculate the score
      const double score( -seq_sep_sum / ( double( count) * std::log( double( m_SequenceLength))));

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseSequenceSeparation::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SequenceLength, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseSequenceSeparation::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SequenceLength, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief determines the sequence separation between two chain and sequence ids
    //! @param CHAIN_ID_A first chain id
    //! @param SEQ_ID_A first seq id
    //! @param CHAIN_ID_B second chain id
    //! @param SEQ_ID_B second seq id
    //! @return size_t which is the sequence separation between the first and second
    size_t DataSetPairwiseSequenceSeparation::CalculateSequenceSeparation
    (
      const char CHAIN_ID_A, const int SEQ_ID_A, const char CHAIN_ID_B, const int SEQ_ID_B
    )
    {
      // true if the chain ids don't match
      if( CHAIN_ID_A != CHAIN_ID_B)
      {
        return util::GetUndefinedSize_t();
      }

      // return difference between SEQ_ID_A and SEQ_ID_B
      return math::Absolute( SEQ_ID_A - SEQ_ID_B);
    }

  } // namespace score
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_size.h"

// includes from bcl - sorted alphabetically
#include "restraint/bcl_restraint_data_set_pairwise.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseSize::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseSize())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseSize::GetDefaultScheme()
    {
      static const std::string s_scheme( "data_set_size");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSize::DataSetPairwiseSize( const std::string &SCHEME) :
      m_SizeRange(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking optional scheme
    //! @param SIZE_RANGE_MIN minimum desired size inclusive
    //! @param SIZE_RANGE_MAX maximum desired size inclusive
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSize::DataSetPairwiseSize
    (
      const size_t &SIZE_RANGE_MIN, const size_t &SIZE_RANGE_MAX, const std::string &SCHEME
    ) :
      m_SizeRange( math::Range< double>( SIZE_RANGE_MIN, SIZE_RANGE_MAX)),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseSize
    DataSetPairwiseSize *DataSetPairwiseSize::Clone() const
    {
      return new DataSetPairwiseSize( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseSize::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseSize::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseSize::operator()( const restraint::DataSetPairwise &DATA) const
    {
      const double data_size( DATA.GetSize());

      // true if size is within the desired range
      if( m_SizeRange.IsWithin( data_size))
      {
        return 0;
      }

      // score is the distance outside of the range
      const double score( math::Absolute( data_size - m_SizeRange.GetMiddle()) - ( m_SizeRange.GetWidth() * 0.5));

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseSize::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SizeRange, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseSize::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SizeRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace score
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_pool.h"
#include "restraint/bcl_restraint_data_set_pairwise.h"
#include "restraint/bcl_restraint_locator_coordinates_first_side_chain_atom.h"
#include "score/bcl_score_data_set_pairwise_sse_center.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseSSECenter::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseSSECenter())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseSSECenter::GetDefaultScheme()
    {
      static const std::string s_scheme( "sse_center");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    DataSetPairwiseSSECenter::DataSetPairwiseSSECenter( const std::string &SCHEME) :
      m_Data(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking pool
    //! @param SSE_POOL the pool the sse definitions will come from
    //! @param SCHEME optional scheme
    DataSetPairwiseSSECenter::DataSetPairwiseSSECenter( const assemble::SSEPool &SSE_POOL, const std::string &SCHEME) :
      m_Data(),
      m_Scheme( SCHEME)
    {
      m_Data = CalculateResiduePositionWeight( SSE_POOL);
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseSSECenter
    DataSetPairwiseSSECenter *DataSetPairwiseSSECenter::Clone() const
    {
      return new DataSetPairwiseSSECenter( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseSSECenter::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseSSECenter::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseSSECenter::operator()( const restraint::DataSetPairwise &DATA) const
    {
      if( DATA.IsEmpty())
      {
        return 0;
      }

      double score( 0);

      // iterate over the data pairs to score them
      for
      (
        restraint::DataSetPairwise::const_iterator itr( DATA.Begin()), itr_end( DATA.End());
        itr != itr_end;
        ++itr
      )
      {
        storage::Map
        <
          util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, double,
          assemble::LocatorAtomCoordinatesInterface::PtrResidueLessThan
        >::const_iterator resi_itr_a( m_Data.Find( itr->First()));

        storage::Map
        <
          util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, double,
          assemble::LocatorAtomCoordinatesInterface::PtrResidueLessThan
        >::const_iterator resi_itr_b( m_Data.Find( itr->Second()));

        // if either residue could not found in the map
        if( resi_itr_a == m_Data.End() || resi_itr_b == m_Data.End())
        {
          ++score;
          continue;
        }

        double weight_a( resi_itr_a->second);
        double weight_b( resi_itr_b->second);

        double current_score( weight_a + weight_b);

        score += current_score;
      }

      score /= double( DATA.GetSize());

      --score;

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseSSECenter::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Data, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseSSECenter::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Data, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculates the weight of every residue in helical sses according to its position relative to the ends
    //! @param SSE_POOL the pool of sses that will be used to calculate the weights
    //! @return map that has for every residue in helical sses the weight associated according to its position relative
    //!         to the end of the sse
    storage::Map
    <
      util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, double,
      assemble::LocatorAtomCoordinatesInterface::PtrResidueLessThan
    > DataSetPairwiseSSECenter::CalculateResiduePositionWeight( const assemble::SSEPool &SSE_POOL)
    {
      // the sses from the pool
      storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> sses
      (
        SSE_POOL.GetRandomNonOverlappingSet()
      );

      // map to hold the residues and their weights
      storage::Map
      <
        util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, double,
        assemble::LocatorAtomCoordinatesInterface::PtrResidueLessThan
      > residue_weights;

      // iterate through the sses
      for
      (
        storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr( sses.Begin()), sse_itr_end( sses.End());
          sse_itr != sse_itr_end;
          ++sse_itr
      )
      {
        // true if the sse is not helix, go to next sse
        if( ( *sse_itr)->GetType() != biol::GetSSTypes().HELIX)
        {
          continue;
        }

        // iterate over the residues of the sse to assign their weights
        for
        (
          biol::AASequence::const_iterator aa_itr( ( *sse_itr)->Begin()), aa_itr_end( ( *sse_itr)->End());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {

          util::ShPtr< assemble::LocatorAtomCoordinatesInterface> current_resi
          (
            new restraint::LocatorCoordinatesFirstSideChainAtom( ( *aa_itr)->GetChainID(), ( *aa_itr)->GetSeqID())
          );

          const double weight( CalculateWeight( **sse_itr, **aa_itr));

          bool success
          (
            residue_weights.Insert
            (
              std::pair< util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, double>( current_resi, weight)
            ).second
          );

          BCL_Assert( success, "was not able to insert residue " + current_resi->GetIdentification());
        }
      }

      return residue_weights;
    }

    //! @brief calculates the weight of the given residue according to its position away from the end of the given sse
    //! @param SSE the sse whose ends will be used to calculate the weight
    //! @param AA_BASE the residue of interest whose weight will be calculated
    //! @return double which is the weight of the residue
    double DataSetPairwiseSSECenter::CalculateWeight( const assemble::SSE &SSE, const biol::AABase &AA_BASE)
    {
      double aa_resi_num( AA_BASE.GetSeqID());

      double sse_middle_resi( ( SSE.GetLastAA()->GetSeqID() - SSE.GetFirstAA()->GetSeqID()) / 2.0 + SSE.GetFirstAA()->GetSeqID());

      const double weight( math::Absolute( aa_resi_num - sse_middle_resi) / SSE.GetSize());

      BCL_MessageDbg
      (
        "resi is " + util::Format()( aa_resi_num) + " sse is " + SSE.GetIdentification() +
        " weight is " + util::Format()( weight) + " middle resi is " + util::Format()( sse_middle_resi)
        + " sse size is " + util::Format()( SSE.GetSize())
      );

      return weight;
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_sse_connection.h"

// includes from bcl - sorted alphabetically
#include "restraint/bcl_restraint_data_set_pairwise.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseSSEConnection::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseSSEConnection())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseSSEConnection::GetDefaultScheme()
    {
      static const std::string s_scheme( "sse_connection");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSSEConnection::DataSetPairwiseSSEConnection( const std::string &SCHEME) :
      m_SSEPool(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking optional scheme
    //! @param SSE_POOL pool to use as sse definitions
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSSEConnection::DataSetPairwiseSSEConnection
    (
      const util::ShPtr< assemble::SSEPool> &SSE_POOL, const std::string &SCHEME
    ) :
      m_SSEPool( SSE_POOL),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseSSEConnection
    DataSetPairwiseSSEConnection *DataSetPairwiseSSEConnection::Clone() const
    {
      return new DataSetPairwiseSSEConnection( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseSSEConnection::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseSSEConnection::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseSSEConnection::operator()( const restraint::DataSetPairwise &DATA) const
    {
      if( DATA.IsEmpty())
      {
        return 0;
      }

      // get random non overlapping set of sses from the pool
      const storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> sses
      (
        m_SSEPool->GetRandomNonOverlappingSet()
      );

      BCL_Assert( !sses.IsEmpty(), "no sses");

      const storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t> sse_pair_counts
      (
        GetSSEPairCounts( sses, DATA)
      );

      // the number of sses
      const size_t s( sses.GetSize());

      // the number of restraints
      const size_t r( DATA.GetSize());

      // the number of sse pairs
      const size_t p( s * ( s - 1) / 2);

      // minimum acceptable integer value for C, the ideal number of connections for each SSE pair
      const size_t C_prime( r / p);

      // maximum acceptable integer value for C, the ideal number of connections for each SSE pair
      // if evenly divisible is it necessary to increment
      const size_t C_prime_prime( C_prime + 1);

      // remainder of r and p
      const size_t M( r % p);

      // sse connection score term R, average percent of restraints in each SSE pair up to ideal value C_prime_prime
      const double S_EC_R( CalculateSSEConnectionScoreComponentR( sse_pair_counts, C_prime_prime, r));

      // sse connection score term C, fraction of SSE pairs that contain exactly the ideal number of restraints
      const double S_EC_C( CalculateSSEConnectionScoreComponentC( sse_pair_counts, C_prime, C_prime_prime, p, M));

      const double composite_score( -( S_EC_R + S_EC_C) / 2.0);

      // return the score
      return composite_score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseSSEConnection::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSEPool, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseSSEConnection::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSEPool, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief Gives information on how many times each SSE pair is connected by a data pair
    //! @param SSES the sses which will be used to count how many datapoints fall in each
    //! @param DATA the dataset which will be used to see how many of each data point are in each sse
    //! @return map of sse pairs and how many times they are connected
    storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t>
    DataSetPairwiseSSEConnection::GetSSEPairCounts
    (
      const storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> &SSES,
      const restraint::DataSetPairwise &DATA
    )
    {
      // to keep track of  how many measurements connect the each sse pair
      storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t> sse_pairs_counts;

      // iterate through the sses
      for
      (
        storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr_a( SSES.Begin()), sse_itr_end( SSES.End());
        sse_itr_a != sse_itr_end;
        ++sse_itr_a
      )
      {
        const util::SiPtr< const assemble::SSE> &sse_a( *sse_itr_a);

        // iterate through the sses again to make sse pairs - pairs of the same sse are not considered
        for
        (
          storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
            sse_itr_b
            (
              ++storage::Set
              <
                util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap
              >::const_iterator( sse_itr_a)
            );
          sse_itr_b != sse_itr_end;
          ++sse_itr_b
        )
        {
          const util::SiPtr< const assemble::SSE> &sse_b( *sse_itr_b);

          // make the pair of sses
          const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > sse_pair( sse_a, sse_b);

          // insert the current pair into sse_pairs_counts
          std::pair
          <
            storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t>::iterator, bool
          > insert_status
          (
            sse_pairs_counts.Insert
            (
              std::pair< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t>( sse_pair, 0)
            )
          );

          BCL_Assert
          (
            insert_status.second, "could not insert " + sse_a->GetIdentification() + " and "
            + sse_b->GetIdentification()
          );

          // iterate through the data set to see which sse each point of each data pair is in
          for
          (
            restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
            data_itr != data_itr_end;
            ++data_itr
          )
          {
            // true if the current data pair connect the sse pair
            // they should be sorted by sequence so can just compare first with first and second with second
            if( data_itr->First()->IsWithin( *sse_a) && data_itr->Second()->IsWithin( *sse_b))
            {
              // if so add a count for the current SSE pair
              ++insert_status.first->second;
            }

            // make sure sorting is working as expected
            BCL_Assert
            (
              !( data_itr->First()->IsWithin( *sse_b) && data_itr->Second()->IsWithin( *sse_a)), "sorting is broken"
            );
          } //< iterate through dataset
        } //< iterate through sses
      } //< iterate through sses

      // return the map of sse pairs and how many times they are connected
      return sse_pairs_counts;
    }

    //! @brief calculates the R component of the SSE connection score
    //! @param SSE_PAIRS_COUNTS map of sse pairs and how many times they are connected
    //! @param C_PRIME_PRIME maximum acceptable integer value for C, the ideal number of connections for each SSE pair
    //! @param NUMBER_RESTRAINTS this is "r" in the reference
    //! @return double which is the R component of the SSE connection score
    double DataSetPairwiseSSEConnection::CalculateSSEConnectionScoreComponentR
    (
      const storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t> &SSE_PAIRS_COUNTS,
      const size_t C_PRIME_PRIME,
      const size_t NUMBER_RESTRAINTS
    )
    {
      double score( 0);

      // iterate through the map
      for
      (
        storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t>::const_iterator
          sse_itr( SSE_PAIRS_COUNTS.Begin()), sse_itr_end( SSE_PAIRS_COUNTS.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // number of connections between the current sse pair
        const size_t ri( sse_itr->second);
        const size_t min( std::min( ri, C_PRIME_PRIME));
        score += min;
      }

      // divide by number of points
      score /= double( NUMBER_RESTRAINTS);

      return score;
    }

    //! @brief sse connection score term C, fraction of SSE pairs that contain exactly the ideal number of restraints
    //! @param SSE_PAIRS_COUNTS map of sse pairs and how many times they are connected
    //! @param C_PRIME minimum acceptable integer value for C, the ideal number of connections for each SSE pair
    //! @param C_PRIME_PRIME maximum acceptable integer value for C, the ideal number of connections for each SSE pair
    //! @param NUM_SSE_PAIRS this is "p" in the reference
    //! @param REMAINDER this is "M" in the reference
    //! @return score for sse connection score component C
    double DataSetPairwiseSSEConnection::CalculateSSEConnectionScoreComponentC
    (
      const storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t> &SSE_PAIRS_COUNTS,
      const size_t C_PRIME,
      const size_t C_PRIME_PRIME,
      const size_t NUM_SSE_PAIRS,
      const size_t REMAINDER
    )
    {
      // the number of SSE pairs with C_PRIME restraints
      size_t F_prime( 0);

      // the number of SSE pairs with C_PRIME_PRIME restraints
      size_t F_prime_prime( 0);

      // iterate through the sses and their data point counts to determine F_prime and F_prime_prime
      for
      (
        storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t>::const_iterator
          sse_itr( SSE_PAIRS_COUNTS.Begin()), sse_itr_end( SSE_PAIRS_COUNTS.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        const size_t current_count( sse_itr->second);

        if( current_count == C_PRIME)
        {
          ++F_prime;
        }

        else if( current_count == C_PRIME_PRIME)
        {
          ++F_prime_prime;
        }
      }

      // min( Fprime,( p - M))
      size_t min_F_prime( std::min( F_prime, ( NUM_SSE_PAIRS - REMAINDER)));

      // min( F_prime_prime, M)
      size_t min_F_prime_prime( std::min( F_prime_prime, REMAINDER));

      // C component of SSE connection score
      const double component_C( double( min_F_prime + min_F_prime_prime) / double( NUM_SSE_PAIRS));

      return component_C;
    }

  } // namespace score
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_sse_size.h"

// includes from bcl - sorted alphabetically
#include "math/bcl_math_running_average_sd.h"
#include "math/bcl_math_running_min_max.h"
#include "restraint/bcl_restraint_data_set_pairwise.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseSSESize::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseSSESize())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseSSESize::GetDefaultScheme()
    {
      static const std::string s_scheme( "sse_size");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSSESize::DataSetPairwiseSSESize( const std::string &SCHEME) :
      m_SSEPool(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking optional scheme
    //! @param SSE_POOL pool to use as sse definitions
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSSESize::DataSetPairwiseSSESize
    (
      const util::ShPtr< assemble::SSEPool> &SSE_POOL, const std::string &SCHEME
    ) :
      m_SSEPool( SSE_POOL),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseSSESize
    DataSetPairwiseSSESize *DataSetPairwiseSSESize::Clone() const
    {
      return new DataSetPairwiseSSESize( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseSSESize::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseSSESize::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseSSESize::operator()( const restraint::DataSetPairwise &DATA) const
    {
      // get random non overlapping set of sses from the pool
      const storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> sse_set
      (
        m_SSEPool->GetRandomNonOverlappingSet()
      );

      // get siptrvector from the set of sses
      util::SiPtrVector< const assemble::SSE> sses( sse_set.Begin(), sse_set.End());

      // keep track of the average size of sse with data point in it
      math::RunningAverageSD< double> average_size;

      // keep track of the max size of any sse
      math::RunningMinMax< double> max_size;

      // iterate through the sses to get the max size
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator sse_itr( sses.Begin()), sse_itr_end( sses.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // consider the size of this sse to see if it is largest
        max_size += double( ( *sse_itr)->GetSize());

        // iterate through the data set to see if any data points are in the current sse
        for
        (
          restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
          data_itr != data_itr_end;
          ++data_itr
        )
        {
          // true if the first data point is in the sse
          if( data_itr->First()->IsWithin( **sse_itr))
          {
            average_size += ( *sse_itr)->GetSize();
          }
          // true if the second data point is in the sse
          if( data_itr->Second()->IsWithin( **sse_itr))
          {
            average_size += ( *sse_itr)->GetSize();
          }
        }
      }

      // score is fraction of average compared to the maximum size
      const double score( -average_size.GetAverage() / max_size.GetMax());

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseSSESize::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSEPool, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseSSESize::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSEPool, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_sse_term.h"

// includes from bcl - sorted alphabetically
#include "restraint/bcl_restraint_data_set_pairwise.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseSSETerm::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseSSETerm())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseSSETerm::GetDefaultScheme()
    {
      static const std::string s_scheme( "sse_term");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSSETerm::DataSetPairwiseSSETerm( const std::string &SCHEME) :
      m_SSEPool(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking optional scheme
    //! @param SSE_POOL pool to use as sse definitions
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseSSETerm::DataSetPairwiseSSETerm
    (
      const util::ShPtr< assemble::SSEPool> &SSE_POOL, const std::string &SCHEME
    ) :
      m_SSEPool( SSE_POOL),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseSSETerm
    DataSetPairwiseSSETerm *DataSetPairwiseSSETerm::Clone() const
    {
      return new DataSetPairwiseSSETerm( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseSSETerm::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseSSETerm::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseSSETerm::operator()( const restraint::DataSetPairwise &DATA) const
    {
      if( DATA.IsEmpty())
      {
        return 0;
      }

      // get random non overlapping set of sses from the pool
      const storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> sses
      (
        m_SSEPool->GetRandomNonOverlappingSet()
      );

      // number of spin labels which is two times the dataset size
      const size_t l( DATA.GetSize() * 2);

      // number of sses
      const size_t s( sses.GetSize());

      // Q is the number of spin labels per SSE - these are the acceptable integer values of Q
      const size_t Q_prime( l / s);
      const size_t Q_prime_prime( Q_prime + 1);

      // the remainder of l / s
      const size_t R( l % s);

      // to keep track of how many labels are in each sse
      const storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap> sse_count
      (
        GetSSECounts( sses, DATA)
      );

      // calculate Ssse(L) which is the secondary structure score component L
      const double s_sse_L( CalculateSSEScoreComponentL( sse_count, Q_prime_prime, l));

      // calculate Ssse(S) which is the secondary structure score component S
      const double s_sse_S( CalculateSSEScoreComponentS( sse_count, Q_prime, Q_prime_prime, R, s));

      const double composite_score( -( s_sse_L + s_sse_S) / 2.0);

      // return the score
      return composite_score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseSSETerm::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSEPool, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseSSETerm::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSEPool, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief for each sse gives the number of data points that fall within that sse
    //! @param SSES the sses which will be used to count how many data points fall within them
    //! @param DATA the data set which will be used to count how many data points fall within the SSES
    //! @return map which has for each sse the number of data points that fall within that sse
    storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap>
    DataSetPairwiseSSETerm::GetSSECounts
    (
      const storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> &SSES,
      const restraint::DataSetPairwise &DATA
    )
    {
      // to keep track of how many labels are in each sse
      storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap> sse_count;

      // iterate through the sses to get the number of labels in each sse
      for
      (
        storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr( SSES.Begin()), sse_itr_end( SSES.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        const util::SiPtr< const assemble::SSE> &sse( *sse_itr);
        // add the sse to the counting map
        std::pair
        <
          storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap>::iterator, bool
        > insert_status( sse_count.Insert( std::pair< util::SiPtr< const assemble::SSE>, size_t>( sse, 0)));

        BCL_Assert( insert_status.second, "could not insert " + sse->GetIdentification());

        // iterate through the data set to see which sse each point of each data pair is in
        for
        (
          restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
          data_itr != data_itr_end;
          ++data_itr
        )
        {
          // true if the first data point is in the sse
          if( data_itr->First()->IsWithin( *sse))
          {
            // if so add a count for the current SSE
            ++insert_status.first->second;
          }
          // true if the second data point is in the sse
          if( data_itr->Second()->IsWithin( *sse))
          {
            // if so add a count for the current SSE
            ++insert_status.first->second;
          }
        }
      }

      // return the map of sses and how many data points from the data set are in each sse
      return sse_count;
    }

    //! @brief calculates the average percentage of points positioned in each SSE up to the ideal value, Qprimeprime
    //! @param SSE_COUNT map with a count for each sse of the number of points in each sse
    //! @param Q_PRIME_PRIME see reference
    //! @param NUMBER_OF_POINTS the number of points in the data set i.e. 2 * (dataset size) ( this is l in reference)
    //! @return double which is the L component of the sse term score
    double DataSetPairwiseSSETerm::CalculateSSEScoreComponentL
    (
      const storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap> &SSE_COUNT,
      const size_t Q_PRIME_PRIME,
      const size_t NUMBER_OF_POINTS
    )
    {
      double score( 0);

      // iterate through the map
      for
      (
        storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr( SSE_COUNT.Begin()), sse_itr_end( SSE_COUNT.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // number of labels in the current sse
        const size_t li( sse_itr->second);
        const size_t min( std::min( li, Q_PRIME_PRIME));
        score += min;
      }

      // divide by number of points
      score /= double( NUMBER_OF_POINTS);

      return score;
    }

    //! @brief calculates S component of SSE score, derived from frachtion of SSEs containing exactly
    //! @param SSE_COUNT map with a count for each sse of the number of points in each sse
    //! @param Q_PRIME_PRIME see reference
    //! @param REMAINDER "R" in reference
    //! @param NUMBER_SSES "s" in reference
    //! @return double which is component S of the sse score
    double DataSetPairwiseSSETerm::CalculateSSEScoreComponentS
    (
      const storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap> &SSE_COUNT,
      const size_t Q_PRIME,
      const size_t Q_PRIME_PRIME,
      const size_t REMAINDER,
      const size_t NUMBER_SSES
    )
    {
      // the number of sses with Q_PRIME data points
      size_t E_prime( 0);

      // the number of sses with Q_PRIME_PRIME data points
      size_t E_prime_prime( 0);

      // iterate through the sses and their data point counts to determine E_prime and E_prime_prime
      for
      (
        storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr( SSE_COUNT.Begin()), sse_itr_end( SSE_COUNT.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        const size_t current_count( sse_itr->second);

        if( current_count == Q_PRIME)
        {
          ++E_prime;
        }

        if( current_count == Q_PRIME_PRIME)
        {
          ++E_prime_prime;
        }
      }

      // min( Eprime,( s - R))
      size_t min_E_prime( std::min( E_prime, ( NUMBER_SSES - REMAINDER)));

      // min( E_prime_prime, R)
      size_t min_E_prime_prime( std::min( E_prime_prime, REMAINDER));

      // S component of SSE score
      const double SsseS( double( min_E_prime + min_E_prime_prime) / double( NUMBER_SSES));

      return SsseS;
    }

  } // namespace score
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_data_set_pairwise_structural_exposure.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_count.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "math/bcl_math_statistics.h"
#include "math/bcl_math_trigonometric_transition.h"
#include "restraint/bcl_restraint_data_set_pairwise.h"
#include "restraint/bcl_restraint_locator_coordinates_first_side_chain_atom.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DataSetPairwiseStructuralExposure::s_Instance
    (
      GetObjectInstances().AddInstance( new DataSetPairwiseStructuralExposure())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &DataSetPairwiseStructuralExposure::GetDefaultScheme()
    {
      static const std::string s_scheme( "exposure");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor taking optional scheme
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseStructuralExposure::DataSetPairwiseStructuralExposure( const std::string &SCHEME) :
      m_ExposureCutoff(),
      m_ExposureMap(),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor taking members
    //! @param EXPOSURE_CUTOFF data involving residues outside of this exposure amount will be penalized
    //! @param ENSEMBLE ensemble for which exposures will be calculated
    //! @param SCHEME the scheme for this scoring function
    DataSetPairwiseStructuralExposure::DataSetPairwiseStructuralExposure
    (
      const double &EXPOSURE_CUTOFF,
      const assemble::ProteinEnsemble &ENSEMBLE,
      const std::string &SCHEME
    ) :
      m_ExposureCutoff( EXPOSURE_CUTOFF),
      m_ExposureMap(),
      m_Scheme( SCHEME)
    {
      FillExposureMap( ENSEMBLE, m_ExposureMap);
    }

    //! @brief Clone function
    //! @return pointer to new DataSetPairwiseStructuralExposure
    DataSetPairwiseStructuralExposure *DataSetPairwiseStructuralExposure::Clone() const
    {
      return new DataSetPairwiseStructuralExposure( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DataSetPairwiseStructuralExposure::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &DataSetPairwiseStructuralExposure::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of a data set
    //! @param DATA data set to be scored
    //! @return the score of the current data set
    double DataSetPairwiseStructuralExposure::operator()( const restraint::DataSetPairwise &DATA) const
    {
      if( DATA.IsEmpty())
      {
        return 0;
      }

      double score( 0);

      // iterate through the data set
      for
      (
        restraint::DataSetPairwise::const_iterator data_itr( DATA.Begin()), data_itr_end( DATA.End());
        data_itr != data_itr_end;
        ++data_itr
      )
      {
        const double score_first( CalculateExposureScore( data_itr->First(), m_ExposureMap, m_ExposureCutoff));
        const double score_second( CalculateExposureScore( data_itr->Second(), m_ExposureMap, m_ExposureCutoff));

        // true if the first data point is defined
        if( util::IsDefined( score_first))
        {
          score += score_first;
        }

        // true if the second data point is defined
        if( util::IsDefined( score_second))
        {
          score += score_second;
        }
      }

      score /= double( DATA.GetSize());

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DataSetPairwiseStructuralExposure::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ExposureCutoff, ISTREAM);
      io::Serialize::Read( m_ExposureMap, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DataSetPairwiseStructuralExposure::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ExposureCutoff, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ExposureMap, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief fills the given exposure map based on the exposures calculated from a given ensemble
    //! @param ENSEMBLE ensemble of models exposures will be calculated for
    //! @param EXPOSURE_MAP the map of exposures that will be filled
    void DataSetPairwiseStructuralExposure::FillExposureMap
    (
      const assemble::ProteinEnsemble &ENSEMBLE, ExposureMap &EXPOSURE_MAP
    )
    {
      assemble::AANeighborCount neighbor_counter;

      // iterate through the ensemble
      for
      (
        assemble::ProteinEnsemble::const_iterator ensemble_itr( ENSEMBLE.Begin()), ensemble_itr_end( ENSEMBLE.End());
        ensemble_itr != ensemble_itr_end;
        ++ensemble_itr
      )
      {
        // get the neighbor list container for the current protein
        const assemble::AANeighborListContainer nl_container
        (
          ( *ensemble_itr)->GetAminoAcids(),
          neighbor_counter.GetDistanceCutoff(),
          neighbor_counter.GetMinimalSequenceSeparation(),
          true
        );

        // iterate through the neighbor list container
        for
        (
          assemble::AANeighborListContainer::const_iterator
            nl_itr( nl_container.Begin()), nl_itr_end( nl_container.End());
          nl_itr != nl_itr_end;
          ++nl_itr
        )
        {
          // get the center residue
          const util::SiPtr< const biol::AABase> &center_aa( nl_itr->second.GetCenterAminoAcid());

          BCL_Assert
          (
            center_aa != util::SiPtr< const biol::AABase>( assemble::AANeighborList::GetDefaultCenterAA()),
            "center residue undefined"
          );

          // make locator to current center residue
          const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> residue_locator
          (
            new restraint::LocatorCoordinatesFirstSideChainAtom
            (
              center_aa->GetChainID(),                      center_aa->GetSeqID(),
              center_aa->GetFirstSidechainAtom().GetType(), center_aa->GetType()
            )
          );

          BCL_MessageDbg
          (
            "doing nc for residue " + nl_itr->second.GetCenterAminoAcid()->GetIdentification() +
            " center_aa identification is " + center_aa->GetIdentification()
          );

          // get the neighbor count for the current residue
          const double nc( neighbor_counter( nl_itr->second));

          BCL_MessageDbg
          (
            "current neighbor count is " + util::Format()( nc) + " for " +
            residue_locator->GetIdentification()
          );

          // try to find the residue locator
          ExposureMap::iterator resi_locator_itr( EXPOSURE_MAP.Find( residue_locator));

          // true if locator was not found
          if( resi_locator_itr == EXPOSURE_MAP.End())
          {
            // insert the locator with a vector containing the current nc
            std::pair< util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, storage::Vector< double> > pair
            (
              residue_locator, storage::Vector< double>( 1, nc)
            );
            BCL_MessageDbg
            (
              "inserted residue key for " + residue_locator->GetIdentification() +
              " with nc " + util::Format()( nc)
            );

            BCL_Assert
            (
              EXPOSURE_MAP.Insert( pair).second, "could not insert " + residue_locator->GetIdentification() +
              " with nc " + util::Format()( nc)
            );
          }
          else //< residue locator already exists in map so just add nc to the vector
          {
            // add the current neighbor count to the list of neighbor counts for the current residue
            resi_locator_itr->second.PushBack( nc);
            BCL_MessageDbg
            (
              "inserted nc value for " + residue_locator->GetIdentification() +
              " with nc " + util::Format()( nc)
            );
          }
        } //< iterate through current neighbor list container
      } //< iterate through ensemble
    } //< function FillExposureMap

    //! @brief calculates the score that a given data point has given its exposures and the exposure cutoff
    //! @param LOCATOR the data point the score will be calculated for
    //! @param EXPOSURE_MAP the map of exposures
    //! @param EXPOSURE_CUTOFF data involving residues outside of this exposure amount will be penalized
    //! @return double which is the score of LOCATOR
    double DataSetPairwiseStructuralExposure::CalculateExposureScore
    (
      const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR,
      const ExposureMap &EXPOSURE_MAP,
      const double EXPOSURE_CUTOFF
    )
    {
      // try to find the datapoint in the exposure map
      ExposureMap::const_iterator itr_first( EXPOSURE_MAP.Find( LOCATOR));

      // true if the data point is not found in the exposure map
      if( itr_first == EXPOSURE_MAP.End())
      {
        BCL_MessageDbg( "could not find " + LOCATOR->GetIdentification());
        return util::GetUndefinedDouble();
      }

      // get the average exposure for the current locator
      const double mean_exposure( math::Statistics::Mean( itr_first->second.Begin(), itr_first->second.End()));

      BCL_MessageDbg
      (
        "mean exposure for " + LOCATOR->GetIdentification() + " is " + util::Format()( mean_exposure)
      );

      // percent the mean exposure is of the desired exposure cutoff
      const double percent_exposure( ( mean_exposure - EXPOSURE_CUTOFF) / EXPOSURE_CUTOFF);

      // threshold for how much larger the mean exposure can be than the desired exposure cutoff
      // ( as a % of desired cutoff) before maximum penalty is given
      static const double transition_amount( 0.5);

      // the max score i.e. worst score
      static const double max_penalty( 1.0);

      // the most favorable score
      static const double best_score( 0);

      // true if mean exposure is more than allowed by transition
      if( percent_exposure >= transition_amount)
      {
        // return max penalty score of max_penalty
        return max_penalty;
      }

      // true if mean exposure is within the transition region
      if( percent_exposure < transition_amount && mean_exposure > EXPOSURE_CUTOFF)
      {
        const double score
        (
          math::TrigonometricTransition
          (
            EXPOSURE_CUTOFF, //< x value of start of transition
            EXPOSURE_CUTOFF + transition_amount * EXPOSURE_CUTOFF, //< x value at end of transition
            best_score, //< score value at start of transition region
            max_penalty //< score value at end of transition region
          )
          ( mean_exposure) //< current value
        );

        return score;
      }

      // at this point best score can be returned
      return best_score;
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_density_profile_sse_agreement.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "biol/bcl_biol_atom.h"
#include "density/bcl_density_map.h"
#include "density/bcl_density_map_cylindrical.h"
#include "restraint/bcl_restraint_body.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  ///////////
  // enums //
  ///////////

    //! @brief Profile1DType as string
    //! @param PROFILE_1D_TYPE the init type
    //! @return the Profile1DType as string
    const std::string &DensityProfileSSEAgreement::GetProfile1DTypeString( const DensityProfileSSEAgreement::Profile1DType &PROFILE_1D_TYPE)
    {
      static const std::string s_profile_1d_type_strings[] =
      {
        "Angle",
        "Height",
        "Radius",
        GetStaticClassName< Profile1DType>()
      };

      return s_profile_1d_type_strings[ PROFILE_1D_TYPE];
    }

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DensityProfileSSEAgreement::s_Instance
    (
      GetObjectInstances().AddInstance( new DensityProfileSSEAgreement())
    );

    const size_t DensityProfileSSEAgreement::s_NumberWedges = 36;
    const double DensityProfileSSEAgreement::s_UpperRadius = 10.0;
    const double DensityProfileSSEAgreement::s_LowerRadius = 2.0;

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    DensityProfileSSEAgreement::DensityProfileSSEAgreement()
    {
    }

    //! @brief construct from Simulator, density map and body restraints
    //! @param SP_SIMULATOR ShPtr to a simulator
    //! @param DENSITY_MAP the experimental density map
    //! @param BODY_RESTRAINT bodies
    //! @param PROFILE_TYPE 1d profile to be used
    DensityProfileSSEAgreement::DensityProfileSSEAgreement
    (
      const util::ShPtr< density::SimulateInterface> &SP_SIMULATOR,
      const density::Map &DENSITY_MAP,
      const restraint::Body &BODY_RESTRAINT,
      const Profile1DType PROFILE_TYPE
    ) :
      m_Profiles(),
      m_Simulator( SP_SIMULATOR),
      m_HeightResolution( DENSITY_MAP.GetCellWidth().X()),
      m_RadiusResolution( DENSITY_MAP.GetCellWidth().Y()),
      m_ProfileType( PROFILE_TYPE)
    {
      // get all bodies/geometries from restraints
      const util::ShPtr< util::ShPtrVector< assemble::SSEGeometryInterface> > &bodies( BODY_RESTRAINT.GetBody());

      // iterate over all geometries
      for
      (
        util::ShPtrVector< assemble::SSEGeometryInterface>::const_iterator body_itr( bodies->Begin()), body_itr_end( bodies->End());
        body_itr != body_itr_end;
        ++body_itr
      )
      {
        // create cylindrical map from current body and given density map
        const density::MapCylindrical density_map
        (
          **body_itr,
          DENSITY_MAP,
          m_HeightResolution,
          m_RadiusResolution,
          s_NumberWedges,
          s_UpperRadius
        );

        // from cylindrical density map, histogram is created representing the profile with option to select histogram type
        math::Histogram profile;
        switch( m_ProfileType)
        {
          case e_Angle:
            profile = density_map.OneDProfileAngle( s_LowerRadius, s_UpperRadius);
            break;
          case e_Height:
            profile = density_map.OneDProfileHeight( s_LowerRadius, s_UpperRadius);
            break;
          case e_Radius:
            profile = density_map.OneDProfileRadius( s_LowerRadius, s_UpperRadius);
            break;
          case s_NumberProfile1DTypes:
            break;
        }

        // insert profile
        m_Profiles[ util::SiPtr< const assemble::SSEGeometryInterface>( *body_itr)] = profile;
      }
    }

    //! @brief Clone function
    //! @return pointer to new DensityProfileSSEAgreement
    DensityProfileSSEAgreement *DensityProfileSSEAgreement::Clone() const
    {
      return new DensityProfileSSEAgreement( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DensityProfileSSEAgreement::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get scheme
    //! @return scheme
    const std::string &DensityProfileSSEAgreement::GetScheme() const
    {
      return GetProfile1DTypeString( m_ProfileType);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator() takes a BODY and an SSE and compares their profiles
    //! @param BODY the density rod that is occupied by the given SSE
    //! @param SECONDAY_STRUCTURE_ELEMENT the secondary structure that was assigned to that density rod
    //! @return return a double which is the agreement of the rod with the SSE
    double DensityProfileSSEAgreement::operator()
    (
      const assemble::SSEGeometryInterface &BODY,
      const assemble::SSE &SECONDAY_STRUCTURE_ELEMENT
    ) const
    {
      // simulate density for that sse using m_Simulator
      const density::Map sse_density_map( m_Simulator->operator()( SECONDAY_STRUCTURE_ELEMENT.GetAtoms()));

      // calculate profile for that sse
      const density::MapCylindrical sse_map_cylindrical
      (
        BODY,
        sse_density_map,
        m_HeightResolution,
        m_RadiusResolution,
        s_NumberWedges,
        s_UpperRadius
      );

      // from SSE, histogram is created representing the profile with option to select histogram type
      math::Histogram sse_profile;
      switch( m_ProfileType)
      {
        case e_Angle:
          sse_profile = sse_map_cylindrical.OneDProfileAngle( s_LowerRadius, s_UpperRadius);
          break;
        case e_Height:
          sse_profile = sse_map_cylindrical.OneDProfileHeight( s_LowerRadius, s_UpperRadius);
          break;
        case e_Radius:
          sse_profile = sse_map_cylindrical.OneDProfileRadius( s_LowerRadius, s_UpperRadius);
          break;
        case s_NumberProfile1DTypes:
          break;
      }

      // find profile for density rod (second or first)
      storage::Map< util::SiPtr< const assemble::SSEGeometryInterface>, math::Histogram>::const_iterator itr( m_Profiles.Find( util::SiPtr< const assemble::SSEGeometryInterface>( BODY)));
      BCL_Assert( itr != m_Profiles.End(), "given density rod was not given to initialization");
      const math::Histogram &rod_profile( itr->second);

      // calculate the ccc
      const double ccc
      (
        CCC
        (
          sse_profile.GetHistogram().Begin(), sse_profile.GetHistogram().End(),
          rod_profile.GetHistogram().Begin(), rod_profile.GetHistogram().End()
        )
      );

      // return the CCC between the profiles
      return -ccc;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DensityProfileSSEAgreement::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Profiles, ISTREAM);
      io::Serialize::Read( m_Simulator, ISTREAM);
      io::Serialize::Read( m_HeightResolution, ISTREAM);
      io::Serialize::Read( m_RadiusResolution, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DensityProfileSSEAgreement::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Profiles        , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Simulator       , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_HeightResolution, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_RadiusResolution, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculate the CCC between two arrays of doubles
    //! @param BEG_PTR_A
    //! @param END_PTR_A
    //! @param BEG_PTR_B
    //! @param END_PTR_B
    //! @return the cross correlation coefficient between range a and b
    double DensityProfileSSEAgreement::CCC( const double *BEG_PTR_A, const double *END_PTR_A, const double *BEG_PTR_B, const double *END_PTR_B)
    {
      // number of voxels that are above the CONTOUR_LEVEL in the experimental (this) density map
      size_t count_voxel( 0);
      double sum_sim( 0);
      double sum_exp( 0);
      double sum_sim2( 0);
      double sum_exp2( 0);
      double sum_exp_sim( 0);

      // iterate over experimental and simulated sub tensor
      for
      (
        const double *exp( BEG_PTR_A), *exp_end( END_PTR_A), *sim( BEG_PTR_B), *sim_end( END_PTR_B);
        exp != exp_end && sim != sim_end;
        ++exp, ++sim
      )
      {
        const double sim_int( *sim);
        const double exp_int( *exp);

        ++count_voxel;
        sum_exp += exp_int;
        sum_sim += sim_int;
        sum_exp_sim += exp_int * sim_int;
        sum_exp2 += math::Sqr( exp_int);
        sum_sim2 += math::Sqr( sim_int);
      }

      // calculate actual correlation
      double correlation( count_voxel * sum_exp_sim - sum_exp * sum_sim);
      correlation /= math::Sqrt( count_voxel * sum_exp2 - math::Sqr( sum_exp)) * math::Sqrt( count_voxel * sum_sim2 - math::Sqr( sum_sim));

      // end
      return correlation;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_energy_distribution.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "io/bcl_io_file.h"
#include "linal/bcl_linal_vector_operations.h"
#include "math/bcl_math_bicubic_spline.h"
#include "math/bcl_math_cubic_spline_damped.h"
#include "math/bcl_math_histogram.h"
#include "math/bcl_math_histogram_2d.h"
#include "math/bcl_math_smooth_data.h"
#include "math/bcl_math_statistics.h"
#include "math/bcl_math_tricubic_spline.h"
#include "score/bcl_score_aa_pair_distance.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! propensity for nn-observed features
    const double EnergyDistribution::s_NonObservedPropensity = 1.0;

    //! minimal count for aa environment potential to be considered
    const double EnergyDistribution::s_MinimalEnvironenmentBinCount = 2.5;

  ////////////////
  // operations //
  ////////////////

    //! @brief converts a given histogram into an energy distribution
    //! @param HISTOGRAM
    //! @return cubic spline with linear continuation
    math::CubicSplineDamped EnergyDistribution::EnergyfunctionFromHistogram
    (
      const math::Histogram &HISTOGRAM, const double PSEUDOCOUNT
    )
    {
      // copy the histogram
      math::Histogram current( HISTOGRAM);
      current.RemoveBinsAfterIndex( current.GetIndexOfLastInformationContainingBin());

      linal::Vector< double> counts( current.GetHistogram());
      const linal::Vector< double> bins( current.GetBinning());

      // add pseudocount
      counts += PSEUDOCOUNT;

      // calculate propensities
      counts.SetToSum( counts.Sum());

      // logarithmize
      for( double *ptr = counts.Begin(), *ptr_end( counts.End()); ptr != ptr_end; ptr++)
      {
        ( *ptr) = -log( *ptr);
      }

      math::CubicSplineDamped energydistribution;
      energydistribution.Train
                         (
                           bins( 0),
                           current.GetBinSize(),
                           counts,
                           0.0,
                           0.0
                         );

      // end
      return energydistribution;
    }

    //! @brief create a bicubicspline for the energy distribution derived for angle/distance statistics by symmetrization
    //! @param ANGLE_DISTANCE_DISTRIBUTION Histogram2D that contains the counts for angle distance distribution
    //! @param DISTANCE_RANGE distance range for given contact type to be used
    //! @return BicubicSpline for given ContactType's angle distance distribution
    math::BicubicSpline EnergyDistribution::SSEPackingSymmetrize
    (
      const math::Histogram2D &ANGLE_DISTANCE_DISTRIBUTION,
      const math::Range< double> &DISTANCE_RANGE
    )
    {
      //cutoff values for different types of sse_interaction represented by the row in the histogram - angle_distance_count
      const std::pair< size_t, size_t> lower_upper_distance_cutoff
      (
        size_t( std::floor( DISTANCE_RANGE.GetMin() / ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().Second())),
        size_t( std::ceil( DISTANCE_RANGE.GetMax() / ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().Second()))
      );

      const linal::Matrix< double> &angle_distance_counts( ANGLE_DISTANCE_DISTRIBUTION.GetHistogram());
      const storage::VectorND< 2, linal::Vector< double> > angle_distance_bins
      (
        ANGLE_DISTANCE_DISTRIBUTION.GetBinningXY()
      );

      // create vectors to sum angle counts and distance counts
      linal::Vector< double> angle_counts( angle_distance_counts.GetNumberCols());
      linal::Vector< double> distance_counts( angle_distance_counts.GetNumberRows(), double( s_PseudoCount));

      //add up all counts for each distance bin and for each angle bin in the given distance range
      for( size_t i( 0); i < angle_distance_counts.GetNumberRows(); ++i)
      {
        for( size_t j( 0); j < angle_distance_counts.GetNumberCols(); j++)
        {
          angle_counts( j) += angle_distance_counts( i, j);
          distance_counts( i) += angle_distance_counts( i, j);
        }
      }

      // normalize distance distribution by distance^2
      distance_counts /= angle_distance_bins.Second();

      // create a matrix with two rows margin to store the actual energy distribution
      linal::Matrix< double> energydistributionmatrix
      (
        lower_upper_distance_cutoff.second - lower_upper_distance_cutoff.first + 4, angle_distance_counts.GetNumberCols()
      );

      // multiply counts of distance and angle( plus pseudocount) into the energydistributionmatrix
      double energysum( 0);
      for( size_t row( 2); row < energydistributionmatrix.GetNumberRows() - 2; ++row)
      {
        for( size_t col( 0); col < energydistributionmatrix.GetNumberCols(); ++col)
        {
          energydistributionmatrix( row, col) =
            distance_counts( lower_upper_distance_cutoff.first + row - 2) * ( angle_counts( col) + 1.0);
          energysum += energydistributionmatrix( row, col);
        }
      }

      double completesum( energysum);
      //multiply counts of distance and angle( plus pseudo count) into the complete sum
      for( size_t col( 0); col < energydistributionmatrix.GetNumberCols(); ++col)
      {
        for( size_t row( lower_upper_distance_cutoff.second); row < angle_distance_counts.GetNumberRows(); ++row)
        {
          completesum += distance_counts( row) * ( angle_counts( col) + 1.0);
        }
      }

      completesum /= energydistributionmatrix.GetNumberCols() * angle_distance_counts.GetNumberRows();
      energydistributionmatrix /= completesum;

      //-log of every bin to have the energy
      for
      (
        double
          *ptr( energydistributionmatrix.Begin() + energydistributionmatrix.GetNumberCols()),
          *ptr_end( energydistributionmatrix.End() - energydistributionmatrix.GetNumberCols());
        ptr != ptr_end; ++ptr)
      {
        *ptr = -log( *ptr);
      }

      //set the second and the row bfore last to the average of the neigbouring lines
      energydistributionmatrix.ReplaceRow
      (
        0,
        linal::Vector< double>( energydistributionmatrix.GetNumberCols(), double( 3.0))
      );
      energydistributionmatrix.ReplaceRow
      (
        1,
        ( energydistributionmatrix.GetRow( 2) + energydistributionmatrix.GetRow( 0)) / 2.0
      );
      energydistributionmatrix.ReplaceRow
      (
        energydistributionmatrix.GetNumberRows() - 2,
        energydistributionmatrix.GetRow( energydistributionmatrix.GetNumberRows() - 3) / 2.0
      );

      //instantiate Spline
      math::BicubicSpline energydistribution;
      const math::SplineBorderType borderflags[ 2] = { math::e_FirstDer, math::e_Periodic};
      const double start[ 2] =
      {
          angle_distance_bins.Second()( lower_upper_distance_cutoff.first)
        - 2 * ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().Second(),
          angle_distance_bins.First()( 0)
      };
      const double binsize[ 2] =
      {
        ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().Second(), ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().First()
      };
      const bool lincont[ 2] = { true, false};
      const storage::Pair< double, double> firstorderder[ 2] =
      {
        storage::Pair< double, double>( -1, 0), storage::Pair< double, double>( 0, 0)
      };
      energydistribution.Train( borderflags, start, binsize, energydistributionmatrix, lincont, firstorderder);

      // end
      return energydistribution;
    }

    //! @brief creates a bicubic spline for the energy distribution derived for EPR distance potentials
    //! @param HISTOGRAM histogram containing the counts for the distance exposure distributions
    //! @param DISTANCE_RANGE distance range for given contact type to be used
    //! @return bicubic spline for the given EPR distance distributions
    math::BicubicSpline EnergyDistribution::EPRDistance
    (
      const math::Histogram2D &HISTOGRAM,
      const math::Range< double> &DISTANCE_RANGE
    )
    {
      const linal::Matrix< double> counts( HISTOGRAM.GetHistogram());
      const storage::VectorND< 2, linal::Vector< double> > bins( HISTOGRAM.GetBinningXY());

      // create the energy function
      const math::SplineBorderType borderflags[ 2] = { math::e_FirstDer, math::e_Periodic};
      const double start[ 2] = { bins.Second()( 2) - 2 * HISTOGRAM.GetBinSizeXY().Second(), bins.First()( 0)};
      const double binsize[ 2] = { HISTOGRAM.GetBinSizeXY().Second(), HISTOGRAM.GetBinSizeXY().First()};
      const bool lincont[ 2] = { true, false};
      const storage::Pair< double, double> firstorderder[ 2] =
        {
          storage::Pair< double, double>( -1, 0),
          storage::Pair< double, double>( 0, 0)
        };
      math::BicubicSpline function;
      function.Train( borderflags, start, binsize, counts, lincont, firstorderder);

      return function;
    }

    //! @brief creates a bicubic spline for the energy distribution derived for contact energy
    //!        multiplies the entries in the associated histogram by the energy for the contact term
    //! @param HISTOGRAM histogram containing the counts for the distance exposure distributions
    //! @param ENERGY energy of the contact
    //! @return bicubic spline for the given EPR distance distributions
    math::TricubicSpline EnergyDistribution::DistanceAngleContactEnergy
    (
      const math::Histogram3D &HISTOGRAM,
      const double &ENERGY
    )
    {
      math::Tensor< double> contact_frequency( HISTOGRAM.GetHistogram());
      if( util::IsDefined( ENERGY))
      {
        for( auto itr( contact_frequency.Begin()), itr_end( contact_frequency.End()); itr != itr_end; ++itr)
        {
          if( *itr < 0.0)
          {
            *itr = 0.0;
          }
        }
        contact_frequency *= ENERGY;
      }
      else
      {
        for( auto itr( contact_frequency.Begin()), itr_end( contact_frequency.End()); itr != itr_end; ++itr)
        {
          if( *itr < 0.0)
          {
            *itr = -1.0;
          }
          else if( *itr > 0.0)
          {
            *itr = 0.0;
          }
        }
      }

      const storage::VectorND< 3, linal::Vector< double> > bins( HISTOGRAM.GetBinningXYZ());

      // create the energy function
      const math::SplineBorderType borderflags[ 2] = { math::e_FirstDer, math::e_FirstDer};
      const double start[ 3] = { bins.First()( 0), bins.Second()( 0), bins.Third()( 0)};
      const double binsize[ 3] = { HISTOGRAM.GetBinSizeXYZ().First(), HISTOGRAM.GetBinSizeXYZ().Second(), HISTOGRAM.GetBinSizeXYZ().Third()};
      const bool lincont[ 3] = { true, true, true};
      const storage::Pair< double, double> firstorderder[ 3] =
      {
        storage::Pair< double, double>( 0, 0),
        storage::Pair< double, double>( 0, 0),
        storage::Pair< double, double>( 0, 0)
      };
      math::TricubicSpline function;
      function.Train( borderflags, start, binsize, contact_frequency, lincont, firstorderder);

      return function;
    }

    //! @brief create a bicubicspline for the energy distribution derived for angle/distance statistics
    //! @param ANGLE_DISTANCE_DISTRIBUTION Histogram2D that contains the counts for angle distance distribution
    //! @param DISTANCE_RANGE distance range for given contact type to be used
    //! @return BicubicSpline for given ContactType's angle distance distribution
    math::BicubicSpline EnergyDistribution::SSEPacking2D
    (
      const math::Histogram2D &ANGLE_DISTANCE_DISTRIBUTION,
      const math::Range< double> &DISTANCE_RANGE
    )
    {
      //cutoff values for different types of sse_interaction represented by the row in the histogram - angle_distance_count
      const std::pair< size_t, size_t> lower_upper_distance_cutoff_index
      (
        size_t( std::floor( ( DISTANCE_RANGE.GetMin() - ANGLE_DISTANCE_DISTRIBUTION.GetBoundariesY().First()) / ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().Second())),
        size_t( std::ceil( ( DISTANCE_RANGE.GetMax() - ANGLE_DISTANCE_DISTRIBUTION.GetBoundariesY().First()) / ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().Second()))
      );

      linal::Matrix< double> angle_distance_counts( ANGLE_DISTANCE_DISTRIBUTION.GetHistogram());
      const storage::VectorND< 2, linal::Vector< double> > angle_distance_bins
      (
        ANGLE_DISTANCE_DISTRIBUTION.GetBinningXY()
      );

      // variable that adds up all counts
      double integral( 0);

      //add up all counts for each distance bin and for each angle bin in the given distance range
      for( size_t i( lower_upper_distance_cutoff_index.first); i < lower_upper_distance_cutoff_index.second; ++i)
      {
        for( size_t j( 0); j < angle_distance_counts.GetNumberCols(); j++)
        {
          double &current_value( angle_distance_counts( i, j));
          // add a pseudo count
          current_value += s_PseudoCount;
          // normalize by the distance
          current_value /= angle_distance_bins.Second()( i);
          // add that value to the integral
          integral += current_value;
        }
      }

      // normalize
      angle_distance_counts *= angle_distance_counts.GetNumberCols() * angle_distance_counts.GetNumberRows() / integral;

      // initialize matrix with two row margin
      linal::Matrix< double> energydistributionmatrix
      (
        lower_upper_distance_cutoff_index.second - lower_upper_distance_cutoff_index.first + 4,
        angle_distance_bins.First().GetSize(),
        double( 0.0)
      );

      // copy the values to the matrix with the 2 row margin on each side
      for( size_t i( lower_upper_distance_cutoff_index.first); i < lower_upper_distance_cutoff_index.second; ++i)
      {
        for( size_t j( 0); j < angle_distance_counts.GetNumberCols(); j++)
        {
          energydistributionmatrix( i + 2 - lower_upper_distance_cutoff_index.first, j) = angle_distance_counts( i, j);
        }
      }

      // repulsion
      static const double s_default_repulsion( 7.0);

      //-log of every bin to get the energy
      for
      (
        double
          *ptr( energydistributionmatrix.Begin() + 2 * energydistributionmatrix.GetNumberCols()),
          *ptr_end( energydistributionmatrix.End() - 2 * energydistributionmatrix.GetNumberCols());
        ptr != ptr_end;
        ++ptr
      )
      {
        *ptr = -log( *ptr);
      }

      //set the second and the row before last to the average of the neighboring lines
      energydistributionmatrix.ReplaceRow
                               ( 0, linal::Vector< double>( energydistributionmatrix.GetNumberCols(), s_default_repulsion));
      energydistributionmatrix.ReplaceRow
                               ( 1, ( energydistributionmatrix.GetRow( 2) + energydistributionmatrix.GetRow( 0)) / 2.0);
      energydistributionmatrix.ReplaceRow
                               (
                                 energydistributionmatrix.GetNumberRows() - 1,
                                 linal::Vector< double>( energydistributionmatrix.GetNumberCols(), double( 0.0))
                               );
      energydistributionmatrix.ReplaceRow
                               (
                                 energydistributionmatrix.GetNumberRows() - 2,
                                 energydistributionmatrix.GetRow( energydistributionmatrix.GetNumberRows() - 3) / 2.0
                               );

      //instantiate Spline
      math::BicubicSpline energydistribution;
      const math::SplineBorderType           borderflags[ 2] = { math::e_FirstDer, math::e_Periodic};
      const double                                 start[ 2] =
        {
            angle_distance_bins.Second()( lower_upper_distance_cutoff_index.first)
          - 2 * ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().Second(),
            angle_distance_bins.First()( 0)
        };
      const double                               binsize[ 2] =
        {
          ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().Second(),
          ANGLE_DISTANCE_DISTRIBUTION.GetBinSizeXY().First()
        };
      const bool                                 lincont[ 2] = { true, false};
      const storage::Pair< double, double> firstorderder[ 2] =
        {
          storage::Pair< double, double>( -1, 0),
          storage::Pair< double, double>( 0, 0)
        };
      energydistribution.Train( borderflags, start, binsize, energydistributionmatrix, lincont, firstorderder);

      // end
      return energydistribution;
    }

    //! create a cubic spline for the potential between a pair of amino acids derived form statistics
    //! @param AA_PAIR_DISTANCE_DISTRIBUTION the distribution the energy is generated for
    //! @param BACKGROUND_DISTRIBUTION the background probability
    //! @param NORMALIZE_BY_BACKGROUND normalize by given background - otherwise each bin has a propensity purely derived from this distribution
    math::CubicSplineDamped EnergyDistribution::AAPairPotential
    (
      const math::Histogram &AA_PAIR_DISTANCE_DISTRIBUTION,
      const math::Histogram &BACKGROUND_DISTRIBUTION,
      const bool NORMALIZE_BY_BACKGROUND
    )
    {
      linal::Vector< double> aa_distance_counts( AA_PAIR_DISTANCE_DISTRIBUTION.GetHistogram());
      const linal::Vector< double> distance_bins( AA_PAIR_DISTANCE_DISTRIBUTION.GetBinning());

      linal::Vector< double> background_distribution( BACKGROUND_DISTRIBUTION.GetHistogram());

      const size_t usedbins( 20);

      std::fill( aa_distance_counts.Begin() + usedbins, aa_distance_counts.End(), double( 0.0));
      std::fill( background_distribution.Begin() + usedbins, background_distribution.End(), double( 0.0));
      aa_distance_counts.SetToSum( 1.0);
      if( !NORMALIZE_BY_BACKGROUND)
      {
        // fill background with r^2
        for( size_t dist( 0); dist < background_distribution.GetSize(); ++dist)
        {
          background_distribution( dist) = math::Sqr( 0.5 + dist);
        }
      }
      background_distribution.SetToSum( 1.0);

      // divide each count in bin by the background distribution for that bin
      size_t i( 0);
      for
      (
        double
          *bg_counts( background_distribution.Begin()), *bg_counts_end( background_distribution.End()),
          *counts( aa_distance_counts.Begin()), *counts_end( aa_distance_counts.End());
        counts != counts_end && bg_counts != bg_counts_end && i < usedbins;
        ++counts, ++bg_counts, ++i
      )
      {
        if( *bg_counts > double( 0))
        {
          // divide by background probability
          *counts /= *bg_counts;
        }

        // add pseudo propensity for empty bins defining the repulsion
        *counts += 0.00000001;
      }

      linal::Vector< double> energydistributionvector( usedbins, aa_distance_counts.Begin());

      // -log of every bin to have the energy
      for( double *ptr = energydistributionvector.Begin(), *ptr_end( energydistributionvector.End()); ptr != ptr_end; ptr++)
      {
        ( *ptr) = -log( *ptr);
      }

      // last value set to zero
      *( energydistributionvector.End() - 1) = 0;

      math::CubicSplineDamped energydistribution;
      energydistribution.Train
                         (
                           AA_PAIR_DISTANCE_DISTRIBUTION.GetBinning().First(),
                           AA_PAIR_DISTANCE_DISTRIBUTION.GetBinSize(),
                           energydistributionvector,
                           0,
                           0
                         );

      // end
      return energydistribution;
    }

    //! @brief create a cubic spline for an environment potential
    //! @param AA_ENV_DISTRIBUTION the distribution of exposure measure
    //! @param BACKGROUND_DISTRIBUTION the background distribution for that exposure measure
    //! @param NORMALIZE_BY_BACKGROUND normalize by given background - otherwise each bin has a propensity purely derived from this distribution
    //! @return a CubicSpline that represents the energy distribution
    math::CubicSplineDamped EnergyDistribution::AAEnvironmentPotential
    (
      const math::Histogram &AA_ENV_DISTRIBUTION,
      const math::Histogram &BACKGROUND_DISTRIBUTION,
      const bool NORMALIZE_BY_BACKGROUND
    )
    {
      // binning for the environment potential
      const linal::Vector< double> env_bins( AA_ENV_DISTRIBUTION.GetBinning());

      // actual counts
      linal::Vector< double> aa_env_counts( AA_ENV_DISTRIBUTION.GetHistogram());
      aa_env_counts.SetToSum( 1.0);

      // background
      linal::Vector< double> background_distribution( BACKGROUND_DISTRIBUTION.GetHistogram());
      background_distribution.SetToSum( 1.0);

      // background should not be used - assume each bin is equally probable
      if( !NORMALIZE_BY_BACKGROUND)
      {
        background_distribution = 1.0 / double( background_distribution.GetSize());
      }

      // divide each count in bin by the background distribution for that bin
      for
      (
        double
          *bg_counts( background_distribution.Begin()), *bg_counts_end( background_distribution.End()),
          *counts( aa_env_counts.Begin()), *counts_end( aa_env_counts.End());
        counts != counts_end && bg_counts != bg_counts_end;
        ++counts, ++bg_counts
      )
      {
        if( *counts > 0.0)
        { // divide by background probability
          *counts /= *bg_counts;
        }
        // no background, so energy should be 0 by setting propensity to 1
        else
        {
          *counts = s_NonObservedPropensity;
        }

        //-log of every bin to have the energy
        *counts = -log( *counts);
      }

      math::CubicSplineDamped energydistribution;
      energydistribution.Train
                         (
                           env_bins( 0),
                           AA_ENV_DISTRIBUTION.GetBinSize(),
                           math::SmoothData::SmoothVector( aa_env_counts, 0.5, true),
                           0,
                           0
                         );

      return energydistribution;
    }

    //! create a Map for each aa type with its environment potential
    storage::Map< biol::AAType, math::CubicSplineDamped>
    EnergyDistribution::AAEnvironmentPotential
    (
      const storage::Vector< math::Histogram> &HISTOGRMAS_AA
    )
    {
      storage::Vector< math::Histogram> histograms( HISTOGRMAS_AA);

      // sum all histograms
      math::Histogram total_sum_histograms;
      for
      (
        storage::Vector< math::Histogram>::iterator
          itr( histograms.Begin()), itr_end( histograms.Begin() + biol::AATypes::s_NumberStandardAATypes);
        itr != itr_end;
        ++itr
      )
      {
        // add pseudo count and normalize the current histogram in order to remove bias to certain aa types
        math::Histogram &current_histogram( *itr);

        // find last information containing bin
        current_histogram.GetIndexOfLastInformationContainingBin( 2.5);
        current_histogram.ResetBinsAfterIndex( current_histogram.GetIndexOfLastInformationContainingBin( 2.5));

        current_histogram.Normalize();

        BCL_Assert
        (
          total_sum_histograms.Combine( current_histogram),
          "unable to combine histograms of different parameters"
        );
      }

      storage::Map< biol::AAType, math::CubicSplineDamped> potentials;

//      if( util::GetMessenger().IsSmallerEqualCurrentMessageLevel( util::Message::e_Debug))
//      {
//        io::OFStream write;
//        io::File::MustOpenOFStream( write, "aa_neighbor_count_background.gnuplot");
//        math::GnuplotHeatmap heatmap;
//        heatmap.SetFromHistogram( total_sum_histograms, false, false);
//        heatmap.SetTitleAndLabel( "amino acid neighbor count background", "neighbor count", "", "p");
//        heatmap.SetPixelAndRatio( 1080, 800, -2.0);
//        heatmap.SetFont( "arialbd", 20);
//        heatmap.SetRotationXTics( 90.0);
//        heatmap.SetFilename( "aa_neighbor_count_background");
//        heatmap.WriteScript( write);
//        io::File::CloseClearFStream( write);
//      }

      // derive potential for each amino acid
      for
      (
        biol::AATypes::const_iterator
          aa_itr( biol::GetAATypes().Begin()),
          aa_itr_end( biol::GetAATypes().GetEnumIteratorFromIndex( biol::AATypes::s_NumberStandardAATypes));
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        potentials[ *aa_itr] = AAEnvironmentPotential( histograms( *aa_itr), total_sum_histograms, true);
      }

      // end
      return potentials;
    }

    //! create a vector for each membrane region with a vector for each amino acid for the membrane environment potential
    storage::Map< biol::EnvironmentType, storage::Map< biol::AAType, math::CubicSplineDamped> >
    EnergyDistribution::AAMembraneEnvironmentPotential
    (
      const storage::Vector< storage::Vector< math::Histogram> > &HISTOGRAMS_MEMBRANE_AA
    )
    {
      // number of bins
      const math::Histogram &first_histogram( HISTOGRAMS_MEMBRANE_AA( 0)( 0));

      // counts of each amino acid in each region and in their bins
      storage::Vector< storage::Vector< linal::Vector< double> > >
        region_counts
        (
          HISTOGRAMS_MEMBRANE_AA.GetSize(),
          storage::Vector< linal::Vector< double> >( HISTOGRAMS_MEMBRANE_AA( 0).GetSize())
        );

      // collect the sum of all counts in each region over all aas
      linal::Vector< double> region_sum( biol::GetEnvironmentTypes().GetEnumCount());

      // total number of amino acids
      storage::Vector< double> aminoacid_counts( biol::GetAATypes().GetEnumCount(), double( 0.0));

      for
      (
        storage::Vector< biol::EnvironmentType>::const_iterator
          env_itr( biol::GetEnvironmentTypes().GetReducedTypes().Begin()),
          env_itr_end( biol::GetEnvironmentTypes().GetReducedTypes().End());
        env_itr != env_itr_end; ++env_itr
      )
      {
        for
        (
          biol::AATypes::const_iterator
            aa_itr( biol::GetAATypes().Begin()),
            aa_itr_end( biol::GetAATypes().GetEnumIteratorFromIndex( biol::AATypes::s_NumberStandardAATypes));
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          region_counts( *env_itr)( *aa_itr) =
            HISTOGRAMS_MEMBRANE_AA( *env_itr)( *aa_itr).GetHistogram();
          //add pseudo count
          region_counts( *env_itr)( *aa_itr) += double( s_PseudoCount);
          //sum up sums for each aatype
          region_sum( *env_itr) += region_counts( *env_itr)( *aa_itr).Sum();
        }

        //divide by the sum in all regions by number_bins for the environment and 20 different aatypes
        for
        (
          biol::AATypes::const_iterator aa_itr( biol::GetAATypes().Begin()),
            aa_itr_end( biol::GetAATypes().GetEnumIteratorFromIndex( biol::AATypes::s_NumberStandardAATypes));
          aa_itr != aa_itr_end; ++aa_itr
        )
        {
          region_counts( *env_itr)( *aa_itr) /=
            ( region_sum( *env_itr) / double( first_histogram.GetNumberOfBins()) / double( 20));
        }

        //add up the sum of the aas in all regions
        for
        (
          biol::AATypes::const_iterator aa_itr( biol::GetAATypes().Begin()),
            aa_itr_end( biol::GetAATypes().GetEnumIteratorFromIndex( biol::AATypes::s_NumberStandardAATypes));
          aa_itr != aa_itr_end; ++aa_itr
        )
        {
          //sum up sums for each aatype
          aminoacid_counts( *aa_itr) += region_counts( *env_itr)( *aa_itr).Sum();
        }
      }

      for
      (
        storage::Vector< biol::EnvironmentType>::const_iterator
          env_itr( biol::GetEnvironmentTypes().GetReducedTypes().Begin()),
          env_itr_end( biol::GetEnvironmentTypes().GetReducedTypes().End());
        env_itr != env_itr_end; ++env_itr
      )
      {
        // Divide by the sum of the aminoacids in all regions
        for
        (
          biol::AATypes::const_iterator aa_itr( biol::GetAATypes().Begin()),
            aa_itr_end( biol::GetAATypes().GetEnumIteratorFromIndex( biol::AATypes::s_NumberStandardAATypes));
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          //divide by the total number of one aatype in all regions, by the number_bins and 3 for 3 regions where the counts for one aa has been summed up
          region_counts( *env_itr)( *aa_itr) /=
            aminoacid_counts( *aa_itr) / double( first_histogram.GetNumberOfBins()) / double( biol::GetEnvironmentTypes().GetReducedTypes().GetSize());

          //-log to yield the energy
          for
          (
            double *ptr( region_counts( *env_itr)( *aa_itr).Begin()),
              *ptr_end( region_counts( *env_itr)( *aa_itr).End());
            ptr != ptr_end; ++ptr
          )
          {
            // logarithmize
            *ptr = -log( *ptr);
          }
        }
      }

      //construct the cubic splines and train them for each amino acid
      storage::Map< biol::EnvironmentType, storage::Map< biol::AAType, math::CubicSplineDamped> > energy_maps;

      for
      (
        storage::Vector< biol::EnvironmentType>::const_iterator
          env_itr( biol::GetEnvironmentTypes().GetReducedTypes().Begin()),
          env_itr_end( biol::GetEnvironmentTypes().GetReducedTypes().End());
        env_itr != env_itr_end; ++env_itr
      )
      {
        for
        (
          biol::AATypes::const_iterator
            aa_itr( biol::GetAATypes().Begin()),
             aa_itr_end( biol::GetAATypes().GetEnumIteratorFromIndex( biol::AATypes::s_NumberStandardAATypes));
           aa_itr != aa_itr_end;
           ++aa_itr
        )
        {
          energy_maps[ *env_itr][ *aa_itr].Train
          (
            first_histogram.GetBinning()( 0),           // start
            first_histogram.GetBinSize(),               // bin size
            math::SmoothData::SmoothVector( region_counts( *env_itr)( *aa_itr), 0.5, true), // data
            0,      // first derivative at left border
            0       // first derivative at right border
          );
        }
      }

      // end
      return energy_maps;
    }

    math::CubicSplineDamped EnergyDistribution::LoopLengthDistancePotential( const math::Histogram &LOOPLENGTHDISTRIBUTION)
    {
      linal::Vector< double> loop_length_counts( LOOPLENGTHDISTRIBUTION.GetHistogram());

      //search for the first position where the count is zero which means this is a forbidden loop conformation
      size_t index( 0);
      for( ; index < loop_length_counts.GetSize(); ++index)
      {
        if( index > 10 && loop_length_counts( index) < 1)
        {
          break;
        }
      }

      linal::Vector< double> loop_energy_distribution( index, loop_length_counts.Begin());

      //add pseudo count
      loop_energy_distribution += double( s_PseudoCount);

      //divide by the sum over i, so that the total sum is equal to the number of bins
      loop_energy_distribution.SetToSum( index);

      //-log of every bin to have the energy
      for( double *ptr = loop_energy_distribution.Begin(); ptr != loop_energy_distribution.End(); ++ptr)
      {
        *ptr = -log( *ptr);
      }

//      BCL_MessageStd( util::Format()( loop_energy_distribution));

      math::CubicSplineDamped energydistribution;
      energydistribution.Train
      (
        LOOPLENGTHDISTRIBUTION.GetBoundaries().First() + 0.5 * LOOPLENGTHDISTRIBUTION.GetBinSize(),
        LOOPLENGTHDISTRIBUTION.GetBinSize(),
        loop_energy_distribution,
        1,
        1
      );

      return energydistribution;
    }

    //! remove the bins from the end, that are empty in all given histograms
    //! @param HISTOGRAMS list of histograms
    //! @return number of removed bins
    void EnergyDistribution::RemoveAdditionalEmptyBinsExceptOne( util::SiPtrVector< math::Histogram> &HISTOGRAMS)
    {
      size_t number_remaining_bins( 0);

      // determine the highest last information containing bin within all histograms
      for( util::SiPtrVector< math::Histogram>::const_iterator itr( HISTOGRAMS.Begin()), itr_end( HISTOGRAMS.End());
        itr != itr_end;
        ++itr)
      {
        number_remaining_bins = std::max( number_remaining_bins, ( *itr)->GetIndexOfLastInformationContainingBin());
      }

      // leave one empty bin for repulsion term
      ++number_remaining_bins;

      for
      (
        util::SiPtrVector< math::Histogram>::iterator itr( HISTOGRAMS.Begin()), itr_end( HISTOGRAMS.End());
        itr != itr_end;
        ++itr
      )
      {
        ( *itr)->RemoveBinsAfterIndex( number_remaining_bins);
      }
    }

    //! create a cubic spline for loop length potentials derived form statistics
    math::BicubicSpline
    EnergyDistribution::LoopLengthDistancePotential
    (
      const math::Histogram2D &LOOPLENGTHDISTRIBUTION,
      const size_t MAX_RESIDUES
    )
    {
      // calculate the number of bins necessary from the LOOPLENGTHDISTRIBUTION
      // x-number of residues
      // y-euclidean distance
      const size_t number_cols
                   (
                     std::min
                     (
                       size_t( MAX_RESIDUES / LOOPLENGTHDISTRIBUTION.GetBinSizeXY().First()),
                       LOOPLENGTHDISTRIBUTION.GetNumberOfBinsX()
                     ) + 2
                   );

      // get a submatrix including only the number_cols determined by the MAX_RESIDUES - numbercols-1 is necessary since
      // GetColSubMatrix includes the passed COL
      linal::Matrix< double> distribution
      (
        LOOPLENGTHDISTRIBUTION.GetHistogram().CreateSubMatrix
        (
          LOOPLENGTHDISTRIBUTION.GetHistogram().GetNumberRows(),
          number_cols
        )
      );

      // determine the number of rows by checking each column for its first 0 after a value different from 0
      // (to skip the first 0's in a column
      size_t number_rows( 0);
      //iterate over all cols
      for( size_t col( 0); col < distribution.GetNumberCols(); ++col)
      {
        //initialize current count
        double current_count( distribution( 0, col));
        //iterate over all values in this col
        for( size_t row( 1); row < distribution.GetNumberRows(); ++row)
        {
          //store previous value
          const double previous_count( current_count);
          //store current count
          current_count = distribution( row, col);
          //if current is 0 and previous was not 0 (like at the top at a column)
          if( current_count == 0.0 && previous_count != 0.0)
          {
            //check that row is larger than already found number_rows
            if( row > number_rows)
            {
              //store highest number_row so far
              number_rows = row;
            }
            //fill the rest of the column with 0.0
            while( row < distribution.GetNumberRows())
            {
              distribution( row, col) = 0.0;
              ++row;
            }
            break;
          }
        }
      }

      //add 1 to number rows, since the best row found is 1 smaller than the number for rows to be considered
      ++number_rows;

      // smoothing is neccessary since there might be certain seq distances that do not occur
      // linal::Matrix< double> smoothed_distribution( math::SmoothData::SmoothMatrix( distribution.GetRowSubMatrix( 0, number_rows - 1), 0.5, false));
      linal::Matrix< double> smoothed_distribution( distribution.CreateSubMatrix( number_rows - 1, distribution.GetNumberCols()));
      linal::Vector< double> col_sum( number_cols, double( 0));

      for( size_t col( 0); col < number_cols; ++col)
      {
        double &current_col_sum( col_sum( col));
        for( size_t row( 0); row < number_rows; ++row)
        {
          smoothed_distribution( row, col) += double( 1.0);
          current_col_sum += smoothed_distribution( row, col);
        }
      }

      for( size_t col( 0); col < number_cols; ++col)
      {
        const double current_col_sum( col_sum( col) / number_rows);
        for( size_t row( 0); row < number_rows; ++row)
        {
          //normalize and logarithmize
          smoothed_distribution( row, col) = -log( smoothed_distribution( row, col) / current_col_sum);
        }
      }

//      // replace one before last with half of the previous col and the last col with 0 - so that every number of residues
//      // Extending current energy distribution gets 0 as score
//      smoothed_distribution.ReplaceCol( number_cols - 1, linal::Vector< double>( number_rows, double( 0.0)));
//      smoothed_distribution.ReplaceCol( number_cols - 2, ( smoothed_distribution.GetCol( number_cols - 3) / 2.0));

      //instantiate Spline
      math::BicubicSpline energydistribution;
      const math::SplineBorderType             borderflags[ 2] = { math::e_FirstDer, math::e_FirstDer};
      const double                             start[ 2] = { LOOPLENGTHDISTRIBUTION.GetBoundariesY().First() + 0.5 * LOOPLENGTHDISTRIBUTION.GetBinSizeXY().Second(),
                                                             LOOPLENGTHDISTRIBUTION.GetBoundariesX().First() + 0.5 * LOOPLENGTHDISTRIBUTION.GetBinSizeXY().First()};
      const double                           binsize[ 2] = { LOOPLENGTHDISTRIBUTION.GetBinSizeXY().Second(), LOOPLENGTHDISTRIBUTION.GetBinSizeXY().First()};
      const bool                             lincont[ 2] = { true, true};
      const storage::Pair< double, double> firstorderder[ 2] = { storage::Pair< double, double>( -1, 1), storage::Pair< double, double>( 0, 0)};
      energydistribution.Train( borderflags, start, binsize, smoothed_distribution, lincont, firstorderder);

//      util::Message::SetMessageLevel( util::Message::e_Silent);
//      util::Format format;
//      format.FFP( 7, 3).W( 7);
//
//      std::stringstream stream;
//      stream << util::Format().W( 7)( "smooth") + "\t");
//      for( double residues = 0;  residues < 2 * MAX_RESIDUES; residues += 4)
//      {
//        stream << format( residues) + "\t";
//      }
//      stream << '\n';
//
//      for( double distance = 0; distance < number_rows * 4; distance += 4)
//      {
//        stream << format( distance) + "\t";
//        for( double residues = 0; residues < 2 * MAX_RESIDUES && residues < number_cols * 4; residues += 4)
//        {
//          stream << format( smoothed_distribution( size_t( distance / 4.0), size_t( residues/4.0))) << '\t';
//        }
//        stream << '\n';
//      }
//      stream << util::Format()( smoothed_distribution);
//
//      stream << util::Format().W( 7)( "test") << '\t';
//      for( double residues = 0;  residues < 3 * MAX_RESIDUES; residues += 6)
//      {
//        stream << format( residues) << '\t';
//      }
//      stream << '\n';
//
//      for( double distance = 0; distance < 120; distance +=4)
//      {
//        stream << format( distance) << '\t';
//        for( double residues = 0;  residues < 3 * MAX_RESIDUES; residues += 30)
//        {
//          stream << format( energydistribution.FFP( MakeVector( distance, residues))) << '\t';
//        }
//        stream << '\n';
//      }
//      util::Message::ResetToPreviousMessageLevel();

      return energydistribution;
    }

    //! @brief create Cubic splines for loop length potentials derived form statistics for different loop lengths
    storage::Vector< math::CubicSplineDamped> EnergyDistribution::LoopLengthDistancePotential
    (
      const storage::Vector< math::Histogram> &LOOPLENGTH_DISTRIBUTIONS
    )
    {
      // vector that will hold all final energy distributions
      storage::Vector< math::CubicSplineDamped> energy_distributions;

      // iterate over all possible loop lengths
      for
      (
        storage::Vector< math::Histogram>::const_iterator
          itr( LOOPLENGTH_DISTRIBUTIONS.Begin()), itr_end( LOOPLENGTH_DISTRIBUTIONS.End());
        itr != itr_end;
        ++itr
      )
      {
        math::Histogram current_histogram( *itr);

        // remove all 0 bins
        current_histogram.RemoveBinsAfterIndex( current_histogram.GetIndexOfLastInformationContainingBin());

        // create vector with histogram
        linal::Vector< double> distribution( current_histogram.GetHistogram());
        linal::Vector< double> binning( current_histogram.GetBinning());

        // add pseudo count
        // normalize by square distance
        for
        (
          double *bin( binning.Begin()), *dist( distribution.Begin()), *dist_end( distribution.End());
          dist != dist_end;
          ++bin, ++dist
        )
        {
          *dist += s_PseudoCount;
          *dist /= math::Sqr( *bin);
        }

        // normalize by number of bins and total sum to get propensities
        distribution.SetToSum( distribution.GetSize());

        // logarithmize
        for( double *dist( distribution.Begin()), *dist_end( distribution.End()); dist != dist_end; ++dist)
        {
          *dist = -log( *dist);
        }

        // train a cubic spline
        math::CubicSplineDamped energy;
        energy.Train
        (
          current_histogram.GetBoundaries().First() + 0.5 * current_histogram.GetBinSize(),
          current_histogram.GetBinSize(),
          distribution,
          0,
          1
        );

        // insert into energies
        energy_distributions.PushBack( energy);
      }

      // end
      return energy_distributions;
    }

    //! @brief This function reads the aa_distances histogram and parses it into a matrix and returns it
    //! matrix gives for each AAType pair, probability of observing them within the given distance cutoff
    //! @param DISTANCE_CUTOFF distance in angstrom that is the cutoff
    //! @return matrix that contains the aa pair probabilities
    linal::Matrix< double> EnergyDistribution::ReadAAPairDistanceHistogram( const double DISTANCE_CUTOFF)
    {
      linal::Matrix< double> probmatrix( biol::GetAATypes().GetEnumCount(), biol::GetAATypes().GetEnumCount());

      // read file with all histograms for each pair of sstypes
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( "aa_distances.histograms"));

      while( !read.eof())
      {
        math::Histogram dist_histogram;
        std::pair< biol::AAType, biol::AAType> aatypepair;
        std::string tmp;
        read >> tmp; aatypepair.first = biol::GetAATypes().AATypeFromOneLetterCode( tmp[ 0]);
        read >> tmp; aatypepair.second = biol::GetAATypes().AATypeFromOneLetterCode( tmp[ 0]);

        //abort if one aatype is unknown
        if( aatypepair.first == biol::GetAATypes().e_Undefined || aatypepair.second == biol::GetAATypes().e_Undefined) break;
        read >> dist_histogram;

        double probability( dist_histogram.GetCountsInBetween( 0, DISTANCE_CUTOFF) / dist_histogram.GetSumOfAllCounts());
        probmatrix( aatypepair.first, aatypepair.second) = probability;
        probmatrix( aatypepair.second, aatypepair.first) = probability;
      }

      io::File::CloseClearFStream( read);

      return probmatrix;
    }

    linal::Matrix< double> EnergyDistribution::ProbabilityOfAAPairTOBeWithinDistance( const double &DISTANCE)
    {
      // read file with all histograms for each pair of sstypes
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( "aa_distances.histograms"));

      linal::Matrix< double> probabilitymatrix
      (
        biol::GetAATypes().GetEnumCount(), biol::GetAATypes().GetEnumCount()
      );

      while( !read.eof())
      {
        math::Histogram current_aa_distance_histogram;
        std::pair< biol::AAType, biol::AAType> aatypepair;
        std::string tmp;
        read >> tmp; aatypepair.first = biol::GetAATypes().AATypeFromOneLetterCode( tmp[ 0]);
        read >> tmp; aatypepair.second = biol::GetAATypes().AATypeFromOneLetterCode( tmp[ 0]);

        //abort if one aatype is unknown
        if( aatypepair.first == biol::GetAATypes().e_Undefined || aatypepair.second == biol::GetAATypes().e_Undefined) break;
        read >> current_aa_distance_histogram;

        //calculate probability
        linal::Vector< double> aa_distance_counts( current_aa_distance_histogram.GetHistogram());
        const linal::Vector< double> distance_bins( current_aa_distance_histogram.GetBinning());

        double totalcounts( 0.0);

        //devide each count in bin by distance distribution square
        const double *bins = distance_bins.Begin();
        for
        (
          double *counts = aa_distance_counts.Begin();
          counts != aa_distance_counts.End() && bins != distance_bins.End();
          counts++, bins++
        )
        {
          //divide by distance^2
          *counts /= math::Sqr( *bins);

          totalcounts += ( *counts);
        }

        double counts_in_distance_range( 0.0);
        //add up all normalized counts till the DISTANCE
        for( size_t i( 0); i < aa_distance_counts.GetSize(); ++i)
        {
          if( distance_bins( i) > DISTANCE)
          {
            break;
          }

          counts_in_distance_range += aa_distance_counts( i);
        }

        const double probability( counts_in_distance_range / totalcounts);

        //store probability in matrix
        probabilitymatrix( aatypepair.first, aatypepair.second) = probability;
        probabilitymatrix( aatypepair.second, aatypepair.first) = probability;
      }

      io::File::CloseClearFStream( read);

      return probabilitymatrix;
    }

    //! @brief This function reads a phi psi angle histogram for the 20 amino acid types and generates a potential
    //! @param PHI_PSI_ANGLE_DISTRIBUTION  Histogram 2D that contains amino acid phi psi angle statistics
    //! @param BACKGROUND the background distribution to use
    //! @param NORMALIZE_BY_BACKGROUND normalize by given background - otherwise each bin has a propensity purely derived from this distribution
    //! @return returns a bicubic spline, energydistribution
    math::BicubicSpline EnergyDistribution::PhiPsiAnglePotential
    (
      const math::Histogram2D &PHI_PSI_ANGLE_DISTRIBUTION,
      const math::Histogram2D &BACKGROUND,
      const bool NORMALIZE_BY_BACKGROUND
    )
    {
      // get the core counts
      linal::Matrix< double> phi_psi_counts( PHI_PSI_ANGLE_DISTRIBUTION.GetHistogram());

      // background distribution
      linal::Matrix< double> background_counts( BACKGROUND.GetHistogram());

      // if the background should not be used = equal probability for each phi-psi combination
      if( !NORMALIZE_BY_BACKGROUND)
      {
        background_counts = 1.0 / double( background_counts.GetNumberOfElements());
      }

      // add pseudo count
      phi_psi_counts += 0.00001;
      background_counts += 0.00001;

      // -log of every bin to get the energy
      for( double *ptr( phi_psi_counts.Begin()), *ptr_end( phi_psi_counts.End()), *back( background_counts.Begin()); ptr != ptr_end; ++ptr, ++back)
      {
        *ptr = -log( *ptr / *back);
      }

      //invoke Spline; both borders are periodic due to spherical symmetry
      math::BicubicSpline energy_distribution;
      const math::SplineBorderType           borderflags[ 2] = { math::e_Periodic, math::e_Periodic};
      const double                                 start[ 2] =
        {
          PHI_PSI_ANGLE_DISTRIBUTION.GetBoundariesY().First() + 0.5 * PHI_PSI_ANGLE_DISTRIBUTION.GetBinSizeXY().Second(),
          PHI_PSI_ANGLE_DISTRIBUTION.GetBoundariesX().First() + 0.5 * PHI_PSI_ANGLE_DISTRIBUTION.GetBinSizeXY().First()
        };
      const double                               binsize[ 2] =
        {
          PHI_PSI_ANGLE_DISTRIBUTION.GetBinSizeXY().Second(),
          PHI_PSI_ANGLE_DISTRIBUTION.GetBinSizeXY().First()
        };
      const bool                                 lincont[ 2] = { false, false};
      const storage::Pair< double, double> firstorder[ 2] =
        { storage::Pair< double, double>( 0, 0), storage::Pair< double, double>( 0, 0)};
      energy_distribution.Train( borderflags, start, binsize, phi_psi_counts, lincont, firstorder);

      // end
      return energy_distribution;
    }

    //! @brief convert a histogram into energy function with a cosine background distribution
    //! @param HISTOGRAM from 0 to pi/2
    //! @return Cubic spline representing the energy
    math::CubicSplineDamped EnergyDistribution::AngleAlignmentPotential( const math::Histogram &HISTOGRAM)
    {
      // current histogram, binsize and counts
      const double bin_size( HISTOGRAM.GetBinSize());
      linal::Vector< double> counts( HISTOGRAM.GetHistogram());

      // initialize angle
      double angle( bin_size / double( 2.0));

      // iterate over current histogram
      for
      (
        double *ptr( counts.Begin()), *ptr_end( counts.End());
        ptr != ptr_end; ++ptr, angle += bin_size
      )
      {
        // add pseudo count
        *ptr += double( 1.0);
        // divide by background probability
        *ptr /= cos( angle);
      }

      // calculate propensities
      counts.SetToSum( counts.GetSize());

      // -log to get the energy
      for( double *ptr( counts.Begin()), *ptr_end( counts.End()); ptr != ptr_end; ++ptr)
      {
        *ptr = -log( *ptr);
      }

      // calculate spline
      return math::CubicSplineDamped().Train
      (
        HISTOGRAM.GetBoundaries().First() + 0.5 * bin_size,
        bin_size,
        counts,
        0,
        0
      );
    }

    //! @brief This function reads a histogram for an amino acid and generates a potential
    //! @param HISTOGRAM Histogram that contains statistics =
    //! @param PSEUDOCOUNT pseudocount to be added
    //! @param BORDER_FLAG Training method to be used for handling the borders
    //! @param FIRST_DERIVATIVE only to be used when e_FirstDer is being used
    //! @param NORMALIZE_ENERGIES if true normalizes the energies calculated from the histogram to be between 0 and 1
    //! @param BONUS_ONLY if true shifts the energy potential to be 0 or less (i.e. no penalties)
    //! @return returns a cubic spline
    math::CubicSplineDamped EnergyDistribution::GeneratePotentialFromHistogram
    (
      const math::Histogram &HISTOGRAM,
      const double PSEUDOCOUNT,
      const math::SplineBorderType BORDER_FLAG,
      const storage::Pair< double, double> &FIRST_DERIVATIVE,
      const bool NORMALIZE_ENERGIES,
      const bool BONUS_ONLY
    )
    {
      // create math::Vector values and initialize with the values in the histogram provided
      linal::Vector< double> values( HISTOGRAM.GetHistogram());

      // add pseudocount
      values += PSEUDOCOUNT;

      // variable that adds up all counts
      const double total_sum( values.Sum());

      // convert to propensities
      values *= values.GetSize() / total_sum;

      //-log of every bin to get the energy
      for( double *ptr( values.Begin()), *ptr_end( values.End()); ptr != ptr_end; ++ptr)
      {
        *ptr = -log( *ptr);
      }

      // true if "NORMALIZE_ENERGIES" is set to true - need to normalize the energies of "values" to be between 0 and 1
      if( NORMALIZE_ENERGIES)
      {
        // divide the energies of "values" by its range
        values /=
          (
            math::Statistics::MaximumValue( values.Begin(), values.End()) -
            math::Statistics::MinimumValue( values.Begin(), values.End())
          );
      }

      // true if "BONUS_ONLY" is set to true - need to shift the energy potential to be 0 or less (i.e. no penalties)
      if( BONUS_ONLY)
      {
        // subtract the largest value of "values" from each element of "values"
        values -= math::Statistics::MaximumValue( values.Begin(), values.End());
      }

      // create CubicSpline energy_distribution
      math::CubicSplineDamped energy_distribution;

      // create const double "" and initialize with the size of the bins in "HISTOGRAM"
      const double bin_size( HISTOGRAM.GetBinSize());

      const double start( HISTOGRAM.GetBoundaries().First() + 0.5 * bin_size);
      // train "energy_distribution"
      if( BORDER_FLAG == math::e_Natural)
      {
        energy_distribution.Train( start, bin_size, values);
      }
      else if( BORDER_FLAG == math::e_FirstDer)
      {
        energy_distribution.Train
        (
          start, //< value of the first full bin
          bin_size,
          values,
          FIRST_DERIVATIVE.First(),
          FIRST_DERIVATIVE.Second()
        );
      }
      else
      {
        BCL_Exit( "cubic spline damped does not currently support periodic or not-a-knot border types", -1);
      }

      // end
      return energy_distribution;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_environment_predictions.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_atom.h"
#include "biol/bcl_biol_membrane.h"
#include "io/bcl_io_file.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> EnvironmentPredictions::s_Instance
    (
      GetObjectInstances().AddInstance( new EnvironmentPredictions())
    );

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &EnvironmentPredictions::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "sspred_env_mean.bcl");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &EnvironmentPredictions::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "ssepred_env");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    EnvironmentPredictions::EnvironmentPredictions() :
      m_Method( sspred::GetMethods().e_Undefined),
      m_Scheme( GetDefaultScheme()),
      m_Potentials()
    {
    }

    //! @brief constructor from a ssmethod and confidence threshold
    //! @param SS_METHOD ssmethod to use
    //! @param CONFIDENCE_THRESHOLD the threshold in units of z-score, above which the score becomes negative
    //! @param SCHEME scheme to be used
    EnvironmentPredictions::EnvironmentPredictions
    (
      const sspred::Method &SS_METHOD,
      const std::string &SCHEME
    ) :
      m_Method( SS_METHOD),
      m_Scheme( SCHEME),
      m_Potentials()
    {
      if( m_Method.IsDefined())
      {
        // read the histogram file and store the energy functions
        ReadEnergyVector();
      }
    }

    //! @brief Clone function
    //! @return pointer to new EnvironmentPredictions
    EnvironmentPredictions *EnvironmentPredictions::Clone() const
    {
      return new EnvironmentPredictions( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &EnvironmentPredictions::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates the score for a given SSE
    //! @param THIS_SSE SSE of interest
    //! @param MEMBRANE membrane object
    //! @return score calculated for the given SSE
    storage::Pair< double, size_t> EnvironmentPredictions::operator()
    (
      const assemble::SSE &THIS_SSE,
      const biol::Membrane &MEMBRANE
    ) const
    {
      // initialize the score
      double score( 0.0);

      // iterate over all amino acids in sequence
      for
      (
        biol::AASequence::const_iterator aa_itr( THIS_SSE.Begin()),
          aa_itr_end( THIS_SSE.End());
        aa_itr != aa_itr_end; ++aa_itr
      )
      {
        // get the environment type
        const biol::EnvironmentType current_env_type
        (
          MEMBRANE.IsDefined()
          ? MEMBRANE.DetermineEnvironmentType( ( *aa_itr)->GetAtom( biol::GetAtomTypes().CA).GetCoordinates())->GetReducedType()
          : biol::GetEnvironmentTypes().e_Solution
        );

        // find the potential
        auto itr( m_Potentials.Find( current_env_type));

        // add the score
        if( itr != m_Potentials.End())
        {
          score += ScoreAminoAcid( **aa_itr, current_env_type, itr->second);
        }
      }

      // end
      return storage::Pair< double, size_t>( score, THIS_SSE.GetSize());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param THIS_SSE SSE of interest
    //! @param MEMBRANE membrane object
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &EnvironmentPredictions::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &THIS_SSE,
      const biol::Membrane &MEMBRANE,
      std::ostream &OSTREAM
    ) const
    {
      // iterate over all amino acids in sequence
      for
      (
        biol::AASequence::const_iterator aa_itr( THIS_SSE.Begin()),
          aa_itr_end( THIS_SSE.End());
        aa_itr != aa_itr_end; ++aa_itr
      )
      {
        // get the environment type
        const biol::EnvironmentType current_env_type
        (
          MEMBRANE.IsDefined() ?
            MEMBRANE.DetermineEnvironmentType
            (
              ( *aa_itr)->GetAtom( biol::GetAtomTypes().CA).GetCoordinates()
            )->GetReducedType() :
            biol::GetEnvironmentTypes().e_Solution
        );

        // find the potential
        auto itr( m_Potentials.Find( current_env_type));

        // add the score
        if( itr != m_Potentials.End())
        {
          OSTREAM << ( *aa_itr)->GetIdentification() << '\t' << current_env_type->GetTwoLetterCode() << '\t'
                  << ScoreAminoAcid( **aa_itr, current_env_type, itr->second) << '\n';
        }
      }

      // end
      return OSTREAM;
    }

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &EnvironmentPredictions::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Method             , ISTREAM);
      io::Serialize::Read( m_Scheme             , ISTREAM);

      if( m_Method.IsDefined())
      {
        // read the histogram file and store the energy functions
        ReadEnergyVector();
      }

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &EnvironmentPredictions::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Method             , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme             , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief score a single amino acid
    //! @param AMIO_ACID amino acid to score
    //! @param ENV_TYPE the environment type the amino acid prediction will be evaluated for
    //! @param ZSCORE the zscore to use
    //! @return the score
    double EnvironmentPredictions::ScoreAminoAcid
    (
      const biol::AABase &AMINO_ACID,
      const biol::EnvironmentType &ENV_TYPE,
      const math::PiecewiseFunction &ZSCORE
    ) const
    {
      auto pred( AMINO_ACID.GetData()->GetSSPrediction( m_Method));
      if( !pred.IsDefined())
      {
        return 0.0;
      }
      // get the raw predictions
      linal::Vector3D predictions( pred->GetThreeStateTMPrediction());
      // translate them into probabilities using the localPPV
      predictions( 0) = m_Potentials.GetValue( biol::GetEnvironmentTypes().e_MembraneCore)( predictions( 0));
      predictions( 1) = m_Potentials.GetValue( biol::GetEnvironmentTypes().e_Transition)( predictions( 1));
      predictions( 2) = m_Potentials.GetValue( biol::GetEnvironmentTypes().e_Solution)( predictions( 2));
      predictions.SetToSum( 1.0);

      // evaluate
      return -predictions( ENV_TYPE->GetReducedIndex());
    }

    //! @brief read energy distribution for scoring pairs of sses
    void EnvironmentPredictions::ReadEnergyVector()
    {
      storage::Map< sspred::Method, storage::Map< biol::EnvironmentType, math::PiecewiseFunction> > funcs;

      io::IFStream read_str;
      io::File::MustOpenIFStream( read_str, Score::AddHistogramPath( GetDefaultHistogramFilename()));
      read_str >> funcs;
      io::File::CloseClearFStream( read_str);

      // search for method
      auto meth_itr( funcs.Find( m_Method));

      if( meth_itr == funcs.End())
      {
        BCL_MessageCrt
        (
          "there is no statistics for method: " + m_Method.GetName() + " in file: " + GetDefaultHistogramFilename() +
          " ==> no SSPred Environment score for this method!!"
        );
        return;
      }
      m_Potentials = meth_itr->second;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_epr_accessibility.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_histogram.h"
#include "restraint/bcl_restraint_assignment.h"
#include "score/bcl_score_energy_distribution.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return the default filename for the default accessibility statistics
    const std::string &EPRAccessibility::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "SLnc-CBnc_pdbs07.histogram");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &EPRAccessibility::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "epr_accessibility");

      // end
      return s_default_scheme;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &EPRAccessibility::GetAlias() const
    {
      static const std::string s_name( "EPR Accessibility");
      return s_name;
    }

    //! @brief return parameters for member data that are not set up from the labels
    //! @return parameters for member data that are not set up from the labels
    io::Serializer EPRAccessibility::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores EPR accessibility");
      serializer.AddInitializer
      (
        "histogram filename",
        "path to file where the statistics and in consequence the energy potentials are read from",
        io::Serialization::GetAgent( &m_HistogramFileName)
       );
      serializer.AddInitializer
      (
        "histogram lower bound",
        "the lower bounds of the bins of the histogram",
        io::Serialization::GetAgent( &m_HistogramLowerBound)
       );
      serializer.AddInitializer
      (
        "histogram upper bound",
        "the upper bounds of the bins of the histogram",
        io::Serialization::GetAgent( &m_HistogramUpperBound)
       );

      return serializer;
    }

    //////////////////////////////////<
    // construction and destruction //
    //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param SCHEME scheme to be used
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    EPRAccessibility::EPRAccessibility
    (
      const std::string &SCHEME,
      const std::string &HISTOGRAM_FILENAME
    ) :
      m_Scheme( SCHEME),
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_EnergyFunction(),
      m_HistogramLowerBound(),
      m_HistogramUpperBound()
    {
      // read the histogram file and store the energy functions
      ReadEnergyVector();
    }

    //! @brief virtual copy constructor
      EPRAccessibility *EPRAccessibility::Clone() const
    {
      return new EPRAccessibility( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &EPRAccessibility::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that scores assignment of interest using pre-generated statistics
    //! @param ASSIGNMENT particular assignment of interest
    //! @return score
    double EPRAccessibility::operator()
    (
      const restraint::Assignment
      <
        storage::Map< restraint::AccessibilityAA::EnvironmentEnum, double>, double, biol::AABase
      > &ASSIGNMENT
    ) const
    {
      if( !ASSIGNMENT.GetGroupCollection().Begin()->second.Begin()->IsDefined())
      {
        return 0.0;
      }
      // create ShPtr "experimental_accessibilities" and initialize as pointing to the experimental restraints
      // in "ASSIGNMENT"
      util::ShPtr
      <
        storage::Map< restraint::AccessibilityAA::EnvironmentEnum, double>
      > experimental_accessibilities
      (
        ASSIGNMENT.GetRestraint()
      );

      // create double "score_sum" which will hold the sum of the agreement of the AABase in "ASSIGNMENT" with each of
      // the experimental measurements
      double score_sum( 0.0);

      // iterate through the experimental data to see how well each measurement agrees with the neighbor count of the
      // AABase in "ASSIGNMENT"
      for
      (
        storage::Map< restraint::AccessibilityAA::EnvironmentEnum, double>::const_iterator
          exp_data_itr( experimental_accessibilities->Begin()), exp_data_itr_end( experimental_accessibilities->End());
        exp_data_itr != exp_data_itr_end;
        ++exp_data_itr
      )
      {
        // create const double "current_accessibility_value" and initialize with the experimental accessibility
        // currently denoted by "exp_data_itr"
        const double current_accessibility_value( exp_data_itr->second);

        // create const double "neighbor_measure" and initialize with the neighbor measure that was calculated for the
        // AABase in "ASSIGNMENT"
        const double neighbor_measure( ASSIGNMENT.GetGroupCollection().Begin()->first);

        const double slnc_cbnc( current_accessibility_value - neighbor_measure);

        double current_score;

        // true if "sl_cb" is outside the boundaries of the SL-CB histogram
        if
        (
          slnc_cbnc < m_HistogramLowerBound || //< smaller than any value
          slnc_cbnc > m_HistogramUpperBound   //< larger than any value
        )
        {
          current_score = 0.0;
        }
        else
        {
          // get the score associated with having "neighbor_measure" calculated for AABase given an experimentally
          // measured accessibility of "current_accessibility_value"
          current_score = m_EnergyFunction( slnc_cbnc);
        }
        BCL_MessageDbg
        (
          "current score for  " +
          ( *ASSIGNMENT.GetGroupCollection().Begin()->second.Begin())->GetIdentification() + " with environment type " +
          exp_data_itr->first.GetString() + " with value " + util::Format()( current_accessibility_value) +
          " and neighbor measure value of " + util::Format()( neighbor_measure) + " is " +
          util::Format()( current_score)
        );
        score_sum += current_score;
      }

      return score_sum;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param ASSIGNMENT
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &EPRAccessibility::WriteDetailedSchemeAndValues
    (
      const restraint::Assignment
      <
        storage::Map< restraint::AccessibilityAA::EnvironmentEnum, double>, double, biol::AABase
      > &ASSIGNMENT,
      std::ostream &OSTREAM
    ) const
    {
      if( !ASSIGNMENT.GetGroupCollection().Begin()->second.Begin()->IsDefined())
      {
        return OSTREAM;
      }

      // create ShPtr "experimental_accessibilities" and initialize as pointing to the experimental restraints
      // in "ASSIGNMENT"
      util::ShPtr
      <
        storage::Map< restraint::AccessibilityAA::EnvironmentEnum, double>
      > experimental_accessibilities
      (
        ASSIGNMENT.GetRestraint()
      );

      // iterate through the experimental data to see how well each measurement agrees with the neighbor count of the
      // AABase in "ASSIGNMENT"
      for
      (
        storage::Map< restraint::AccessibilityAA::EnvironmentEnum, double>::const_iterator
          exp_data_itr( experimental_accessibilities->Begin()), exp_data_itr_end( experimental_accessibilities->End());
        exp_data_itr != exp_data_itr_end;
        ++exp_data_itr
      )
      {
        // create const double "current_accessibility_value" and initialize with the experimental accessibility
        // currently denoted by "exp_data_itr"
        const double current_accessibility_value( exp_data_itr->second);

        // create const double "neighbor_measure" and initialize with the neighbor measure that was calculated for the
        // AABase in "ASSIGNMENT"
        const double neighbor_measure( ASSIGNMENT.GetGroupCollection().Begin()->first);

        const double slnc_cbnc( current_accessibility_value - neighbor_measure);

        double current_score;

        // true if "sl_cb" is outside the boundaries of the SL-CB histogram
        if
        (
          slnc_cbnc < m_HistogramLowerBound || //< smaller than any value
          slnc_cbnc > m_HistogramUpperBound   //< larger than any value
        )
        {
          current_score = 0.0;
        }
        else
        {
          // get the score associated with having "neighbor_measure" calculated for AABase given an experimentally
          // measured accessibility of "current_accessibility_value"
          current_score = m_EnergyFunction( slnc_cbnc);
        }

        OSTREAM << "current score for  " <<
          ( *ASSIGNMENT.GetGroupCollection().Begin()->second.Begin())->GetIdentification() << " with environment type "
          << exp_data_itr->first.GetString() << " with value " << current_accessibility_value <<
          " and neighbor measure value of " << neighbor_measure << " is " << current_score << '\n';
      }

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @return ERROR_STREAM stream with which to write errors
    bool EPRAccessibility::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERROR_STREAM
    )
    {
      ReadEnergyVector();
      return true;
    }

    //! @brief read the energy distribution for scoring EPR accessibilities
    void EPRAccessibility::ReadEnergyVector()
    {
      // initialize read
      io::IFStream read;

      // bind read to the file "m_HistogramFileName"
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      // create math::Histogram named "accessibility_histogram" which will be used to hold the accessibility histogram
      math::Histogram accessibility_histogram;

      // read in the data from "m_HistogramFileName" into "accessibility_histogram"
      read >> accessibility_histogram;

      // close and clear read stream
      io::File::CloseClearFStream( read);

      const storage::VectorND< 2, double> boundaries( accessibility_histogram.GetBoundaries());

      m_HistogramLowerBound = boundaries.First() + 0.5 * accessibility_histogram.GetBinSize();
      m_HistogramUpperBound = boundaries.Second() - 0.5 * accessibility_histogram.GetBinSize();

      // set "m_EnergyFunction" to the cubic spline that has been trained on "accessibility_histogram"
      m_EnergyFunction = EnergyDistribution::GeneratePotentialFromHistogram
      (
        accessibility_histogram, 1.0, math::e_Natural, EnergyDistribution::GetDefaultFirstDerivative(),
        true, true
      );
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_fuzzy_logic_filter.h"

// includes from bcl - sorted alphabetically
#include "math/bcl_math_gaussian_function.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> FuzzyLogicFilter::s_Instance
    (
      util::Enumerated< RestraintAtomDistanceAssignment>::AddInstance( new FuzzyLogicFilter())
    );

    //! score for a restraint with residues/atoms not found in the protein model
    const double FuzzyLogicFilter::s_DefaultScore( 0.0);

    //! effective distance per bond
    const double FuzzyLogicFilter::s_EffectiveDistancePerBond( 1.0);

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief parameter constructor
    //! @param SCHEME the short tag denoting this scoring function
    FuzzyLogicFilter::FuzzyLogicFilter( const std::string &SCHEME) :
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new class_name
    FuzzyLogicFilter *FuzzyLogicFilter::Clone() const
    {
      return new FuzzyLogicFilter( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &FuzzyLogicFilter::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &FuzzyLogicFilter::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "fuzzy_logic_filter");

      // end
      return s_default_scheme;
    }

    //! @brief returns scheme being used
    //! @return scheme being used
    const std::string &FuzzyLogicFilter::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief () operator scores protein model
    //! @param RESTRAINT restraint to be scored
    //! @return score
    double FuzzyLogicFilter::operator()( const restraint::AtomDistanceAssignment &RESTRAINT) const
    {
      // calculate the distance
      const double cb_distance( RESTRAINT.CalculateAtomDistance());

      // if the calculated distance is undefined
      if( !util::IsDefined( cb_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      // get the bond distance
      const size_t bond_distance( GetTotalBondsFromCB( RESTRAINT));

      // if the bond distance is not defined
      if( !util::IsDefined( bond_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      // create a gaussian function to evaluate the difference between the distances
      return -math::GaussianFunction
      (
        0.0,
        std::max( 0.5, RESTRAINT.GetUpperBound() - RESTRAINT.GetDistance())
      )( cb_distance - RESTRAINT.GetDistance() - double( bond_distance) * s_EffectiveDistancePerBond);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &FuzzyLogicFilter::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Scheme, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &FuzzyLogicFilter::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_log_normal_distribution.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_serialization.h"
#include "io/bcl_io_serializer.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // initialize "s_WellDepth"
    const double LogNormalDistribution::s_WellDepth( -1.0);

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> LogNormalDistribution::s_Instance
    (
      util::Enumerated< RestraintAtomDistanceAssignment>::AddInstance( new LogNormalDistribution( 1.0))
    );

    // score for a restraint with residues/atoms not found in the protein model
    const double LogNormalDistribution::s_DefaultScore( 0.0);

    // effective distance per bond
    const double LogNormalDistribution::s_EffectiveDistancePerBond( 1.0);

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LogNormalDistribution::LogNormalDistribution() :
      m_KVariable( util::GetUndefinedDouble()),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief parameter constructor
    //! @param SCHEME the short tag denoting this scoring function
    LogNormalDistribution::LogNormalDistribution
    (
      const double &KVARIABLE
    ) :
      m_KVariable( KVARIABLE),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief Clone function
    //! @return pointer to new LogNormalDistribution
    LogNormalDistribution *LogNormalDistribution::Clone() const
    {
      return new LogNormalDistribution( *this);
    }

    //! @brief virtual destructor
    LogNormalDistribution::~LogNormalDistribution()
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LogNormalDistribution::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &LogNormalDistribution::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "log_normal_distribution");

      // end
      return s_default_scheme;
    }

    //! @brief returns scheme being used
    //! @return scheme being used
    const std::string &LogNormalDistribution::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief () operator scores protein model
    //! @param RESTRAINT restraint to be scored
    //! @return score
    double LogNormalDistribution::operator()( const restraint::AtomDistanceAssignment &RESTRAINT) const
    {
      // calculate the distance
      const double cb_distance( RESTRAINT.CalculateAtomDistance());

      // if the calculated distance is undefined
      if( !util::IsDefined( cb_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      // get the bond distance
      const size_t bond_distance( GetTotalBondsFromCB( RESTRAINT));

      // if the bond distance is not defined
      if( !util::IsDefined( bond_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      // calculate the value which will shift the graph enough that the scores will be negative within the upper bound
      // then add the negative well depth in order to shift the graph down and make it a bonus function
      return m_KVariable *
        std::pow
        (
          std::log
          (
            cb_distance / ( RESTRAINT.GetDistance() + double( bond_distance) * s_EffectiveDistancePerBond)
          ),
          2.0
        ) + s_WellDepth;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LogNormalDistribution::GetSerializer() const
    {
      io::Serializer serialize;
      serialize.SetClassDescription( "K * Ln^2(CB-Distance/(Restraint + {Restraint-label # bonds from CB})))  - 1");
      serialize.AddInitializer( "K", "magnitude for Log normal", io::Serialization::GetAgent( &m_KVariable), "1");
      return serialize;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_loop_angle.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
    //! @brief returns default file where loop angle histograms and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &LoopAngle::GetDefaultHistogramFilename()
    {
      static const std::string s_default_histogram_filename( "loop_angle.histograms");
      return s_default_histogram_filename;
    }

    //! @brief returns default file where the loop angle table is stored
    //! @return default file where the loop angle table data is stored
    const std::string &LoopAngle::GetDefaultTableFilename()
    {
      static const std::string s_default_table_filename( "loop_angle.tbl");
      return s_default_table_filename;
    }

    //! @brief returns the maximum sequence distance between SSEs to be considered as consecutive
    //! @return maximum sequence distance between SSEs to be considered as consecutive
    size_t LoopAngle::GetDefaultMaxmimumSequenceDistance()
    {
      static const size_t s_max_sequence_distance( 20); // set according to the cos(angle) cutoff plots
      return s_max_sequence_distance;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &LoopAngle::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "loop_angle");
      return s_default_scheme;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return  the name of the object when used in a dynamic context
    const std::string &LoopAngle::GetAlias() const
    {
      static const std::string s_name( "LoopAngle");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LoopAngle::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores the loop angle between two SSEs");
      serializer.AddInitializer
      (
        "histogram filename",
        "file from which statistics and in consequence energy potentials are read",
        io::Serialization::GetAgent( &m_HistogramFileName)
      );
      serializer.AddInitializer
      (
        "max sequence distance",
        "maximum sequence distance between SSEs to be considered consecutive",
        io::Serialization::GetAgent( &m_MaxSequenceDistance)
      );

      return serializer;
    }

    //! @brief constructor from a specified histogram file and scheme
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param MAX_SEQ_DISTANCE maximum sequence distance between SSEs to be considered as consecutive
    //! @param SCHEME scheme to be used
    LoopAngle::LoopAngle
    (
      const std::string &HISTOGRAM_FILENAME,
      const size_t &MAX_SEQ_DISTANCE,
      const std::string &SCHEME
    ) :
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_MaxSequenceDistance( MAX_SEQ_DISTANCE),
      m_Scheme( SCHEME),
      m_EnergyFunctionShortLoops(),
      m_EnergyFunctionLongLoops()
    {
      ReadEnergyVector();
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new Loop copied from this one
    LoopAngle *LoopAngle::Clone() const
    {
      return new LoopAngle( *this);
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LoopAngle::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the histogram filename
    //! @return the histogram filename
    const std::string &LoopAngle::GetHistogramFileName() const
    {
      return m_HistogramFileName;
    }

    //! @brief gets the maximum sequence distance for which the two SSEs are considered consecutive for this score
    //! @return the maximum sequence distance considered
    const size_t &LoopAngle::GetMaxSequenceDistance() const
    {
      return m_MaxSequenceDistance;
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &LoopAngle::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief get energy functions
    //! @return VectorND of short and long loop cubic spline
    storage::VectorND< 2, math::CubicSplineDamped> LoopAngle::GetEnergyFunctions() const
    {
      return storage::VectorND< 2, math::CubicSplineDamped>( m_EnergyFunctionShortLoops, m_EnergyFunctionLongLoops);
    }

    //! @brief get score type
    //! @return score type
    ProteinModel::Type LoopAngle::GetType() const
    {
      return ProteinModel::e_Structure;
    }

    //! @brief returns the angle between the given SSEs respective to the given position
    //! @param SSE_FIRST first SSE of interest
    //! @param SSE_SECOND first SSE of interest
    //! @param CENTER_OF_MASS the center of mass of the protein the SSEs are in
    //! @return angle between the given SSEs respective to the given position
    double LoopAngle::CalculateCosAngle
    (
      const assemble::SSE &SSE_FIRST,
      const assemble::SSE &SSE_SECOND,
      const linal::Vector3D &CENTER_OF_MASS
    ) const
    {
      // the angle is calculated between the end points of the loop
      const linal::Vector3D prev_end_of_z( SSE_FIRST.EndOfZ());
      const linal::Vector3D next_begin_of_z( SSE_SECOND.BeginOfZ());

      return linal::ProjAngleCosinus( CENTER_OF_MASS, prev_end_of_z, next_begin_of_z);
    }

    //! @brief the loop angle between the two given SSEs
    //! @param PROTEIN_MODEL the protein model to be scored
    //! @return score for the angle between consecutive SSEs
    double LoopAngle::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      std::stringstream dummy_stream;
      return ScoreLoops( PROTEIN_MODEL, dummy_stream, false);
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &LoopAngle::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_HistogramFileName, ISTREAM);
      io::Serialize::Read( m_MaxSequenceDistance, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // read the histogram file and store the energy functions
      ReadEnergyVector();

      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &LoopAngle::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_HistogramFileName, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MaxSequenceDistance, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      return OSTREAM;
    }

    //! @brief write detailed scheme and values to OSTREAM
    //! @param MODEL protein models to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &LoopAngle::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &MODEL,
      std::ostream &OSTREAM
    ) const
    {
      ScoreLoops( MODEL, OSTREAM, true);
      return OSTREAM;
    }

    //! @brief set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @return ERROR_STREAM stream with which to write errors
     bool LoopAngle::ReadInitializeSuccessHook
     (
       const util::ObjectDataLabel &LABEL,
       std::ostream &ERROR_STREAM
     )
    {
      ReadEnergyVector();
      return true;
    }

    //! @brief read energy distribution for scoring pairs of AASequences
    void LoopAngle::ReadEnergyVector()
    {
      // read histogram
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));
      math::Histogram loop_angle_short_loops_histogram, loop_angle_long_loops_histogram;
      read >> loop_angle_short_loops_histogram;
      read >> loop_angle_long_loops_histogram;
      io::File::CloseClearFStream( read);

      // create energy function from histogram
      m_EnergyFunctionShortLoops = EnergyDistribution::EnergyfunctionFromHistogram( loop_angle_short_loops_histogram);
      m_EnergyFunctionLongLoops = EnergyDistribution::EnergyfunctionFromHistogram( loop_angle_long_loops_histogram);
    }

    //! @brief helper function called by WriteDetailedSchemeAndValues and operator() so that the code remains in sync
    //! @param MODEL the protein model to be scored
    //! @param OSTREAM the output stream to write the detailed scheme to for this chain
    //! @param DO_WRITE set to true to actually write to the output stream; otherwise, nothing will be written
    //! @return the final score
    double LoopAngle::ScoreLoops( const assemble::ProteinModel &MODEL, std::ostream &OSTREAM, const bool &WRITE) const
    {
      // the center of mass is used as reference point for the angle calculation
      const linal::Vector3D center_of_mass( MODEL.GetCenterOfMass());

      // only select helices and strands from the model since the coils are the loops
      storage::Set< biol::SSType> sse_types( biol::GetSSTypes().GetHelixTypes());
      sse_types.Insert( biol::GetSSTypes().STRAND);

      // iterate over the SSEs and score the angle for consecutive ones
      const util::SiPtrVector< const assemble::SSE> sses( MODEL.GetSSEs( sse_types));
      double score( 0.0);
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator itr( sses.Begin()), itr_end( sses.End());
        itr != itr_end && itr + 1 != itr_end;
        ++itr
      )
      {
        // if the sequence distance between the current SSEs exceeds the provided maximum distance,
        // disregard this iteration
        const assemble::SSE &sse_a( **itr);
        const assemble::SSE &sse_b( **( itr + 1));
        const int seq_id_a( sse_a.GetLastAA()->GetSeqID());
        const int seq_id_b( sse_b.GetFirstAA()->GetSeqID());
        const size_t sequence_distance( seq_id_b - seq_id_a);

        // score the angle between the current SSE and it's successor
        const double cos_angle( CalculateCosAngle( sse_a, sse_b, center_of_mass));
        score += sequence_distance <= m_MaxSequenceDistance ?
          m_EnergyFunctionShortLoops( cos_angle) : m_EnergyFunctionLongLoops( cos_angle);

        if( WRITE)
        {
          OSTREAM << "Loop between " << sse_a.GetIdentification() << " and " << sse_b.GetIdentification()
            << " sequence_distance=" << sequence_distance << " cos(angle)="
            << cos_angle << " cumulative_score=" << score << "\n";
        }
      }

      // normalize the summed up score by the number of sses
      score /= sses.GetSize();
      if( WRITE)
      {
        OSTREAM << "Normalized score=" << score << " by number_of_sse=" << sses.GetSize();
      }

      return score;
    }
  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_loop_closure.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "math/bcl_math_linear_function.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LoopClosure::s_Instance
    (
      util::Enumerated< math::BinaryFunctionInterfaceSerializable< assemble::SSE, assemble::SSE, double> >::AddInstance
      (
        new LoopClosure()
      )
    );

  /////////////////
  // data access //
  /////////////////

    //! @brief get the name of the object
    //! @return the name of the object
    const std::string &LoopClosure::GetAlias() const
    {
      static const std::string s_name( "LoopClosure");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LoopClosure::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores distance to form loops between two SSEs");
      serializer.AddInitializer
      (
        "number excluded residues",
        "number of excluded residues from each end of loop",
        io::Serialization::GetAgent( &m_NrExcludedResidues)
       );
      serializer.AddInitializer
      (
        "sigmoid width",
        "width of the sigmoidal function to be used",
        io::Serialization::GetAgent( &m_SigmoidWidth)
      );
      serializer.AddInitializer
      (
        "fraction allowed distance",
        "fraction of allowed distance to use",
        io::Serialization::GetAgent( &m_FractionAllowedDistance)
      );
      serializer.AddInitializer
      (
        "exclude coil",
        "whether or not coil sses should be used in scoring",
        io::Serialization::GetAgent( &m_ExcludeCoil)
       );

      return serializer;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LoopClosure::LoopClosure() :
      m_NrExcludedResidues(),
      m_SigmoidWidth(),
      m_FractionAllowedDistance(),
      m_ExcludeCoil()
    {
    }

    //! @brief constructor from a sigmoid width
    //! @param NR_EXCLUDED_RESIDUES Number of excluded residues from each end of loop
    //! @param SIGMOID_WIDTH width of sigmoid function
    //! @param FRACTION_ALLOWED_DISTANCE the allowed distance is multiplied with the fraction before calculating the penalty
    //! @param EXCLUDE_COIL true if coil sses should not be considered in scoring
    LoopClosure::LoopClosure
    (
      const size_t NR_EXCLUDED_RESIDUES,
      const double SIGMOID_WIDTH,
      const double FRACTION_ALLOWED_DISTANCE,
      const bool EXCLUDE_COIL
    ) :
      m_NrExcludedResidues( NR_EXCLUDED_RESIDUES),
      m_SigmoidWidth( SIGMOID_WIDTH),
      m_FractionAllowedDistance( FRACTION_ALLOWED_DISTANCE),
      m_ExcludeCoil( EXCLUDE_COIL)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LoopClosure
    LoopClosure *LoopClosure::Clone() const
    {
      return new LoopClosure( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &LoopClosure::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculate Sequence distance between aas and Euclidean distance between last and first amino acids of SSEs
    //! if the NR_EXCLUDED_RESIDUES is >= size of sse, it will be reduced, so that at least 1 amino acid remains
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @param NR_EXCLUDED_RESIDUES number of residues to be excluded from each end
    //! @return a pair which first member is the length of the loop and aminoacids and the second is the Euclidean distance
    storage::Pair< size_t, double> LoopClosure::SequenceAndEuclideanDistanceWithExclusion
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B,
      const size_t NR_EXCLUDED_RESIDUES
    )
    {
      // sequences of different chains
      if( SSE_A.GetChainID() != SSE_B.GetChainID())
      {
        BCL_MessageVrb( "passing two different chains");
        return storage::Pair< size_t, double>( util::GetUndefined< size_t>(), util::GetUndefined< double>());
      }

      // check if given sses are not empty
      if( SSE_A.GetSize() == 0 || SSE_B.GetSize() == 0)
      {
        BCL_MessageVrb
        (
          "the passed SSEs are empty, returning undefined" +
          SSE_A.GetIdentification() + " and " + SSE_B.GetIdentification()
        );
        return storage::Pair< size_t, double>( util::GetUndefined< size_t>(), util::GetUndefined< double>());
      }

      // order pair, so that first's Sequence first AA has the smaller Sequence ID
      storage::VectorND< 2, util::SiPtr< const assemble::SSE> > ordered_pair( SSE_A, SSE_B);

      // if the first SSE comes after the second SSE
      if( ordered_pair.First()->GetFirstAA()->GetSeqID() > ordered_pair.Second()->GetFirstAA()->GetSeqID())
      {
        std::swap( ordered_pair.First(), ordered_pair.Second());
      }

      const size_t nr_excluded_res1( std::min( NR_EXCLUDED_RESIDUES, ordered_pair.First()->GetSize() - 1));
      const size_t nr_excluded_res2( std::min( NR_EXCLUDED_RESIDUES, ordered_pair.Second()->GetSize() - 1));

      // make sure the SSEs are long enough
      if( nr_excluded_res1 != NR_EXCLUDED_RESIDUES || nr_excluded_res2 != NR_EXCLUDED_RESIDUES)
      {
        BCL_MessageVrb
        (
          "the SSEs are too short to cut by " + util::Format()( NR_EXCLUDED_RESIDUES) +
          " into " + SSE_A.GetIdentification() + " and " + SSE_B.GetIdentification() +
          " less residues are used to cut in"
        );
      }

      // construct the pair to hold sequence and euclidean distances
      storage::Pair< size_t, double> seq_euc_distance;

      // calculate the sequence distance
      seq_euc_distance.First() = biol::CalculateSequenceDistance( *ordered_pair.Second(), *ordered_pair.First())
        + nr_excluded_res1 + nr_excluded_res2;

      // now calculate the Euclidean distance
      seq_euc_distance.Second() = biol::GetPeptideBondLength
        (
          *ordered_pair.First()->GetAA( ordered_pair.First()->GetSize() - nr_excluded_res1 - 1),
          *ordered_pair.Second()->GetAA( nr_excluded_res2)
        );

      BCL_MessageDbg
      (
        "seq_euc_distance is " + util::Format()( seq_euc_distance) + " for " +
        ordered_pair.First()->GetIdentification() + " and " + ordered_pair.Second()->GetIdentification()
      );

      // end
      return seq_euc_distance;
    }

    //! @brief score the loop
    //! @param SEQ_EUC_DISTANCE pair of sequence and Euclidean distance
    //! @return the loop closure score
    double LoopClosure::ScoreLoop( const storage::Pair< size_t, double> &SEQ_EUC_DISTANCE) const
    {
      // initialize static linear function
      static const double s_slope( 2.5609);
      static const double s_intercept( 2.1136);
      static const math::LinearFunction s_linear_function( s_slope, s_intercept);

      // calculate the different to maximum allowed distance
      const double difference( SEQ_EUC_DISTANCE.Second() - m_FractionAllowedDistance * s_linear_function( SEQ_EUC_DISTANCE.First()));

      // if within the range
      if( difference <= 0.0)
      {
        return 0.0;
      }
      // if larger than the sigmoid width
      else if( difference >= m_SigmoidWidth)
      {
        if( !m_SigmoidWidth)
        {
          return difference;
        }
        return 1.0;
      }
      else
      {
        // apply the sigmoidal function to get a value between 0 and sigmoid width
        return math::WeightBetweenZeroAndPi( ( ( m_SigmoidWidth - difference) / m_SigmoidWidth) * math::g_Pi);
      }
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief gives a penalty for two sses based on the difference between the observed distance and the distance the
    //! missing amino acids could bridge
    //! @param SSE_A the first sse
    //! @param SSE_B the second sse
    //! @return the score for two sses based on the possibility to close the loop between SSE_A and SSE_B
    double LoopClosure::operator()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      // if coils are excluded, return without scoring
      if( m_ExcludeCoil && ( SSE_A.GetType() == biol::GetSSTypes().COIL || SSE_B.GetType() == biol::GetSSTypes().COIL))
      {
        return 0.0;
      }

      // sum the score
      const storage::Pair< size_t, double> seq_euclid_dist( SequenceAndEuclideanDistanceWithExclusion( SSE_A, SSE_B, m_NrExcludedResidues));

      // loop is undefined
      if( !util::IsDefined( seq_euclid_dist.First()) || !util::IsDefined( seq_euclid_dist.Second()))
      {
        return 0.0;
      }

      const double score( ScoreLoop( seq_euclid_dist));
      if( !util::IsDefined( score))
      {
        return 0.0;
      }

      // return score
      return score;
    }

    //! @brief operator that scores the chain
    //! @param CHAIN the chain for which all neighbor scores are calculated
    //! @return score
    double LoopClosure::operator()( const assemble::Chain &CHAIN) const
    {
      // sum of all scores
      double score( 0.0);

      // need at least two sses in the chain
      if( CHAIN.GetNumberSSEs() < 2)
      {
        return score;
      }

      // iterate through the sses of "CHAIN" to calculate their score sum
      for
      (
        storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr_a( CHAIN.GetData().Begin()),
          sse_itr_b( ++CHAIN.GetData().Begin()),
          sse_itr_end( CHAIN.GetData().End());
        sse_itr_b != sse_itr_end;
        ++sse_itr_a, ++sse_itr_b
      )
      {
        score += this->operator ()( **sse_itr_a, **sse_itr_b);
      }

      // return the score sum
      return score;
    }

    //! @brief operator that scores the Protein model
    //! @param PROTEIN_MODEL the protein model for which all neighbor scores are calculated
    //! @return score
    double LoopClosure::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // score sum
      double score( 0.0);

      // iterate through the chains of PROTEIN_MODEL
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        score += operator()( **chain_itr);
      }

      // return score
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write the Scheme and the Function value for the ARGUMENT to the STREAM
    //! @param SSE_A the first sse
    //! @param SSE_B the second sse
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    LoopClosure::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &SSE_A, const assemble::SSE &SSE_B,
      std::ostream &OSTREAM
    ) const
    {
      // form the sse pair and calculate the sequence euclidean distances
      const storage::Pair< size_t, double> seq_euc_distance
      (
        SequenceAndEuclideanDistanceWithExclusion( SSE_A, SSE_B, m_NrExcludedResidues)
      );

      // write the detailed values and score
      OSTREAM << SSE_A.GetIdentification()    << '\t' << SSE_B.GetIdentification() << '\t'
              << seq_euc_distance.First()     << '\t' << seq_euc_distance.Second() << '\t'
              << ScoreLoop( seq_euc_distance) << '\n';

      // end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_loop.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "command/bcl_command_command_state.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_histogram.h"
#include "score/bcl_score_energy_distribution.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> Loop::s_Instance
    (
      util::Enumerated< math::BinaryFunctionInterfaceSerializable< assemble::SSE, assemble::SSE, double> >::AddInstance
      (
        new Loop()
      )
    );

  /////////////////
  // data access //
  /////////////////

    //! @brief returns default file where loop distance histograms and in consequence energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &Loop::GetDefaultHistogramFilename()
    {
      static const std::string s_default_histogram_filename( "loop.histograms");
      return s_default_histogram_filename;
    }

    //! @brief returns default file where the loop distance table is stored
    //! @return default file where the loop distance table data is stored
    const std::string &Loop::GetDefaultTableFilename()
    {
      static const std::string s_default_table_filename( "loop.tbl");
      return s_default_table_filename;
    }
    //! @brief returns default scheme
    //! @return default scheme
    const std::string &Loop::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "loop");
      return s_default_scheme;
    }

    //! @brief returns default maximum loop length in residues to be considered
    //! @return default maximum loop length in residues to be considered
    size_t Loop::GetDefaultMaxLoopLength()
    {
      static const size_t s_default_max_loop_length( 25);
      return s_default_max_loop_length;
    }

    //! @brief get the name of the object
    //! @return the name of the object
    const std::string &Loop::GetAlias() const
    {
      static const std::string s_name( "Loop");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer Loop::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores the loop length between two SSEs");
      serializer.AddInitializer
      (
        "histogram filename",
        "path to where the statistics and energy potentials are read from",
        io::Serialization::GetAgent( &m_HistogramFileName)
       );
      serializer.AddInitializer
      (
        "max loop length",
        "max number of residues in loop",
        io::Serialization::GetAgent( &m_MaxLoopLength)
       );

      return serializer;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param SCHEME scheme to be used
    //! @param MAX_LOOP_LENGTH maximum number of residues in a loop to be considered
    Loop::Loop
    (
      const std::string &HISTOGRAM_FILENAME,
      const std::string &SCHEME,
      const size_t MAX_LOOP_LENGTH
    ) :
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_Scheme( SCHEME),
      m_MaxLoopLength( MAX_LOOP_LENGTH),
      m_EnergyFunctions()
    {
      // read the histogram file and store the energy functions, except for the static instance
      if( !command::CommandState::GetGlobalCommandState().IsInStaticInitialization())
      {
        ReadEnergyVector();
      }
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new Loop copied from this one
    Loop *Loop::Clone() const
    {
      return new Loop( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &Loop::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &Loop::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief score the loop length and distance
    //! @param SEQ_EUC_DISTANCE pair of sequence and euclidean distance
    //! @return score for that combination of sequence and euclidean distance
    double Loop::Score( const storage::Pair< size_t, double> &SEQ_EUC_DISTANCE) const
    {
      // if loop is longer than max loop length, return energy for longer loops which is derived from the distance over
      // log of the sequence distance
      if( SEQ_EUC_DISTANCE.First() >= m_MaxLoopLength)
      {
        return m_EnergyFunctionLongLoops( NormalizeDistance( SEQ_EUC_DISTANCE));
      }

      // return the function value for the pair of residue distance and euclidean distance
      return m_EnergyFunctions( SEQ_EUC_DISTANCE.First())( SEQ_EUC_DISTANCE.Second());
    }

    //! @brief calculate Sequence distance between aas and euclidean distance between ends of bodies of two SSEs
    //! @brief SSE_A first SSE of interest
    //! @brief SSE_B first SSE of interest
    //! @return a pair which first member is the length of the loop end aminoacids and the second is the euclidean distance
    storage::Pair< size_t, double>
    Loop::SequenceAndEuclideanDistance
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B
    )
    {
      // sequences of different chains
      if( SSE_A.GetChainID() != SSE_B.GetChainID())
      {
        BCL_MessageVrb( "passing two different chains");
        return storage::Pair< size_t, double>( util::GetUndefined< size_t>(), util::GetUndefined< double>());
      }

      // order pair, so that first's Sequence first AA has the smaller Sequence ID
      storage::VectorND< 2, util::SiPtr< const assemble::SSE> > ordered_pair( SSE_A, SSE_B);

      // if the first SSE comes after the second SSE
      if( ordered_pair.First()->GetFirstAA()->GetSeqID() > ordered_pair.Second()->GetFirstAA()->GetSeqID())
      {
        std::swap( ordered_pair.First(), ordered_pair.Second());
      }

      const size_t seq_distance
      (
        biol::CalculateSequenceDistance( *ordered_pair.Second(), *ordered_pair.First())
      );

      if( !util::IsDefined( seq_distance))
      {
        BCL_MessageCrt( "undefined distance between two sequences");
        return storage::Pair< size_t, double>( util::GetUndefined< size_t>(), util::GetUndefined< double>());
      }

      storage::VectorND< 2, util::SiPtr< const assemble::SSEGeometryInterface> > ordered_geometries
      (
        util::SiPtr< const assemble::SSEGeometryInterface>( ordered_pair.First()),
        util::SiPtr< const assemble::SSEGeometryInterface>( ordered_pair.Second())
      );

      // get the corresponding fragments and store them
      util::SiPtr< const assemble::SSEGeometryInterface> frag_first_sse
      (
        ordered_pair.First()->GetSSEGeometries().IsEmpty() ?
          util::SiPtr< const assemble::SSEGeometryInterface>( ordered_pair.First()) :
          util::SiPtr< const assemble::SSEGeometryInterface>( ordered_pair.First()->GetSSEGeometries().LastElement())
      );
      util::SiPtr< const assemble::SSEGeometryInterface> frag_second_sse
      (
        ordered_pair.Second()->GetSSEGeometries().IsEmpty() ?
          util::SiPtr< const assemble::SSEGeometryInterface>( ordered_pair.Second()) :
          util::SiPtr< const assemble::SSEGeometryInterface>( ordered_pair.Second()->GetSSEGeometries().FirstElement())
      );

      // update the fragments if they are defined
      // otherwise, such as SSEs that are too short to generate a fragment, stick with the SSE
      if( frag_first_sse.IsDefined())
      {
        ordered_geometries.First() = frag_first_sse;
      }
      if( frag_second_sse.IsDefined())
      {
        ordered_geometries.Second() = frag_second_sse;
      }

      // return undefined if either of the bodies is not defined
      if( !ordered_geometries.First()->IsDefined() || !ordered_geometries.Second()->IsDefined())
      {
        BCL_MessageDbg
        (
          "passing at least one undefined SSE for loop end distance calculation " +
          ordered_geometries.First()->GetIdentification() + " vs " + ordered_geometries.Second()->GetIdentification()
        );
        return storage::Pair< size_t, double>( util::GetUndefined< size_t>(), util::GetUndefined< double>());
      }

      return storage::Pair< size_t, double>
      (
        seq_distance,
        ( ordered_geometries.Second()->BeginOfZ() - ordered_geometries.First()->EndOfZ()).Norm()
      );

    }

    //! @brief normalizes the distance by the sequence length
    //! @param SEQ_EUC_DISTANCE pair of sequence and euclidean distance
    //! @return normalized distance
    double Loop::NormalizeDistance
    (
      const storage::Pair< size_t, double> &SEQ_EUC_DISTANCE
    )
    {
      return SEQ_EUC_DISTANCE.Second() / std::log( double( SEQ_EUC_DISTANCE.First() + 2));
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief the loop length and distance between the two given sses
    //! @brief SSE_A first SSE of interest
    //! @brief SSE_B first SSE of interest
    //! @return potential for loop
    double
    Loop::operator()
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B
    ) const
    {
      // check that sses are from same chain - and neither of them is a coil
      if( SSE_A.GetChainID() != SSE_B.GetChainID())
      {
        BCL_MessageVrb( "cannot score loops between different chains!");
        return double( 0.0);
      }

      // check that both sses are helix or strand
      if( SSE_A.GetType() > biol::GetSSTypes().STRAND || SSE_B.GetType() > biol::GetSSTypes().STRAND)
      {
        BCL_MessageVrb( "can only score loops between SSE types HELIX or STRAND!");
        return double( 0.0);
      }

      //calculate the sequence and euclidean distance
      const storage::Pair< size_t, double> seq_euc_distance( SequenceAndEuclideanDistance( SSE_A, SSE_B));

      // if the distance is not defined, return a zero score
      if( !util::IsDefined( seq_euc_distance.First()) || !util::IsDefined( seq_euc_distance.Second()))
      {
        return 0;
      }

      // score this combination of seq and euclidean distance
      return Score( seq_euc_distance);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write the Scheme and the Function value for the ARGUMENT to the STREAM
    //! @param SSE_A first SSE of interest
    //! @param SSE_B first SSE of interest
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    Loop::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B,
      std::ostream &OSTREAM
    ) const
    {
      //calculate sequence and euclidean distance
      const storage::Pair< size_t, double> seq_euc_distance( SequenceAndEuclideanDistance( SSE_A, SSE_B));

      //write sstype, Angel to membrane plane first and last amino acid and value to the STREAM
      OSTREAM << SSE_A.GetIdentification() << '\t'
              << SSE_B.GetIdentification() << '\t'
              << seq_euc_distance.First() << '\t'
              << seq_euc_distance.Second() << '\t'
              << Score( seq_euc_distance) << '\n';

      //end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculate the maximum loop euclidian distance from the histogram files for each loop sequence length within a certain percentile
    //! @param HISTOGRAM_FILE filename of histogram to be used
    //! @param MAX_NR_LOOP_RESIDUES maximum number of loop residues
    //! @param FRACTION fraction of counts that needs to be below this threshold
    storage::Vector< double> Loop::CalculateMaximumObservedDistances
    (
      const std::string &HISTOGRAM_FILENAME,
      const size_t MAX_NR_LOOP_RESIDUES,
      const double FRACTION
    )
    {
      // make sure gievn fraction is valid
      BCL_Assert( FRACTION >= 0.0 && FRACTION <= 1.0, "The given fraction should be in range [0,1]");

      // initialize vector to be returned
      storage::Vector< double> max_distances_vector( MAX_NR_LOOP_RESIDUES + 1, util::GetUndefinedDouble());

      // initialize histograms vector
      storage::Vector< math::Histogram> histograms;

      // open stream and read
      io::IFStream read;
      io::File::MustOpenIFStream( read, HISTOGRAM_FILENAME);
      read >> histograms;

      // clear the stream
      io::File::CloseClearFStream( read);

      // make sure there are enough histograms
      BCL_Assert
      (
        histograms.GetSize() >= MAX_NR_LOOP_RESIDUES + 1,
        "There are only " + util::Format()( histograms.GetSize()) +
        " histograms in the given file, but requested number is " + util::Format()( MAX_NR_LOOP_RESIDUES)
      );

      // iterate over the histograms
      for( size_t hist_no( 0); hist_no <= MAX_NR_LOOP_RESIDUES; ++hist_no)
      {
        BCL_MessageVrb( "looking at loops of length: " + util::Format()( hist_no));

        // create ref on this histogram
        math::Histogram &histogram( histograms( hist_no));

        // get the total counts and calculated the threshold count sum
        const size_t total_counts( histogram.GetSumOfAllCounts());
        const size_t threshold_count( total_counts * FRACTION);
        size_t last_pos( histogram.GetIndexOfLastInformationContainingBin());

        BCL_MessageVrb
        (
          "total_counts: " + util::Format()( total_counts) +
          "\tthreshold_count: " + util::Format()( threshold_count) +
          "\tlast_pos: " + util::Format()( last_pos)
        );

        // initialize counts_sum
        size_t counts_sum( total_counts);

        // while the counts_sum is still larger than the threshold count
        while( counts_sum >= threshold_count && last_pos > 0)
        {
          // decrease the sum of this bin and move one position back
          if( last_pos == histogram.GetNumberOfBins())
          {
            counts_sum -= histogram.GetBoundariesCounts().Second();
          }
          else
          {
            counts_sum -= histogram.GetHistogram()( last_pos);
          }
          --last_pos;
        }

        // calculate the distance for the right boundary for this bin
        const double max_distance
        (
          histogram.GetBoundaries().First() + ( histogram.GetBinSize() * ( last_pos + 2))
        );

        // print the position
        BCL_MessageVrb( "last_pos: " + util::Format()( last_pos) + "distance: " + util::Format()( max_distance));

        max_distances_vector( hist_no) = max_distance;
      }

      // end
      return max_distances_vector;
    }

    //! @brief set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read from this class
    //! @param ERROR_STREAM stream with which to write errors
    bool Loop::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERROR_STREAM
     )
    {
      ReadEnergyVector();
      return true;
    }

    //! @brief read energy distribution for scoring pairs of AASequences
    void Loop::ReadEnergyVector()
    {
      // read file with according histogram2D
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      // read the histogram
      storage::Vector< math::Histogram> looplength_distance_histogram;
      read >> looplength_distance_histogram;

      // read the histograms for distance over log seq distance
      storage::Vector< math::Histogram> looplength_log_distance_histogram;
      read >> looplength_log_distance_histogram;

      // clear the stream
      io::File::CloseClearFStream( read);

      // create the energy histogram and store it in m_EnergyFunction
      BCL_Assert( m_MaxLoopLength + 1 <= looplength_distance_histogram.GetSize(), "not enough histograms given");

      // only calculate the energy distributions for individual loop lengths up to the max loop length
      looplength_distance_histogram.Resize( m_MaxLoopLength + 1);
      m_EnergyFunctions = EnergyDistribution::LoopLengthDistancePotential( looplength_distance_histogram);

      BCL_Assert( m_MaxLoopLength + 1 < looplength_log_distance_histogram.GetSize(), "the given max loop length is too big");

      math::Histogram combined_hist;
      // iterate over all energy functions for distance over log loop length
      for
      (
        storage::Vector< math::Histogram>::const_iterator
          itr( looplength_log_distance_histogram.Begin() + m_MaxLoopLength + 1), itr_end( looplength_log_distance_histogram.End());
        itr < itr_end;
        ++itr
      )
      {
        math::Histogram current( *itr);
        current.Normalize();
        combined_hist.Combine( current);
      }

      // derive distribution from combined histograms to score loops that are larger than the max loop length
      m_EnergyFunctionLongLoops = EnergyDistribution::EnergyfunctionFromHistogram( combined_hist, 0.0001);
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_phi_psi.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "biol/bcl_biol_atom.h"
#include "biol/bcl_biol_membrane.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_bicubic_spline.h"
#include "math/bcl_math_gnuplot_heatmap.h"
#include "math/bcl_math_histogram_2d.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PhiPsi::s_Instance
    (
      util::Enumerated
      <
        math::BinaryFunctionInterfaceSerializable< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> >
      >::AddInstance( new PhiPsi())
    );

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return the default filename for the default phi_psi_angle statistics
    const std::string &PhiPsi::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "phi_psi_angles_by_sstype.histogram2D");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &PhiPsi::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "phi_psi");

      // end
      return s_default_scheme;
    }

    //! @brief get the name of the object
    //! @return the name of the object
    const std::string &PhiPsi::GetAlias() const
    {
      static const std::string s_name( "PhiPsi");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer PhiPsi::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores the agreement of phi psi values with expected probabilities for an SSE");
      serializer.AddInitializer
      (
        "histogram filename",
        "path to where the statistics and energy potentials are read from",
        io::Serialization::GetAgent( &m_HistogramFileName),
        GetDefaultHistogramFilename()
       );
      serializer.AddOptionalInitializer
      (
        "ss types",
        "types of SSEs whose phi psi angles will be scored independently of the ss type",
        io::Serialization::GetAgent( &m_SSTypes)
       );

      return serializer;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PhiPsi::PhiPsi() :
      m_Scheme( GetDefaultScheme()),
      m_HistogramFileName(),
      m_EnergyMapSoluble(),
      m_EnergyMapMembrane(),
      m_AATypeEnergyMap(),
      m_SSTypes()
    {
    }

    //! @brief constructor from a specified histogram file
    //! @param SCHEME scheme to be used
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param SSTYPE_SET the types of sses whose phi psi angles will be score independently of the sstype
    PhiPsi::PhiPsi
    (
      const std::string &SCHEME,
      const std::string &HISTOGRAM_FILENAME,
      const storage::Set< biol::SSType> &SSTYPE_SET
    ) :
      m_Scheme( SCHEME),
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_EnergyMapSoluble(),
      m_EnergyMapMembrane(),
      m_AATypeEnergyMap(),
      m_SSTypes( SSTYPE_SET)
    {
      // read the histogram file and store the energy functions
      ReadEnergyVector();
    }

    //! @brief virtual copy constructor
    PhiPsi *PhiPsi::Clone() const
    {
      return new PhiPsi( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PhiPsi::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief Operator that scores the phi_psi bending of various SSEs in a protein
    //! @param THIS_SSE SSE to be scored
    //! @param MEMBRANE membrane object
    //! @return pair of score and number of scored amino acids
    storage::Pair< double, size_t> PhiPsi::operator()
    (
      const assemble::SSE &THIS_SSE,
      const biol::Membrane &MEMBRANE
    ) const
    {
      // ensure that the amino acid chain length is at least three
      if( THIS_SSE.GetSize() < 3)
      {
        return storage::Pair< double, size_t>( double( 0.0), 0);
      }

      // true if the phi and psi angles of the sse should be scored without taking into account the type of sse
      if( m_SSTypes.Find( THIS_SSE.GetType()) != m_SSTypes.End())
      {
        return ScorePhiPsiSSTypeIndependent( THIS_SSE);
      }

      // find the vector of histograms with corresponding sstype
      const storage::Map
      <
        biol::SSType, storage::Map< biol::AAType, math::BicubicSpline>
      >::const_iterator map_itr_sol( m_EnergyMapSoluble.Find( THIS_SSE.GetType())),
                        map_itr_mem( m_EnergyMapMembrane.Find( THIS_SSE.GetType()));

      // make sure it's found
      if( map_itr_sol == m_EnergyMapSoluble.End())
      {
        BCL_MessageCrt( "unexpected sstype found " + THIS_SSE.GetType().GetName());
        return storage::Pair< double, size_t>( double( 0.0), 0);
      }

      // end
      return ScoreSequencePhiPsi( THIS_SSE, map_itr_sol->second, map_itr_mem->second, MEMBRANE);
    }

    //! @brief scores an sse according to phi and psi without taking into account the SS Type
    //! @param THIS_SSE will be scored for agreement of phi and psi probabilities
    //! @return pair of double and size_t which is the score and number of scored amino acids, respectively
    storage::Pair< double, size_t> PhiPsi::ScorePhiPsiSSTypeIndependent( const assemble::SSE &THIS_SSE) const
    {
      return ScoreSequencePhiPsi( THIS_SSE, m_AATypeEnergyMap, m_AATypeEnergyMap, biol::Membrane::GetUndefinedMembrane());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &PhiPsi::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme           , ISTREAM);
      io::Serialize::Read( m_HistogramFileName, ISTREAM);
      io::Serialize::Read( m_SSTypes          , ISTREAM);

      // read the histogram files and store the energy functions
      ReadEnergyVector();

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &PhiPsi::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme           , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_HistogramFileName, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SSTypes          , OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read from this class
    //! @param ERROR_STREAM stream with which to write errors
    bool PhiPsi::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERROR_STREAM
      )
    {
      ReadEnergyVector();
      return true;
    }

    //! @brief read the energy distribution for scoring phi_psi angles
    void PhiPsi::ReadEnergyVector()
    {
      // open the histogram file into a stream
      m_EnergyMapSoluble.Reset();
      m_EnergyMapMembrane.Reset();
      m_AATypeEnergyMap.Reset();

      // initialize read
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      util::SiPtrVector< storage::Map< biol::SSType, storage::Map< biol::AAType, math::BicubicSpline> > > soluble_membrane_maps;
      soluble_membrane_maps.PushBack( util::ToSiPtrNonConst( m_EnergyMapSoluble));
      soluble_membrane_maps.PushBack( util::ToSiPtrNonConst( m_EnergyMapMembrane));
      storage::Vector< std::string> suffices( storage::Vector< std::string>::Create( "soluble", "membrane"));
      auto itr_suffices( suffices.Begin());
      for
      (
        auto itr_env( soluble_membrane_maps.Begin()), itr_env_end( soluble_membrane_maps.End());
        itr_env != itr_env_end;
        ++itr_env, ++itr_suffices
      )
      {
        std::string env_type;
        read >> env_type;
        // store aatype_sstype_histograms before deriving energy functions
        storage::Map< biol::AAType, storage::Map< biol::SSType, math::Histogram2D> > aatype_sstype_histograms;

        math::Histogram2D background;

        // for each sstype
        for
        (
          biol::SSTypes::const_iterator
            sstype_itr( biol::GetSSTypes().Begin()), sstype_itr_end( biol::GetSSTypes().COIL.GetIterator() + 1);
          sstype_itr != sstype_itr_end; ++sstype_itr
        )
        {
          // initialize SSType to be read
          biol::SSType current_sstype;

          // read sstype
          read >> current_sstype;

          // make sure it's the same as the expected
          BCL_Assert
          (
            current_sstype == *sstype_itr,
            "Unexpected sstype read from file!" + sstype_itr->GetName() + " != " + current_sstype.GetName()
          );

          // for each amino acids type read histogram
          for
          (
            biol::AATypes::const_iterator
              aa_itr( biol::GetAATypes().Begin()),
              aa_itr_end( biol::GetAATypes().GetEnumIteratorFromIndex( biol::AATypes::s_NumberStandardAATypes));
            aa_itr != aa_itr_end;
            ++aa_itr
          )
          {
            // initialize aatype to be read
            biol::AAType current_aatype;

            // read one letter code that represents the aatype
            std::string tmp;
            read >> tmp;
            current_aatype = biol::GetAATypes().AATypeFromOneLetterCode( tmp[ 0]);

            // assert that the aatypes in the histogram file are in the same order
            BCL_Assert
            (
              *aa_itr == current_aatype,
              "unexpected aatype read from file! " + aa_itr->GetName() + " != " + current_aatype.GetName()
            );

            // read Histogram2D from stream
            math::Histogram2D &current_phi_psi_histogram( aatype_sstype_histograms[ *aa_itr][ current_sstype]);
            read >> current_phi_psi_histogram;

            // normalize
            current_phi_psi_histogram.Normalize();

            // add to background
            background.Combine( current_phi_psi_histogram);
          }
        }

        // normalize background
        background.Normalize();

        if( util::GetMessenger().IsSmallerEqualCurrentMessageLevel( util::Message::e_Debug))
        {
          io::OFStream write;
          io::File::MustOpenOFStream( write, "phi_psi_background_" + *itr_suffices + ".gnuplot");
          math::GnuplotHeatmap heatmap;
          heatmap.SetFromHistogram( background, false, false);
          heatmap.SetTitleAndLabel( "phi psi background " + *itr_suffices, "phi [" + math::Angle::s_DegreeSymbolGnuplot + "]", "psi [" + math::Angle::s_DegreeSymbolGnuplot + "]", "p");
          const linal::Vector< double> binning
          (
            linal::FillVector< double>
            (
              background.GetNumberOfBinsX() + 1,
              math::Angle::Degree( background.GetBoundariesX().First()),
              math::Angle::Degree( background.GetBinSizeXY().First())
            )
          );
          heatmap.SetTicsX( math::GnuplotHeatmap::TicsFromBinning( binning, 1, util::Format().FFP( 0).W( 3).Fill( ' ').R()), false, 1);
          heatmap.SetTicsY( math::GnuplotHeatmap::TicsFromBinning( binning, 1, util::Format().FFP( 0).W( 3).Fill( ' ').R()), false, 1);
          heatmap.SetFont( "arialbd", 16);
          heatmap.SetPixelAndRatio( 1080, 800, -1);
          heatmap.SetRotationXTics( 90.0);
          heatmap.SetFilename( "phi_psi_background");
          heatmap.WriteScript( write);
          io::File::CloseClearFStream( write);
        }

        // generate scores

        for
        (
          storage::Map< biol::AAType, storage::Map< biol::SSType, math::Histogram2D> >::const_iterator
            aa_itr( aatype_sstype_histograms.Begin()), aa_itr_end( aatype_sstype_histograms.End());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          // sum of all sstypes, for sstype independent score
          math::Histogram2D sstype_sum;
          for
          (
            storage::Map< biol::SSType, math::Histogram2D>::const_iterator
              ss_itr( aa_itr->second.Begin()), ss_itr_end( aa_itr->second.End());
            ss_itr != ss_itr_end;
            ++ss_itr
          )
          {
            // add to sstype independent sum
            sstype_sum.Combine( ss_itr->second);

            ( **itr_env)[ ss_itr->first][ aa_itr->first] = EnergyDistribution::PhiPsiAnglePotential( ss_itr->second, background, false);
            //          m_EnergyMap[ ss_itr->first][ aa_itr->first] = EnergyDistribution::PhiPsiAnglePotential( ss_itr->second, background, false);
          }

          if( itr_suffices == suffices.Begin())
          {
            sstype_sum.Normalize();
            m_AATypeEnergyMap[ aa_itr->first] = EnergyDistribution::PhiPsiAnglePotential( sstype_sum, background, false);
            //        m_AATypeEnergyMap[ aa_itr->first] = EnergyDistribution::PhiPsiAnglePotential( sstype_sum, background, false);
          }
        }
      }

      // close and clear read stream
      io::File::CloseClearFStream( read);
    }

    //! @brief scores the phi psi of a single residue according to a given energy map
    //! @param AATYPE_ENERGY the energy used to score the phi psi of the residue
    //! @param AA_BASE the residue of interest
    //! @param AA_PREVIOUS the residue previous in sequence to the residue of interest
    //! @param AA_NEXT the residue following in sequence to the residue of interest
    //! @return double which is the score of the phi and psi angles for the residue of interest
    double PhiPsi::ScoreAAPhiPsi
    (
      const math::BicubicSpline &AATYPE_ENERGY,
      const biol::AABase &AA_BASE,
      const biol::AABase &AA_PREVIOUS,
      const biol::AABase &AA_NEXT
    )
    {
      // calculate phi psi for selected amino acid
      const storage::Pair< double, double> phi_psi_pair
      (
        AA_BASE.CalculatePhiPsi
        (
          AA_PREVIOUS.GetAtom( biol::GetAtomTypes().C),
          AA_NEXT.GetAtom( biol::GetAtomTypes().N)
        )
      );

      // check that angles are defined
      if( !util::IsDefined( phi_psi_pair.First()) || !util::IsDefined( phi_psi_pair.Second()))
      {
        return util::GetUndefinedDouble();
      }

      // get the score from the bicubicspline for this amino acid add this score to the sum
      const double score( AATYPE_ENERGY.F( linal::MakeVector( phi_psi_pair.Second(), phi_psi_pair.First())));

      // end
      return score;
    }

    //! @brief scores the phi and psi angles of an entire aa sequence according to a given energy map
    //! @param AA_SEQUENCE the amino acid sequence which will be scored
    //! @param AATYPE_ENERGY_MAP the energy map used to score the amino acid sequence
    //! @return pair of double and size_t which are the score and number of residues scored, respectively
    storage::Pair< double, size_t> PhiPsi::ScoreSequencePhiPsi
    (
      const biol::AASequence &AA_SEQUENCE,
      const storage::Map< biol::AAType, math::BicubicSpline> &AATYPE_ENERGY_MAP_SOLUBLE,
      const storage::Map< biol::AAType, math::BicubicSpline> &AATYPE_ENERGY_MAP_MEMBRANE,
      const biol::Membrane &MEMBRANE
    )
    {
      // initialize the sum
      double score_sum( 0.0);
      size_t scored_entities( 0);

      // iterate over amino acids
      for
      (
        biol::AASequence::const_iterator
          aa_itr( AA_SEQUENCE.Begin() + 1), aa_itr_end( AA_SEQUENCE.End() - 1);
        aa_itr != aa_itr_end; ++aa_itr
      )
      {
        const storage::Map< biol::AAType, math::BicubicSpline> &map
        (
          MEMBRANE.IsDefined() &&
          MEMBRANE.DetermineEnvironmentType( ( *aa_itr)->GetCA().GetCoordinates())->GetReducedType()
          == biol::GetEnvironmentTypes().e_MembraneCore
          ? AATYPE_ENERGY_MAP_MEMBRANE
          : AATYPE_ENERGY_MAP_SOLUBLE
        );

        // checks whether amino acid type is contained within the energy map.
        const storage::Map< biol::AAType, math::BicubicSpline>::const_iterator spline_itr
        (
          map.Find( ( *aa_itr)->GetType())
        );

        // make sure a bicubic spline exists for the selected amino acid type
        if( spline_itr == map.End())
        {
          continue;
        }

        // get the score from the bicubicspline for this amino acid
        const double current_score( ScoreAAPhiPsi( spline_itr->second, **aa_itr, **( aa_itr - 1), **( aa_itr + 1)));

        // true if "current_score" is defined
        if( util::IsDefined( current_score))
        {
          // add this score to the sum and increment "scored_entities"
          score_sum += current_score;
          ++scored_entities;
        }
      }

      // end
      return storage::Pair< double, size_t>( score_sum, scored_entities);
    }

  } // namespace score
} // namespace bcl

// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_phi_psi_with_sspred.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "math/bcl_math_bicubic_spline.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PhiPsiWithSSPred::s_Instance
    (
      GetObjectInstances().AddInstance( new PhiPsiWithSSPred())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &PhiPsiWithSSPred::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "phipsi_sspred");

      // end
      return s_default_scheme;
    }

    //! @brief get the name of the object
    //! @return the name of the object
    const std::string &PhiPsiWithSSPred::GetAlias() const
    {
      static const std::string s_name( "PhiPsiWithSSPred");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer PhiPsiWithSSPred::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores the phi and psi angles of an SSE taking into account SS predictions");
      serializer.AddInitializer
      (
        "histogram filename",
        "path to where the statistics and energy potentials are read from",
        io::Serialization::GetAgent( &m_HistogramFileName)
       );
      serializer.AddInitializer
      (
        "ss methods",
        "set of SS methods to use in evaluation",
        io::Serialization::GetAgent( &m_SSMethods)
       );

      return serializer;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PhiPsiWithSSPred::PhiPsiWithSSPred() :
      m_Scheme( GetDefaultScheme()),
      m_HistogramFileName(),
      m_EnergyMap(),
      m_SSMethods()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param HISTOGRAM_FILENAME path to file where statistics and in consequence the energy potentials are read from
    //! @param SS_METHODS set of SSMethods to use in evaluation
    //! @param SCHEME scheme to be used in outputting
    PhiPsiWithSSPred::PhiPsiWithSSPred
    (
      const storage::Set< sspred::Method> &SS_METHODS,
      const std::string &SCHEME,
      const std::string &HISTOGRAM_FILENAME
    ) :
      m_Scheme( SCHEME),
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_EnergyMap(),
      m_SSMethods( SS_METHODS)
    {
      m_EnergyMap = PhiPsi( "", m_HistogramFileName).GetEnergyFunctions();
    }

    //! @brief Clone function
    //! @return pointer to new PhiPsiWithSSPred
    PhiPsiWithSSPred *PhiPsiWithSSPred::Clone() const
    {
      return new PhiPsiWithSSPred( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PhiPsiWithSSPred::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read from this class
    //! @param ERROR_STREAM stream with which to write errors
    bool PhiPsiWithSSPred::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERROR_STREAM
    )
    {
      m_EnergyMap = PhiPsi( "", m_HistogramFileName).GetEnergyFunctions();
      return true;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates the score for a given SSE
    //! @param SSE SSE of interest
    //! @param MEMBRANE membrane object
    //! @return score calculated for the given SSE
    storage::Pair< double, size_t> PhiPsiWithSSPred::operator()
    (
      const assemble::SSE &SSE,
      const biol::Membrane &MEMBRANE
    ) const
    {
      // make sure the ssmethods set is not empty
      if( m_SSMethods.IsEmpty())
      {
        static bool s_have_warned( false);
        if( !s_have_warned)
        {
          BCL_MessageStd( "No SS prediction methods set for PhiPsiWithSSPred");
          s_have_warned = true;
        }
        return storage::Pair< double, size_t>( 0.0, 0);
      }

      // ensure that the amino acid chain length is at least three
      if( SSE.GetSize() < 3)
      {
        return storage::Pair< double, size_t>( double( 0.0), 0);
      }

      // varables for total score of sse and number residues scored
      double scoresum( 0.0);
      size_t scored_entities( 0);

      // iterate over amino acids
      for
      (
        biol::AASequence::const_iterator
          aa_itr( SSE.Begin() + 1), aa_itr_end( SSE.End() - 1);
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        BCL_MessageDbg( "aa " + util::Format()( aa_itr - SSE.Begin()));

        // get references to the previous and next residues
        const biol::AABase &previous_aa( **( aa_itr - 1));
        const biol::AABase &next_aa( **( aa_itr + 1));

        // will hold the best score for the current amino acid out of all the ss types
        double best_score( util::GetUndefinedDouble());

        // iterate over the SStypes
        for
        (
          storage::Map
          <
            biol::SSType, storage::Map< biol::AAType, math::BicubicSpline>
          >::const_iterator ss_type_itr( m_EnergyMap.Begin()), ss_type_itr_end( m_EnergyMap.End());
          ss_type_itr != ss_type_itr_end;
          ++ss_type_itr
        )
        {
          // checks whether amino acid type is contained within the energy map.
          const storage::Map< biol::AAType, math::BicubicSpline>::const_iterator spline_itr
          (
            ss_type_itr->second.Find( ( *aa_itr)->GetType())
          );

          // make sure a bicubic spline exists for the selected amino acid type
          if( spline_itr == ss_type_itr->second.End())
          {
            BCL_MessageStd
            (
              "There is no spline stored for aa type " + ( *aa_itr)->GetType().GetName()
            )
            continue;
          }

          // get the phi psi score for the current residue for the current ss type
          double sstype_phi_psi_score( PhiPsi::ScoreAAPhiPsi( spline_itr->second, **aa_itr, previous_aa, next_aa));

          // if the phi psi score is not defined go to next ss type
          if( !util::IsDefined( sstype_phi_psi_score))
          {
            BCL_MessageDbg( "sstype_phi_psi_score is undefined");
            continue;
          }

          // will hold the sum of all phi psi score weighted with each ss prediction for th current aa and ss type
          double weighted_scoresum( 0.0);

          // iterate over the ss prediction methods
          for
          (
            storage::Set< sspred::Method>::const_iterator
              method_itr( m_SSMethods.Begin()), method_itr_end( m_SSMethods.End());
            method_itr != method_itr_end; ++method_itr
          )
          {
            // store the predicted one state
            const util::SiPtr< const sspred::MethodInterface> this_prediction( ( *aa_itr)->GetSSPrediction( *method_itr));

            // TODO: the SS-predictions are not ordinarily stored on the AAs that are in the SSE since these change during
            //       folding; instead, they're stored on the main sequence. This code presupposes that they're stored on the
            //       SSE too, which is generally not true.
            // check that ss prediction is defined
            if( !this_prediction.IsDefined())
            {
              BCL_MessageVrb
              (
                "SS Prediction is not defined " + method_itr->GetName()
                + " for residue " + ( *aa_itr)->GetIdentification()
                + " PhiPsiWithSSPred will be 0!"
              );
            }
            else
            {

              // square root of the prediction for the current method and current ss type
              const double prediction_value( this_prediction->GetThreeStatePrediction()( ss_type_itr->first));

              // add the current weighted score to the weighted score sum
              weighted_scoresum += prediction_value * sstype_phi_psi_score;
            }
          }

          // true if the weighted score sum for the current ss type is better than for the other ss types
          if( !util::IsDefined( best_score))
          {
            best_score = weighted_scoresum;
          }
          else if( weighted_scoresum < best_score)
          {
            // best score is now the score for obtained for the current ss type
            best_score = weighted_scoresum;
          }
        }

        // add the score for the current residue to the total scoresum of the amino acid sequence
        if( util::IsDefined( best_score))
        {
          scoresum += best_score;
        }

        // increase the number of scored residues
        ++scored_entities;
      }

      // normalize by the number of methods
      scoresum /= double( m_SSMethods.GetSize());

      // return the result of score and number scored residues
      return storage::Pair< double, size_t>( scoresum, scored_entities);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PhiPsiWithSSPred::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_HistogramFileName, ISTREAM);
      io::Serialize::Read( m_SSMethods, ISTREAM);

      m_EnergyMap = PhiPsi( "", m_HistogramFileName).GetEnergyFunctions();

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &PhiPsiWithSSPred::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_HistogramFileName, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SSMethods, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_pofr.h"

// includes from bcl - sorted alphabetically
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "command/bcl_command_parameter_check_allowed.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_statistics.h"
#include "restraint/bcl_restraint_sas_analysis.h"
#include "restraint/bcl_restraint_sas_distance_density_point.h"
#include "storage/bcl_storage_list.h"
#include "util/bcl_util_wrapper_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PofR::s_Instance
    (
      GetObjectInstances().AddInstance( new PofR())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Constructor
    PofR::PofR()
    {
    }

    //! @brief Clone function
    //! @return pointer to new PofR
    PofR *PofR::Clone() const
    {
      return new PofR( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PofR::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief overloaded () operator to calculate Derivative Score or Cumulative Integral Score from two SAXS curves
    //! @param SAXS_DATA experimental and calculated saxs data
    //! @return return Derivative Score for two SAS curves
    double PofR::operator()( const restraint::SasExperimentalAndCalculatedDensity &SAS_DATA) const
    {
      // The score is initialized to zero
      double score( 0.0);

      // Compare dmax if model exceeds experimental boundary, reject
      double cal_dmax( SAS_DATA.GetCalculatedDensity().GetDmax());
      double exp_dmax( SAS_DATA.GetExperimentalDensity().GetDmax());

      double dmax_difference( exp_dmax - cal_dmax);

      // if the Max Dimension is violated, return a score of 10000
      if( dmax_difference < 0)
      {
        score = 10000.0;
        return score;
      }

      // Compare auc of both profiles, if model exceeds experimental auc, reject
      double auc_difference( restraint::SasAnalysis::CalculatePofRIntegralScore( SAS_DATA));

      if( auc_difference < 0)
      {
        score = 10000.0;
        return score;
      }

      // Compute Excess Integral score
       double excess_integral( restraint::SasAnalysis::CalculatePofRExcessIntegralScore( SAS_DATA));

      // Compute Oscillation score
      double cal_oscillation( restraint::SasAnalysis::CalculatePofROscillationScore( SAS_DATA.GetCalculatedDensity()));
      double exp_oscillation( restraint::SasAnalysis::CalculatePofROscillationScore( SAS_DATA.GetExperimentalDensity()));

      double oscillation_score( math::Absolute( exp_oscillation - cal_oscillation));

      if( excess_integral > 0.1)
      {
        excess_integral = 10 * excess_integral;
      }

      score = ( dmax_difference) + ( auc_difference) + ( 10 * excess_integral) + ( 10 * oscillation_score);
      //score = ( dmax_difference + auc_difference);
      BCL_MessageStd( "score: " + util::Format()( score));

      // if no violations occur, return a score
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PofR::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &PofR::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {

      // return the stream
      return OSTREAM;
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_atom_density.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinAtomDensity::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinAtomDensity())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinAtomDensity::ProteinAtomDensity()
    {
    }

    //! @brief construct from atom types and sse types
    //! @param SSE_TYPES sse types to be considered
    //! @param ATOM_TYPES atom types to be considered
    //! @param RESOLUTION the resolution in x, y and z to be used to determine the density
    ProteinAtomDensity::ProteinAtomDensity
    (
      const storage::Set< biol::SSType> &SSE_TYPES,
      const storage::Set< biol::AtomType> &ATOM_TYPES,
      const linal::Vector3D &RESOLUTION
    ) :
      m_SSTypes( SSE_TYPES),
      m_AtomTypes( ATOM_TYPES),
      m_Resolution( RESOLUTION)
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProteinAtomDensity
    ProteinAtomDensity *ProteinAtomDensity::Clone() const
    {
      return new ProteinAtomDensity( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &ProteinAtomDensity::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object
    //! @return the name of the object
    const std::string &ProteinAtomDensity::GetAlias() const
    {
      static const std::string s_name( "BodyExtentPositionAgreement");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinAtomDensity::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores the density of atoms in a protein model");
      serializer.AddInitializer
      (
        "ss types",
        "secondary structure element types to be considered",
        io::Serialization::GetAgent( &m_SSTypes)
      );
      serializer.AddInitializer
      (
        "atom types",
        "atoms to be considered in the density calculation",
        io::Serialization::GetAgent( &m_AtomTypes)
      );
      /**      serializer.AddInitializer
      (
        "resolution",
        "the resolution for the density",
        io::Serialization::GetAgent( &m_Resolution)
       ); **/

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculate the atom density in the given protein model
    //! @param PROTEIN_MODEL the protein model to be considered
    //! @return the average density of atoms in Angstroem^-3
    double ProteinAtomDensity::CalculateAverageAtomDensity( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // secondary structure elements
      const util::SiPtrVector< const assemble::SSE> sses( PROTEIN_MODEL.GetSSEs( m_SSTypes));

      util::SiPtrVector< const linal::Vector3D> all_atom_coordinates;

      // iterate over all sses and collect atom coordinates to consider
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator sse_itr( sses.Begin()), sse_itr_end( sses.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        all_atom_coordinates.Append( ( *sse_itr)->GetAtomCoordinates( m_AtomTypes));
      }

      // calculate the density for coordinates
      return coord::CalculatePointDensity( all_atom_coordinates, m_Resolution);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that scores the density of atom in the protein model
    //! @param PROTEIN_MODEL the protein model to be considered
    //! @return the score for the density determined
    double ProteinAtomDensity::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      return 0;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinAtomDensity::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return output stream which was written to
    std::ostream &ProteinAtomDensity::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_aa_neighborhood.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_count.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_protein_model.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "biol/bcl_biol_atom.h"
#include "biol/bcl_biol_membrane.h"
#include "fold/bcl_fold_default_flags.h"
#include "math/bcl_math_statistics.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

    //! @brief conversion to a string from a Type
    //! @param TYPE the type to get a string for
    //! @return a string representing that type
    const std::string &ProteinModelAANeighborhood::GetTypeName( const NormalizationType &TYPE)
    {
      static const std::string s_descriptors[ s_NumberTypes + 1] =
      {
        "none",
        "normalize",
        "rmsd",
        "explained",
        "correlation_and_relative_error",
        GetStaticClassName< ProteinModelAANeighborhood>()
      };
      return s_descriptors[ size_t( TYPE)];
    }

    //! @brief conversion to a string from a Type
    //! @param TYPE the type to get a string for
    //! @return a string representing that type
    const std::string &ProteinModelAANeighborhood::GetTypeSuffix( const NormalizationType &TYPE)
    {
      static const std::string s_descriptors[ s_NumberTypes + 1] =
      {
        "",
        "_norm",
        "_rmsd",
        "_explained",
        "_corr",
        GetStaticClassName< ProteinModelAANeighborhood>()
      };
      return s_descriptors[ size_t( TYPE)];
    }

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> ProteinModelAANeighborhood::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelAANeighborhood())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelAANeighborhood::ProteinModelAANeighborhood() :
      m_ScoreAANeighborhood(),
      m_AANeighborListContainerGenerator(),
      m_Normalization( e_None),
      m_Scheme()
    {
    }

    //! @brief constructor from ShPtr to aa exposure function
    //! @param SP_SCORE_AA_NEIGHBORHOOD ShPtr to AA neighborhood scoring function
    //! @param TYPE normalization type to use
    //! @param CONSIDER_DIFFERENT_CHAIN whether neighbors from different chains should be considered
    //! @param SCORE_TYPE score type
    //! @param READABLE_SCHEME scheme that is more human readable
    ProteinModelAANeighborhood::ProteinModelAANeighborhood
    (
      const util::ShPtr< AANeighborhoodInterface> &SP_SCORE_AA_NEIGHBORHOOD,
      const TypeEnum &TYPE,
      const bool CONSIDER_DIFFERENT_CHAIN,
      const ProteinModel::Type &SCORE_TYPE,
      const std::string &READABLE_SCHEME
    ) :
      m_ScoreAANeighborhood( SP_SCORE_AA_NEIGHBORHOOD),
      m_AANeighborListContainerGenerator
      (
        SP_SCORE_AA_NEIGHBORHOOD.IsDefined() ?
          assemble::AANeighborListContainerGeneratorProteinModel::AANeighborListGenerator
          (
            SP_SCORE_AA_NEIGHBORHOOD->GetDistanceCutoff(),
            SP_SCORE_AA_NEIGHBORHOOD->GetMinimalSequenceSeparation(),
            CONSIDER_DIFFERENT_CHAIN,
            true
          )
          :
          util::ShPtr< math::FunctionInterfaceSerializable< assemble::ProteinModel, assemble::AANeighborListContainer> >()
      ),
      m_Normalization( TYPE),
      m_Scheme( SP_SCORE_AA_NEIGHBORHOOD->GetScheme()),
      m_ScoreType( SCORE_TYPE),
      m_ReadableScheme( READABLE_SCHEME)
    {
      m_Scheme += GetTypeSuffix( TYPE);
      if( m_ReadableScheme.empty())
      {
        m_ReadableScheme = GetScheme();
      }
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new ProteinModelAANeighborhood copied from this one
    ProteinModelAANeighborhood *ProteinModelAANeighborhood::Clone() const
    {
      return new ProteinModelAANeighborhood( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelAANeighborhood::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelAANeighborhood::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculates the sum of exposures of all amino acids for the given ProteinModel
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return the sum of exposures of all amino acids for the given ProteinModel
    double ProteinModelAANeighborhood::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // check if protein model has a membrane
      const util::SiPtr< const biol::Membrane> sp_membrane
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane)
      );

      // collect AANeighborLists for all amino acids in the given protein model
      const assemble::AANeighborListContainer all_aa_neighbor_list
      (
        m_AANeighborListContainerGenerator->operator ()( PROTEIN_MODEL)
      );

      // count scored amino acids
      size_t number_scored_aas( 0);
      double score( 0);

      // vectors for storing contact numbers provided or computed from the folded model
      storage::Vector< double> predicted_contact_numbers;
      storage::Vector< double> model_contact_numbers;

      // iterate over all lists in the all_aa_neighbor_list
      assemble::AANeighborCount neighcount;
      for
      (
        assemble::AANeighborListContainer::const_iterator
          aa_itr( all_aa_neighbor_list.Begin()), aa_itr_end( all_aa_neighbor_list.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        const biol::AABase &current_aa( *aa_itr->second.GetCenterAminoAcid());

        // skip undefined aa types
        if( !current_aa.GetType().IsDefined() || !current_aa.GetType()->IsNaturalAminoAcid())
        {
          continue;
        }

        // check that the current amino acid has a defined coordinate
        if( !current_aa.GetFirstSidechainAtom().GetCoordinates().IsDefined())
        {
          continue;
        }

        // calculate exposure for the current amino acid
        const double current_score( m_ScoreAANeighborhood->operator()( aa_itr->second, sp_membrane));

        // average
        if( util::IsDefined( current_score) && current_score != double( 0))
        {
          if( m_Normalization == e_RMSD)
          {
            score += math::Sqr( current_score);
          }
          else if( m_Normalization == e_CorrelationPlusRelativeError)
          {
            // insert predicted contact number for the current amino acid
            predicted_contact_numbers.PushBack( current_aa.GetExposurePrediction());

            // insert model contact number
            model_contact_numbers.PushBack( neighcount( aa_itr->second));
          }
          else if( m_Normalization == e_FractionExplained)
          {
            score += ( current_score - current_aa.GetExposurePrediction()) / current_aa.GetExposurePrediction();
          }
          else
          {
            score += current_score;
          }
          ++number_scored_aas;
        }
      }

      // normalized final score over entire protein
      if( m_Normalization == e_Normalize && number_scored_aas > 0)
      {
        score /= double( number_scored_aas);
      }
      else if( m_Normalization == e_RMSD && number_scored_aas > 0)
      {
        score = math::Sqrt( score / double( number_scored_aas));
      }
      else if( m_Normalization == e_FractionExplained && number_scored_aas > 0)
      {
        score /= double( number_scored_aas);
      }
      else if( m_Normalization == e_CorrelationPlusRelativeError && number_scored_aas > 0)
      {
        // compute the Spearman (ranked) correlation coefficient between predicted contact numbers
        // and contact numbers derived from folded protein model
        const double spearman_correlation_coefficient( math::Statistics::CorrelationSpearman
          (
            predicted_contact_numbers.Begin(),
            predicted_contact_numbers.End(),
            model_contact_numbers.Begin(),
            model_contact_numbers.End()
          ));

        // get the number of potentially structured amino acids in the sse pool
        const util::ShPtr< assemble::SSEPool> sse_pool( PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool));
        const size_t number_potential_structured_aas( sse_pool->GetNumberPotentiallyStructuredAAs());

        // compute the completeness of the folded protein model
        const double completeness( number_scored_aas / double( number_potential_structured_aas));

        // total relative error of contact number computed based on the folded protein model
        double total_contact_number_relative_error( 0);
        for
        (
          storage::Vector< double>::const_iterator
            predicted_cn_itr( predicted_contact_numbers.Begin()), model_cn_itr( model_contact_numbers.Begin()),
            predicted_cn_itr_end( predicted_contact_numbers.End());
          predicted_cn_itr != predicted_cn_itr_end;
          ++predicted_cn_itr, ++model_cn_itr
        )
        {
          total_contact_number_relative_error +=
            math::Absolute( ( *predicted_cn_itr) - ( *model_cn_itr) / completeness) / ( *predicted_cn_itr);
        }

        // positive correlation is rewarding whereas deviation in averages is penalizing
        score = -spearman_correlation_coefficient * number_scored_aas + total_contact_number_relative_error * math::Sqr( completeness);
      }

      // end
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &ProteinModelAANeighborhood::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ScoreAANeighborhood, ISTREAM);
      io::Serialize::Read( m_AANeighborListContainerGenerator, ISTREAM);
      io::Serialize::Read( m_Normalization, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &ProteinModelAANeighborhood::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ScoreAANeighborhood, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AANeighborListContainerGenerator, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Normalization, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    ProteinModelAANeighborhood::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      // check if protein model has a membrane
      const util::SiPtr< const biol::Membrane> sp_membrane( PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane));

      // collect AANeighborLists for all amino acids in the given protein model
      const assemble::AANeighborListContainer all_aa_neighbor_list
      (
        m_AANeighborListContainerGenerator->operator ()( PROTEIN_MODEL)
      );

      // iterate over all lists in the all_aa_neighbor_list
      for
      (
        assemble::AANeighborListContainer::const_iterator
          aa_itr( all_aa_neighbor_list.Begin()), aa_itr_end( all_aa_neighbor_list.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        m_ScoreAANeighborhood->WriteDetailedSchemeAndValues( aa_itr->second, sp_membrane, OSTREAM) << '\n';
      }

      // end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_aa_neighborhood_docking.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_count.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_protein_model.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_aa_sequence.h"
#include "biol/bcl_biol_atom.h"
#include "biol/bcl_biol_membrane.h"
#include "fold/bcl_fold_default_flags.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_statistics.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelAANeighborhoodDocking::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelAANeighborhoodDocking())
    );

    //!
    //!
    ProteinModelAANeighborhoodDocking::ProteinModelAANeighborhoodDocking() :
      m_ScoreAANeighborhood(),
      m_Scheme( "aa_neighborhood_restraint")
    {
      // nothing else to do
    }

    //! @param SCORE_AA_NEIGHBORHOOD
    //! @param SCHEME
    ProteinModelAANeighborhoodDocking::ProteinModelAANeighborhoodDocking
    (
      const AANeighborhoodInterface &SCORE_AA_NEIGHBORHOOD,
      const std::string &SCHEME
    ) :
      m_ScoreAANeighborhood( SCORE_AA_NEIGHBORHOOD),
      m_Scheme( SCHEME)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new ProteinModelAANeighborhood copied from this one
    ProteinModelAANeighborhoodDocking *ProteinModelAANeighborhoodDocking::Clone() const
    {
      return new ProteinModelAANeighborhoodDocking( *this);
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelAANeighborhoodDocking::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelAANeighborhoodDocking::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProteinModelAANeighborhoodDocking::GetAlias() const
    {
      static const std::string s_alias( "ProteinModelAANeighborhoodDocking");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelAANeighborhoodDocking::GetSerializer() const
    {
      // create a Serializer object
      io::Serializer serializer;

      // set description
      serializer.SetClassDescription
      (
        "AANeighborhoodDocking is a scoring term that penalizes docked models "
        "in which the neighborhood environment of interface residues deviates "
        "from the given environment restraint"
      );
      serializer.AddInitializer
      (
        "environment type",
        "the neighborhood environment to be used",
        io::Serialization::GetAgent( &m_ScoreAANeighborhood)
      );

      // return the serializer
      return serializer;
    }

    //! @brief Set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @param ERROR_STREAM stream with which to write errors
    bool ProteinModelAANeighborhoodDocking::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM
    )
    {
      return true;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculates the sum of exposures of all amino acids for the given ProteinModel
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return the sum of exposures of all amino acids for the given ProteinModel
    double ProteinModelAANeighborhoodDocking::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // get the membrane
      const util::ShPtr< biol::Membrane> sp_membrane
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane)
      );

      //
      const util::ShPtr< math::FunctionInterfaceSerializable< assemble::ProteinModel, assemble::AANeighborListContainer> >
        aa_neighbor_list_container_generater
        (
          assemble::AANeighborListContainerGeneratorProteinModel::AANeighborListGenerator
          (
            m_ScoreAANeighborhood->GetDistanceCutoff(),
            m_ScoreAANeighborhood->GetMinimalSequenceSeparation(),
            true,
            true
          )
        );

      // all neighbor list
      const assemble::AANeighborListContainer all_neighbor_lists
      (
        aa_neighbor_list_container_generater->operator ()( PROTEIN_MODEL)
      );

      // initialize score
      double score( 0.0);

      // initialize the number of scored residues
      size_t number_of_scored_residues( 0);

      // iterate all neighbor lists
      for
      (
        assemble::AANeighborListContainer::const_iterator
          list_itr( all_neighbor_lists.Begin()), list_itr_end( all_neighbor_lists.End());
        list_itr != list_itr_end;
        ++list_itr
      )
      {
        // get central amino acid
        const util::SiPtr< const biol::AABase> sp_current_aa( list_itr->second.GetCenterAminoAcid());

        // skip undefined aa types
        if( !sp_current_aa->GetType().IsDefined() || !sp_current_aa->GetType()->IsNaturalAminoAcid())
        {
          continue;
        }

        // check that the current amino acid has a defined coordinate
        if( !sp_current_aa->GetFirstSidechainAtom().GetCoordinates().IsDefined())
        {
          continue;
        }

        // skip residues that have undefined exposure prediction
        if( !util::IsDefined( sp_current_aa->GetExposurePrediction()))
        {
          continue;
        }

        // skip non-membrane residues
        if
        (
          sp_membrane->DetermineEnvironmentType( sp_current_aa->GetFirstSidechainAtom().GetCoordinates())
            != biol::GetEnvironmentTypes().e_MembraneCore
        )
        {
          continue;
        }

        // compute the deviation
        double absolute_deviation( m_ScoreAANeighborhood->operator ()( list_itr->second, sp_membrane));

        // skip undefined deviations
        if( !util::IsDefined( absolute_deviation))
        {
          continue;
        }

        // update score
        score += math::Sqr( absolute_deviation);

        // update the number of scored residues
        number_of_scored_residues += 1;
      }

      // compute the RMSD-type score
      return math::Sqrt( score / number_of_scored_residues);
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &ProteinModelAANeighborhoodDocking::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ScoreAANeighborhood, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream object
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @return returns the output stream
    std::ostream &ProteinModelAANeighborhoodDocking::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ScoreAANeighborhood, OSTREAM);
      io::Serialize::Write( m_Scheme, OSTREAM);

      // return the stream object
      return OSTREAM;
    }

    //! @brief reads the exposure predictions from a file
    //! @param ISTREAM stream to read from
    //! @param PROTEIN_MODEL protein model to contain predictions
    void ProteinModelAANeighborhoodDocking::ReadPredictions( std::istream &ISTREAM, assemble::ProteinModel &PROTEIN_MODEL)
    {
      // vector that stores seq_id exposure pairs
      storage::Map< char, storage::Vector< storage::Pair< int, std::string> > > chain_exposure;

      // read residue seq_id and its corresponding exposure
      char chain_id;
      int seq_id;
      std::string exposure;
      while( ISTREAM >> chain_id >> seq_id >> exposure)
      {
        chain_exposure[ chain_id].PushBack( storage::Pair< int, std::string>( seq_id, exposure));
      }

      //iterate over all chains in the sequence
      for
      (
        util::ShPtrVector< assemble::Chain>::iterator chain_itr( PROTEIN_MODEL.GetChains().Begin()),
          chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // get exposures for the current chain
        const storage::Vector< storage::Pair< int, std::string> >
          current_chain_exposure( chain_exposure[ ( *chain_itr)->GetChainID()]);

        // read predictions for the sequence
        ReadPredictions( current_chain_exposure, *( *chain_itr)->GetSequence());
      }
    }

    //! @brief reads the exposure predictions from a file
    //! @param ISTREAM stream to read from
    //! @param SEQUENCE sequence to contain predictions
    void ProteinModelAANeighborhoodDocking::ReadPredictions
    (
      const storage::Vector< storage::Pair< int, std::string> > &CHAIN_EXPOSURE,
      biol::AASequence &SEQUENCE
    )
    {
      // assign exposure value to the right residue
      for
      (
        storage::Vector< storage::Pair< int, std::string> >::const_iterator
          exposure_itr( CHAIN_EXPOSURE.Begin()), exposure_itr_end( CHAIN_EXPOSURE.End());
        exposure_itr != exposure_itr_end;
        ++exposure_itr
      )
      {
        const size_t current_aa_index( exposure_itr->First() - 1);
        util::ShPtr< biol::AABase> sp_current_aa( SEQUENCE.GetAA( current_aa_index));
        sp_current_aa->SetExposurePrediction
        (
          util::ConvertStringToNumericalValue< double>( exposure_itr->Second())
        );
//          // iterate over the sequence
//          for
//          (
//            biol::AASequence::iterator aa_itr( SEQUENCE.Begin()), aa_itr_end( SEQUENCE.End());
//            aa_itr != aa_itr_end; ++aa_itr
//          )
//          {
//            // if no exposure value for current residue, set it to undefined
//            if( ( *aa_itr)->GetSeqID() != exposure_itr->First())
//            {
//              ( *aa_itr)->SetExposurePrediction( util::GetUndefinedDouble());
//            }
//            else
//            {
//              ( *aa_itr)->SetExposurePrediction( util::ConvertStringToNumericalValue< double>( exposure_itr->Second()));
//            }
//          }
      }
    }

  } // namespace score
} // namespace bcl

// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_completeness.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_atom.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelCompleteness::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelCompleteness())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from default values
    //! @param IGNORE_TERM_LOOPS ignore terminal loops for the calculation of the completeness
    //! @param SCHEME scheme of the score
    ProteinModelCompleteness::ProteinModelCompleteness( bool IGNORE_TERM_LOOPS, const std::string &SCHEME) :
      m_IgnoreTermLoops( IGNORE_TERM_LOOPS),
      m_Scheme( SCHEME)
    {
    }

    //! @brief returns a pointer to a new ProteinModelCompleteness
    //! @return pointer to a new ProteinModelCompleteness
    ProteinModelCompleteness *ProteinModelCompleteness::Clone() const
    {
      return new ProteinModelCompleteness( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &ProteinModelCompleteness::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the scheme of this score
    //! @return the scheme of this score
    const std::string &ProteinModelCompleteness::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief returns the default scheme of this score
    //! @return the default scheme of this score
    const std::string &ProteinModelCompleteness::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "coord_complete");
      return s_default_scheme;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProteinModelCompleteness::GetAlias() const
    {
      static const std::string s_name( "ProteinModelCompleteness");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelCompleteness::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Scores the completeness of a protein model.");
      serializer.AddInitializer
      (
        "ignore term loops",
        "ignore terminal loops for the completeness computation",
        io::Serialization::GetAgent( &m_IgnoreTermLoops),
        "False"
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief scores the completeness of the given protein model
    //! @detail the completeness is calculated by computing the ratio of residues with defined coordinates and the
    //! total number of residues in the sequence.
    //! @param PROTEIN_MODEL protein model for which to compute the completeness
    //! @return completeness of the given protein model with -1.0 being complete and 0.0 being empty
    double ProteinModelCompleteness::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // compute the total number of residues and the residues with defined coordinates
      const size_t num_residues( GetNumResidues( PROTEIN_MODEL));
      const size_t num_residues_defined( GetNumResiduesDefined( PROTEIN_MODEL));

      // compute the fraction only if there are residues in the model
      const double score( num_residues != 0 ? -( double) num_residues_defined / num_residues : 0.0);

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief computes the number of residues in the given chain
    //! @param CHAIN chain for which to compute the number of residues
    //! @return number of residues with in the given chain
    size_t ProteinModelCompleteness::GetNumResidues( const assemble::Chain &CHAIN) const
    {
      // get the total number of residues in the chain
      size_t num_residues( CHAIN.GetNumberAAs());

      // subtract the residues in terminal loops if required
      if( m_IgnoreTermLoops)
      {
        // skip if the first SSE is not a loop, otherwise subtract the number of residues in the loop
        const assemble::SSE &first_sse( **CHAIN.GetData().Begin());
        if( first_sse.GetType() == biol::GetSSTypes().COIL)
        {
          num_residues -= first_sse.GetSize();
        }

        // skip if the last SSE is not a loop, otherwise subtract the number of residues in the loop
        const assemble::SSE &last_sse( **--CHAIN.GetData().End());
        if( last_sse.GetType() == biol::GetSSTypes().COIL)
        {
          num_residues -= last_sse.GetSize();
        }
      }

      return num_residues;
    }

    //! @brief computes the number of residues in the given protein model
    //! @param MODEL protein model for which to compute the number of residues
    //! @return number of residues in the given protein model
    size_t ProteinModelCompleteness::GetNumResidues( const assemble::ProteinModel &MODEL) const
    {
      // sum up the number of residues in each chain
      size_t num_residues( 0);
      for
      (
        auto chain_it( MODEL.GetChains().Begin()), chain_it_end( MODEL.GetChains().End());
        chain_it != chain_it_end;
        ++chain_it
      )
      {
        num_residues += GetNumResidues( **chain_it);
      }

      return num_residues;
    }

    //! @brief computes the number of residues with defined backbone coordinates in a given SSE
    //! @param SSE SSE for which to compute the number of residues with defined backbone coordinates
    //! @return number of residues with defined backbone coordinates in the given SSE
    size_t ProteinModelCompleteness::GetNumResiduesDefined( const assemble::SSE &SSE) const
    {
      // get the residues in the SSE
      const util::SiPtrVector< const biol::AABase> &residues( SSE.GetData());

      // count the residues with defined backbone coordinates
      size_t num_residues_defined( 0);
      for( auto res_it( residues.Begin()), res_it_end( residues.End()); res_it != res_it_end; ++res_it)
      {
        if( ( **res_it).HasDefinedCoordinates())
        {
          ++num_residues_defined;
        }
      }

      return num_residues_defined;
    }

    //! @brief computes the number of residues with defined backbone coordinates in a given chain
    //! @param CHAIN chain for which to compute the number of residues with defined backbone coordinates
    //! @return number of residues with defined backbone coordinates in the given chain
    size_t ProteinModelCompleteness::GetNumResiduesDefined( const assemble::Chain &CHAIN) const
    {
      // get the residues in the chain
      const util::SiPtrVector< const biol::AABase> &residues( CHAIN.GetAminoAcids());

      // count the residues with defined backbone coordinates
      size_t num_residues_defined( 0);
      for( auto res_it( residues.Begin()), res_it_end( residues.End()); res_it != res_it_end; ++res_it)
      {
        if( ( **res_it).HasDefinedCoordinates())
        {
          ++num_residues_defined;
        }
      }

      // subtract the defined residues in terminal loops if required
      if( m_IgnoreTermLoops)
      {
        // skip if the first SSE is not a loop, otherwise subtract the number of residues in the loop
        const assemble::SSE &first_sse( *CHAIN.GetSSEs().FirstElement());
        if( first_sse.GetType() == biol::GetSSTypes().COIL)
        {
          num_residues_defined -= GetNumResiduesDefined( first_sse);
        }

        // skip if the last SSE is not a loop, otherwise subtract the number of residues in the loop
        const assemble::SSE &last_sse( *CHAIN.GetSSEs().LastElement());
        if( last_sse.GetType() == biol::GetSSTypes().COIL)
        {
          num_residues_defined -= GetNumResiduesDefined( last_sse);
        }
      }

      return num_residues_defined;
    }

    //! @brief computes the number of residues with defined backbone coordinates in a given protein model
    //! @param MODEL protein model for which to compute the number of residues with defined backbone coordinates
    //! @return number of residues with defined backbone coordinates in the given protein model
    size_t ProteinModelCompleteness::GetNumResiduesDefined( const assemble::ProteinModel &MODEL) const
    {
      // sum up the number of defined residues in each chain
      size_t num_residues_defined( 0);
      const util::ShPtrVector< assemble::Chain> chains( MODEL.GetChains());
      for( auto chain_it( chains.Begin()), chain_it_end( chains.End()); chain_it != chain_it_end; ++chain_it)
      {
        num_residues_defined += GetNumResiduesDefined( **chain_it);
      }

      return num_residues_defined;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  /////////////////
  // data access //
  /////////////////

    //! @brief conversion to a string from a Type
    //! @param TYPE the type to get a string for
    //! @return a string representing that type
    const std::string &ProteinModel::GetTypeName( const Type &TYPE)
    {
      static const std::string s_descriptors[] =
      {
        "Score (Structure)",
        "Score (Sequence|Structure)",
        "Score (Misc.)",
        "undefined",
        GetStaticClassName< ProteinModel>()
      };
      return s_descriptors[ size_t( TYPE)];
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief return true if PROTEIN_MODEL_LHS is less than PROTEIN_MODEL_RHS
    //! @param PROTEIN_MODEL_LHS first protein model score class
    //! @param PROTEIN_MODEL_RHS second protein model score class
    //! @return true if PROTEIN_MODEL_LHS is less than PROTEIN_MODEL_RHS
    bool ProteinModelLessThan::operator()
    (
      const ProteinModel &PROTEIN_MODEL_LHS, const ProteinModel &PROTEIN_MODEL_RHS
    ) const
    {
      // if the type of LHS is less than type of RHS
      if( PROTEIN_MODEL_LHS.GetType() < PROTEIN_MODEL_RHS.GetType())
      {
        return true;
      }

      // if the types are the same
      if( PROTEIN_MODEL_LHS.GetType() == PROTEIN_MODEL_RHS.GetType())
      {
        // check readable scheme
        if( PROTEIN_MODEL_LHS.GetReadableScheme() < PROTEIN_MODEL_RHS.GetReadableScheme())
        {
          return true;
        }
      }

      // otherwise return false
      return false;
    }

    //! @brief return true if PROTEIN_MODEL_LHS is less than PROTEIN_MODEL_RHS
    //! @param PROTEIN_MODEL_LHS first protein model score class
    //! @param PROTEIN_MODEL_RHS second protein model score class
    //! @return true if PROTEIN_MODEL_LHS is less than PROTEIN_MODEL_RHS
    bool ProteinModelLessThan::operator()
    (
      const util::PtrInterface< ProteinModel> &PROTEIN_MODEL_LHS,
      const util::PtrInterface< ProteinModel> &PROTEIN_MODEL_RHS
    ) const
    {
      return operator ()( *PROTEIN_MODEL_LHS, *PROTEIN_MODEL_RHS);
    }

    //! @brief return true if PROTEIN_MODEL_LHS is less than PROTEIN_MODEL_RHS
    //! @param PROTEIN_MODEL_LHS first protein model score class
    //! @param PROTEIN_MODEL_RHS second protein model score class
    //! @return true if PROTEIN_MODEL_LHS is less than PROTEIN_MODEL_RHS
    bool ProteinModelLessThan::operator()
    (
      const util::PtrInterface< const ProteinModel> &PROTEIN_MODEL_LHS,
      const util::PtrInterface< const ProteinModel> &PROTEIN_MODEL_RHS
    ) const
    {
      return operator ()( *PROTEIN_MODEL_LHS, *PROTEIN_MODEL_RHS);
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_defined_loops.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_atom.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
    const util::SiPtr< const util::ObjectInterface> ProteinModelDefinedLoops::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelDefinedLoops())
    );
  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from default values
    //! @param IGNORE_TERM_LOOPS ignore terminal loops for the calculation of the completeness
    //! @param SCHEME scheme of the score
    ProteinModelDefinedLoops::ProteinModelDefinedLoops( bool IGNORE_TERM_LOOPS, const std::string &SCHEME) :
      m_IgnoreTermLoops( IGNORE_TERM_LOOPS),
      m_Scheme( SCHEME)
    {
    }

    //! @brief returns a pointer to a new ProteinModelDefinedLoops
    //! @return pointer to a new ProteinModelDefinedLoops
    ProteinModelDefinedLoops *ProteinModelDefinedLoops::Clone() const
    {
      return new ProteinModelDefinedLoops( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &ProteinModelDefinedLoops::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the scheme of this score
    //! @return the scheme of this score
    const std::string &ProteinModelDefinedLoops::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief returns the default scheme of this score
    //! @return the default scheme of this score
    const std::string &ProteinModelDefinedLoops::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "loops_defined");
      return s_default_scheme;
    }
    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &ProteinModelDefinedLoops::GetAlias() const
    {
      static const std::string s_name( "ProteinModelDefinedLoops");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelDefinedLoops::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "scores the loop completeness of a protein model");
      serializer.AddInitializer
      (
        "ignore term loops",
        "ignore terminal loops for the calculation of the completeness",
        io::Serialization::GetAgent( &m_IgnoreTermLoops),
        "false"
      );
      return serializer;
    }
  ////////////////
  // operations //
  ////////////////

    //! @brief scores the loop completeness of the given protein model
    //! @detail the loop completeness is calculated by computing the number of loops with fully defined
    //! backbone coordinates.
    //! @param PROTEIN_MODEL protein model for which to compute the loop completeness
    //! @return loop completeness of the given protein model with -1 * number of defined loops
    double ProteinModelDefinedLoops::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // get the loops in the protein model
      const util::SiPtrVector< const assemble::SSE> loops( PROTEIN_MODEL.GetSSEs( biol::GetSSTypes().COIL));

      // determine the number of loops with undefined coordinates
      size_t undefined_loops( 0);
      for( auto loop_it( loops.Begin()), loop_it_end( loops.End()); loop_it != loop_it_end; ++loop_it)
      {
        // loop to be scored
        const assemble::SSE &loop( **loop_it);

        // check if current loop is terminal and ignore it if necessary
        const biol::AABase &first_res( *loop.GetFirstMember());
        const biol::AABase &last_res( *loop.GetLastMember());
        const size_t seq_length
        (
          PROTEIN_MODEL.GetChain( loop.GetChainID())->GetSequence()->GetMembers().GetSize()
        );
        if( !m_IgnoreTermLoops || ( first_res.GetSeqID() != 1 && ( size_t) last_res.GetSeqID() != seq_length))
        {
          if( !IsDefined( loop))
          {
            ++undefined_loops;
          }
        }
      }

      return undefined_loops;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief reads members from an input stream
    //! @param ISTREAM input stream to read members from
    //! @return the input stream
    std::istream &ProteinModelDefinedLoops::Read( std::istream &ISTREAM)
    {
      // read members from input stream
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_IgnoreTermLoops, ISTREAM);

      return ISTREAM;
    }

    //! @brief writes members into an output stream
    //! @param OSTREAM output stream to write members into
    //! @INDENT number of indentations to use
    //! @return the output stream
    std::ostream &ProteinModelDefinedLoops::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members into output stream
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_IgnoreTermLoops, OSTREAM, INDENT);

      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief determines if all coordinates in the given SSE are defined
    //! @param SSE SSE for which to determine if all coordinates are defined
    //! @return true, if all coordinates of the given SSE are defined
    bool ProteinModelDefinedLoops::IsDefined( const assemble::SSE &SSE) const
    {
      // get the residues in the SSE
      const util::SiPtrVector< const biol::AABase> &residues( SSE.GetData());

      // count the residues with defined backbone coordinates
      for( auto res_it( residues.Begin()), res_it_end( residues.End()); res_it != res_it_end; ++res_it)
      {
        if( !( **res_it).HasDefinedCoordinates())
        {
          return false;
        }
      }

      return true;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_fragment_topology.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_topology_combined.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_geometry_packing_pickers.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "assemble/bcl_assemble_sse_pool_agreement.h"
#include "assemble/bcl_assemble_topology.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////
    
    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> ProteinModelFragmentTopology::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelFragmentTopology())
    );
   
  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////
    
    //! @brief Clone function
    //! @return pointer to new ProteinModelFragmentTopology
    ProteinModelFragmentTopology *ProteinModelFragmentTopology::Clone() const
    {
      return new ProteinModelFragmentTopology( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelFragmentTopology::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate and return the percentage of recovered contacts
    //! @param TEMPLATE the known correct protein model
    //! @param MODEL the protein model to be evaluated against the TEMPLATE
    //! @return the percentage of recovered contacts
    double ProteinModelFragmentTopology::operator()
    ( 
      const assemble::ProteinModel &TEMPLATE, 
      const assemble::ProteinModel &MODEL
    ) const
    {
      // get sequences
      util::SiPtrVector< const biol::AASequence> template_seqs( TEMPLATE.GetSequences());
      util::SiPtrVector< const biol::AASequence> model_seqs( MODEL.GetSequences());

      size_t model_size( MODEL.GetNumberAAs());
      size_t template_size( TEMPLATE.GetNumberAAs());

      util::SiPtrVector< const biol::AASequence>::const_iterator template_seq_itr( template_seqs.Begin());
      for
      ( 
        util::SiPtrVector< const biol::AASequence>::const_iterator model_seq_itr( model_seqs.Begin()),
        model_seq_itr_end( model_seqs.End());
        model_seq_itr != model_seq_itr_end;
        model_seq_itr++, template_seq_itr++
      )
      {
        // make sure template and model have the same sequence
        const biol::AASequence model_seq( **model_seq_itr);
        const biol::AASequence template_seq( **template_seq_itr);

         BCL_Assert
        (
          model_seq == template_seq,
          "model and template must have the same sequence"
        );
      }

      //initialize matrices of fragment interactions for template and model
      linal::Matrix< double> model_matrix( MODEL.CalculateFragmentInteractions());
      linal::Matrix< double> template_matrix( TEMPLATE.CalculateFragmentInteractions());

      //calculate distance between the two matrices
      double temp_value( 0);
      double model_value( 0);

      // calculate euclidean distance between matices
      double norm( linal::Distance( model_matrix.AsVector(), template_matrix.AsVector()));

      return norm;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelFragmentTopology::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelFragmentTopology::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }
    
  /////////////////////
  // helper funtions //
  /////////////////////
    
  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_gap.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_atom.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelGap::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelGap())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from default values
    //! @param SCHEME scheme of the score
    ProteinModelGap::ProteinModelGap( const std::string &SCHEME) :
      m_Scheme( SCHEME),
      m_Score()
    {
    }

    //! @brief returns a pointer to a new ProteinModelGap
    //! @return pointer to a new ProteinModelGap
    ProteinModelGap *ProteinModelGap::Clone() const
    {
      return new ProteinModelGap( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &ProteinModelGap::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the scheme of this score
    //! @return the scheme of this score
    const std::string &ProteinModelGap::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief returns the default scheme of this score
    //! @return the default scheme of this score
    const std::string &ProteinModelGap::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "gap");
      return s_default_scheme;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProteinModelGap::GetAlias() const
    {
      static const std::string s_name( "ProteinModelGap");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelGap::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Scoring function to penalize gaps in protein models.");

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Score a protein model regarding gaps.
    //! @param PROTEIN_MODEL protein model for which to compute the gap score
    //! @return gap score of the protein model
    double ProteinModelGap::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // sum up gap score for all chains in the model
      double score( 0.0);
      const util::SiPtrVector< const biol::AASequence> chains( PROTEIN_MODEL.GetSequences());
      for( auto chain_it( chains.Begin()), chain_it_end( chains.End()); chain_it != chain_it_end; ++chain_it)
      {
        score += ComputeGapScore( **chain_it);
      }

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief Compute the gap score for the given sequence.
    //! @param SEQUENCE Sequence for which to compute the gap score.
    //! @return Gap score for the given sequence.
    double ProteinModelGap::ComputeGapScore( const biol::AASequence &SEQUENCE) const
    {
      double score( 0.0);
      const util::ShPtrVector< biol::AABase> aas( SEQUENCE.GetData());
      util::ShPtr< biol::AABase> def_n;
      util::ShPtr< biol::AABase> def_c;
      for( auto res_it( aas.Begin()), res_it_end( aas.End()); res_it != res_it_end; ++res_it)
      {
        const biol::AABase &current_aa( **res_it);
        if( current_aa.HasDefinedCoordinates())
        {
          def_n = *res_it;
        }
        else if( def_n.IsDefined() && def_n->GetSeqID() < current_aa.GetSeqID())
        {
          for( auto res_find_it( res_it + 1); res_find_it != res_it_end; ++res_find_it)
          {
            const util::ShPtr< biol::AABase> sp_c_cand( *res_find_it);
            if( sp_c_cand->HasDefinedCoordinates())
            {
              def_c = *res_find_it;
              res_it = res_find_it - 1;
              const size_t sequence_distance( def_c->GetSeqID() - def_n->GetSeqID() - 1);
              const double euclidean_distance( ( def_c->GetCA().GetCoordinates() - def_n->GetCA().GetCoordinates()).Norm());
              const storage::Pair< size_t, double> gap_parameters( sequence_distance, euclidean_distance);
              // score += m_Score.Score( gap_parameters);
              score += ComputeGapScore( *def_n, *def_c);
              break;
            }
          }
        }

      }

      return score;
    }

    //! @brief Compute the gap score for the given endpoints of the gap.
    //! @param AA_N n-terminal endpoint of the gap
    //! @param AA_C c-terminal endpoint of the gap
    //! @return Gap score for the given sequence.
    double ProteinModelGap::ComputeGapScore( const biol::AABase &AA_N, const biol::AABase &AA_C) const
    {
      const size_t seq_dist( AA_C.GetSeqID() - AA_N.GetSeqID() - 1);
      const double euclidean_dist( ( AA_C.GetCenter() - AA_N.GetCenter()).Norm());
      const double score( euclidean_dist / seq_dist);

      return score;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_inverted.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelInverted::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelInverted())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelInverted::ProteinModelInverted() :
      m_Score(),
      m_Inverter(),
      m_Scheme()
    {
    }

    //! @brief constructor from a score function, a inverter and a scheme
    //! @param SP_SCORE ShPtr to ProteinModel scoring function to be used
    //! @param SP_INVERTER ShPtr to ProteinModelInverter to be used
    //! @param SCHEME Scheme to be used
    //! @param SCORE_TYPE score type
    //! @param READABLE_SCHEME scheme that is more human readable
    ProteinModelInverted::ProteinModelInverted
    (
      const util::ShPtr< ProteinModel> &SP_SCORE,
      const util::ShPtr< assemble::ProteinModelInverter> &SP_INVERTER,
      const std::string &SCHEME,
      const ProteinModel::Type &SCORE_TYPE,
      const std::string &READABLE_SCHEME
    ) :
      m_Score( SP_SCORE),
      m_Inverter( SP_INVERTER),
      m_Scheme( SCHEME),
      m_ScoreType( SCORE_TYPE),
      m_ReadableScheme( READABLE_SCHEME)
    {
      if( m_ReadableScheme.empty())
      {
        m_ReadableScheme = GetScheme();
      }
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelInverted
    ProteinModelInverted *ProteinModelInverted::Clone() const
    {
      return new ProteinModelInverted( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelInverted::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief invert the given ProteinModel and score it
    //! @param PROTEIN_MODEL ProteinModel to be inverted and scored
    //! @return score of the inverted model
    double ProteinModelInverted::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // calculate the inverted model
      util::ShPtr< assemble::ProteinModel> sp_inverted_model( m_Inverter->GetInvertedModel( PROTEIN_MODEL));

      // make sure it is defined
      BCL_Assert( sp_inverted_model.IsDefined(), "ProteinModelInverter returned empty ShPtr");

      // calculate score and return it
      return m_Score->operator ()( *sp_inverted_model);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelInverted::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Score, ISTREAM);
      io::Serialize::Read( m_Inverter, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelInverted::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Score, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Inverter, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_loop_domain_closure.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_locator_loop_domain.h"
#include "fold/bcl_fold_loop_domain.h"
#include "fold/bcl_fold_mutate_protein_model_loop_domain_ccd.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelLoopDomainClosure::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelLoopDomainClosure())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelLoopDomainClosure::ProteinModelLoopDomainClosure()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelLoopDomainClosure
    ProteinModelLoopDomainClosure *ProteinModelLoopDomainClosure::Clone() const
    {
      return new ProteinModelLoopDomainClosure( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelLoopDomainClosure::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &ProteinModelLoopDomainClosure::GetAlias() const
    {
      static const std::string s_name( "ProteinModelLoopDomainClosure");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelLoopDomainClosure::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      (
        "Scores how close the a loop is to being closed according to the psuedo residue, target residue, and atoms"
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score after replicating the protein model using symmetry
    //! @param PROTEIN_MODEL protein model to be scored
    //! @return the score after replicating the protein model using symmetry
    double ProteinModelLoopDomainClosure::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // get the loop domain locator from model data
      util::ShPtr< util::ShPtrList< fold::LocatorLoopDomain> > sp_loop_domains(
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_LoopDomainLocators));

      // initialize score
      double score( 0.0);

      // make sure it's defined
      if( !sp_loop_domains.IsDefined())
      {
        BCL_MessageDbg( "Loop domain locators are not stored with the given model");
        return score;
      }

      // iterate through the list of loop domains
      for
      (
        auto loop_itr( sp_loop_domains->Begin()), loop_itr_end( sp_loop_domains->End());
        loop_itr != loop_itr_end;
        ++loop_itr
      )
      {
        util::ShPtr< fold::LoopDomain> sp_loop_domain( ( *loop_itr)->Locate( PROTEIN_MODEL));
        if( !sp_loop_domain.IsDefined())
        {
          continue;
        }

        // create list of TargetAndMovingPointPair objects using the current model
        const storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair> target_and_moving_points
        (
          sp_loop_domain->TargetAndMovingPointsForCCD( PROTEIN_MODEL)
        );

        if( target_and_moving_points.IsEmpty())
        {
          // score does not change if no target and moving points. this unfortunately means emptiness is favored
          // but protein model should be complete at anyways. score entropy scores inverse (i.e. empty model)
          BCL_MessageStd(
            "There are no target and moving points for loop domain " + util::Format()( ( *loop_itr)->GetIdentification()));
          continue;
        }

        double rmsd( fold::LocatorLoopDomain::CalculateSquareDistanceSum( target_and_moving_points));

        BCL_MessageDbg(
          " loop domain score sum_square_distance for: " + ( *loop_itr)->GetLoopSegments().Begin()->GetIdentification() + " is: " + util::Format()( rmsd));

        rmsd /= target_and_moving_points.GetSize();
        rmsd = math::Sqrt( rmsd);

        static const double s_peptide_bond_length( biol::GetAtomTypes().C->GetBondLength( biol::GetAtomTypes().N));

        // sum up the score
        score += std::log( rmsd / s_peptide_bond_length);
      }

      // return the score
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_membrane_topology.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_locator_domain_sse_pool_overlapping.h"
#include "biol/bcl_biol_atom.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "fold/bcl_fold_setup.h"
#include "io/bcl_io_file.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelMembraneTopology::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelMembraneTopology())
    );

    //! @brief gives the flag that allows the input of the filename of the pool containing the expectd tm helices
    //! @return shptr to flag with parameter for providing the expected transmembrane helices
    const util::ShPtr< command::FlagInterface> &
    ProteinModelMembraneTopology::GetFlagExpectedTransmembraneHelicesPoolFile()
    {
      static const util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "tm_helices",
          "The pool formatted file containing the expected tm helices that the protein model will be scored against",
          command::Parameter
          (
            "pool_file", "filename of the pool formatted file containing the expected helices", "tm_helices.pool"
          )
        )
      );

      return s_flag;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelMembraneTopology::ProteinModelMembraneTopology() :
      m_TransmembraneDomain(),
      m_SSEPool(),
      m_Scheme( GetStaticClassName< ProteinModelMembraneTopology>())
    {
    }

    //! @brief constructor taking member variables
    //! @param LOCATOR the locator that will be used to locate the transmembrane domains of the protein model
    //! @param POOL the pool of sses identifying the transmembrane sses
    //! @param SCHEME the scheme of this score
    ProteinModelMembraneTopology::ProteinModelMembraneTopology
    (
      const util::ShPtr< find::LocatorInterface< util::ShPtr< assemble::Domain>, assemble::ProteinModel> > &LOCATOR,
      const assemble::SSEPool &POOL,
      const std::string &SCHEME
    ) :
      m_TransmembraneDomain( LOCATOR),
      m_SSEPool( POOL),
      m_Scheme( SCHEME)
    {
      BCL_Assert
      (
        !m_SSEPool.IsOverlapping(), "SSE pool has overlapping SSE definitions. "
         "Please choose which unique transmembrane segments you would like to use."
      );

      BCL_Assert
      (
        m_SSEPool.GetSSEs( biol::GetSSTypes().STRAND).GetSize() == 0, "Expected TM SSEs pool should only have helices"
      );
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelMembraneTopology
    ProteinModelMembraneTopology *ProteinModelMembraneTopology::Clone() const
    {
      return new ProteinModelMembraneTopology( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelMembraneTopology::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelMembraneTopology::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief get a more readable score scheme
    //! @return a more readable score scheme
    const std::string &ProteinModelMembraneTopology::GetReadableScheme() const
    {
      static const std::string s_readable_scheme( "MP topology");
      return s_readable_scheme;
    }

    //! @brief get score type
    //! @return score type
    ProteinModel::Type ProteinModelMembraneTopology::GetType() const
    {
      return ProteinModel::e_Structure;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief initialize this score from the flag
    bool ProteinModelMembraneTopology::InitializeFromFlag()
    {
      if( !GetFlagExpectedTransmembraneHelicesPoolFile()->GetFlag())
      {
        return false;
      }
      io::IFStream read;
      std::string pool_filename
      (
        GetFlagExpectedTransmembraneHelicesPoolFile()->GetFirstParameter()->GetValue()
      );
      io::File::MustOpenIFStream( read, pool_filename);
      m_SSEPool.ReadSSEPool( read, *fold::GetSetup().GetEmptyModel(), 9, 3);
      io::File::CloseClearFStream( read);
      // make a domain locator
      m_TransmembraneDomain = util::ShPtr< assemble::LocatorDomainSSEPoolOverlapping>
      (
        new assemble::LocatorDomainSSEPoolOverlapping( m_SSEPool)
      );
      m_Scheme = "mp_helix_topology";
      return true;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an PROTEIN_MODEL and returning a t_ResultType object
    //! @param PROTEIN_MODEL Protein Model to be used to evaluate the function
    //! @return function value of the given argument
    double ProteinModelMembraneTopology::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // locate the transmebmrane domain
      const util::ShPtr< assemble::Domain> transmembrane_domain( m_TransmembraneDomain->Locate( PROTEIN_MODEL));
      BCL_MessageDbg
      (
        "transmembrane domain size " + util::Format()( transmembrane_domain->GetSSEs().GetSize())
      );

      // to hold the tm sses coming from the sse pool and the associated sses from the located tm domain
      storage::Map
      <
        util::SiPtr< const assemble::SSE>, //< expected tm segment
        storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThan>, //< model tm sses
        assemble::SSELessThan
      > tm_assignments( AssociateModelTMSSEsWithExpectedTMSegments( *transmembrane_domain, m_SSEPool));

      double score( 0);

      // check n-termini
      {
        // to hold the side of the membrane the nterminal ca atom is on for each transmembrane sse in the model
        // and the chain the sse is in
        storage::Map< size_t, storage::Vector< storage::Pair< double, char> > > membrane_side_coordinates
        (
          GetExpectedMembraneSideAndModelSSETerminusCoordinates( tm_assignments, m_SSEPool.GetSSEs(), true)
        );

        // get the score it is not normalized; penalize ntermini that should be on the same side but are not
        score += ScoreTopology( membrane_side_coordinates);

        BCL_MessageDbg( "n-termini ScoreTopology score is " + util::Format()( score));

        // penalize ntermini that are on the same side but shouldn't be
        score += ScoreTopologyOpposingSides( membrane_side_coordinates);

        BCL_MessageDbg( "n-termini ScoreTopologyOpposingSides score is " + util::Format()( score));
      }

      // check c-termini
      {
        // to hold the side of the membrane the cterminal ca atom is on for each transmembrane sse in the model
        // and the chain the sse is in
        storage::Map< size_t, storage::Vector< storage::Pair< double, char> > > membrane_side_coordinates
        (
          GetExpectedMembraneSideAndModelSSETerminusCoordinates( tm_assignments, m_SSEPool.GetSSEs(), false)
        );

        score += ScoreTopology( membrane_side_coordinates);

        BCL_MessageDbg( "c-termini ScoreTopology score is " + util::Format()( score));

        // penalize ntermini that are on the same side but shouldn't be
        score += ScoreTopologyOpposingSides( membrane_side_coordinates);

        BCL_MessageDbg( "c-termini ScoreTopologyOpposingSides score is " + util::Format()( score));
      }

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelMembraneTopology::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_TransmembraneDomain, ISTREAM);
      io::Serialize::Read( m_SSEPool, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelMembraneTopology::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_TransmembraneDomain, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SSEPool, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief associate the expected tm sses coming from the sse pool with the sses from the located tm domain
    //! @param TRANSMEMBRANE_DOMAIN
    //! @param EXPECTED_TM_SEGMENTS
    //! @return map with the expected tm sse as the key and the set of associated model tm sses as the value.
    //!         there can be multiple model sses associated with an expected tm sse since in the model the whole tm
    //!         segment might be broken
    storage::Map
    <
      util::SiPtr< const assemble::SSE>,
      storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThan>,
      assemble::SSELessThan
    > ProteinModelMembraneTopology::AssociateModelTMSSEsWithExpectedTMSegments
    (
      const assemble::Domain &TRANSMEMBRANE_DOMAIN, const assemble::SSEPool &EXPECTED_TM_SEGMENTS
    )
    {
      storage::Map
      <
        util::SiPtr< const assemble::SSE>,
        storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThan>,
        assemble::SSELessThan
      > tm_assignments;

      // iterate through the sses in the domain
      for
      (
        storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
          domain_itr( TRANSMEMBRANE_DOMAIN.GetData().Begin()), domain_itr_end( TRANSMEMBRANE_DOMAIN.GetData().End());
        domain_itr != domain_itr_end;
        ++domain_itr
      )
      {
        // reference on current sse
        const assemble::SSE &current_sse( **domain_itr);

        BCL_MessageDbg( "checking domain sse " + current_sse.GetIdentification());

        // get the best matching sse out of the sse pool
        const util::SiPtr< const assemble::SSE> best_tm_match
        (
          EXPECTED_TM_SEGMENTS.FindBestMatchFromPool( current_sse, 10).First()
        );

        // true if no match could be found
        if( !best_tm_match.IsDefined())
        {
          BCL_MessageDbg( "no match could be found for sse " + current_sse.GetIdentification());
          // go to next sse
          continue;
        }

        // assign the current sse to the best tm match from the sse pool
        tm_assignments[ best_tm_match].Insert( *domain_itr);
        BCL_MessageDbg
        (
          "associated " + ( *domain_itr)->GetIdentification() + " with expected tm sse "
          + best_tm_match->GetIdentification()
        );
      }

      return tm_assignments;
    }

    //! @brief For a side of the membrane, gathers the coordinates of the n-termini of SSEs that should be on that side
    //!        The side is implicitly defined by the fact that all expected TM sses are provided, and every other SSE
    //!        should have its n-terminus on the same side
    //! @param EXPECTED_AND_MODEL_TM_SSES the assignment of an expected TM sse with corresponding sses from the model
    //! @param ALL_EXPECTED_TM_SSES the list of all expected SSEs
    //! @return map which has a size_t representing a side of the membrane, and the corresponding coordinates from
    //!         model sses assigned to expected tm sses whose n-termini should be on the same side of the membrane
    //!         The char is the chain id of the sse, because if the sses aren't in the same chain they should not be
    //!         compared together
    storage::Map< size_t, storage::Vector< storage::Pair< double, char> > >
    ProteinModelMembraneTopology::GetExpectedMembraneSideAndModelSSETerminusCoordinates
    (
      const storage::Map
      <
        util::SiPtr< const assemble::SSE>,
        storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThan>,
        assemble::SSELessThan
      > &EXPECTED_AND_MODEL_TM_SSES,
      const util::SiPtrVector< const assemble::SSE> &ALL_EXPECTED_TM_SSES,
      const bool N_TERMINUS
    )
    {
      // to hold the side of the membrane the nterminal ca atom is on for each transmembrane sse in the model
      storage::Map< size_t, storage::Vector< storage::Pair< double, char> > > membrane_side_coordinates;

      // iterate through the sse pool of tm segments
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          pool_tm_sse_itr( ALL_EXPECTED_TM_SSES.Begin()), pool_tm_sse_itr_end( ALL_EXPECTED_TM_SSES.End());
        pool_tm_sse_itr != pool_tm_sse_itr_end;
        ++pool_tm_sse_itr
      )
      {
        storage::Map
        <
          util::SiPtr< const assemble::SSE>,
          storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThan>,
          assemble::SSELessThan
        >::const_iterator assignment_itr( EXPECTED_AND_MODEL_TM_SSES.Find( *pool_tm_sse_itr));

        // true if there are no sses in the model corresponding to the current tm sse
        if( assignment_itr == EXPECTED_AND_MODEL_TM_SSES.End())
        {
          continue;
        }

        // build up set of sses from the fragments overlapping with the tm sse to ensure they are ordered by sequence
        const storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThan> &model_tm_segments
        (
          assignment_itr->second
        );

        // the z-coordinate of the terminus of the sse of interest
        const assemble::SSE &model_tm_segment( N_TERMINUS ? **model_tm_segments.Begin() : **( --model_tm_segments.End()));
        const double z_coordinate
        (
          N_TERMINUS ? model_tm_segment.GetFirstAA()->GetCA().GetCoordinates().Z() :
                       model_tm_segment.GetLastAA()->GetCA().GetCoordinates().Z()
        );

        BCL_MessageDbg( "current expected TM SSE is " + ( *pool_tm_sse_itr)->GetIdentification());
        BCL_MessageDbg
        (
          "current membrane side is tm sse # "
          + util::Format()( pool_tm_sse_itr - ALL_EXPECTED_TM_SSES.Begin()) + " = membrane side "
          + util::Format()( ( pool_tm_sse_itr - ALL_EXPECTED_TM_SSES.Begin()) % 2)
        );
        BCL_MessageDbg
        (
          "current model segment is "
          + model_tm_segment.GetIdentification()
        );
        BCL_MessageDbg
        (
          "current model nterminal coordinate is "
          + util::Format()( z_coordinate)
        );

        // ntermini should be on alternating sides of the membrane - arbitrarily assign even indices to one side, and
        // odd to the other. on either side, z coordinate of nterminal ca atom of each sse should have the same sign
        membrane_side_coordinates[ ( pool_tm_sse_itr - ALL_EXPECTED_TM_SSES.Begin()) % 2].PushBack
        (
          storage::Pair< double, char>( z_coordinate, model_tm_segment.GetChainID())
        );
      }

      return membrane_side_coordinates;
    }

    //! @brief scores the agreement of the actual arrangement of sses with the expected arrangement
    //! @param TOPOLOGY map that implicitly holds the expected and model topologies. The size_t indicates a side of
    //!        the membrane, the vector of doubles is the coordinates of the nterminus of sses that should be on that
    //!        side of the membrane.
    //! @return double which is the score of the agreement of the model sse topology with expected topology
    double ProteinModelMembraneTopology::ScoreTopology
    (
      const storage::Map< size_t, storage::Vector< storage::Pair< double, char> > > &TOPOLGY
    )
    {
      double score( 0);

      // count number of times z coordinates don't match sign even though they should be on the same side of membrane
      for
      (
        storage::Map< size_t, storage::Vector< storage::Pair< double, char> > >::const_iterator
          membrane_side_itr( TOPOLGY.Begin()),
          membrane_side_itr_end( TOPOLGY.End());
        membrane_side_itr != membrane_side_itr_end;
        ++membrane_side_itr
      )
      {
        // get the coordinates for this side
        const storage::Vector< storage::Pair< double, char> > &coordinates( membrane_side_itr->second);

        // iterate through the coordinates
        for
        (
          storage::Vector< storage::Pair< double, char> >::const_iterator
            coordinate_itr( coordinates.Begin()), coordinate_itr_end( coordinates.End());
          coordinate_itr != coordinate_itr_end;
          ++coordinate_itr
        )
        {
          // iterate through the coordinates
          for
          (
            storage::Vector< storage::Pair< double, char> >::const_iterator coordinate_itr_b( coordinate_itr + 1);
            coordinate_itr_b != coordinate_itr_end;
            ++coordinate_itr_b
          )
          {
            // true if the coordiantes are on opposite sides of the membrane i.e. z coordinates have opposite signs
            // and they are in the same chain
            if
            (
              ( coordinate_itr_b->First() / coordinate_itr->First()) < 0 &&
              coordinate_itr_b->Second() == coordinate_itr->Second()
            )
            {
              ++score;
            }
          }
        }
      }

      return score;
    }

    //! @brief scores the agreement of the actual arrangement of sses with the expected arrangement
    //!        Penalizes occurances of ntermini being on the same side of the membrane although they shouldn't be,
    //!        since their arrangement would force a loop to go through the membrane
    //! @param TOPOLOGY map that implicitly holds the expected and model topologies. The size_t indicates a side of
    //!        the membrane, the vector of doubles is the coordinates of the nterminus of sses that should be on that
    //!        side of the membrane.
    //! @return double which is the score of the agreement of the model sse topology with expected topology
    double ProteinModelMembraneTopology::ScoreTopologyOpposingSides
    (
      const storage::Map< size_t, storage::Vector< storage::Pair< double, char> > > &TOPOLGY
    )
    {
      double score( 0);

      // count number of times z coordinates match sign even though they shouldn't be on the same side of membrane
      for
      (
        storage::Map< size_t, storage::Vector< storage::Pair< double, char> > >::const_iterator
          membrane_side_itr( TOPOLGY.Begin()),
          membrane_side_itr_end( TOPOLGY.End());
        membrane_side_itr != membrane_side_itr_end;
        ++membrane_side_itr
      )
      {
        // get the coordinates for this side
        const storage::Vector< storage::Pair< double, char> > &coordinates( membrane_side_itr->second);

        // iterate through membrane side again
        for
        (
          storage::Map< size_t, storage::Vector< storage::Pair< double, char> > >::const_iterator
            membrane_side_itr_b
            (
              ++storage::Map< size_t, storage::Vector< storage::Pair< double, char> > >::const_iterator( membrane_side_itr)
            );
            membrane_side_itr_b != membrane_side_itr_end;
          ++membrane_side_itr_b
        )
        {
          // get the coordinates for this side
          const storage::Vector< storage::Pair< double, char> > &coordinates_b( membrane_side_itr_b->second);

          // iterate through the coordinates
          for
          (
            storage::Vector< storage::Pair< double, char> >::const_iterator
              coordinate_itr( coordinates.Begin()), coordinate_itr_end( coordinates.End());
            coordinate_itr != coordinate_itr_end;
            ++coordinate_itr
          )
          {
            // iterate through the coordinates
            for
            (
              storage::Vector< storage::Pair< double, char> >::const_iterator
                coordinate_itr_b( coordinates_b.Begin()), coordinate_itr_b_end( coordinates_b.End());
              coordinate_itr_b != coordinate_itr_b_end;
              ++coordinate_itr_b
            )
            {
              // true if the coordinates are on same sides of the membrane i.e. z coordinates have same signs
              // and they have the same chain id
              if
              (
                ( coordinate_itr_b->First() / coordinate_itr->First()) > 0 &&
                coordinate_itr_b->Second() == coordinate_itr->Second()
              )
              {
                ++score;
              }
            }
          }
        }
      }

      return score;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_score_sum.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model_multiplier.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> ProteinModelScoreSum::s_Instance
    (
      // while this class, in principle, could be added to the util::Enumerated< ProteinModel> set,
      // math::SumFunctionMixin already satisfies all functionality covered by score::ProteinModel, so there
      // would be no benefit. This class just extends those methods with alternative formatting for non-interface
      // functions
      GetObjectInstances().AddInstance( new ProteinModelScoreSum())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelScoreSum::ProteinModelScoreSum( const std::string &SCHEME) :
      math::SumFunctionMixin< ProteinModel>( SCHEME)
    {
    }

    //! @brief constructor from a map of functions and weights
    //! @param SCORE_WEIGHT_MAP map of scores and corresponding weights
    ProteinModelScoreSum::ProteinModelScoreSum
    (
      const storage::Map< util::ShPtr< ProteinModel>, double> &SCORE_WEIGHT_MAP
    ) :
      math::SumFunctionMixin< ProteinModel>()
    {
      AddScoresWithWeights( SCORE_WEIGHT_MAP);
    }

    //! @brief constructor from a map of Score enums and weights
    //! @param SCORE_WEIGHT_MAP map of scores and corresponding weights
    ProteinModelScoreSum::ProteinModelScoreSum
    (
      const storage::Map< fold::Score, double> &SCORE_WEIGHT_MAP
    ) :
      math::SumFunctionMixin< ProteinModel>()
    {
      // iterate over weights map provided
      for
      (
        storage::Map< fold::Score, double>::const_iterator
          map_itr( SCORE_WEIGHT_MAP.Begin()), map_itr_end( SCORE_WEIGHT_MAP.End());
        map_itr != map_itr_end; ++map_itr
      )
      {
        // if the weight is equal to 0
        if( map_itr->second == double( 0.0))
        {
          // skip this one
          BCL_MessageStd
          (
            "Weight is equal to 0, therefore not adding the following score " + map_itr->first.GetName()
          );
        }
        // otherwise
        else
        {
          // add the score
          NewOperand( **map_itr->first, map_itr->second);
        }
      }
    }

    //! @brief constructor from a map of functions and from a weight set
    //! @param SCORE_MAP map of scoring functions to be used
    //! @param WEIGHT_SET map of function schemes and corresponding weights
    ProteinModelScoreSum::ProteinModelScoreSum
    (
      const storage::Map< std::string, util::ShPtr< ProteinModel> > &SCORE_MAP,
      const storage::Map< std::string, double> &WEIGHT_SET
    ) :
      math::SumFunctionMixin< ProteinModel>()
    {
      AddScoresWithWeights( SCORE_MAP, WEIGHT_SET);
    }

    //! @brief virtual copy constructor
    ProteinModelScoreSum *ProteinModelScoreSum::Clone() const
    {
      return new ProteinModelScoreSum( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelScoreSum::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns a vector of string that has readable schemes of the individual functions
    //! @return the vector of strings that has readable schemes of the individual functions
    storage::Vector< std::string> ProteinModelScoreSum::GetReadableFunctionSchemes() const
    {
      // get the combined score map
      const storage::Map< ProteinModel::TypeEnum, storage::Map< std::string, double> > score_map( CombineSimilarScores());

      // add some padding to create subheadings
      const std::string padding( "  ");

      // initialize vector to store the function names
      storage::Vector< std::string> function_names;

      // get the structure based scores
      const storage::Map< ProteinModel::TypeEnum, storage::Map< std::string, double> >::const_iterator struct_find
      (
        score_map.Find( ProteinModel::e_Structure)
      );
      if( struct_find != score_map.End())
      {
        function_names.PushBack( ProteinModel::GetTypeName( ProteinModel::e_Structure));
        for
        (
          storage::Map< std::string, double>::const_iterator score_itr( struct_find->second.Begin()),
            score_itr_end( struct_find->second.End());
          score_itr != score_itr_end; ++score_itr
        )
        {
          function_names.PushBack( padding + score_itr->first);
        }
      }

      // get the sequence based scores
      const storage::Map< ProteinModel::TypeEnum, storage::Map< std::string, double> >::const_iterator seq_find
      (
        score_map.Find( ProteinModel::e_Sequence)
      );
      if( struct_find != score_map.End())
      {
        function_names.PushBack( ProteinModel::GetTypeName( ProteinModel::e_Sequence));
        for
        (
          storage::Map< std::string, double>::const_iterator score_itr( seq_find->second.Begin()),
            score_itr_end( seq_find->second.End());
          score_itr != score_itr_end; ++score_itr
        )
        {
          function_names.PushBack( padding + score_itr->first);
        }
      }

      // push sum column
      function_names.PushBack( "Score (total)");

      // end
      return function_names;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &ProteinModelScoreSum::GetAlias() const
    {
      static const std::string s_name( "ProteinModelScoreSum");
      return s_name;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief creates a table with individual function values, weights and weighted values
    //! the table has scores as the columns
    //! @param PROTEIN_MODEL ProteinModel to be used for calculating the function value
    //! @return a table with individual functions and their weighted sums
    storage::Table< double> ProteinModelScoreSum::CreateValueTableHorizontal
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // cast a pointer to the multiplier data
      const util::ShPtr< assemble::ProteinModelMultiplier> sp_multiplier
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Multiplier)
      );

      // set boolean to see if this is multimer
      assemble::ProteinModel multimer_model;
      const bool has_multimers( sp_multiplier.IsDefined());
      if( has_multimers)
      {
        multimer_model = sp_multiplier->operator ()( PROTEIN_MODEL);
      }

      // initialize vectors to store values and allocate memory
      storage::Vector< double> weights_vector, values_vector, weighted_values_vector;
      weights_vector.AllocateMemory( m_Functions.GetSize() + 2);
      values_vector.AllocateMemory( m_Functions.GetSize() + 2);
      weighted_values_vector.AllocateMemory( m_Functions.GetSize() + 2);

      // initialize the sums
      double sum_weights( 0.0), sum_values( 0.0), sum_weighted_values( 0.0);

      // initialize vector to store the function names
      storage::Vector< std::string> function_names;

      // iterate to collect the scores
      for
      (
        const_iterator function_itr( m_Functions.Begin()), function_itr_end( m_Functions.End());
        function_itr != function_itr_end;
        ++function_itr
      )
      {
        // insert the name for this function
        function_names.PushBack( function_itr->Second()->GetScheme());

        // calculate the value for the argument using this function
        const double this_weight( function_itr->First());
        double this_value( 0.0);
        if( has_multimers)
        {
          this_value = ( function_itr->Second()->operator()( multimer_model));
        }
        else
        {
          this_value = ( function_itr->Second()->operator()( PROTEIN_MODEL));
        }
        const double this_weighted_value( this_value * function_itr->First());

        // record the value, weight and the weighted value
        weights_vector.PushBack( this_weight);
        values_vector.PushBack( this_value);
        weighted_values_vector.PushBack( this_weighted_value);

        // update the sums
        sum_weights += this_weight;
        sum_values += this_value;
        sum_weighted_values += this_weighted_value;
      }

      // add the sum column
      function_names.PushBack( "sum");

      // add the summed values
      weights_vector.PushBack( sum_weights);
      values_vector.PushBack( sum_values);
      weighted_values_vector.PushBack( sum_weighted_values);

      // Insert the rows
      util::ShPtr< storage::TableHeader> sp_table_header( new storage::TableHeader( function_names));
      storage::Table< double> function_table( sp_table_header);
      function_table.InsertRow( "weights", weights_vector);
      function_table.InsertRow( "value", values_vector);
      function_table.InsertRow( "weighted_value", weighted_values_vector);

      // end
      return function_table;
    }

    //! @brief creates a table with individual function values and their weighted sums for the given argument
    //! the table has scores as rows
    //! @param PROTEIN_MODEL ProteinModel to be used for calculating the function value
    //! @return a table with individual functions and their weighted sums
    storage::Table< double> ProteinModelScoreSum::CreateValueTableVertical
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // cast a pointer to the multiplier data
      const util::ShPtr< assemble::ProteinModelMultiplier> sp_multiplier
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Multiplier)
      );

      // set boolean to see if this is multimer
      assemble::ProteinModel multimer_model;
      const bool has_multimers( sp_multiplier.IsDefined());
      if( has_multimers)
      {
        multimer_model = sp_multiplier->operator ()( PROTEIN_MODEL);
      }

      // get the value table
      storage::Table< double> table
      (
        has_multimers ?
          math::SumFunctionMixin< ProteinModel>::CreateValueTableVertical( multimer_model) :
          math::SumFunctionMixin< ProteinModel>::CreateValueTableVertical( PROTEIN_MODEL)
      );

      // end
      return table;
    }

    //! @brief creates a table with individual function values and their weighted sums for the given argument
    //! the table has scores as rows, using readable names instead of scheme
    //! @param PROTEIN_MODEL ProteinModel to be used for calculating the function value
    //! @return a table with individual functions and their weighted sums
    storage::Table< double> ProteinModelScoreSum::CreateSortedReadableTable( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // initialize table header and a table
      util::ShPtr< storage::TableHeader> sp_table_header
      (
        new storage::TableHeader( math::SumFunctionMixin< ProteinModel>::GetValueTableVerticalColumnNames())
      );
      storage::Table< double> function_table( sp_table_header);

      // initialize the sum
      double sum( 0.0);

      // get the combined map
      storage::Map< ProteinModel::TypeEnum, storage::Map< std::string, double> > score_map( CombineSimilarScores());

      // iterate to collect the scores
      for
      (
        const_iterator function_itr( m_Functions.Begin()), function_itr_end( m_Functions.End());
        function_itr != function_itr_end;
        ++function_itr
      )
      {
        // get score
        const util::SiPtr< const ProteinModel> si_score( &*function_itr->Second());
        const ProteinModel &score( *si_score);

        const double this_weighted_value( score( PROTEIN_MODEL) * function_itr->First());

        score_map[ score.GetType()][ score.GetReadableScheme()] += this_weighted_value;

        // update the sums
        sum += this_weighted_value;
      }

      // get the structure based scores
      const storage::Map< ProteinModel::TypeEnum, storage::Map< std::string, double> >::const_iterator struct_find
      (
        score_map.Find( ProteinModel::e_Structure)
      );
      if( struct_find != score_map.End())
      {
        function_table.InsertRow
        (
          ProteinModel::GetTypeName( ProteinModel::e_Structure),
          storage::Vector< double>::Create( util::GetUndefined< double>(), util::GetUndefined< double>(), util::GetUndefined< double>())
        );
        for
        (
          storage::Map< std::string, double>::const_iterator score_itr( struct_find->second.Begin()),
            score_itr_end( struct_find->second.End());
          score_itr != score_itr_end; ++score_itr
        )
        {
          function_table.InsertRow
          (
            storage::Table< double>::s_Indentation + score_itr->first,
            storage::Vector< double>::Create( util::GetUndefined< double>(), util::GetUndefined< double>(), score_itr->second)
          );
        }
      }

      // get the sequence based scores
      const storage::Map< ProteinModel::TypeEnum, storage::Map< std::string, double> >::const_iterator seq_find
      (
        score_map.Find( ProteinModel::e_Sequence)
      );
      if( struct_find != score_map.End())
      {
        function_table.InsertRow
        (
          ProteinModel::GetTypeName( ProteinModel::e_Sequence),
          storage::Vector< double>::Create( util::GetUndefined< double>(), util::GetUndefined< double>(), util::GetUndefined< double>())
        );
        for
        (
          storage::Map< std::string, double>::const_iterator score_itr( seq_find->second.Begin()),
            score_itr_end( seq_find->second.End());
          score_itr != score_itr_end; ++score_itr
        )
        {
          function_table.InsertRow
          (
            storage::Table< double>::s_Indentation + score_itr->first,
            storage::Vector< double>::Create( util::GetUndefined< double>(), util::GetUndefined< double>(), score_itr->second)
          );
        }
      }

      // add the sum row
      function_table.InsertRow( "Score (total)", storage::Vector< double>::Create( sum, sum, sum));

      // end
      return function_table;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief initialize the score sum using the given score weight map
    //! @param SCORE_WEIGHT_MAP map of scores and corresponding weights
    void ProteinModelScoreSum::AddScoresWithWeights
    (
      const storage::Map< util::ShPtr< ProteinModel>, double> &SCORE_WEIGHT_MAP
    )
    {
      // iterate over weights map provided
      for
      (
        storage::Map< util::ShPtr< ProteinModel>, double>::const_iterator
          map_itr( SCORE_WEIGHT_MAP.Begin()), map_itr_end( SCORE_WEIGHT_MAP.End());
        map_itr != map_itr_end; ++map_itr
      )
      {
        // if the weight is equal to 0
        if( map_itr->second == double( 0.0))
        {
          // skip this one
          BCL_MessageStd
          (
            "Weight is equal to 0, therefore not adding the following score " + map_itr->first->GetScheme()
          );
        }
        // otherwise
        else
        {
          // add the score
          NewOperand( *map_itr->first, map_itr->second);
        }
      }
    }

    //! @brief initialize the score sum using the given score map and weight map
    //! @param SCORE_MAP map of scoring functions to be used
    //! @param WEIGHT_SET map of function schemes and corresponding weights
    void ProteinModelScoreSum::AddScoresWithWeights
    (
      const storage::Map< std::string, util::ShPtr< ProteinModel> > &SCORE_MAP,
      const storage::Map< std::string, double> &WEIGHT_SET
    )
    {
      // iterate over weights provided
      for
      (
        storage::Map< std::string, double>::const_iterator weight_itr( WEIGHT_SET.Begin()),
          weight_itr_end( WEIGHT_SET.End());
        weight_itr != weight_itr_end;
        ++weight_itr
      )
      {
        // if the weight is equal to 0
        if( weight_itr->second == double( 0.0))
        {
          // skip this one
          BCL_MessageStd
          (
            "Weight is equal to 0, therefore not adding the following score " + weight_itr->first
          );
          continue;
        }

        // look in the score map for this function
        storage::Map< std::string, util::ShPtr< ProteinModel> >::const_iterator
          sp_score_itr( SCORE_MAP.Find( weight_itr->first));

        // make sure it was found
        BCL_Assert( sp_score_itr != SCORE_MAP.End(), "Score was not found in the map " + weight_itr->first);

        // add the score
        NewOperand( *sp_score_itr->second, weight_itr->second);
      }
    }

    //! @brief calculate the score for the given ProteinModel
    //! @brief PROTEIN_MODEL ProteinModel to be evaluated
    //! @return the score for the given model
    double ProteinModelScoreSum::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // cast a pointer to the multiplier data
      const util::ShPtr< assemble::ProteinModelMultiplier> sp_multiplier
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Multiplier)
      );

      // set boolean to see if this is multimer
      const bool has_multimers( sp_multiplier.IsDefined());

      // initialize double sum
      double sum( 0.0);

      // calculate the sum function result
      if( has_multimers)
      {
        sum =
         math::SumFunctionMixin< ProteinModel>::operator()( sp_multiplier->operator ()( PROTEIN_MODEL));
      }
      // otherwise score just the protein model
      else
      {
        sum = math::SumFunctionMixin< ProteinModel>::operator()( PROTEIN_MODEL);
      }

      // return sum f(x) = y
      return sum;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL ProteinModel to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &ProteinModelScoreSum::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {

      // cast a pointer to the multiplier data
      const util::ShPtr< assemble::ProteinModelMultiplier> sp_multiplier
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Multiplier)
      );

      // set boolean to see if this is multimer
      const bool has_multimers( sp_multiplier.IsDefined());
      const size_t nr_multimers( has_multimers ? sp_multiplier->GetNumberMultimers() : 1);

      OSTREAM << "has_multimers " << has_multimers << '\n';
      OSTREAM << "nr_multimers " << nr_multimers << '\n';

      for
      (
        const_iterator pair_itr( m_Functions.Begin()), pair_itr_end( m_Functions.End());
        pair_itr != pair_itr_end;
        ++pair_itr
      )
      {
        OSTREAM << pair_itr->Second()->GetScheme() << '\t'
                << nr_multimers * pair_itr->First() * pair_itr->Second()->operator()( PROTEIN_MODEL) << std::endl;

        pair_itr->Second()->WriteDetailedSchemeAndValues( PROTEIN_MODEL, OSTREAM) << '\n';
      }

      //end
      return OSTREAM;
    }

    //! @brief combines scores with the same readable scheme
    //! @return scores with the same readable scheme
    storage::Map< ProteinModel::TypeEnum, storage::Map< std::string, double> > ProteinModelScoreSum::CombineSimilarScores() const
    {
      // initialize map
      storage::Map< ProteinModel::TypeEnum, storage::Map< std::string, double> > score_map;

      // iterate to collect the scores
      for
      (
        const_iterator function_itr( m_Functions.Begin()), function_itr_end( m_Functions.End());
        function_itr != function_itr_end;
        ++function_itr
      )
      {
        // get score
        const util::SiPtr< const ProteinModel> si_score( &*function_itr->Second());
        const ProteinModel &score( *si_score);

        // insert into map
        score_map[ score.GetType()][ score.GetReadableScheme()] = 0;
      }

      // end
      return score_map;
    }

  } // namespace score
} // namespace bcl

// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_sse_chirality.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "command/bcl_command_command_state.h"
#include "graph/bcl_graph_connectivity.h"
#include "graph/bcl_graph_const_graph.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "io/bcl_io_serializer.h"
#include "storage/bcl_storage_list.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"
#include "util/bcl_util_string_functions.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelSSEChirality::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelSSEChirality())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! default constructor
    //! @param PSEUDOCOUNT pseudocount to use
    ProteinModelSSEChirality::ProteinModelSSEChirality
    (
      const double &PSEUDOCOUNT,
      const bool   &CONTACT_SPECIFIC,
      const bool   &SCALE_BY_AAS
    ) :
      m_Pseudocount( PSEUDOCOUNT),
      m_UseContactSpecificWeights( CONTACT_SPECIFIC),
      m_ScaleByAAs( SCALE_BY_AAS)
    {
      std::stringstream err_str;
      BCL_Assert
      (
        this->ReadInitializerSuccessHook( util::ObjectDataLabel(), err_str),
        "Couldn't read histogram file: " + err_str.str()
      );
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelSSEChirality
    ProteinModelSSEChirality *ProteinModelSSEChirality::Clone() const
    {
      return new ProteinModelSSEChirality( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelSSEChirality::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelSSEChirality::GetScheme() const
    {
      static const std::string
        s_contact_name( "all_sse_chirality"),
        s_contact_sp_name( "all_sse_chirality_contact"),
        s_contact_name_aa( "all_sse_chirality_aa"),
        s_contact_sp_name_aa( "all_sse_chirality_contact_aa");
      return m_ScaleByAAs
             ? (
                 m_UseContactSpecificWeights
                 ? s_contact_sp_name_aa
                 : s_contact_name_aa
               )
             : (
                 m_UseContactSpecificWeights
                 ? s_contact_sp_name
                 : s_contact_name
               );
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &ProteinModelSSEChirality::GetAlias() const
    {
      static const std::string s_combined( "SSEChirality"), s_ann_name( "SSEChiralityEff"), s_con_name( "SSEChiralityConSpec");
      return m_UseContactSpecificWeights ? s_con_name : s_combined;
    }

    //! @brief get the propensities vector
    const linal::Vector< double> &ProteinModelSSEChirality::GetPropensities() const
    {
      return m_Propensities;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelSSEChirality::GetSerializer() const
    {
      io::Serializer serializer;

      serializer.SetClassDescription
      (
        "Scores interaction energy of all SSE pairs and chirality of all triplets"
      );
      serializer.AddInitializer
      (
        "pseudocount",
        "pseudocount to add to each count",
        io::Serialization::GetAgent( &m_Pseudocount),
        "20"
      );
      serializer.AddInitializer
      (
        "contact specific",
        "use hi-res weights that further break down which SSEs are in contact",
        io::Serialization::GetAgent( &m_UseContactSpecificWeights),
        "0"
      );
      serializer.AddInitializer
      (
        "scale by aas",
        "whether to scale by the number of aas in the protein",
        io::Serialization::GetAgent( &m_ScaleByAAs),
        "True"
      );
      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that scores the chain
    //! @param CHAIN the chain for which all neighbor scores are calculated
    //! @param MISSING_SSES sse pool of missing sses
    //! @return score
    double ProteinModelSSEChirality::operator()
    (
      const assemble::Chain &CHAIN,
      const assemble::SSEPool &MISSING_SSES
    ) const
    {
      std::stringstream dummy_stream;
      return ScoreLoops( CHAIN, MISSING_SSES, dummy_stream, false);
    }

    //! @brief operator that scores the Protein model
    //! @param PROTEIN_MODEL the protein model for which all neighbor scores are calculated
    //! @return score
    double ProteinModelSSEChirality::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // score sum
      double score( 0.0);

      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );

      // find all sse's not yet in the model. do not assume a linear loop between sses if another SSE could exist
      // between them, because that would invalidate the linear loop assumption
      util::SiPtrList< const assemble::SSE> non_overlapping
      (
        sp_pool.IsDefined()
        ? sp_pool->GetNonOverlappingSSEs( PROTEIN_MODEL)
        : util::SiPtrList< const assemble::SSE>()
      );

      // create an sse-pool with the missing SSEs
      assemble::SSEPool sse_pool( non_overlapping, true, false);

      // iterate through the chains of PROTEIN_MODEL
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        score += operator()( **chain_itr, sse_pool);
      }

      // return score
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL ProteinModel to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &ProteinModelSSEChirality::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );

      // find all sse's not yet in the model. do not assume a linear loop between sses if another SSE could exist
      // between them, because that would invalidate the linear loop assumption
      assemble::SSEPool non_overlapping
      (
        sp_pool.IsDefined()
        ? sp_pool->GetNonOverlappingSSEs( PROTEIN_MODEL)
        : util::SiPtrList< const assemble::SSE>()
      );

      // iterate through the chains of PROTEIN_MODEL
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        ScoreLoops( **chain_itr, non_overlapping, OSTREAM, true);
      }
      // end
      return OSTREAM;
    }

    //! @brief helper function called by WriteDetailedSchemeAndValues and operator() so that the code remains in-sync
    //! @param CHAIN the chain of interest
    //! @param MISSING_SSES missing sses from the pool
    //! @param OSTREAM the output stream to write the detailed scheme to for this chain
    //! @param DO_WRITE set to true to actually write to the output stream; otherwise, nothing will be written
    //! @return the final score
    double ProteinModelSSEChirality::ScoreLoops
    (
      const assemble::Chain &CHAIN,
      const assemble::SSEPool &MISSING_SSES,
      std::ostream &OSTREAM,
      const bool &DO_WRITE
    ) const
    {
      // sum of all scores
      double score( 0.0);

      // need at least three sses in the chain
      if( CHAIN.GetNumberSSEs() < 2)
      {
        return score;
      }

      // min probability to score two residues as being an almost-certain contact
      const double min_p( 0.04);

      // Create a matrix that will hold the x,y, and z coordinates for terminii of the first & second strands
      linal::Matrix3x3< double> xyz_coordinates( 0.0); // make a matrix of size 3 X 3

      // collect all non-coil sse's
      const util::SiPtrVector< const assemble::SSE> structured_sses
      (
        CHAIN.GetSSEs( storage::Set< biol::SSType>( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND))
      );
      const storage::Set< biol::AtomType> types_of_interest
      (
        biol::GetAtomTypes().GetFirstSidechainAtomTypes()
      );

      util::SiPtrVector< const biol::Atom> si_atoms;
      math::RunningAverage< double> score_ave;
      assemble::VoxelGridAA interactions_detector( m_HashMaker.GetInteractionDistance());
      const size_t min_atoms_helix( m_HashMaker.GetMinAtomsInContactHelix());
      const size_t min_atoms_strand( m_HashMaker.GetMinAtomsInContactStrand());
      linal::Matrix< float> interactions_matrix
      (
        interactions_detector.GetSSEInteractionMatrix
        (
          structured_sses,
          CHAIN.GetAminoAcids(),
          2,
          m_HashMaker.GetInteractionDistance(),
          false,
          min_p,
          false
        )
      );
      // cache of the packing objects computed so far
      storage::Vector< storage::Vector< assemble::SSEGeometryPacking::OrientationEnum> > orientations
      (
        structured_sses.GetSize(),
        storage::Vector< assemble::SSEGeometryPacking::OrientationEnum>
        (
          structured_sses.GetSize(),
          assemble::SSEGeometryPacking::OrientationEnum( assemble::SSEGeometryPacking::s_NumberOrientations)
        )
      );

      storage::Vector< math::RunningAverage< double> > sse_average_chirality_score( structured_sses.GetSize());
      storage::Vector< math::RunningAverage< double> > sse_average_adj_chirality_score( structured_sses.GetSize());

      // handle SSE-pair interaction-weight and parallel/anti-parallel bias
      size_t a( 0), atoms_in_sses( 0);
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          itr_a( structured_sses.Begin()),
          itr_end( structured_sses.End());
        itr_a != itr_end;
        ++itr_a, ++a
      )
      {
        size_t b( a + 1);
        atoms_in_sses += ( *itr_a)->GetSize();
        const size_t min_atoms_a( ( *itr_a)->GetType() == biol::GetSSTypes().STRAND ? min_atoms_strand : min_atoms_helix);
        for
        (
          util::SiPtrVector< const assemble::SSE>::const_iterator itr_b( itr_a + 1);
          itr_b != itr_end;
          ++itr_b, ++b
        )
        {
          // for every pair of SSEs
          const assemble::SSEGeometryPacking::OrientationEnum &packing_ab
          (
            m_HashMaker.GetCacheOrientation( orientations, a, b, **itr_a, **itr_b)
          );
          const size_t min_atoms_b( ( *itr_b)->GetType() == biol::GetSSTypes().STRAND ? min_atoms_strand : min_atoms_helix);

          util::SiPtrVector< const assemble::SSE>::const_iterator itr_c( itr_b + 1);
          if( itr_c == itr_end)
          {
            continue;
          }
          size_t c( b + 1);
          const size_t interactions_ab( interactions_matrix( a, b));
          const size_t min_atoms_c( ( *itr_c)->GetType() == biol::GetSSTypes().STRAND ? min_atoms_strand : min_atoms_helix);

          if
          (
            a + 1 == b
            &&
            ( interactions_ab >= min_atoms_a * min_atoms_b ? 1 : 0)
            + ( interactions_matrix( a, c) >= min_atoms_a * min_atoms_c ? 1 : 0)
            + ( interactions_matrix( b, c) >= min_atoms_b * min_atoms_c ? 1 : 0)
            > 1
          )
          {
            const int end_last_sse_seq_id( ( *itr_a)->GetLastAA()->GetPdbID());
            const int start_next_sse_seq_id( ( *itr_c)->GetFirstAA()->GetPdbID());

            bool found_potential_sse_between( false);
            // check for any overlapping sses in the pool
            for
            (
              auto itr_pool( MISSING_SSES.Begin()), itr_pool_end( MISSING_SSES.End());
              itr_pool != itr_pool_end;
              ++itr_pool
            )
            {
              const assemble::SSE &potential_sse( **itr_pool);
              if
              (
                potential_sse.GetFirstAA()->GetSeqID() > end_last_sse_seq_id
                && potential_sse.GetLastAA()->GetSeqID() < start_next_sse_seq_id
              )
              {
                // overlapping sse. inflate the number of residues between these sses to ensure that we don't check
                // the distance between the pair
                found_potential_sse_between = true;
                break;
              }
            }
            if( !found_potential_sse_between)
            {
              const assemble::SSEGeometryPacking::OrientationEnum &packing_ac
              (
                m_HashMaker.GetCacheOrientation( orientations, a, c, **itr_a, **itr_c)
              );
              const assemble::SSEGeometryPacking::OrientationEnum &packing_bc
              (
                m_HashMaker.GetCacheOrientation( orientations, b, c, **itr_b, **itr_c)
              );
              const linal::Vector3D root_position( ( *itr_b)->GetCenter());

              xyz_coordinates.GetRow( 0).CopyValues( ( *itr_a)->GetMainAxis().GetStartPoint() - root_position);
              xyz_coordinates.GetRow( 1).CopyValues( ( *itr_a)->GetMainAxis().GetEndPoint() - root_position);
              xyz_coordinates.GetRow( 2).CopyValues( ( *itr_c)->GetCenter() - root_position);

              // Calculate the determinant of a 3 X 3 matrix that has rows sorted in descending order of priority.
              // Opposite orders will have opposite signs. The sign is assigned to a value of 1 and returned as the
              // value of the stereocenter.
              const float determinant( xyz_coordinates.Determinant());
              const double triplet_adj_score
              (
                m_Propensities
                (
                  m_HashMaker.GetPackingTripletNumber
                  (
                    ( *itr_a)->GetType(),
                    ( *itr_b)->GetType(),
                    ( *itr_c)->GetType(),
                    packing_ab,
                    packing_bc,
                    packing_ac,
                    interactions_ab,
                    interactions_matrix( b, c),
                    interactions_matrix( a, c),
                    true,
                    determinant >= 0.0
                  )
                )
              );
              sse_average_adj_chirality_score( a).AddWeightedObservation( triplet_adj_score, interactions_ab + interactions_matrix( a, c));
              sse_average_adj_chirality_score( b).AddWeightedObservation( triplet_adj_score, interactions_ab + interactions_matrix( b, c));
              sse_average_adj_chirality_score( c).AddWeightedObservation( triplet_adj_score, interactions_matrix( b, c) + interactions_matrix( a, c));
              if( DO_WRITE)
              {
                OSTREAM << "Triplet combined_energy adjacent: "
                        << ( *itr_a)->GetIdentification()
                        << " " << ( *itr_b)->GetIdentification()
                        << " " << ( *itr_c)->GetIdentification()
                        << " " << packing_ab.GetString()
                        << " " << packing_bc.GetString()
                        << " " << packing_ac.GetString()
                        << " " << bool( determinant >= 0)
                        << " " << interactions_ab
                        << " " << interactions_matrix( b, c)
                        << " " << interactions_matrix( a, c)
                        << " " << triplet_adj_score << std::endl;
              }
              ++itr_c;
              ++c;
            }
          }
          for( ; itr_c != itr_end; ++itr_c, ++c)
          {
            const size_t min_atoms_c( ( *itr_c)->GetType() == biol::GetSSTypes().STRAND ? min_atoms_strand : min_atoms_helix);

            if
            (
              ( interactions_ab >= min_atoms_a * min_atoms_b ? 1 : 0)
              + ( interactions_matrix( a, c) >= min_atoms_a * min_atoms_c ? 1 : 0)
              + ( interactions_matrix( b, c) >= min_atoms_b * min_atoms_c ? 1 : 0)
              <= 1
            )
            {
              continue;
            }
            const assemble::SSEGeometryPacking::OrientationEnum &packing_ac
            (
              m_HashMaker.GetCacheOrientation( orientations, a, c, **itr_a, **itr_c)
            );
            const assemble::SSEGeometryPacking::OrientationEnum &packing_bc
            (
              m_HashMaker.GetCacheOrientation( orientations, b, c, **itr_b, **itr_c)
            );
            const linal::Vector3D root_position( ( *itr_b)->GetCenter());

            xyz_coordinates.GetRow( 0).CopyValues( ( *itr_a)->GetMainAxis().GetStartPoint() - root_position);
            xyz_coordinates.GetRow( 1).CopyValues( ( *itr_a)->GetMainAxis().GetEndPoint() - root_position);
            xyz_coordinates.GetRow( 2).CopyValues( ( *itr_c)->GetCenter() - root_position);

            // Calculate the determinant of a 3 X 3 matrix that has rows sorted in descending order of priority.
            // Opposite orders will have opposite signs. The sign is assigned to a value of 1 and returned as the
            // value of the stereocenter.
            const float determinant( xyz_coordinates.Determinant());
            const double triplet_nonadj_score
            (
              m_Propensities
              (
                m_HashMaker.GetPackingTripletNumber
                (
                  ( *itr_a)->GetType(),
                  ( *itr_b)->GetType(),
                  ( *itr_c)->GetType(),
                  packing_ab,
                  packing_bc,
                  packing_ac,
                  interactions_ab,
                  interactions_matrix( b, c),
                  interactions_matrix( a, c),
                  false,
                  determinant >= 0.0
                )
              )
            );
            sse_average_chirality_score( a).AddWeightedObservation( triplet_nonadj_score, interactions_ab + interactions_matrix( a, c));
            sse_average_chirality_score( b).AddWeightedObservation( triplet_nonadj_score, interactions_ab + interactions_matrix( b, c));
            sse_average_chirality_score( c).AddWeightedObservation( triplet_nonadj_score, interactions_matrix( b, c) + interactions_matrix( a, c));
            if( DO_WRITE)
            {
              OSTREAM << "Triplet combined_energy non-adjacent: "
                      << ( *itr_a)->GetIdentification()
                      << " " << ( *itr_b)->GetIdentification()
                      << " " << ( *itr_c)->GetIdentification()
                      << " " << packing_ab.GetString()
                      << " " << packing_bc.GetString()
                      << " " << packing_ac.GetString()
                      << " " << bool( determinant >= 0)
                      << " " << interactions_ab
                      << " " << interactions_matrix( b, c)
                      << " " << interactions_matrix( a, c)
                      << " " << triplet_nonadj_score << std::endl;
            }
          }
        }
      }

      for( size_t i( 0), n_sses( structured_sses.GetSize()); i < n_sses; ++i)
      {
        const double ave_adj( sse_average_adj_chirality_score( i).GetAverage());
        const double ave_nonadj( sse_average_chirality_score( i).GetAverage());

        // if there are both adjacent and non-adjacent terms that agree in sign,
        // take whichever is larger in magnitude. This avoids that a highly-favorable adjacent chirality term becomes
        // less favorable when paired with other favorable non-adjacent terms
        if
        (
          sse_average_adj_chirality_score( i).GetWeight()
          && sse_average_chirality_score( i).GetWeight()
          && ( ( ave_adj > 0.0) == ( ave_nonadj > 0.0))
        )
        {
          score_ave.AddWeightedObservation
          (
            ( ave_adj < 0.0 ? std::min( ave_adj, ave_nonadj) : std::max( ave_adj, ave_nonadj)),
            structured_sses( i)->GetSize()
          );
        }
        else
        {
          score_ave.AddWeightedObservation
          (
            ave_adj + ave_nonadj,
            structured_sses( i)->GetSize()
          );
        }
      }
      // return the score sum
      return score_ave.GetAverage() * ( m_ScaleByAAs ? atoms_in_sses : 1.0);
    }

    //! @brief Set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @return ERROR_STREAM stream with which to write errors
    bool ProteinModelSSEChirality::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
    {
      if( !command::CommandState::GetGlobalCommandState().IsInStaticInitialization())
      {
        io::IFStream input;
        io::File::MustOpenIFStream
        (
          input,
          Score::AddHistogramPath
          (
            m_UseContactSpecificWeights
            ? "sse_triplet_chirality_contact.histogram"
            : "sse_triplet_chirality.histogram"
          )
        );
        util::ChopHeader( input);
        bool read_success( m_HashMaker.TryRead( util::ObjectDataLabel( input), ERROR_STREAM));
        if( !read_success)
        {
          return false;
        }
        util::ChopHeader( input);
        m_Propensities = linal::Vector< double>( m_HashMaker.GetNumberHashes(), 0.0);
        storage::Map< std::string, size_t> hash_to_index;
        for( size_t i( 0); i < m_HashMaker.GetNumberHashes(); ++i)
        {
          hash_to_index[ m_HashMaker.GetPackingTripletString( size_t( i))] = i;
        }
        storage::Vector< storage::Vector< std::string> > tokens
        (
          util::SplittedStringLineListFromIStream( input, " \n\t")
        );
        if( !tokens.IsEmpty() && tokens.LastElement().IsEmpty())
        {
          // remove empty lines at the end
          tokens.PopBack();
        }
        if( tokens.GetSize() != m_HashMaker.GetNumberHashes())
        {
          ERROR_STREAM << "Wrong number of hashes in file, should be: "
                       << m_HashMaker.GetNumberHashes() << " but found " << tokens.GetSize() << '\n';
          return false;
        }
        for( auto itr_line( tokens.Begin()), itr_line_end( tokens.End()); itr_line != itr_line_end; ++itr_line)
        {
          const storage::Vector< std::string> &line( *itr_line);
          if( line.GetSize() != 4 && line.GetSize() != 2)
          {
            ERROR_STREAM << "Every line should have two fields (ID and propensity) or four fields (ID, weighted SSEs, raw SSEs, expected SSEs)"
                         << " but one field had: "
                         << line.GetSize()
                         << " : " << util::Join( " ", line) << '\n';
            return false;
          }
          auto itr_hash_to_index( hash_to_index.Find( line( 0)));
          if( itr_hash_to_index == hash_to_index.End())
          {
            ERROR_STREAM << "Hash: " << line( 0) << " is not recognized.\n";
            return false;
          }
          const size_t hash_index( itr_hash_to_index->second);
          if( line.GetSize() == size_t( 2))
          {
            const double counts( util::ConvertStringToNumericalValue< double>( line( 1)));
            m_Propensities( hash_index) = counts;
          }
          else
          {
            const double counts( util::ConvertStringToNumericalValue< double>( line( 2))),
                         expected_counts( util::ConvertStringToNumericalValue< double>( line( 3)));
            m_Propensities( hash_index) = -std::log( ( counts + m_Pseudocount) / ( expected_counts + m_Pseudocount));
          }
        }
        io::File::CloseClearFStream( input);
      }
      return true;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_sse_completeness.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "biol/bcl_biol_atom.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelSSECompleteness::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelSSECompleteness( false))
    );

    const util::SiPtr< const util::ObjectInterface> ProteinModelSSECompleteness::s_AAInstance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelSSECompleteness( true))
    );
  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief returns a pointer to a new ProteinModelSSECompleteness
    //! @return pointer to a new ProteinModelSSECompleteness
    ProteinModelSSECompleteness *ProteinModelSSECompleteness::Clone() const
    {
      return new ProteinModelSSECompleteness( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &ProteinModelSSECompleteness::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the scheme of this score
    //! @return the scheme of this score
    const std::string &ProteinModelSSECompleteness::GetScheme() const
    {
      static const std::string s_default_scheme( "sse_completeness"), s_aa_scheme( "sse_completeness_aas");
      return m_CountAAs ? s_aa_scheme : s_default_scheme;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProteinModelSSECompleteness::GetAlias() const
    {
      return GetScheme();
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelSSECompleteness::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      (
        m_CountAAs
        ? "# of aas in sses that could still be added"
        : "# of sses that could still be added"
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief scores the completeness of the given protein model
    //! @detail the completeness is calculated by computing the ratio of residues with defined coordinates and the
    //! total number of residues in the sequence.
    //! @param PROTEIN_MODEL protein model for which to compute the completeness
    //! @return completeness of the given protein model with -1.0 being complete and 0.0 being empty
    double ProteinModelSSECompleteness::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      if( !sp_pool.IsDefined())
      {
        return 0.0;
      }

      // find all sse's not yet in the model
      util::SiPtrList< const assemble::SSE> non_overlapping
      (
        sp_pool->GetNonOverlappingSSEs( PROTEIN_MODEL)
      );

      size_t total_sse_sizes( 0);
      if( m_CountAAs)
      {
        for( auto itr( non_overlapping.Begin()), itr_end( non_overlapping.End()); itr != itr_end; ++itr)
        {
          total_sse_sizes += ( *itr)->GetSize();
        }
      }
      // Return # of missing aas
      return m_CountAAs ? total_sse_sizes : non_overlapping.GetSize();
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_sse.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_membrane.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelSSE::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelSSE())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelSSE::ProteinModelSSE() :
      m_ScoreSingle(),
      m_Normalize( false)
    {
    }

    //! @brief construct from a function
    //! @param SP_SINGLE_FUNCTION single function to be used
    //! @param NORMALIZE
    //! @param SCORE_TYPE score type
    //! @param READABLE_SCHEME scheme that is more human readable
    ProteinModelSSE::ProteinModelSSE
    (
      const util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > > &SP_SINGLE_FUNCTION,
      const bool NORMALIZE,
      const ProteinModel::Type &SCORE_TYPE,
      const std::string &READABLE_SCHEME
    ) :
      m_ScoreSingle( *SP_SINGLE_FUNCTION),
      m_Normalize( NORMALIZE),
      m_ScoreType( SCORE_TYPE),
      m_ReadableScheme( READABLE_SCHEME)
    {
      if( m_ReadableScheme.empty())
      {
        m_ReadableScheme = GetScheme();
      }
    }

    //! @brief virtual copy constructor
    ProteinModelSSE *ProteinModelSSE::Clone() const
    {
      return new ProteinModelSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelSSE::GetScheme() const
    {
      return m_ScoreSingle->GetScheme();
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &ProteinModelSSE::GetAlias() const
    {
      static const std::string s_alias( "ProteinModelSSE");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelSSE::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Wrapping class for scoring functions evaluating individual SSEs.");
      serializer.AddInitializer
      (
        "score function",
        "score function to evaluate the individual SSEs",
        io::Serialization::GetAgent( &m_ScoreSingle)
      );
      serializer.AddInitializer
      (
        "normalize",
        "normalize by the number of evaluated SSEs",
        io::Serialization::GetAgent( &m_Normalize)
      );
      // serializer.AddInitializer
      // (
      //   "type",
      //   "type of the score function",
      //   io::Serialization::GetAgent( &m_ScoreType)
      // );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an PROTEIN_MODEL and returning a t_ResultType object
    //! @param PROTEIN_MODEL Protein Model to be used to evaluate the function
    //! @return function value of the given argument
    double ProteinModelSSE::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      BCL_MessageDbg( "score singles");
      //instantiate the scoresum
      double score( 0.0);

      size_t scored_entities( 0);

      //instantiate a util::SiPtrVector to the elements in the ProteinModel
      const util::SiPtrVector< const assemble::SSE> all_elements( PROTEIN_MODEL.GetSSEs());

      // get any associated membrane
      const util::ShPtr< biol::Membrane> sp_membrane
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane)
      );

      //iterate over all elements
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          element_itr( all_elements.Begin()),
          element_itr_end( all_elements.End());
        element_itr != element_itr_end; ++element_itr)
      {
        //call the pairscore
        const storage::Pair< double, size_t> current_score
        (
          m_ScoreSingle->operator()
          (
            **element_itr,
            sp_membrane.IsDefined() ? *sp_membrane : biol::Membrane::GetUndefinedMembrane()
          )
        );
        score += current_score.First();
        scored_entities += current_score.Second();
      }

      // if normalize flag is given and at least 1 entity was scored
      if( m_Normalize && scored_entities != 0)
      {
        score /= double( scored_entities);
      }

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL ProteinModel to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &ProteinModelSSE::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      //instantiate a util::SiPtrVector to the elements in the ProteinModel
      const util::SiPtrVector< const assemble::SSE> all_elements( PROTEIN_MODEL.GetSSEs());

      // get any associated membrane
      const util::ShPtr< biol::Membrane> sp_membrane
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane)
      );

      //iterate over all possible pairs of elements
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          element_itr( all_elements.Begin()), element_itr_end( all_elements.End());
        element_itr != element_itr_end;
        ++element_itr
      )
      {
        //write the detailed scheme and value for the pair score
        m_ScoreSingle->WriteDetailedSchemeAndValues
        (
          **element_itr,
          sp_membrane.IsDefined() ? *sp_membrane : biol::Membrane::GetUndefinedMembrane(),
          OSTREAM
        );
      }

      //end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_sse_linear_loop_proximity.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "io/bcl_io_serialization.h"
#include "io/bcl_io_serializer.h"
#include "storage/bcl_storage_list.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelSSELinearLoopProximity::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelSSELinearLoopProximity())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct parameters
    //! @param NORMALIZE if true, final score will be normalized by the number of sses/sequences in the protein model
    //! @param CONSIDER_DISTANCE_ALONG_SSE onsider the distance along the sse if true; usually useful, see comment
    //!        for m_ConsiderDistanceAlongSSE
    //! @param FOOTPOINT_OFFSET sets m_FootPointOffset
    //! @param MAXIMUM_LINEAR_LOOP_RESIDUES maximum number of residues between adjacent sses for virtual loops; useful
    //!                                     so that incomplete models are not penalized in cases where the linear loop
    //!                                     approximation breaks down
    ProteinModelSSELinearLoopProximity::ProteinModelSSELinearLoopProximity
    (
      const bool NORMALIZE,
      const bool CONSIDER_DISTANCE_ALONG_SSE,
      const double &FOOTPOINT_OFFSET,
      const bool &CONSIDER_VIRTUAL_LOOP_CLASHES,
      const size_t &MAXIMUM_LINEAR_LOOP_RESIDUES
    ) :
      m_Normalize( NORMALIZE),
      m_ConsiderDistanceAlongSSE( CONSIDER_DISTANCE_ALONG_SSE),
      m_FootPointOffset( FOOTPOINT_OFFSET),
      m_ConsiderVirtualLoopClashes( CONSIDER_VIRTUAL_LOOP_CLASHES),
      m_MaximumSequenceSeparation( MAXIMUM_LINEAR_LOOP_RESIDUES)
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelSSELinearLoopProximity
    ProteinModelSSELinearLoopProximity *ProteinModelSSELinearLoopProximity::Clone() const
    {
      return new ProteinModelSSELinearLoopProximity( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelSSELinearLoopProximity::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelSSELinearLoopProximity::GetScheme() const
    {
      static const std::string s_name( "sse_linear_loop_proximity"), s_aa_name( "sse_linear_loop_proximity_aa");
      return m_Normalize ? s_aa_name : s_name;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &ProteinModelSSELinearLoopProximity::GetAlias() const
    {
      static const std::string s_name( "SSELinearLoopProximity");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelSSELinearLoopProximity::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      ( "score for proximity of imaginary linear loops between all neighborings sses to other sses in the model");
      serializer.AddInitializer
      (
        "normalize",
        "Normalizes the final score to # of aas in each associated sse pair",
        io::Serialization::GetAgent( &m_Normalize),
        "false"
      );
      serializer.AddInitializer
      (
        "consider distance alongSSE",
        "Weights each close contact by (x+y+2*footpoint_offset)/(1+2*footpoint_offset), "
        "where x = closest point on sse norm distance from end (0-0.5), "
        "y = closest point on loop norm distance from end (0-0.5)",
        io::Serialization::GetAgent( &m_ConsiderDistanceAlongSSE),
        "true"
      );
      serializer.AddInitializer
      (
        "foot point offset",
        "See equation for m_ConsiderDistanceAlongSSE",
        io::Serialization::GetAgent( &m_FootPointOffset),
        "0.125"
      );
      serializer.AddInitializer
      (
        "consider virtual loop clashes",
        "whether to consider virtual loop clashes",
        io::Serialization::GetAgent( &m_ConsiderVirtualLoopClashes),
        "true"
      );
      serializer.AddInitializer
      (
        "maximum sequence separation",
        "Maximum sequence distance between sses to consider; useful during folding and with incomplete models, "
        "where linear loop approximation breaks down, potentially in such a way that it prevents non-consecutive insertion of"
        " SSEs.  Set to undefined or similarly high number to consider all loops",
        io::Serialization::GetAgent( &m_MaximumSequenceSeparation),
        "40"
      );
      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that scores the chain
    //! @param CHAIN the chain for which all neighbor scores are calculated
    //! @param MISSING_SSES sse pool of missing sses
    //! @return score
    double ProteinModelSSELinearLoopProximity::operator()
    (
      const assemble::Chain &CHAIN,
      const assemble::SSEPool &MISSING_SSES
    ) const
    {
      std::stringstream dummy_stream;
      return ScoreLoops( CHAIN, MISSING_SSES, dummy_stream, false);
    }

    //! @brief operator that scores the Protein model
    //! @param PROTEIN_MODEL the protein model for which all neighbor scores are calculated
    //! @return score
    double ProteinModelSSELinearLoopProximity::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // score sum
      double score( 0.0);

      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );

      // find all sse's not yet in the model. do not assume a linear loop between sses if another SSE could exist
      // between them, because that would invalidate the linear loop assumption
      util::SiPtrList< const assemble::SSE> non_overlapping
      (
        sp_pool.IsDefined()
        ? sp_pool->GetNonOverlappingSSEs( PROTEIN_MODEL)
        : util::SiPtrList< const assemble::SSE>()
      );

      // create an sse-pool with the missing SSEs
      assemble::SSEPool sse_pool( non_overlapping, true, false);

      // iterate through the chains of PROTEIN_MODEL
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        score += operator()( **chain_itr, sse_pool);
      }

      // return score
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelSSELinearLoopProximity::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Normalize, ISTREAM);
      io::Serialize::Read( m_ConsiderDistanceAlongSSE, ISTREAM);
      io::Serialize::Read( m_FootPointOffset, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelSSELinearLoopProximity::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Normalize, OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_ConsiderDistanceAlongSSE, OSTREAM, 0) << '\t';
      io::Serialize::Write( m_FootPointOffset, OSTREAM, 0);

      // return the stream
      return OSTREAM;
    }

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL ProteinModel to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &ProteinModelSSELinearLoopProximity::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );

      // find all sse's not yet in the model. do not assume a linear loop between sses if another SSE could exist
      // between them, because that would invalidate the linear loop assumption
      util::SiPtrList< const assemble::SSE> non_overlapping
      (
        sp_pool.IsDefined()
        ? sp_pool->GetNonOverlappingSSEs( PROTEIN_MODEL)
        : util::SiPtrList< const assemble::SSE>()
      );

      // iterate through the chains of PROTEIN_MODEL
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        ScoreLoops( **chain_itr, non_overlapping, OSTREAM, true);
      }
      // end
      return OSTREAM;
    }

    //! @brief helper function called by WriteDetailedSchemeAndValues and operator() so that the code remains in-sync
    //! @param CHAIN the chain of interest
    //! @param MISSING_SSES missing sses from the pool
    //! @param OSTREAM the output stream to write the detailed scheme to for this chain
    //! @param DO_WRITE set to true to actually write to the output stream; otherwise, nothing will be written
    //! @return the final score
    double ProteinModelSSELinearLoopProximity::ScoreLoops
    (
      const assemble::Chain &CHAIN,
      const assemble::SSEPool &MISSING_SSES,
      std::ostream &OSTREAM,
      const bool &DO_WRITE
    ) const
    {
      // sum of all scores
      double score( 0.0);

      // need at least three sses in the chain
      if( CHAIN.GetNumberSSEs() < 3)
      {
        return score;
      }

      // collect all non-coil sse's
      const util::SiPtrVector< const assemble::SSE> structured_sses
      (
        CHAIN.GetSSEs( storage::Set< biol::SSType>( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND))
      );

      // need at least three sses in the chain
      if( structured_sses.GetSize() < 3)
      {
        return score;
      }

      // determine the number of residues between each structured sse
      storage::List< size_t> residues_between_sses;
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          itr( structured_sses.Begin()), itr_next( structured_sses.Begin() + 1), itr_end( structured_sses.End());
        itr_next != itr_end;
        ++itr, ++itr_next
      )
      {
        const int end_last_sse_seq_id( ( *itr)->GetLastAA()->GetPdbID());
        const int start_next_sse_seq_id( ( *itr_next)->GetFirstAA()->GetPdbID());
        if( size_t( start_next_sse_seq_id - end_last_sse_seq_id) >= m_MaximumSequenceSeparation)
        {
          residues_between_sses.PushBack( start_next_sse_seq_id - end_last_sse_seq_id);
        }
        else
        {
          bool found_potential_sse_between( false);
          // check for any overlapping sses in the pool
          for
          (
            auto itr_pool( MISSING_SSES.Begin()), itr_pool_end( MISSING_SSES.End());
            itr_pool != itr_pool_end;
            ++itr_pool
          )
          {
            const assemble::SSE &potential_sse( **itr_pool);
            if
            (
              potential_sse.GetFirstAA()->GetSeqID() > end_last_sse_seq_id
              && potential_sse.GetLastAA()->GetSeqID() < start_next_sse_seq_id
            )
            {
              // overlapping sse. inflate the number of residues between these sses to ensure that we don't check
              // the distance between the pair
              found_potential_sse_between = true;
              break;
            }
          }
          residues_between_sses.PushBack
          (
            found_potential_sse_between
            ? m_MaximumSequenceSeparation + 1
            : start_next_sse_seq_id - end_last_sse_seq_id
          );
        }
      }

      // map from sse pointer to pair containing: center of the sse, and vector of lines making up the sse geometry
      // This is considerably faster than always converting the individual fragments to lines every time through the
      // inner loop of this algorithm
      storage::Map
      <
        util::SiPtr< const assemble::SSEGeometryInterface>,
        storage::Pair< linal::Vector3D, storage::Vector< coord::LineSegment3D> >
      > sses_to_center_and_segments;

      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          sse_itr( structured_sses.Begin()), sse_itr_end( structured_sses.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // insert this sse into the map
        storage::Pair< linal::Vector3D, storage::Vector< coord::LineSegment3D> > &
          this_sse_center_and_segments( sses_to_center_and_segments[ **sse_itr]);

        // set the center
        this_sse_center_and_segments.First() = ( *sse_itr)->GetCenter();

        // insert all the line segments
        storage::Vector< coord::LineSegment3D> &segments( this_sse_center_and_segments.Second());
        util::SiPtrVector< const assemble::SSEGeometryInterface> geometries( ( *sse_itr)->GetSSEGeometries());
        segments.AllocateMemory( geometries.GetSize());
        for
        (
          util::SiPtrVector< const assemble::SSEGeometryInterface>::const_iterator
            itr_geo( geometries.Begin()), itr_geo_end( geometries.End());
          itr_geo != itr_geo_end;
          ++itr_geo
        )
        {
          // get the line segment for this fragment
          segments.PushBack( ( *itr_geo)->GetMainAxis());
        }
      }

      // create virtual linear loops between all adjacent SSE elements
      storage::List< assemble::SSEGeometry> linear_loops;

      // iterate through vector of loop sizes
      storage::List< size_t>::const_iterator itr_loop_size( residues_between_sses.Begin());

      // iterate through consecutive sses of "CHAIN" to create all necessary line segments
      // DO NOT call GetCenter() on any SSEGeometryInterface in sses_to_center_and_segments, since the center is not
      // defined for all of them (e.g. coils)
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          sse_itr_a( structured_sses.Begin()),
          sse_itr_b( ++structured_sses.Begin()),
          sse_itr_end( structured_sses.End());
        sse_itr_b != sse_itr_end;
        ++sse_itr_a, ++sse_itr_b, ++itr_loop_size
      )
      {
        // cast the pointers down to geometry interfaces for easier comparison later on
        util::SiPtr< const assemble::SSEGeometryInterface> sse_a_ptr( **sse_itr_a), sse_b_ptr( **sse_itr_b);

        // test for excessive residues between the two ends of the loop; if so, it is likely that the linear loop
        // approximation will be invalid
        if( *itr_loop_size > m_MaximumSequenceSeparation)
        {
          continue;
        }

        // get the line from the end of the last structured element to the beginning of this one
        const coord::LineSegment3D coil( ( *sse_itr_a)->EndOfZ(), ( *sse_itr_b)->BeginOfZ());

        // walk over the map
        for
        (
          storage::Map
          <
            util::SiPtr< const assemble::SSEGeometryInterface>,
            storage::Pair< linal::Vector3D, storage::Vector< coord::LineSegment3D> >
          >::const_iterator
            itr_map( sses_to_center_and_segments.Begin()),
            itr_map_end( sses_to_center_and_segments.End());
          itr_map != itr_map_end;
          ++itr_map
        )
        {
          const assemble::SSEGeometryInterface &sse_geometry( *itr_map->first);
          // skip sse's that are immediately adjacent to this sse (e.g. the sses bordering this coil)
          if( sse_a_ptr == itr_map->first || sse_b_ptr == itr_map->first)
          {
            continue;
          }

          // for each segment of the SSE
          const linal::Vector3D &sse_center( itr_map->second.First());
          const storage::Vector< coord::LineSegment3D> &sse_segments( itr_map->second.Second());

          // find the highest (most-clashing) score for any segment of this sse
          // One could add up all the scores for all the segments of the sse, but then the score would increase (gets worse)
          // whenever the SSEs are bent, so it is therefore desireable to only take the highest-scoring
          double highest_score( 0), best_interaction_weight( 0);
          double highest_score_distance( std::numeric_limits< double>::infinity());
          const double &radial_extent( sse_geometry.GetType()->GetRadialExtent());
          const double sse_length( sse_geometry.GetLength());

          for
          (
            storage::Vector< coord::LineSegment3D>::const_iterator
              itr_segment( sse_segments.Begin()), itr_segment_end( sse_segments.End());
            itr_segment != itr_segment_end;
            ++itr_segment
          )
          {
            const coord::LineSegment3D &sse_segment( *itr_segment);

            // test for closest distance and whether it was orthogonal
            storage::Pair< coord::LineSegment3D, bool>
              line_orthog( coord::ShortestConnectionBetweenLineSegments3D( coil, sse_segment));

            // if the foot-point of the connection is at the end of either line, skip it, because this indicates that the
            // sse is spatially staggered from the linear coil (as opposed to being in its way or nearly in its way)
            if( !line_orthog.Second())
            {
              continue;
            }

            // compute the distance weight
            // if the loop is < 1/2 the radial extent of the SSE, leave it at 1,
            // otherwise decrease linearly to 0
            // TODO: make this continuously diff; maybe cosine
            const double distance( line_orthog.First().GetLength());
            double distance_weight( 0.0);
            if( distance < 0.5 * radial_extent)
            {
              distance_weight = 1.0;
            }
            else if( distance < radial_extent)
            {
              distance_weight = 1.0 - 2.0 * distance / radial_extent;
            }
            else
            {
              continue;
            }

            double interaction_weight( 1);
            if( m_ConsiderDistanceAlongSSE)
            {
              // compute the interaction weight based on how far along the near-intersection point is along the sse and
              // the loop
              const coord::LineSegment3D &shortest_line_loop_to_sse( line_orthog.First());
              const linal::Vector3D &footpoint_loop( shortest_line_loop_to_sse.GetStartPoint());
              const linal::Vector3D &footpoint_sse( shortest_line_loop_to_sse.GetEndPoint());

              // get the distance along the loop
              const double norm_dist_along_loop
              (
                linal::Distance( footpoint_loop, coil.GetStartPoint()) / coil.GetLength()
              );
              // normalized distances to loop end (0 - 0.5)
              const double norm_dist_to_loop_end( std::min( norm_dist_along_loop, 1.0 - norm_dist_along_loop));

              // get the distance from the center of the sse to the closest connection point
              const double distance_along_sse
              (
                0.5 - std::min( linal::Distance( footpoint_sse, sse_center) / sse_length, 0.5)
              );

              // compute the weighting
              // average the normalized distances; this is because it is bad for either sse to be intersecting anywhere
              // other than at the ends (which are much more commonly near-intersected at in native models)
              interaction_weight = ( distance_along_sse + norm_dist_to_loop_end + 2.0 * m_FootPointOffset)
                                   /
                                   ( 1.0 + 2.0 * m_FootPointOffset);
            }

            const double local_score( interaction_weight * distance_weight);

            // track the min distance for this sse segment
            if( local_score > highest_score)
            {
              highest_score_distance = distance;
              highest_score = local_score;
              best_interaction_weight = interaction_weight;
            }
          }

          if( highest_score)
          {
            double sse_length_av( double( ( *sse_itr_a)->GetSize() + ( *sse_itr_b)->GetSize()) / 20.0);
            score += ( m_Normalize ? sse_length_av : 1.0) * highest_score;
            if( DO_WRITE)
            {
              OSTREAM << "Loop between " << ( *sse_itr_a)->GetIdentification()
                << " - "
                << ( *sse_itr_b)->GetIdentification()
                << " closest approach from "
                << sse_geometry.GetIdentification()
                << " was: " << highest_score_distance
                << " Angstrom; score contribution was: " << highest_score << " unweighted; weighted: " << sse_length_av * highest_score
                << " interaction weight was: " << best_interaction_weight
                << '\n';
            }
          }
        }

        if( m_ConsiderVirtualLoopClashes)
        {
          // add this linear coil to the map
          // Give it type helix so that it has a defined radial extent.  Coils have larger extents than either helices or
          // strands typically, but helix is the better approximation
          linear_loops.PushBack
          (
            assemble::SSEGeometry
            (
              biol::GetSSTypes().HELIX,
              "COIL " + ( *sse_itr_a)->GetLastAA()->GetIdentification()
              + " - " + ( *sse_itr_b)->GetFirstAA()->GetIdentification(),
              coil.GetLength()
            )
          );

          // insert this sse into the map
          storage::Pair< linal::Vector3D, storage::Vector< coord::LineSegment3D> > &
            this_sse_center_and_segments( sses_to_center_and_segments[ linear_loops.LastElement()]);

          // set the center
          this_sse_center_and_segments.First() = 0.5 * ( coil.GetStartPoint() + coil.GetEndPoint());

          // insert all the single line segment
          storage::Vector< coord::LineSegment3D> &segments( this_sse_center_and_segments.Second());
          segments.PushBack( coil);

          // insert the loops size
          residues_between_sses.PushBack( *itr_loop_size);
        }
      }

      // normalize
      if( DO_WRITE)
      {
        OSTREAM << "Final " << GetScheme() << " score: " << score << '\n';
      }

      // return the score sum
      return score;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_sse_neighbors.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelSSENeighbors::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelSSENeighbors())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelSSENeighbors::ProteinModelSSENeighbors()
    {
    }

    //! @brief construct from Pair function
    //! @param SP_PAIR_FUNCTION binary function to score a pair of sses
    //! @param NORMALIZE if true, final score will be normalized by the number of sse pairs in the protein model
    ProteinModelSSENeighbors::ProteinModelSSENeighbors
    (
      const util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> > &SP_PAIR_FUNCTION,
      const bool NORMALIZE
    ) :
      m_ScorePair( SP_PAIR_FUNCTION),
      m_Normalize( NORMALIZE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelSSENeighbors
    ProteinModelSSENeighbors *ProteinModelSSENeighbors::Clone() const
    {
      return new ProteinModelSSENeighbors( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelSSENeighbors::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelSSENeighbors::GetScheme() const
    {
      return m_ScorePair->GetScheme();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that scores the chain
    //! @param CHAIN the chain for which all neighbor scores are calculated
    //! @return score
    double ProteinModelSSENeighbors::operator()( const assemble::Chain &CHAIN) const
    {
      // sum of all scores
      double score( 0.0);

      // need at least two sses in the chain
      if( CHAIN.GetNumberSSEs() < 2)
      {
        return score;
      }

      size_t count( 0);

      // iterate through the sses of "CHAIN" to calculate their score sum
      for
      (
        storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr_a( CHAIN.GetData().Begin()),
          sse_itr_b( ++CHAIN.GetData().Begin()),
          sse_itr_end( CHAIN.GetData().End());
        sse_itr_b != sse_itr_end;
        ++sse_itr_a, ++sse_itr_b, ++count
      )
      {
        score += m_ScorePair->operator ()( **sse_itr_a, **sse_itr_b);
      }

      // normalize
      if( m_Normalize)
      {
        score /= double( count);
      }

      // return the score sum
      return score;
    }

    //! @brief operator that scores the Protein model
    //! @param PROTEIN_MODEL the protein model for which all neighbor scores are calculated
    //! @return score
    double ProteinModelSSENeighbors::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // score sum
      double score( 0.0);

      // iterate through the chains of PROTEIN_MODEL
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        score += operator()( **chain_itr);
      }

      // return score
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelSSENeighbors::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ScorePair, ISTREAM);
      io::Serialize::Read( m_Normalize, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelSSENeighbors::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ScorePair, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Normalize, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL ProteinModel to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &ProteinModelSSENeighbors::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      // iterate through the chains of PROTEIN_MODEL
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        if( ( *chain_itr)->GetData().IsEmpty())
        {
          continue;
        }
        // iterate through the sses of "CHAIN" to calculate their score sum
        for
        (
          storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
            sse_itr_a( ( *chain_itr)->GetData().Begin()),
            sse_itr_b( ++( *chain_itr)->GetData().Begin()),
            sse_itr_end( ( *chain_itr)->GetData().End());
          sse_itr_b != sse_itr_end;
          ++sse_itr_a, ++sse_itr_b
        )
        {
          m_ScorePair->WriteDetailedSchemeAndValues( **sse_itr_a, **sse_itr_b, OSTREAM);
        }
      }

      // end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_sse_packing.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "assemble/bcl_assemble_voxel_grid_atom.h"
#include "command/bcl_command_command_state.h"
#include "graph/bcl_graph_connectivity.h"
#include "graph/bcl_graph_const_graph.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "io/bcl_io_serializer.h"
#include "linal/bcl_linal_vector_reference.h"
#include "signal/bcl_signal_signal.h"
#include "storage/bcl_storage_list.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"
#include "util/bcl_util_string_functions.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelSSEPacking::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelSSEPacking())
    );

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //!
    //! @class CacheHelper
    //! @brief manages the cache to link protein models to their scores
    //!
    //! @remark example unnecessary
    //! @author mendenjl
    //! @date Mar 29, 2017
    //!
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class CacheHelper :
      public signal::Slots
    {
    private:
      //! @brief the cache that stores for each Argument the result
      //! the key is the pointer (address) of the argument, the data is a pointer to a result, NULL if the result does
      //! not exist (because the argument has changed)
      typedef std::map< assemble::ProteinModel *, const linal::Vector< double> *> CacheType;
      mutable CacheType m_Cache;

      //! Instance of the main class
      ProteinModelSSEPacking m_Packer;

    public:

      //! Default constructor
      CacheHelper() :
        m_Packer( ProteinModelSSEPacking::s_NumberTypes)
      {
      }

      //! Destructor
      ~CacheHelper()
      {
        // iterate over cache and delete all result pointer
        for( typename CacheType::iterator itr( m_Cache.begin()), itr_end( m_Cache.end()); itr != itr_end; ++itr)
        {
          // delete only if there is an actual object
          if( itr->second != NULL)
          {
            delete itr->second;
          }
        }
      }

      //! @brief return the only instance of this class
      static CacheHelper &GetInstance()
      {
        static CacheHelper s_instance;
        return s_instance;
      }

      //! @brief operator taking an ARGUMENT and returning a t_ResultType object
      //! If there is a result stored in the cache, return that
      //! @param ARGUMENT Argument to be used to evaluate the function
      //! @return function value of the given argument
      linal::Vector< double> operator()
      (
        const assemble::ProteinModel &MODEL,
        const assemble::SSEPool &MISSING_SSES,
        std::ostream &OSTREAM,
        const bool &DO_WRITE
      ) const
      {
        // search in cache
        typename CacheType::iterator itr( m_Cache.find( typename CacheType::key_type( &MODEL)));

        // no result found
        if( itr == m_Cache.end())
        {
          // try to insert
          const std::pair< typename CacheType::iterator, bool> insert_pair
          (
            m_Cache.insert
            (
              typename CacheType::value_type
              (
                typename CacheType::key_type( &MODEL),
                typename CacheType::mapped_type( m_Packer.Score( MODEL, MISSING_SSES, OSTREAM, DO_WRITE).Clone())
              )
            )
          );

          // check that insert was successful
          BCL_Assert( insert_pair.second, "could not insert the result!");

          // connect this to all signal handlers on ARGUMENT
          CacheHelper *non_const_this_ptr( const_cast< CacheHelper *>( this));

          // register this to the destructor signal with RemoveResultFromCache function
          MODEL.GetDestructorSignal().Connect( non_const_this_ptr, &CacheHelper::RemoveResultFromCache);
          // register this to the update signal with InvalidateResult function
          MODEL.GetChangeSignal().Connect( non_const_this_ptr, &CacheHelper::InvalidateResult);

          // return the result
          return *insert_pair.first->second;
        }
        else if( itr->second == NULL)
        {
          // result invalidated. Update it
          itr->second = m_Packer.Score( MODEL, MISSING_SSES, OSTREAM, DO_WRITE).Clone();
        }
        else if( DO_WRITE)
        {
          m_Packer.Score( MODEL, MISSING_SSES, OSTREAM, DO_WRITE);
        }
        // return the result
        return *itr->second;
      }

    //////////////////////
    // helper functions //
    //////////////////////

    private:

      //! @brief remove results for this object from the cache
      //! @param ARGUMENT argument that should be removed
      void RemoveResultFromCache( const assemble::ProteinModel &MODEL)
      {
        // find result for that Argument
        typename CacheType::iterator itr( m_Cache.find( typename CacheType::key_type( &MODEL)));

        // skip if there is no result cached
        if( itr == m_Cache.end())
        {
          return;
        }

        // copy of result - if result is deleted before the itr is removed from cache, if could be that the deletion of
        // the result triggers another call to this function
        const linal::Vector< double> *result( itr->second);

        // erase from cache
        m_Cache.erase( itr);

        // delete result
        delete result;
      }

      //! @brief delete a result if argument changes and function has to be reevaluated
      //! @param ARGUMENT the argument for which the result has to be forgotten
      void InvalidateResult( const assemble::ProteinModel &MODEL)
      {
        // find result for that Argument
        typename CacheType::iterator itr( m_Cache.find( typename CacheType::key_type( &MODEL)));

        // delete if there is a result cached
        if( itr != m_Cache.end() && itr->second != NULL)
        {
          // delete result
          const linal::Vector< double> *result( itr->second);
          itr->second = NULL;
          delete result;
        }
      }

    };

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! default constructor
    //! @param PSEUDOCOUNT pseudocount to use
    ProteinModelSSEPacking::ProteinModelSSEPacking( const Type &TYPE) :
      m_Type( TYPE)
    {
      if( TYPE == s_NumberTypes)
      {
        std::stringstream err_str;
        BCL_Assert
        (
          this->ReadInitializerSuccessHook( util::ObjectDataLabel(), err_str),
          "Couldn't read histogram file: " + err_str.str()
        );
      }
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelSSEPacking
    ProteinModelSSEPacking *ProteinModelSSEPacking::Clone() const
    {
      return new ProteinModelSSEPacking( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelSSEPacking::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelSSEPacking::GetScheme() const
    {
      static const std::string s_contact_names[ s_NumberTypes + 1] =
      {
         "sse_contact_type",
         "sse_contact_adjacency",
         "sse_orientation",
         "sse_interaction_angle_overlap",
         GetStaticClassName< Type>()
      };
      return s_contact_names[ size_t( m_Type)];
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &ProteinModelSSEPacking::GetAlias() const
    {
      return GetScheme();
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelSSEPacking::GetSerializer() const
    {
      static const std::string s_desc[ s_NumberTypes + 1] =
      {
         "Propensity of each contact type, assuming that SSEs of the generic type are involved",
         "Propensity of the given SSE types to be in contact given that they are adjacent in sequence",
         "Orientational propensities given distance in # of SSEs apart the SSEs actually are",
         "Propensity of the SSE interaction to have the given angle and overlap with one another",
         GetStaticClassName< Type>()
      };
      io::Serializer serializer;
      serializer.SetClassDescription( std::string ( s_desc[ size_t( m_Type)]));
      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that scores the Protein model
    //! @param PROTEIN_MODEL the protein model for which all neighbor scores are calculated
    //! @return score
    double ProteinModelSSEPacking::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );

      // find all sse's not yet in the model. do not assume a linear loop between sses if another SSE could exist
      // between them, because that would invalidate the linear loop assumption
      util::SiPtrList< const assemble::SSE> non_overlapping
      (
        sp_pool.IsDefined()
        ? sp_pool->GetNonOverlappingSSEs( PROTEIN_MODEL)
        : util::SiPtrList< const assemble::SSE>()
      );

      // create an sse-pool with the missing SSEs
      assemble::SSEPool sse_pool( non_overlapping);

      // iterate through the chains of PROTEIN_MODEL
      std::stringstream oss;

      return CacheHelper::GetInstance().operator ()( PROTEIN_MODEL, sse_pool, oss, false)( size_t( m_Type));
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL ProteinModel to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &ProteinModelSSEPacking::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );

      // find all sse's not yet in the model. do not assume a linear loop between sses if another SSE could exist
      // between them, because that would invalidate the linear loop assumption
      assemble::SSEPool non_overlapping
      (
        sp_pool.IsDefined()
        ? sp_pool->GetNonOverlappingSSEs( PROTEIN_MODEL)
        : util::SiPtrList< const assemble::SSE>()
      );

      CacheHelper::GetInstance().operator ()( PROTEIN_MODEL, non_overlapping, OSTREAM, true);
      // end
      return OSTREAM;
    }

    //! @brief helper function called by WriteDetailedSchemeAndValues and operator() so that the code remains in-sync
    //! @param CHAIN the chain of interest
    //! @param MISSING_SSES missing sses from the pool
    //! @param OSTREAM the output stream to write the detailed scheme to for this chain
    //! @param DO_WRITE set to true to actually write to the output stream; otherwise, nothing will be written
    //! @return the final score
    linal::Vector< double> ProteinModelSSEPacking::Score
    (
      const assemble::ProteinModel &MODEL,
      const assemble::SSEPool &MISSING_SSES,
      std::ostream &OSTREAM,
      const bool &DO_WRITE
    ) const
    {
      static const size_t n_categories( scorestat::ProteinModelPacking::s_NumberNaturalCategories);
      static const size_t n_non_weight_categories( scorestat::ProteinModelPacking::e_WeakInteraction);
      static const Type type_mapping[ n_categories] =
      {
        e_AdjacentSSEContactPropensity, // e_Adjacent
        e_AdjacentSSEContactPropensity, // e_NonAdjacent
        e_Orientation, // AdjP
        e_Orientation, // AdjAP
        e_Orientation, // SSE+1P
        e_Orientation, // SSE+1AP
        e_Orientation, // SSE+2P
        e_Orientation, // SSE+2AP
        e_Orientation, // SSE+3P
        e_Orientation, // SSE+3AP
        e_InteractionWeight,
        e_InteractionWeight,
        e_InteractionWeight
      };
      // sum of all scores
      linal::Vector< double> score( s_NumberTypes, 0.0);

      // need at least two sses
      if( MODEL.GetNumberSSEs() < 2)
      {
        return score;
      }
      BCL_Assert
      (
        m_ContactTypeEntropies.GetSize(),
        "No contact propensities loaded! The static instance of " + this->GetClassIdentifier() + " must be used. Or the "
        "histogram may not have been found"
      );

      // collect all non-coil sse's
      const util::SiPtrVector< const assemble::SSE> structured_sses
      (
        MODEL.GetSSEs( storage::Set< biol::SSType>( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND))
      );

      if( structured_sses.GetSize() < 2)
      {
        return score;
      }

      // initializes maps for storing histograms of distances between all types of amino acid pairs
      storage::Vector< storage::Vector< linal::Vector< size_t> > > packing_info_by_sse_contact_type
      (
        structured_sses.GetSize(),
        storage::Vector< linal::Vector< size_t> >
        (
          contact::GetTypes().GetEnumCount(),
          linal::Vector< size_t>( size_t( scorestat::ProteinModelPacking::s_NumberNaturalCategories), size_t( 0))
        )
      );
      storage::Vector< linal::Vector< size_t> > contact_type_counts
      (
        structured_sses.GetSize(),
        linal::Vector< size_t>( contact::GetTypes().GetEnumCount(), size_t( 0))
      );
      storage::Vector< linal::Vector< float> > sum_packing_info_by_sse_contact_type
      (
        contact::GetTypes().GetEnumCount(),
        linal::Vector< float>( size_t( scorestat::ProteinModelPacking::s_NumberNaturalCategories), float( 0))
      );
      linal::Vector< float> sum_ave_contact_type_counts( contact::GetTypes().GetEnumCount(), float( 0));
      storage::Vector< size_t> adj_noncontact_count( structured_sses.GetSize(), size_t( 0));
      storage::Vector< size_t> adj_contact_count( structured_sses.GetSize(), size_t( 0));
      storage::Vector< size_t> dist_contact_count( structured_sses.GetSize(), size_t( 0));

      // min probability to score two residues as being an almost-certain contact
      const double min_p( 0.04);

      const size_t min_contacting_atoms( m_PackingDefinition.GetMinAtomsInContact());

      assemble::VoxelGridAA interactions_detector( m_PackingDefinition.GetMinInteractionDistance());
      linal::Matrix< float> interactions_matrix
      (
        interactions_detector.GetSSEInteractionMatrix
        (
          structured_sses,
          MODEL.GetAminoAcids(),
          2,
          m_PackingDefinition.GetMinInteractionDistance(),
          false,
          min_p,
          false
        )
      );
      // handle SSE-pair interaction-weight and parallel/anti-parallel bias
      size_t a( 0);
      size_t aas_in_sses( 0);
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          itr_a( structured_sses.Begin()),
          itr_end( structured_sses.End());
        itr_a != itr_end;
        ++itr_a, ++a
      )
      {
        size_t b( a + 1);
        aas_in_sses += ( *itr_a)->GetSize();
        for
        (
          util::SiPtrVector< const assemble::SSE>::const_iterator itr_b( itr_a + 1);
          itr_b != itr_end;
          ++itr_b, ++b
        )
        {
          bool is_adjacent( itr_b == itr_a + 1 && ( *itr_a)->GetChainID() == ( *itr_b)->GetChainID());
          if( interactions_matrix( a, b) < min_contacting_atoms && !is_adjacent)
          {
            continue;
          }
          size_t effective_separation( b - a - 1);
          const int end_last_sse_seq_id( ( *itr_a)->GetLastAA()->GetPdbID());
          const int start_next_sse_seq_id( ( *itr_b)->GetFirstAA()->GetPdbID());

          // check for any overlapping sses in the pool
          for
          (
            auto itr_pool( MISSING_SSES.Begin()), itr_pool_end( MISSING_SSES.End());
            itr_pool != itr_pool_end;
            ++itr_pool
          )
          {
            const assemble::SSE &potential_sse( **itr_pool);
            if
            (
              potential_sse.GetFirstAA()->GetSeqID() > end_last_sse_seq_id
              && potential_sse.GetLastAA()->GetSeqID() < start_next_sse_seq_id
            )
            {
              // overlapping sse. inflate the number of residues between these sses to ensure that we don't check
              // the distance between the pair
              effective_separation += 1;
            }
          }
          if( effective_separation && interactions_matrix( a, b) < min_contacting_atoms)
          {
            continue;
          }
          const double max_loop_length
          (
            ( ( *itr_b)->GetFirstAA()->GetPdbID() - ( *itr_a)->GetLastAA()->GetPdbID()) * 2.56 + 2.11
          );
          const bool could_be_opposite_ori
          (
            ( *itr_b)->GetChainID() != ( *itr_a)->GetChainID()
            ||
            std::min
            (
              linal::Distance( ( *itr_b)->GetLastAA()->GetCA().GetCoordinates(), ( *itr_a)->GetLastAA()->GetCA().GetCoordinates()),
              std::min
              (
                linal::Distance( ( *itr_b)->GetLastAA()->GetCA().GetCoordinates(), ( *itr_b)->GetFirstAA()->GetCA().GetCoordinates()),
                linal::Distance( ( *itr_a)->GetLastAA()->GetCA().GetCoordinates(), ( *itr_a)->GetFirstAA()->GetCA().GetCoordinates())
              ) + 2.34
            ) < max_loop_length
          );

          // for every pair of SSEs
          assemble::SSEGeometryPacking packing_ab( **itr_a, **itr_b, 0.0);
          if( !packing_ab.GetContactType().IsDefined())
          {
            continue;
          }
          const bool in_contact( interactions_matrix( a, b) >= min_contacting_atoms);
          if( DO_WRITE)
          {
            OSTREAM
              << ( *itr_a)->GetIdentification()
              << " " << ( *itr_b)->GetIdentification()
              << " " << packing_ab.GetContactType().GetName()
              << in_contact
              << ( is_adjacent ? "Adjacent" : "Non-Adjacent")
              << packing_ab.GetOrientationName( packing_ab.GetOrientation())
              << '\n';
          }
          const contact::Type rev_type( contact::GetTypes().Reverse( packing_ab.GetContactType()));
          if( in_contact)
          {
            ++contact_type_counts( a)( packing_ab.GetContactType());
            ++contact_type_counts( b)( rev_type);
          }
          m_PackingDefinition.AddPackingType
          (
            packing_ab,
            in_contact,
            effective_separation,
            false,
            could_be_opposite_ori,
            packing_info_by_sse_contact_type( a)( packing_ab.GetContactType())
          );
          m_PackingDefinition.AddPackingType
          (
            packing_ab,
            in_contact,
            effective_separation,
            false,
            could_be_opposite_ori,
            packing_info_by_sse_contact_type( b)( rev_type)
          );
        }
        const linal::Vector< size_t> &contact_counts( contact_type_counts( a));
        const float total_contact_counts( contact_counts.Sum());
        float norm[ n_categories] =
        {
          0.0, // e_Adjacent
          0.0, // e_NonAdjacent
          0.0, // AdjP
          0.0, // AdjAP
          0.0, // SSE+1P
          0.0, // SSE+1AP
          0.0, // SSE+2P
          0.0, // SSE+2AP
          0.0, // SSE+3P
          0.0, // SSE+3AP
          total_contact_counts,
          total_contact_counts,
          total_contact_counts
        };
        const storage::Vector< linal::Vector< size_t> > &p_info_this_sse( packing_info_by_sse_contact_type( a));
        for( size_t i( 0), n( contact_counts.GetSize()); i < n; ++i)
        {
          const linal::Vector< size_t> &contacts_counts_local( p_info_this_sse( i));
          for( size_t j( 0); j < n_non_weight_categories; ++j)
          {
            norm[ j] += contacts_counts_local( j);
          }
        }
        norm[ scorestat::ProteinModelPacking::e_AdjacentInContact]
          = norm[ scorestat::ProteinModelPacking::e_AdjacentNotInContact]
          += norm[ scorestat::ProteinModelPacking::e_AdjacentInContact];
        norm[ scorestat::ProteinModelPacking::e_AdjacentParallel]
          = norm[ scorestat::ProteinModelPacking::e_AdjacentAntiParallel]
          += norm[ scorestat::ProteinModelPacking::e_AdjacentParallel];
        norm[ scorestat::ProteinModelPacking::e_OneSSEApartParallel]
          = norm[ scorestat::ProteinModelPacking::e_OneSSEApartAntiParallel]
          += norm[ scorestat::ProteinModelPacking::e_OneSSEApartParallel];
        norm[ scorestat::ProteinModelPacking::e_TwoSSEApartParallel]
          = norm[ scorestat::ProteinModelPacking::e_TwoSSEApartAntiParallel]
          += norm[ scorestat::ProteinModelPacking::e_TwoSSEApartParallel];
        norm[ scorestat::ProteinModelPacking::e_ThreeOrMoreSSEApartParallel]
          = norm[ scorestat::ProteinModelPacking::e_ThreeOrMoreSSEApartAntiParallel]
          += norm[ scorestat::ProteinModelPacking::e_ThreeOrMoreSSEApartParallel];

        for( size_t i( 0), n( contact_counts.GetSize()); i < n; ++i)
        {
          if( total_contact_counts)
          {
            sum_ave_contact_type_counts( i) += float( contact_counts( i)) / total_contact_counts;
          }
          const linal::Vector< size_t> &contacts_counts_local( p_info_this_sse( i));
          for( size_t j( 0); j < n_categories; ++j)
          {
            if( contacts_counts_local( j))
            {
              sum_packing_info_by_sse_contact_type( i)( j) += float( contacts_counts_local( j)) / norm[ j];
            }
          }
        }
      }
      for( size_t i( 0), n_contact_types( contact::GetTypes().GetEnumCount()); i < n_contact_types; ++i)
      {
        contact::Type type( i);
        const linal::Vector< float> &spec_counts( sum_packing_info_by_sse_contact_type( i));
        if( sum_ave_contact_type_counts( i))
        {
          score( e_ContactType) += m_SSToContactTypeEntropy( i) * sum_ave_contact_type_counts( i);
          if( DO_WRITE)
          {
            OSTREAM << type.GetName() << " Count: " << sum_ave_contact_type_counts( i) << " sum-entropy: "
                    << sum_ave_contact_type_counts( i) * m_SSToContactTypeEntropy( i) << '\n';
          }
        }
        for( size_t j( 0); j < scorestat::ProteinModelPacking::s_NumberNaturalCategories; ++j)
        {
          if( spec_counts( j))
          {
            score( size_t( type_mapping[ j])) += m_ContactTypeEntropies( i)( j) * spec_counts( j);
            if( DO_WRITE)
            {
              OSTREAM << type.GetName() << " "
                      << scorestat::ProteinModelPacking::GetCategoryName( scorestat::ProteinModelPacking::Category( j))
                      << " Count: " << spec_counts( j) << " sum-entropy: "
                      << spec_counts( j) * m_ContactTypeEntropies( i)( j) << '\n';
            }
          }
        }
      }
      score *= double( aas_in_sses) / double( structured_sses.GetSize());

      // return the score sum
      return score;
    }

    //! @brief Set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @return ERROR_STREAM stream with which to write errors
    bool ProteinModelSSEPacking::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
    {
      if( !command::CommandState::GetGlobalCommandState().IsInStaticInitialization())
      {
        io::IFStream input;
        io::File::MustOpenIFStream( input, Score::AddHistogramPath( "ssepack_entropies.table"));
        if( !m_PackingDefinition.TryRead( util::ObjectDataLabel( input), ERROR_STREAM))
        {
          return false;
        }
        m_SSToContactTypeEntropy = m_PackingDefinition.ReadSSPairToContactEntropies( input);
        m_ContactTypeEntropies = m_PackingDefinition.ReadContactTypeEntropies( input);
        io::File::CloseClearFStream( input);
      }
      return true;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_sse_pairs.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelSSEPairs::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new ProteinModelSSEPairs())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! default constructor
    ProteinModelSSEPairs::ProteinModelSSEPairs() :
      m_SpScorePair(),
      m_Normalize( false)
    {
    }

    //! @brief construct from Pair function
    //! @param SP_PAIR_FUNCTION binary function to score a pair of sses
    //! @param NORMALIZE if true, final score will be normalized by the number of sses/sequences in the protein model
    //! @param SCORE_TYPE score type
    //! @param READABLE_SCHEME scheme that is more human readable
    ProteinModelSSEPairs::ProteinModelSSEPairs
    (
      const util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSE, assemble::SSE, double> > &SP_PAIR_FUNCTION,
      const bool NORMALIZE,
      const ProteinModel::Type &SCORE_TYPE,
      const std::string &READABLE_SCHEME
    ) :
      m_SpScorePair( *SP_PAIR_FUNCTION),
      m_Normalize( NORMALIZE),
      m_ScoreType( SCORE_TYPE),
      m_ReadableScheme( READABLE_SCHEME)
    {
      if( m_ReadableScheme.empty())
      {
        m_ReadableScheme = GetScheme();
      }
    }

    //! virtual copy constructor
    ProteinModelSSEPairs *ProteinModelSSEPairs::Clone() const
    {
      return new ProteinModelSSEPairs( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelSSEPairs::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelSSEPairs::GetScheme() const
    {
      return m_SpScorePair->GetScheme();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that scores the Protein model
    //! @param PROTEIN_MODEL the protein model for which all neighbor scores are calculated
    //! @return score
    double ProteinModelSSEPairs::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      //instantiate the scoresum
      double score( 0.0);

      //instantiate a util::SiPtrVector to the elements in the ProteinModel
      const util::SiPtrVector< const assemble::SSE> all_elements( PROTEIN_MODEL.GetSSEs());

      //iterate over all possible pairs of elements
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator element_itr_a( all_elements.Begin()),
          element_itr_end( all_elements.End());
        element_itr_a != element_itr_end;
        ++element_itr_a
      )
      {
        for
        (
          util::SiPtrVector< const assemble::SSE>::const_iterator element_itr_b( element_itr_a + 1);
          element_itr_b != element_itr_end;
          ++element_itr_b
        )
        {
          //call the pairscore
          score += m_SpScorePair->operator()( **element_itr_a, **element_itr_b);
        }
      }

      // if protein model has sses and normalize flag is set
      if( m_Normalize && !all_elements.IsEmpty())
      {
        return score / all_elements.GetSize();
      }

      //end
      return score;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProteinModelSSEPairs::GetAlias() const
    {
      static const std::string s_name( "ProteinModelSSEPairs");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinModelSSEPairs::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Scores interactions between SSE pairs.");
      serializer.AddInitializer
      (
        "score function",
        "function to score residue-residue interactions between the two SSEs",
        io::Serialization::GetAgent( &m_SpScorePair)
      );
      serializer.AddInitializer
      (
        "normalize",
        "normalize score by number of residues",
        io::Serialization::GetAgent( &m_Normalize)
      );

      return serializer;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL ProteinModel to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &ProteinModelSSEPairs::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      //instantiate a util::SiPtrVector to the elements in the ProteinModel
      const util::SiPtrVector< const assemble::SSE> all_elements( PROTEIN_MODEL.GetSSEs());

      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator element_itr_a( all_elements.Begin()),
          element_itr_end( all_elements.End());
        element_itr_a != element_itr_end;
        ++element_itr_a
      )
      {
        for
        (
          util::SiPtrVector< const assemble::SSE>::const_iterator element_itr_b( element_itr_a + 1);
          element_itr_b != element_itr_end;
          ++element_itr_b
        )
        {
          //write the detailed scheme and value for the pair score
          m_SpScorePair->WriteDetailedSchemeAndValues( **element_itr_a, **element_itr_b, OSTREAM);
        }
      }

      //end
      return OSTREAM;
    }

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &ProteinModelSSEPairs::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SpScorePair, ISTREAM);
      io::Serialize::Read( m_Normalize, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &ProteinModelSSEPairs::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SpScorePair, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Normalize, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_topology.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_topology_combined.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_geometry_packing_pickers.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "assemble/bcl_assemble_sse_pool_agreement.h"
#include "assemble/bcl_assemble_topology.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> ProteinModelTopology::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelTopology())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor allowing to define the score result type, and default constructor
    ProteinModelTopology::ProteinModelTopology( score_result RESULT) :
      m_Result( RESULT)
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelTopology
    ProteinModelTopology *ProteinModelTopology::Clone() const
    {
      return new ProteinModelTopology( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelTopology::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate and return the percentage of recovered contacts
    //! @param TEMPLATE the known correct protein model
    //! @param MODEL the protein model to be evaluated against the TEMPLATE
    //! @return the percentage of recovered contacts
    double ProteinModelTopology::operator()
    (
      const assemble::ProteinModel &TEMPLATE,
      const assemble::ProteinModel &MODEL
    ) const
    {
      assemble::CollectorTopologyCombined collector;
      const assemble::Topology template_topology( collector.CalculateTopology( TEMPLATE.GetSSEs()));
      const assemble::Topology model_topology( collector.CalculateTopology( MODEL.GetSSEs()));
      util::SiPtrVector< const assemble::SSEGeometryInterface> template_sses( template_topology.GetElements()),
          model_sses( model_topology.GetElements());

      SSEMap mapping( CalculateSSEMapping( template_sses, model_sses));

      storage::Vector< storage::VectorND< 2, assemble::Topology::GraphType::VertexType> >
          template_edge_vertices( template_topology.GetGraph().GetEdgeVertices()),
          model_edge_vertices( model_topology.GetGraph().GetEdgeVertices());

      BCL_MessageDbg
      (
        "template_edge_vertices.size=" + util::Format()( template_edge_vertices.GetSize())
        + " model_edge_vertices.size=" + util::Format()( model_edge_vertices.GetSize())
      );

      // calculate TP and FP rates
      size_t tp( 0); // correctly identified, i.e. contacts that exist between template SSEs and  between model SSEs
      for
      (
        storage::Vector< storage::VectorND< 2, assemble::Topology::GraphType::VertexType> >::const_iterator
          itr( template_edge_vertices.Begin()), itr_end( template_edge_vertices.End());
        itr != itr_end; ++itr
      )
      {
        const storage::VectorND< 2, assemble::Topology::GraphType::VertexType> &template_edge_verteces( *itr);
        const assemble::Topology::GraphType::VertexType &template_edge_vertex_a( template_edge_verteces.First()),
            &template_edge_vertex_b( template_edge_verteces.Second());
        const util::SiPtr< const assemble::SSEGeometryInterface>
            &template_edge_vertex_a_data( template_edge_vertex_a.GetData()),
            &template_edge_vertex_b_data( template_edge_vertex_b.GetData());
        BCL_MessageDbg
        (
          "Find sse contact for template SSEs " + template_edge_vertex_a_data->GetIdentification()
          + "||" + template_edge_vertex_b_data->GetIdentification()
        );

        const util::SiPtr< const assemble::SSEGeometryInterface>
            &model_edge_vertex_a_data( mapping[ template_edge_vertex_a_data]),
            &model_edge_vertex_b_data( mapping[ template_edge_vertex_b_data]);

        if( !model_edge_vertex_a_data.IsDefined() || !model_edge_vertex_b_data.IsDefined())
        {
          BCL_MessageDbg( "No mapping for template SSEs to model SSEs");
          continue;
        }

        const util::ShPtr< assemble::Topology::GraphType::VertexType>
            &model_edge_vertex_a( model_topology.GetGraph().FindVertex( model_edge_vertex_a_data)),
            &model_edge_vertex_b( model_topology.GetGraph().FindVertex( model_edge_vertex_b_data));
        // if the model_edge_vertex_{a,b}_data are defined, then we will find the model_edge_vertex_{a,b} in the graph

        if( !model_edge_vertex_a->FindEdge( *model_edge_vertex_b).IsDefined())
        {
          BCL_MessageDbg
          (
            "No contact for model SSEs" + model_edge_vertex_a_data->GetIdentification()
            + "||" + model_edge_vertex_b_data->GetIdentification()
          );
          continue;
        }

        BCL_MessageDbg
        (
          "Found contact for model SSEs " + model_edge_vertex_a_data->GetIdentification()
          + "||" + model_edge_vertex_b_data->GetIdentification()
        );
        ++tp;
      }

      size_t fp( model_edge_vertices.GetSize() - tp); // incorrectly identified = all identified - correctly identified
      size_t fn( template_edge_vertices.GetSize() - tp); // incorrectly rejected = all correct - correctly identified
      BCL_MessageVrb
      (
        "tp=" + util::Format()( tp) + " fp=" + util::Format()( fp) + " fn=" + util::Format()( fn)
        + " correct=tp+fn=" + util::Format()( template_edge_vertices.GetSize())
        + " predicted=tp+fp=" + util::Format()( model_edge_vertices.GetSize())
      );

      double tpr( ( double)tp / template_edge_vertices.GetSize()); // true positive rate or sensitivity
      double ppv( ( double)tp / model_edge_vertices.GetSize()); // positive predictive value or precision
      double f( 2.0 * tp / ( 2 * tp + fp + fn)); // f-score
      BCL_MessageVrb( "f=" + util::Format()( f) + " tpr=" + util::Format()( tpr) + " ppv=" + util::Format()( ppv));

      switch( m_Result)
      {
        case score_tpr: return tpr;
        case score_ppv: return ppv;
        case score_f  : break;
        default       : break;
      }
      return f;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelTopology::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelTopology::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  /////////////////////
  // helper funtions //
  /////////////////////

    //! @brief calculates a mapping template_sse->model_sse based on the Q3 score
    //! @param TEMPLATE_SSES all template SSEs
    //! @param MODEL_SSES all model SSEs
    //! @return the mapping
    ProteinModelTopology::SSEMap ProteinModelTopology::CalculateSSEMapping
    (
      util::SiPtrVector< const assemble::SSEGeometryInterface> TEMPLATE_SSES,
      util::SiPtrVector< const assemble::SSEGeometryInterface> MODEL_SSES
    )
    {
      SSEMap mapping; // result
      assemble::SSEPoolAgreement ssepool_score; // create score before loop

      // try to find a matching model SSE for every template SSE; stop if one of the vectors is empty
      while( !TEMPLATE_SSES.IsEmpty() && !MODEL_SSES.IsEmpty())
      {
        // remove from the end b/c these are vectors
        util::SiPtr< const assemble::SSEGeometryInterface> current_template_sse_ptr( TEMPLATE_SSES.LastElement());
        TEMPLATE_SSES.RemoveElement( --TEMPLATE_SSES.End());
        BCL_MessageDbg( "Find match for template_sse: " + current_template_sse_ptr->GetIdentification());

        // initialize everything before the loop
        util::SiPtrVector< const assemble::SSE> template_sse_vector( current_template_sse_ptr); // create sse vector
        assemble::SSEPool template_pool( template_sse_vector, true, false); // create pool from sse vector with template sse
        double max_score( 0.0); // best Q3 score found so far
        util::SiPtrVector< const assemble::SSEGeometryInterface>::iterator max_score_model_sse_itr( MODEL_SSES.End());

        for
        (
          util::SiPtrVector< const assemble::SSEGeometryInterface>::iterator
            itr( MODEL_SSES.Begin()), itr_end( MODEL_SSES.End());
          itr != itr_end; ++itr
        )
        {
          util::SiPtrVector< const assemble::SSE> model_sse_vector( *itr);
          assemble::SSEPool model_pool( model_sse_vector, true, false);
          double score( ssepool_score.Q3Score( template_pool, model_pool));
          if( score > max_score)
          {
            max_score = score;
            max_score_model_sse_itr = itr;
          }
          BCL_MessageDbg
          (
            "Compare with model_sse: " + ( **itr).GetIdentification() + " score=" + util::Format()( score)
            + " max_score=" + util::Format()( max_score)
          );
        }

        // if we have a match, create mapping, and remove model sses from the vector (the template sse is removed above)
        if( max_score_model_sse_itr != MODEL_SSES.End() && max_score_model_sse_itr->IsDefined())
        {
          BCL_MessageDbg
          (
            "Create mapping template_sse->model_sse: " + current_template_sse_ptr->GetIdentification()
            + "->" + ( **max_score_model_sse_itr).GetIdentification()
          );
          mapping.Insert
          (
            std::pair
            <
              util::SiPtr< const assemble::SSEGeometryInterface>, util::SiPtr< const assemble::SSEGeometryInterface>
            >( current_template_sse_ptr, *max_score_model_sse_itr)
          );
          MODEL_SSES.RemoveElement( max_score_model_sse_itr);
        }
        else
        {
          BCL_MessageVrb( "No mapping for template_sse " + current_template_sse_ptr->GetIdentification());
        }
      }

      return mapping;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_protein_model_wrapper.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelWrapper::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelWrapper())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelWrapper::ProteinModelWrapper() :
      m_Function(),
      m_ScoreType( e_Undefined),
      m_ReadableScheme()
    {
    }

    //! @brief construct from member
    //! @param SP_FUNCTION function to wrap
    //! @brief construct from members
    //! @param SP_FUNCTION function to wrap
    //! @param TYPE score type
    //! @param READABLE_SCHEME readable scheme
    ProteinModelWrapper::ProteinModelWrapper
    (
      const util::ShPtr< math::FunctionInterfaceSerializable< assemble::ProteinModel, double> > &SP_FUNCTION,
      const Type &TYPE,
      const std::string &READABLE_SCHEME,
      const std::string &SCHEME
    ) :
      m_Function( SP_FUNCTION),
      m_ScoreType( TYPE),
      m_ReadableScheme( READABLE_SCHEME),
      m_Scheme( SCHEME)
    {
      if( m_ReadableScheme.empty())
      {
        m_ReadableScheme = m_Function->GetScheme();
      }
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelWrapper
    ProteinModelWrapper *ProteinModelWrapper::Clone() const
    {
      return new ProteinModelWrapper( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelWrapper::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &ProteinModelWrapper::GetScheme() const
    {
      return m_Scheme.empty() ? m_Function->GetScheme() : m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a t_ResultType object
    //! @param ARGUMENT Argument to be used to evaluate the function
    //! @return function value of the given argument
    double ProteinModelWrapper::operator()( const assemble::ProteinModel &ARGUMENT) const
    {
      return m_Function->operator ()( ARGUMENT);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelWrapper::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelWrapper::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

    //! @brief write detailed scheme and values to OSTREAM
    //! @param ARGUMENT Argument to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &ProteinModelWrapper::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &ARGUMENT,
      std::ostream &OSTREAM
    ) const
    {
      return m_Function->WriteDetailedSchemeAndValues( ARGUMENT, OSTREAM);
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_radius_of_gyration.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "command/bcl_command_command_state.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_histogram.h"
#include "math/bcl_math_running_average_sd.h"
#include "math/bcl_math_statistics.h"
#include "score/bcl_score_energy_distribution.h"
#include "storage/bcl_storage_table.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> RadiusOfGyration::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new RadiusOfGyration())
    );

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return the default filename for the default phi_psi_angle statistics
    const std::string &RadiusOfGyration::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "radius_of_gyration_chains.histogram");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &RadiusOfGyration::GetDefaultHistogramFilenameMembrane()
    {
      // static string
      static const std::string s_default_histogram_filename( "radius_of_gyration_model_membrane.histogram");

      // end
      return s_default_histogram_filename;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param NORMALIZE flag to enable normalization
    //! @param SCHEME scheme to be used
    //! @param SOLUBLE_FILENAME filename for soluble histogram
    //! @param MEMBRANE_FILENAME filename for membrane histogram
    RadiusOfGyration::RadiusOfGyration
    (
      const bool NORMALIZE,
      const bool RAW,
      const std::string &SCHEME,
      const std::string &SOLUBLE_FILENAME,
      const std::string &MEMBRANE_FILENAME
    ) :
      m_Normalize( NORMALIZE),
      m_Raw( RAW),
      m_Scheme( SCHEME.empty() ? std::string( RAW ? "rgyr_raw" : "rgyr") + std::string( NORMALIZE ? "_norm" : "") : SCHEME),
      m_HistogramFileNameSoluble( SOLUBLE_FILENAME),
      m_HistogramFileNameMembrane( MEMBRANE_FILENAME),
      m_EnergyFunctionSoluble(),
      m_EnergyFunctionMembrane()
    {
      std::ostringstream oss;
      ReadInitializerSuccessHook( util::ObjectDataLabel(), oss);
    }

    //! @brief virtual copy constructor
    RadiusOfGyration *RadiusOfGyration::Clone() const
    {
      return new RadiusOfGyration( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RadiusOfGyration::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &RadiusOfGyration::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief returns filename of the histogram being used for soluble proteins
    //! @return filename of the histogram being used for soluble proteins
    const std::string &RadiusOfGyration::GetHistogramFilenameSoluble() const
    {
      return m_HistogramFileNameSoluble;
    }

    //! @brief returns filename of the histogram being used for membrane proteins
    //! @return filename of the histogram being used for membrane proteins
    const std::string &RadiusOfGyration::GetHistogramFilenameMembrane() const
    {
      return m_HistogramFileNameMembrane;
    }

    //! @brief returns the energy function
    //! @return energy function
    const math::CubicSplineDamped &RadiusOfGyration::GetEnergyFunctionSoluble() const
    {
      return *m_EnergyFunctionSoluble;
    }

    //! @brief returns the membrane energy function
    //! @return membrane energy function
    const math::CubicSplineDamped &RadiusOfGyration::GetEnergyFunctionMembrane() const
    {
      return *m_EnergyFunctionMembrane;
    }

    //! @brief get a more readable score scheme
    //! @return a more readable score scheme
    const std::string &RadiusOfGyration::GetReadableScheme() const
    {
      static const std::string s_readable_scheme( "Radius of gyration");
      return s_readable_scheme;
    }

    //! @brief get score type
    //! @return score type
    ProteinModel::Type RadiusOfGyration::GetType() const
    {
      return ProteinModel::e_Structure;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RadiusOfGyration::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      (
        "Calculates the radius of gyration score of a protein model."
      );
      serializer.AddInitializer
      (
        "raw",
        "if set, no energy function (from histograms) will be used. Instead, the raw radius of gyration will be returned. ",
        io::Serialization::GetAgent( &m_Raw),
        "False"
      );
      serializer.AddInitializer
      (
        "normalize",
        "normalize by sequence length",
        io::Serialization::GetAgent( &m_Normalize),
        "False"
      );
      serializer.AddInitializer
      (
        "histogram file name soluble",
        "file name of the histogram for the radius of gyration of soluble proteins.",
        io::Serialization::GetAgent( &m_HistogramFileNameSoluble),
        GetDefaultHistogramFilename()
      );
      serializer.AddInitializer
      (
        "histogram file name membrane",
        "file name of the histogram for the radius of gyration of membrane proteins.",
        io::Serialization::GetAgent( &m_HistogramFileNameMembrane),
        GetDefaultHistogramFilenameMembrane()
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculates the radius of gyration for CB atoms for ProteinModel
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return the radius of gyration for CB atoms for ProteinModel
    double RadiusOfGyration::SquareRadiusOfGyration( const assemble::ProteinModel &PROTEIN_MODEL)
    {
      // calculate the radius of gyration
      return coord::SquareRadiusOfGyration
      (
        PROTEIN_MODEL.GetAtomCoordinates( biol::GetAtomTypes().GetFirstSidechainAtomTypes())
      );
    }

    //! @brief calculates the radius of gyration for specified atom type for ProteinModel with a collapsing normal
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @param ATOM_TYPES Atom types that will be considered when doing the calculations
    //! @return the radius of gyration for specified atom type for ProteinModel with a collapsing normal
    double RadiusOfGyration::SquareRadiusOfGyrationCollapsed
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      // try to get the membrane
      const util::ShPtr< biol::Membrane> &sp_membrane
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane)
      );

      // calculate the radius of gyration
      return SquareRadiusOfGyrationCollapsed
      (
        PROTEIN_MODEL.GetAtomCoordinates( ATOM_TYPES),
        sp_membrane
      );
    }

    //! @brief compute the square radius of gyration for a set of coordinates and a collapsing normal
    //! @param COORDINATES coordinates to be collapsed
    //! @param MEMBRANE membrane object to collapse
    //! @return square radius of gyration collapsed
    double RadiusOfGyration::SquareRadiusOfGyrationCollapsed
    (
      const util::SiPtrVector< const linal::Vector3D> &COORDINATES,
      const util::ShPtr< biol::Membrane> &MEMBRANE
    )
    {
      // if membrane not defined
      if( !MEMBRANE.IsDefined() || MEMBRANE->GetThickness( biol::GetEnvironmentTypes().e_MembraneCore) == 0.0)
      {
        // return normal radius of gyration
        return coord::SquareRadiusOfGyration( COORDINATES);
      }

      //collapsed coordinates
      storage::Vector< linal::Vector3D> collapsed_coordinates;
      collapsed_coordinates.AllocateMemory( COORDINATES.GetSize());

      // collapse distance
      const double collapse_distance( MEMBRANE->GetThickness( biol::GetEnvironmentTypes().e_MembraneCore));
      const linal::Vector3D normal( MEMBRANE->GetNormal());

      for
      (
        util::SiPtrVector< const linal::Vector3D>::const_iterator
          coordinates_itr( COORDINATES.Begin()), coordinates_itr_end( COORDINATES.End());
        coordinates_itr != coordinates_itr_end;
        ++coordinates_itr
      )
      {
        // skip undefined coordinates
        if( !( *coordinates_itr)->IsDefined())
        {
          continue;
        }

        linal::Vector3D current_coord( **coordinates_itr);
        double distance( linal::ScalarProduct( normal, current_coord - MEMBRANE->GetCenter()));

        // if distance is above collapse zone
        if( distance > collapse_distance)
        {
          // move toward plane by collapse distance
          current_coord -= collapse_distance * normal;
        }
        // if distance is below collapse zone
        else if( distance < -collapse_distance)
        {
          // move toward plane by collapse distance
          current_coord += collapse_distance * normal;
        }
        // if distance is within collapse zone
        else
        {
          // move onto plane
          current_coord -= distance * normal;
        }

        // insert
        collapsed_coordinates.PushBack( current_coord);
      }

      //end
      return coord::SquareRadiusOfGyration( util::ConvertToSiPtrVector( collapsed_coordinates));
    }

    //! @brief Set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @param ERROR_STREAM stream with which to write errors
    //! @return return code indicating success or failure
    bool RadiusOfGyration::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
    {
      if( !command::CommandState::IsInStaticInitialization())
      {
        m_EnergyFunctionSoluble = ReadEnergyFunction( m_HistogramFileNameSoluble);
        m_EnergyFunctionMembrane = ReadEnergyFunction( m_HistogramFileNameMembrane);
      }
      return true;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the score of radius of gyration for the given ProteinModel
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return the score of radius of gyration for the given ProteinModel
    double RadiusOfGyration::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      BCL_MessageDbg( "score radius of gyration");
      if( PROTEIN_MODEL.GetChains().IsEmpty())
      {
        return double( 0);
      }

      if( PROTEIN_MODEL.GetNumberSSE( biol::GetSSTypes().COIL) > size_t( 0))
      {
        assemble::ProteinModel copy( PROTEIN_MODEL);
        auto coils( copy.GetSSEs( biol::GetSSTypes().COIL));
        for( auto itr( coils.Begin()), itr_end( coils.End()); itr != itr_end; ++itr)
        {
          copy.Remove( **itr);
        }
        copy.SetProteinModelData( PROTEIN_MODEL.GetProteinModelData());
        return operator()( copy);
      }
      // collect all first side chain atom coordinates
      const util::SiPtrVector< const linal::Vector3D> first_sc_atom_coordinates
      (
        PROTEIN_MODEL.GetAtomCoordinates( biol::GetAtomTypes().GetFirstSidechainAtomTypes())
      );

      // get the total number of residues between
      size_t number_res( 0);
      for
      (
        auto chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        if( ( *chain_itr)->GetNumberSSEs())
        {
          auto sses( ( *chain_itr)->GetSSEs());
          number_res += sses.LastElement()->GetFirstAA()->GetSeqID() - sses.FirstElement()->GetFirstAA()->GetSeqID() + 1;
        }
      }

      // if no atom coordinates
      if( first_sc_atom_coordinates.IsEmpty())
      {
        return double( 0);
      }

      // initialize values to calculate
      double square_radius_of_gyration;
      double ratio_square_rgyr_residues;
      double score;

      // try to get the membrane
      const util::ShPtr< biol::Membrane> &sp_membrane
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane)
      );

      // if this is a membrane protein
      if( sp_membrane.IsDefined() && sp_membrane->GetThickness( biol::GetEnvironmentTypes().e_MembraneCore) != 0.0)
      {
        square_radius_of_gyration = SquareRadiusOfGyrationCollapsed( first_sc_atom_coordinates, sp_membrane);

        // calculate the ratio of square radius of gyration to number of coordinates (residues) used
        ratio_square_rgyr_residues = square_radius_of_gyration / double( number_res);

        // return the value from the spline
        score = util::IsDefined( ratio_square_rgyr_residues)
                ? ( m_Raw ? ratio_square_rgyr_residues - 1.3 : m_EnergyFunctionMembrane->operator ()( ratio_square_rgyr_residues))
                : 0;
      }
      // a soluble protein
      else
      {
        square_radius_of_gyration = coord::SquareRadiusOfGyration( first_sc_atom_coordinates);

        // calculate the ratio of square radius of gyration to number of coordinates (residues) used
        ratio_square_rgyr_residues = square_radius_of_gyration / double( number_res);

        // return the value from the spline
        score = util::IsDefined( ratio_square_rgyr_residues)
                ? ( m_Raw ? ratio_square_rgyr_residues - 1.3 : m_EnergyFunctionSoluble->operator ()( ratio_square_rgyr_residues))
                : 0;
      }

      // if normalization flag is not given
      if( !m_Normalize)
      {
        score *= double( first_sc_atom_coordinates.GetSize());
      }

      // end
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief create histograms from a table generated from statistics application
    //! @param TABLE containing rows: rgyr_sqr, nr_coordinates, subunits
    //! @return map containg histograms for proteins with a single subunit and one over all with the filenames as key
    storage::Map< std::string, math::Histogram> RadiusOfGyration::HistogramsFromTable( const storage::Table< double> &TABLE)
    {
      // calculate mean and sd of rgyr2 and number residues
      math::RunningAverageSD< double> single_mean_sd;
      math::RunningAverageSD< double> multi_mean_sd;
      for( storage::Table< double>::const_iterator itr( TABLE.Begin()), itr_end( TABLE.End()); itr != itr_end; ++itr)
      {
        const double ratio( itr->Second()[ "rgyr_sqr"] / itr->Second()[ "nr_aa"]);
        if( util::IsDefined( ratio) && ratio > 0.0)
        {
          if( itr->Second()[ "subunits"] == 1.0)
          {
            single_mean_sd += ratio;
          }
          multi_mean_sd += ratio;
        }
      }

      // binsize and start
      const size_t nr_bins( 30);
      const double binsize_single( 0.2);
      const double start_single( 0.0);
      const double binsize_multi( 0.2);
      const double start_multi( 0.0);

      math::Histogram radius_of_gryation_chains_histogram( start_single, binsize_single, nr_bins);
      math::Histogram radius_of_gryation_model_histogram( start_multi, binsize_multi, nr_bins);

      for( storage::Table< double>::const_iterator itr( TABLE.Begin()), itr_end( TABLE.End()); itr != itr_end; ++itr)
      {
        const double ratio( itr->Second()[ "rgyr_sqr"] / itr->Second()[ "nr_aa"]);
        if( util::IsDefined( ratio) && ratio > 0.0)
        {
          if( itr->Second()[ "subunits"] == 1.0)
          {
            radius_of_gryation_chains_histogram.PushBack( ratio);
          }
          radius_of_gryation_model_histogram.PushBack( ratio);
        }
      }

      storage::Map< std::string, math::Histogram> histograms;

      // write rgyr histogram for chains
      histograms[ "radius_of_gyration_chains"] = radius_of_gryation_chains_histogram;
      histograms[ "radius_of_gyration_model"] = radius_of_gryation_model_histogram;

      // end
      return histograms;
    }

    //! @brief read individual energy functions for scoring radius of gyration
    //! @param FILENAME filename to be read in
    //! @return read in energy function
    util::ShPtr< math::CubicSplineDamped> RadiusOfGyration::ReadEnergyFunction( const std::string &FILENAME)
    {
      // initialize read
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( FILENAME));

      // read histogram and reset the stream
      math::Histogram rgyr_histogram;
      read >> rgyr_histogram;
      io::File::CloseClearFStream( read);

      // remove unnecessary bins
      // iterate over the all bins and find the second positive slope
      bool downwards( false);
      rgyr_histogram.RemoveBinsBeforeIndex( rgyr_histogram.GetIndexOfFirstInformationContainingBin());
      size_t i( 0), i_max( rgyr_histogram.GetNumberOfBins() - 1);
      for( ; i < i_max; ++i)
      {
        // still first slope?
        if( !downwards)
        {
          downwards = rgyr_histogram.GetHistogram()( i) > rgyr_histogram.GetHistogram()( i + 1);
        }
        // first slope overcome - ist there another positive slope
        else if( rgyr_histogram.GetHistogram()( i) < rgyr_histogram.GetHistogram()( i + 1))
        {
          rgyr_histogram.RemoveBinsAfterIndex( i);
          break;
        }
      }

      // was there a second positive slope?
      if( i >= i_max)
      {
        rgyr_histogram.RemoveBinsAfterIndex( rgyr_histogram.GetIndexOfLastInformationContainingBin());
      }

      // create a cubic spline from the histogram and return
      return util::ShPtr< math::CubicSplineDamped>
      (
        new math::CubicSplineDamped
        (
          EnergyDistribution::GeneratePotentialFromHistogram
          (
            rgyr_histogram, 1.0, math::e_FirstDer, storage::Pair< double, double>( 0.0, 0.0)
          )
        )
      );
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_read_histograms.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_types.h"
#include "biol/bcl_biol_environment_types.h"
#include "math/bcl_math_histogram.h"
#include "score/bcl_score_energy_distribution.h"
#include "util/bcl_util_si_ptr_vector.h"
#include "util/bcl_util_string_functions.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  ////////////////
  // operations //
  ////////////////

    //! @brief read histograms for membrane dependent score from stream
    //! also removes additional empty bins from the end of the histograms - but keeping them all of the same length
    //! @param ISTREAM stream containing the histograms for each membrane region 20 amino acid histograms
    //! @return vector for all membrane regions containing vectors of histograms containing all amino acids
    storage::Vector< storage::Vector< math::Histogram> >
    ReadHistograms::ReadMembraneDependentEnvironmentHistograms
    (
      std::istream &ISTREAM
    )
    {
      // vector for all membrane regions containing vectors of histograms containing all amino acids
      storage::Vector< storage::Vector< math::Histogram> >
        membrane_aa_histograms
        (
          biol::GetEnvironmentTypes().GetEnumCount(),
          storage::Vector< math::Histogram>
          (
            biol::GetAATypes().GetEnumCount()
          )
        );

      // initialize vector of histograms
      util::SiPtrVector< math::Histogram> all_histograms;

      // iterate over environment types
      while( ISTREAM.good() && !ISTREAM.eof())
      {
        // read environment type and make sure it is correct
        std::string tmp_env;
        ISTREAM >> tmp_env;
        if( !ISTREAM.good())
        {
          break;
        }
        ISTREAM >> tmp_env;
        biol::EnvironmentType current_env( util::Strip( tmp_env, "\""));

        // iterate over AATypes
        for( biol::AATypes::const_iterator
               aa_itr( biol::GetAATypes().Begin()),
               aa_itr_end( biol::GetAATypes().GetEnumIteratorFromIndex( biol::AATypes::s_NumberStandardAATypes));
             aa_itr != aa_itr_end;
             ++aa_itr)
        {
          // get the one letter code and make sure it is correct
          std::string tmp;
          ISTREAM >> tmp;
          biol::AAType aatype( biol::GetAATypes().AATypeFromOneLetterCode( tmp[ 0]));
          BCL_Assert
          (
            *aa_itr == aatype,
            "unexpected aatype read from file! " + util::Format()( *aa_itr) + " != " +   util::Format()( aatype)
          );

          // read the corresponding histogram
          ISTREAM >> membrane_aa_histograms( current_env)( aatype);

          // pushback the histogram
          all_histograms.PushBack( util::SiPtr< math::Histogram>( membrane_aa_histograms( current_env)( aatype)));
        }
      }

      // remove all empty bins - but keep the length of all histograms the same
      EnergyDistribution::RemoveAdditionalEmptyBinsExceptOne( all_histograms);

      // end
      return membrane_aa_histograms;
    }

    //! read histograms from stream, containing 20 histograms for each aminoacid
    storage::Vector< math::Histogram>
    ReadHistograms::ReadEnvironmentHistograms
    (
      std::istream &ISTREAM
    )
    {
      // histograms for all aminoacids
      storage::Vector< math::Histogram> histograms( biol::AATypes::s_NumberStandardAATypes);

      for( biol::AATypes::const_iterator
             aa_itr( biol::GetAATypes().Begin()),
             aa_itr_end( biol::GetAATypes().GetEnumIteratorFromIndex( biol::AATypes::s_NumberStandardAATypes));
           aa_itr != aa_itr_end;
           ++aa_itr)
      {
        math::Histogram current_aa_env_histogram;
        biol::AAType current_aatype;

        // read one letter code and make sure it is correct amino acid
        std::string tmp;
        ISTREAM >> tmp;
        current_aatype = biol::GetAATypes().AATypeFromOneLetterCode( tmp[ 0]);
        BCL_Assert
        (
          *aa_itr == current_aatype,
          "unexpected aatype read from file! " + util::Format()( *aa_itr) + " != " +   util::Format()( current_aatype)
        );

        // read the corresponding histogram for this AAType
        ISTREAM >> histograms( current_aatype);
      }

      util::SiPtrVector< math::Histogram> all_histograms( util::ConvertToSiPtrVector( histograms));
      // remove all empty bins - but keep the length of all histograms the same
      EnergyDistribution::RemoveAdditionalEmptyBinsExceptOne( all_histograms);

      // end
      return histograms;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_residual_dipolar_coupling_histogram.h"

// includes from bcl - sorted alphabetically
#include "math/bcl_math_histogram.h"
#include "math/bcl_math_running_min_max.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_message.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ResidualDipolarCouplingHistogram::s_Instance
    (
      util::Enumerated< math::FunctionInterfaceSerializable< nmr::RDCContainer, double> >::AddInstance
      (
        new ResidualDipolarCouplingHistogram()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Clone function
    //! @return pointer to new ResidualDipolarCoupling
    ResidualDipolarCouplingHistogram *ResidualDipolarCouplingHistogram::Clone() const
    {
       return new ResidualDipolarCouplingHistogram( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &ResidualDipolarCouplingHistogram::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &ResidualDipolarCouplingHistogram::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "rdc_histogram");

      // end
      return s_default_scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator() for calculating the agreement between theoretical and experimental RDCs
    //! @param RDC_CONTAINER contains both the theoretical and experimental RDCs
    //! @return double which is the agreement between the theoretical and experimental RDCs
    double ResidualDipolarCouplingHistogram::operator()( const nmr::RDCContainer &RDC_CONTAINER) const
    {
      static const size_t s_nr_bins( 25);

      // initialize min/max dataset to get histogram boundaries
      math::RunningMinMax< double> data_set_min_max;

      // iterate through the RDCContainer
      for
      (
        storage::Vector< double>::const_iterator
          exp_itr( RDC_CONTAINER.GetExperimentalValues().Begin()),
          exp_itr_end( RDC_CONTAINER.GetExperimentalValues().End()),
          calc_itr( RDC_CONTAINER.GetCalculatedlValues().Begin()),
          calc_itr_end( RDC_CONTAINER.GetCalculatedlValues().End());
        exp_itr != exp_itr_end && calc_itr != calc_itr_end; ++exp_itr, ++calc_itr
      )
      {
        data_set_min_max += *exp_itr;
        data_set_min_max += *calc_itr;
      }

      // Initialize variables for creating histograms
      const double min_value( data_set_min_max.GetMin() - 0.1);
      const double bin_size( ( data_set_min_max.GetMax() - min_value) / s_nr_bins + 0.01);

      // Create histograms for experimental and calculated RDCs
      math::Histogram exp_histogram( min_value, bin_size, s_nr_bins);
      math::Histogram calc_histogram( min_value, bin_size, s_nr_bins);

      // Calculate the histograms
      exp_histogram.CalculateHistogram( RDC_CONTAINER.GetExperimentalValues());
      calc_histogram.CalculateHistogram( RDC_CONTAINER.GetCalculatedlValues());

      // Initialize sum of square difference
      double sum_of_squares( 0.0);

      // Initialize the number of non empty bins
      size_t non_empty_bins( 0);

      // Iterate through the bins in both histograms
      for
      (
        linal::Vector< double>::const_iterator
          exp_count_itr( exp_histogram.GetHistogram().Begin()),
          exp_count_itr_end( exp_histogram.GetHistogram().End()),
          calc_count_itr( calc_histogram.GetHistogram().Begin()),
          calc_count_itr_end( calc_histogram.GetHistogram().End());
        exp_count_itr != exp_count_itr_end && calc_count_itr != calc_count_itr_end;
        ++exp_count_itr, ++calc_count_itr
      )
      {

        // Increment the number of non empty bins
        if( *exp_count_itr > 0 || *calc_count_itr > 0)
        {
          ++non_empty_bins;
        }

        // Calculate the difference then square it then add to the sum
        sum_of_squares += math::Sqr( *exp_count_itr - *calc_count_itr);
      }

      // Calculate the RMSD
      const double histogram_rmsd( math::Sqrt( sum_of_squares / double( non_empty_bins)));

      BCL_MessageStd( util::Format()( histogram_rmsd));

      // convert the rmsd to a score
      const double score( histogram_rmsd == 0.0 ? -1.0 : -1.0 / histogram_rmsd);

      BCL_MessageStd( util::Format()( score));

      // incorporate the number of rdcs available into the score by taking the natural log of that number and
      // multiplying it by the rmsd
      return log( double( RDC_CONTAINER.GetExperimentalValues().GetSize() + 1)) * score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ResidualDipolarCouplingHistogram::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription( "Compares experimental with calculated RDC histograms");
      return parameters;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_residual_dipolar_coupling_q_value.h"

// includes from bcl - sorted alphabetically
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ResidualDipolarCouplingQValue::s_Instance
    (
      util::Enumerated< math::FunctionInterfaceSerializable< nmr::RDCContainer, double> >::AddInstance
      (
        new ResidualDipolarCouplingQValue()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Clone function
    //! @return pointer to new ResidualDipolarCouplingQValue
    ResidualDipolarCouplingQValue *ResidualDipolarCouplingQValue::Clone() const
    {
      return new ResidualDipolarCouplingQValue( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &ResidualDipolarCouplingQValue::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &ResidualDipolarCouplingQValue::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "rdc_q_value");

      // end
      return s_default_scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator() for calculating the agreement between theoretical and experimental RDCs
    //! @param RDC_RESTRAINTS contains the experimental RDCs and calculated RDCs
    //! @return double which is the agreement between the theoretical and experimental RDCs
    double ResidualDipolarCouplingQValue::operator()( const nmr::RDCContainer &RDC_RESTRAINTS) const
    {
      // initialize sums
      double square_experimental_sum( 0.0);
      double square_deviation_sum( 0.0);

      // iterate over the data
      for
      (
        storage::Vector< double>::const_iterator
          exp_itr( RDC_RESTRAINTS.GetExperimentalValues().Begin()),
          exp_itr_end( RDC_RESTRAINTS.GetExperimentalValues().End()),
          calc_itr( RDC_RESTRAINTS.GetCalculatedlValues().Begin()),
          calc_itr_end( RDC_RESTRAINTS.GetCalculatedlValues().End());
        exp_itr != exp_itr_end && calc_itr != calc_itr_end; ++exp_itr, ++calc_itr
      )
      {
        // update the square deviation
        square_deviation_sum += math::Sqr( *exp_itr - *calc_itr);

        // update the square experimental sum
        square_experimental_sum += math::Sqr( *exp_itr);
      }

      // if square_experimental_sum is zero (no restraints passed or some problem with data)
      if( square_experimental_sum == 0.0)
      {
        // return 0 (basically the maximum score)
        return 0.0;
      }

      // calculate the q value
      double q_value( math::Sqrt( square_deviation_sum / square_experimental_sum));

      // convert q-value to score by subtracting 1
      return q_value - 1.0;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param RDC_RESTRAINTS contains the experimental RDCs and calculated RDCs
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &ResidualDipolarCouplingQValue::WriteDetailedSchemeAndValues
    (
      const nmr::RDCContainer &RDC_RESTRAINTS,
      std::ostream &OSTREAM
    ) const
    {
      // write the scheme
      OSTREAM << GetScheme() << '\n';

      // initialize sums
      double square_experimental_sum( 0.0);
      double square_deviation_sum( 0.0);

      // iterate over the data
      for
      (
        storage::Vector< double>::const_iterator
          exp_itr( RDC_RESTRAINTS.GetExperimentalValues().Begin()),
          exp_itr_end( RDC_RESTRAINTS.GetExperimentalValues().End()),
          calc_itr( RDC_RESTRAINTS.GetCalculatedlValues().Begin()),
          calc_itr_end( RDC_RESTRAINTS.GetCalculatedlValues().End());
        exp_itr != exp_itr_end && calc_itr != calc_itr_end; ++exp_itr, ++calc_itr
      )
      {
        // write the experimental value, the calculated value, and the single Q value
        OSTREAM << util::Format()( *exp_itr) << ", " << util::Format()( *calc_itr) << " : "
                << util::Format()( math::Sqrt( math::Sqr( *exp_itr - *calc_itr) / math::Sqr( *exp_itr))) << '\n';

        // update the sums
        square_deviation_sum += math::Sqr( *exp_itr - *calc_itr);
        square_experimental_sum += math::Sqr( *exp_itr);
      }

      // write the Q-value
      OSTREAM << "Q-value: " << util::Format()( math::Sqrt( square_deviation_sum / square_experimental_sum)) << '\n';

      // end
      return OSTREAM;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ResidualDipolarCouplingQValue::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription( "Calculates normalized standard deviation between computed and experimental RDCs");
      return parameters;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_atom_attraction.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_histogram.h"
#include "math/bcl_math_trigonometric_transition.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> RestraintAtomAttraction::s_Instance
    (
      util::Enumerated< RestraintAtomDistanceAssignment>::AddInstance( new RestraintAtomAttraction())
    );

    //! @brief gives the default width of the cosine transition region of the peicewise function
    //! @return double which is the default width of the cosine transition region of the peicewise function
    double RestraintAtomAttraction::GetDefaultTransitionWidth()
    {
      return double( 25.0);
    }

    //! @brief gives the default range of the depth of the cosine transition region of the peicewise function
    //! @return double which gives the default range of the depth of the cosine transition region of the function
    const math::Range< double> &RestraintAtomAttraction::GetDefaultDepthRange()
    {
      static const math::Range< double> s_depth_range( -1.0, 0.0);

      return s_depth_range;
    }

    //! @brief amount to shift in the x-direction so that attraction is not level at same place as KB potential
    //! @return double amount to shift in x-direction so that attraction is not level at same place as KB potential
    double RestraintAtomAttraction::GetDefaultScoreOffset()
    {
      return 2.0;
    }

    //! @brief gives the x-coordinate of the ending point for the attraction on the left of the KB potential
    //! @return double which is the x-coordinate of the ending point for the attraction on the left of the KB potential
    double RestraintAtomAttraction::GetDefaultLeftEndWell( const math::Histogram &HISTOGRAM)
    {
      return HISTOGRAM.GetBoundaries().First() +
        double( HISTOGRAM.GetIndexOfFirstInformationContainingBin()) * HISTOGRAM.GetBinSize() +
        RestraintAtomAttraction::GetDefaultScoreOffset();
    }

    //! @brief gives the x-coordinate of the ending point for the attraction on the right of the KB potential
    //! @return double which is the x-coordinate of the ending point for the attraction on the right of the KB potential
    double RestraintAtomAttraction::GetDefaultRightEndWell( const math::Histogram &HISTOGRAM)
    {
      BCL_Assert
      (
        HISTOGRAM.GetBinning().GetSize() != HISTOGRAM.GetIndexOfLastInformationContainingBin(),
        "Your histogram has counts outside its boundaries. Increase the width of your histogram."
      );
      return HISTOGRAM.GetBoundaries().Second() -
        double( HISTOGRAM.GetBinning().GetSize() - HISTOGRAM.GetIndexOfLastInformationContainingBin() - 1) *
        HISTOGRAM.GetBinSize() - GetDefaultScoreOffset() + GetDefaultTransitionWidth();
    }

  //////////
  // data //
  //////////

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintAtomAttraction::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "atom_attraction");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    RestraintAtomAttraction::RestraintAtomAttraction() :
      m_WellPotential( 0.0, GetDefaultTransitionWidth(), GetDefaultDepthRange().GetMin(), GetDefaultDepthRange().GetMax()),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief constructor from a specified histogram file
    //! @param WELL_DEPTH range over which the function will cover
    //! @param END_OF_WELL where the well should end
    //! @param WIDTH how wide the cos portion of the scoring function should be
    //! @param MAX_TO_MIN true if the function should go from max to min value - false otherwise
    //! @param SCHEME scheme to be used
    RestraintAtomAttraction::RestraintAtomAttraction
    (
      const math::Range< double> &WELL_DEPTH,
      const double END_OF_WELL,
      const double WIDTH,
      const bool MAX_TO_MIN,
      const std::string &SCHEME
    ) :
      m_WellPotential
      (
        END_OF_WELL - WIDTH,
        END_OF_WELL,
        MAX_TO_MIN ? WELL_DEPTH.GetMax() : WELL_DEPTH.GetMin(),
        MAX_TO_MIN ? WELL_DEPTH.GetMin() : WELL_DEPTH.GetMax()
      ),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone is the virtual copy constructor
    RestraintAtomAttraction *RestraintAtomAttraction::Clone() const
    {
      return new RestraintAtomAttraction( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintAtomAttraction::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &RestraintAtomAttraction::GetAlias() const
    {
      return m_Scheme;
    }

    //! @brief gives the peicewise function that comprises this score
    //! @return function that is this score
    const math::TrigonometricTransition &RestraintAtomAttraction::GetFunction() const
    {
      return m_WellPotential;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief () operator scores protein model
    //! @param RESTRAINT restraint to be scored
    //! @return score
    double RestraintAtomAttraction::operator()( const restraint::AtomDistanceAssignment &RESTRAINT) const
    {
      // calculate the distance between the two modeled atoms
      const double cb_distance( RESTRAINT.CalculateAtomDistance());

      // if the calculated distance is undefined
      if( !util::IsDefined( cb_distance))
      {
        // return default score
        return std::max( m_WellPotential.GetTransitionBeginYAxis(), m_WellPotential.GetTransitionEndYAxis());
      }

      // return the well-potential's scoring value
      return m_WellPotential( RESTRAINT.GetDistance() - cb_distance);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintAtomAttraction::GetSerializer() const
    {
      io::Serializer serializer;
      if( m_Scheme == GetDefaultScheme())
      {
        serializer.SetClassDescription
        (
          "A piecewise-continuous step-like score with a cosine transition region in place of the step."
        );
        serializer.AddInitializer
        (
          "start angstroms",
          "beginning of the transition region in angstroms representing target restraint distance between atoms - "
          "model's distance between atoms",
          io::Serialization::GetAgent( &m_WellPotential.GetTransitionBeginXAxis())
        );
        serializer.AddInitializer
        (
          "end angstroms",
          "end of the transition region in angstroms representing target restraint distance between atoms - "
          "model's distance between atoms",
          io::Serialization::GetAgent( &m_WellPotential.GetTransitionEndXAxis())
        );
        serializer.AddInitializer
        (
          "start score",
          "score for distances <= start angstroms",
          io::Serialization::GetAgent( &m_WellPotential.GetTransitionBeginYAxis())
        );
        serializer.AddInitializer
        (
          "end score",
          "score for distances >= end angstroms",
          io::Serialization::GetAgent( &m_WellPotential.GetTransitionEndYAxis())
        );
      }
      else
      {
        serializer.SetClassDescription
        (
          "An piecewise-continuous step-like score with a cosine transition region in place of the step.\n "
          "f(x) = " + m_WellPotential.AsString() + " where x is the target distance of the atoms in the restraint minus "
          "their actual distance in the current model"
        );
      }
      return serializer;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_atom_distance.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "restraint/bcl_restraint_atom_distance_assignment.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintAtomDistance::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "distance_restraint");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    RestraintAtomDistance::RestraintAtomDistance() :
      m_ScoringFunction(),
      m_FinalFraction( 1.0),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief construct from a scoring function and scheme
    //! @param SCORING_FUNCTION scoring function to be used
    //! @param FRACTION fraction of total restraints to be used for final score calculation
    //! @param SCHEME scheme to be used
    //! @param RESTRAINTS the restraints to use
    RestraintAtomDistance::RestraintAtomDistance
    (
      const RestraintAtomDistanceAssignment &SCORING_FUNCTION,
      const double &FRACTION,
      const std::string SCHEME,
      const util::ShPtr< Container> &RESTRAINTS
    ) :
      m_ScoringFunction( SCORING_FUNCTION),
      m_Restraints( RESTRAINTS),
      m_FinalFraction( FRACTION),
      m_Scheme( SCHEME)
    {
      BCL_Assert( m_FinalFraction <= 1.0 && m_FinalFraction >= 0.0, "Restraint fraction is not between zero and one.");
    }

    //! @brief Clone function
    //! @return pointer to new RestraintAtomDistance
    RestraintAtomDistance *RestraintAtomDistance::Clone() const
    {
      return new RestraintAtomDistance( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &RestraintAtomDistance::GetAlias() const
    {
      return this->GetScheme();
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintAtomDistance::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief () operator scores the protein model and associated restraints using the member scoring function
    //! @param PROTEIN_MODEL protein model to be scored
    //! @return distance restraint score
    double RestraintAtomDistance::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // initialize score
      double score( 0.0);

      // if no restraints were found
      if( !m_Restraints.IsDefined())
      {
        // return a score of 0
        BCL_MessageDbg( "No distance restraints found, not scoring the model");
        return score;
      }

      // calculate the number of restraints to consider
      const size_t nr_final_restraints( m_Restraints->GetSize() * m_FinalFraction);

      // if all restraints are requested
      if( m_FinalFraction == 1.0)
      {
        // iterate through the restraints
        for
        (
          Container::const_iterator restraint_itr( m_Restraints->Begin()), restraint_itr_end( m_Restraints->End());
          restraint_itr != restraint_itr_end; ++restraint_itr
        )
        {
          // score the assignment generated by the restraint multiplied by the restraint confidence
          double confidence = ( *restraint_itr)->GetConfidence();
          score += m_ScoringFunction->operator ()( ( *restraint_itr)->GenerateAssignment( PROTEIN_MODEL)) * confidence;
        }
      }
      else
      {
        // create vector to hold all scores
        storage::Vector< double> all_scores;

        // iterate through the restraints
        for
        (
          util::ShPtrVector< restraint::AtomDistance>::const_iterator restraint_itr( m_Restraints->Begin()),
            restraint_itr_end( m_Restraints->End());
          restraint_itr != restraint_itr_end; ++restraint_itr
        )
        {
          // score the assignment generated by the restraint multiplied by the restraint confidence
          double confidence = ( *restraint_itr)->GetConfidence();
          all_scores.PushBack( m_ScoringFunction->operator ()( ( *restraint_itr)->GenerateAssignment( PROTEIN_MODEL)) * confidence);
        }

        // sort the vector
        all_scores.Sort( std::less< double>());

        // iterate over number requested
        for( size_t i( 0); i != nr_final_restraints; ++i)
        {
          score += all_scores( i);
        }
      }

      const double average( score / double( m_Restraints->GetSize()));

      // iterate over the sequences to sum up the # of residues
      double nr_residues( 0.0);
      const util::SiPtrVector< const biol::AASequence> sequences( PROTEIN_MODEL.GetSequences());
      for
      (
        util::SiPtrVector< const biol::AASequence>::const_iterator seq_itr( sequences.Begin()),
          seq_itr_end( sequences.End());
        seq_itr != seq_itr_end; ++seq_itr
      )
      {
        nr_residues += ( *seq_itr)->GetSize();
      }

      // weight average by log(#restraints + 1) * (#AAs)
      return average * log10( double( nr_final_restraints + 1)) * nr_residues;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintAtomDistance::GetSerializer() const
    {
      io::Serializer serializer;
      const bool is_named_instance( m_Scheme != GetDefaultScheme());
      serializer.SetClassDescription
      (
        is_named_instance
        ? "A type of atom distance restraint. Scoring function info: " + m_ScoringFunction->GetCompleteSerializer().GetClassDescription()
        : "An atom distance restraint"
      );
      serializer.AddInitializer
      (
        "fraction",
        "Fraction of best restraints to consider during the score. All restraint scores are calculated, weighted by "
        "confidence, but only this fraction of the best satisfied restraints will be included in the final score",
        io::Serialization::GetAgentWithRange( &m_FinalFraction, 0.0, 1.0),
        is_named_instance ? util::Format()( m_FinalFraction) : "1.0"
      );
      if( !is_named_instance)
      {
        serializer.AddInitializer
        (
          "scoring function",
          "scoring function to use on each restraint",
          io::Serialization::GetAgent( &m_ScoringFunction)
        );
      }
      return serializer;
    }

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL protein model to be evaluated
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &RestraintAtomDistance::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      BCL_MessageDbg( "RestraintAtomDistance::WriteDetailedSchemeAndValues start");
      BCL_Assert( !PROTEIN_MODEL.GetProteinModelData()->GetKeys().IsEmpty(), "protein model data now is " + util::Format()( PROTEIN_MODEL.GetProteinModelData()->GetKeys()));
      // write the scheme of the scoring function used
      OSTREAM << m_ScoringFunction->GetScheme() << '\n';

      // if no restraints were found
      if( !m_Restraints.IsDefined())
      {
        return OSTREAM;
      }

      // initialize violated restraint counter
      size_t violated_restrants( 0);

      // iterate through the restraints
      for
      (
        util::ShPtrVector< restraint::AtomDistance>::const_iterator restraint_itr( m_Restraints->Begin()),
          restraint_itr_end( m_Restraints->End());
        restraint_itr != restraint_itr_end; ++restraint_itr
      )
      {
        // generate the assignment
        const restraint::AtomDistanceAssignment assignment( ( *restraint_itr)->GenerateAssignment( PROTEIN_MODEL));

        // get the score
        const double current_score( m_ScoringFunction->operator ()( assignment));

        // if the score is positive
        if( current_score >= 0.0)
        {
          // the restraint is violated so increment the counter
          ++violated_restrants;
        }

        // write the identification and score
        OSTREAM << ( *restraint_itr)->GetIdentification() << " : "
                << util::Format()( assignment.CalculateAtomDistance()) << '\t'
                << util::Format()( current_score) << '\n';
      }

      // write the # of violated restraints
      OSTREAM << "# violated : # total restraints: " << violated_restrants
              << " : " << m_Restraints->GetSize() << '\n';

      BCL_MessageDbg( "RestraintAtomDistance::WriteDetailedSchemeAndValues end");
      // end
      return OSTREAM;
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_body_protein_model.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "restraint/bcl_restraint_assignment.h"
#include "restraint/bcl_restraint_body.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> RestraintBodyProteinModel::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new RestraintBodyProteinModel())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    RestraintBodyProteinModel::RestraintBodyProteinModel() :
      m_Restraint(),
      m_Score()
    {
    }

    //! @brief construct from a ShPtrList of Restraints and a score object
    //! @param RESTRAINT is the ShPtrList of Restraints which will be "m_Restraint"
    //! @param SCORE is the FunctionInterface object which will be used to score the restraints of "m_Restraint"
    RestraintBodyProteinModel::RestraintBodyProteinModel
    (
      const util::ShPtr< util::ShPtrVector< restraint::Body> > &RESTRAINT,
      const BodyAssignment &SCORE
    ) :
      m_Restraint( RESTRAINT),
      m_Score( SCORE)
    {
    }

    //! @brief Clone is the virtual copy constructor
    RestraintBodyProteinModel *RestraintBodyProteinModel::Clone() const
    {
      return new RestraintBodyProteinModel( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintBodyProteinModel::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get scheme
    //! @return scheme
    const std::string &RestraintBodyProteinModel::GetScheme() const
    {
      return m_Score.GetScheme();
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &RestraintBodyProteinModel::GetAlias() const
    {
      static const std::string s_name( "RestraintBodyProteinModel");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintBodyProteinModel::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      (
        "scoring the agreement of restraint::Body with the coord::Bodies"
      );
      serializer.AddInitializer
      (
        "score",
        "used to score the agreement of the protein model with the body restraints m_Restraint",
        io::Serialization::GetAgent( &m_Score)
      );
      return serializer;
    }

  //////////////
  // operator //
  //////////////

    //! @brief operator() which takes an ProteinModel for calculating its agreement with the restraint::Body
    //! @param PROTEIN_MODEL the ProteinModel which will be scored for agreement with the restraint::Body
    //! @return return a double which is the score of the agreement of the ProteinModel with the restraint::Body
    double RestraintBodyProteinModel::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // create double "score" to hold the score of the t_Argument with the restraints
      double score( 0);
      // iterate through "m_Restraint"
      for
      (
        util::ShPtrVector< restraint::Body>::const_iterator itr( m_Restraint->Begin()), itr_end( m_Restraint->End());
        itr != itr_end;
        ++itr
      )
      {
        // add the score of the current assignment to "score"
        score += ScoreCurrent( **itr, PROTEIN_MODEL);
      }
      // return "score" which is the agreement of "ARGUMENT" with "m_Restraint"
      BCL_MessageDbg
      (
        " score::RestraintBodyProteinModel::operator() score: " + util::Format()( score) + "\n"
      );
      return score;
    }

    //! @brief ScoreCurrent gives the score the agreement of a ProteinModel with a Restraint
    //! @param RESTRAINT is the restraint which the proteinmodel is being score for agreement with
    //! @param PROTEIN_MODEL is the ProteinModel which is being scored for agreement with RESTRAINT
    //! @return returns a double which is the score of the agreement of PROTEIN_MODEL with RESTRAINT
    double RestraintBodyProteinModel::ScoreCurrent
    (
      const restraint::Body &RESTRAINT,
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      static const storage::Set< biol::SSType> s_sstypes( storage::Set< biol::SSType>( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND));
      return m_Score( RESTRAINT.GenerateAssignment( PROTEIN_MODEL.GetSSEs( s_sstypes)));
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &RestraintBodyProteinModel::Read( std::istream &ISTREAM)
    {
      // read in members
      io::Serialize::Read( m_Restraint, ISTREAM);
      io::Serialize::Read( m_Score, ISTREAM);

      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &RestraintBodyProteinModel::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Restraint, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Score, OSTREAM, INDENT);

      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_distance_epr.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_protein_model.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_histogram_2d.h"
#include "score/bcl_score_energy_distribution.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from a restraint set, histogram file, and scheme
    //! @param RESTRAINTS EPR restraints for scoring the protein model
    //! @param HISTOGRAM_FILENAME name of the histogram file used to interpolate the potential function
    //! @param SCHEME scheme of this score
    RestraintDistanceEPR::RestraintDistanceEPR
    (
      const util::ShPtrVector< restraint::AtomDistance> &RESTRAINTS,
      const std::string &HISTOGRAM_FILENAME,
      const std::string &SCHEME
    ) :
      m_Scheme( SCHEME),
      m_EnergyFunction( CreateEnergyFunction( HISTOGRAM_FILENAME)),
      m_Restraints( RESTRAINTS),
      m_NeighborCalculator
      (
        assemble::AANeighborListContainerGeneratorProteinModel::AANeighborListGenerator( 11.4, 0, true, false)
      ),
      m_ExposureCalculator()
    {
    }

    //! @brief returns a pointer to a new RestraintDistanceEPR
    //! @return pointer to a new RestraintDistanceEPR
    RestraintDistanceEPR *RestraintDistanceEPR::Clone() const
    {
      return new RestraintDistanceEPR( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &RestraintDistanceEPR::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the scheme of this score
    //! @return the scheme of this score
    const std::string &RestraintDistanceEPR::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief returns default file name where the statistics and in consequence the energy potentials are read from
    //! @return default file name where the statistics and in consequence the energy potentials are read from
    const std::string &RestraintDistanceEPR::GetDefaultHistogramFilename()
    {
      static const std::string s_default_histogram_filename( "sl-cb_distances_geom.histograms");
      return s_default_histogram_filename;
    }

    //! @brief returns the default scheme of this score
    //! @return the default scheme of this score
    const std::string &RestraintDistanceEPR::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "epr_distance_geom");
      return s_default_scheme;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief scores the agreement of a given protein model with distance measurements obtained from an EPR experiment
    //! @param PROTEIN_MODEL protein model for which to compute the agreement
    //! @return normalized agreement score with -1 being the best and 0 being the worst agreement
    double RestraintDistanceEPR::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // compute the exposure of the residues in the protein model
      const assemble::AANeighborListContainer neighbor_lists( ( *m_NeighborCalculator)( PROTEIN_MODEL));

      // sum up the energy scores for the restraints
      double sum_score( 0.0);
      for
      (
        util::ShPtrVector< restraint::AtomDistance>::const_iterator it( m_Restraints.Begin()), it_end( m_Restraints.End());
        it != it_end;
        ++it
      )
      {
        // get the restraint data
        const restraint::AtomDistance &restraint( **it);
        const double exp_distance( restraint.GetDistance()->GetDistance());
        const restraint::DataPairwise &data( restraint.GetData());
        const double model_distance( data.EuclidianDistance( PROTEIN_MODEL));

        // get the coordinates of the Ca and Cb atoms of the spin labeling sites
        const biol::AABase &aa_first( *data.First()->LocateAA( PROTEIN_MODEL));
        const biol::AABase &aa_second( *data.Second()->LocateAA( PROTEIN_MODEL));
        const biol::Atom &ca_first( aa_first.GetAtom( biol::GetAtomTypes().CA));
        const linal::Vector3D &ca_first_coord( ca_first.GetCoordinates());
        const linal::Vector3D &cb_first_coord( data.First()->Locate( PROTEIN_MODEL));
        const biol::Atom &ca_second( aa_second.GetAtom( biol::GetAtomTypes().CA));
        const linal::Vector3D &ca_second_coord( ca_second.GetCoordinates());
        const linal::Vector3D &cb_second_coord( data.Second()->Locate( PROTEIN_MODEL));

        // compute the projection angles between the CaCb and CaCa vectors of the spin labeling sites
        const double proj_first_cos( linal::ProjAngleCosinus( ca_first_coord, cb_first_coord, ca_second_coord));
        const double proj_second_cos( linal::ProjAngleCosinus( ca_second_coord, cb_second_coord, ca_first_coord));

        // compute the neighbor counts of the spin labeling sites
        const double nc_first( m_ExposureCalculator( neighbor_lists.Find( aa_first)->second));
        const double nc_second( m_ExposureCalculator( neighbor_lists.Find( aa_second)->second));

        // compute the energy score and add it to the sum score for all restraints
        const double aggregate( ( ( nc_first * proj_first_cos) + ( nc_second * proj_second_cos)) / 8.0);
        const double dsl_dbb( exp_distance - model_distance);
        const double score( ( *m_EnergyFunction)( aggregate, dsl_dbb));
        sum_score += score;
      }

      return sum_score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief reads in members from stream
    //! @param ISTREAM stream to read members from
    //! @return returns the input stream
    std::istream &RestraintDistanceEPR::Read( std::istream &ISTREAM)
    {
      // read members from input stream
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_EnergyFunction, ISTREAM);
      io::Serialize::Read( m_Restraints, ISTREAM);
      io::Serialize::Read( m_NeighborCalculator, ISTREAM);
      io::Serialize::Read( m_ExposureCalculator, ISTREAM);

      return ISTREAM;
    }

    //! @brief write members into a stream
    //! @param OSTREAM stream to write members into
    //! @INDENT number of indentations to use
    //! @return returns the output stream
    std::ostream &RestraintDistanceEPR::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members into output stream
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_EnergyFunction, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_Restraints, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_NeighborCalculator, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_ExposureCalculator, OSTREAM, INDENT);

      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief creates the energy function used to score the agreement of model with the EPR data from the given histogram
    //! @param HISTOGRAM_FILENAME histogram from which to create the energy function
    //! @return shared pointer to the energy function created from the given histogram
    util::ShPtr< math::BicubicSpline> RestraintDistanceEPR::CreateEnergyFunction( const std::string &HISTOGRAM_FILENAME)
    {
      // read in the histogram
      math::Histogram2D histogram;
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( HISTOGRAM_FILENAME));
      read >> histogram;
      io::File::CloseClearFStream( read);
      histogram.NormalizeRows();

      // create the energy function
      const math::Range< double> distance_range( -14.0, 14.0);
      util::ShPtr< math::BicubicSpline> sp_energy_function
      (
        new math::BicubicSpline( EnergyDistribution::EPRDistance( histogram, distance_range))
      );

      return sp_energy_function;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_distance_spin_label.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_file.h"
#include "score/bcl_score_energy_distribution.h"
#include "storage/bcl_storage_triplet.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> RestraintDistanceSpinLabel::s_Instance
    (
      util::Enumerated< RestraintAtomDistanceAssignment>::AddInstance( new RestraintDistanceSpinLabel())
    );

    // energy function with lower and upper bound
    storage::Triplet< math::CubicSplineDamped, double, double> RestraintDistanceSpinLabel::s_EnergyFunction;

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &RestraintDistanceSpinLabel::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "sl-cb_distances.histograms");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintDistanceSpinLabel::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "epr_distance");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Clone is the virtual copy constructor
    RestraintDistanceSpinLabel *RestraintDistanceSpinLabel::Clone() const
    {
      return new RestraintDistanceSpinLabel( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintDistanceSpinLabel::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator() which takes an Assignment for calculating the agreement of the Assignment with the distance
    //! @param ASSIGNMENT the assignment which contains the MovableInterfaces whose distance will be scored
    //! @return return a double which is the score of the agreement of the MovableInterfaces with the distance
    double RestraintDistanceSpinLabel::operator()
    (
      const restraint::AtomDistanceAssignment &ASSIGNMENT
    ) const
    {
      if( !ASSIGNMENT.GetAtomA().AllCoordinatesDefined() || !ASSIGNMENT.GetAtomB().AllCoordinatesDefined())
      {
        return double( 0);
      }

      return ScoreDistance( ASSIGNMENT.CalculateAtomDistance(), ASSIGNMENT.GetDistance());
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief ScoreDistance is the function which calculates the score a given distance should get
    //! @brief DISTANCE is the distance which will be scored - this is the distance from the protein model
    //! @brief RESTRAINT_DISTANCE is the distance that DISTANCE will be scored against
    //! @return returns the score of a distance of DISTANCE
    double RestraintDistanceSpinLabel::ScoreDistance
    (
      const double &DISTANCE, const double &RESTRAINT_DISTANCE
    ) const
    {
      // create cont double "sl_cb" and initialize with the difference between "RESTRAINT_DISTANCE" and "DISTANCE"
      double sl_cb( RESTRAINT_DISTANCE - DISTANCE);

      // create double "score" and initialize with the potential associated with "bin_number"
      const double score( GetEnergyFunction().First()( sl_cb));

      BCL_Message
      (
        util::Message::e_Verbose,
        "restraint: " + util::Format()( RESTRAINT_DISTANCE) + " actual: " + util::Format()( DISTANCE) +
        " difference: " + util::Format()( RESTRAINT_DISTANCE - DISTANCE) + " score: " + util::Format()( score)
      );

      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintDistanceSpinLabel::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      (
        "Knowledge-based energy function score for spin labels, histogram file is " + GetDefaultHistogramFilename()
      );
      return serializer;
    }

    //! @brief gets the energy function and lower and upper bounds
    //! @return the energy function and lower and upper bounds
    storage::Triplet< math::CubicSplineDamped, double, double> &RestraintDistanceSpinLabel::GetEnergyFunction()
    {
      // if the energy function has not been set
      if( s_EnergyFunction.First().GetXValues().IsEmpty())
      {
        // read in it
        s_EnergyFunction = ReadEnergyFunction();
      }

      // end
      return s_EnergyFunction;
    }

    //! @brief reads the energy function and lower and upper bounds
    //! @return the energy function and lower and upper bounds
    storage::Triplet< math::CubicSplineDamped, double, double> RestraintDistanceSpinLabel::ReadEnergyFunction()
    {
      // create Histogram "histogram" which will be used to hold the histogram of SL-CB distances
      math::Histogram histogram;

      // create IFStream "read"
      io::IFStream read;

      // open "read" and bind it to the histogram file containing SL-CB distances
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( GetDefaultHistogramFilename()));

      // read in from "read" into "histogram"
      read >> histogram;

      // close and clear read stream
      io::File::CloseClearFStream( read);

      const storage::VectorND< 2, double> boundaries( histogram.GetBoundaries());

      const size_t start_bin( histogram.GetIndexOfFirstInformationContainingBin() - 1);

      histogram.RemoveBinsBeforeIndex( start_bin);
      const double lower_bound( histogram.GetBoundaries().First());
      const size_t last_bin( histogram.GetIndexOfLastInformationContainingBin() + 1);
      histogram.RemoveBinsAfterIndex( last_bin);
      const double upper_bound( histogram.GetBoundaries().Second());

      return storage::Triplet< math::CubicSplineDamped, double, double>
      (
        EnergyDistribution::GeneratePotentialFromHistogram
        (
          histogram, 1000000, math::e_FirstDer, EnergyDistribution::GetDefaultFirstDerivative(), true, true
        ),
        lower_bound,
        upper_bound
      );
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_energy_well.h"

// includes from bcl - sorted alphabetically
#include "math/bcl_math_const_function.h"
#include "math/bcl_math_piecewise_function.h"
#include "math/bcl_math_quadratic_function.h"
#include "math/bcl_math_trigonometric_transition.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // enum //
  //////////

    //! @brief conversion to a string from a Type
    //! @param TYPE the type to get a string for
    //! @return a string representing that type
    const std::string &RestraintEnergyWell::GetTypeName( const RestraintEnergyWell::Type &TYPE)
    {
      static const std::string s_descriptors[] =
      {
        "NOE",
        "PRE",
        GetStaticClassName< Type>()
      };
      return s_descriptors[ size_t( TYPE)];
    }

  //////////
  // data //
  //////////

    //! default r1 value
    const double RestraintEnergyWell::s_DefaultROne( 0.0);

    //! distance between r1 and r2 as well as r3 and r4 for PRE calculations
    const double RestraintEnergyWell::s_PREPenaltyWidth( 15.0);

    //! initialize "s_WellDepth"
    const double RestraintEnergyWell::s_WellDepth( -1.0);

    //! score for a restraint with residues/atoms not found in the protein model
    const double RestraintEnergyWell::s_DefaultScore( 0.0);

    //! effective distance per bond
    const double RestraintEnergyWell::s_EffectiveDistancePerBond( 1.0);

    const util::SiPtr< const util::ObjectInterface> RestraintEnergyWell::s_PREInstance
    (
      util::Enumerated< RestraintAtomDistanceAssignment>::AddInstance( new RestraintEnergyWell( e_PRE))
    );
    const util::SiPtr< const util::ObjectInterface> RestraintEnergyWell::s_NOEInstance
    (
      util::Enumerated< RestraintAtomDistanceAssignment>::AddInstance( new RestraintEnergyWell( e_NOE))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    RestraintEnergyWell::RestraintEnergyWell() :
      m_KTwoValue( util::GetUndefinedDouble()),
      m_KThreeValue( util::GetUndefinedDouble()),
      m_Type( s_NumberTypes),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief constructor from well type
    RestraintEnergyWell::RestraintEnergyWell( const TypeEnum &WELL_TYPE) :
      m_KTwoValue( 1.0),
      m_KThreeValue( 1.0),
      m_Type( WELL_TYPE),
      m_Scheme( GetDefaultScheme() + "_" + WELL_TYPE.GetString())
    {
    }

    //! @brief parameter constructor
    //! @param K_TWO_VALUE the K value to be used if the x value falls within the second range
    //! @param K_THREE_VALUE the K value to be used if the x value falls within the fourth range
    //! @param WELL_TYPE type of energy well to be used
    //! @param SCHEME the short tag denoting this scoring function
    RestraintEnergyWell::RestraintEnergyWell
    (
      const double K_TWO_VALUE,
      const double K_THREE_VALUE,
      const TypeEnum &WELL_TYPE,
      const std::string &SCHEME
    ) :
      m_KTwoValue( K_TWO_VALUE),
      m_KThreeValue( K_THREE_VALUE),
      m_Type( WELL_TYPE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new RestraintEnergyWell
    RestraintEnergyWell *RestraintEnergyWell::Clone() const
    {
      return new RestraintEnergyWell( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintEnergyWell::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintEnergyWell::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "energy_well");

      // end
      return s_default_scheme;
    }

    //! @brief returns scheme being used
    //! @return scheme being used
    const std::string &RestraintEnergyWell::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief () operator scores protein model
    //! @param RESTRAINT restraint to be scored
    //! @return score
    double RestraintEnergyWell::operator()( const restraint::AtomDistanceAssignment &RESTRAINT) const
    {
      // calculate the distance
      const double cb_distance( RESTRAINT.CalculateAtomDistance());

      // if the calculated distance is undefined
      if( !util::IsDefined( cb_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      // get the bond distance from the CB
      const size_t bond_distance( GetTotalBondsFromCB( RESTRAINT));

      // if the bond distance is not defined
      if( !util::IsDefined( bond_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      // create a Piecewise Function
      const math::PiecewiseFunction noe_score_piecewise_function
      (
        GetPiecewiseFunction( RESTRAINT, bond_distance)
      );

      // return the piecewise function with the calculated NOE distance restraint score from BCL data -1 in order to
      // align it with the other three scoring functions
      return noe_score_piecewise_function( cb_distance) + s_WellDepth;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief create a PiecewiseFunction i.e. the scoring function specific to the current restraint distance
    //! @param RESTRAINT_DISTANCE gives the experimental data necessary for creating the function
    //! @param BOND_DISTANCE # of bonds from atoms in restraint to CB
    //! @return a PiecewiseFunction related to scoring NOEs
    math::PiecewiseFunction RestraintEnergyWell::GetPiecewiseFunction
    (
      const restraint::AtomDistanceAssignment &RESTRAINT_DISTANCE,
      const size_t BOND_DISTANCE
    ) const
    {
      // make sure the restraint type is defined
      BCL_Assert( m_Type != s_NumberTypes, "Energy well type must be defined");

      // initialize r-values
      double r_one;
      double r_two;
      double r_three;
      double r_four;

      // calculate the effective distance
      const double effective_distance( double( BOND_DISTANCE) * s_EffectiveDistancePerBond);

      // if the type is NOE
      if( m_Type == e_NOE)
      {
        // pull each necessary element from the parameters of ScoreDistance
        const double upper_bound( RESTRAINT_DISTANCE.GetUpperBound() + effective_distance);
        const double lower_bound( std::max( s_DefaultROne, RESTRAINT_DISTANCE.GetLowerBound() - effective_distance));
        const double exp_distance( RESTRAINT_DISTANCE.GetDistance() + effective_distance);

        r_one = std::min( s_DefaultROne, lower_bound - 0.1); // this is to make sure r_one and r_two are not the same
        r_two = lower_bound;
        r_three = exp_distance;
        r_four = std::max( exp_distance + 0.1, upper_bound); // this is to make sure r_three and r_four are not the same
      }
      // if the type is PRE
      else // if( m_Type == e_PRE)
      {
        // shift the bounds since the SL distance is usually longer than the CB distance
        const double upper_bound( RESTRAINT_DISTANCE.GetUpperBound() - effective_distance / 2.0);
        const double lower_bound
        (
          std::max( s_DefaultROne, RESTRAINT_DISTANCE.GetLowerBound() - effective_distance / 2.0)
        );

        r_one = lower_bound - s_PREPenaltyWidth;
        r_two = lower_bound;
        r_three = upper_bound;
        r_four = upper_bound + s_PREPenaltyWidth;
      }

      const double max( std::numeric_limits< double>::max());
      // assert that the r-values are consecutive
      BCL_Assert
      (
        r_one < r_two && r_two < r_three && r_three < r_four,
        "Energy well score r-values must be sequential: " + util::Format()( r_one) + ", " +
        util::Format()( r_two) + ", " + util::Format()( r_three) + ", " + util::Format()( r_four)
      );

      // use these parameters to construct the ranges necessary for the piecewise function
      const math::Range< double>
        range_a( math::RangeBorders::e_LeftOpen, -max, r_one, math::RangeBorders::e_RightOpen),
        range_b( math::RangeBorders::e_LeftClosed, r_one, r_two, math::RangeBorders::e_RightOpen),
        range_c( math::RangeBorders::e_LeftClosed, r_two, r_three, math::RangeBorders::e_RightOpen),
        range_d( math::RangeBorders::e_LeftClosed, r_three, r_four, math::RangeBorders::e_RightOpen),
        range_e( math::RangeBorders::e_LeftClosed, r_four, max, math::RangeBorders::e_RightOpen);

      // create the vectors needed for the Quadratic Functions
      // these are the x and y values of vertex of the two quadratic functions
      const storage::VectorND< 2, double> bound_two( r_two, 0.0);
      const storage::VectorND< 2, double> bound_three( r_three, 0.0);

      // create the functions
      const util::ShPtr< math::FunctionInterfaceSerializable< double, double> > function_c
      (
        new math::ConstFunction< double, double>( 0.0)
      );
      util::ShPtr< math::FunctionInterfaceSerializable< double, double> > function_a;
      util::ShPtr< math::FunctionInterfaceSerializable< double, double> > function_b;
      util::ShPtr< math::FunctionInterfaceSerializable< double, double> > function_d;
      util::ShPtr< math::FunctionInterfaceSerializable< double, double> > function_e;

      // if NOE
      if( m_Type == e_NOE)
      {
        // create Quadratic Functions so the Linear functions can be calculated
        const math::QuadraticFunction quad_a( bound_two, m_KTwoValue);
        const math::QuadraticFunction quad_e( bound_three, m_KThreeValue);

        // use parameters from ScoreDistance to construct the functions necessary for the piecewise function
        function_a = GetLinearFunction( quad_a, r_one);
        function_b = util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
          (
            new math::QuadraticFunction( bound_two, m_KTwoValue)
          );
        function_d = util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
          (
            new math::QuadraticFunction( bound_three, m_KThreeValue)
          );
        function_e = GetLinearFunction( quad_e, r_four);
      }
      // PRE
      else
      {
        // use cosine transition instead of quadratic
        function_a = util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
          (
            new math::ConstFunction< double, double>( 1.0)
          );
        function_b = util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
          (
            new math::TrigonometricTransition( r_one, bound_two.First(), 1.0, bound_two.Second())
          );
        function_d = util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
          (
            new math::TrigonometricTransition( bound_three.First(), r_four, bound_three.Second(), 1.0)
          );
        function_e = function_a;
      }

      // put the ranges and corresponding functions into pairs into a list
      storage::List
      <
        storage::Pair< math::Range< double>, util::ShPtr< math::FunctionInterfaceSerializable< double, double> > >
      > noe_score_list;
      noe_score_list.PushBack
      (
        storage::Pair
        <
          math::Range< double>, util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
        >( range_a, function_a)
      ),
      noe_score_list.PushBack
      (
        storage::Pair
        <
          math::Range< double>, util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
        >( range_b, function_b)
      ),
      noe_score_list.PushBack
      (
        storage::Pair
        <
          math::Range< double>, util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
        >( range_c, function_c)
      ),
      noe_score_list.PushBack
      (
        storage::Pair
        <
          math::Range< double>, util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
        >( range_d, function_d)
      ),
      noe_score_list.PushBack
      (
        storage::Pair
        <
          math::Range< double>, util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
        >( range_e, function_e)
      );

      // construct the piecewise function
      return math::PiecewiseFunction( noe_score_list);
    }

    //! @brief will provide the Linear functions needed for the piecewise function because the slope is the same as the
    //! preceding quadratic function
    //! @param QUADRATIC gives the quadratic function needed to find the slope from its derivative
    //! @param R_VALUE gives the value needed to determine the y-intercept of the linear function
    //! @return a function interface in a linear function form
    util::ShPtr< math::FunctionInterfaceSerializable< double, double> > RestraintEnergyWell::GetLinearFunction
    (
      const math::QuadraticFunction &QUADRATIC, const double R_VALUE
    )
    {
      // get the derivative of "QUADRATIC"
      const util::ShPtr< math::FunctionInterfaceSerializable< double, double> > derivative( QUADRATIC.GetDerivative());

      // use "derivative" to get the slope of "QUADRATIC" at "R_VALUE"
      const double slope( derivative->operator()( R_VALUE));

      // get the y_value of "QUADRATIC" at "R_VALUE"
      const double y_value( QUADRATIC( R_VALUE));

      // solve for the y-intercept and return the corresponding LinearFunction
      const double y_intercept( y_value - ( slope * R_VALUE));
      return util::ShPtr< math::FunctionInterfaceSerializable< double, double> >( new math::LinearFunction( slope, y_intercept));
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_nmr_distance_interface.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  /////////////////
  // data access //
  /////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief gets the sum of the number of bonds between each atom and the CB
    //! @param ASSIGNMENT AtomDistanceAssignment containing the two atoms
    //! @return the sum of the number of bonds between each atom and the CB
    size_t RestraintNMRDistanceInterface::GetTotalBondsFromCB( const restraint::AtomDistanceAssignment &ASSIGNMENT)
    {
      return GetBondsFromCB( ASSIGNMENT.GetAtomA().GetType()) + GetBondsFromCB( ASSIGNMENT.GetAtomB().GetType());
    }

    //! @brief gets the number of bonds from the cb for a given atom type, H and HA return 0 since their positions can
    //!        be determined
    //! @param ATOM_TYPE atom type
    //! @return the number of bonds from the cb for a given atom type
    size_t RestraintNMRDistanceInterface::GetBondsFromCB( const biol::AtomType &ATOM_TYPE)
    {
      // create static undefined distance
      static const size_t s_undefined_distance( util::GetUndefined< size_t>());

      // if the atom type is CB, H, or HA
      if
      (
        ATOM_TYPE == biol::GetAtomTypes().CB ||
        ATOM_TYPE == biol::GetAtomTypes().H ||
        ATOM_TYPE == biol::GetAtomTypes().HA ||
        ATOM_TYPE == biol::GetAtomTypes().HA2 ||
        ATOM_TYPE == biol::GetAtomTypes().HA3
      )
      {
        return 0;
      }

      // if this is a spin label
      if( ATOM_TYPE == biol::GetAtomTypes().O1)
      {
        return GetSpinLabelLength();
      }

      // if the atom is not a proton
      if( ATOM_TYPE->GetElementType() != chemistry::GetElementTypes().e_Hydrogen)
      {
        // return an undefined distance
        return s_undefined_distance;
      }

      // read in the second character to determine the side chain position (i.e. beta, gamma, delta, etc.)
      const char atom_pos( ATOM_TYPE.GetName()[ 1]);

      // initialize number of bonds between proton and CB
      size_t nr_bonds( s_undefined_distance);

      // use the atom_pos char to determine how many bonds away the proton is
      switch( atom_pos)
      {
        case 'A':
          nr_bonds = 2;
          break;
        case 'B':
          nr_bonds = 1;
          break;
        case 'G':
          nr_bonds = 2;
          break;
        case 'D':
          nr_bonds = 3;
          break;
        case 'E':
          nr_bonds = 4;
          break;
        case 'Z':
          nr_bonds = 5;
          break;
        case 'H':
          nr_bonds = 6;
          break;
        // proton position not determined so return distance will remain undefined
      }

      // end
      return nr_bonds;
    }

    //! @brief Gets the atom type (CB, H, or HA) from the given assignment
    //! @param RESTRAINT assignment containing the atoms
    //! @return the atom type
    biol::AtomType RestraintNMRDistanceInterface::GetAtomType( const restraint::AtomDistanceAssignment &RESTRAINT)
    {
      // store types
      const biol::AtomType &type_a( RESTRAINT.GetAtomA().GetType());
      const biol::AtomType &type_b( RESTRAINT.GetAtomB().GetType());

      if
      (
        type_a->GetElementType() == chemistry::GetElementTypes().e_Hydrogen
        || type_b->GetElementType() == chemistry::GetElementTypes().e_Hydrogen
      )
      {
        // if either atom type is H
        if( type_a == biol::GetAtomTypes().H || type_b == biol::GetAtomTypes().H)
        {
          return biol::GetAtomTypes().H;
        }

        // if either type is HA
        if
        (
          type_a == biol::GetAtomTypes().HA || type_a == biol::GetAtomTypes().HA2 || type_a == biol::GetAtomTypes().HA3 ||
          type_b == biol::GetAtomTypes().HA || type_b == biol::GetAtomTypes().HA2 || type_b == biol::GetAtomTypes().HA3
        )
        {
          return biol::GetAtomTypes().HA;
        }
      }

      // type is not H or HA so return CB
      return biol::GetAtomTypes().CB;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintNMRDistanceInterface::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      (
        " an NMR distance restraint score. "
        "Currently these are not enumerated, so there are no user-changeable parameters"
      );
      return serializer;
    }

    //! @brief Get the number of bonds that the spin label is from CB from the command line flag
    //! @return the number of bonds that the spin label is from CB from the command line flag
    size_t &RestraintNMRDistanceInterface::GetSpinLabelLength()
    {
      static size_t s_spin_label_length( 6);
      return s_spin_label_length;
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_noe_attraction.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_file.h"
#include "math/bcl_math_histogram.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // map of histogram data
    storage::Map
    <
      storage::Pair< biol::AtomType, size_t>,
      RestraintAtomAttraction
    > RestraintNoeAttraction::s_HistogramData;

    // initialize default score
    const double RestraintNoeAttraction::s_DefaultScore( 0.0);

    const util::SiPtr< const util::ObjectInterface> RestraintNoeAttraction::s_Instance
    (
      util::Enumerated< RestraintAtomDistanceAssignment>::AddInstance( new RestraintNoeAttraction())
    );

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &RestraintNoeAttraction::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "noe_knowledge_based.histogram");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintNoeAttraction::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "atom_attraction_noe");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Clone is the virtual copy constructor
    RestraintNoeAttraction *RestraintNoeAttraction::Clone() const
    {
      return new RestraintNoeAttraction( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintNoeAttraction::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the histograms
    //! @return the histograms
    const storage::Map
    <
      storage::Pair< biol::AtomType, size_t>,
      RestraintAtomAttraction
    > &RestraintNoeAttraction::GetNOEHistogram()
    {
      // read in the data if it is empty
      if( s_HistogramData.IsEmpty())
      {
        s_HistogramData = ReadNOEHistogram();
      }

      // end
      return s_HistogramData;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief () operator scores protein model
    //! @param RESTRAINT restraint to be scored
    //! @return score
    double RestraintNoeAttraction::operator()( const restraint::AtomDistanceAssignment &RESTRAINT) const
    {
      // calculate the distance
      const double cb_distance( RESTRAINT.CalculateAtomDistance());

      // if the calculated distance is undefined
      if( !util::IsDefined( cb_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      // get the bond distance
      const size_t bond_distance( GetTotalBondsFromCB( RESTRAINT));

      // if the bond distance is not defined
      if( !util::IsDefined( bond_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      // return the value calculated from the appropriate spline
      return GetNOEHistogram().GetValue
      (
        storage::Pair< biol::AtomType, size_t>( GetAtomType( RESTRAINT), bond_distance)
      )( RESTRAINT);
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief reads in the histograms with NOE distance statistics from the file
    //! @return the histograms
    storage::Map
    <
      storage::Pair< biol::AtomType, size_t>,
      RestraintAtomAttraction
    > RestraintNoeAttraction::ReadNOEHistogram()
    {
      // create IFStream "read"
      io::IFStream read;

      // open "read" and bind it to the histogram file containing SL-CB distances
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( GetDefaultHistogramFilename()));

      // initialize atom type
      biol::AtomType atom_type;

      // initialize map
      storage::Map
      <
        storage::Pair< biol::AtomType, size_t>,
        RestraintAtomAttraction
      > histograms;

      // iterate through the entire histogram
      while( read >> atom_type && !read.eof())
      {
        // break if undefined atom_type (end of file)
        if( atom_type == biol::GetAtomTypes().e_Undefined)
        {
          break;
        }

        // create an empty size_t for storing the bond distances
        size_t bond_distance;

        // read histogram
        math::Histogram histogram;
        read >> bond_distance >> histogram;

        // calculate spline and store in map
        histograms[ storage::Pair< biol::AtomType, size_t>( atom_type, bond_distance)] =
          RestraintAtomAttraction
          (
            RestraintAtomAttraction::GetDefaultDepthRange(),
            RestraintAtomAttraction::GetDefaultLeftEndWell( histogram),
            RestraintAtomAttraction::GetDefaultTransitionWidth(),
            true
          );
      }

      // close and clear read stream
      io::File::CloseClearFStream( read);

      // end
      return histograms;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_noe_knowledge_based.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_file.h"
#include "math/bcl_math_histogram.h"
#include "score/bcl_score_energy_distribution.h"
#include "score/bcl_score_restraint_atom_attraction.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
  //////////
  // data //
  //////////

    // map of histogram data
    storage::Map
    <
      storage::Pair< biol::AtomType, size_t>,           // type (CB, H, or HA) and number of bonds
      math::CubicSplineDamped   // cubic spline of histogram
    > RestraintNoeKnowledgeBased::s_HistogramData;

    // initialize default score
    const double RestraintNoeKnowledgeBased::s_DefaultScore( 0.0);

    const util::SiPtr< const util::ObjectInterface> RestraintNoeKnowledgeBased::s_Instance
    (
      util::Enumerated< RestraintAtomDistanceAssignment>::AddInstance( new RestraintNoeKnowledgeBased())
    );

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &RestraintNoeKnowledgeBased::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "noe_knowledge_based.histogram");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintNoeKnowledgeBased::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "noe_kb");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Clone is the virtual copy constructor
    RestraintNoeKnowledgeBased *RestraintNoeKnowledgeBased::Clone() const
    {
      return new RestraintNoeKnowledgeBased( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintNoeKnowledgeBased::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the histogram
    //! @return the histogram
    const storage::Map
    <
      storage::Pair< biol::AtomType, size_t>,
      math::CubicSplineDamped
    > &RestraintNoeKnowledgeBased::GetNOEHistogram()
    {
      // read in the data if it is empty
      if( s_HistogramData.IsEmpty())
      {
        s_HistogramData = ReadNOEHistogram();
      }

      // end
      return s_HistogramData;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief () operator scores protein model
    //! @param RESTRAINT restraint to be scored
    //! @return score
    double RestraintNoeKnowledgeBased::operator()( const restraint::AtomDistanceAssignment &RESTRAINT) const
    {
      // get the bond distance
      const size_t bond_distance( GetTotalBondsFromCB( RESTRAINT));

      // if the bond distance is not defined
      if( !util::IsDefined( bond_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      // if the bond distance is zero, possible w/ H-HA NOEs for example
      if( bond_distance == 0)
      {
        // create static atom attraction score
        static const RestraintAtomAttraction s_atom_attraction_score
        (
          RestraintAtomAttraction::GetDefaultDepthRange(), -0.5, 10, true
        );

        // score using atom attraction since a knowledge-based potential does not make sense in this case
        return s_atom_attraction_score( RESTRAINT);
      }

      // calculate the distance
      const double cb_distance( RESTRAINT.CalculateAtomDistance());

      // if the calculated distance is undefined
      if( !util::IsDefined( cb_distance))
      {
        // return default score
        return s_DefaultScore;
      }

      return GetNOEHistogram().GetValue
      (
        storage::Pair< biol::AtomType, size_t>( GetAtomType( RESTRAINT), bond_distance)
      )( RESTRAINT.GetDistance() - cb_distance);
    }

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief reads in the Histogram with NOE distance statistics from the file
    //! @return the histogram
    storage::Map
    <
      storage::Pair< biol::AtomType, size_t>,
      math::CubicSplineDamped
    > RestraintNoeKnowledgeBased::ReadNOEHistogram()
    {
      // create IFStream "read"
      io::IFStream read;

      // open "read" and bind it to the histogram file containing SL-CB distances
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( GetDefaultHistogramFilename()));

      // initialize atom type
      biol::AtomType atom_type;

      // initialize map
      storage::Map
      <
        storage::Pair< biol::AtomType, size_t>,
        math::CubicSplineDamped
      > histogram_data;

      // iterate through the entire histogram
      while( read >> atom_type && !read.eof())
      {
        // break if undefined atom_type (end of file)
        if( atom_type == biol::GetAtomTypes().e_Undefined)
        {
          break;
        }

        // create an empty size_t for storing the bond distances
        size_t bond_distance;

        // read histogram
        math::Histogram histogram;
        read >> bond_distance >> histogram;

        // calculate spline and store in map
        histogram_data[ storage::Pair< biol::AtomType, size_t>( atom_type, bond_distance)] =
          EnergyDistribution::GeneratePotentialFromHistogram
          (
            histogram, 100, math::e_FirstDer, EnergyDistribution::GetDefaultFirstDerivative(), true, true
          );
      }

      // close and clear read stream
      io::File::CloseClearFStream( read);

      // end
      return histogram_data;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "restraint/bcl_restraint_sas_experimental_and_calculated_density.h"

// includes from bcl - sorted alphabetically
#include "score/bcl_score_restraint_pofr.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> RestraintPofr::s_Instance
    (
      GetObjectInstances().AddInstance( new RestraintPofr())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintPofr::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "pofr_restraint");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    RestraintPofr::RestraintPofr() :
      m_Calc(),
      m_Score(),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief construct from member variables
    //! @param DATA_FROM_STRUCTURE_CALCULATOR function interface for calculating theoretical Saxs Curves
    //! @param DATA_AGREEMENT_CALCULATOR function interface for calculating a Saxs Curve agreement value
    //! @param SCHEME Scheme to be used
    RestraintPofr::RestraintPofr
    (
      const util::Implementation< restraint::SasPofRInterface> &POFR_IMPLEMENTATION,
      const PofR &SCORE,
      const std::string &SCHEME
    ) :
      m_Calc( POFR_IMPLEMENTATION),
      m_Score( SCORE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new RestraintPofr
    RestraintPofr *RestraintPofr::Clone() const
    {
      return new RestraintPofr( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintPofr::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &RestraintPofr::GetAlias() const
    {
      static const std::string s_Name( "ScorePofr");
      return s_Name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintPofr::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription
      (
        " Computes the difference between experimental SAS and computed density histograms"
      );
      return parameters;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator() which takes a ProteinModel for calculating its agreement with the Pofr Data
    //! @param PROTEIN_MODEL the ProteinModel which will be scored for agreement with the Pofr Data
    //! @return return a double which is the score of the agreement of the ProteinModel with the Pofr data
    double RestraintPofr::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      //BCL_Message( util::Message::e_Standard, "Inside Operator to compute profile and score agreement");

      // Compute the raw saxs profile
      // m_Calc contains the experimental data stored as a data member
      restraint::SasExperimentalAndCalculatedDensity raw_data( m_Calc->operator()( PROTEIN_MODEL));

      // calculate the score
      return m_Score( raw_data);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &RestraintPofr::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &RestraintPofr::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_restraint_residual_dipolar_coupling.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "io/bcl_io_serializer.h"
#include "nmr/bcl_nmr_rdc_container.h"
#include "restraint/bcl_restraint_rdc.h"
#include "restraint/bcl_restraint_rdc_assignment.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    const util::SiPtr< const util::ObjectInterface> RestraintResidualDipolarCoupling::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new RestraintResidualDipolarCoupling())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    RestraintResidualDipolarCoupling::RestraintResidualDipolarCoupling() :
      m_CalculatorOfRDCs(),
      m_RDCAgreementCalculator(),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief construct from member variables
    //! @param RDCS experimental rdcs
    //! @param RDC_FROM_STRUCTURE_CALCULATOR function interface for calculating theoretical RDCs
    //! @param RDC_AGREEMENT_CALCULATOR function interface for calculating an RDC agreement value
    //! @param SCHEME Scheme to be used
    RestraintResidualDipolarCoupling::RestraintResidualDipolarCoupling
    (
      const util::ShPtr< restraint::RDC> &RDCS,
      const math::FunctionInterfaceSerializable< restraint::RDCAssignment, nmr::RDCContainer> &RDC_FROM_STRUCTURE_CALCULATOR,
      const math::FunctionInterfaceSerializable< nmr::RDCContainer, double> &RDC_AGREEMENT_CALCULATOR,
      const std::string &SCHEME
    ) :
      m_CalculatorOfRDCs( RDC_FROM_STRUCTURE_CALCULATOR),
      m_RDCAgreementCalculator( RDC_AGREEMENT_CALCULATOR),
      m_RDCs( RDCS),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new RestraintResidualDipolarCoupling
    RestraintResidualDipolarCoupling *RestraintResidualDipolarCoupling::Clone() const
    {
      return new RestraintResidualDipolarCoupling( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &RestraintResidualDipolarCoupling::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintResidualDipolarCoupling::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "rdc_restraint");

      // end
      return s_default_scheme;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &RestraintResidualDipolarCoupling::GetAlias() const
    {
      static const std::string s_name( "RestraintResidualDipolarCoupling");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintResidualDipolarCoupling::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      (
        "Scores a protein model's agreement with residual dipolar coupling data"
      );
      serializer.AddInitializer
      (
        "calculator of RDCs",
        "Takes a list of assigned RDCs and calculates theoretical RDCs",
        io::Serialization::GetAgent( &m_CalculatorOfRDCs)
      );
      serializer.AddInitializer
      (
        "RDC agreement calculator",
        "takes a ResidualDipolarCouplingContainer and returns an agreement value",
        io::Serialization::GetAgent( &m_RDCAgreementCalculator)
      );
      return serializer;
    }
  ////////////////
  // operations //
  ////////////////

    //! @brief operator() which takes an ProteinModel for calculating its agreement with the RDC data
    //! @param PROTEIN_MODEL the ProteinModel which will be scored for agreement with the RDC data
    //! @return return a double which is the score of the agreement of the ProteinModel with the RDC data
    double RestraintResidualDipolarCoupling::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // if no restraints were found
      if( !m_RDCs.IsDefined())
      {
        // return a score of zero
        BCL_MessageStd( "No RDC restraints found, not scoring the model");
        return 0.0;
      }

      // calculate the RDCs and the score
      const double score
      (
        m_RDCAgreementCalculator->operator ()
        (
          m_CalculatorOfRDCs->operator ()( m_RDCs->GenerateAssignment( PROTEIN_MODEL))
        )
      );

      // weight score by log(#restraints + 1) * (#AAs)
      return score *
          log10( double( m_RDCs->GetData().GetSize() + 1)) *
          double( PROTEIN_MODEL.GetNumberAAs());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &RestraintResidualDipolarCoupling::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_RDCs, ISTREAM);
      io::Serialize::Read( m_CalculatorOfRDCs, ISTREAM);
      io::Serialize::Read( m_RDCAgreementCalculator, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return output stream which was written to
    std::ostream &RestraintResidualDipolarCoupling::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_RDCs, OSTREAM, INDENT);
      io::Serialize::Write( m_CalculatorOfRDCs, OSTREAM, INDENT);
      io::Serialize::Write( m_RDCAgreementCalculator, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write detailed scheme and values to OSTREAM
    //! @param PROTEIN_MODEL the ProteinModel which will be scored for agreement with the RDC data
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &RestraintResidualDipolarCoupling::WriteDetailedSchemeAndValues
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      std::ostream &OSTREAM
    ) const
    {
      // if no restraints were found
      if( !m_RDCs.IsDefined())
      {
        return OSTREAM;
      }

      // call the WriteDetailedSchemeAndValues from the agreement calculator
      return m_RDCAgreementCalculator->WriteDetailedSchemeAndValues
          (
            m_CalculatorOfRDCs->operator ()( m_RDCs->GenerateAssignment( PROTEIN_MODEL)),
            OSTREAM
          );
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "restraint/bcl_restraint_sas_transformation.h"
#include "score/bcl_score_restraint_saxs.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> RestraintSaxs::s_Instance
    (
      GetObjectInstances().AddInstance( new RestraintSaxs())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &RestraintSaxs::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "saxs_restraint");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    RestraintSaxs::RestraintSaxs() :
      m_Calc(),
      m_Score(),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief construct from member variables
    //! @param DATA_FROM_STRUCTURE_CALCULATOR function interface for calculating theoretical Saxs Curves
    //! @param DATA_AGREEMENT_CALCULATOR function interface for calculating a Saxs Curve agreement value
    //! @param SCHEME Scheme to be used
    RestraintSaxs::RestraintSaxs
    (
      const util::Implementation< restraint::SasDebyeInterface> &DEBYE_IMPLEMENTATION,
      const SasType &SCORE,
      const std::string &SCHEME
    ) :
      m_Calc( DEBYE_IMPLEMENTATION),
      m_Score( SCORE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new RestraintSaxs
    RestraintSaxs *RestraintSaxs::Clone() const
    {
      return new RestraintSaxs( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &RestraintSaxs::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &RestraintSaxs::GetAlias() const
    {
      static const std::string s_Name( "ScoreSaxs");
      return s_Name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintSaxs::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription
      (
        " Computes the score between two SAXS Profiles"
      );
      parameters.AddInitializer
      (
        "",
        "algorithm to calculate the saxs profile; opencl version will run on GPU, if available",
        io::Serialization::GetAgent( &m_Calc)
      );
      parameters.Merge( m_Score.GetSerializer());
      return parameters;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator() which takes a ProteinModel for calculating its agreement with the Saxs Data
    //! @param PROTEIN_MODEL the ProteinModel which will be scored for agreement with the Saxs Data
    //! @return return a double which is the score of the agreement of the ProteinModel with the Saxs data
    double RestraintSaxs::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // Compute the raw saxs profile
      restraint::SasExperimentalAndCalculatedData raw_data( m_Calc->operator()( PROTEIN_MODEL));

      // transform the profile into the desired form
      restraint::SasExperimentalAndCalculatedData transformed_data( restraint::SasTransformation()( raw_data));

      // calculate the score
      return m_Score( transformed_data);
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "math/bcl_math_const_function.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_serialization.h"
#include "io/bcl_io_serializer.h"
#include "math/bcl_math_trigonometric_transition.h"
#include "score/bcl_score_restraint_xlink.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {
    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> RestraintXlink::s_Instance
    (
      util::Enumerated< ProteinModel>::AddInstance( new RestraintXlink())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from default values
    RestraintXlink::RestraintXlink() :
      m_Scheme( GetDefaultScheme()),
      m_Restraints(),
      m_ROGCalculator(),
      m_ScoringFunction()
    {
    }

    //! @brief construct from a restraint set and scheme
    //! @param SP_RESTRAINTS shared pointer to the restraints obtained from a cross-linking experiment
    //! @param TRANSITION_LENGTH length of the transition region of the scoring function
    //! @param SCHEME scheme of this score
    RestraintXlink::RestraintXlink
    (
      const util::ShPtr< util::ShPtrVector< restraint::AtomDistance> > &SP_RESTRAINTS,
      double TRANSITION_LENGTH,
      const std::string &SCHEME
    ) :
      m_Scheme( SCHEME),
      m_Restraints( SP_RESTRAINTS),
      m_ROGCalculator(),
      m_TransitionLength( TRANSITION_LENGTH),
      m_ScoringFunction( CreateScoringFunction( m_TransitionLength))
    {
    }

    //! @brief returns a pointer to a new RestraintXlink
    //! @return pointer to a new RestraintXlink
    RestraintXlink *RestraintXlink::Clone() const
    {
      return new RestraintXlink( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &RestraintXlink::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the scheme of this score
    //! @return the scheme of this score
    const std::string &RestraintXlink::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief returns the default scheme of this score
    //! @return the default scheme of this score
    const std::string &RestraintXlink::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "xlink");
      return s_default_scheme;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &RestraintXlink::GetAlias() const
    {
      static const std::string s_name( "RestraintXlink");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer RestraintXlink::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      ( "scores the agreement of a protein model with cross-linking data");
      serializer.AddInitializer
      (
        "transition length",
        "The transition length used to call the scoring function",
        io::Serialization::GetAgent( &m_TransitionLength)
      );
      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief scores the agreement of a given protein model with data obtained from a cross-linking experiment
    //! @param PROTEIN_MODEL protein model for which to compute the agreement
    //! @return agreement score normalized for each restraint with -1 being the best and 0 being the worst agreement
    double RestraintXlink::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // sum up score for all restraints
      double sum_score( 0.0);
      for
      (
        util::ShPtrVector< restraint::AtomDistance>::const_iterator it( m_Restraints->Begin()),
        it_end( m_Restraints->End());
        it != it_end;
        ++it
      )
      {
        // get the relevant data for evaluating the agreement of the model with this cross-link
        const restraint::AtomDistance &restraint( **it);
        const double xl_length( restraint.GetDistance()->GetDistance());
        const util::SiPtr< const biol::Atom> sp_atom_first( restraint.GetData().First()->LocateAtom( PROTEIN_MODEL));
        const util::SiPtr< const biol::Atom> sp_atom_second( restraint.GetData().Second()->LocateAtom( PROTEIN_MODEL));

        // if the end points of the restraint are not in the model, skip it
        if( !sp_atom_first.IsDefined() || !sp_atom_second.IsDefined())
        {
          continue;
        }

        // compute the agreement of the protein model with the given cross-link
        const double score( ComputeAgreement( PROTEIN_MODEL, *sp_atom_first, *sp_atom_second, xl_length));
        sum_score += score;
      }

      return sum_score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief reads members from an input stream
    //! @param ISTREAM input stream to read members from
    //! @return the input stream
    std::istream &RestraintXlink::Read( std::istream &ISTREAM)
    {
      // read members from input stream
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_Restraints, ISTREAM);
      io::Serialize::Read( m_ROGCalculator, ISTREAM);
      io::Serialize::Read( m_TransitionLength, ISTREAM);
      io::Serialize::Read( m_ScoringFunction, ISTREAM);

      return ISTREAM;
    }

    //! @brief writes members into an output stream
    //! @param OSTREAM output stream to write members into
    //! @INDENT number of indentations to use
    //! @return the output stream
    std::ostream &RestraintXlink::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members into output stream
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_Restraints, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_ROGCalculator, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_TransitionLength, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_ScoringFunction, OSTREAM, INDENT);

      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief Set the members of this property from the given LABEL
    //! @param LABEL the label to parse
    //! @param ERR_STREAM stream to write out errors to
    bool RestraintXlink::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERR_STREAM
    )
    {
      m_ScoringFunction = CreateScoringFunction( m_TransitionLength);
      return true;
    }

    //! @brief computes the agreement of the given protein model with the cross-link between the given atoms
    //! @param PROTEIN_MODEL protein model to compute the agreement for
    //! @param ATOM_FIRST first end point of the cross-link
    //! @param ATOM_SECOND second end point of the cross-link
    //! @param XL_LENGTH length of the cross-linker
    //! @return agreement of the protein model with the given cross-link
    double RestraintXlink::ComputeAgreement
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      const biol::Atom &ATOM_FIRST,
      const biol::Atom &ATOM_SECOND,
      const double XL_LENGTH
    ) const
    {
      // compute opening angle defined by the end points of the cross-link
      const linal::Vector3D center( PROTEIN_MODEL.GetCenter());
      const linal::Vector3D cos_first( linal::UnitVector( center, ATOM_FIRST.GetCoordinates()));
      const linal::Vector3D cos_second( linal::UnitVector( center, ATOM_SECOND.GetCoordinates()));
      const double proj_angle( std::abs( linal::ProjAngle( cos_first, cos_second)));

      // approximate the distance that needs to be spanned by the cross-link by computing the perimeter of the circle
      const double radius( std::sqrt( m_ROGCalculator.SquareRadiusOfGyration( PROTEIN_MODEL)));
      const double perimeter( radius * proj_angle);
      const double length( perimeter);

      // evaluate the difference between cross-linker length and the length that must be spanned
      const double score( ( *m_ScoringFunction)( XL_LENGTH - length));

      return score;
    }

    //! @brief creates the function that scores the agreement of a protein model with cross-linking data
    //! @param TRANSITION_LENGTH length of the transition region
    //! @return shared pointer to the scoring function
    util::ShPtr< math::PiecewiseFunction> RestraintXlink::CreateScoringFunction( double TRANSITION_LENGTH)
    {
      // define the pieces of the function
      const math::Range< double> lower_range( -100.0, -TRANSITION_LENGTH / 2.0);
      const math::Range< double> trans_range
      (
        math::RangeBorders::e_LeftOpen,
        -TRANSITION_LENGTH / 2.0,
        TRANSITION_LENGTH / 2.0,
        math::RangeBorders::e_RightOpen
      );
      const math::Range< double> upper_range( TRANSITION_LENGTH / 2.0, 100.0);

      // define the function pieces
      const math::ConstFunction< double, double> lower_func( 0.0);
      const math::TrigonometricTransition trans_func( -TRANSITION_LENGTH / 2.0, TRANSITION_LENGTH / 2.0, 0.0, -1.0);
      const math::ConstFunction< double, double> upper_func( -1.0);

      // define the resulting function
      storage::List< storage::Pair< math::Range< double>, util::ShPtr< FunctionInterfaceSerializable< double, double> > > > args;
      args.Append
      (
        storage::Pair< math::Range< double>, util::ShPtr< FunctionInterfaceSerializable< double, double> > >
        (
          lower_range, util::CloneToShPtr( lower_func)
        )
      );
      args.Append
      (
        storage::Pair< math::Range< double>, util::ShPtr< FunctionInterfaceSerializable< double, double> > >
        (
          trans_range, util::CloneToShPtr( trans_func)
        )
      );
      args.Append
      (
        storage::Pair< math::Range< double>, util::ShPtr< FunctionInterfaceSerializable< double, double> > >
        (
          upper_range, util::CloneToShPtr( upper_func)
        )
      );
      util::ShPtr< math::PiecewiseFunction> sp_scoring_function( new math::PiecewiseFunction( args));

      return sp_scoring_function;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sas_type.h"

// includes from bcl - sorted alphabetically
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "command/bcl_command_parameter_check_allowed.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_statistics.h"
#include "restraint/bcl_restraint_sas_analysis.h"
#include "storage/bcl_storage_list.h"
#include "util/bcl_util_wrapper_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

    //! @brief ScoreFunction as string
    //! @param SCORE_FUNCTION the ScoreFunction
    //! @return the string for the ScoreFunction
    const std::string &SasType::GetFunctionDescriptor( const ScoreFunction &SCORE_FUNCTION)
    {
      static const std::string s_descriptors[] =
      {
        "chi",
        "cumulative",
        "stovgaard",
        GetStaticClassName< ScoreFunction>()
      };

      return s_descriptors[ SCORE_FUNCTION];
    }

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SasType::s_Instance
    (
      GetObjectInstances().AddInstance( new SasType())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Constructor
    SasType::SasType() : m_UseErrors( false), m_ScoreType( e_chi)
    {
    }

    //! @brief Alternative Constructor
    SasType::SasType( const bool &USE_ERRORS, const ScoreFunctionEnum &SCORE_TYPE)
    :
        m_UseErrors( USE_ERRORS),
        m_ScoreType( SCORE_TYPE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SasType
    SasType *SasType::Clone() const
    {
      return new SasType( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SasType::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief function to calculate the chi score for different SAXS intensity curves
    //! @param SAXS_DATA experimental and calculated saxs data
    //! @return derivative chi score
    double SasType::CalculateChiScore( const restraint::SasExperimentalAndCalculatedData &SAXS_DATA) const
    {
      return SAXS_DATA.ComputeScoringFunction( m_UseErrors);
    }

    //! @brief function to calculate cumulative integral score for different SAXS intensity curves
    //! @param SAXS_DATA experimental and calculated saxs data
    //! @return cumulative integral score
    double SasType::CalculateCumulativeIntegralScore
    (
      const restraint::SasExperimentalAndCalculatedData &SAXS_DATA
    ) const
    {
      // Convert the experimental intensity to list of doubles
      storage::List< double> experimental_intensity
      (
        restraint::SasAnalysis::ConvertIntensityDataToList( SAXS_DATA.GetExperimentalData())
      );

      // Convert the calculated intensity to list of doubles
      storage::List< double> calculated_intensity
      (
        restraint::SasAnalysis::ConvertIntensityDataToList( SAXS_DATA.GetCalculatedData())
      );

      // Calculate the Score
      double cumulative_score
      (
        math::Statistics::CumulativeEuclidian
        (
          experimental_intensity.Begin(),
          experimental_intensity.End(),
          calculated_intensity.Begin(),
          calculated_intensity.End()
        )
      );
      return cumulative_score;
    }

    //! @brief function to calculate Stovgaard score for different SAXS intensity curves
    //! @param SAXS_DATA experimental and calculated saxs data
    //! @return Stovgaard score
    double SasType::CalculateStovgaardScore( const restraint::SasExperimentalAndCalculatedData &SAXS_DATA) const
    {
      // initialize sum
      double summation( 0.0), alpha( 0.15), beta( 0.3);
      size_t qbins( 1);

      // iterate over experimental and calculated data to get values
      for
      (
        storage::Vector< restraint::SasScatteringPoint>::const_iterator
          exp_data_itr( SAXS_DATA.GetExperimentalData().Begin()),
          cal_data_itr( SAXS_DATA.GetCalculatedData().Begin()),
          exp_data_itr_end( SAXS_DATA.GetExperimentalData().End());
        exp_data_itr != exp_data_itr_end;
        ++exp_data_itr, ++cal_data_itr
      )
      {
        // if both I values are defined
        double sigma = exp_data_itr->GetIntensity() * ( exp_data_itr->GetQvalue() + alpha) * beta;

        // add to the sum
        summation += math::Sqr( ( exp_data_itr->GetIntensity() - cal_data_itr->GetIntensity()) / sigma);
        ++qbins;
      }

      return qbins == 1 ? 0.0 : math::Sqrt( summation / ( qbins - 1));
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief overloaded () operator to calculate Derivative Score or Cumulative Integral Score from two SAXS curves
    //! @param SAXS_DATA experimental and calculated saxs data
    //! @return return Derivative Score for two SAXS curves
    double SasType::operator()( const restraint::SasExperimentalAndCalculatedData &SAXS_DATA) const
    {

      double score( 0.0);

      switch( m_ScoreType)
      {
        case e_chi:
          score = CalculateChiScore( SAXS_DATA);
          break;
        case e_cumulative:
          score = CalculateCumulativeIntegralScore( SAXS_DATA);
          break;
        case e_stovgaard:
          score = CalculateStovgaardScore( SAXS_DATA);
          break;
        default:
          BCL_Assert( false, "Unknown scoring type - the accepted types are chi, cumulative, and stovgaard");
          break;

      }
      return score;
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &SasType::GetAlias() const
    {
      static const std::string s_name( "SasType");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer SasType::GetSerializer() const
    {
      io::Serializer serial;
      serial.SetClassDescription( "parameters for small angle x-ray/neutron scattering");
      serial.AddInitializer
      (
        "consider errors",
        "true to consider the amount of error in each measurement when computing rmsd",
        io::Serialization::GetAgent( &m_UseErrors),
        "False"
      );
      serial.AddInitializer
      (
        "score",
        "how to score differences between the profiles",
        io::Serialization::GetAgent( &m_ScoreType),
        GetFunctionDescriptor( SasType().GetScoreFunction())
      );
      return serial;
    }

  } // namespace score

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_scores.h"

// includes from bcl - sorted alphabetically
#include "fold/bcl_fold_default_scores.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> Scores::s_Instance
    (
      GetObjectInstances().AddInstance( new Scores())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    Scores::Scores()
    {
    }

    //! @brief copy constructor
    //! @return pointer to a new Scores
    Scores *Scores::Clone() const
    {
      return new Scores( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @returns single instance of this class
    //! @return single instance of this class
    Scores &Scores::GetInstance()
    {
      static Scores s_single_instance;
      return s_single_instance;
    }

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &Scores::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief initializes the mutates and adds them to the enumerator
    void Scores::Initialize()
    {
      // initialize scoring functions
      fold::DefaultScores::GetInstance().InitializeScores();
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief reads members from a given input stream
    //! @param ISTREAM input stream to read members from
    //! @return input stream which members were read from
    std::istream &Scores::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief writes members into a given output stream
    //! @param OSTREAM output stream to write members into
    //! @param INDENT number of indentations
    //! @return output stream into which members were written
    std::ostream &Scores::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_membrane_alignment.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "biol/bcl_biol_membrane.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_cubic_spline.h"
#include "math/bcl_math_histogram.h"
#include "score/bcl_score_energy_distribution.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &SSEMembraneAlignment::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "sse_membrane_alignment.histograms");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &SSEMembraneAlignment::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "ssealign");

      // end
      return s_default_scheme;

    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param SCHEME scheme to be used
    SSEMembraneAlignment::SSEMembraneAlignment
    (
      const std::string &HISTOGRAM_FILENAME,
      const std::string &SCHEME
    ) :
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_Scheme( SCHEME),
      m_EnergyFunctions()
    {
      // read the histogram file and store the energy functions
      ReadEnergyFunctions();
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new SSEMembraneAlignment object copied from this one
    SSEMembraneAlignment *SSEMembraneAlignment::Clone() const
    {
      return new SSEMembraneAlignment( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEMembraneAlignment::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &SSEMembraneAlignment::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief access energy functions
    //! @return map for each sstype, that has a map for each environmenttype with a cubic spline
    const storage::Map< biol::SSType, storage::Map< biol::EnvironmentType, math::CubicSplineDamped> > &
    SSEMembraneAlignment::GetEnergyFunctions() const
    {
      return m_EnergyFunctions;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &SSEMembraneAlignment::GetAlias() const
    {
      static const std::string s_name( "SSEMembraneAlignment");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer SSEMembraneAlignment::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Scores the alignment of transmembrane SSEs with the membrane normal.");
      serializer.AddInitializer
      (
        "histogram filename",
        "path to the histogram file that is used to construct the potential function",
        io::Serialization::GetAgent( &m_HistogramFileName)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculates the projection angle of the given SSE to the membrane plane
    //! @param SSE_GEOMETRY sse geometry derived class of interest
    //! @param AXIS membrane axis
    //! @param MEMBRANE membrane object
    //! @return calculated angle
    double SSEMembraneAlignment::AngleToMembranePlane
    (
      const assemble::SSEGeometryInterface &SSE_GEOMETRY,
      const coord::Axis &AXIS,
      const biol::Membrane &MEMBRANE
    )
    {
      return math::Absolute( linal::ProjAngle( MEMBRANE.GetNormal(), SSE_GEOMETRY.GetAxis( AXIS)) - math::g_Pi / 2.0);
    }

    //! @brief calculate weight for the given strand, that it is not turned in membrane
    //! @param STRAND sse geometry derived class of interest
    //! @param MEMBRANE membrane object
    //! @return calculated weight
    double SSEMembraneAlignment::WeightXAxis
    (
      const assemble::SSEGeometryInterface &STRAND,
      const biol::Membrane &MEMBRANE
    )
    {
      if( STRAND.GetType() == biol::GetSSTypes().HELIX)
      {
        return double( 1);
      }
      else if( STRAND.GetType() == biol::GetSSTypes().STRAND)
      {
        return math::WeightBetweenZeroAndPi_ThreeSections( AngleToMembranePlane( STRAND, coord::GetAxes().e_X, MEMBRANE) * 2.0);
      }
      else
      {
        return double( 0);
      }

      return util::GetUndefined< double>();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates the score for a given SSE
    //! @param SSE SSE of interest
    //! @param MEMBRANE membrane object
    //! @return score calculated for the given SSE
    storage::Pair< double, size_t> SSEMembraneAlignment::operator()
    (
      const assemble::SSE &SSE,
      const biol::Membrane &MEMBRANE
    ) const
    {
      // make sure it's helix or strand
      if( !SSE.GetType()->IsStructured())
      {
        return storage::Pair< double, size_t>( double( 0), 0);
      }

      // initialize score and count
      storage::Pair< double, size_t> score_count( 0.0, 0);

      // iterate over all fragments
      for
      (
        util::ShPtrVector< assemble::SSEGeometryInterface>::const_iterator frag_itr( SSE.GetFragments().Begin()),
          frag_itr_end( SSE.GetFragments().End());
        frag_itr != frag_itr_end;
        ++frag_itr
      )
      {
        // determine environment type and weight in gap
        const storage::Pair< biol::EnvironmentType, double> environment_weight
        (
          MEMBRANE.DetermineEnvironmentTypeAndWeight( ( *frag_itr)->GetCenter())
        );

        BCL_MessageDbg
        (
          "ssemembranealignment: " +
          environment_weight.First().GetName() + " " + ( *frag_itr)->GetIdentification() +
          " origin " + util::Format()( ( *frag_itr)->GetCenter())
        );

        const double angle_to_membrane_plane( AngleToMembranePlane( **frag_itr, coord::GetAxes().e_Z, MEMBRANE));
        double energy( 0);

        if( !environment_weight.First()->IsGap())
        {
          const storage::Map< biol::SSType, storage::Map< biol::EnvironmentType, math::CubicSplineDamped> >::const_iterator
            sse_type_itr
            (
              m_EnergyFunctions.Find
              (
                ( *frag_itr)->GetType()
              )
            );
          if( sse_type_itr == m_EnergyFunctions.End())
          {
            BCL_MessageDbg( "sse type not found in map of energy functions");
            continue;
          }
          const storage::Map< biol::EnvironmentType, math::CubicSplineDamped>::const_iterator environment_type_itr
          (
            sse_type_itr->second.Find( environment_weight.First())
          );

          if( environment_type_itr == sse_type_itr->second.End())
          {
            BCL_MessageDbg
            (
              "environment type " + environment_weight.First()->GetName() + " not found for ss type: " +
              sse_type_itr->first->GetName()
            );
            continue;
          }

          // calculate the energy
          energy = environment_type_itr->second( angle_to_membrane_plane);
        }
        else
        {
          // if it is a gap type, energy for adjacent env type have to be determined
          const biol::EnvironmentType env_type_left( environment_weight.First().GetIndex() - 1);
          const biol::EnvironmentType env_type_right( environment_weight.First().GetIndex() + 1);

          const double energy_left
          (
            m_EnergyFunctions.Find
            (
              ( *frag_itr)->GetType()
            )->second.Find( env_type_left)->second( angle_to_membrane_plane)
          );
          const double energy_right
          (
            m_EnergyFunctions.Find
            (
              ( *frag_itr)->GetType()
            )->second.Find( env_type_right)->second( angle_to_membrane_plane)
          );

          // weight the two energies depending on how close the z-coordinate is to left or right
          energy += energy_left * environment_weight.Second();
          energy += energy_right * ( 1.0 - environment_weight.Second());
        }

        // weight of the x axes orientation (necessary for strands)
        if( ( *frag_itr)->GetType() == biol::GetSSTypes().STRAND)
        {
          energy *= WeightXAxis( **frag_itr, MEMBRANE);
        }

        score_count.First() += energy;
        ++score_count.Second();
      }

      // energy and number of scored entities
      return score_count;
    }

    //! @brief Set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @param ERROR_STREAM stream with which to write errors
    //! @return return code indicating success or failure
    bool SSEMembraneAlignment::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
    {
      ReadEnergyFunctions();

      return true;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &SSEMembraneAlignment::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_HistogramFileName, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // read the histogram file and store the energy functions
      ReadEnergyFunctions();

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @return returns the output stream
    std::ostream &SSEMembraneAlignment::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_HistogramFileName, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param SSE SSE of interest
    //! @param MEMBRANE membrane object
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    SSEMembraneAlignment::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &SSE,
      const biol::Membrane &MEMBRANE,
      std::ostream &OSTREAM
    ) const
    {
      //write sstype, Angel to membrane plane first and last amino acid and value to the STREAM
      OSTREAM << SSE.GetType() << '\t'
              << AngleToMembranePlane( SSE, coord::GetAxes().e_Z, MEMBRANE) << '\t'
              << SSE.GetFirstAA()->GetSeqID() << '\t'
              << SSE.GetFirstAA()->GetType()->GetThreeLetterCode() << '\t'
              << SSE.GetLastAA()->GetSeqID() << '\t'
              << SSE.GetLastAA()->GetType()->GetThreeLetterCode() << '\t'
              << operator()( SSE, MEMBRANE).First() << '\n';

      //end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief read energy distribution for scoring sse membrane alignment
    void
    SSEMembraneAlignment::ReadEnergyFunctions()
    {
      // reset the energy functions
      m_EnergyFunctions.Reset();

      //initialize sstype, and vector to store the histograms read from the file
      storage::Map< biol::SSType, storage::Map< biol::EnvironmentType, math::Histogram> > sse_membrane_alignment;

      // initialize read
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      //read alignment histograms
      read >> sse_membrane_alignment;

      // reset stream
      io::File::CloseClearFStream( read);

      // iterate over two sstypes
      for
      (
        biol::SSTypes::const_iterator sstype_itr( biol::GetSSTypes().Begin()),
          sstype_itr_end( biol::GetSSTypes().COIL.GetIterator());
        sstype_itr != sstype_itr_end;
        ++sstype_itr
      )
      {
        // iterate over every environment and copy the counts
        for
        (
          biol::EnvironmentTypes::const_iterator env_itr( biol::GetEnvironmentTypes().GetReducedTypes().Begin()),
            env_itr_end( biol::GetEnvironmentTypes().GetReducedTypes().End());
          env_itr != env_itr_end; ++env_itr
        )
        {
          // calculate spline
          m_EnergyFunctions[ *sstype_itr][ *env_itr] =
            EnergyDistribution::AngleAlignmentPotential( sse_membrane_alignment[ *sstype_itr][ *env_itr]);

        } // env_itr
      } // sstype_itr
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_pair_angle_distance.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor - initialize with memory usage
    SSEPairAngleDistance::SSEPairAngleDistance() :
      m_SSEPackScoringFunction()
    {
    }

    //! @brief constructor from a SSEPackInterface
    //! @param SSE_PACK_INTERFACE reference to a SSEPackInterface derived class
    SSEPairAngleDistance::SSEPairAngleDistance( const SSEPackInterface &SSE_PACK_INTERFACE) :
      m_SSEPackScoringFunction( SSE_PACK_INTERFACE.Clone())
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new SSEPairAngleDistance copied from this one
    SSEPairAngleDistance *SSEPairAngleDistance::Clone() const
    {
      return new SSEPairAngleDistance( *this);
    }

    //! @brief destructor
    SSEPairAngleDistance::~SSEPairAngleDistance()
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPairAngleDistance::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &SSEPairAngleDistance::GetScheme() const
    {
      return m_SSEPackScoringFunction->GetScheme();
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &SSEPairAngleDistance::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSEPackScoringFunction, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &SSEPairAngleDistance::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSEPackScoringFunction, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    SSEPairAngleDistance::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B,
      std::ostream &OSTREAM
    ) const
    {

      // calculate the SSEPack
      const assemble::SSEGeometryPacking sse_pack
      (
        SSE_A, SSE_B, m_SSEPackScoringFunction->GetMinimalInterfaceLength()
      );

      // print SSE information
      // write sstype, Angel to membrane plane first and last aminoacid and value to the STREAM
      OSTREAM << SSE_A.GetIdentification() << '\t'
              << SSE_B.GetIdentification() << '\n';

      // now write the scheme for the scoring function scored
      return m_SSEPackScoringFunction->WriteDetailedSchemeAndValues( sse_pack, OSTREAM);
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_pair_clash.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &SSEPairClash::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "sseclash");

      // end
      return s_default_scheme;

    }

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEPairClash::s_Instance
    (
      util::Enumerated< SSEPackInterface>::AddInstance( new SSEPairClash)
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a SCHEME
    //! @param SIGMOID_WIDTH width of the sigmoid repulsive term, before it reaches 1.0
    //! @param SCHEME scheme to be used
    SSEPairClash::SSEPairClash
    (
      const double SIGMOID_WIDTH,
      const std::string &SCHEME
    ) :
      m_Scheme( SCHEME),
      m_MinimalInterfaceLength( 0.0),
      m_SigmoidWidth( SIGMOID_WIDTH)
    {
    }

    //! @brief virtual copy constructor
    SSEPairClash *SSEPairClash::Clone() const
    {
      return new SSEPairClash( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPairClash::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &SSEPairClash::GetAlias() const
    {
      static const std::string s_name( "SSEPairClash");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer SSEPairClash::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Evaluates clashes between SSEs.");
      serializer.AddInitializer
      (
        "min interface length",
        "minimum length of the interface between SSEs to receive full weight",
        io::Serialization::GetAgent( &m_MinimalInterfaceLength),
        "0.0"
      );
      serializer.AddInitializer
      (
        "sigmoid width",
        "width of the sigmoidal transition function",
        io::Serialization::GetAgent( &m_SigmoidWidth),
        "1.0"
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that score packing of a pair of SSEs of interest
    //! @param SSE_PACK SSEGeometryPacking of pair of SSEs of interest
    //! @return potential of interaction
    double SSEPairClash::operator()
    (
      const assemble::SSEGeometryPacking &SSE_PACK
    ) const
    {
      // if packing weight is small just return no score
      if( SSE_PACK.GetInteractionWeight() < std::numeric_limits< double>::epsilon())
      {
        return 0.0;
      }

      // store contact type
      const contact::Type contact_type( SSE_PACK.GetContactType());

      // switch over contact type
      // if UNKNOWN
      if( contact_type == contact::GetTypes().e_Undefined)
      {
        return 0.0;
      }
      // if HELIX_HELIX
      else if
      (
        contact_type == contact::GetTypes().HELIX_HELIX
      )
      {
        return
        (
          SSE_PACK.GetInteractionWeight() * SSE_PACK.GetRelativePositionWeight()
          *
          (
            CalculateRepulsiveTerm( SSE_PACK.GetDistance(), contact_type->GetMinimalSSEDistance())
          )
        );
      }
      // for any helix and strand (sheet) combination
      else if
      (
        contact_type == contact::GetTypes().HELIX_SHEET            ||
        contact_type == contact::GetTypes().SHEET_HELIX            ||
        contact_type == contact::GetTypes().UNDEFINED_HELIX_STRAND ||
        contact_type == contact::GetTypes().UNDEFINED_STRAND_HELIX ||
        contact_type == contact::GetTypes().HELIX_STRAND           ||
        contact_type == contact::GetTypes().STRAND_HELIX
      )
      {
        return
        (
          SSE_PACK.GetInteractionWeight() * SSE_PACK.GetRelativePositionWeight()
          *
          (
            CalculateRepulsiveTerm( SSE_PACK.GetDistance(), contact::GetTypes().HELIX_SHEET->GetMinimalSSEDistance())
          )
          +
          SSE_PACK.GetInteractionWeight() * ( 1.0 - SSE_PACK.GetRelativePositionWeight())
          *
          (
            CalculateRepulsiveTerm( SSE_PACK.GetDistance(), contact::GetTypes().HELIX_STRAND->GetMinimalSSEDistance())
          )
        );
      }
      // if strand strand related contact type
      else if
      (
        contact_type == contact::GetTypes().STRAND_STRAND ||
        contact_type == contact::GetTypes().SHEET_SHEET   ||
        contact_type == contact::GetTypes().UNDEFINED_STRAND_STRAND
      )
      {
        // apply transition function
        return
        (
          SSE_PACK.GetInteractionWeight() * SSE_PACK.GetRelativePositionWeight()
          *
          (
            CalculateRepulsiveTerm( SSE_PACK.GetDistance(), contact::GetTypes().SHEET_SHEET->GetMinimalSSEDistance())
          )
          +
          SSE_PACK.GetInteractionWeight() * SSE_PACK.GetStrandStrandPairingWeight()
          *
          (
            CalculateRepulsiveTerm( SSE_PACK.GetDistance(), contact::GetTypes().STRAND_STRAND->GetMinimalSSEDistance())
          )
        );
      }
      // if none above
      else
      {
        return util::GetUndefined< double>();
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &SSEPairClash::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_MinimalInterfaceLength, ISTREAM);
      io::Serialize::Read( m_SigmoidWidth, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &SSEPairClash::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MinimalInterfaceLength, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SigmoidWidth, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param SSE_PACK SSEGeometryPacking of pair of SSEs of interest
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &SSEPairClash::WriteDetailedSchemeAndValues
    (
      const assemble::SSEGeometryPacking &SSE_PACK,
      std::ostream &OSTREAM
    ) const
    {
      //write sstype, Angle to membrane plane to the STREAM
      OSTREAM << SSE_PACK.GetContactType().GetName() << '\t'
              << SSE_PACK.GetInteractionWeight() << '\t'
              << math::Angle::Degree( SSE_PACK.GetRelativePosition()) << '\t'
              << SSE_PACK.GetRelativePositionWeight() << '\t'
              << SSE_PACK.GetDistance() << '\t'
              << math::Angle::Degree( SSE_PACK.GetTwistAngle()) << '\t'
              << operator()( SSE_PACK) << '\n';

      //end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief repulsive term from distance and shortest observed distance
    //! @param DISTANCE the actual distance between sses of interest
    //! @param SHORTEST_OBSERVED_DISTANCE shortest distance observed
    double SSEPairClash::CalculateRepulsiveTerm
    (
      const double DISTANCE,
      const double SHORTEST_OBSERVED_DISTANCE
    ) const
    {
      const double difference( SHORTEST_OBSERVED_DISTANCE - DISTANCE);

      // no repulsion
      if( difference <= 0.0)
      {
        return 0.0;
      }
      // full repulsion
      else if( difference >= m_SigmoidWidth)
      {
        return 1.0;
      }

      return math::WeightBetweenZeroAndPi( ( ( m_SigmoidWidth - difference) / m_SigmoidWidth) * math::g_Pi);
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_pair_connectivity.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "biol/bcl_biol_atom.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPairConnectivity::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEPairConnectivity())
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &SSEPairConnectivity::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "sse_connectivity");

      // end
      return s_default_scheme;
    }

    //! @brief GetExtendedResidueLength gives the length a completely extended residue can cover
    //! @return the length a completely extended residue can cover
    const double &SSEPairConnectivity::GetExtendedResidueLength()
    {
      // the length of an extended residue
      static const double s_extended_residue_length( biol::GetSSTypes().STRAND->GetRiseInZPerResidue());

      return s_extended_residue_length;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a scheme
    //! @param SCHEME Scheme to be used
    SSEPairConnectivity::SSEPairConnectivity
    (
      const std::string &SCHEME
    ) :
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEPairConnectivity
    SSEPairConnectivity *SSEPairConnectivity::Clone() const
    {
      return new SSEPairConnectivity( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPairConnectivity::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &SSEPairConnectivity::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief gives the score for two sses based on how close they are to being connected, if they are adjecent
    //! @param SSE_A the first sse whose closeness to being peptide bonded to the second sse will be scored
    //! @param SSE_B the second sse whose closeness to being peptide bonded to the first sse will be scored
    //! @return the score for two sses based on how close SSE_A and SSE_B are to being connected by a peptide bond
    double SSEPairConnectivity::operator()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      // message which sses are currently being used to calculate connectivity score
      BCL_MessageDbg
      (
        "CalculateConnectivityScore for sse " + SSE_A.GetIdentification() + " and " +
        SSE_B.GetIdentification()
      );

      const size_t sequence_separation( biol::SequenceSeparation( *SSE_A.GetLastAA(), *SSE_B.GetFirstAA()));

      if( !util::IsDefined( sequence_separation))
      {
        return 0.0;
      }

      // calculate how far away the C atom of the last residue of SSE_A is from the N atom of the first residue of SSE_B
      const double c_n_distance
      (
        linal::Distance
        (
          SSE_A.GetLastAA()->GetAtom( biol::GetAtomTypes().C).GetCoordinates(),
          SSE_B.GetFirstAA()->GetAtom( biol::GetAtomTypes().N).GetCoordinates()
        )
      );

      // check if distance is defined
      if( !util::IsDefined( c_n_distance))
      {
        return 0.0;
      }

      // peptide bond length
      static const double s_peptide_bond_length( biol::GetAtomTypes().C->GetBondLength( biol::GetAtomTypes().N) * 1.02);

      // difference of actual distance to maximal distance that could be bridged
      const double safety( c_n_distance - ( sequence_separation * GetExtendedResidueLength() + s_peptide_bond_length));

      // if there is safety margin, return no penalty
      if( safety < 0)
      {
        return 0.0;
      }
      // saftey is crossed; return square as penalty
      else
      {
        return math::Sqr( safety);
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPairConnectivity::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPairConnectivity::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief write the Scheme and the Function value for the ARGUMENT to the STREAM
    //! @param SSE_A the first sse whose closeness to being peptide bonded to the second sse will be scored
    //! @param SSE_B the second sse whose closeness to being peptide bonded to the first sse will be scored
    //! @return std::ostream which was written to
    std::ostream &
    SSEPairConnectivity::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &SSE_A, const assemble::SSE &SSE_B,
      std::ostream &OSTREAM
    ) const
    {
      // write the detailed values and score
      OSTREAM << SSE_A.GetIdentification() << '\t' << SSE_B.GetIdentification() << '\t'
              << operator()( SSE_A, SSE_B) << '\n';

      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_pair_contact.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "math/bcl_math_binary_sum_function.h"
#include "score/bcl_score_aa_pair_contact.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEPairContact::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEPairContact())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEPairContact::SSEPairContact()
    {
    }

    //! @brief constructor with a prediction map
    //! @param SP_PREDICTION_MAP ShPtr to PredictionMap to be used
    SSEPairContact::SSEPairContact( const util::ShPtr< contact::PredictionMap> &SP_PREDICTION_MAP) :
      m_ScoringFunctions( contact::Types::s_NumberValidTypes)
    {

      // constructor the scoring function for HELIX_HELIX
      m_ScoringFunctions( contact::GetTypes().HELIX_HELIX) =
        util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
        (
          new AAPairContact( contact::GetTypes().HELIX_HELIX,   SP_PREDICTION_MAP)
        );

      // constructor the scoring function for HELIX_SHEET
      m_ScoringFunctions( contact::GetTypes().HELIX_SHEET) =
        util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
        (
          new AAPairContact( contact::GetTypes().HELIX_SHEET, SP_PREDICTION_MAP)
        );

      // constructor the scoring function for SHEET_HELIX
      m_ScoringFunctions( contact::GetTypes().SHEET_HELIX) =
        util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
        (
          new AAPairContact( contact::GetTypes().SHEET_HELIX, SP_PREDICTION_MAP)
        );

      // constructor the scoring function for STRAND_STRAND
      m_ScoringFunctions( contact::GetTypes().STRAND_STRAND) =
        util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
        (
          new AAPairContact( contact::GetTypes().STRAND_STRAND, SP_PREDICTION_MAP)
        );

      // constructor the scoring function for SHEET_SHEET
      m_ScoringFunctions( contact::GetTypes().SHEET_SHEET) =
        util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
        (
          new AAPairContact( contact::GetTypes().SHEET_SHEET,   SP_PREDICTION_MAP)
        );
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new SSEPairContact copied from this one
    SSEPairContact *SSEPairContact::Clone() const
    {
      return new SSEPairContact( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPairContact::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &SSEPairContact::GetScheme() const
    {
      // initialize static string to store scheme
      static const std::string s_scheme( "ssecont");
      return s_scheme;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculate the score for the given SSE pair
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @return the score for the given SSE pair
    double SSEPairContact::operator()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      BCL_MessageDbg( "score sse pair contact");

      // Retrieve Contacttype and distance_angleX_angleZ of these two SSEs
      const assemble::SSEGeometryPacking ssepack( SSE_A, SSE_B);

      // util::ShPtr to function which will be assigned according to the contact type and the relative position of
      // the two sses to each other
      util::ShPtr
      <
        math::BinaryFunctionInterface< biol::AABase, biol::AABase, double>
      > merged_scoring;

      // store contact type
      contact::Type contact_type( ssepack.GetContactType());

      // switch over contact type
      // if UNKNOWN
      if( contact_type == contact::GetTypes().e_Undefined)
      {
        return 0.0;
      }
      // if HELIX_HELIX, HELIX_SHEET, SHEET_HELIX or STRAND_STRAND
      else if
      (
        contact_type == contact::GetTypes().HELIX_HELIX  ||
        contact_type == contact::GetTypes().HELIX_SHEET ||
        contact_type == contact::GetTypes().SHEET_HELIX ||
        contact_type == contact::GetTypes().STRAND_STRAND
      )
      {
        merged_scoring = m_ScoringFunctions( ssepack.GetContactType());
      }
      // if UNDEFINED_HELIX_STRAND
      else if( contact_type == contact::GetTypes().UNDEFINED_HELIX_STRAND)
      {
        merged_scoring =
          util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
          (
            (
              ( *m_ScoringFunctions( contact::GetTypes().HELIX_SHEET)) *
              math::WeightBetweenZeroAndPi_ThreeSections( ssepack.GetRelativePosition() * 2)
            ).Clone()
          );
      }
      // if UNDEFINED_STRAND_HELIX
      else if( contact_type == contact::GetTypes().UNDEFINED_STRAND_HELIX)
      {
        merged_scoring =
          util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
          (
            (
              ( *m_ScoringFunctions( contact::GetTypes().SHEET_HELIX)) *
              math::WeightBetweenZeroAndPi_ThreeSections( ssepack.GetRelativePosition() * 2)
            ).Clone()
          );
      }
      // if SHEET_SHEET
      else if( contact_type == contact::GetTypes().SHEET_SHEET)
      {
        merged_scoring = m_ScoringFunctions( contact::GetTypes().SHEET_SHEET);
      }
      // if UNDEFINED_STRAND_STRAND
      else if( contact_type == contact::GetTypes().UNDEFINED_STRAND_STRAND)
      {
        // calculate the weight
        const double weight( math::WeightBetweenZeroAndPi_ThreeSections( ssepack.GetRelativePosition()));

        merged_scoring =
          util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
          (
            (
              weight * ( *m_ScoringFunctions( contact::GetTypes().SHEET_SHEET)) +
              ( 1 - weight) * ( *m_ScoringFunctions( contact::GetTypes().STRAND_STRAND))
            ).Clone()
          );
      }
      // if none above
      else
      {
        BCL_MessageCrt( "undefined contacttype has been found");
        return util::GetUndefined< double>();
      }

      double score( 0);

      // iterate over every residue in first SSE against every residue in the other SSE
      for
      (
        biol::AASequence::const_iterator
          aa_itr_a( SSE_A.GetData().Begin()),
          aa_itr_a_end( SSE_A.GetData().End());
        aa_itr_a != aa_itr_a_end; ++aa_itr_a
      )
      {
        for
        (
          biol::AASequence::const_iterator
            aa_itr_b( SSE_B.GetData().Begin()),
            aa_itr_b_end( SSE_B.GetData().End());
          aa_itr_b != aa_itr_b_end; ++aa_itr_b
        )
        {
          // and sum over the scores
          score += merged_scoring->operator()( **aa_itr_a, **aa_itr_b);
        }
      }

      // return the total score times the interaction weight if the packing is not optimal (orthogonal)
      return ssepack.GetInteractionWeight() * score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &SSEPairContact::Read( std::istream &ISTREAM)
    {
      // read members
      ISTREAM >> m_ScoringFunctions;

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &SSEPairContact::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      OSTREAM << m_ScoringFunctions;

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &SSEPairContact::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B,
      std::ostream &OSTREAM
    ) const
    {
      // Retrieve Contacttype and distance_angleX_angleZ of these two SSEs
      const assemble::SSEGeometryPacking ssepack( SSE_A, SSE_B);

      //util::ShPtr to function which will be assigned according to the contacttype and the relative position of the two sses to each other
      util::ShPtr
      <
        math::BinaryFunctionInterface< biol::AABase, biol::AABase, double>
      > merged_scoring;

      // store contact type
      contact::Type contact_type( ssepack.GetContactType());

      // switch over contact type
      // if UNKNOWN
      if( contact_type == contact::GetTypes().e_Undefined)
      {
        return OSTREAM;
      }
      // if HELIX_HELIX, HELIX_SHEET, SHEET_HELIX or STRAND_STRAND
      else if
      (
        contact_type == contact::GetTypes().HELIX_HELIX  ||
        contact_type == contact::GetTypes().HELIX_SHEET ||
        contact_type == contact::GetTypes().SHEET_HELIX ||
        contact_type == contact::GetTypes().STRAND_STRAND
      )
      {
        merged_scoring = m_ScoringFunctions( ssepack.GetContactType());
      }
      // if UNDEFINED_HELIX_STRAND
      else if( contact_type == contact::GetTypes().UNDEFINED_HELIX_STRAND)
      {
        merged_scoring
          = util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
            (
              (
                ( *m_ScoringFunctions( contact::GetTypes().HELIX_SHEET))
                * math::WeightBetweenZeroAndPi_ThreeSections( ssepack.GetRelativePosition() * 2)
              ).Clone()
            );
      }
      // if UNDEFINED_STRAND_HELIX
      else if( contact_type == contact::GetTypes().UNDEFINED_STRAND_HELIX)
      {
        merged_scoring
          = util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
            (
              (
                ( *m_ScoringFunctions( contact::GetTypes().SHEET_HELIX))
                * math::WeightBetweenZeroAndPi_ThreeSections( ssepack.GetRelativePosition() * 2)
              ).Clone()
            );
      }
      // if UNDEFINED_STRAND_HELIX
      else if( contact_type == contact::GetTypes().SHEET_SHEET)
      {
        merged_scoring = m_ScoringFunctions( contact::GetTypes().SHEET_SHEET);
      }
      // if UNDEFINED_STRAND_HELIX
      else if( contact_type == contact::GetTypes().UNDEFINED_STRAND_STRAND)
      {
        const double weight( math::WeightBetweenZeroAndPi_ThreeSections( ssepack.GetRelativePosition()));
        merged_scoring
          = util::ShPtr< math::BinaryFunctionInterface< biol::AABase, biol::AABase, double> >
            (
              (
                weight * ( *m_ScoringFunctions( contact::GetTypes().SHEET_SHEET)) + ( 1 - weight)
                * ( *m_ScoringFunctions( contact::GetTypes().STRAND_STRAND))
              ).Clone()
            );
      }
      // if none above
      else
      {
        BCL_MessageCrt( "undefined contacttype has been found");
        return OSTREAM;
      }

      //iterate over all pairs of SSElements
      for
      (
        biol::AASequence::const_iterator
          aa_itr_a( SSE_A.GetData().Begin()),
          aa_itr_a_end( SSE_A.GetData().End());
        aa_itr_a != aa_itr_a_end; ++aa_itr_a
      )
      {
        for
        (
          biol::AASequence::const_iterator
            aa_itr_b( SSE_B.GetData().Begin()),
            aa_itr_b_end( SSE_B.GetData().End());
          aa_itr_b != aa_itr_b_end;
          ++aa_itr_b
        )
        {
          merged_scoring->WriteDetailedSchemeAndValues( **aa_itr_a, **aa_itr_b, OSTREAM);
        }
      }

      //end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl

// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_pair_gap.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "io/bcl_io_serialization.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPairGap::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEPairGap( 0.0))
    );

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &SSEPairGap::GetDefaultScheme()
    {
      static const std::string s_scheme( "sse_pair_gap");
      return s_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a scheme
    //! @param NON_COIL_PENALTY additional penalty to add, if the ss type is not COIL
    //! @param SCHEME Scheme to be used
    SSEPairGap::SSEPairGap
    (
      const double NON_COIL_PENALTY,
      const std::string &SCHEME
    ) :
      m_Scheme( SCHEME),
      m_NonCoilPenalty( NON_COIL_PENALTY)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEPairGap
    SSEPairGap *SSEPairGap::Clone() const
    {
      return new SSEPairGap( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPairGap::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &SSEPairGap::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &SSEPairGap::GetAlias() const
    {
      static const std::string s_name( "SSEPairGap");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer SSEPairGap::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Returns the number of residues between two SSEs as penalty.");
      serializer.AddInitializer
      (
        "non coil penalty",
        "penalty if both ends are not coils",
        io::Serialization::GetAgent( &m_NonCoilPenalty)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief gives the score for two sses based on how close they are to being connected, if they are adjecent
    //! @param SSE_A the first sse whose closeness to being peptide bonded to the second sse will be scored
    //! @param SSE_B the second sse whose closeness to being peptide bonded to the first sse will be scored
    //! @return the score for two sses based on how close SSE_A and SSE_B are to being connected by a peptide bond
    double SSEPairGap::operator()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      size_t sequence_separation( biol::SequenceSeparation( *SSE_A.GetLastAA(), *SSE_B.GetFirstAA()));

      // no gap, score is zero
      if( !util::IsDefined( sequence_separation) || sequence_separation == 0)
      {
        return 0.0;
      }

      // score is proportinal to sequence separation
      double score( sequence_separation);

      // gap between structured sses is penalized more
      score += SSE_A.GetType()->IsStructured() * m_NonCoilPenalty;
      score += SSE_B.GetType()->IsStructured() * m_NonCoilPenalty;

      BCL_MessageDbg
      (
        "gap score between structured SSEs: |" + SSE_A.GetIdentification() + '|' + SSE_B.GetIdentification() + '|' +
        util::Format()( score)
      );

      return double( score);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPairGap::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPairGap::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_pair_packing.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_angle.h"
#include "math/bcl_math_histogram_2d.h"
#include "score/bcl_score_energy_distribution.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &SSEPairPacking::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "sse_angle_distance.histograms2D");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &SSEPairPacking::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "ssepack");

      // end
      return s_default_scheme;

    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param SCHEME scheme to be used
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param DISTANCE_RANGE_MAP map of distance ranges for valid contact types
    SSEPairPacking::SSEPairPacking
    (
      const std::string &SCHEME,
      const std::string &HISTOGRAM_FILENAME,
      const storage::Map< contact::Type, math::Range< double> > &DISTANCE_RANGE_MAP
    ) :
      m_Scheme( SCHEME),
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_DistanceRangeMap( DISTANCE_RANGE_MAP),
      m_MinimalInterfaceLength(),
      m_EnergyFunctions()
    {
      // read the histogram file and store the energy functions
      ReadEnergyVector();
    }

    //! @brief virtual copy constructor
    SSEPairPacking *SSEPairPacking::Clone() const
    {
      return new SSEPairPacking( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPairPacking::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that score packing of a pair of SSEs of interest
    //! @param SSE_PACK SSEGeometryPacking of pair of SSEs of interest
    //! @return potential of interaction
    double SSEPairPacking::operator()
    (
      const assemble::SSEGeometryPacking &SSE_PACK
    ) const
    {
      //if packing weight is small just return no score
      if( SSE_PACK.GetInteractionWeight() < std::numeric_limits< double>::epsilon())
      {
        return 0.0;
      }

      // store contact type
      contact::Type contact_type( SSE_PACK.GetContactType());

      // switch over contact type
      // if UNKNOWN
      if( contact_type == contact::GetTypes().e_Undefined)
      {
        return 0.0;
      }
      // if HELIX_HELIX
      else if
      (
        contact_type == contact::GetTypes().HELIX_HELIX
      )
      {
        return
        (
          SSE_PACK.GetInteractionWeight() * SSE_PACK.GetRelativePositionWeight()
          *
          (
            m_EnergyFunctions.Find( SSE_PACK.GetContactType())->second->F
            (
              linal::MakeVector( SSE_PACK.GetDistance(), SSE_PACK.GetTwistAngle())
            )
          )
        );
      }
      // for any helix and strand (sheet) combination
      else if
      (
        contact_type == contact::GetTypes().HELIX_SHEET            ||
        contact_type == contact::GetTypes().SHEET_HELIX            ||
        contact_type == contact::GetTypes().UNDEFINED_HELIX_STRAND ||
        contact_type == contact::GetTypes().UNDEFINED_STRAND_HELIX ||
        contact_type == contact::GetTypes().HELIX_STRAND           ||
        contact_type == contact::GetTypes().STRAND_HELIX
      )
      {
        return
        (
          SSE_PACK.GetInteractionWeight() * SSE_PACK.GetRelativePositionWeight()
          *
          (
            m_EnergyFunctions.Find( contact::GetTypes().HELIX_SHEET)->second->F
            (
              linal::MakeVector( SSE_PACK.GetDistance(), SSE_PACK.GetTwistAngle())
            )
          )
          +
          SSE_PACK.GetInteractionWeight() * ( 1.0 - SSE_PACK.GetRelativePositionWeight())
          *
          (
            m_EnergyFunctions.Find( contact::GetTypes().HELIX_STRAND)->second->F
            (
              linal::MakeVector( SSE_PACK.GetDistance(), SSE_PACK.GetTwistAngle())
            )
          )
        );
      }
      // if STRAND_STRAND, SHEET_SHEET or UNDEFINED_STRAND_STRAND
      else if
      (
        contact_type == contact::GetTypes().STRAND_STRAND ||
        contact_type == contact::GetTypes().SHEET_SHEET   ||
        contact_type == contact::GetTypes().UNDEFINED_STRAND_STRAND
      )
      {
        //apply transition function
        return
        (
          SSE_PACK.GetInteractionWeight() * SSE_PACK.GetRelativePositionWeight()
          *
          (
            m_EnergyFunctions.Find( contact::GetTypes().SHEET_SHEET)->second->F
            (
              linal::MakeVector( SSE_PACK.GetDistance(), SSE_PACK.GetTwistAngle())
            )
          )
        );
      }
      // if none above
      else
      {
        return util::GetUndefined< double>();
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &SSEPairPacking::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_HistogramFileName, ISTREAM);
      io::Serialize::Read( m_DistanceRangeMap, ISTREAM);

      // read the histogram file and store the energy functions
      m_EnergyFunctions.Reset();
      ReadEnergyVector();

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &SSEPairPacking::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_HistogramFileName, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_DistanceRangeMap, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param SSE_PACK SSEGeometryPacking of pair of SSEs of interest
    //! @param OSTREAM std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &SSEPairPacking::WriteDetailedSchemeAndValues
    (
      const assemble::SSEGeometryPacking &SSE_PACK,
      std::ostream &OSTREAM
    ) const
    {
      // write sstype, Angle to membrane plane to the STREAM
      OSTREAM << SSE_PACK.GetContactType().GetName() << '\t'
              << SSE_PACK.GetInteractionWeight() << '\t'
              << math::Angle::Degree( SSE_PACK.GetRelativePosition()) << '\t'
              << SSE_PACK.GetRelativePositionWeight() << '\t'
              << SSE_PACK.GetDistance() << '\t'
              << math::Angle::Degree( SSE_PACK.GetTwistAngle()) << '\t'
              << operator()( SSE_PACK) << '\n';

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief read energy distribution for scoring pairs of sses
    void SSEPairPacking::ReadEnergyVector()
    {
      // read file with all histograms for each pair of sstypes
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      // read minimal interface length and set the member variable to that one
      read >> m_MinimalInterfaceLength;

      // while reading contact type and a histogram not reaching the end of file
      while( read.good())
      {
        // initialize contact type
        contact::Type contact_type;

        // initialize histogram to read
        math::Histogram2D current_angle_distance_histogram;

        // read the contact type and the histogram
        read >> contact_type >> current_angle_distance_histogram;

        // calculate energydistribution, write it in spline and store it in map - also with swapped types

        util::ShPtr< math::BicubicSpline> current_spline;

        // for fragment packing, use the 2d energy distributions
        if( m_Scheme.find( "_fr") != std::string::npos)
        {
          current_spline = util::ShPtr< math::BicubicSpline>
          (
            new math::BicubicSpline
            (
              EnergyDistribution::SSEPacking2D( current_angle_distance_histogram, m_DistanceRangeMap.Find( contact_type)->second)
            )
          );
        }
        // use the symmetrize
        else
        {
          current_spline = util::ShPtr< math::BicubicSpline>
          (
            new math::BicubicSpline
            (
              EnergyDistribution::SSEPackingSymmetrize( current_angle_distance_histogram, m_DistanceRangeMap.Find( contact_type)->second)
            )
          );
        }

        m_EnergyFunctions[ contact_type] = current_spline;
        if( contact_type == contact::GetTypes().HELIX_SHEET)
        {
          m_EnergyFunctions[ contact::GetTypes().SHEET_HELIX] = current_spline;
        }
        else if( contact_type == contact::GetTypes().HELIX_STRAND)
        {
          m_EnergyFunctions[ contact::GetTypes().STRAND_HELIX] = current_spline;
        }

        // end of all histograms data
        if( contact_type == contact::GetTypes().SHEET_SHEET)
        {
          break;
        }
      }

      //close input stream
      io::File::CloseClearFStream( read);
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_pairs_fragments.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "io/bcl_io_serialization.h"
#include "storage/bcl_storage_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPairsFragments::s_Instance
    (
      util::Enumerated< math::BinaryFunctionInterfaceSerializable< assemble::SSE, assemble::SSE, double> >::AddInstance
      (
        new SSEPairsFragments()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEPairsFragments::SSEPairsFragments() :
      m_Packer( assemble::GetSSEGeometryPackingListPickers().GetUndefined()),
      m_SPScorePair(),
      m_NormalizeOverNumberOfPairs( false)
    {
    }

    //! @brief construct from a Function Interface and a normalization flag boolean
    //! @param PACKING_PICKER Function that will be used to calculate the packings between fragments
    //! @param PACKING_FUNCTION Function that will be used to calculate scores for all packings
    //! @param NORMALIZE_OVER_NUMBER_OF_PAIRS boolean flag to determine whether to normalize over number of pairs,
    SSEPairsFragments::SSEPairsFragments
    (
      const assemble::SSEGeometryPackingListPicker &PACKING_PICKER,
      const SSEPackInterface &PACKING_FUNCTION,
      const bool NORMALIZE_OVER_NUMBER_OF_PAIRS
    ) :
      m_Packer( PACKING_PICKER),
      m_SPScorePair( PACKING_FUNCTION.Clone()),
      m_NormalizeOverNumberOfPairs( NORMALIZE_OVER_NUMBER_OF_PAIRS)
    {
      // make sure the minimal interface lengths of the packer and the scoring function match each other
      BCL_Assert
      (
        ( *m_Packer)->GetMinimalInterfaceLength() == m_SPScorePair->GetMinimalInterfaceLength(),
        "The minimal interface lengths of the packer and the scoring function do not match " +
        util::Format()( ( *m_Packer)->GetMinimalInterfaceLength()) + " for packer vs " +
        util::Format()( m_SPScorePair->GetMinimalInterfaceLength()) + " for scoring function"
      );
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new SSEPairsFragments instance copied from this one
    SSEPairsFragments *SSEPairsFragments::Clone() const
    {
      return new SSEPairsFragments( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPairsFragments::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &SSEPairsFragments::GetScheme() const
    {
      return m_SPScorePair->GetScheme();
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &SSEPairsFragments::GetAlias() const
    {
      static const std::string s_name( "SSEPairsFragments");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer SSEPairsFragments::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Evaluates fragment interactions between SSEs.");
      serializer.AddInitializer
      (
        "packer",
        "packer used to evaluate packing",
        io::Serialization::GetAgent( &m_Packer)
      );
      serializer.AddInitializer
      (
        "score function",
        "function used to score the fragment interactions",
        io::Serialization::GetAgent( &m_SPScorePair)
      );
      serializer.AddInitializer
      (
        "normalize",
        "normalize over the number of pairs",
        io::Serialization::GetAgent( &m_NormalizeOverNumberOfPairs)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief returns whether the given pair of SSEs are valid
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @return whether the given pair of SSEs are valid
    bool SSEPairsFragments::AreValidSSEs( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      return m_SPScorePair->AreValidSSEs( SSE_A, SSE_B);
    }

    //! @brief f to sum up all pairwise scores for the given SSE Pair
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @return summed up score for the given SSE Pair
    double SSEPairsFragments::operator()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      //instatiate the scoresum
      double score( 0.0);

      // if both SSEs are not helix or strand
      if( !SSE_A.GetType()->IsStructured() || !SSE_B.GetType()->IsStructured())
      {
        // return 0
        return double( 0.0);
      }

      // make sure the SSEs are valid
      if( !AreValidSSEs( SSE_A, SSE_B))
      {
        return double( 0.0);
      }

      BCL_MessageDbg( "scoring fragments with " + m_SPScorePair->GetScheme());
      BCL_MessageDbg
      (
        "SSEs " + SSE_A.GetIdentification() + " and " + SSE_B.GetIdentification()
      );

      // get the list of packings
      const storage::List< assemble::SSEGeometryPacking> packing_list( ( *m_Packer)->operator ()( SSE_A, SSE_B));

      // iterate over the packings
      for
      (
        storage::List< assemble::SSEGeometryPacking>::const_iterator
          pack_itr( packing_list.Begin()), pack_itr_end( packing_list.End());
        pack_itr != pack_itr_end; ++pack_itr
      )
      {

        // call the pairscore with pair of fragments
        const double this_score( m_SPScorePair->operator()( *pack_itr));

        BCL_MessageDbg
        (
          "fragments " +
          pack_itr->GetFirstSSEGeometry()->GetIdentification() + " and " +
          pack_itr->GetSecondSSEGeometry()->GetIdentification() +
          " weight: " + util::Format()( pack_itr->GetInteractionWeight()) +
          " contact " + pack_itr->GetContactType().GetName() +
          " distance " + util::Format()( pack_itr->GetDistance()) +
          " strand pairing w " + util::Format()( pack_itr->GetStrandStrandPairingWeight()) +
          " relative position w " + util::Format()( pack_itr->GetRelativePositionWeight()) +
          " twist " + util::Format()( pack_itr->GetTwistAngle()) +
          " score: " + util::Format()( this_score)
        );

        // sum up the score
        score += this_score;
      }

      // if given SSEs has fragments and normalize flag is set
      if( m_NormalizeOverNumberOfPairs && !packing_list.IsEmpty())
      {
        // then normalize the score by the fragments_a list since it is smaller
        return score / packing_list.GetSize();
      }

      //end
      return score;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &SSEPairsFragments::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Packer, ISTREAM);
      io::Serialize::Read( m_SPScorePair, ISTREAM);
      io::Serialize::Read( m_NormalizeOverNumberOfPairs, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &SSEPairsFragments::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Packer, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SPScorePair, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_NormalizeOverNumberOfPairs, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the Function value for the ARGUMENT to the STREAM
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @param OSTREAM std::sotream to be written to
    //! @return std::ostream which was written to
    std::ostream &SSEPairsFragments::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B,
      std::ostream &OSTREAM
    ) const
    {

      // if both SSEs are not helix or strand
      if
      (
        ( SSE_A.GetType() != biol::GetSSTypes().HELIX && SSE_A.GetType() != biol::GetSSTypes().STRAND)
        ||
        ( SSE_B.GetType() != biol::GetSSTypes().HELIX && SSE_B.GetType() != biol::GetSSTypes().STRAND)
      )
      {
        // return 0
        return OSTREAM;
      }

      OSTREAM << SSE_A.GetIdentification() << '\t'
              << SSE_B.GetIdentification() << '\t'
              << operator()( SSE_A, SSE_B) << '\n';

      // get the list of packings
      const storage::List< assemble::SSEGeometryPacking> packing_list( ( *m_Packer)->operator ()( SSE_A, SSE_B));

      // iterate over the packings
      for
      (
        storage::List< assemble::SSEGeometryPacking>::const_iterator
          pack_itr( packing_list.Begin()), pack_itr_end( packing_list.End());
        pack_itr != pack_itr_end; ++pack_itr
      )
      {
        OSTREAM << "\t\t"
                << pack_itr->GetFirstSSEGeometry()->GetIdentification() << '\t'
                << pack_itr->GetSecondSSEGeometry()->GetIdentification() << '\t';

        //write the detailed scheme and value for the pair score
        m_SPScorePair->WriteDetailedSchemeAndValues( *pack_itr, OSTREAM);
      }

      //end
      return OSTREAM;
    }

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_pool_sses.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPoolSSEs::s_Instance
    (
      GetObjectInstances().AddInstance
      (
        new SSEPoolSSEs
        (
          util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >(),
          false, false
        )
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from sse score and normalization
    SSEPoolSSEs::SSEPoolSSEs
    (
      const util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > > &SP_SCORE_SSE,
      const bool NORMALIZE_SSE,
      const bool NORMALIZE_NUMBER_SSES
    ) :
      m_SSEScore( SP_SCORE_SSE),
      m_NormalizeSSE( NORMALIZE_SSE),
      m_NormalizeNumberSSEs( NORMALIZE_NUMBER_SSES)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEPoolSSEs
    SSEPoolSSEs *SSEPoolSSEs::Clone() const
    {
      return new SSEPoolSSEs( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPoolSSEs::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &SSEPoolSSEs::GetScheme() const
    {
      return m_SSEScore->GetScheme();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that scores the pool
    //! @param POOL the sse pool to be scored
    //! @param MEMBRANE membrane object
    //! @return the sum of the normalized scores
    double SSEPoolSSEs::operator()( const assemble::SSEPool &POOL, const biol::Membrane &MEMBRANE) const
    {
      double score( 0);
      size_t number( 0);
      size_t entities( 0);

      // iterate over all sses in the pool
      for( assemble::SSEPool::const_iterator itr( POOL.Begin()), itr_end( POOL.End()); itr != itr_end; ++itr)
      {
        // score that sses
        storage::Pair< double, size_t> result( m_SSEScore->operator ()( **itr, MEMBRANE));

        // at least one entity needs to be scored
        if( result.Second() == 0)
        {
          continue;
        }

        if( !util::IsDefined( result.First()))
        {
          BCL_MessageDbg
          (
            "scoring SSE: " + ( *itr)->GetIdentification() +
            " with score: " + m_SSEScore->GetScheme() + " returned undefined"
          );
          continue;
        }
//        // normalize by the entities scored
//        if( m_NormalizeSSE)
//        {
//          result.First() /= double( result.Second());
//        }

        score    += result.First();
        entities += result.Second();
        ++number;
      }

      if( m_NormalizeSSE && entities > 0)
      {
        score /= double( entities);
      }
      // normalize by the number of sses
      else if( m_NormalizeNumberSSEs && number > 0)
      {
        score /= double( number);
      }

      // end
      return score;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write detailed scheme and values to OSTREAM
    //! @param POOL Argument to be used to evaluate the function
    //! @param OSTREAM std::ostream to be written to
    //! @param MEMBRANE membrane object
    //! @return std::ostream which was written to
    std::ostream &SSEPoolSSEs::WriteDetailedSchemeAndValues
    (
      const assemble::SSEPool &POOL,
      const biol::Membrane &MEMBRANE,
      std::ostream &OSTREAM
    ) const
    {
      // iterate over all sses in the pool
      for( assemble::SSEPool::const_iterator itr( POOL.Begin()), itr_end( POOL.End()); itr != itr_end; ++itr)
      {
        // score that sses
        storage::Pair< double, size_t> result( m_SSEScore->operator ()( **itr, MEMBRANE));

        // normalize by the entities scored
        if( m_NormalizeSSE)
        {
          result.First() /= double( result.Second());
        }

        OSTREAM << ( *itr)->GetIdentification() << '\t' << result.First() << '\t' << result.Second() << '\n';
      }

      // end
      return OSTREAM;
    }

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPoolSSEs::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSEScore           , ISTREAM);
      io::Serialize::Read( m_NormalizeSSE       , ISTREAM);
      io::Serialize::Read( m_NormalizeNumberSSEs, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPoolSSEs::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSEScore           , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_NormalizeSSE       , OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_NormalizeNumberSSEs, OSTREAM, 0);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_sse_predictions.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_running_average_sd.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPredictions::s_Instance
    (
      util::Enumerated< SSEPredictionInterface>::AddInstance( new SSEPredictions())
    );

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &SSEPredictions::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "sspred_sstype_nres_average_mean.bcl");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &SSEPredictions::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "ssepred");

      // end
      return s_default_scheme;
    }

    //! @brief multiple of the confidence interval for the z-score
    const double SSEPredictions::s_DefaultConfidenceThreshold( 0.5); // mean and higher probability sses should have a negative score

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEPredictions::SSEPredictions() :
      m_Method( sspred::GetMethods().e_Undefined),
      m_ConfidenceThreshold( s_DefaultConfidenceThreshold),
      m_Scheme( GetDefaultScheme())
    {
    }

    //! @brief constructor from a ssmethod and confidence threshold
    //! @param SS_METHOD ssmethod to use
    //! @param CONFIDENCE_THRESHOLD the threshold in units of z-score, above which the score becomes negative
    //! @param SCHEME scheme to be used
    SSEPredictions::SSEPredictions
    (
      const sspred::Method &SS_METHOD,
      const double CONFIDENCE_THRESHOLD,
      const std::string &SCHEME
    ) :
      m_Method( SS_METHOD),
      m_ConfidenceThreshold( CONFIDENCE_THRESHOLD),
      m_Scheme( SCHEME)
    {
      if( m_Method.IsDefined())
      {
        // read the histogram file and store the energy functions
        ReadEnergyVector();
      }
    }

    //! @brief Clone function
    //! @return pointer to new SSEPredictions
    SSEPredictions *SSEPredictions::Clone() const
    {
      return new SSEPredictions( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPredictions::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &SSEPredictions::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &SSEPredictions::GetAlias() const
    {
      static const std::string s_name( "SSEPredictions");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer SSEPredictions::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Score the log likelihodd of each amino acids prediction");
      serializer.AddInitializer
      (
        "method",
        "sspred method use in SSE prediction evaluation",
        io::Serialization::GetAgent( &m_Method),
        sspred::GetMethods().e_Undefined
      );
      serializer.AddInitializer
      (
        "confidence threshold",
        "In units of z-score, at which z-score, the confidence is negative ?",
        io::Serialization::GetAgent( &m_ConfidenceThreshold),
        util::Format()( s_DefaultConfidenceThreshold)
      );
      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates the score for a given SSE
    //! @param SSE SSE of interest
    //! @param MEMBRANE membrane object
    //! @return score calculated for the given SSE
    storage::Pair< double, size_t> SSEPredictions::operator()
    (
      const assemble::SSE &SSE,
      const biol::Membrane &MEMBRANE
    ) const
    {
      double score( 0);

      const storage::Map< biol::SSType, math::PiecewiseFunction>::const_iterator
        itr( m_Potentials.Find( SSE.GetType()));

      if( itr == m_Potentials.End())
      {
        return storage::Pair< double, size_t>( score, 0);
      }

      // iterate over all amino acids in sequence
      for
      (
        biol::AASequence::const_iterator aa_itr( SSE.Begin()), aa_itr_end( SSE.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        score += ScoreAminoAcid( **aa_itr, SSE.GetType(), itr->second);
      }

      // end
      return storage::Pair< double, size_t>( score, SSE.GetSize());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param SSE SSE of interest
    //! @param MEMBRANE membrane object
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &SSEPredictions::WriteDetailedSchemeAndValues
    (
      const assemble::SSE &SSE,
      const biol::Membrane &MEMBRANE,
      std::ostream &OSTREAM
    ) const
    {
      const storage::Map< biol::SSType, math::PiecewiseFunction>::const_iterator
        itr( m_Potentials.Find( SSE.GetType()));

      if( itr == m_Potentials.End())
      {
        return OSTREAM;
      }

      // iterate over all amino acids in sequence
      for
      (
        biol::AASequence::const_iterator aa_itr( SSE.Begin()), aa_itr_end( SSE.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        OSTREAM << ( *aa_itr)->GetIdentification() << '\t' << SSE.GetType()->GetOneLetterCode() << '\t' << ScoreAminoAcid( **aa_itr, SSE.GetType(), itr->second) << '\n';
      }

      // end
      return OSTREAM;
    }

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPredictions::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Method             , ISTREAM);
      io::Serialize::Read( m_ConfidenceThreshold, ISTREAM);
      io::Serialize::Read( m_Scheme             , ISTREAM);

      if( m_Method.IsDefined())
      {
        // read the histogram file and store the energy functions
        ReadEnergyVector();
      }

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPredictions::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Method             , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ConfidenceThreshold, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme             , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief score a single amino acid
    //! @param AMIO_ACID amino acid to score
    //! @param SS_TYPE the sstype amino acid prediction will be evaluated for
    //! @param PiecewiseFunction the PiecewiseFunction to use
    //! @return the score
    double SSEPredictions::ScoreAminoAcid( const biol::AABase &AMINO_ACID, const biol::SSType &SS_TYPE, const math::PiecewiseFunction &FUNC) const
    {
      // if Z score has sigma of zero, return score of zero
      auto pred( AMINO_ACID.GetData()->GetSSPrediction( m_Method));
      if( !pred.IsDefined())
      {
        return 0.0;
      }

      // get the raw predictions
      linal::Vector3D predictions( pred->GetThreeStatePrediction());
      // translate them into probabilities using the localPPV
      for( int i( 0); i < 3; ++i)
      {
        predictions( i) = m_Potentials.GetValue( biol::SSType( i))( predictions( i));
      }
      predictions.SetToSum( 1.0);

      // evaluate
      return -predictions( SS_TYPE);
    }

    //! @brief read energy distribution for scoring pairs of sses
    void SSEPredictions::ReadEnergyVector()
    {
      storage::Map< sspred::Method, storage::Map< biol::SSType, math::PiecewiseFunction> > funcs;

      io::IFStream read_str;
      io::File::MustOpenIFStream( read_str, Score::AddHistogramPath( GetDefaultHistogramFilename()));
      read_str >> funcs;
      io::File::CloseClearFStream( read_str);

      // search for method
      auto meth_itr( funcs.Find( m_Method));

      if( meth_itr == funcs.End())
      {
        BCL_MessageCrt
        (
          "there is no statistics for method: " + m_Method.GetName() + " in file: " + GetDefaultHistogramFilename() +
          " ==> no SSPred score for this method!!"
        );
        return;
      }
      m_Potentials = meth_itr->second;
    }

    //! @brief Set the members of this property from the given LABEL
    //! @param LABEL the label to parse
    //! @param ERR_STREAM stream to write out errors to
    bool SSEPredictions::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERR_STREAM
    )
    {
      ReadEnergyVector();
      return true;
    }
  } // namespace score
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_strand_pairing.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "command/bcl_command_command_state.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_histogram_2d.h"
#include "score/bcl_score_energy_distribution.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> StrandPairing::s_Instance
    (
      util::Enumerated< SSEPackInterface>::AddInstance( new StrandPairing())
    );

  //////////
  // data //
  //////////

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &StrandPairing::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "strand_angle_distance.histograms2D");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &StrandPairing::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "strand");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a specified histogram file
    //! @param SCHEME scheme to be used
    //! @param HISTOGRAM_FILENAME filename of the histogram to be used
    //! @param DISTANCE_RANGE distance range
    StrandPairing::StrandPairing
    (
      const std::string &SCHEME,
      const std::string &HISTOGRAM_FILENAME,
      const math::Range< double> &DISTANCE_RANGE
    ) :
      m_Scheme( SCHEME),
      m_HistogramFileName( HISTOGRAM_FILENAME),
      m_DistanceRange( DISTANCE_RANGE),
      m_MinimalInterfaceLength(),
      m_EnergyFunction()
    {
      if( !command::CommandState::GetGlobalCommandState().IsInStaticInitialization())
      {
        // read the histogram file and store the energy functions
        ReadEnergyVector();
      }
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new StrandPairing object that is copied from this one
    StrandPairing *StrandPairing::Clone() const
    {
      return new StrandPairing( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &StrandPairing::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }
    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &StrandPairing::GetAlias() const
    {
      static const std::string s_name( "StrandPairing");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer StrandPairing::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "A Function derived class for scoring pairing of strands within one sheet");
      serializer.AddInitializer
      (
        "histogram file name",
        "path to file where the statistics and in consequence the energy potentials are read from",
        io::Serialization::GetAgent( &m_HistogramFileName),
        util::Format()( GetDefaultHistogramFilename())
      );
      serializer.AddInitializer
      (
        "distance range",
        "distance range",
        io::Serialization::GetAgent( &m_DistanceRange),
        contact::GetTypes().STRAND_STRAND->GetDistanceRange().GetString()
      );
      serializer.AddInitializer
      (
        "Minimal interface length",
        "minimal interface length for packing to get a full weight",
        io::Serialization::GetAgent( &m_MinimalInterfaceLength),
        "0"
      );
      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief returns whether the given pair of SSEs are valid
    //! @param SSE_A first SSE of interest
    //! @param SSE_B second SSE of interest
    //! @return whether the given pair of SSEs are valid
    bool StrandPairing::AreValidSSEs( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
    {
      // return true only if both SSEs are strands
      return SSE_A.GetType() == biol::GetSSTypes().STRAND && SSE_B.GetType() == biol::GetSSTypes().STRAND;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates strand pair packing potential
    //! @param SSE_PACK SSEGeometryPacking of pair of SSEs of interest - if not strands just returns 0
    //! @return strand pairing potential
    double
    StrandPairing::operator()
    (
      const assemble::SSEGeometryPacking &SSE_PACK
    ) const
    {
      // if packign weight is small just return no score
      if( SSE_PACK.GetInteractionWeight() < std::numeric_limits< double>::epsilon())
      {
        return 0.0;
      }

      // store the contact type
      contact::Type contact_type( SSE_PACK.GetContactType());

      // switch over contacttype
      if
      (
          contact_type == contact::GetTypes().e_Undefined            ||
          contact_type == contact::GetTypes().HELIX_HELIX            ||
          contact_type == contact::GetTypes().HELIX_SHEET            ||
          contact_type == contact::GetTypes().SHEET_HELIX            ||
          contact_type == contact::GetTypes().HELIX_STRAND           ||
          contact_type == contact::GetTypes().STRAND_HELIX           ||
          contact_type == contact::GetTypes().UNDEFINED_HELIX_STRAND ||
          contact_type == contact::GetTypes().UNDEFINED_STRAND_HELIX
      )
      {
        return double( 0);
      }
      // if strand strand related contact type
      else if
      (
          contact_type == contact::GetTypes().SHEET_SHEET   ||
          contact_type == contact::GetTypes().STRAND_STRAND ||
          contact_type == contact::GetTypes().UNDEFINED_STRAND_STRAND
      )
      {
        // calculate weight for transition region and multiply it with score
        return
            (
                SSE_PACK.GetStrandStrandPairingWeight() * SSE_PACK.GetInteractionWeight()
                *
                (
                    m_EnergyFunction->F( linal::MakeVector( SSE_PACK.GetDistance(), SSE_PACK.GetTwistAngle()))
                )
            );
      }

      // return undefined
      return util::GetUndefined< double>();
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &StrandPairing::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_HistogramFileName, ISTREAM);
      io::Serialize::Read( m_DistanceRange, ISTREAM);

      // read the histogram file and store the energy functions
      ReadEnergyVector();

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @param INDENT indentation
    //! @return returns the output stream
    std::ostream &StrandPairing::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_HistogramFileName, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_DistanceRange, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write the Scheme and the function value for the ARGUMENT to the STREAM
    //! @param SSE_PACK SSEGeometryPacking of pair of SSEs of interest
    //! @param OSTREAM the std::ostream to be written to
    //! @return std::ostream which was written to
    std::ostream &
    StrandPairing::WriteDetailedSchemeAndValues
    (
      const assemble::SSEGeometryPacking &SSE_PACK,
      std::ostream &OSTREAM
    ) const
    {
      //write sstype, Angel to membrane plane first and last aminoacid and value to the STREAM
      OSTREAM << SSE_PACK.GetContactType().GetName() << '\t'

          // output interaction angleas and weight. it shows how parallel main axes of SSEs are. optimal is 0, 0, 1
          //              << math::Degree( SSE_PACK.AngleSSEConnection( *SSE_PAIR.First(), SSE_PACK.GetShortestConnection()))
          //              << '\t'
          //              << math::Degree( SSE_PACK.AngleSSEConnection( *SSE_PAIR.Second(), SSE_PACK.GetShortestConnection()))
          //              << '\t'
          << SSE_PACK.GetInteractionWeight() << '\t'

          // output planarity within sheet and associated weight, perfect strand strand pair would be 90, 90, 1
          //              << math::Degree( math::Absolute( math::g_Pi / 2 - math::Absolute( math::g_Pi / 2 - linal::ProjAngle( SSE_PACK.GetShortestConnection().GetEndPoint(), SSE_PACK.GetShortestConnection().GetStartPoint(), SSE_PACK.GetShortestConnection().GetEndPoint() + SSE_PAIR.Second()->GetAxis( coord::GetAxes().e_X))))) << '\t'
          //              << math::Degree( math::Absolute( math::g_Pi / 2 - math::Absolute( math::g_Pi / 2 - linal::ProjAngle( SSE_PACK.GetShortestConnection().GetStartPoint(), SSE_PACK.GetShortestConnection().GetEndPoint(), SSE_PACK.GetShortestConnection().GetStartPoint() + SSE_PAIR.First()->GetAxis( coord::GetAxes().e_X))))) << '\t'
          << SSE_PACK.GetStrandStrandPairingWeight() << '\t'

          // output shortest distance and twis angle
          //               << ( 1.0 - math::WeightBetweenZeroAndPi_ThreeSections( SSE_PACK.GetRelativePosition())) << '\t'
          << SSE_PACK.GetDistance() << '\t'
          << math::Angle::Degree( SSE_PACK.GetTwistAngle()) << '\t'
          << operator()( SSE_PACK) << '\n';

      //end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief read energy distribution for scoring pairs of  of strands within one sheet
    void StrandPairing::ReadEnergyVector()
    {
      //read file with all histograms for each pair of sstypes
      io::IFStream read;
      io::File::MustOpenIFStream( read, Score::AddHistogramPath( m_HistogramFileName));

      // read minimal interface length and set the member variable to that one
      read >> m_MinimalInterfaceLength;

      //read the sstype pair and according histogram of counts
      contact::Type contact_type;
      read >> contact_type;

      // assert the histogram contains the correct contact type (STRAND-STRAND) histogram
      BCL_Assert
      (
        contact_type == contact::GetTypes().STRAND_STRAND,
        "file is not a histogram for strand-strand packing"
      );

      // read the histogram
      math::Histogram2D current_angle_distance_histogram;
      read >> current_angle_distance_histogram;

      //calculate energydistribution, write it in spline and store it in map - also with swapped types
      m_EnergyFunction =
          util::ShPtr< math::BicubicSpline>
      (
        new math::BicubicSpline
        (
          EnergyDistribution::SSEPacking2D( current_angle_distance_histogram, m_DistanceRange)
        )
      );

      //close input stream
      io::File::CloseClearFStream( read);
    }

    //! @brief Set the members of this property from the given LABEL
    //! @param LABEL the label to parse
    //! @param ERR_STREAM stream to write out errors to
    bool StrandPairing::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERR_STREAM
    )
    {
      ReadEnergyVector();
      return true;
    }

  } // namespace score
} // namespace bcl

// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "score/bcl_score_symmetry.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_atom.h"
#include "io/bcl_io_file.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace score
  {

    //! @brief construct from file that contains movable locators
    //! this function has to be specialized for each t_ArgumentType within the cpp
    //! @param FILENAME filename that contains some kind of movable locators
    //! @param SCHEME
    template<>
    Symmetry< assemble::ProteinModel>::Symmetry
    (
      const std::string &FILENAME,
      const std::string &SCHEME
    ) :
      m_Scheme( SCHEME),
      m_MovableLocators()
    {
      // create stream to file
      io::IFStream read;
      io::File::MustOpenIFStream( read, FILENAME);
      BCL_MessageStd( "read symmetry file: " + FILENAME);

      // create "symmetry_definitions" and initialize with the information from "read"
      storage::Vector< storage::Vector< std::string> > symmetry_definitions
      (
        util::SplittedStringLineListFromIStream( read)
      );

      for
      (
        storage::Vector< storage::Vector< std::string> >::const_iterator
          line_iter( symmetry_definitions.Begin()), line_iter_end( symmetry_definitions.End());
        line_iter != line_iter_end;
        ++line_iter
      )
      {
        util::ShPtrVector< find::LocatorInterface< linal::Vector3D, assemble::ProteinModel> > symmetry_unit;
        for
        (
          storage::Vector< std::string>::const_iterator
            point_iter( line_iter->Begin()), point_iter_end( line_iter->End());
          point_iter != point_iter_end;
          ++point_iter
        )
        {
          const char chain_char( point_iter->operator[]( 0));
          BCL_MessageDbg( "chain is " + util::Format()( chain_char));

          // go to next (it will be residue number)
          ++point_iter;
          const int residue( util::ConvertStringToNumericalValue< int>( *point_iter));
          BCL_MessageDbg( "residue is " + util::Format()( residue));

          // go to next (it will be atom name)
          ++point_iter;
          const biol::AtomType atom_type( biol::GetAtomTypes().TypeFromPDBAtomName( *point_iter));
          BCL_MessageDbg( "atom name is " + util::Format()( atom_type->GetName()));

          const util::ShPtr< find::LocatorInterface< linal::Vector3D, assemble::ProteinModel> > coordinate_locator
          (
            new assemble::LocatorAtom( chain_char, residue, atom_type)
          );

          symmetry_unit.PushBack( coordinate_locator);
        }
        BCL_MessageDbg( "Number of points in symmetry unit is " + util::Format()( symmetry_unit.GetSize()));
        m_MovableLocators.PushBack( symmetry_unit);
      }

      BCL_MessageDbg( "Number of symmetry units is " + util::Format()( m_MovableLocators.GetSize()));
    }

  } // namespace score
} // namespace bcl
