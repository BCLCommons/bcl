// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "chemistry/bcl_chemistry_bond_lengths.h"

// includes from bcl - sorted alphabetically
#include "chemistry/bcl_chemistry_atom_configurational_interface.h"
#include "chemistry/bcl_chemistry_atom_constitutional_interface.h"
#include "chemistry/bcl_chemistry_bond_conformational.h"
#include "chemistry/bcl_chemistry_possible_atom_types_for_atom.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_ofstream.h"
#include "util/bcl_util_string_functions.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace chemistry
  {
  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief convert bond order or aromatic into the corresponding radius
    //! @param BOND_ORDER_OR_AROMATIC bond type in notation: 1=single, 2=double, 3=triple, 4=aromatic
    AtomTypeData::Properties BondLengths::BondOrderProperty( const size_t &BOND_ORDER_OR_AROMATIC)
    {
      static AtomTypeData::Properties s_properties[ 5] =
      {
        AtomTypeData::e_VdWaalsRadiusCSD,
        AtomTypeData::e_CovalentRadiusSingleBond,
        AtomTypeData::e_CovalentRadiusDoubleBond,
        AtomTypeData::e_CovalentRadiusTripleBond,
        AtomTypeData::e_CovalentRadiusAromaticBond
      };
      BCL_Assert
      (
        BOND_ORDER_OR_AROMATIC && BOND_ORDER_OR_AROMATIC <= size_t( 4),
        "Bond order must be between 1 and 4 (4 = aromatic), but got " + util::Format()( BOND_ORDER_OR_AROMATIC)
      );
      return s_properties[ BOND_ORDER_OR_AROMATIC];
    }

    //! @brief set radius information for the atom types of a given phenotype
    //! @param ATOM_TYPES atom types for which to set the given property
    //! @param PROPERTY the property to set
    //! @param VALUE the value to set the property to
    void BondLengths::SetPropertyInfo
    (
      storage::Vector< AtomType> &ATOM_TYPES,
      const AtomTypeData::Properties &PROPERTY,
      const double &VALUE
    )
    {
      // set the associated information
      for
      (
        storage::Vector< AtomType>::iterator itr( ATOM_TYPES.Begin()), itr_end( ATOM_TYPES.End());
        itr != itr_end;
        ++itr
      )
      {
        ( *itr)->SetProperty( PROPERTY, VALUE);
      }
    }

    //! @brief initialization of bond lengths
    //! @param BEGIN iterator to beginning of atom types
    //! @param END iterator to end of atom types
    void BondLengths::Initialize( std::vector< AtomType>::iterator BEGIN, std::vector< AtomType>::iterator END)
    {
      // make a mapping from element type, # bonds, # electrons in bonds to a listing of all atom types with those
      // properties
      storage::Map< std::string, storage::Vector< AtomType> > phenotype_to_atom_type;

      for( std::vector< AtomType>::iterator itr( BEGIN); itr != END; ++itr)
      {
        // get a mutable ref to the atom type
        AtomType &atom_type( *itr);

        // create the triplet of phenotypic info about this atom type
        const std::string phenotype
        (
          atom_type->GetElementType()->GetChemicalSymbol()
          + util::Format()( atom_type->GetNumberBonds() * 10 + atom_type->GetNumberElectronsInBonds())
        );

        phenotype_to_atom_type[ phenotype].PushBack( atom_type);
      }

      // These values were generated by app::GenerateAtomHybridization descriptors using the COD on June 26, 2019
      SetPropertyInfo( phenotype_to_atom_type[ "As33"], AtomTypeData::e_CovalentRadiusSingleBond, 1.04);
      SetPropertyInfo( phenotype_to_atom_type[ "Al33"], AtomTypeData::e_CovalentRadiusSingleBond, 1.22);
      SetPropertyInfo( phenotype_to_atom_type[ "B23"], AtomTypeData::e_CovalentRadiusSingleBond, 0.80);
      SetPropertyInfo( phenotype_to_atom_type[ "B33"], AtomTypeData::e_CovalentRadiusSingleBond, 0.79);
      SetPropertyInfo( phenotype_to_atom_type[ "B34"], AtomTypeData::e_CovalentRadiusSingleBond, 0.81);
      SetPropertyInfo( phenotype_to_atom_type[ "B44"], AtomTypeData::e_CovalentRadiusSingleBond, 0.86);
      SetPropertyInfo( phenotype_to_atom_type[ "Be22"], AtomTypeData::e_CovalentRadiusSingleBond, 1.15);
      SetPropertyInfo( phenotype_to_atom_type[ "Br11"], AtomTypeData::e_CovalentRadiusSingleBond, 1.16);
      SetPropertyInfo( phenotype_to_atom_type[ "C23"], AtomTypeData::e_CovalentRadiusSingleBond, 0.75);
      SetPropertyInfo( phenotype_to_atom_type[ "C24"], AtomTypeData::e_CovalentRadiusSingleBond, 0.70);
      SetPropertyInfo( phenotype_to_atom_type[ "C33"], AtomTypeData::e_CovalentRadiusSingleBond, 0.77);
      SetPropertyInfo( phenotype_to_atom_type[ "C34"], AtomTypeData::e_CovalentRadiusSingleBond, 0.73);
      SetPropertyInfo( phenotype_to_atom_type[ "C44"], AtomTypeData::e_CovalentRadiusSingleBond, 0.76);
      SetPropertyInfo( phenotype_to_atom_type[ "Cl11"], AtomTypeData::e_CovalentRadiusSingleBond, 1.00);
      SetPropertyInfo( phenotype_to_atom_type[ "F11"], AtomTypeData::e_CovalentRadiusSingleBond, 0.60);
      SetPropertyInfo( phenotype_to_atom_type[ "I11"], AtomTypeData::e_CovalentRadiusSingleBond, 1.36);
      SetPropertyInfo( phenotype_to_atom_type[ "K11"], AtomTypeData::e_CovalentRadiusSingleBond, 2.18);
      SetPropertyInfo( phenotype_to_atom_type[ "Li11"], AtomTypeData::e_CovalentRadiusSingleBond, 1.37);
      SetPropertyInfo( phenotype_to_atom_type[ "Mg22"], AtomTypeData::e_CovalentRadiusSingleBond, 1.05);
      SetPropertyInfo( phenotype_to_atom_type[ "N22"], AtomTypeData::e_CovalentRadiusSingleBond, 0.69);
      SetPropertyInfo( phenotype_to_atom_type[ "N23"], AtomTypeData::e_CovalentRadiusSingleBond, 0.67);
      SetPropertyInfo( phenotype_to_atom_type[ "N24"], AtomTypeData::e_CovalentRadiusSingleBond, 0.65);
      SetPropertyInfo( phenotype_to_atom_type[ "N33"], AtomTypeData::e_CovalentRadiusSingleBond, 0.67);
      SetPropertyInfo( phenotype_to_atom_type[ "N34"], AtomTypeData::e_CovalentRadiusSingleBond, 0.71);
      SetPropertyInfo( phenotype_to_atom_type[ "N35"], AtomTypeData::e_CovalentRadiusSingleBond, 0.73);
      SetPropertyInfo( phenotype_to_atom_type[ "N44"], AtomTypeData::e_CovalentRadiusSingleBond, 0.74);
      SetPropertyInfo( phenotype_to_atom_type[ "N45"], AtomTypeData::e_CovalentRadiusSingleBond, 0.70);
      SetPropertyInfo( phenotype_to_atom_type[ "Na11"], AtomTypeData::e_CovalentRadiusSingleBond, 1.78);
      SetPropertyInfo( phenotype_to_atom_type[ "O11"], AtomTypeData::e_CovalentRadiusSingleBond, 0.63);
      SetPropertyInfo( phenotype_to_atom_type[ "O22"], AtomTypeData::e_CovalentRadiusSingleBond, 0.65);
      SetPropertyInfo( phenotype_to_atom_type[ "O23"], AtomTypeData::e_CovalentRadiusSingleBond, 0.60);
      SetPropertyInfo( phenotype_to_atom_type[ "O33"], AtomTypeData::e_CovalentRadiusSingleBond, 0.68);
      SetPropertyInfo( phenotype_to_atom_type[ "P23"], AtomTypeData::e_CovalentRadiusSingleBond, 1.10);
      SetPropertyInfo( phenotype_to_atom_type[ "P33"], AtomTypeData::e_CovalentRadiusSingleBond, 1.09);
      SetPropertyInfo( phenotype_to_atom_type[ "P34"], AtomTypeData::e_CovalentRadiusSingleBond, 0.98);
      SetPropertyInfo( phenotype_to_atom_type[ "P35"], AtomTypeData::e_CovalentRadiusSingleBond, 1.01);
      SetPropertyInfo( phenotype_to_atom_type[ "P44"], AtomTypeData::e_CovalentRadiusSingleBond, 1.06);
      SetPropertyInfo( phenotype_to_atom_type[ "P45"], AtomTypeData::e_CovalentRadiusSingleBond, 0.99);
      SetPropertyInfo( phenotype_to_atom_type[ "S11"], AtomTypeData::e_CovalentRadiusSingleBond, 0.85);
      SetPropertyInfo( phenotype_to_atom_type[ "S22"], AtomTypeData::e_CovalentRadiusSingleBond, 1.02);
      SetPropertyInfo( phenotype_to_atom_type[ "S23"], AtomTypeData::e_CovalentRadiusSingleBond, 1.11);
      SetPropertyInfo( phenotype_to_atom_type[ "S33"], AtomTypeData::e_CovalentRadiusSingleBond, 1.03);
      SetPropertyInfo( phenotype_to_atom_type[ "S34"], AtomTypeData::e_CovalentRadiusSingleBond, 1.03);
      SetPropertyInfo( phenotype_to_atom_type[ "S46"], AtomTypeData::e_CovalentRadiusSingleBond, 0.99);
      SetPropertyInfo( phenotype_to_atom_type[ "S66"], AtomTypeData::e_CovalentRadiusSingleBond, 0.99);
      SetPropertyInfo( phenotype_to_atom_type[ "Se22"], AtomTypeData::e_CovalentRadiusSingleBond, 1.18);
      SetPropertyInfo( phenotype_to_atom_type[ "Si33"], AtomTypeData::e_CovalentRadiusSingleBond, 1.11);
      SetPropertyInfo( phenotype_to_atom_type[ "Si34"], AtomTypeData::e_CovalentRadiusSingleBond, 1.18);
      SetPropertyInfo( phenotype_to_atom_type[ "Si44"], AtomTypeData::e_CovalentRadiusSingleBond, 1.11);
      SetPropertyInfo( phenotype_to_atom_type[ "Te22"], AtomTypeData::e_CovalentRadiusSingleBond, 1.39);
      SetPropertyInfo( phenotype_to_atom_type[ "B23"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.86);
      SetPropertyInfo( phenotype_to_atom_type[ "B34"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.86);
      SetPropertyInfo( phenotype_to_atom_type[ "C23"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.63);
      SetPropertyInfo( phenotype_to_atom_type[ "C24"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.63);
      SetPropertyInfo( phenotype_to_atom_type[ "C34"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.68);
      SetPropertyInfo( phenotype_to_atom_type[ "Mg12"], AtomTypeData::e_CovalentRadiusDoubleBond, 1.10);
      SetPropertyInfo( phenotype_to_atom_type[ "N12"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.53);
      SetPropertyInfo( phenotype_to_atom_type[ "N23"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.62);
      SetPropertyInfo( phenotype_to_atom_type[ "N24"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.62);
      SetPropertyInfo( phenotype_to_atom_type[ "N34"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.65);
      SetPropertyInfo( phenotype_to_atom_type[ "N35"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.68);
      SetPropertyInfo( phenotype_to_atom_type[ "N45"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.65);
      SetPropertyInfo( phenotype_to_atom_type[ "O12"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.54);
      SetPropertyInfo( phenotype_to_atom_type[ "O23"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.55);
      SetPropertyInfo( phenotype_to_atom_type[ "P23"], AtomTypeData::e_CovalentRadiusDoubleBond, 1.10);
      SetPropertyInfo( phenotype_to_atom_type[ "P24"], AtomTypeData::e_CovalentRadiusDoubleBond, 1.11);
      SetPropertyInfo( phenotype_to_atom_type[ "P34"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.97);
      SetPropertyInfo( phenotype_to_atom_type[ "P35"], AtomTypeData::e_CovalentRadiusDoubleBond, 1.02);
      SetPropertyInfo( phenotype_to_atom_type[ "P45"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.94);
      SetPropertyInfo( phenotype_to_atom_type[ "S12"], AtomTypeData::e_CovalentRadiusDoubleBond, 1.00);
      SetPropertyInfo( phenotype_to_atom_type[ "S23"], AtomTypeData::e_CovalentRadiusDoubleBond, 1.01);
      SetPropertyInfo( phenotype_to_atom_type[ "S34"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.95);
      SetPropertyInfo( phenotype_to_atom_type[ "S46"], AtomTypeData::e_CovalentRadiusDoubleBond, 0.89);
      SetPropertyInfo( phenotype_to_atom_type[ "Se12"], AtomTypeData::e_CovalentRadiusDoubleBond, 1.16);
      SetPropertyInfo( phenotype_to_atom_type[ "Si24"], AtomTypeData::e_CovalentRadiusDoubleBond, 1.17);
      SetPropertyInfo( phenotype_to_atom_type[ "Si34"], AtomTypeData::e_CovalentRadiusDoubleBond, 1.10);
      SetPropertyInfo( phenotype_to_atom_type[ "C13"], AtomTypeData::e_CovalentRadiusTripleBond, 0.58);
      SetPropertyInfo( phenotype_to_atom_type[ "C24"], AtomTypeData::e_CovalentRadiusTripleBond, 0.60);
      SetPropertyInfo( phenotype_to_atom_type[ "N13"], AtomTypeData::e_CovalentRadiusTripleBond, 0.55);
      SetPropertyInfo( phenotype_to_atom_type[ "N24"], AtomTypeData::e_CovalentRadiusTripleBond, 0.54);
      SetPropertyInfo( phenotype_to_atom_type[ "N35"], AtomTypeData::e_CovalentRadiusTripleBond, 0.54);
      SetPropertyInfo( phenotype_to_atom_type[ "O13"], AtomTypeData::e_CovalentRadiusTripleBond, 0.55);
      SetPropertyInfo( phenotype_to_atom_type[ "P13"], AtomTypeData::e_CovalentRadiusTripleBond, 0.94);
      SetPropertyInfo( phenotype_to_atom_type[ "P35"], AtomTypeData::e_CovalentRadiusTripleBond, 1.00);
      SetPropertyInfo( phenotype_to_atom_type[ "S13"], AtomTypeData::e_CovalentRadiusTripleBond, 0.94);
      SetPropertyInfo( phenotype_to_atom_type[ "S46"], AtomTypeData::e_CovalentRadiusTripleBond, 0.72);
      SetPropertyInfo( phenotype_to_atom_type[ "Si24"], AtomTypeData::e_CovalentRadiusTripleBond, 1.03);
      SetPropertyInfo( phenotype_to_atom_type[ "As33"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.96);
      SetPropertyInfo( phenotype_to_atom_type[ "B23"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.90);
      SetPropertyInfo( phenotype_to_atom_type[ "B33"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.77);
      SetPropertyInfo( phenotype_to_atom_type[ "B34"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.81);
      SetPropertyInfo( phenotype_to_atom_type[ "C33"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.69);
      SetPropertyInfo( phenotype_to_atom_type[ "C34"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.69);
      SetPropertyInfo( phenotype_to_atom_type[ "N22"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.68);
      SetPropertyInfo( phenotype_to_atom_type[ "N23"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.64);
      SetPropertyInfo( phenotype_to_atom_type[ "N24"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.67);
      SetPropertyInfo( phenotype_to_atom_type[ "N33"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.68);
      SetPropertyInfo( phenotype_to_atom_type[ "N34"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.66);
      SetPropertyInfo( phenotype_to_atom_type[ "N35"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.68);
      SetPropertyInfo( phenotype_to_atom_type[ "N45"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.62);
      SetPropertyInfo( phenotype_to_atom_type[ "O22"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.68);
      SetPropertyInfo( phenotype_to_atom_type[ "O33"], AtomTypeData::e_CovalentRadiusAromaticBond, 0.75);
      SetPropertyInfo( phenotype_to_atom_type[ "P23"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.05);
      SetPropertyInfo( phenotype_to_atom_type[ "P24"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.10);
      SetPropertyInfo( phenotype_to_atom_type[ "P33"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.11);
      SetPropertyInfo( phenotype_to_atom_type[ "P34"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.12);
      SetPropertyInfo( phenotype_to_atom_type[ "P45"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.10);
      SetPropertyInfo( phenotype_to_atom_type[ "S22"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.03);
      SetPropertyInfo( phenotype_to_atom_type[ "S33"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.11);
      SetPropertyInfo( phenotype_to_atom_type[ "S34"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.19);
      SetPropertyInfo( phenotype_to_atom_type[ "S46"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.11);
      SetPropertyInfo( phenotype_to_atom_type[ "Se22"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.18);
      SetPropertyInfo( phenotype_to_atom_type[ "Si34"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.09);
      SetPropertyInfo( phenotype_to_atom_type[ "Te22"], AtomTypeData::e_CovalentRadiusAromaticBond, 1.39);

      SetPropertyInfo( phenotype_to_atom_type[ "As33"], AtomTypeData::e_VdWaalsRadiusCSD, 1.39);
      SetPropertyInfo( phenotype_to_atom_type[ "Al33"], AtomTypeData::e_VdWaalsRadiusCSD, 1.80);
      SetPropertyInfo( phenotype_to_atom_type[ "B33"], AtomTypeData::e_VdWaalsRadiusCSD, 1.25);
      SetPropertyInfo( phenotype_to_atom_type[ "B34"], AtomTypeData::e_VdWaalsRadiusCSD, 1.4);
      SetPropertyInfo( phenotype_to_atom_type[ "B44"], AtomTypeData::e_VdWaalsRadiusCSD, 1.5);
      SetPropertyInfo( phenotype_to_atom_type[ "Br11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.62);
      SetPropertyInfo( phenotype_to_atom_type[ "C13"], AtomTypeData::e_VdWaalsRadiusCSD, 1.30);
      SetPropertyInfo( phenotype_to_atom_type[ "C23"], AtomTypeData::e_VdWaalsRadiusCSD, 1.30);
      SetPropertyInfo( phenotype_to_atom_type[ "C24"], AtomTypeData::e_VdWaalsRadiusCSD, 1.33);
      SetPropertyInfo( phenotype_to_atom_type[ "C33"], AtomTypeData::e_VdWaalsRadiusCSD, 1.35);
      SetPropertyInfo( phenotype_to_atom_type[ "C34"], AtomTypeData::e_VdWaalsRadiusCSD, 1.35);
      SetPropertyInfo( phenotype_to_atom_type[ "C44"], AtomTypeData::e_VdWaalsRadiusCSD, 1.14);
      SetPropertyInfo( phenotype_to_atom_type[ "Cl11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.49);
      SetPropertyInfo( phenotype_to_atom_type[ "F11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.16);
      SetPropertyInfo( phenotype_to_atom_type[ "I11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.74);
      SetPropertyInfo( phenotype_to_atom_type[ "K11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.75);
      SetPropertyInfo( phenotype_to_atom_type[ "Li11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.25);
      SetPropertyInfo( phenotype_to_atom_type[ "Na11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.6);
      SetPropertyInfo( phenotype_to_atom_type[ "N12"], AtomTypeData::e_VdWaalsRadiusCSD, 1.55);
      SetPropertyInfo( phenotype_to_atom_type[ "N13"], AtomTypeData::e_VdWaalsRadiusCSD, 1.67);
      SetPropertyInfo( phenotype_to_atom_type[ "N22"], AtomTypeData::e_VdWaalsRadiusCSD, 1.16);
      SetPropertyInfo( phenotype_to_atom_type[ "N23"], AtomTypeData::e_VdWaalsRadiusCSD, 1.16);
      SetPropertyInfo( phenotype_to_atom_type[ "N24"], AtomTypeData::e_VdWaalsRadiusCSD, 1.32);
      SetPropertyInfo( phenotype_to_atom_type[ "N33"], AtomTypeData::e_VdWaalsRadiusCSD, 1.27);
      SetPropertyInfo( phenotype_to_atom_type[ "N34"], AtomTypeData::e_VdWaalsRadiusCSD, 1.26);
      SetPropertyInfo( phenotype_to_atom_type[ "N35"], AtomTypeData::e_VdWaalsRadiusCSD, 1.39);
      SetPropertyInfo( phenotype_to_atom_type[ "N44"], AtomTypeData::e_VdWaalsRadiusCSD, 1.30);
      SetPropertyInfo( phenotype_to_atom_type[ "N45"], AtomTypeData::e_VdWaalsRadiusCSD, 1.34);
      SetPropertyInfo( phenotype_to_atom_type[ "O11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.18);
      SetPropertyInfo( phenotype_to_atom_type[ "O12"], AtomTypeData::e_VdWaalsRadiusCSD, 1.14);
      SetPropertyInfo( phenotype_to_atom_type[ "O13"], AtomTypeData::e_VdWaalsRadiusCSD, 1.15);
      SetPropertyInfo( phenotype_to_atom_type[ "O22"], AtomTypeData::e_VdWaalsRadiusCSD, 1.16);
      SetPropertyInfo( phenotype_to_atom_type[ "O23"], AtomTypeData::e_VdWaalsRadiusCSD, 1.34);
      SetPropertyInfo( phenotype_to_atom_type[ "O33"], AtomTypeData::e_VdWaalsRadiusCSD, 1.20);
      SetPropertyInfo( phenotype_to_atom_type[ "P13"], AtomTypeData::e_VdWaalsRadiusCSD, 1.64);
      SetPropertyInfo( phenotype_to_atom_type[ "P23"], AtomTypeData::e_VdWaalsRadiusCSD, 1.64);
      SetPropertyInfo( phenotype_to_atom_type[ "P24"], AtomTypeData::e_VdWaalsRadiusCSD, 1.50);
      SetPropertyInfo( phenotype_to_atom_type[ "P33"], AtomTypeData::e_VdWaalsRadiusCSD, 1.26);
      SetPropertyInfo( phenotype_to_atom_type[ "P34"], AtomTypeData::e_VdWaalsRadiusCSD, 1.65);
      SetPropertyInfo( phenotype_to_atom_type[ "P35"], AtomTypeData::e_VdWaalsRadiusCSD, 1.50);
      SetPropertyInfo( phenotype_to_atom_type[ "P44"], AtomTypeData::e_VdWaalsRadiusCSD, 1.40);
      SetPropertyInfo( phenotype_to_atom_type[ "P45"], AtomTypeData::e_VdWaalsRadiusCSD, 1.57);
      SetPropertyInfo( phenotype_to_atom_type[ "S11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.62);
      SetPropertyInfo( phenotype_to_atom_type[ "S12"], AtomTypeData::e_VdWaalsRadiusCSD, 1.39);
      SetPropertyInfo( phenotype_to_atom_type[ "S22"], AtomTypeData::e_VdWaalsRadiusCSD, 1.40);
      SetPropertyInfo( phenotype_to_atom_type[ "S23"], AtomTypeData::e_VdWaalsRadiusCSD, 1.36);
      SetPropertyInfo( phenotype_to_atom_type[ "S33"], AtomTypeData::e_VdWaalsRadiusCSD, 1.36);
      SetPropertyInfo( phenotype_to_atom_type[ "S34"], AtomTypeData::e_VdWaalsRadiusCSD, 1.51);
      SetPropertyInfo( phenotype_to_atom_type[ "S46"], AtomTypeData::e_VdWaalsRadiusCSD, 1.69);
      SetPropertyInfo( phenotype_to_atom_type[ "S66"], AtomTypeData::e_VdWaalsRadiusCSD, 1.78);
      SetPropertyInfo( phenotype_to_atom_type[ "Se12"], AtomTypeData::e_VdWaalsRadiusCSD, 1.85);
      SetPropertyInfo( phenotype_to_atom_type[ "Se22"], AtomTypeData::e_VdWaalsRadiusCSD, 1.26);
      SetPropertyInfo( phenotype_to_atom_type[ "Si24"], AtomTypeData::e_VdWaalsRadiusCSD, 1.24);
      SetPropertyInfo( phenotype_to_atom_type[ "Si33"], AtomTypeData::e_VdWaalsRadiusCSD, 1.24);
      SetPropertyInfo( phenotype_to_atom_type[ "Si34"], AtomTypeData::e_VdWaalsRadiusCSD, 1.76);
      SetPropertyInfo( phenotype_to_atom_type[ "Si44"], AtomTypeData::e_VdWaalsRadiusCSD, 1.18);
      SetPropertyInfo( phenotype_to_atom_type[ "Te22"], AtomTypeData::e_VdWaalsRadiusCSD, 1.39);

      // Hydrogen is a special case.  It's radius cannot be obtained from x-ray data, in which H cannot ordinarily be
      // discerned.  Instead, use values obtained from neutron diffraction experiments
      // http://pubs.acs.org/doi/pdf/10.1021/jp953141%2B
      SetPropertyInfo( phenotype_to_atom_type[ "H11"], AtomTypeData::e_VdWaalsRadiusCSD, 1.09);

      // See comment above and http://pubs.rsc.org/en/content/articlepdf/2008/dt/b801115j
      SetPropertyInfo( phenotype_to_atom_type[ "H11"], AtomTypeData::e_CovalentRadiusSingleBond, 0.31);
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief virtual copy constructor
    //! @return pointer to new BondLengths
    BondLengths *BondLengths::Clone() const
    {
      return new BondLengths();
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief get name of the current class
    //! @return name of the class
    const std::string &BondLengths::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief get the average bond length of two atom types joined by a bond of specified type
    //! @param ATOM_TYPE_A either atom type in the bond
    //! @param BOND_ORDER_OR_AROMATIC bond type in notation: 1=single, 2=double, 3=triple, 4=aromatic
    //! @param ATOM_TYPE_B the other atom type in the bond
    //! @return return the estimated covalent radius of the atom, in angstroms
    double BondLengths::GetBondLength
    (
      const AtomType &ATOM_TYPE_A,
      const size_t &BOND_ORDER_OR_AROMATIC,
      const AtomType &ATOM_TYPE_B
    )
    {
      return GetCovalentRadius( ATOM_TYPE_A, BOND_ORDER_OR_AROMATIC)
             + GetCovalentRadius( ATOM_TYPE_B, BOND_ORDER_OR_AROMATIC);
    }

    //! @brief Get the covalent radius of an atom about a specific bond type
    //! @param ATOM_TYPE the atom type for which to estimate the covalent radius
    //! @param BOND_ORDER_OR_AROMATIC bond type in notation: 1=single, 2=double, 3=triple, 4=aromatic
    //! @return return the estimated covalent radius of the atom, in angstroms
    double BondLengths::GetCovalentRadius( const AtomType &ATOM_TYPE, const size_t &BOND_ORDER_OR_AROMATIC)
    {
      return ATOM_TYPE->GetAtomTypeProperty( BondOrderProperty( BOND_ORDER_OR_AROMATIC));
    }

    //! @brief Get the average covalent radius for a particular bond of an atom
    //! @param ELEMENT_TYPE the element type of the atom
    //! @param NUMBER_BONDS the total number of bonds for the atom
    //! @param NUMBER_ELECTRONS_IN_BONDS the total # of electrons in bonds around the atom
    //! @param BOND_ORDER_OR_AROMATIC bond type in sdf notation (1=single, 2=double, 3=triple, 4=aromatic)
    //! @return return the estimated covalent radius of the atom, in angstroms
    double BondLengths::GetCovalentRadius
    (
      const ElementType &ELEMENT_TYPE,
      const size_t &NUMBER_BONDS,
      const size_t &NUMBER_ELECTRONS_IN_BONDS,
      const size_t &BOND_ORDER_OR_AROMATIC
    )
    {
      PossibleAtomTypesForAtom possible_types( ELEMENT_TYPE, NUMBER_BONDS, NUMBER_ELECTRONS_IN_BONDS, 0, false);
      return possible_types.GetMostStableType()->GetAtomTypeProperty( BondOrderProperty( BOND_ORDER_OR_AROMATIC));
    }

    //! @brief Get the average covalent radius of all the bonds about an atom
    //! @param ATOM the atom for which to estimate the covalent radius
    //! @return return the estimated covalent radius of the atom, in angstroms
    double BondLengths::GetAverageCovalentRadius( const AtomConstitutionalInterface &ATOM)
    {
      size_t counts[ 4] = { 0, 0, 0, 0};

      // add valence bonds
      const storage::Vector< ConstitutionalBondType> &valence_bonds( ATOM.GetValenceBonds());
      for
      (
        storage::Vector< ConstitutionalBondType>::const_iterator
          itr( valence_bonds.Begin()), itr_end( valence_bonds.End());
        itr != itr_end;
        ++itr
      )
      {
        ++counts[ ( *itr)->GetBondData( ConstitutionalBondTypeData::e_BondOrderOrAromatic) - 1];
      }

      for
      (
        storage::Vector< BondConstitutional>::const_iterator
          itr( ATOM.GetBonds().Begin()), itr_end( ATOM.GetBonds().End());
        itr != itr_end;
        ++itr
      )
      {
        ++counts[ itr->GetBondType()->GetBondData( ConstitutionalBondTypeData::e_BondOrderOrAromatic) - 1];
      }

      return GetAveCovalentRadius( ATOM.GetAtomType(), counts[ 0], counts[ 1], counts[ 2], counts[ 3]);
    }

    //! @brief Get the average covalent radius of all the bonds about an atom
    //! @param ATOM the atom for which to estimate the covalent radius
    //! @return return the estimated covalent radius of the atom, in angstroms
    double BondLengths::GetAverageCovalentRadius( const AtomConfigurationalInterface &ATOM)
    {
      size_t counts[ 4] = { 0, 0, 0, 0};

      // add valence bonds
      const storage::Vector< ConstitutionalBondType> &valence_bonds( ATOM.GetValenceBonds());
      for
      (
        storage::Vector< ConstitutionalBondType>::const_iterator
          itr( valence_bonds.Begin()), itr_end( valence_bonds.End());
        itr != itr_end;
        ++itr
      )
      {
        ++counts[ ( *itr)->GetBondData( ConstitutionalBondTypeData::e_BondOrderOrAromatic) - 1];
      }

      for
      (
        storage::Vector< BondConfigurational>::const_iterator
          itr( ATOM.GetBonds().Begin()), itr_end( ATOM.GetBonds().End());
        itr != itr_end;
        ++itr
      )
      {
        ++counts[ itr->GetBondType()->GetBondData( ConfigurationalBondTypeData::e_BondOrderOrAromatic) - 1];
      }

      return GetAveCovalentRadius( ATOM.GetAtomType(), counts[ 0], counts[ 1], counts[ 2], counts[ 3]);
    }

    //! @brief Get the average covalent radius of all the bonds about an atom
    //! @param ATOM the atom for which to estimate the covalent radius
    //! @return return the estimated covalent radius of the atom, in angstroms
    double BondLengths::GetAverageCovalentRadius( const AtomConformationalInterface &ATOM)
    {
      size_t counts[ 4] = { 0, 0, 0, 0};

      // add valence bonds
      const storage::Vector< ConstitutionalBondType> &valence_bonds( ATOM.GetValenceBonds());
      for
      (
        storage::Vector< ConstitutionalBondType>::const_iterator
          itr( valence_bonds.Begin()), itr_end( valence_bonds.End());
        itr != itr_end;
        ++itr
      )
      {
        ++counts[ ( *itr)->GetBondData( ConstitutionalBondTypeData::e_BondOrderOrAromatic) - 1];
      }

      for
      (
        storage::Vector< BondConformational>::const_iterator
          itr( ATOM.GetBonds().Begin()), itr_end( ATOM.GetBonds().End());
        itr != itr_end;
        ++itr
      )
      {
        ++counts[ itr->GetBondType()->GetBondData( ConfigurationalBondTypeData::e_BondOrderOrAromatic) - 1];
      }

      return GetAveCovalentRadius( ATOM.GetAtomType(), counts[ 0], counts[ 1], counts[ 2], counts[ 3]);
    }

  ////////////////
  // operations //
  ////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief Estimate the covalent radius of an atom
    //! @param ATOM_TYPE the atom type
    //! @param SINGLE_BONDS the number of single bonds for this atom
    //! @param DOUBLE_BONDS the number of double bonds for this atom
    //! @param TRIPLE_BONDS the number of triple bonds for this atom
    //! @param AROMATIC_BONDS the number of aromatic bonds for this atom
    //! @return return the estimated covalent radius of the atom, in angstroms
    double BondLengths::GetAveCovalentRadius
    (
      const AtomType &ATOM_TYPE,
      const size_t &SINGLE_BONDS,
      const size_t &DOUBLE_BONDS,
      const size_t &TRIPLE_BONDS,
      const size_t &AROMATIC_BONDS
    )
    {
      // handle the case of undefined atom types
      if( !ATOM_TYPE.IsDefined() || !ATOM_TYPE->IsGasteigerAtomType())
      {
        return util::GetUndefined< double>();
      }

      // summate covalent radius by bond order
      double sum_covalent_radius( 0.0);

      if( SINGLE_BONDS)
      {
        sum_covalent_radius += ATOM_TYPE->GetAtomTypeProperty( AtomTypeData::e_CovalentRadiusSingleBond) * SINGLE_BONDS;
      }
      if( DOUBLE_BONDS)
      {
        sum_covalent_radius += ATOM_TYPE->GetAtomTypeProperty( AtomTypeData::e_CovalentRadiusDoubleBond) * DOUBLE_BONDS;
      }
      if( TRIPLE_BONDS)
      {
        sum_covalent_radius += ATOM_TYPE->GetAtomTypeProperty( AtomTypeData::e_CovalentRadiusTripleBond) * TRIPLE_BONDS;
      }
      if( AROMATIC_BONDS)
      {
        sum_covalent_radius += ATOM_TYPE->GetAtomTypeProperty( AtomTypeData::e_CovalentRadiusAromaticBond) * AROMATIC_BONDS;
      }

      // return the average covalent bond length
      return sum_covalent_radius / double( ATOM_TYPE->GetNumberBonds());
    }

    //! @brief solve for VDW radii
    //! @param SEP_MAP map containing strings with two atom types each and a set of distances between those types
    //! @return Map containing VDW radii computed for each atom type (assuming lp_solve is installed)
    storage::Map< std::string, double> BondLengths::ComputeVdwRadii
    (
      storage::Map< std::string, storage::Vector< double> > &RADII,
      const storage::Map< std::string, double> &MIN_VALUES
    )
    {
      std::stringstream output_str;

      // Map from VDW atom type to count of occurances; used for weighting
      storage::Map< std::string, size_t> vdw_counts;
      for
      (
        storage::Map< std::string, storage::Vector< double> >::const_iterator
          itr( RADII.Begin()), itr_end( RADII.End());
        itr != itr_end;
        ++itr
      )
      {
        if( itr->second.GetSize() < 5)
        {
          continue;
        }
        storage::Vector< std::string> substrings( util::SplitString( itr->first, " "));
        vdw_counts[ substrings( 0)] += itr->second.GetSize();
        if( substrings( 0) != substrings( 1))
        {
          vdw_counts[ substrings( 1)] += itr->second.GetSize();
        }
      }
      for
      (
        storage::Map< std::string, storage::Vector< double> >::iterator
          itr( RADII.Begin()), itr_end( RADII.End());
        itr != itr_end;
        ++itr
      )
      {
        if( itr->second.GetSize() < 5)
        {
          continue;
        }
        storage::Vector< std::string> substrings( util::SplitString( itr->first, " "));
        if( vdw_counts[ substrings( 0)] < 100 || vdw_counts[ substrings( 1)] < 100)
        {
          continue;
        }

        itr->second.Sort( std::less< double>());

        // in most datasets, the coordinates are noisy, so discard the first 0.5% or 100 entries (whichever is fewer)
        // always ignore the 1st entry
        size_t index( std::min( std::max( itr->second.GetSize() / size_t( 20), size_t( 1)), size_t( 10)));

        // now extrapolate back from 2x the index to find the expected min distance, excluding outliers
        const size_t twice_index( index ? index * 2 : 1);
        double expected_min( std::max( itr->second( 0), 2.0 * itr->second( index) - itr->second( twice_index)));
        BCL_MessageStd
        (
          itr->first + " counts: " + util::Format()( itr->second.GetSize())
          + " index: " + util::Format()( index)
          + " expected min: " + util::Format()( expected_min)
          + " actual min: " + util::Format()( itr->second( 0))
          + " at index: " + util::Format()( itr->second( index))
          + " at 2x index: " + util::Format()( itr->second( twice_index))
        );

        if( substrings( 0) != substrings( 1))
        {
          output_str << substrings( 0) << " + " << substrings( 1) << " <= " << expected_min << ";\n";
        }
        else
        {
          output_str << substrings( 0) << " <= " << expected_min / 2.0 << ";\n";
        }
      }
      std::stringstream optimization_str;

      // maximize the radii sum, subject to the constraints that :
      // each radii is at least as large as the covalent radius
      // sums of van der waals radii seen in the input file are (essentially) always less than the minimal
      // distance seen in the input file
      optimization_str << "max: ";
      bool is_first( true);
      size_t number_atom_types( 0);
      for
      (
        storage::Map< std::string, size_t>::const_iterator itr( vdw_counts.Begin()), itr_end( vdw_counts.End());
        itr != itr_end;
        ++itr
      )
      {
        if( itr->second < size_t( 5))
        {
          continue;
        }
        ++number_atom_types;
        if( !is_first)
        {
          optimization_str << " + ";
        }
        else
        {
          is_first = false;
        }
        optimization_str << sqrt( double( itr->second)) << ' ' << itr->first;
        output_str << std::max( MIN_VALUES.GetValue( itr->first), 0.5) << " <= " << itr->first << " <= 3.5;\n";
      }

      optimization_str << ";\n";

      io::OFStream output;
      const std::string vdw_filename( "van_der_waals_radii.lp");
      const std::string vdw_soln_filename( vdw_filename + ".model");
      io::File::MustOpenOFStream( output, vdw_filename);
      output << optimization_str.str() << output_str.str() << std::endl;
      io::File::CloseClearFStream( output);

      // run the command to solve the system with lp_solve
      // do not rely on the return status of system; system returns 0 even if the command was not found
      // Instead, check the output file for the correct information
      const std::string command( "lp_solve " + vdw_filename + " > " + vdw_soln_filename);
      system( command.c_str());

      // read in the model
      io::IFStream input_model;
      io::File::MustOpenIFStream( input_model, vdw_soln_filename);
      storage::Vector< storage::Vector< std::string> > vdw_radii_model
      (
        util::SplittedStringLineListFromIStream( input_model, " ")
      );
      io::File::CloseClearFStream( input_model);
      if( vdw_radii_model.GetSize() == 0)
      {
        BCL_MessageStd
        (
          "lp_solve was not available to determine the vdw radii; download it from http://lpsolve.sourceforge.net/5.5/ and ensure that it is in your $PATH variable"
        );
        return storage::Map< std::string, double>();
      }

      storage::Map< std::string, double> model_radii;
      for
      (
        storage::Vector< storage::Vector< std::string> >::const_iterator
          itr( vdw_radii_model.Begin()), itr_end( vdw_radii_model.End());
        itr != itr_end;
        ++itr
      )
      {
        // skip non-solution lines
        if
        (
          itr->GetSize() != size_t( 2)
          || !util::IsNumerical( itr->LastElement())
          || !vdw_counts.Has( itr->FirstElement())
        )
        {
          continue;
        }

        // get the atom type
        const std::string atom_type( itr->FirstElement());

        // remove the atom type from vdw counts
        vdw_counts.RemoveElement( vdw_counts.Find( atom_type));

        // get the radius
        const double radius( util::ConvertStringToNumericalValue< double>( itr->LastElement()));

        model_radii[ atom_type] = radius;
      }

      std::stringstream missing_atom_types;
      size_t n_missing( 0);
      for
      (
        storage::Map< std::string, size_t>::const_iterator itr( vdw_counts.Begin()), itr_end( vdw_counts.End());
        itr != itr_end;
        ++itr
      )
      {
        if( itr->second >= size_t( 5))
        {
          ++n_missing;
          missing_atom_types << itr->first << ' ';
        }
      }
      if( n_missing)
      {
        BCL_MessageStd
        (
          "Solution was missing values for these atom types: " + missing_atom_types.str()
        );
      }
      return model_radii;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &BondLengths::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream
    //! @param INDENT number of indentations
    //! @return ostream which was written to
    std::ostream &BondLengths::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  } // namespace chemistry
} // namespace bcl

