// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_add_parabolic_loops.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_atom.h"
#include "opti/bcl_opti_approximator_root_regula_falsi.h"
#include "opti/bcl_opti_criterion_combine.h"
#include "opti/bcl_opti_criterion_convergence_argument.h"
#include "opti/bcl_opti_criterion_number_iterations.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //!
    //! @class NormOptimization
    //! @brief takes a normalization factor as input and calculates the parabolic arc length - desired arc length
    //! @detail the arc length is computed using the formula:
    //!     L = 1/4a[ ln((d2+s2)/(d1+s1)) + d2s2 -d1s1],
    //!     l1 = 0.0              l2 = 1.0
    //!      a = norm_factor       b = -(norm_factor + SSE Distance)
    //!     d1 = 2al1 + b         d2 = 2al2 + b
    //!     s1 = Sqrt( 1 + d1^2)  s2 = Sqrt( 1 + d2^2)
    //!AddParabolicLoops::
    //! @see @link example_fold_add_parabolic_loops.cpp @endlink
    //! @author putnamdk, mendenjl
    //! @date Aug 28, 2012
    //!
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class BCL_API NormOptimization :
      public math::FunctionInterfaceSerializable< double, double>
    {

    private:

    //////////
    // data //
    //////////

      double m_DesiredDistance; //!< The desired parabolic length
      double m_SSEDistance;     //!< The linear distance between sse's

    public:

    //////////
    // constructors //
    //////////

      //! @brief Clone function
      //! @return pointer to new NormOptimization
      NormOptimization *Clone() const
      {
        return new NormOptimization( *this);
      }

      //! @brief constructor from a linear distance between sse's
      //! @param DESIRED_DISTANCE double which is the desired length of the parabolic path between two SSE's
      //! @param SSE_DISTANCE double which is the linear distance between two SSE's
      NormOptimization( const double DESIRED_DISTANCE, const double SSE_DISTANCE) :
        m_DesiredDistance( DESIRED_DISTANCE),
        m_SSEDistance( SSE_DISTANCE)
      {
      }

      //! @brief returns class name
      //! @return the class name as const ref std::string
      const std::string &GetClassIdentifier() const
      {
        // Get BCL Standardized Class name
        return GetStaticClassName( *this);
      }

      //! @brief read from std::istream
      //! @param ISTREAM input stream
      //! @return istream which was read from
      std::istream &Read( std::istream &ISTREAM)
      {
        // return the stream
        return ISTREAM;
      }

      //! @brief write to std::ostream
      //! @param OSTREAM output stream to write to
      //! @param INDENT number of indentations
      //! @return outputstream which was written to
      std::ostream &Write( std::ostream &OSTREAM, const size_t INDENT) const
      {
        // return the stream
        return OSTREAM;
      }

      //! @brief takes a normalization factor as input and calculates the parabolic arc length - desired arc length
      //! @detail the arc length is computed using the formula:
      //!     L = 1/4a[ ln((d2+s2)/(d1+s1)) + d2s2 -d1s1],
      //!     l1 = 0.0              l2 = 1.0
      //!      a = norm_factor       b = -(norm_factor + SSE Distance)
      //!     d1 = 2al1 + b         d2 = 2al2 + b
      //!     s1 = Sqrt( 1 + d1^2)  s2 = Sqrt( 1 + d2^2)
      //! @param ARGUMENT a given normalization factor
      //! @return the parabolic arc length - the desired arc length for a given normalization factor
      double operator()( const double &ARGUMENT) const
      {
        const double a( ARGUMENT);
        const double b( -( ARGUMENT + m_SSEDistance));

        const double partial_derivative( 2 * a + b);

        const double intermediate_1( math::Sqrt( 1 + math::Sqr( b)));
        const double intermediate_2( math::Sqrt( 1 + math::Sqr( partial_derivative)));

        const double constant( 1.0 / ( 4.0 * a));
        const double log_part( std::log( ( partial_derivative + intermediate_2) / ( b + intermediate_1)));
        const double parabolic_length( constant * ( log_part + ( partial_derivative * intermediate_2 - b * intermediate_1)));

        return parabolic_length - m_DesiredDistance;
      }
    };

  //////////
  // data //
  //////////

    //! single instance of that class
    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> AddParabolicLoops::s_Instance
    (
      GetObjectInstances().AddInstance( new AddParabolicLoops( true))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Constructor that takes a bool
    //! @param LOOPS bool value to represent loops that are not present in the protein model
    AddParabolicLoops::AddParabolicLoops( const bool &ANALYTIC_NORM_FACTOR, const bool &APPROXIMATE_CB) :
      m_DetermineAnalyticNormFactor( ANALYTIC_NORM_FACTOR),
      m_ApproximateCB( APPROXIMATE_CB)
    {
    }

    //! @brief Clone function
    //! @return pointer add parabolic loops
    AddParabolicLoops *AddParabolicLoops::Clone() const
    {
      return new AddParabolicLoops( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AddParabolicLoops::GetClassIdentifier() const
    {
      // Get BCL Standardized Class name
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief TODO
    //! @param PROTEIN_MODEL - protein model
    //! @param FIRST_RESIDUE, LAST_RESIDUE, first and last residues for the loop
    //! @return returns the coordinates for each atom in the loop
    storage::Vector< storage::Pair< biol::AAType, linal::Vector3D> >
    AddParabolicLoops::GetLoopCoordinates
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      storage::Vector< storage::Pair< biol::AAType, linal::Vector3D> > loop_coordinates_and_atom_types;

      // iterate over the chains
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator chain_itr( PROTEIN_MODEL.GetChains().Begin()),
          chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // get all the structured sses
        const util::SiPtrVector< const assemble::SSE> structured_sses
        (
          ( *chain_itr)->GetSSEs( storage::Set< biol::SSType>( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND))
        );

        // if structured_sses are empty
        if( structured_sses.IsEmpty())
        {
          // warn user and return empty vector
          BCL_MessageStd( "No structured SSEs found in protein model");
          return loop_coordinates_and_atom_types;
        }

        // get the first and last sse
        const util::SiPtr< const assemble::SSE> sp_first_sse( structured_sses.FirstElement());
        const util::SiPtr< const assemble::SSE> sp_last_sse( structured_sses.LastElement());

        int prev_seqid( sp_first_sse->GetLastAA()->GetSeqID());
        linal::Vector3D prev_sse_end( sp_first_sse->GetSSEGeometries().LastElement()->EndOfZ());
        linal::Vector3D prev_sse_ctr( sp_first_sse->GetSSEGeometries().LastElement()->GetCenter());

        // iterate over the SSEs
        for
        (
          storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
            sse_itr( ( *chain_itr)->GetData().Begin()), sse_itr_end( ( *chain_itr)->GetData().End());
          sse_itr != sse_itr_end; ++sse_itr
        )
        {
          // if estimating loops and this sse is not a coil
          if( ( *sse_itr)->GetType()->IsStructured())
          {
            // store the begin and end id
            const int begin_seqid( ( *sse_itr)->GetFirstAA()->GetSeqID());

            // if there is any region between this and the previous sse
            if( begin_seqid > prev_seqid + 1)
            {
              // get the sequence
              const util::ShPtr< biol::AASequence> &chain_sequence( ( *chain_itr)->GetSequence());
              biol::AASequence sub_sequence
              (
                chain_sequence->SubSequence( prev_seqid, begin_seqid - prev_seqid - 1)
              );

              // Calculate the length of the subsequence
              const size_t sub_sequence_length( sub_sequence.GetSize());

              //Calculate Vector
              const linal::Vector3D begin_coords( ( *sse_itr)->GetSSEGeometries().FirstElement()->BeginOfZ());

              // The coordinates will be approximated by parabolic loop building function
              // Calculate Vector pointing in the direction of the SSE by subtracting Initialize starting loop point
              const linal::Vector3D point_a( prev_sse_end);
              const linal::Vector3D center_a( prev_sse_ctr);
              const linal::Vector3D vector_a( point_a - center_a);

              // Get the direction of the vector pointing along the first SSE by diving all elements by the magnitude
              const linal::Vector3D dir_vector_a( vector_a / vector_a.Norm());

              // Initialize the end loop point
              // Calculate Vector pointing in the direction of the SSE by subtracting Initialize starting loop point
              const linal::Vector3D point_b( begin_coords);
              const linal::Vector3D center_b( ( *sse_itr)->GetSSEGeometries().FirstElement()->GetCenter());
              const linal::Vector3D vector_b( point_b - center_b);

              // Get the direction of the vector pointing along the second SSE by diving all elements by the magnitude
              const linal::Vector3D dir_vector_b( vector_b / vector_b.Norm());

              // Find the distance between points along the parabolic path.  This is a number between 0 and 1
              double distance = 1.0 / double( sub_sequence_length + 1);

              // Find the vector between Secondary Structure elements
              const linal::Vector3D vector_c( point_b - point_a);

              // Compute the distance between Secondary Structure elements
              const double sse_distance( vector_c.Norm());

              // Set the CB-CB spacing
              const double atom_distance( 3.2);

              // Compute the desired distance
              const double desired_distance( ( sub_sequence_length) * atom_distance);

              const double norm_factor
              (
                m_DetermineAnalyticNormFactor
                ? ComputeNormFactor( desired_distance, sse_distance)
                : ComputeNormalizationFactor( desired_distance, sse_distance, sub_sequence_length)
              );

              // Initialize the location of the point
              double location = 0.0;

              // Initialize the point to 0
              linal::Vector3D point( 0, 0, 0);

              BCL_MessageDbg( "Found loop with size: " + util::Format()( sub_sequence.GetData().GetSize()));

              // Iterate over the subsequence
              for
              (
                util::ShPtrVector< biol::AABase>::iterator sub_itr( sub_sequence.GetData().Begin()),
                  sub_itr_end( sub_sequence.GetData().End());
                sub_itr != sub_itr_end;
                ++sub_itr
              )
              {
                location += distance;
                point = ( 1.0 - location) * point_a + location * point_b +
                          norm_factor * location * ( 1.0 - location) *
                        ( ( 1.0 - location) * dir_vector_a + ( location * dir_vector_b));

                loop_coordinates_and_atom_types.PushBack
                (
                  storage::Pair< biol::AAType, linal::Vector3D>( ( *sub_itr)->GetType(), point)
                );
              }
            } // end loop region check

            // update previous variables
            prev_seqid = ( *sse_itr)->GetLastAA()->GetSeqID();
            prev_sse_end = ( *sse_itr)->GetSSEGeometries().LastElement()->EndOfZ();
            prev_sse_ctr = ( *sse_itr)->GetSSEGeometries().LastElement()->GetCenter();
          } // end loop estimation
        } // SSE iteration
      } // chain iteration

      return loop_coordinates_and_atom_types;
    }

    //! @brief takes a proteinModel as input and calculates an intensity using the debye formula
    //! @param PROTEIN_MODEL
    //! @return the intensity for a given q value
    assemble::ProteinModel AddParabolicLoops::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      util::ShPtr< assemble::ProteinModel> sp_tmp_protein( PROTEIN_MODEL.HardCopy());
      assemble::ProteinModel &tmp_protein( *sp_tmp_protein);

      storage::Vector< storage::Pair< biol::AAType, linal::Vector3D> > loop_coordinates_aa_types
      (
        GetLoopCoordinates( tmp_protein)
      );

      storage::Vector< storage::Pair< biol::AAType, linal::Vector3D> >::const_iterator
        itr_loop_coordinates_aa_types( loop_coordinates_aa_types.Begin()),
        itr_loop_coordinates_aa_types_end( loop_coordinates_aa_types.End());

      // iterate over the chains
      for
      (
        util::ShPtrVector< assemble::Chain>::iterator chain_itr( tmp_protein.GetChains().Begin()),
          chain_itr_end( tmp_protein.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        ( *chain_itr)->AddLoops( true, false);

        // get all the structured sses
        const util::SiPtrVector< const assemble::SSE> unstructured_sses
        (
          ( *chain_itr)->GetSSEs( biol::GetSSTypes().COIL)
        );

        // get the first and last residues' seq-ids
        const int first_seq_id( ( *chain_itr)->GetSequence()->GetData().FirstElement()->GetSeqID());
        const int last_seq_id( ( *chain_itr)->GetSequence()->GetData().LastElement()->GetSeqID());

        // iterate over the SSEs
        for
        (
          storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
            sse_itr( ( *chain_itr)->GetData().Begin()), sse_itr_end( ( *chain_itr)->GetData().End());
          sse_itr != sse_itr_end; ++sse_itr
        )
        {
          util::ShPtr< assemble::SSE> sse( *sse_itr);

          // if estimating loops and this sse is not a coil
          if( !sse->GetType()->IsStructured())
          {
            if( sse->GetLastAA()->GetSeqID() == last_seq_id || sse->GetFirstAA()->GetSeqID() == first_seq_id)
            {
              // skip terminal loops
              continue;
            }
            // Iterate over the subsequence
            BCL_MessageDbg( "Setting coordinates for loop with size: " + util::Format()( sse->GetData().GetSize()));
            math::RunningAverage< linal::Vector3D> loop_center;
            if( m_ApproximateCB)
            {
              size_t loop_size( sse->GetData().GetSize());
              auto itr_loop_coord_aa_types_cp( itr_loop_coordinates_aa_types);
              for( size_t pos( 0); pos < loop_size; ++pos, ++itr_loop_coord_aa_types_cp)
              {
                loop_center += itr_loop_coord_aa_types_cp->Second();
              }
            }

            for
            (
              util::ShPtrVector< biol::AABase>::iterator sub_itr( sse->GetData().Begin()),
                sub_itr_end( sse->GetData().End());
              sub_itr != sub_itr_end;
              ++sub_itr, ++itr_loop_coordinates_aa_types
            )
            {
              BCL_Assert
              (
                itr_loop_coordinates_aa_types != itr_loop_coordinates_aa_types_end,
                "Premature end to loop coordinates vector " + util::Format()( loop_coordinates_aa_types.GetSize())
                + " loop size " + util::Format()( sse->GetData().GetSize())
              );

              const linal::Vector3D &coordinate( itr_loop_coordinates_aa_types->Second());

              // create atoms at interpolated coordinates, set atoms in amino acid
              biol::Atom atom_n ( coordinate, biol::GetAtomTypes().N,  util::GetUndefinedSize_t(), -1.00);
              biol::Atom atom_ca( coordinate, biol::GetAtomTypes().CA, util::GetUndefinedSize_t(), -1.00);
              biol::Atom atom_c ( coordinate, biol::GetAtomTypes().C,  util::GetUndefinedSize_t(), -1.00);
              biol::Atom atom_o ( coordinate, biol::GetAtomTypes().O,  util::GetUndefinedSize_t(), -1.00);
              biol::Atom atom_cb( coordinate, biol::GetAtomTypes().CB, util::GetUndefinedSize_t(), -1.00);
              if( m_ApproximateCB)
              {
                atom_cb = biol::Atom( linal::UnitVector( loop_center, coordinate) * 1.4 + coordinate, biol::GetAtomTypes().CB, util::GetUndefinedSize_t(), -1.00);
              }
              ( **sub_itr).SetAtoms
              (
                util::SiPtrVector< const biol::Atom>::Create( atom_n, atom_ca, atom_c, atom_o, atom_cb)
              );
            }
          } // end loop estimation
        } // SSE iteration
      } // chain iteration

      BCL_Assert
      (
        itr_loop_coordinates_aa_types == itr_loop_coordinates_aa_types_end,
        "Should have used all the loop coordinates, but omitted "
        + util::Format()( std::distance( itr_loop_coordinates_aa_types, itr_loop_coordinates_aa_types_end))
        + " of them"
      );
      return tmp_protein;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AddParabolicLoops::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AddParabolicLoops::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return Computed Normalization factor for parabolic function - determines parabolic height.
    //! @param DESIRED_DISTANCE - this is how long you want the parabola to be
    //! @param SSE_DISTANCE - this is the distance between two sse's
    //! @return double normalization factor
    double AddParabolicLoops::ComputeNormFactor( const double &DESIRED_DISTANCE, const double &SSE_DISTANCE) const
    {
      // Set the distance from 0 the function will find
      const double root_tolerance( 0.0001);

      // Set Left point of interval, must be > 0
      const double border_left( root_tolerance);

      // Set Right point of interval, must be sufficient to contain x-intercept
      const double border_right( 5.0);

      // build the objective function
      util::ShPtr< math::FunctionInterfaceSerializable< double, double> >
        sp_function( new NormOptimization( DESIRED_DISTANCE, SSE_DISTANCE));

      // combine the termination criteria
      opti::CriterionCombine< double, double> criterion_combine;
      criterion_combine.InsertCriteria( opti::CriterionNumberIterations< double, double>( 200));
      criterion_combine.InsertCriteria( opti::CriterionConvergenceArgument< double, double>( 1, root_tolerance));

      // create regula falsi approximator
      opti::ApproximatorRootRegulaFalsi< double, double> approximator
      (
        *sp_function, criterion_combine, border_left, border_right
      );

      // approximate
      approximator.Approximate();

      // return the x-value that approximates the function value to 0 with the set tolerance
      return approximator.GetTracker().GetBest()->First();
    }

    double AddParabolicLoops::ComputeNormalizationFactor( const double &DESIRED_DISTANCE, const double &SSE_DISTANCE, const double &NAA) const
    {
      if( DESIRED_DISTANCE > SSE_DISTANCE)
      {
        const double height( 0.5 * math::Sqrt( math::Sqr( DESIRED_DISTANCE) - math::Sqr( SSE_DISTANCE)));
        return height;
      }
      return 0.0;
    }
  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_collector_loop_domain_all_non_rigid.h"

// includes from bcl - sorted alphabetically
#include "fold/bcl_fold_loop_domain.h"
#include "fold/bcl_fold_mutation_residue.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorLoopDomainAllNonRigid::s_Instance
    (
      GetObjectInstances().AddInstance( new CollectorLoopDomainAllNonRigid())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorLoopDomainAllNonRigid::CollectorLoopDomainAllNonRigid()
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateLoopDomainAllNonRigid
    CollectorLoopDomainAllNonRigid *CollectorLoopDomainAllNonRigid::Clone() const
    {
      return new CollectorLoopDomainAllNonRigid( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &CollectorLoopDomainAllNonRigid::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual Collect taking an ARGUMENT and returning a list of MutationResidues
    //! @param LOOP_DOMAIN LoopDomain of interest
    //! @return storage::List< MutationResidue> that results from collecting from "LOOP_DOMAIN"
    storage::List< MutationResidue> CollectorLoopDomainAllNonRigid::Collect( const LoopDomain &LOOP_DOMAIN) const
    {
      // create list which will be used to hold mutation residues for all of the non rigid residues
      storage::List< MutationResidue> mutation_residues;

      storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> > residues( LOOP_DOMAIN.GetResidues());

      // iterate through the residues
      for
      (
        storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> >::const_iterator
          resi_itr( residues.Begin()), resi_itr_end( residues.End());
        resi_itr != resi_itr_end;
        ++resi_itr
      )
      {
        // true if the segment is rigid, meaning it cannot be changed
        if( resi_itr->Second())
        {
          // go to next residue
          continue;
        }

        BCL_MessageDbg( "currently making mutation residue for " + resi_itr->First()->GetIdentification());
        // create mutation residue
        const MutationResidue current_mutation_residue( resi_itr, residues);

        mutation_residues.PushBack( current_mutation_residue);
      }

      // return
      return mutation_residues;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_collector_loop_domain.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_locator_loop_domain.h"
#include "fold/bcl_fold_loop_domain.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_sh_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorLoopDomain::s_Instance
    (
      util::Enumerated< find::CollectorInterface< util::ShPtrList< LoopDomain>, assemble::DomainInterface> >::AddInstance
      (
        new CollectorLoopDomain()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorLoopDomain::CollectorLoopDomain() :
      m_CollectUnclosedOnly( false),
      m_LoopClosureThreshold()
    {
    }

    //! @brief constructor from variables
    //! @param COLLECT_UNCLOSED_ONLY boolean to collect only the unclosed ones
    //! @param LOOP_CLOSURE_THRESHOLD Distance sum threshold for identifying closed loops
    CollectorLoopDomain::CollectorLoopDomain
    (
      const bool COLLECT_UNCLOSED_ONLY,
      const double LOOP_CLOSURE_THRESHOLD
    ) :
      m_CollectUnclosedOnly( COLLECT_UNCLOSED_ONLY),
      m_LoopClosureThreshold( LOOP_CLOSURE_THRESHOLD)
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorLoopDomain
    CollectorLoopDomain *CollectorLoopDomain::Clone() const
    {
      return new CollectorLoopDomain( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorLoopDomain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &CollectorLoopDomain::GetAlias() const
    {
      static const std::string s_name( "CollectorLoopDomain");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorLoopDomain::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects loop domains in a protein model.");
      serializer.AddInitializer
      (
        "only unclosed",
        "collect only unclosed loop domains",
        io::Serialization::GetAgent( &m_CollectUnclosedOnly)
      );
      serializer.AddInitializer
      (
        "threshold",
        "loop closure threshold",
        io::Serialization::GetAgent( &m_LoopClosureThreshold)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Collect loop domains from given protein model
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return loop domains collected from given protein model
    util::ShPtrList< LoopDomain> CollectorLoopDomain::Collect( const assemble::DomainInterface &PROTEIN_MODEL) const
    {
      // try to cast the given DomainInterface to ProteinModel
      util::SiPtr< const assemble::ProteinModel> sp_model( &PROTEIN_MODEL);
      BCL_Assert( sp_model.IsDefined(), "The cast from DomainInterface to ProteinModel failed!");

      // first get the loop domain locators from protein model
      util::ShPtr< util::ShPtrList< LocatorLoopDomain> > sp_locators
      (
        sp_model->GetProteinModelData()->GetData( assemble::ProteinModelData::e_LoopDomainLocators)
      );

      // initialize list of loop domains
      util::ShPtrList< LoopDomain> loop_domains;

      // make sure it is defined
      if( !sp_locators.IsDefined())
      {
        BCL_MessageCrt( "No loop domain locators stored with the model");
        return loop_domains;
      }

      // iterate over the locators
      for
      (
        util::ShPtrList< LocatorLoopDomain>::const_iterator
          locator_itr( sp_locators->Begin()), locator_itr_end( sp_locators->End());
        locator_itr != locator_itr_end; ++locator_itr
      )
      {
        // locate the loop domain
        util::ShPtr< LoopDomain> this_domain( ( *locator_itr)->Locate( PROTEIN_MODEL));

        // if collecting not only the unclosed ones
        if( !m_CollectUnclosedOnly)
        {
          // then directly insert it
          loop_domains.PushBack( this_domain);
        }
        else
        {
          // otherwise insert only if the loop is not closed
          if( !LocatorLoopDomain::IsClosed( **locator_itr, *sp_model, m_LoopClosureThreshold))
          {
            loop_domains.PushBack( this_domain);
          }
        }
      }

      return loop_domains;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &CollectorLoopDomain::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_CollectUnclosedOnly, ISTREAM);
      io::Serialize::Read( m_LoopClosureThreshold, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &CollectorLoopDomain::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_CollectUnclosedOnly, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_LoopClosureThreshold, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_collector_loop_domain_random.h"

// includes from bcl - sorted alphabetically
#include "fold/bcl_fold_collector_loop_domain_all_non_rigid.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorLoopDomainRandom::s_Instance
    (
      util::Enumerated< find::CollectorInterface< storage::List< MutationResidue>, LoopDomain> >::AddInstance
      (
        new CollectorLoopDomainRandom()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorLoopDomainRandom::CollectorLoopDomainRandom() :
      m_NumberMutationResiduesToCollect(),
      m_RandomNumberGenerator( random::GetGlobalRandom())
    {
    }

    //! @brief constructor taking parameter
    //! @param NUMBER_MUTATION_RESIDUES_TO_COLLECT the number of residues that should be collected for mutation
    //! @param RANDOM_NUMBER_GENERATOR the random number generator used to select residues for mutation
    CollectorLoopDomainRandom::CollectorLoopDomainRandom
    (
      const size_t NUMBER_MUTATION_RESIDUES_TO_COLLECT,
      const random::DistributionInterface &RANDOM_NUMBER_GENERATOR
    ) :
      m_NumberMutationResiduesToCollect( NUMBER_MUTATION_RESIDUES_TO_COLLECT),
      m_RandomNumberGenerator( RANDOM_NUMBER_GENERATOR)
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorLoopDomainRandom
    CollectorLoopDomainRandom *CollectorLoopDomainRandom::Clone() const
    {
      return new CollectorLoopDomainRandom( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &CollectorLoopDomainRandom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorLoopDomainRandom::GetAlias() const
    {
      static const std::string s_alias( "CollectorLoopDomainRandom");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorLoopDomainRandom::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects random loop domains.");
      serializer.AddInitializer
      (
        "number residues",
        "number of residues to collect for mutation",
        io::Serialization::GetAgent( &m_NumberMutationResiduesToCollect)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief virtual Collect taking an ARGUMENT and returning a list of MutationResidues
    //! @param LOOP_DOMAIN LoopDomain of interest
    //! @return storage::List< MutationResidue> that results from collecting from "LOOP_DOMAIN"
    storage::List< MutationResidue> CollectorLoopDomainRandom::Collect( const LoopDomain &LOOP_DOMAIN) const
    {
      // collect all the possible mutation residues
      const storage::List< MutationResidue> all_mutation_residues
      (
        CollectorLoopDomainAllNonRigid().Collect( LOOP_DOMAIN)
      );

      // make siptr vector which will hold all possible mutation residues
      util::SiPtrList< const MutationResidue> all_mutation_residues_vector
      (
        all_mutation_residues.Begin(), all_mutation_residues.End()
      );

      // create list to hold the final list of selected mutation residues
      storage::List< MutationResidue> selected_mutation_residues;

      // fill "selected_mutation_residues" with MutationResidues randomly selected from "all_mutation_residues_vector"
      while( !all_mutation_residues.IsEmpty() && selected_mutation_residues.GetSize() < m_NumberMutationResiduesToCollect)
      {
        // get a random iterator
        util::SiPtrList< const MutationResidue>::iterator selected_itr
        (
          m_RandomNumberGenerator.Iterator
          (
            all_mutation_residues_vector.Begin(),
            all_mutation_residues_vector.End(),
            all_mutation_residues_vector.GetSize()
          )
        );

        // add the mutation residue
        selected_mutation_residues.PushBack( **selected_itr);
        all_mutation_residues_vector.Remove( selected_itr);
      }

      // return the list of selected mutation residues
      return selected_mutation_residues;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_collector_unconnected_sses.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> CollectorUnconnectedSSE::s_Instance
    (
      util::Enumerated< find::CollectorInterface< util::SiPtrList< const assemble::SSE>, assemble::DomainInterface> >::AddInstance
      (
        new CollectorUnconnectedSSE()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorUnconnectedSSE::CollectorUnconnectedSSE() :
      m_Direction(),
      m_TestBondConnected(),
      m_SSTypes(),
      m_IgnoreTermini()
    {

    }

    //! @brief construct from sequence direction
    //! @param DIRECTION the sequence direction is
    //! @param TEST_BOND_CONNECTION
    //! @param SS_TYPES
    //! @param IGNORE_TERMINAL_SSE
    CollectorUnconnectedSSE::CollectorUnconnectedSSE
    (
      const biol::AASequenceFlexibility::SequenceDirection &DIRECTION,
      const bool TEST_BOND_CONNECTION,
      const storage::Set< biol::SSType> &SS_TYPES,
      const bool IGNORE_TERMINAL_SSE
    ) :
      m_Direction( DIRECTION),
      m_TestBondConnected( TEST_BOND_CONNECTION),
      m_SSTypes( SS_TYPES),
      m_IgnoreTermini( IGNORE_TERMINAL_SSE)
    {
    }

    //! @brief clone function
    //! @return pointer to a new CollectorUnconnectedSSE
    CollectorUnconnectedSSE *CollectorUnconnectedSSE::Clone() const
    {
      return new CollectorUnconnectedSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &CollectorUnconnectedSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorUnconnectedSSE::GetAlias() const
    {
      static const std::string s_alias( "CollectorUnconnectedSSE");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorUnconnectedSSE::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Optimization implementation for Monte Carlo Metropolis algorithms.");
      serializer.AddInitializer
      (
        "sequence direction",
        "sequence direction in which to collect the sses",
        io::Serialization::GetAgent( &m_Direction)
      );
      serializer.AddInitializer
      (
        "bond connected",
        "whether to test bond connection",
        io::Serialization::GetAgent( &m_TestBondConnected)
      );
      serializer.AddInitializer
      (
        "sse types",
        "sse types to consider",
        io::Serialization::GetAgent( &m_SSTypes)
      );
      serializer.AddInitializer
      (
        "ignore termini",
        "ignore terminal loops",
        io::Serialization::GetAgent( &m_IgnoreTermini)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief collects unconnected SSEs from the given domain
    //! @param DOMAIN_INTERFACE domain from which to collect unconnected SSEs
    //! @return unconnected SSEs in the given domain
    util::SiPtrList< const assemble::SSE> CollectorUnconnectedSSE::Collect
    (
      const assemble::DomainInterface &DOMAIN_INTERFACE
    ) const
    {
      // get all coil sses
      util::SiPtrVector< const assemble::SSE> sses( DOMAIN_INTERFACE.GetSSEs( m_SSTypes));

      // collect all sses with m_Direction flexibility
      util::SiPtrList< const assemble::SSE> eligible_sses;

      for( util::SiPtrVector< const assemble::SSE>::const_iterator itr( sses.Begin()), itr_end( sses.End()); itr != itr_end; ++itr)
      {
        // get adjacent sses
        const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > adjacent( DOMAIN_INTERFACE.GetAdjacentSSEs( **itr));

        // ignore terminating sses
        if( m_IgnoreTermini)
        {
          const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > neighors( DOMAIN_INTERFACE.GetNeighborSSEs( **itr));

          // skip if termini, either neighbor is not defined
          if( !neighors.First().IsDefined() || !neighors.Second().IsDefined())
          {
            continue;
          }
        }

        // if the direction dependent sse is present and peptide bonded, ignore that coil
        if( m_Direction == biol::AASequenceFlexibility::e_CTerminal)
        {
          // skip if there is an adjacent sse and possibly peptide bond connected
          if
          (
            adjacent.Second().IsDefined()
            && ( !m_TestBondConnected || biol::AABase::AreAminoAcidsPeptideBonded( *( *itr)->GetLastAA(), *adjacent.Second()->GetFirstAA(), true))
          )
          {
            continue;
          }
        }
        else if( m_Direction == biol::AASequenceFlexibility::e_NTerminal)
        {
          // skip if there is an adjacent sse and possibly peptide bond connected
          if
          (
            adjacent.First().IsDefined() &&
            ( !m_TestBondConnected || biol::AABase::AreAminoAcidsPeptideBonded( *adjacent.First()->GetLastAA(), *( *itr)->GetFirstAA(), true))
          )
          {
            continue;
          }
        }
        else
        {
          continue;
        }

        // sse passed all conditions
        eligible_sses.PushBack( *itr);
       }

      return eligible_sses;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold.h"

// includes from bcl - sorted alphabetically
#include "util/bcl_util_class_descriptor.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

    //! @brief identifier for the name space
    //! @return the name of the namespace
    const std::string &GetNamespaceIdentifier()
    {
      static const std::string *s_namespace_name( new std::string( util::ExtractNamespaceIdentifier( __PRETTY_FUNCTION__)));
      return *s_namespace_name;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_default_flags.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_storage_file.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "command/bcl_command_flag_dynamic.h"
#include "command/bcl_command_parameter_check_allowed.h"
#include "command/bcl_command_parameter_check_extension.h"
#include "command/bcl_command_parameter_check_file_existence.h"
#include "command/bcl_command_parameter_check_ranged.h"
#include "fold/bcl_fold_protocols.h"
#include "mc/bcl_mc_movie_printers.h"
#include "mc/bcl_mc_temperature_accepted.h"
#include "pdb/bcl_pdb_factory.h"
#include "quality/bcl_quality_measures.h"
#include "quality/bcl_quality_superimpose_measures.h"
#include "score/bcl_score_aa_neighborhood_exposure_prediction.h"
#include "score/bcl_score_symmetry.h"
#include "util/bcl_util_runtime_environments.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DefaultFlags::s_Instance
    (
      GetObjectInstances().AddInstance( new DefaultFlags())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    DefaultFlags::DefaultFlags()
    {
    }

    //! @brief Clone function
    //! @return pointer to new DefaultFlags
    DefaultFlags *DefaultFlags::Clone() const
    {
      return new DefaultFlags( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DefaultFlags::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////
  // flags //
  ///////////

    //! @brief return all command line flags defined by this class
    //! @return all command line flags defined by this class
    const util::ShPtrVector< command::FlagInterface> &DefaultFlags::GetAllFlags()
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // flags from this class
        s_all_flags_vector.PushBack( GetProtocols().GetFlagProtocols());
        s_all_flags_vector.PushBack( GetProtocols().GetFlagMutateProtocols());
        s_all_flags_vector.PushBack( GetProtocols().GetFlagScoreProtocols());
        s_all_flags_vector.PushBack( GetFlagFastaRead());
        s_all_flags_vector.PushBack( GetFlagChainIdRead());
        s_all_flags_vector.PushBack( GetFlagPrefix());
        s_all_flags_vector.PushBack( GetFlagNumberModels());
        s_all_flags_vector.PushBack( GetFlagNativeModel());
        s_all_flags_vector.PushBack( GetFlagStartModel());
        s_all_flags_vector.PushBack( GetFlagUseNativeSSEsAsPool());
        s_all_flags_vector.PushBack( GetFlagEnableSSEResize());
        s_all_flags_vector.PushBack( GetFlagPoolSeparate());
        s_all_flags_vector.PushBack( GetFlagPrintMinimization());
        s_all_flags_vector.PushBack( GetFlagPrintTrackerHistory());
        s_all_flags_vector.PushBack( GetFlagMCNumberIterations());
        s_all_flags_vector.PushBack( GetFlagPrintStartModel());
        s_all_flags_vector.PushBack( GetFlagReadSequenceDataPath());
        s_all_flags_vector.PushBack( GetFlagScoreRead());
        s_all_flags_vector.PushBack( GetFlagScoreWrite());
        s_all_flags_vector.PushBack( GetFlagScoreWeightSetRead());
        s_all_flags_vector.PushBack( GetFlagScoreWeightSetWrite());
        s_all_flags_vector.PushBack( GetFlagMutateRead());
        s_all_flags_vector.PushBack( GetFlagMutateWrite());
        s_all_flags_vector.PushBack( GetFlagMutateWeightSetRead());
        s_all_flags_vector.PushBack( GetFlagMutateWeightSetWrite());
        s_all_flags_vector.PushBack( GetFlagStagesFileRead());
        s_all_flags_vector.PushBack( GetFlagStagesFileWrite());
        s_all_flags_vector.PushBack( GetFlagStagesNumberCycles());
        s_all_flags_vector.PushBack( GetFlagFitSwappedSSEs());
        s_all_flags_vector.PushBack( GetFlagPDBIDNumbering());

        // flags from other classes
        s_all_flags_vector.PushBack( pdb::Factory::GetFlagMinSSESize());
        s_all_flags_vector.PushBack( pdb::Factory::GetFlagAAClass());
        s_all_flags_vector.PushBack( assemble::SSEPool::GetFlagPoolRead());
        s_all_flags_vector.PushBack( assemble::SSEPool::GetFlagMinSSELengths());
        s_all_flags_vector.PushBack( mc::MoviePrinterInterface::GetFlagMoviePrinter());
        s_all_flags_vector.PushBack( mc::TemperatureAccepted::GetFlagTemperature());
        s_all_flags_vector.PushBack( quality::Measures::GetFlagQualityMeasures());
        s_all_flags_vector.PushBack( quality::SuperimposeMeasures::GetFlagSuperimposeMeasure());
        s_all_flags_vector.PushBack( score::Symmetry< assemble::ProteinModel>::GetFlagScoreSymmetry());
        s_all_flags_vector.PushBack( sspred::Methods::GetFlagReadSSPredictions());
        s_all_flags_vector.PushBack( assemble::ProteinStorageFile::GetDefaultStorageFlag());
        s_all_flags_vector.PushBack( assemble::SSEPool::GetFlagPoolPrefix());
        s_all_flags_vector.PushBack( score::AANeighborhoodExposurePrediction::GetFlagScoreExposure());
      }

      // return
      return s_all_flags_vector;
    }

  ///////////////////
  // general flags //
  ///////////////////

    //! @brief return command line flag for writing the minimization to files - only of given step statuses
    //! @return command line flag for writing the minimization to files - only of given step statuses
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagPrintMinimization()
    {
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagDynamic
        (
          "write_minimization", "write the minimization to files - only of given step statuses",
          command::Parameter
          (
            "stepstatuses",
            "any step status from the list",
            command::ParameterCheckAllowed( opti::StepStatusEnum::GetStringVector()),
            opti::GetStepStatusName( opti::e_Improved)
          ),
          0,
          opti::s_NumberStepStatus
        )
      );

      return s_flag;
    }

    //! @brief return command line parameter for specifying the path for where tracker files are generated
    //! @return command line parameter for specifying the path for where tracker files are generated
    util::ShPtr< command::ParameterInterface> &DefaultFlags::GetParameterPrintTrackerHistoryPath()
    {
      static util::ShPtr< command::ParameterInterface> s_parameter
      (
        new command::Parameter
        (
          "print_tracker_history_path",
          "path for where the tracker history is saved",
          ""
        )
      );

      return s_parameter;
    }

    //! @brief return command line flag for a detailed analysis of each step in a tabulated format
    //! @return command line flag for a detailed analysis of each step in a tabulated format
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagPrintTrackerHistory()
    {
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "print_tracker_history",
          "\tprint <path>" + util::GetRuntimeEnvironment().GetPathSeperator()
            + "<prefix>.tracker_history that has a detailed analysis of each step in a tabulated format"
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameter into flag
        flag->PushBack( GetParameterPrintTrackerHistoryPath());
      }

      return s_flag;
    }

    //! @brief return command line flag for monte carlo minimization, max number of rejected steps and max iterations
    //! @return command line flag for monte carlo minimization, max number of rejected steps and max iterations
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagMCNumberIterations()
    {
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "mc_number_iterations",
          "\tmodify the number of iterations and max steps without improvement"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_total
      (
        new command::Parameter
        (
          "mc_number_total_iterations", "\ttotal number of iterations for minimization", "100"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_max_unimproved
      (
        new command::Parameter
        (
          "mc_max_unimproved_steps", "\tnumber of steps without improvement before terminating", "50"
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters into flag
        flag->PushBack( s_total);
        flag->PushBack( s_max_unimproved);
      }

      // end
      return s_flag;
    }

    //! @brief return command line flag for specifying whether or not to print the start model
    //! @return command line flag for specifying  whether or not to print the start model
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagPrintStartModel()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic( "print_start_model", "\t\tflag to determine whether to print start model or not")
      );

      // end
      return s_flag;
    }

    //! @brief return command line flag for specifying a prefix to be used for writing files
    //! @return command line flag for specifying a prefix to be used for writing files
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagPrefix()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "prefix", "\tfile prefix to be used for writing files",
          command::Parameter( "file_prefix", "\twill be prepended to each file - can contain a path", "")
        )
      );

      // end
      return s_flag;
    }

    //! @brief return command line flag for specifying the number of models to build
    //! @return command line flag for specifying the number of models to build
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagNumberModels()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "nmodels", "the number of models that will be created",
          command::Parameter
          (
            "number_of_models", "\tthe number of models that will be created", "1"
          )
        )
      );

      // end
      return s_flag;
    }

    //! @brief return command line flag for providing one or more fasta files for complete de novo folding
    //! @return command line flag for providing one or more fasta files for complete de novo folding
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagFastaRead()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagDynamic
        (
          "fasta",
          "\t filenames of one or more fasta files to be used, one file per chain in alphabetical order",
          command::Parameter
          (
            "fasta_filename",
            "\tfilename for input amino acid sequence of the form {name}{chainid}.fasta, or {name}.fasta and chain id given by chain id flag",
            command::ParameterCheckFileExistence()
          ),
          0, 20
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for providing one or more chain ids for fasta files for complete de novo folding
    //! @return command line flag for providing one or more chain ids for fasta files for complete de novo folding
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagChainIdRead()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagDynamic
        (
          "fasta_chain_id",
          "\t chain ids for each amino acid sequence given by fasta files",
          command::Parameter
          (
            "fasta_filename",
            "\tfilename single character A to Z for each amino acid sequence"
          ),
          0, 20
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for providing a native model for comparison
    //! @return command line flag for providing a native model for comparison
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagNativeModel()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "native", "\t\tpdb file of native structure or template structure for comparison",
          command::Parameter
          (
            "native_pdb_filename", "\tfilename for native or template pdb to which rmsd will be calculated",
             command::ParameterCheckExtension( ".pdb"), ""
          )
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for providing a starting model
    //! @return command line flag for providing a starting model
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagStartModel()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "start_model", "\t\tpdb file of starting model structure for refinement or folding",
          command::Parameter
          (
            "start_model_filename", "\tfilename for pdb file of starting model structure",
             command::ParameterCheckExtension( ".pdb"), ""
          )
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for using native SSE definitions as the SSE pool
    //! @return command line flag for using native SSE definitions as the SSE pool
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagUseNativeSSEsAsPool()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "use_native_pool",
          "\tflag to use the SSE definitions in the native structure as the pool",
          command::Parameter
          (
            "idealize",
            "idealize the SSEs or use the native conformations",
            command::ParameterCheckAllowed( storage::Vector< std::string>::Create( "ideal", "native")),
            "ideal"
          )
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for enable resizing of SSEs
    //! @return command line flag for enable resizing of SSEs
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagEnableSSEResize()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "enable_sse_resize", "\tflag to allow resizing and split moves for SSEs. "
          "Requires a high (>20) weight for sspred_PSIPRED and similar"
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for separating adjoining SSE pools with specified number of loop residues
    //! @return command line flag for separating adjoining SSE pools with specified number of loop residues
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagPoolSeparate()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "pool_separate", "\t\tseparate the adjoining SSEs in the pool with specified number of loop residues",
          command::Parameter
          (
            "pool_separate_nr_res", "\tnumber of residues each adjoining SSE will be shortened by",
             command::ParameterCheckRanged< size_t>( 1, 3),
             "1"
          )
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for specifying the path where the ss predictions should be read from
    //! @return command line flag for specifying the path where the ss predictions should be read from
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagReadSequenceDataPath()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "sequence_data",
          "\tflag for specifying the path and prefix for sequence data files, such as secondary structure prediction"
          ": {data_path} {data_prefix};"
          "to be used in conjunction with sspred flag. The {data_prefix} should be identifier for your protein ( "
          " most likely the *FOUR* letter code)."
          "The chain id for secondary structure predictions will be determined from the chains that are in your protein"
          " model. A data file of the specified types will be searched for for each chain as "
          "\"{data_path}{data_prefix}{chainid}.{extension}\"."
        )
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_path_param
      (
        new command::Parameter
        (
          "data_path",
          "\tpath of sequence data file",
          "."
        )
      );
      static util::ShPtr< command::ParameterInterface> s_prefix_param
      (
        new command::Parameter
        (
          "data_prefix",
          "\tprefix of sequence data file",
          "XXXX"
        )
      );

      // if this flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);

        // insert parameters
        flag->PushBack( s_path_param);
        flag->PushBack( s_prefix_param);
      }

      // end
      return s_flag;
    }

    //! @brief return command line flag for reading scores from a file
    //! @return command line flag for reading scores from a file
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagScoreRead()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "score_read", "\t\tread scoring function from a given file",
          command::Parameter( "score_read_filename", "\tfilename for the input scoring function", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for writing scores to a file
    //! @return command line flag for writing scores to a file
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagScoreWrite()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "score_write", "\t\twrite scoring function to a file",
          command::Parameter( "score_write_filename", "\tfilename for writing scoring function", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for reading score weight set from a file
    //! @return command line flag for reading score weight set from a file
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagScoreWeightSetRead()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "score_weightset_read", "\t\tfile with weightset for the scores to be used",
          command::Parameter( "score_weightset_read_filename", "\tfilename for score weightset", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for writing score weight set to a file
    //! @return command line flag for writing score weight set to a file
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagScoreWeightSetWrite()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "score_weightset_write", "\t\twrite score weightset to a file",
          command::Parameter( "score_weightset_filename_prefix", "\tfilename prefix for score weightset", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for reading mutates from a file
    //! @return command line flag for reading mutates from a file
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagMutateRead()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "mutate_read", "\t\tread mutate objects from a given file",
          command::Parameter( "mutate_read_filename", "\tfilename for reading mutate objects", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for writing mutates to a file
    //! @return command line flag for writing mutates to a file
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagMutateWrite()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "mutate_write", "\t\twrite mutate objects to a file",
          command::Parameter( "mutate_write_filename", "\tfilename for writing mutate objects", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for reading mutate weight set from a file
    //! @return command line flag for reading mutate weight set from a file
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagMutateWeightSetRead()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "mutate_weightset_read", "\t\tfile with weightset for the mutates to be used",
          command::Parameter( "mutate_weightset_filename", "\tfilename for mutate weightset", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for writing mutate weight set to a file
    //! @return command line flag for writing mutate weight set to a file
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagMutateWeightSetWrite()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "mutate_weightset_write", "\t\twrite mutate weightset to a file",
          command::Parameter( "mutate_weightset_filename_prefix", "\tfilename prefix for mutate weightset", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for defining the filename to read the stages from
    //! @return command line flag for defining the filename to read the stages from
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagStagesFileRead()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "stages_read", "\t\tfile with stages",
          command::Parameter( "stages_filename", "\tfilename for stages", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for defining the filename to write the stages to
    //! @return command line flag for defining the filename to write the stages to
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagStagesFileWrite()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "stages_write", "\t\tfile with stages to be used",
          command::Parameter( "stage_filename", "\tfilename for stages", "")
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for defining the number of cycles stages should go through
    //! @return command line flag for defining the number of cycles stages should go through
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagStagesNumberCycles()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "stages_cycle", "\t\t the number of cycles stages should go through",
          command::Parameter
          (
            "stage_number_cycles", "\tthe number of cycles",
            command::ParameterCheckRanged< size_t>( 1, 100), "1"
          )
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for defining whether to fit swapped sses
    //! @return command line flag for defining whether to fit swapped sses
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagFitSwappedSSEs()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic( "fit_swapped", "\t\t whether to fit swapped SSEs to the original")
      );
      // end
      return s_flag;
    }

    //! @brief command line flag indicating the input file numbering is PDB numbering instead of sequence id numbering
    //! @return flag indicating the input file numbering is PDB numbering instead of sequence id numbering
    util::ShPtr< command::FlagInterface> &DefaultFlags::GetFlagPDBIDNumbering()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "use_pdbid_numbering",
          "\tindicates the input file (e.g. restraint or domain files) numbering is PDB numbering (from the atom section) instead of sequence id numbering"
        )
      );

      return s_flag;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DefaultFlags::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DefaultFlags::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  } // namespace fold

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_default_mutates.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sheet.h"
#include "assemble/bcl_assemble_collector_sse.h"
#include "assemble/bcl_assemble_collector_sse_paired.h"
#include "assemble/bcl_assemble_collector_sse_size.h"
#include "assemble/bcl_assemble_locator_domain_random.h"
#include "assemble/bcl_assemble_locator_sse_furthest.h"
#include "assemble/bcl_assemble_locator_sse_random.h"
#include "assemble/bcl_assemble_locator_sse_unpaired.h"
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "assemble/bcl_assemble_pick_sse_short_loops.h"
#include "assemble/bcl_assemble_sse_compare_type.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "coord/bcl_coord_move_combine.h"
#include "coord/bcl_coord_move_rotate_defined.h"
#include "coord/bcl_coord_move_rotate_random.h"
#include "coord/bcl_coord_move_transform_random.h"
#include "coord/bcl_coord_move_translate_random.h"
#include "find/bcl_find_collector_criteria_combined.h"
#include "find/bcl_find_collector_criteria_wrapper.h"
#include "find/bcl_find_locator.h"
#include "find/bcl_find_locator_criteria.h"
#include "find/bcl_find_locator_criteria_wrapper.h"
#include "find/bcl_find_pick_criteria_wrapper.h"
#include "fold/bcl_fold_mutate_domain_flip.h"
#include "fold/bcl_fold_mutate_domain_shuffle.h"
#include "fold/bcl_fold_mutate_protein_model_domain.h"
#include "fold/bcl_fold_mutate_protein_model_pair_strands.h"
#include "fold/bcl_fold_mutate_protein_model_sse.h"
#include "fold/bcl_fold_mutate_protein_model_sse_add.h"
#include "fold/bcl_fold_mutate_protein_model_sse_move.h"
#include "fold/bcl_fold_mutate_protein_model_sse_pair.h"
#include "fold/bcl_fold_mutate_protein_model_sse_pair_hinge.h"
#include "fold/bcl_fold_mutate_protein_model_sse_remove.h"
#include "fold/bcl_fold_mutate_protein_model_sse_resize.h"
#include "fold/bcl_fold_mutate_protein_model_sse_split.h"
#include "fold/bcl_fold_mutate_protein_model_sse_swap.h"
#include "fold/bcl_fold_mutate_protein_model_sse_swap_with_pool.h"
#include "fold/bcl_fold_mutate_protein_model_sse_swap_with_pool_overlap.h"
#include "fold/bcl_fold_mutate_protein_model_strand_switch_sheet.h"
#include "fold/bcl_fold_mutate_sheet_cycle.h"
#include "fold/bcl_fold_mutate_sheet_divide.h"
#include "fold/bcl_fold_mutate_sheet_register_fix.h"
#include "fold/bcl_fold_mutate_sheet_register_shift.h"
#include "fold/bcl_fold_mutate_sheet_twist.h"
#include "fold/bcl_fold_mutate_sse_bend_ramachandran.h"
#include "fold/bcl_fold_mutate_sse_bend_random.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_placement_sse_next_to_sse.h"
#include "fold/bcl_fold_placement_sse_short_loop.h"
#include "fold/bcl_fold_setup.h"
#include "math/bcl_math_mutate_move_wrapper.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DefaultMutates::s_Instance
    (
      GetObjectInstances().AddInstance( new DefaultMutates())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    DefaultMutates::DefaultMutates()
    {
    }

    //! @brief Clone function
    //! @return pointer to new DefaultMutates
    DefaultMutates *DefaultMutates::Clone() const
    {
      return new DefaultMutates( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to single instance
    //! @return single instance of default mutates
    DefaultMutates &DefaultMutates::GetInstance()
    {
      static DefaultMutates s_single_instance;
      return s_single_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DefaultMutates::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief initialize the mutates and add them to Mutates enumerator
    void DefaultMutates::InitializeMutates()
    {
      // mutates already initialized
      if( e_AddSSENextToSSE.IsDefined())
      {
        return;
      }

      // create storage set of xyz axis
      storage::Set< coord::Axis> xyz_axes_set( coord::GetAxes().e_X, coord::GetAxes().e_Y, coord::GetAxes().e_Z);

    ///////////////////////////
    // collector and locator //
    ///////////////////////////

      // random sse locator
      const util::ShPtr< assemble::LocatorSSERandom> sp_locator_sse_random( new assemble::LocatorSSERandom());

      // helix collector
      const assemble::CollectorSSE collector_helix( biol::GetSSTypes().HELIX);

      // strand collector
      const assemble::CollectorSSE collector_strand( biol::GetSSTypes().STRAND);

      // random picker
      const assemble::PickSSERandom picker_sse_random;

      // random helix locator
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > sp_locator_helix_random
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          collector_helix, picker_sse_random
        )
      );

      // random strand locator
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > sp_locator_strand_random
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          collector_strand, picker_sse_random
        )
      );

      // pool picker
      const find::PickCriteriaWrapper
      <
        util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::DomainInterface
      > picker_sse_pool( picker_sse_random);

      // random pool strand picker
      const find::PickCriteriaWrapper
      <
        util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::DomainInterface
      >
      picker_strand_sse_pool_random( assemble::PickSSERandom( storage::Set< biol::SSType>( biol::GetSSTypes().STRAND)));

      //  short loop picker
      const size_t short_loop_length( 7);
      const assemble::PickSSEShortLoops picker_sse_pool_short_loop( short_loop_length);

      const find::LocatorCriteriaWrapper< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::SSE>
        locator_sse_random_crit_wrap( sp_locator_sse_random);

      // construct Set to stra
      storage::Set< contact::Type> pair_contact_types;
      pair_contact_types.Insert( contact::GetTypes().HELIX_HELIX);
      pair_contact_types.Insert( contact::GetTypes().HELIX_SHEET);
      pair_contact_types.Insert( contact::GetTypes().SHEET_HELIX);
      pair_contact_types.Insert( contact::GetTypes().HELIX_STRAND);
      pair_contact_types.Insert( contact::GetTypes().STRAND_HELIX);
      pair_contact_types.Insert( contact::GetTypes().UNDEFINED_HELIX_STRAND);
      pair_contact_types.Insert( contact::GetTypes().UNDEFINED_STRAND_HELIX);

      // create helix pair collector
      const util::ShPtr< assemble::CollectorSSEPaired> collector_sse_pair
      (
        new assemble::CollectorSSEPaired
        (
          assemble::GetSSEGeometryPackingPickers().e_BestInteractionWeight,
          pair_contact_types,
          12.0, // distance
          true  // orthogonal
        )
      );

      // create helix pair collector
      const util::ShPtr< assemble::CollectorSSEPaired> collector_helix_pair
      (
        new assemble::CollectorSSEPaired
        (
          assemble::GetSSEGeometryPackingPickers().e_BestInteractionWeight,
          storage::Set< contact::Type>( contact::GetTypes().HELIX_HELIX),
          12.0, // distance
          true  // orthogonal
        )
      );

      // create sheet collector
      const util::ShPtr< find::CollectorInterface< util::ShPtrVector< assemble::Domain>, assemble::ProteinModel> >
        collector_sheet( new assemble::CollectorSheet());

      // initialize first collector for use in locator 1
      // this collector collects all the sses that agree in type with the criterion sse
      const find::CollectorCriteriaCombined< assemble::SSE> collector_same_sstype
      (
        util::ShPtr< util::BinaryFunctionInterfaceSerializable< assemble::SSE, assemble::SSE, bool> >
        (
          new assemble::SSECompareType()
        )
      );

      // initialize random picker (this picker will be used with both collectors)
      const find::PickCriteriaWrapper
      <
        util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE
      > picker( picker_sse_random);

      // create locator to locate sses of same type
      const find::LocatorCriteria
      <
        util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE,
        util::SiPtrList< const assemble::SSE>
      > locator_ss_type( util::CloneToShPtr( collector_same_sstype), util::CloneToShPtr( picker));

      // collector sse wrapped
      const assemble::CollectorSSE collector_sse;
      const find::CollectorCriteriaWrapper< util::SiPtrList< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface>
      collector_sse_wrapped( collector_sse);

      // collector helix wrapped
      const find::CollectorCriteriaWrapper< util::SiPtrList< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface>
      collector_helix_wrapped( assemble::CollectorSSE( biol::GetSSTypes().HELIX));

      // collector strand wrapped
      const find::CollectorCriteriaWrapper< util::SiPtrList< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface>
      collector_strand_wrapped( assemble::CollectorSSE( biol::GetSSTypes().STRAND));

      // constructor locator for furthest SSE from center
      const assemble::LocatorSSEFurthest< assemble::DomainInterface> locator_sse_furthest( collector_sse_wrapped);

      // constructor locator for furthest helix from center
      const assemble::LocatorSSEFurthest< assemble::DomainInterface> locator_helix_furthest( collector_helix_wrapped);

      // constructor locator for furthest strand from center
      const assemble::LocatorSSEFurthest< assemble::DomainInterface> locator_strand_furthest( collector_strand_wrapped);

      // random helix locator criteria wrapped for domain
      const find::LocatorCriteriaWrapper< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface>
      locator_sse_random_wrapped
      (
        sp_locator_sse_random
      );

      // random helix locator criteria wrapped for domain
      const find::LocatorCriteriaWrapper< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface>
      locator_helix_random_wrapped
      (
        sp_locator_helix_random
      );

      // random strand locator criteria wrapped for domain
      const find::LocatorCriteriaWrapper< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface>
      locator_strand_random_wrapped
      (
        sp_locator_strand_random
      );

    ///////////////
    // placement //
    ///////////////

      // place an sse next to a located sse in the protein model with a distance deviation factor of 1.0
      const PlacementSSENextToSSE placement_next_to_sse( locator_sse_random_crit_wrap);

      // place an sse with short loop next to a located sse in the protein model with a distance deviation factor of 1.0
      const PlacementSSEShortLoop placement_short_loop( short_loop_length);

      // place a strand from loop next to an edge strand in a sheet
      const PlacementStrandNextToSheet placement_strand_next_to_sheet( 0.5);

    //////////////
    // sse adds //
    //////////////

      // adds a SSE from the pool next to an SSE in the model
      e_AddSSENextToSSE = GetMutates().AddMutate
      (
        MutateProteinModelSSEAdd
        (
          picker_sse_pool,
          placement_next_to_sse,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_sse_next_to_sse"
        )
      );

      // adds a SSE from pool next to an SSE in the model connected by a short loop
      e_AddSSEShortLoop = GetMutates().AddMutate
      (
        MutateProteinModelSSEAdd
        (
          picker_sse_pool_short_loop,
          placement_short_loop,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_sse_short_loop"
        )
      );

      // adds a strand from pool next to another strand/sheet in the model
      e_AddStrandNextToSheet = GetMutates().AddMutate
      (
        MutateProteinModelSSEAdd
        (
          picker_strand_sse_pool_random,
          placement_strand_next_to_sheet,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_strand_next_to_sheet"
        )
      );

    //////////////////
    // sse removals //
    //////////////////

      // remove a random SSE from model
      e_RemoveRandom = GetMutates().AddMutate
      (
        MutateProteinModelSSERemove
        (
          sp_locator_sse_random,
          MutateTree::GetMutateTypeName( MutateTree::e_Remove) + "_random"
        )
      );

      // remove an unpaired strand from model
      e_RemoveUnpairedStrand = GetMutates().AddMutate
      (
        MutateProteinModelSSERemove
        (
          util::CloneToShPtr( assemble::LocatorSSEUnpaired( assemble::PickSSEFurthestEuclidean(), contact::GetTypes().STRAND_STRAND, 20.0)),
          MutateTree::GetMutateTypeName( MutateTree::e_Remove) + "_unpaired_strand"
        )
      );

    ///////////////
    // sse swaps //
    ///////////////

      // swap a SSE of same type within the model
      e_SwapSSEs = GetMutates().AddMutate
      (
        MutateProteinModelSSESwap
        (
          locator_ss_type,
          DefaultFlags::GetFlagFitSwappedSSEs()->GetFlag(),
          MutateTree::GetMutateTypeName( MutateTree::e_Swap) + "_sses"
        )
      );

      // swap a SSE in model, with a non-overlapping SSE from the pool of same type
      e_SwapSSEWithPool = GetMutates().AddMutate
      (
        MutateProteinModelSSESwapWithPool
        (
          locator_ss_type,
          DefaultFlags::GetFlagFitSwappedSSEs()->GetFlag(),
          MutateTree::GetMutateTypeName( MutateTree::e_Swap) + "_sse_with_pool"
        )
      );

      // swap a SSE in model, with an overlapping SSE (or two if possible) from the pool of same type
      e_SwapSSEWithPoolOverlap = GetMutates().AddMutate
      (
        MutateProteinModelSSESwapWithPoolOverlap
        (
          util::CloneToShPtr( collector_same_sstype),
          false,
          DefaultFlags::GetFlagFitSwappedSSEs()->GetFlag(),
          MutateTree::GetMutateTypeName( MutateTree::e_Swap) + "_sse_with_pool_overlap"
        )
      );

    ////////////
    // resize //
    ////////////

      // resize move for SSEs cterm
      e_SSEResizeCTerm = GetMutates().AddMutate
      (
        MutateProteinModelSSEResize
        (
          sp_locator_sse_random,
          0.5, // extend prob
          math::Range< size_t>( 1, 3), // length range to extend/shrink
          biol::AASequenceFlexibility::e_CTerminal, // change both ends
          true, // recenter after resize
          assemble::SSEPool::GetCommandLineMinSSELengths(),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_resize_cterm"
        )
      );

      // resize move for SSEs nterm
      e_SSEResizeNTerm = GetMutates().AddMutate
      (
        MutateProteinModelSSEResize
        (
          sp_locator_sse_random,
          0.5, // extend prob
          math::Range< size_t>( 1, 3), // length range to extend/shrink
          biol::AASequenceFlexibility::e_NTerminal, // change both ends
          true, // recenter after resize
          assemble::SSEPool::GetCommandLineMinSSELengths(),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_resize_nterm"
        )
      );

    //////////////////////
    // single SSE moves //
    //////////////////////

      // move a SSE next to SSE
      e_SSEMoveNext = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_sse_random_wrapped,
          placement_next_to_sse,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_move_next"
        )
      );

      // move a SSE next to short loop SSE
      e_SSEMoveShortLoop = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_sse_random_wrapped,
          placement_short_loop,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_move_short_loop"
        )
      );

      // move the furthest SSE next to SSE
      e_SSEFurthestMoveNext = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_sse_furthest,
          placement_next_to_sse,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_furthest_move_next"
        )
      );

      // split coil length
      const math::Range< size_t> sse_split_coil_length_range( 1, 3);
      storage::Map< biol::SSType, size_t> sse_split_min_sizes;
      sse_split_min_sizes[ biol::GetSSTypes().HELIX] = 5;
      sse_split_min_sizes[ biol::GetSSTypes().STRAND] = 3;

      // ranges for the SSE locator by size
      storage::Map< biol::SSType, math::Range< size_t> > sse_size_ranges;
      sse_size_ranges[ biol::GetSSTypes().HELIX] = math::Range< size_t>( 15, util::GetUndefinedSize_t());
      sse_size_ranges[ biol::GetSSTypes().STRAND] = math::Range< size_t>( 9, util::GetUndefinedSize_t());

      // locator for large SSEs
      util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > sp_locator
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          util::ShPtr< assemble::CollectorSSESize>
          (
            new assemble::CollectorSSESize( sse_size_ranges)
          ),
          util::ShPtr< assemble::PickSSERandom>( new assemble::PickSSERandom())
        )
      );

      // iterate over ss prediction methods
      storage::Set< sspred::Method> ss_pred_methods( sspred::Methods::GetCommandLineMethods());
      for
      (
        storage::Set< sspred::Method>::const_iterator
          sspred_itr( ss_pred_methods.Begin()), sspred_itr_end( ss_pred_methods.End());
        sspred_itr != sspred_itr_end;
        ++sspred_itr
      )
      {
        // construct split moves for each method
        m_SSESplit[ *sspred_itr] = GetMutates().AddMutate
        (
          MutateProteinModelSSESplit
          (
            *sspred_itr,
            sp_locator,
            sse_split_min_sizes,
            sse_split_coil_length_range,
            MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_split_" + sspred_itr->GetName()
          )
        );
      }

      // bend a random SSE using a phi/psi angle pair picked from ramachandran distribution
      e_SSEBendRamachandran = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( MutateSSEBendRamachandran( math::Range< size_t>( 1, 2))),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_bend_ramachandran"
        )
      );

      // bend a random SSE with phi/psi changes within  +/- 5 degrees
      const math::Range< double> bend_small_range( -math::g_Pi / 36.0, math::g_Pi / 36.0);
      e_SSEBendRandomSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( MutateSSEBendRandom( bend_small_range, bend_small_range)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_bend_random_small"
        )
      );

      // bend a random SSE with phi/psi changes within +/- 20 degrees
      const math::Range< double> bend_large_range( -math::g_Pi/ 9.0, math::g_Pi/ 9.0);   // +- 20 degrees
      e_SSEBendRandomLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( MutateSSEBendRandom( bend_large_range, bend_large_range)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_bend_random_large"
        )
      );

      // init translation small and large along every axis
      const linal::Vector3D x_trans_s( 2.0, 0.0, 0.0);
      const linal::Vector3D y_trans_s( 0.0, 2.0, 0.0);
      const linal::Vector3D z_trans_s( 0.0, 0.0, 2.0);
      const linal::Vector3D x_trans_l( 6.0, 0.0, 0.0);
      const linal::Vector3D y_trans_l( 0.0, 6.0, 0.0);
      const linal::Vector3D z_trans_l( 0.0, 0.0, 6.0);

      // construct translation moves
      e_SSETranslateSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( 2.0, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_translate_small"
        )
      );
      e_SSETranslateXSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( x_trans_s, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_translate_x_small"
        )
      );
      e_SSETranslateYSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( y_trans_s, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_translate_y_small"
        )
      );
      e_SSETranslateZSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( z_trans_s, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_translate_z_small"
        )
      );
      e_SSETranslateLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( 2.0, 6.0, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_translate_large"
        )
      );
      e_SSETranslateXLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( x_trans_s, x_trans_l, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_translate_x_large"
        )
      );
      e_SSETranslateYLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( y_trans_s, y_trans_l, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_translate_y_large"
        )
      );
      e_SSETranslateZLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( z_trans_s, z_trans_l, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_translate_z_large"
        )
      );

      // initialize rotations
      const linal::Vector3D x_rot_s( math::g_Pi / 12.0, 0.0, 0.0);
      const linal::Vector3D y_rot_s( 0.0, math::g_Pi / 12.0, 0.0);
      const linal::Vector3D z_rot_s( 0.0, 0.0, math::g_Pi / 12.0);
      const linal::Vector3D x_rot_l( math::g_Pi / 4.0, 0.0, 0.0);
      const linal::Vector3D y_rot_l( 0.0, math::g_Pi / 4.0, 0.0);
      const linal::Vector3D z_rot_l( 0.0, 0.0, math::g_Pi / 4.0);

      // construct rotation moves
      e_SSERotateSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( math::g_Pi / 12.0, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_rotate_small"
        )
      );
      e_SSERotateXSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( x_rot_s, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_rotate_x_small"
        )
      );
      e_SSERotateYSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( y_rot_s, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_rotate_y_small"
        )
      );
      e_SSERotateZSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( z_rot_s, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_rotate_z_small"
        )
      );
      e_SSERotateLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( math::g_Pi / 12.0, math::g_Pi / 4.0, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_rotate_large"
        )
      );
      e_SSERotateXLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( x_rot_s, x_rot_l, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_rotate_x_large"
        )
      );
      e_SSERotateYLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( y_rot_s, y_rot_l, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_rotate_y_large"
        )
      );
      e_SSERotateZLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( z_rot_s, z_rot_l, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_rotate_z_large"
        )
      );

      // construct transformations
      e_SSETransformSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTransformRandom( 2.0, math::g_Pi / 12.0, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_transform_small"
        )
      );
      e_SSETransformLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTransformRandom( 2.0, 6.0, math::g_Pi / 12.0, math::g_Pi / 4.0, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_transform_large"
        )
      );

      // construct flips
      const coord::MoveRotateDefined x_flip( coord::MoveRotateDefined::GetFlipMove( coord::GetAxes().e_X));
      const coord::MoveRotateDefined y_flip( coord::MoveRotateDefined::GetFlipMove( coord::GetAxes().e_Y));
      const coord::MoveRotateDefined z_flip( coord::MoveRotateDefined::GetFlipMove( coord::GetAxes().e_Z));

      // add x, y and z flips
      e_SSEFlipX = GetMutates().AddMutate( MutateProteinModelSSE( sp_locator_sse_random, util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( x_flip), false)), MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_flip_x"));
      e_SSEFlipY = GetMutates().AddMutate( MutateProteinModelSSE( sp_locator_sse_random, util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( y_flip), false)), MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_flip_y"));
      e_SSEFlipZ = GetMutates().AddMutate( MutateProteinModelSSE( sp_locator_sse_random, util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( z_flip), false)), MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_flip_z"));

    ////////////////////////
    // single helix moves //
    ////////////////////////

      // move a helix next to SSE
      e_HelixMoveNext = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_helix_random_wrapped,
          placement_next_to_sse,
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_move_next"
        )
      );

      // move a helix next to short loop SSE
      e_HelixMoveShortLoop = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_helix_random_wrapped,
          placement_short_loop,
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_move_short_loop"
        )
      );

      // move the furthest helix next to SSE
      e_HelixFurthestMoveNext = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_helix_furthest,
          placement_next_to_sse,
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_furthest_move_next"
        )
      );

      // translation along xy axes 0 to 2 angstroms
      const linal::Vector3D xy_translation_small( 2.0, 2.0, 0.0);
      e_HelixTranslateXYSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( xy_translation_small, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_translate_xy_small"
        )
      );

      // translation along xy axes 2 to 4 angstroms
      const linal::Vector3D xy_translation_large( 4.0, 4.0, 0.0);
      e_HelixTranslateXYLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( xy_translation_small, xy_translation_large, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_translate_xy_large"
        )
      );

      // translation along z axis 0 to 2 angstroms
      const linal::Vector3D z_translation_small( 0.0, 0.0, 2.0);
      e_HelixTranslateZSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( z_translation_small, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_translate_z_small"
        )
      );

      // translation along z axis 2 to 4 angstroms
      const linal::Vector3D z_translation_large( 0.0, 0.0, 4.0);
      e_HelixTranslateZLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( z_translation_small, z_translation_large, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_translate_z_large"
        )
      );

      // rotation around xy axes 0 to 15 degrees
      const linal::Vector3D xy_rotation_small( math::g_Pi / 12.0, math::g_Pi / 12.0, 0.0);
      e_HelixRotateXYSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( xy_rotation_small, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_rotate_xy_small"
        )
      );

      // rotation around xy axes 15 to 45 degrees
      const linal::Vector3D xy_rotation_large( math::g_Pi / 4.0, math::g_Pi / 4.0, 0.0);
      e_HelixRotateXYLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( xy_rotation_small, xy_rotation_large, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_rotate_xy_large"
        )
      );

      // rotation around z axis 0 to 15 degrees
      const linal::Vector3D z_rotation_small( 0.0, 0.0, math::g_Pi / 12.0);
      e_HelixRotateZSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( z_rotation_small, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_rotate_z_small"
        )
      );

      // rotation around z axis 15 to 45 degrees
      const linal::Vector3D z_rotation_large( 0.0, 0.0, math::g_Pi / 4.0);
      e_HelixRotateZLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( z_rotation_small, z_rotation_large, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_rotate_z_large"
        )
      );

      // small transformation around xy axes
      e_HelixTransformXYSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTransformRandom( xy_translation_small, xy_rotation_small, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_transform_xy_small"
        )
      );

      // large transformation around xy axes
      e_HelixTransformXYLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTransformRandom( xy_translation_small, xy_translation_large, xy_rotation_small, xy_rotation_large, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_transform_xy_large"
        )
      );

      // small transformation around z axis
      e_HelixTransformZSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTransformRandom( z_translation_small, z_rotation_small, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_transform_z_small"
        )
      );

      // large transformation around z axis
      e_HelixTransformZLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_helix_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTransformRandom( z_translation_small, z_translation_large, z_rotation_small, z_rotation_large, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_transform_z_large"
        )
      );

      // construct xy flip which consists of a x flip and then a random rotation around Z axis between 0 and 360 degrees
      util::ShPtrList< coord::MoveInterface> moves_list;
      moves_list.PushBack( util::ShPtr< coord::MoveInterface>( x_flip.Clone()));
      moves_list.PushBack
      (
        util::ShPtr< coord::MoveInterface>( new coord::MoveRotateRandom( linal::Vector3D( 0.0, 0.0, 2.0 * math::g_Pi)))
      );
      coord::MoveCombine xy_flip( moves_list);

      // add xy and z flip
      e_HelixFlipXY = GetMutates().AddMutate( MutateProteinModelSSE( sp_locator_helix_random, util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( xy_flip), false)), MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_flip_xy"));
      e_HelixFlipZ = GetMutates().AddMutate( MutateProteinModelSSE( sp_locator_helix_random, util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( z_flip), false)), MutateTree::GetMutateTypeName( MutateTree::e_Helix) + "_flip_z"));

    /////////////////////////
    // single strand moves //
    /////////////////////////

      // move a strand next to a sheet
      e_StrandMoveNext = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_strand_random_wrapped,
          placement_next_to_sse, MutateTree::GetMutateTypeName( MutateTree::e_Strand) + "_move_next"
        )
      );

      // move the furthest strand next to a sheet
      e_StrandFurthestMoveNext = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_strand_furthest,
          placement_next_to_sse,
          MutateTree::GetMutateTypeName( MutateTree::e_Strand) + "_furthest_move_next"
        )
      );

      // move a strand next to a sheet
      e_StrandMoveSheet = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_strand_random_wrapped,
          placement_strand_next_to_sheet,
          MutateTree::GetMutateTypeName( MutateTree::e_Strand) + "_move_sheet"
        )
      );

      // move the furthest strand next to a sheet
      e_StrandFurthestMoveSheet = GetMutates().AddMutate
      (
        MutateProteinModelSSEMove
        (
          locator_strand_furthest,
          placement_strand_next_to_sheet,
          MutateTree::GetMutateTypeName( MutateTree::e_Strand) + "_furthest_move_sheet"
        )
      );

      // translation along z axis 0 to 2 angstroms
      e_StrandTranslateZSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_strand_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( z_translation_small, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Strand) + "_translate_z_small"
        )
      );

      // translation along z axis 2 to 4 angstroms
      e_StrandTranslateZLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_strand_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( z_translation_small, z_translation_large, true)), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Strand) + "_translate_z_large"
        )
      );

      // add flips
      e_StrandFlipX = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_strand_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( x_flip), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Strand) + "_flip_x"
        )
      );
      e_StrandFlipY = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_strand_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( y_flip), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Strand) + "_flip_y"
        )
      );
      e_StrandFlipZ = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_strand_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( z_flip), false)),
          MutateTree::GetMutateTypeName( MutateTree::e_Strand) + "_flip_z"
        )
      );

    ////////////////////
    // sse pair moves //
    ////////////////////

      // small translations along the hinge axis
      e_SSEPairTranslateNoHingeSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSEPairHinge
        (
          *collector_sse_pair,
          coord::MoveTranslateRandom( 2.0),
          false,
          MutateTree::GetMutateTypeName( MutateTree::e_SSEPair) + "_translate_no_hinge_small"
        )
      );

      // large translations along the hinge axis
      e_SSEPairTranslateNoHingeLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSEPairHinge
        (
          *collector_sse_pair,
          coord::MoveTranslateRandom( 2.0, 4.0),
          false,
          MutateTree::GetMutateTypeName( MutateTree::e_SSEPair) + "_translate_no_hinge_large"
        )
      );

      // translate sse pair small
      e_SSEPairTranslateSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSEPair
        (
          collector_sse_pair,
          math::Range< double>( 0.0, 1.0), // translation range
          math::Range< double>( 0.0, 0.0), // 0 to 15 degrees rotation
          MutateTree::GetMutateTypeName( MutateTree::e_SSEPair) + "_translate_small"
        )
      );

      // translate sse pair large
      e_SSEPairTranslateLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSEPair
        (
          collector_sse_pair,
          math::Range< double>( 1.0, 3.0), // translation range
          math::Range< double>( 0.0, 0.0), // 15 degree to 45 degree rotation
          MutateTree::GetMutateTypeName( MutateTree::e_SSEPair) + "_translate_large"
        )
      );

      // rotate sse pair small
      e_SSEPairRotateSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSEPair
        (
          collector_sse_pair,
          math::Range< double>( 0.0, 0.0), // translation range
          math::Range< double>( 0.0, math::g_Pi / 12.0), // 0 to 15 degrees rotation
          MutateTree::GetMutateTypeName( MutateTree::e_SSEPair) + "_rotate_small"
        )
      );

      // rotate sse pair large
      e_SSEPairRotateLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSEPair
        (
          collector_sse_pair,
          math::Range< double>( 0.0, 0.0), // translation range
          math::Range< double>( math::g_Pi / 18.0, math::g_Pi / 4.0), // 10 to 45 degree rotation
          MutateTree::GetMutateTypeName( MutateTree::e_SSEPair) + "_rotate_large"
        )
      );

      // translate sse pair small
      e_SSEPairTransformSmall = GetMutates().AddMutate
      (
        MutateProteinModelSSEPair
        (
          collector_sse_pair,
          math::Range< double>( 0.0, 1.0), // translation range
          math::Range< double>( 0.0, math::g_Pi / 18.0), // 0 to 10 degrees rotation
          MutateTree::GetMutateTypeName( MutateTree::e_SSEPair) + "_transform_small"
        )
      );

      // translate sse pair large
      e_SSEPairTransformLarge = GetMutates().AddMutate
      (
        MutateProteinModelSSEPair
        (
          collector_sse_pair,
          math::Range< double>( 1.0, 3.0), // translation range
          math::Range< double>( math::g_Pi / 18.0, math::g_Pi / 4.0), // 10 to 45 degrees rotation
          MutateTree::GetMutateTypeName( MutateTree::e_SSEPair) + "_transform_large"
        )
      );

    //////////////////////
    // helix pair moves //
    //////////////////////

      // small rotations around Z axis of the hinge
      e_HelixPairRotateZSmallNoHinge = GetMutates().AddMutate
      (
        MutateProteinModelSSEPairHinge
        (
          *collector_helix_pair,
          coord::MoveRotateRandom( z_rotation_small),
          false,
          MutateTree::GetMutateTypeName( MutateTree::e_HelixPair) + "_rotate_z_small_no_hinge"
        )
      );

      // small rotations around Z axis of the hinge, also rotation the hinge
      e_HelixPairRotateZSmallHinge = GetMutates().AddMutate
      (
        MutateProteinModelSSEPairHinge
        (
          *collector_helix_pair,
          coord::MoveRotateRandom( z_rotation_small),
          true,
          MutateTree::GetMutateTypeName( MutateTree::e_HelixPair) + "_rotate_z_small_hinge"
        )
      );

      // large rotations around Z axis of the hinge
      e_HelixPairRotateZLargeNoHinge = GetMutates().AddMutate
      (
        MutateProteinModelSSEPairHinge
        (
          *collector_helix_pair,
          coord::MoveRotateRandom( z_rotation_small, z_rotation_large),
          false,
          MutateTree::GetMutateTypeName( MutateTree::e_HelixPair) + "_rotate_z_large_no_hinge"
        )
      );

      // large rotations around Z axis of the hinge, also rotation the hinge
      e_HelixPairRotateZLargeHinge = GetMutates().AddMutate
      (
        MutateProteinModelSSEPairHinge
        (
          *collector_helix_pair,
          coord::MoveRotateRandom( z_rotation_small, z_rotation_large),
          true,
          MutateTree::GetMutateTypeName( MutateTree::e_HelixPair) + "_rotate_z_large_hinge"
        )
      );

    ////////////////////////
    // helix domain moves //
    ////////////////////////

      // initialize random helix domain locator of 2 to 4 helices
      assemble::LocatorDomainRandom helix_domain_locator( math::Range< size_t>( 2, 4), biol::GetSSTypes().HELIX);

      // shuffle helices in the domain
      e_HelixDomainShuffle = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          helix_domain_locator,
          MutateDomainShuffle( 2, DefaultFlags::GetFlagFitSwappedSSEs()->GetFlag()),
          MutateTree::GetMutateTypeName( MutateTree::e_HelixDomain) + "_shuffle"
        )
      );

      // translate the helix domain up to 2 angstroms
      e_HelixDomainTranslateSmall = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          helix_domain_locator,
          coord::MoveTranslateRandom( 2.0, true),
          MutateTree::GetMutateTypeName( MutateTree::e_HelixDomain) + "_translate_small"
        )
      );

      // translate the helix domain up to 6 angstroms
      e_HelixDomainTranslateLarge = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          helix_domain_locator,
          coord::MoveTranslateRandom( 2.0, 6.0, true),
          MutateTree::GetMutateTypeName( MutateTree::e_HelixDomain) + "_translate_large"
        )
      );

      // rotate the helix domain 0 to 15 degrees
      e_HelixDomainRotateSmall = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          helix_domain_locator,
          coord::MoveRotateRandom( math::g_Pi / 12.0, true),
          MutateTree::GetMutateTypeName( MutateTree::e_HelixDomain) + "_rotate_small"
        )
      );

      // rotate the helix domain 15 to 45 degrees
      e_HelixDomainRotateLarge = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          helix_domain_locator,
          coord::MoveRotateRandom( math::g_Pi / 12.0, math::g_Pi / 4.0, true),
          MutateTree::GetMutateTypeName( MutateTree::e_HelixDomain) + "_rotate_large"
        )
      );

      // transform the helix domain with 0 to 2 angstrom translation and 0 to 15 degree rotation
      e_HelixDomainTransformSmall = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          helix_domain_locator,
          coord::MoveTransformRandom( 2.0, math::g_Pi / 6.0),
          MutateTree::GetMutateTypeName( MutateTree::e_HelixDomain) + "_transform_small"
        )
      );

      // transform the helix domain with 2 to 6 angstrom translation and 15 to 45 degree rotation
      e_HelixDomainTransformLarge = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          helix_domain_locator,
          coord::MoveTransformRandom( 2.0, 6.0, math::g_Pi / 12.0, math::g_Pi / 4.0),
          MutateTree::GetMutateTypeName( MutateTree::e_HelixDomain) + "_transform_large"
        )
      );

      // flip helix domain externally around a randomly determined axis
      e_HelixDomainFlipExt = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateDomainFlip( xyz_axes_set, false),
          MutateTree::GetMutateTypeName( MutateTree::e_HelixDomain) + "_flip_ext"
        )
      );

      // flip each helix in the domain internally around an axis
      e_HelixDomainFlipInt = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateDomainFlip( xyz_axes_set, true, true),
          MutateTree::GetMutateTypeName( MutateTree::e_HelixDomain) + "_flip_int"
        )
      );

    /////////////////
    // sheet moves //
    /////////////////

      // rotate the sheet up to 15 degrees
      e_SheetRotateSmall = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          coord::MoveRotateRandom( math::g_Pi / 12.0, true),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_rotate_small"
        )
      );

      // rotate the sheet between 15 and 45 degrees
      e_SheetRotateLarge = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          coord::MoveRotateRandom( math::g_Pi / 12.0, math::g_Pi / 4.0, true),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_rotate_large"
        )
      );

      // translate sheet upto 2 angstroms
      e_SheetTranslateSmall = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          coord::MoveTranslateRandom( 2.0, true),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_translate_small"
        )
      );

      // translate sheet between 2 and 4 angstroms
      e_SheetTranslateLarge = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          coord::MoveTranslateRandom( 2.0, 4.0, true),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_translate_large"
        )
      );

      // transform sheet with upto 2 angstrom translation and 15 degrees rotation
      e_SheetTransformSmall = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          coord::MoveTransformRandom( 2.0, math::g_Pi / 12.0),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_transform_small"
        )
      );

      // transform sheet with upto 2 angstrom translation and 15 degrees rotation
      e_SheetTransformLarge = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          coord::MoveTransformRandom( 2.0, 4.0, math::g_Pi / 12.0, math::g_Pi / 4.0),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_transform_large"
        )
      );

      // pair strands
      e_SheetPairStrands = GetMutates().AddMutate
      (
        MutateProteinModelPairStrands( MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_pair_strands")
      );

      // move strand from one sheet to another
      e_SheetSwitchStrand = GetMutates().AddMutate
      (
        MutateProteinModelStrandSwitchSheet
        (
          placement_strand_next_to_sheet, MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_switch_strand"
        )
      );

      e_SheetFlipExt = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateDomainFlip( xyz_axes_set, false),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_flip_ext"
        )
      );

      e_SheetFlipInt = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateDomainFlip( xyz_axes_set, true, true),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_flip_int"
        )
      );

      e_Sheet_flip_int_sub = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateDomainFlip( xyz_axes_set, true, false, false),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_flip_int_sub"
        )
      );

      e_Sheet_flip_int_sub_diff = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateDomainFlip( xyz_axes_set, true, false, true),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_flip_int_sub_diff"
        )
      );

      // divide a sheet into two pieces
      e_Sheet_divide = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetDivide( 4, 2, false),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_divide"
        )
      );

      // divide a sheet into two pieces as a sandwich
      e_Sheet_divide_sandwich = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetDivide( 4, 2, true),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_divide_sandwich"
        )
      );

      // adjusts twist angles each pair strand in the selected sheet between 0 and 5 degrees
      e_Sheet_twist_small = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetTwist( math::Range< double>( 0.0, math::Angle::Radian( 2.0))),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_twist_small"
        )
      );

      // adjusts twist angles each pair strand in the selected sheet between 0 and 5 degrees
      e_Sheet_twist_large = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetTwist( math::Range< double>( 0.0, math::Angle::Radian( 10.0))),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_twist_large"
        )
      );

      // does 1 to 2 swaps within the sheet
      e_Sheet_shuffle = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateDomainShuffle( 2, DefaultFlags::GetFlagFitSwappedSSEs()->GetFlag()),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_shuffle"
        )
      );

      // build nr_rotations
      const math::Range< size_t> nr_rotations( 1, 3);
      const math::Range< size_t> subset_size( 2, 4);

      // cycles all the strands in the sheet by shifting 1 to 3 positions
      e_Sheet_cycle = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetCycle( true, false, false, nr_rotations),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_cycle"
        )
      );

      // cycles all the strands in the sheet shifting 1 to 3 positions while keeping pairwise orientations intact
      e_Sheet_cycle_intact = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetCycle( true, true, false, nr_rotations),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_cycle_intact"
        )
      );

      // cycles the positions, shifting 1 to 3 positions, of a subset (2 to 4) strands in a given sheet
      e_Sheet_cycle_subset = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetCycle( true, false, true, nr_rotations, subset_size),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_cycle_subset"
        )
      );

      // cycles the positions, shifting 1 to 3 positions, of a subset (2 to 4) strands in a given sheet
      // while keeping pairwise orientations intact
      e_Sheet_cycle_subset_intact = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetCycle( true, true, true, nr_rotations, subset_size),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_cycle_subset_intact"
        )
      );

      // fixes the hyrogen bonding pattern of strands in a sheet
      e_Sheet_register_fix = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetRegisterFix(),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_register_fix"
        )
      );

      // shifts the register of strands in a sheet by translations
      e_Sheet_register_shift = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetRegisterShift( storage::VectorND< 2, double>( 1.0, 0.0)),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_register_shift"
        )
      );

      // shifts the register of strands in a sheet by flips, half the translation and a flip around z axis
      e_Sheet_register_shift_flip = GetMutates().AddMutate
      (
        MutateProteinModelDomain
        (
          *collector_sheet,
          MutateSheetRegisterShift( storage::VectorND< 2, double>( 0.0, 1.0)),
          MutateTree::GetMutateTypeName( MutateTree::e_Sheet) + "_register_shift_flip"
        )
      );
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void DefaultMutates::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      // // get the pool using the empty model
      util::ShPtr< assemble::SSEPool> sp_pool
      (
        GetSetup().GetEmptyModel()->GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      BCL_Assert( sp_pool.IsDefined(), "pool is not initialized!");

      // get the average number of helices and strands, and calculate the ratios
      const storage::Pair< double, double> avg_sse_counts( sp_pool->CalculateAverageHelixStrandCounts());
      const double avg_helix_count( avg_sse_counts.First());
      const double avg_strand_count( avg_sse_counts.Second());
      const double avg_sse_count( avg_helix_count + avg_strand_count);
      const double avg_helix_ratio( avg_helix_count / avg_sse_count);
      const double avg_strand_ratio( avg_strand_count / avg_sse_count);

      BCL_MessageStd
      (
        "average helix/strand/sse counts from pool: " + util::Format()( avg_helix_count) + " / " +
         util::Format()( avg_strand_count) + " / " + util::Format()( avg_sse_count)
      );

      // initialize variables that are based on the counts
      const bool has_helix( avg_helix_count > 0);
      const bool has_strand( avg_strand_count > 0);
      const bool has_helixdomain( avg_helix_count >= 1.5);
      const bool has_helixpair( avg_helix_count >= 1.5);
      const bool has_sheet( avg_strand_count >= 1.5);

      // first choose probabilities for add, remove, swap, move
      MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_Add,         0.075);
      MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_Remove,      0.025);
      MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_Swap,        0.10);
      MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_SSE,         0.10);
      MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_Helix,       0.20 * avg_helix_ratio);
      MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_Strand,      0.20 * avg_strand_ratio);
      const double ssepair_weight(                                     0.20);
      MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_SSEPair,     ssepair_weight);
      const double domain_weight(                                      0.30);

      // if has a helix pair
      if( has_helixpair)
      {
        // update helix pair weight
        MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_HelixPair, ssepair_weight * avg_helix_ratio);
        MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_SSEPair,   ssepair_weight * avg_strand_ratio);
      }

      // update domain weights
      if( has_helixdomain)
      {
        MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_HelixDomain, domain_weight * avg_helix_ratio);
      }

      if( has_sheet)
      {
        MUTATE_TREE.SetDefaultMutateTypeProbability( MutateTree::e_Sheet,       domain_weight * avg_strand_ratio);
      }

      // adds
      MUTATE_TREE.SetDefaultMutateProbability( e_AddSSENextToSSE     , 0.75);
      MUTATE_TREE.SetDefaultMutateProbability( e_AddSSEShortLoop     , 0.25);
      MUTATE_TREE.SetDefaultMutateProbability( e_AddStrandNextToSheet, 1.00 * avg_strand_ratio);
      // remove
      MUTATE_TREE.SetDefaultMutateProbability( e_RemoveRandom        , 0.5);
      MUTATE_TREE.SetDefaultMutateProbability( e_RemoveUnpairedStrand, 0.5);

      // swap
      MUTATE_TREE.SetDefaultMutateProbability( e_SwapSSEs       , 0.8);
      MUTATE_TREE.SetDefaultMutateProbability( e_SwapSSEWithPool, 0.2);
      // if the pool is overlapping
      if( sp_pool->IsOverlapping())
      {
        MUTATE_TREE.SetDefaultMutateProbability( e_SwapSSEWithPoolOverlap, 0.2);
      }

      // single SSE moves
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEMoveNext,         3.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEMoveShortLoop,    3.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEFurthestMoveNext, 3.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEBendRamachandran, 1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEBendRandomSmall,  1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEBendRandomLarge,  1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETranslateSmall,   3.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETranslateXSmall,  1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETranslateYSmall,  1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETranslateZSmall,  1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETranslateLarge,   3.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETranslateXLarge,  1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETranslateYLarge,  1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETranslateZLarge,  1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSERotateSmall,      3.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSERotateXSmall,     1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSERotateYSmall,     1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSERotateZSmall,     1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSERotateLarge,      3.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSERotateXLarge,     1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSERotateYLarge,     1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSERotateZLarge,     1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETransformSmall,   6.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSETransformLarge,   6.0);

      // if secondary structure prediction were provided and sse resizing is not disabled
      if
      (
        sspred::Methods::GetFlagReadSSPredictions()->GetFlag() &&
        DefaultFlags::GetFlagEnableSSEResize()->GetFlag()
      )
      {
        // average number of non overlapping sses
        const double number_non_overlapping_long_sses( sp_pool->CountLongNonOverlappingSSEs( 30, 20));
        const double split_probability( ( 2.0 + 2 * number_non_overlapping_long_sses) / m_SSESplit.GetSize());

        // resize move
        MUTATE_TREE.SetDefaultMutateProbability( e_SSEResizeCTerm, 1.5);
        MUTATE_TREE.SetDefaultMutateProbability( e_SSEResizeNTerm, 1.5);

        // iterate over ss prediction methods
        for
        (
          storage::Map< sspred::Method, Mutate>::const_iterator
            sspred_itr( m_SSESplit.Begin()), sspred_itr_end( m_SSESplit.End());
          sspred_itr != sspred_itr_end;
          ++sspred_itr
        )
        {
          MUTATE_TREE.SetDefaultMutateProbability( sspred_itr->second, split_probability);
        }
      }

      // single helix moves
      if( has_helix)
      {
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixMoveNext,             2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixMoveShortLoop,        2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixFurthestMoveNext,     2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixTranslateXYSmall,     1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixTranslateXYLarge,     2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixTranslateZSmall,      1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixTranslateZLarge,      2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixRotateXYSmall,        1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixRotateXYLarge,        2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixRotateZSmall,         1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixRotateZLarge,         2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixTransformXYSmall,     1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixTransformXYLarge,     2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixTransformZSmall,      1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixTransformZLarge,      2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixFlipXY,               2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixFlipZ,                2.0);
      }

      // single strand moves
      if( has_strand)
      {
        MUTATE_TREE.SetDefaultMutateProbability( e_StrandMoveNext,          2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_StrandFurthestMoveNext,  2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_StrandMoveSheet,         2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_StrandFurthestMoveSheet, 2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_StrandTranslateZSmall,   1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_StrandTranslateZLarge,   2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_StrandFlipX,             2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_StrandFlipY,             2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_StrandFlipZ,             2.0);
      }

      // sse pair moves
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEPairTranslateNoHingeSmall, 1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEPairTranslateNoHingeLarge, 2.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEPairTranslateSmall,        1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEPairTranslateLarge,        2.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEPairRotateSmall,           1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEPairRotateLarge,           2.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEPairTransformSmall,        1.0);
      MUTATE_TREE.SetDefaultMutateProbability( e_SSEPairTransformLarge,        2.0);

      // helix pair moves
      if( has_helixpair)
      {
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixPairRotateZSmallNoHinge, 1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixPairRotateZSmallHinge,   1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixPairRotateZLargeNoHinge, 1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixPairRotateZLargeHinge,   1.0);
      }

      // helix domain moves
      if( has_helixdomain)
      {
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixDomainShuffle,        8.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixDomainTranslateSmall, 1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixDomainTranslateLarge, 2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixDomainRotateSmall,    1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixDomainRotateLarge,    2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixDomainTransformSmall, 1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixDomainTransformLarge, 2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixDomainFlipExt,        2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_HelixDomainFlipInt,        2.0);
      }

      // sheet moves
      if( has_sheet)
      {
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetRotateSmall,           1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetRotateLarge,           2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetTranslateSmall,        1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetTranslateLarge,        2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetTransformSmall,        1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetTransformLarge,        2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetPairStrands,           2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetSwitchStrand,          4.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetFlipExt,               2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_SheetFlipInt,               2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_flip_int_sub,         2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_flip_int_sub_diff,    2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_divide,               2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_divide_sandwich,      2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_twist_small,          2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_twist_large,          2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_shuffle,              8.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_cycle,                4.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_cycle_intact,         4.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_cycle_subset,         4.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_cycle_subset_intact,  4.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_register_fix,         1.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_register_shift,       2.0);
        MUTATE_TREE.SetDefaultMutateProbability( e_Sheet_register_shift_flip,  2.0);
      }

    }

    //! @brief initializes the mutate tree for the given protein model
    //! @param TREE mutate tree that shall be optimized
    //! @param MODEL protein model for which the mutate tree shall be optimized
    void DefaultMutates::InitializeMutateTree( MutateTree &TREE, const assemble::ProteinModel &MODEL) const
    {
      // get the pool of the protein model
      util::ShPtr< assemble::SSEPool> sp_pool
      (
        MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );

      // get the average number of helices and strands, and calculate the ratios
      const storage::Pair< double, double> avg_sse_counts
      (
        sp_pool.IsDefined() ? sp_pool->CalculateAverageHelixStrandCounts() : storage::Pair< double, double>( 5, 5)
      );
      const double avg_helix_count( avg_sse_counts.First());
      const double avg_strand_count( avg_sse_counts.Second());
      const double avg_sse_count( avg_helix_count + avg_strand_count);
      const double avg_helix_ratio( avg_helix_count / avg_sse_count);
      const double avg_strand_ratio( avg_strand_count / avg_sse_count);

      BCL_MessageStd
      (
        "average helix/strand/sse counts from pool: " + util::Format()( avg_helix_count) + " / " +
         util::Format()( avg_strand_count) + " / " + util::Format()( avg_sse_count)
      );

      // initialize variables that are based on the counts
      const bool has_helix( avg_helix_count > 0);
      const bool has_strand( avg_strand_count > 0);
      const bool has_helixdomain( avg_helix_count >= 1.5);
      const bool has_helixpair( avg_helix_count >= 1.5);
      const bool has_sheet( avg_strand_count >= 1.5);

      // first choose probabilities for add, remove, swap, move
      TREE.SetDefaultMutateTypeProbability( MutateTree::e_Add,         0.075);
      TREE.SetDefaultMutateTypeProbability( MutateTree::e_Remove,      0.025);
      TREE.SetDefaultMutateTypeProbability( MutateTree::e_Swap,        0.10);
      TREE.SetDefaultMutateTypeProbability( MutateTree::e_SSE,         0.10);
      TREE.SetDefaultMutateTypeProbability( MutateTree::e_Helix,       0.20 * avg_helix_ratio);
      TREE.SetDefaultMutateTypeProbability( MutateTree::e_Strand,      0.20 * avg_strand_ratio);
      const double ssepair_weight(                                     0.20);
      TREE.SetDefaultMutateTypeProbability( MutateTree::e_SSEPair,     ssepair_weight);
      const double domain_weight(                                      0.30);

      // if has a helix pair
      if( has_helixpair)
      {
        // update helix pair weight
        TREE.SetDefaultMutateTypeProbability( MutateTree::e_HelixPair, ssepair_weight * avg_helix_ratio);
        TREE.SetDefaultMutateTypeProbability( MutateTree::e_SSEPair,   ssepair_weight * avg_strand_ratio);
      }

      // update domain weights
      if( has_helixdomain)
      {
        TREE.SetDefaultMutateTypeProbability( MutateTree::e_HelixDomain, domain_weight * avg_helix_ratio);
      }
      if( has_sheet)
      {
        TREE.SetDefaultMutateTypeProbability( MutateTree::e_Sheet,       domain_weight * avg_strand_ratio);
      }

      // adds
      TREE.SetDefaultMutateProbability( e_AddSSENextToSSE     , 0.75);
      TREE.SetDefaultMutateProbability( e_AddSSEShortLoop     , 0.25);
      TREE.SetDefaultMutateProbability( e_AddStrandNextToSheet, 1.00 * avg_strand_ratio);
      // remove
      TREE.SetDefaultMutateProbability( e_RemoveRandom        , 0.5);
      TREE.SetDefaultMutateProbability( e_RemoveUnpairedStrand, 0.5);

      // swap
      TREE.SetDefaultMutateProbability( e_SwapSSEs       , 0.8);
      TREE.SetDefaultMutateProbability( e_SwapSSEWithPool, 0.2);
      // if the pool is overlapping
      if( !sp_pool.IsDefined() || sp_pool->IsOverlapping())
      {
        TREE.SetDefaultMutateProbability( e_SwapSSEWithPoolOverlap, 0.2);
      }

      // single SSE moves
      TREE.SetDefaultMutateProbability( e_SSEMoveNext,         3.0);
      TREE.SetDefaultMutateProbability( e_SSEMoveShortLoop,    3.0);
      TREE.SetDefaultMutateProbability( e_SSEFurthestMoveNext, 3.0);
      TREE.SetDefaultMutateProbability( e_SSEBendRamachandran, 1.0);
      TREE.SetDefaultMutateProbability( e_SSEBendRandomSmall,  1.0);
      TREE.SetDefaultMutateProbability( e_SSEBendRandomLarge,  1.0);
      TREE.SetDefaultMutateProbability( e_SSETranslateSmall,   3.0);
      TREE.SetDefaultMutateProbability( e_SSETranslateXSmall,  1.0);
      TREE.SetDefaultMutateProbability( e_SSETranslateYSmall,  1.0);
      TREE.SetDefaultMutateProbability( e_SSETranslateZSmall,  1.0);
      TREE.SetDefaultMutateProbability( e_SSETranslateLarge,   3.0);
      TREE.SetDefaultMutateProbability( e_SSETranslateXLarge,  1.0);
      TREE.SetDefaultMutateProbability( e_SSETranslateYLarge,  1.0);
      TREE.SetDefaultMutateProbability( e_SSETranslateZLarge,  1.0);
      TREE.SetDefaultMutateProbability( e_SSERotateSmall,      3.0);
      TREE.SetDefaultMutateProbability( e_SSERotateXSmall,     1.0);
      TREE.SetDefaultMutateProbability( e_SSERotateYSmall,     1.0);
      TREE.SetDefaultMutateProbability( e_SSERotateZSmall,     1.0);
      TREE.SetDefaultMutateProbability( e_SSERotateLarge,      3.0);
      TREE.SetDefaultMutateProbability( e_SSERotateXLarge,     1.0);
      TREE.SetDefaultMutateProbability( e_SSERotateYLarge,     1.0);
      TREE.SetDefaultMutateProbability( e_SSERotateZLarge,     1.0);
      TREE.SetDefaultMutateProbability( e_SSETransformSmall,   6.0);
      TREE.SetDefaultMutateProbability( e_SSETransformLarge,   6.0);

      // if secondary structure prediction were provided and sse resizing is not disabled
      if
      (
        sspred::Methods::GetFlagReadSSPredictions()->GetFlag() &&
        DefaultFlags::GetFlagEnableSSEResize()->GetFlag()
      )
      {
        // average number of non overlapping sses
        const double number_non_overlapping_long_sses
        (
          sp_pool.IsDefined() ? sp_pool->CountLongNonOverlappingSSEs( 30, 20) : 2.0
        );
        const double split_probability( ( 2.0 + 2 * number_non_overlapping_long_sses) / m_SSESplit.GetSize());

        // resize move
        TREE.SetDefaultMutateProbability( e_SSEResizeCTerm, 1.5);
        TREE.SetDefaultMutateProbability( e_SSEResizeNTerm, 1.5);

        // iterate over ss prediction methods
        for
        (
          storage::Map< sspred::Method, Mutate>::const_iterator
            sspred_itr( m_SSESplit.Begin()), sspred_itr_end( m_SSESplit.End());
          sspred_itr != sspred_itr_end;
          ++sspred_itr
        )
        {
          TREE.SetDefaultMutateProbability( sspred_itr->second, split_probability);
        }
      }

      // single helix moves
      if( has_helix)
      {
        TREE.SetDefaultMutateProbability( e_HelixMoveNext,             2.0);
        TREE.SetDefaultMutateProbability( e_HelixMoveShortLoop,        2.0);
        TREE.SetDefaultMutateProbability( e_HelixFurthestMoveNext,     2.0);
        TREE.SetDefaultMutateProbability( e_HelixTranslateXYSmall,     1.0);
        TREE.SetDefaultMutateProbability( e_HelixTranslateXYLarge,     2.0);
        TREE.SetDefaultMutateProbability( e_HelixTranslateZSmall,      1.0);
        TREE.SetDefaultMutateProbability( e_HelixTranslateZLarge,      2.0);
        TREE.SetDefaultMutateProbability( e_HelixRotateXYSmall,        1.0);
        TREE.SetDefaultMutateProbability( e_HelixRotateXYLarge,        2.0);
        TREE.SetDefaultMutateProbability( e_HelixRotateZSmall,         1.0);
        TREE.SetDefaultMutateProbability( e_HelixRotateZLarge,         2.0);
        TREE.SetDefaultMutateProbability( e_HelixTransformXYSmall,     1.0);
        TREE.SetDefaultMutateProbability( e_HelixTransformXYLarge,     2.0);
        TREE.SetDefaultMutateProbability( e_HelixTransformZSmall,      1.0);
        TREE.SetDefaultMutateProbability( e_HelixTransformZLarge,      2.0);
        TREE.SetDefaultMutateProbability( e_HelixFlipXY,               2.0);
        TREE.SetDefaultMutateProbability( e_HelixFlipZ,                2.0);
      }

      // single strand moves
      if( has_strand)
      {
        TREE.SetDefaultMutateProbability( e_StrandMoveNext,          2.0);
        TREE.SetDefaultMutateProbability( e_StrandFurthestMoveNext,  2.0);
        TREE.SetDefaultMutateProbability( e_StrandMoveSheet,         2.0);
        TREE.SetDefaultMutateProbability( e_StrandFurthestMoveSheet, 2.0);
        TREE.SetDefaultMutateProbability( e_StrandTranslateZSmall,   1.0);
        TREE.SetDefaultMutateProbability( e_StrandTranslateZLarge,   2.0);
        TREE.SetDefaultMutateProbability( e_StrandFlipX,             2.0);
        TREE.SetDefaultMutateProbability( e_StrandFlipY,             2.0);
        TREE.SetDefaultMutateProbability( e_StrandFlipZ,             2.0);
      }

      // sse pair moves
      TREE.SetDefaultMutateProbability( e_SSEPairTranslateNoHingeSmall, 1.0);
      TREE.SetDefaultMutateProbability( e_SSEPairTranslateNoHingeLarge, 2.0);
      TREE.SetDefaultMutateProbability( e_SSEPairTranslateSmall,        1.0);
      TREE.SetDefaultMutateProbability( e_SSEPairTranslateLarge,        2.0);
      TREE.SetDefaultMutateProbability( e_SSEPairRotateSmall,           1.0);
      TREE.SetDefaultMutateProbability( e_SSEPairRotateLarge,           2.0);
      TREE.SetDefaultMutateProbability( e_SSEPairTransformSmall,        1.0);
      TREE.SetDefaultMutateProbability( e_SSEPairTransformLarge,        2.0);

      // helix pair moves
      if( has_helixpair)
      {
        TREE.SetDefaultMutateProbability( e_HelixPairRotateZSmallNoHinge, 1.0);
        TREE.SetDefaultMutateProbability( e_HelixPairRotateZSmallHinge,   1.0);
        TREE.SetDefaultMutateProbability( e_HelixPairRotateZLargeNoHinge, 1.0);
        TREE.SetDefaultMutateProbability( e_HelixPairRotateZLargeHinge,   1.0);
      }

      // helix domain moves
      if( has_helixdomain)
      {
        TREE.SetDefaultMutateProbability( e_HelixDomainShuffle,        8.0);
        TREE.SetDefaultMutateProbability( e_HelixDomainTranslateSmall, 1.0);
        TREE.SetDefaultMutateProbability( e_HelixDomainTranslateLarge, 2.0);
        TREE.SetDefaultMutateProbability( e_HelixDomainRotateSmall,    1.0);
        TREE.SetDefaultMutateProbability( e_HelixDomainRotateLarge,    2.0);
        TREE.SetDefaultMutateProbability( e_HelixDomainTransformSmall, 1.0);
        TREE.SetDefaultMutateProbability( e_HelixDomainTransformLarge, 2.0);
        TREE.SetDefaultMutateProbability( e_HelixDomainFlipExt,        2.0);
        TREE.SetDefaultMutateProbability( e_HelixDomainFlipInt,        2.0);
      }

      // sheet moves
      if( has_sheet)
      {
        TREE.SetDefaultMutateProbability( e_SheetRotateSmall,           1.0);
        TREE.SetDefaultMutateProbability( e_SheetRotateLarge,           2.0);
        TREE.SetDefaultMutateProbability( e_SheetTranslateSmall,        1.0);
        TREE.SetDefaultMutateProbability( e_SheetTranslateLarge,        2.0);
        TREE.SetDefaultMutateProbability( e_SheetTransformSmall,        1.0);
        TREE.SetDefaultMutateProbability( e_SheetTransformLarge,        2.0);
        TREE.SetDefaultMutateProbability( e_SheetPairStrands,           2.0);
        TREE.SetDefaultMutateProbability( e_SheetSwitchStrand,          4.0);
        TREE.SetDefaultMutateProbability( e_SheetFlipExt,               2.0);
        TREE.SetDefaultMutateProbability( e_SheetFlipInt,               2.0);
        TREE.SetDefaultMutateProbability( e_Sheet_flip_int_sub,         2.0);
        TREE.SetDefaultMutateProbability( e_Sheet_flip_int_sub_diff,    2.0);
        TREE.SetDefaultMutateProbability( e_Sheet_divide,               2.0);
        TREE.SetDefaultMutateProbability( e_Sheet_divide_sandwich,      2.0);
        TREE.SetDefaultMutateProbability( e_Sheet_twist_small,          2.0);
        TREE.SetDefaultMutateProbability( e_Sheet_twist_large,          2.0);
        TREE.SetDefaultMutateProbability( e_Sheet_shuffle,              8.0);
        TREE.SetDefaultMutateProbability( e_Sheet_cycle,                4.0);
        TREE.SetDefaultMutateProbability( e_Sheet_cycle_intact,         4.0);
        TREE.SetDefaultMutateProbability( e_Sheet_cycle_subset,         4.0);
        TREE.SetDefaultMutateProbability( e_Sheet_cycle_subset_intact,  4.0);
        TREE.SetDefaultMutateProbability( e_Sheet_register_fix,         1.0);
        TREE.SetDefaultMutateProbability( e_Sheet_register_shift,       2.0);
        TREE.SetDefaultMutateProbability( e_Sheet_register_shift_flip,  2.0);
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DefaultMutates::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DefaultMutates::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_default_scores.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_count.h"
#include "fold/bcl_fold_score_weight_set.h"
#include "score/bcl_score_aa_neighborhood_exposure.h"
#include "score/bcl_score_aa_pair_clash.h"
#include "score/bcl_score_aa_pair_contact_energy.h"
#include "score/bcl_score_aa_pair_distance.h"
#include "score/bcl_score_aa_pair_hi_res_clash.h"
#include "score/bcl_score_aa_sequence_pair.h"
#include "score/bcl_score_contact_order.h"
#include "score/bcl_score_loop.h"
#include "score/bcl_score_loop_angle.h"
#include "score/bcl_score_loop_closure.h"
#include "score/bcl_score_phi_psi.h"
#include "score/bcl_score_protein_model_aa_neighborhood.h"
#include "score/bcl_score_protein_model_inverted.h"
#include "score/bcl_score_protein_model_sse.h"
#include "score/bcl_score_protein_model_sse_chirality.h"
#include "score/bcl_score_protein_model_sse_completeness.h"
#include "score/bcl_score_protein_model_sse_linear_loop_proximity.h"
#include "score/bcl_score_protein_model_sse_neighbors.h"
#include "score/bcl_score_protein_model_sse_packing.h"
#include "score/bcl_score_protein_model_sse_pairs.h"
#include "score/bcl_score_protein_model_wrapper.h"
#include "score/bcl_score_radius_of_gyration.h"
#include "score/bcl_score_sse_pair_clash.h"
#include "score/bcl_score_sse_pair_gap.h"
#include "score/bcl_score_sse_pair_packing.h"
#include "score/bcl_score_sse_pairs_fragments.h"
#include "score/bcl_score_sse_predictions.h"
#include "score/bcl_score_strand_pairing.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> DefaultScores::s_Instance
    (
      GetObjectInstances().AddInstance( new DefaultScores())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    DefaultScores::DefaultScores() :
      m_ProteinInverter( new assemble::ProteinModelInverter( true))
    {
    }

    //! @brief Clone function
    //! @return pointer to new DefaultScores
    DefaultScores *DefaultScores::Clone() const
    {
      return new DefaultScores( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief acces to static instance of this class
    DefaultScores &DefaultScores::GetInstance()
    {
      static DefaultScores s_default_scores_instance;
      return s_default_scores_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &DefaultScores::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the protein inverter
    //! @return the protein inverter
    const util::ShPtr< assemble::ProteinModelInverter> &DefaultScores::GetProteinInverter() const
    {
      return m_ProteinInverter;
    }

    //! @brief get the sspred scores
    //! the sspred scores
    const storage::Map< sspred::Method, storage::VectorND< 2, Score> > &DefaultScores::GetSSPredScores() const
    {
      return m_SSPredScores;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief initialize the scores and add them to Scores enumerator
    void DefaultScores::InitializeScores()
    {
      // was already initialized?
      if( e_ScoreAAPairClash.IsDefined())
      {
        return;
      }

      // aa distance clash
      e_ScoreAAPairClash = GetScores().AddScore
      (
//        util::ShPtr< score::ProteinModel>
//        (
//          new score::ProteinModelSSEPairs
//          (
//            Scores::WrapCacheSSEPairScore
//            (
//              util::CloneToShPtr( score::AASequencePair( score::AAPairClash(), false)),
//              false // symmetric
//            ),
//            false, // no normalization
//            score::ProteinModel::e_Sequence,
//            "AA pair distance"
//          )
//        )
        util::ShPtr< score::ProteinModel>
        (
          new score::AAPairClash()
        )
//        util::ShPtr< score::ProteinModel>
//        (
//          new score::ProteinModelSSEPairs
//          (
//            fold::Scores::WrapCacheSSEPairScore( util::CloneToShPtr( score::AAPairClash()), false),
//            false, // no normalization
//            score::ProteinModel::e_Sequence,
//            "AA pair distance"
//          )
//        )
      );

      // aa distance score
      e_ScoreAAPairDistance = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
          new score::AAPairDistance()
        )
      );

      // aa_clash_hires
      e_ScoreAAPairHiResClash = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::AAPairHiResClash()
          )
        )
      );

      // aa_pair_interaction
      e_ScoreAAPairSCInteraction = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
          new score::AAPairContactEnergy()
        )
      );

      // aaneigh score
      e_ScoreAANeighborCount = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
            new score::ProteinModelAANeighborhood
            (
              util::CloneToShPtr( score::AANeighborhoodExposure( assemble::AANeighborCount())),
              score::ProteinModelAANeighborhood::e_None,
              true,
              score::ProteinModel::e_Sequence,
              "AA environment"
            )
        )
      );

      // aaneigh entropy score
      e_ScoreAANeighborCountEntropy = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
          new score::ProteinModelInverted
          (
            Scores::WrapCacheProteinModelScore
            (
              util::ShPtr< score::ProteinModel>
              (
                  new score::ProteinModelAANeighborhood
                  (
                    util::CloneToShPtr( score::AANeighborhoodExposure( assemble::AANeighborCount())),
                    score::ProteinModelAANeighborhood::e_None, // normalize
                    false // consider different chain
                  )
              )
            ),
            m_ProteinInverter,
            assemble::AANeighborCount::GetDefaultScheme() + "_ent",
            score::ProteinModel::e_Sequence,
            "AA environment"
          )
        )
      );

      // loop score; faster to compute than to cache
      e_ScoreLoop = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
          new score::ProteinModelSSEPairs
          (
            Scores::WrapCacheSSEPairScore( util::CloneToShPtr( score::Loop()), false),
            true,
            score::ProteinModel::e_Structure,
            "Loop closure"
          )
        )
      );

      // loop angle score
      e_ScoreLoopAngle = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>( new score::LoopAngle())
      );

      // loop closure score; computation is faster than caching, so no wrapping with cache
      e_ScoreLoopClosure = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
          new score::ProteinModelWrapper
          (
            util::CloneToShPtr
            (
              score::ProteinModelSSENeighbors
              (
                util::CloneToShPtr( score::LoopClosure( 1, 1.0, 1.0)),
                false // no normalization
              )
            ),
            score::ProteinModel::e_Structure,
            "Loop closure 1A bin",
            "loop_closure"
          )
        )
      );

      // loop closure score with wider transition region, calculation is faster than caching
      e_ScoreLoopClosureGradient = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
          new score::ProteinModelWrapper
          (
            util::CloneToShPtr
            (
              score::ProteinModelSSENeighbors
              (
                util::CloneToShPtr( score::LoopClosure( 1, 20, 1.0)),
                false // no normalization
              )
            ),
            score::ProteinModel::e_Structure,
            "Loop closure 20A bin",
            "loop_closure_gradient"
          )
        )
      );

      // phi psi
      e_ScorePhiPsi = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
          new score::ProteinModelSSE
          (
            Scores::WrapCacheSSEScore
            (
              util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >
              (
                new score::PhiPsi( score::PhiPsi::GetDefaultScheme())
              )
            ),
            false
          )
        )
      );

      e_ScoreSSELoopClash = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSELinearLoopProximity( false, true, 0.125)
          )
        )
      );

      // sse confidence
      // iterate over sse methods
      storage::Set< sspred::Method> ss_pred_methods( sspred::Methods::GetCommandLineMethods());
      for
      (
        storage::Set< sspred::Method>::const_iterator
          sspred_itr( ss_pred_methods.Begin()), sspred_itr_end( ss_pred_methods.End());
        sspred_itr != sspred_itr_end;
        ++sspred_itr
      )
      {
        const std::string scheme( "ss_" + sspred_itr->GetName());
        util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >
        sp_sse_preds
        (
          util::CloneToShPtr( score::SSEPredictions( *sspred_itr, 0.0, scheme))
        );

        // add the wrapped ProteinModel score
        const util::ShPtr< score::ProteinModel> sp_score
        (
          util::CloneToShPtr
          (
            score::ProteinModelSSE
            (
              sp_sse_preds,
              false,
              score::ProteinModel::e_Sequence,
              "SS prediction"
            )
          )
        );
        m_SSPredScores[ *sspred_itr].First() = GetScores().AddScore( sp_score);

        // construct the entropy term form the same score
        const std::string scheme_ent( scheme + "_ent");
        util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >
        sp_sse_preds_ent
        (
          Scores::WrapCacheSSEScore( util::CloneToShPtr( score::SSEPredictions( *sspred_itr, 0.0, "")))
        );
        m_SSPredScores[ *sspred_itr].Second() = GetScores().AddScore
        (
          Scores::WrapCacheProteinModelScore
          (
            util::CloneToShPtr
            (
              score::ProteinModelInverted
              (
                Scores::WrapCacheProteinModelScore( sp_score),
                m_ProteinInverter,
                scheme_ent,
                score::ProteinModel::e_Sequence,
                "SS prediction"
              )
            )
          )
        );
      }

      // radius of gyration
      e_ScoreRadiusOfGyration = GetScores().AddScore
      (
        util::CloneToShPtr( score::RadiusOfGyration())
      );

      // relative contact order score
      e_ScoreContactOrder = GetScores().AddScore
      (
        util::CloneToShPtr
        (
          score::ContactOrder
          (
            contact::Order::e_RelativeAAsUsed,
            false, // normalize
            score::ContactOrder::GetDefaultScheme(),
            false
          )
        )
      );

      // sse packing
      e_ScoreSSEFragmentPairPacking = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
          new score::ProteinModelSSEPairs
          (
            Scores::WrapCacheSSEPairScore
            (
              util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> >
              (
                new score::SSEPairsFragments
                (
                  assemble::GetSSEGeometryPackingListPickers().e_BestInteractionWeight,
                  score::SSEPairPacking
                  (
                    score::SSEPairPacking::GetDefaultScheme() + "_fr", "sse_fragment_angle_distance.histograms2D"
                  ),
                  false
                )
              ),
              false // symmetric
            ),
            false,
            score::ProteinModel::e_Structure,
            "SSE packing"
          )
        )
      );

      // strand pairing. Very fast to compute, so caching is not beneficial
      e_ScoreStrandFragmentPairing = GetScores().AddScore
      (
        util::ShPtr< score::ProteinModel>
        (
          new score::ProteinModelSSEPairs
          (
            Scores::WrapCacheSSEPairScore
            (
              util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> >
              (
                new score::SSEPairsFragments
                (
                  assemble::GetSSEGeometryPackingListPickers().e_BestInteractionWeight,
                  score::StrandPairing
                  (
                    score::StrandPairing::GetDefaultScheme() + "_fr", "strand_fragment_angle_distance.histograms2D"
                  ), false
                )
              ),
              false
            ),
            false,
            score::ProteinModel::e_Structure,
            "Strand pairing"
          )
        )
      );

       // between sses aa clash checking all atoms of each aa
      e_ScoreSSECompleteness = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSECompleteness()
          )
        )
      );
      e_ScoreSSETripletChirality = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSEChirality( 120.0, false)
          )
        )
      );
      e_ScoreSSEDerivedTripletChirality = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSEChirality( 120.0, true)
          )
        )
      );
      e_ScoreSSEContactType = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSEPacking( score::ProteinModelSSEPacking::e_ContactType)
          )
        )
      );
      e_ScoreSSEAdjacentContact = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSEPacking( score::ProteinModelSSEPacking::e_AdjacentSSEContactPropensity)
          )
        )
      );
      e_ScoreSSEOrientation = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSEPacking( score::ProteinModelSSEPacking::e_Orientation)
          )
        )
      );
      e_ScoreSSEInteractionWeight = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSEPacking( score::ProteinModelSSEPacking::e_InteractionWeight)
          )
        )
      );
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void DefaultScores::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
      // reset the map
      SCORE_WEIGHT_SET.Reset();

      // adjust the weights
      SCORE_WEIGHT_SET.SetWeight( e_ScoreAAPairClash           ,     0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreAAPairDistance        ,     0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreAAPairHiResClash      ,    50.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreAAPairSCInteraction   ,     0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreAANeighborCount       ,    50.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreAANeighborCountEntropy,    50.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreContactOrder          ,     0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreLoop                  ,    10.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreLoopAngle             ,     0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreLoopClosureGradient   , 50000.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreRadiusOfGyration      ,     5.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSELoopClash          ,    10.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSEFragmentPairPacking,     8.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreStrandFragmentPairing ,    20.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSECompleteness       ,     0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSETripletChirality   ,     0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSEDerivedTripletChirality, 0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSEContactType,             0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSEAdjacentContact,         0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSEOrientation,             0.00);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSEInteractionWeight,       0.00);

      for
      (
        storage::Map< sspred::Method, storage::VectorND< 2, Score> >::const_iterator sspred_itr( m_SSPredScores.Begin()),
          sspred_itr_end( m_SSPredScores.End());
        sspred_itr != sspred_itr_end;
        ++sspred_itr
      )
      {
        double weight( 1.0);
        if( sspred_itr->first == sspred::GetMethods().e_PSIPRED)
        {
          weight = 20.0;
        }
        else if( sspred_itr->first == sspred::GetMethods().e_JUFO)
        {
          weight = 5.0;
        }

        SCORE_WEIGHT_SET.SetWeight( sspred_itr->second.First(), weight);  // normal score
        SCORE_WEIGHT_SET.SetWeight( sspred_itr->second.Second(), weight); // entropy score
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &DefaultScores::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &DefaultScores::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_handler_locator_loop_domain.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_aa.h"
#include "fold/bcl_fold_collector_unconnected_sses.h"
#include "fold/bcl_fold_handler_locator_loop_segment.h"
#include "fold/bcl_fold_locator_loop_domain.h"
#include "fold/bcl_fold_loop_segment.h"
#include "fold/bcl_fold_loop_segment_sequence_order.h"
#include "fold/bcl_fold_mutation_residue.h"
#include "fold/bcl_fold_phi_psi_generator_ramachandran.h"
#include "fold/bcl_fold_protocol_loop_coordinate_add.h"
#include "util/bcl_util_sh_ptr_list.h"
#include "util/bcl_util_string_functions.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! the string used to indicate the end of a loop domain
      const std::string HandlerLocatorLoopDomain::s_DomainEndString( "DomainLocatorEnd");

      //! single instance of that class
      const util::SiPtr< const util::ObjectInterface> HandlerLocatorLoopDomain::s_Instance
      (
        GetObjectInstances().AddInstance( new HandlerLocatorLoopDomain())
      );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @param RANDOMIZE_PHI_PSI bool true if the phi and psi values held in the pseudo residue should be randomized
    HandlerLocatorLoopDomain::HandlerLocatorLoopDomain( const bool RANDOMIZE_PHI_PSI) :
      m_RandomizePseudoResiduePhiPsi( RANDOMIZE_PHI_PSI)
    {
    }

    //! @brief Clone function
    //! @return pointer to new HandlerLocatorLoopDomain
    HandlerLocatorLoopDomain *HandlerLocatorLoopDomain::Clone() const
    {
      return new HandlerLocatorLoopDomain( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &HandlerLocatorLoopDomain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief HandleRead creates a LocatorLoopDomain when from an istream and protein model
    //! @param ISTREAM the file stream which contains the loop domain locator information
    //! @param MODEL the protein model which will be used to help create the LocatorLoopDomain
    //! @return LocatorLoopDomain which has been created from ISTREAM and MODEL
    LocatorLoopDomain HandlerLocatorLoopDomain::HandleRead
    (
      std::istream &ISTREAM, const assemble::ProteinModel &MODEL
    ) const
    {
      // get the list of LocatorLoopSegments from "ISTREAM"
      const storage::List< LocatorLoopSegment> loop_segment_locators( CreateLocatorLoopSegments( ISTREAM));

      // true if "loop_segment_locators" has no loop segment locators in it
      if( loop_segment_locators.IsEmpty())
      {
        // return empty LocatorLoopDomain
        return LocatorLoopDomain();
      }

      // create loop domain locator from "loop_segment_locators"
      const LocatorLoopDomain domain_locator( loop_segment_locators);

      // return "domain_locator"
      return domain_locator;
    }

    //! @brief HandleReadMultiple can create a list of LocatorLoopDomain objects from a file and a protein model
    //! @param ISTREAM the file stream which contains the loop domain locators information
    //! @param MODEL the protein model which will be used to help create the LocatorLoopDomains
    //! @return list of LocatorLoopDomains which has been created from ISTREAM and MODEL
    util::ShPtrList< LocatorLoopDomain> HandlerLocatorLoopDomain::HandleReadMultiple
    (
      std::istream &ISTREAM, const assemble::ProteinModel &MODEL
    ) const
    {
      // create list to hold all of the LocatorLoopDomain objects
      util::ShPtrList< LocatorLoopDomain> locator_list;

      // read in the first LocatorLoopDomain from ISTREAM
      const util::ShPtr< LocatorLoopDomain> current_locator( HandleRead( ISTREAM, MODEL).Clone());

      // add "current_locator" to "locator_list"
      locator_list.PushBack( current_locator);

      // print the number of LocatorLoopDomains read in so far
      BCL_MessageDbg
      (
        "read in " + util::Format()( locator_list.GetSize()) + " locator domains so far"
      );

      // while the ISTREAM still has stuff in it
      while( !ISTREAM.eof() && ISTREAM.good() && !ISTREAM.fail())
      {
        // print the number of LocatorLoopDomains read in so far
        BCL_MessageDbg
        (
          "read in " + util::Format()( locator_list.GetSize()) + " locator domains so far"
        );

        // create the current LocatorLoopDomain from ISTREAM
        const util::ShPtr< LocatorLoopDomain> current_locator( HandleRead( ISTREAM, MODEL).Clone());

        // true if "current_locator" is not empty
        if( !current_locator->GetLoopSegments().IsEmpty())
        {
          // add "current_locator" to "locator_list"
          locator_list.PushBack( current_locator);
        }
      }

      // return the created list of LocatorLoopDomains
      return locator_list;
    }

    //! @brief CreateLocatorLoopDomainsForInteriorCoil creates a list of loop domain locators from a protein model
    //! It creates a loop domain locator for every coil sse that is in the protein model
    //! @param MODEL the model for which a list of loop domain locators will be created for all its coil sses
    //! @return a list of LocatorLoopDomains created from MODEL - one for each coild sse
    const util::ShPtrList< LocatorLoopDomain> HandlerLocatorLoopDomain::CreateLocatorLoopDomainsForInteriorCoil
    (
      const assemble::ProteinModel &MODEL
    ) const
    {
      // create list which will hold the loop domain locators created from MODEL
      util::ShPtrList< LocatorLoopDomain> loop_domain_list;

      // get the list of coil sses in "MODEL". The sses will be ordered by chain and sequence
      const util::SiPtrVector< const assemble::SSE> coil_sses( MODEL.GetSSEs( biol::GetSSTypes().COIL));

      // iterate through "coil_sses"
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          sse_itr( coil_sses.Begin()), sse_itr_end( coil_sses.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // get the starting seq id of the sse
        const int sse_start_seq_id( ( *sse_itr)->GetFirstAA()->GetSeqID());

        // get the ending seq id of the sse
        const int sse_end_seq_id( ( *sse_itr)->GetLastAA()->GetSeqID());

        // get the chain id of the sse
        const char chain_id( ( *sse_itr)->GetChainID());

        // true if the current sse is not the first or last sse in the sse's chain
        // this is important since only interior regions of the protein will be built
        if
        (
          sse_start_seq_id != MODEL.GetChain( chain_id)->GetSequence()->GetFirstAA()->GetSeqID() &&
          sse_end_seq_id != MODEL.GetChain( chain_id)->GetSequence()->GetLastAA()->GetSeqID()
        )
        {
          // create a LocatorLoopSegment for the sse currently denoted by "sse_itr"
          const LocatorLoopSegment current_loop_segment
          (
            assemble::LocatorSSE( chain_id, sse_start_seq_id, sse_end_seq_id),
            false //< loopsegment is not rigid
          );

          // put "current_loop_segment" into a list
          const storage::List< LocatorLoopSegment> loop_segment_list( 1, current_loop_segment);

          // create the loop domain locator
          const util::ShPtr< LocatorLoopDomain> domain_locator
          (
            new LocatorLoopDomain( loop_segment_list)
          );

          // add "domain_locator" to "loop_domain_list"
          loop_domain_list.PushBack( domain_locator);
        }
      }

      // return the list of loop domains where every coil sse is a loop domain
      return loop_domain_list;
    }

    //! @brief creates a list of loop domain locators from a protein model with bidirectionally grown loops
    //! every loop is assumed to be made up of two coils with on attached n and the other attached c terminally
    //! @param MODEL the model for which a list of loop domain locators will be created for all its coil sses
    //! @return a list of LocatorLoopDomains created from MODEL
    util::ShPtr< util::ShPtrList< LocatorLoopDomain> >
    HandlerLocatorLoopDomain::CreateBidirectionalLocatorsForInteriorCoil
    (
      const assemble::ProteinModel &MODEL
    ) const
    {
      // create list which will hold the loop domain locators created from MODEL
      util::ShPtr< util::ShPtrList< LocatorLoopDomain> > loop_domain_list( new util::ShPtrList< LocatorLoopDomain>());

      const CollectorUnconnectedSSE collector_unconnected_sse_n_flex
      (
        biol::AASequenceFlexibility::e_NTerminal,
        true,
        storage::Set< biol::SSType>( biol::GetSSTypes().COIL),
        true
      );
      const CollectorUnconnectedSSE collector_unconnected_sse_c_flex
      (
        biol::AASequenceFlexibility::e_CTerminal,
        true,
        storage::Set< biol::SSType>( biol::GetSSTypes().COIL),
        true
      );

      const util::SiPtrList< const assemble::SSE> n_flex_coils( collector_unconnected_sse_n_flex.Collect( MODEL));
      const util::SiPtrList< const assemble::SSE> c_flex_coils( collector_unconnected_sse_c_flex.Collect( MODEL));

      // iterate over n flex coils
      for( util::SiPtrList< const assemble::SSE>::const_iterator itr( n_flex_coils.Begin()), itr_end( n_flex_coils.End()); itr != itr_end; ++itr)
      {
        // insert locator into list of loop domains
        BCL_MessageVrb( "CreateCToNLocator adding loop domain locator for sse " + ( *itr)->GetIdentification());
        const util::ShPtr< LocatorLoopDomain> cterm_nflex_locator( CreateCToNLocator( **itr, MODEL));
        loop_domain_list->PushBack( cterm_nflex_locator);
      }

      // iterate over c flex coils
      for( util::SiPtrList< const assemble::SSE>::const_iterator itr( c_flex_coils.Begin()), itr_end( c_flex_coils.End()); itr != itr_end; ++itr)
      {
        // insert locator into list of loop domains
        BCL_MessageVrb( "CreateNToCLocator adding loop domain locator for sse " + ( *itr)->GetIdentification());
        const util::ShPtr< LocatorLoopDomain> nterm_cflex_locator( CreateNToCLocator( **itr, MODEL));
        loop_domain_list->PushBack( nterm_cflex_locator);
      }

      BCL_MessageVrb( "loop domain list size is " + util::Format()( loop_domain_list->GetSize()));

      // return the list of loop domains where every coil sse is a loop domain
      return loop_domain_list;
    }

    //! @brief creates a locator loop domain that will give an N to C direction loop domain
    //! @param SSE the sse that will be used to make a loop domain locator
    //! @param MODEL the model that will be used to make LocatorLoopDomain
    //! @return ShPtr to a LocatorLoopDomain
    util::ShPtr< LocatorLoopDomain>
    HandlerLocatorLoopDomain::CreateNToCLocator( const assemble::SSE &SSE, const assemble::ProteinModel &MODEL) const
    {
      // get the starting seq id of the sse
      const int sse_start_seq_id( SSE.GetFirstAA()->GetSeqID());

      // get the ending seq id of the sse
      const int sse_end_seq_id( SSE.GetLastAA()->GetSeqID());

      // get the chain id of the sse
      const char chain_id( SSE.GetChainID());

      // create a LocatorLoopSegment for the sse currently denoted by "sse_itr"
      const LocatorLoopSegment current_loop_segment
      (
        assemble::LocatorSSE( chain_id, sse_start_seq_id, sse_end_seq_id),
        false //< loopsegment is not rigid
      );

      // put "current_loop_segment" into a list
      const storage::List< LocatorLoopSegment> loop_segment_list( 1, current_loop_segment);

      // create the loop domain locator
      const util::ShPtr< LocatorLoopDomain> domain_locator
      (
        new LocatorLoopDomain( loop_segment_list)
      );

      return domain_locator;
    }

    //! @brief creates a locator loop domain that will give an C to N direction loop domain
    //! @param SSE the sse that will be used to make a loop domain locator
    //! @param MODEL the model that will be used to make LocatorLoopDomain
    //! @return ShPtr to a LocatorLoopDomain
    util::ShPtr< LocatorLoopDomain>
    HandlerLocatorLoopDomain::CreateCToNLocator( const assemble::SSE &SSE, const assemble::ProteinModel &MODEL) const
    {
      // get the starting seq id of the sse
      const int sse_start_seq_id( SSE.GetFirstAA()->GetSeqID());

      // get the ending seq id of the sse
      const int sse_end_seq_id( SSE.GetLastAA()->GetSeqID());

      // get the chain id of the sse
      const char chain_id( SSE.GetChainID());

      // create a LocatorLoopSegment for the sse currently denoted by "sse_itr"
      const LocatorLoopSegment current_loop_segment
      (
        assemble::LocatorSSE( chain_id, sse_start_seq_id, sse_end_seq_id),
        false //< loopsegment is not rigid
      );

      // put "current_loop_segment" into a list
      const storage::List< LocatorLoopSegment> loop_segment_list( 1, current_loop_segment);

      // get anchor aa locator
      const assemble::LocatorAA aa_anchor_locator( SSE.GetChainID(), SSE.GetFirstAA()->GetSeqID());

    ///////////////////////////
    // create pseudo residue //
    ///////////////////////////

      const util::SiPtr< const biol::AABase> pseudo_residue_basis
      (
        assemble::LocatorAA( SSE.GetChainID(), SSE.GetFirstAA()->GetSeqID() - 1).Locate( MODEL)
      );

      BCL_Assert( pseudo_residue_basis.IsDefined(), "pseudo residue basis is not defined");

      // create a ShPtr to the residue that is the basis for the pseudo residue
      const util::ShPtr< biol::AABase> dummy_pseudo_residue_basis( pseudo_residue_basis->Clone());

      // define phi and psi
      MutationResidue temp( dummy_pseudo_residue_basis, util::ShPtr< biol::AABase>(), util::ShPtr< biol::AABase>());
      storage::VectorND< 2, double> phi_psi
      (
        PhiPsiGeneratorRamachandran::GetDefaultInstance().operator()( temp)
      );

      // create the loop domain locator
      const util::ShPtr< LocatorLoopDomain> domain_locator
      (
        new LocatorLoopDomain( loop_segment_list, false)
      );

      return domain_locator;
    }

    //! @brief GetFormat gives the format that this handler needs in order to work
    //! @return string which describes the format needed by this handler in order for it to work
    std::string HandlerLocatorLoopDomain::GetFormat() const
    {
      return "Every loop domain should be separated by \"DomainLocatorEnd\"\n"
        "example\n"
        "'A' 114 114 false\n"
        "DomainLocatorEnd\n"
        "'A' 124 125 false\n"
        "DomainLocatorEnd\n"
        "'A' 126 134 false\n"
        "'A' 135 136 false\n"
        "DomainLocatorEnd";
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &HandlerLocatorLoopDomain::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &HandlerLocatorLoopDomain::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief CreateLocatorLoopSegments creates a list of loop segment locators from an istream
    //! @param ISTREAM the file stream which contains the information to create a list of loop segment locators
    //! @return a list of LocatorLoopSegments created from ISTREAM
    const storage::List< LocatorLoopSegment> HandlerLocatorLoopDomain::CreateLocatorLoopSegments
    (
      std::istream &ISTREAM
    ) const
    {
      // create list which will hold the loop segment locators created from ISTREAM
      storage::List< LocatorLoopSegment> loop_segment_list;

      // create string "current" line which will hold each of the current lines as read in from ISTREAM
      std::string current_line;

      // get the current line from ISTREAM and put it into "current_line"
      std::getline( ISTREAM, current_line);

      // trim "current_line"
      util::TrimString( current_line);

      // print "current_line"
      BCL_MessageDbg( "current_line |" + current_line + "|");

      // go until the end of file has been reached or "s_DomainEndString" has been read in
      while( current_line != s_DomainEndString && !ISTREAM.eof())
      {
        // create LoopSegment and add it to "loop_segment_list"
        loop_segment_list.PushBack( HandlerLocatorLoopSegment().HandleRead( current_line));

        // get the next line from ISREAM and put it into "current_line"
        std::getline( ISTREAM, current_line);

        // trim "current_line"
        util::TrimString( current_line);

        // print "current_line
        BCL_MessageDbg( "current_line |" + current_line + "|");
      }

      // return the list of created loop segment locators
      return loop_segment_list;
    }

    //! @brief CreateNTerminalSSELocator creates the locator to the nterminal anchor sse of a loop domain
    //! @param LOOP_SEGMENT_LOCATORS list of loop segment locators which make up a loop domain
    //! @param MODEL the protein model which the loop segment locators and the loop domain refer
    //! @return LocatorSSE which can locate the nterminal anchor sse of the loop domain
    const assemble::LocatorSSE HandlerLocatorLoopDomain::CreateNTerminalSSELocator
    (
      const storage::List< LocatorLoopSegment> &LOOP_SEGMENT_LOCATORS, const assemble::ProteinModel &MODEL
    ) const
    {
      // order the loop segments by sequence
      const storage::Set< LocatorLoopSegment, LoopSegmentSequenceOrder> ordered_segments
      (
        LOOP_SEGMENT_LOCATORS.Begin(), LOOP_SEGMENT_LOCATORS.End()
      );

      // make sure "ordered_segments" and "LOOP_SEGMENT_LOCATORS" have the same size
      BCL_Assert( ordered_segments.GetSize() == LOOP_SEGMENT_LOCATORS.GetSize(), "sizes differ");

      // get the first loop segment locator according to sequence
      const LocatorLoopSegment &locator_first_loop_segment( *ordered_segments.Begin());

      const char chain_id( locator_first_loop_segment.GetLocatorSSE().GetChainID());

      // get the sses from "MODEL" in a set sorted by sequence
      const storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap> &model_sses( MODEL.GetChain( chain_id)->GetData());

      // locate the first segment in MODEL
      const LoopSegment first_loop_segment( locator_first_loop_segment.Locate( MODEL));

      // get an iterator to the first loop segment as it is in "MODEL"
      storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator itr_first_loop_sse
      (
        model_sses.Find( first_loop_segment.GetSSE())
      );

      // make sure that the sse could be found in model
      BCL_Assert
      (
        itr_first_loop_sse != model_sses.End(), "could not find " + first_loop_segment.GetSSE()->GetIdentification()
      );

      // make sure that the first loop segment is not the first sse in the model
      BCL_Assert
      (
        itr_first_loop_sse != model_sses.Begin(), "first loop segment is the last sse in the protein model"
       );

        // move "itr_first_loop_sse" to the previous sse
        --itr_first_loop_sse;

        // get the chain id and first and last seq ids of the sse denoted by "itr_first_loop_sse"
        const char nterminal_sse_chain_id( ( *itr_first_loop_sse)->GetChainID());
        const int  nterminal_sse_start_seq_id( ( *itr_first_loop_sse)->GetFirstAA()->GetSeqID());
        const int  nterminal_sse_last_seq_id( ( *itr_first_loop_sse)->GetLastAA()->GetSeqID());

        // create locator for locating the nterminal anchor sse of the loop domain
        const assemble::LocatorSSE nterminal_sse_locator
        (
          nterminal_sse_chain_id, nterminal_sse_start_seq_id, nterminal_sse_last_seq_id
        );

        // return the locator
        return nterminal_sse_locator;
      }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_handler_locator_loop_segment.h"

// includes from bcl - sorted alphabetically
#include "fold/bcl_fold_locator_loop_segment.h"
#include "util/bcl_util_string_functions.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! number of columns that the line containing the information should have
    const size_t HandlerLocatorLoopSegment::s_ExpectedLineColumns( 4);

    //! the column number where the chain id should be in the line
    const size_t HandlerLocatorLoopSegment::s_ChainIDColumn( 0);

    //! the column number where the starting residue of the sse should be in the line
    const size_t HandlerLocatorLoopSegment::s_SSEStartSeqIDColumn( 1);

    //! the column number where the ending residue of the sse should be in the line
    const size_t HandlerLocatorLoopSegment::s_SSEEndSeqIDColumn( 2);

    //! the column number where the boolean indicating rigid or not should be in the line
    const size_t HandlerLocatorLoopSegment::s_SSEIsRigidIDColumn( 3);

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> HandlerLocatorLoopSegment::s_Instance
    (
      GetObjectInstances().AddInstance( new HandlerLocatorLoopSegment())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Clone function
    //! @return pointer to new HandlerLocatorLoopSegment
    HandlerLocatorLoopSegment *HandlerLocatorLoopSegment::Clone() const
    {
      return new HandlerLocatorLoopSegment( *this);
    }

    //! @brief virtual destructor
    HandlerLocatorLoopSegment::~HandlerLocatorLoopSegment()
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &HandlerLocatorLoopSegment::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief HandleRead creates a LocatorLoopSegment from a stream
    //! @param ISTREAM the stream from which the LocatorLoopSegment will be created
    //! @return LocatorLoopSegment which was created from the contents of ISTREAM
    LocatorLoopSegment HandlerLocatorLoopSegment::HandleRead( std::istream &ISTREAM) const
    {
      // create string to hold a line from ISTREAM
      std::string line;

      // get the current line from ISTREAM and put it into "line"
      std::getline( ISTREAM, line);

      // create LocatorLoopSegment from "line"
      return HandleRead( line);
    }

    //! @brief HandleRead creates a LocatorLoopSegment from a string
    //! @param STRING the string from which the LocatorLoopSegment will be created
    //! @return LocatorLoopSegment which was created from the contents of STRING
    LocatorLoopSegment HandlerLocatorLoopSegment::HandleRead( const std::string &STRING) const
    {
      // trim and split "STRING" and put into vector "split_line"
      const storage::Vector< std::string> split_line( util::SplitString( util::TrimString( STRING)));

      // make sure "split_line" has the correct size
      BCL_Assert
      (
        split_line.GetSize() == s_ExpectedLineColumns,
        "split line should have " + util::Format()( s_ExpectedLineColumns) + " but has " +
        util::Format()( split_line.GetSize()) + "\n" + GetFormat()
      );

      // get the chain id
      const std::string &chain_id_string( split_line( s_ChainIDColumn));

      // make sure chain id consists of three characters
      BCL_Assert
      (
        chain_id_string.size() == 3,
        "chain id column " + util::Format()( s_ChainIDColumn) +
        " should have length 3 with chain id (e.g. 'A') but is " + chain_id_string + "\n" + GetFormat()
      );

      // make sure the chain id has the correct formatting
      BCL_Assert
      (
        chain_id_string[ 0] == '\'' && chain_id_string[ 2] == '\'',
        "chain id column " + util::Format()( s_ChainIDColumn) +
        " should have length 3 with chain id (e.g. 'A') but is " + chain_id_string + "\n" + GetFormat()
      );

      // get the chain id character
      const char chain_id( chain_id_string[ 1]);

      // get the starting residue of the sse
      const std::string &sse_start_seq_id_string( split_line( s_SSEStartSeqIDColumn));

      // get the numerical value seq id of the starting residue of the sse
      const int sse_start_seq_id( util::ConvertStringToNumericalValue< int>( sse_start_seq_id_string));

      // make sure "sse_start_seq_id" is defined
      BCL_Assert
      (
        util::IsDefined( sse_start_seq_id),
        "starting seq id of SSE is undefined. Read in value is  \"" + sse_start_seq_id_string + "\""
      );

      // get the ending residue of the sse
      const std::string sse_end_seq_id_string( split_line( s_SSEEndSeqIDColumn));

      // get the numerical value seq id of the ending residue of the sse
      const int sse_end_seq_id( util::ConvertStringToNumericalValue< int>( sse_end_seq_id_string));

      // make sure "sse_end_seq_id" is defined
      BCL_Assert
      (
        util::IsDefined( sse_end_seq_id),
        "ending seq id of SSE is undefined. Read in value is  \"" + sse_end_seq_id_string + "\""
      );

      // get the boolean indicating rigid or not
      const std::string &sse_is_rigid_string( split_line( s_SSEIsRigidIDColumn));

      // convert the is_rigid string to a boolean value
      const bool sse_is_rigid( util::ConvertStringToBoolean( sse_is_rigid_string));

      // create a LocatorLoopSegment from "chain_id", "sse_start_seq_id", "sse_end_seq_id", and "sse_is_rigid"
      const LocatorLoopSegment loop_segment_locator
      (
        assemble::LocatorSSE( chain_id, sse_start_seq_id, sse_end_seq_id), sse_is_rigid
      );

      // return the created LocatorLoopSegment
      return loop_segment_locator;
    }

    //! @brief GetFormat gives the format that this handler needs in order to work
    //! @return string which describes the format needed by this handler in order for it to work
    std::string HandlerLocatorLoopSegment::GetFormat() const
    {
      return "<chain_id> <sse_start_seq_id> <sse_end_seq_id> <true/false>\n"
        "where \"true\" or \"false\" indicate whether the sse is rigid (true) or not (false)\n"
        "chain id should be surrounded by '', e.g. 'B'"
        "example\n'A' 32 34 true\nexample\n'A' 32 34 false\n";
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &HandlerLocatorLoopSegment::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &HandlerLocatorLoopSegment::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_locator_loop.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> LocatorLoop::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorLoop())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from members
    //! @param IGNORE_TERMS ignore terminal loops
    //! @param LOCATE_UNDEFINED locate undefined loop regions
    LocatorLoop::LocatorLoop( bool IGNORE_TERMS, bool LOCATE_UNDEFINED) :
      m_IgnoreTerms( IGNORE_TERMS),
      m_LocateUndefined( LOCATE_UNDEFINED)
    {
    }

    //! @brief clone function
    //! @return pointer to a new LocatorLoop
    LocatorLoop *LocatorLoop::Clone() const
    {
      return new LocatorLoop( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &LocatorLoop::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief locates loops in a protein model and computes a parameterization of the segment
    //! @param MODEL protein model for which to find loops
    //! @return parameterizations of loops in the given protein model
    util::ShPtrVector< LoopParameters> LocatorLoop::Locate
    (
      const assemble::ProteinModel &MODEL
    ) const
    {
      // get all loops in the model and filter out the ones not consistent with given options
      const util::SiPtrVector< const assemble::SSE> loops( MODEL.GetSSEs( biol::GetSSTypes().COIL));
      util::SiPtrVector< const assemble::SSE> loops_filtered;
      for( auto loop_it( loops.Begin()), loop_it_end( loops.End()); loop_it != loop_it_end; ++loop_it)
      {
        const assemble::SSE &sse( **loop_it);
        const int num_residues( MODEL.GetChain( sse.GetChainID())->GetSequence()->GetSize());
        if( !m_IgnoreTerms || ( sse.GetFirstAA()->GetSeqID() != 1 && sse.GetLastAA()->GetSeqID() != num_residues))
        {
          if( IsDefined( sse) != m_LocateUndefined)
          {
            loops_filtered.PushBack( *loop_it);
          }
        }
      }

      // compute the parameterizations for the filtered loops
      util::ShPtrVector< LoopParameters> segments;
      for
      (
        auto loop_it( loops_filtered.Begin()), loop_it_end( loops_filtered.End());
        loop_it != loop_it_end;
        ++loop_it
      )
      {
        // get the anchor residues for this loop
        const assemble::SSE &sse( **loop_it);
        const char chain_id( sse.GetChainID());
        const util::SiPtrVector< const biol::AABase> &residues
        (
          MODEL.GetChain( chain_id)->GetSequence()->GetMembers()
        );
        const int num_residues( residues.GetSize());
        const int anchor_1_seq_id( std::max( 1, ( **loop_it).GetFirstAA()->GetSeqID() - 1));
        const int anchor_2_seq_id( std::min( num_residues, ( **loop_it).GetLastAA()->GetSeqID() + 1));
        const biol::AABase &anchor_1( *residues( anchor_1_seq_id - 1));
        const biol::AABase &anchor_2( *residues( anchor_2_seq_id - 1));

        // compute the parameterization of the loop
        if( anchor_2.GetSeqID() - anchor_1.GetSeqID() > 0)
        {
          segments.PushBack( LoopParameters::Create( anchor_1, anchor_2));
        }
      }

      return segments;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief reads members from a given input stream
    //! @param ISTREAM input stream to read members from
    //! @return input stream which members were read from
    std::istream &LocatorLoop::Read( std::istream &ISTREAM)
    {
      // read members from input stream
      io::Serialize::Read( m_IgnoreTerms, ISTREAM);
      io::Serialize::Read( m_LocateUndefined, ISTREAM);

      return ISTREAM;
    }

    //! @brief writes members into a given output stream
    //! @param OSTREAM output stream to write members into
    //! @param INDENT number of indentations
    //! @return output stream into which members were written
    std::ostream &LocatorLoop::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members into output stream
      io::Serialize::Write( m_IgnoreTerms, OSTREAM, INDENT) << std::endl;
      io::Serialize::Write( m_LocateUndefined, OSTREAM, INDENT);

      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief determines if the given loop has fully defined coordinates
    //! @param LOOP loop for which to determine if it is fully defined
    //! @return true if the given loop has fully defined coordinates
    bool LocatorLoop::IsDefined( const assemble::SSE &LOOP)
    {
      const util::ShPtrVector< biol::AABase> &residues( LOOP.GetData());
      for( auto res_it( residues.Begin()), res_it_end( residues.End()); res_it != res_it_end; ++res_it)
      {
        const biol::AABase &current_res( **res_it);
        if( !current_res.HasDefinedCoordinates())
        {
          return false;
        }
      }

      return true;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_locator_loop_domain.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_loop_domain_c_to_n.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LocatorLoopDomain::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorLoopDomain())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorLoopDomain::LocatorLoopDomain() :
      m_LoopSegments(),
      m_NToCSequenceDirection()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param SEGMENT_LOCATORS the loop segment locators that will be used to find the domain loop segments
    //! @param N_TO_C true if the loop domain goes from n to c - false if LocatorLoopDomainCToN should be used instead
    LocatorLoopDomain::LocatorLoopDomain
    (
      const storage::List< LocatorLoopSegment> &SEGMENT_LOCATORS,
      const bool N_TO_C
    ) :
      m_LoopSegments( SEGMENT_LOCATORS),
      m_NToCSequenceDirection( N_TO_C)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LoopSegment
    LocatorLoopDomain *LocatorLoopDomain::Clone() const
    {
      return new LocatorLoopDomain( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &LocatorLoopDomain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetIdentification
    //! @return GetIdentification
    const std::string LocatorLoopDomain::GetIdentification() const
    {
      std::string identification( "LocatorLoopDomain identification\n");

      for
      (
        storage::List< LocatorLoopSegment>::const_iterator itr( m_LoopSegments.Begin()), itr_end( m_LoopSegments.End());
          itr != itr_end; ++itr
      )
      {
        identification += "loop segment " + itr->GetIdentification() + '\n';
      }

      identification += " n to c direction ? " + util::Format()( m_NToCSequenceDirection);

      return identification;
    }

    //! @brief GetLoopSegments gives the list of locators for the loop segments that make up the loop domain
    //! @return the list of locators for the loop segments that make up the loop domain
    const storage::List< LocatorLoopSegment> &LocatorLoopDomain::GetLoopSegments() const
    {
      return m_LoopSegments;
    }

    //! @brief give vector of all the locator sses that correspond to this loop domain
    //! @return vector of all the locator sses that correspond to this loop domain
    util::SiPtrVector< const assemble::LocatorSSE> LocatorLoopDomain::GetLocatorSSEs() const
    {
      // to hold the locator sses of this loop domain
      util::SiPtrVector< const assemble::LocatorSSE> locator_sses;

      // iterate through the list of locator loop segments
      for
      (
          storage::List< LocatorLoopSegment>::const_iterator
            segment_itr( m_LoopSegments.Begin()), segment_itr_end( m_LoopSegments.End());
          segment_itr != segment_itr_end;
          ++segment_itr
      )
      {
        locator_sses.PushBack( segment_itr->GetLocatorSSE());
      }

      return locator_sses;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Locate locates the desired LoopDomain in a domain
    //! @param SSE_DOMAIN the domain in which the LoopDomain will be located
    //! @return the desired loop domain as located in SSE_DOMAIN
    util::ShPtr< LoopDomain> LocatorLoopDomain::Locate( const assemble::DomainInterface &SSE_DOMAIN) const
    {
      // create list which will hold all of the located loop segments from "PROTEIN_MODEL"
      storage::List< LoopSegment> located_loop_segments;

      // iterate through "m_LoopSegments" in order to fill "located_loop_segments"
      for
      (
        storage::List< LocatorLoopSegment>::const_iterator
          segment_itr( m_LoopSegments.Begin()), segment_itr_end( m_LoopSegments.End());
        segment_itr != segment_itr_end;
        ++segment_itr
      )
      {
        // create a LoopSegment from ProteinModel using the LocatorLoopSegment currently denoted by "segment_itr"
        const LoopSegment loop_segment( segment_itr->Locate( SSE_DOMAIN));

        // add "loop_segment" to "located_loop_segments"
        located_loop_segments.PushBack( loop_segment);
      }

      // create LoopDomain from "located_loop_segments", "m_PseudoResidue", and "located_sse"
      util::ShPtr< LoopDomain> located_domain( new LoopDomain( located_loop_segments));

      if( m_NToCSequenceDirection)
      {
        located_domain = util::ShPtr< LoopDomain>
        (
          new LoopDomain( located_loop_segments)
        );
      }
      else
      {
        located_domain = util::ShPtr< LoopDomain>
        (
          new LoopDomainCToN( located_loop_segments)
        );
      }

      // return the created loop domain
      return located_domain;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorLoopDomain::Read( std::istream &ISTREAM)
    {
      io::Serialize::Read( m_LoopSegments, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorLoopDomain::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      io::Serialize::Write( m_LoopSegments, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculates the sum of the square of the distances between target and moving points
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @param LOCATOR_LOOP_DOMAIN Loop domain locator
    //! @return calculates the sum of the square of the distances between target and moving points
    double LocatorLoopDomain::CalculateSquareDistanceSum
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      const LocatorLoopDomain &LOCATOR_LOOP_DOMAIN
    )
    {
      util::ShPtr< LoopDomain> sp_loop_domain( LOCATOR_LOOP_DOMAIN.Locate( PROTEIN_MODEL));
      return CalculateSquareDistanceSum( sp_loop_domain->TargetAndMovingPointsForCCD( PROTEIN_MODEL));
    }

    //! @brief calculates the root mean square distance between target and moving points
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @param LOCATOR_LOOP_DOMAIN Loop domain locator
    //! @return the RMS of the points to be superimposed
    double LocatorLoopDomain::CalculateRMS
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      const LocatorLoopDomain &LOCATOR_LOOP_DOMAIN
    )
    {
      util::ShPtr< LoopDomain> sp_loop_domain( LOCATOR_LOOP_DOMAIN.Locate( PROTEIN_MODEL));
      const storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair> points( sp_loop_domain->TargetAndMovingPointsForCCD( PROTEIN_MODEL));

      // sum of square distances
      double rms( CalculateSquareDistanceSum( points));

      // rmsd
      rms /= points.GetSize();
      rms = math::Sqrt( rms);

      // end
      return rms;
    }

    //! @brief calculates the sum of the square of the distances between target and moving points
    //! @param TARGET_AND_MOVING_POINTS List of target and moving points
    double LocatorLoopDomain::CalculateSquareDistanceSum
    (
      const storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair> &TARGET_AND_MOVING_POINTS
    )
    {
      // create double which will hold the sum of the square of the distances between the target and moving points
      double distance_sum( 0);

      // iterate through the target and moving points in order to calculate the square distance between each pair
      for
      (
        storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair>::const_iterator
          points_itr( TARGET_AND_MOVING_POINTS.Begin()), points_itr_end( TARGET_AND_MOVING_POINTS.End());
        points_itr != points_itr_end;
        ++points_itr
      )
      {
        BCL_MessageDbg
        (
          "current GetTargetPoint is " + util::Format()( points_itr->GetTargetPoint())
        );
        BCL_MessageDbg
        (
          "current GetMovingPoint is " + util::Format()( points_itr->GetMovingPoint())
        );
        // add the current square distance to "starting_sum_distance"
        const double sqr_dist
        (
          linal::SquareDistance( points_itr->GetTargetPoint(), points_itr->GetMovingPoint())
        );

        distance_sum += sqr_dist;

        BCL_MessageDbg( "current square distance is " + util::Format()( sqr_dist));
      }

      // message the distance sum
      BCL_MessageDbg( "total sum square distance is " + util::Format()( distance_sum));

      // return the sum of the square of the distances between the target and moving points
      return distance_sum;
    }

    //! @brief determines if a loop domain is closed or not
    //! @param DOMAIN_LOCATOR the domain that will be checked for closure
    //! @param MODEL the protein model needed to see if loop is closed or not
    //! @param RMSD_CLOSURE_THRESHOLD the threshold in rmsd Angstrom for considering the loop closed
    //! @return bool true if the loop domain is closed - false otherwise
    bool LocatorLoopDomain::IsClosed
    (
      const LocatorLoopDomain &DOMAIN_LOCATOR,
      const assemble::ProteinModel &MODEL,
      const double RMSD_CLOSURE_THRESHOLD
    )
    {
      // create double with the current sum of the square of the distances between the target and moving points
      const double rmsd( CalculateRMS( MODEL, DOMAIN_LOCATOR));

      // return false if the distance sum more than the threshold
      if( rmsd > RMSD_CLOSURE_THRESHOLD)
      {
        return false;
      }

      // otherwise return true indicating the loop is closed
      return true;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_locator_loop_segment.h"

// includes from bcl - sorted alphabetically
#include "fold/bcl_fold_loop_segment.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LocatorLoopSegment::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorLoopSegment())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorLoopSegment::LocatorLoopSegment() :
      m_SSELocator(),
      m_IsRigid()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param SSE_LOCATOR locator to locate the SSE that will be a part of the loop segment
    //! @param IS_RIGID indicates if the dihedral angles of the SSE must be kept rigid (true), false otherwise
    LocatorLoopSegment::LocatorLoopSegment( const assemble::LocatorSSE &SSE_LOCATOR, const bool IS_RIGID) :
      m_SSELocator( SSE_LOCATOR),
      m_IsRigid( IS_RIGID)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LoopSegment
    LocatorLoopSegment *LocatorLoopSegment::Clone() const
    {
      return new LocatorLoopSegment( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &LocatorLoopSegment::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetIdentification
    //! @return GetIdentification
    const std::string LocatorLoopSegment::GetIdentification() const
    {
      return m_SSELocator.GetIdentification() + " is rigid? " + util::Format()( m_IsRigid);
    }

    //! @brief GetLocatorSSE gives the locator to locate the SSE that will be a part of the loop segment
    //! @return the locator to locate the SSE that will be a part of the loop segment
    const assemble::LocatorSSE &LocatorLoopSegment::GetLocatorSSE() const
    {
      return m_SSELocator;
    }

    //! @brief IsRigid indicates if the dihedral angles of the SSE must be kept rigid or if they can be changed
    //! @return true if the dihedral angles of the sse must be kept rigid, false otherwise
    const bool LocatorLoopSegment::IsRigid() const
    {
      return m_IsRigid;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Locate locates and creates the loop segment in a domain
    //! @param SSE_DOMAIN is the domain from which the loop segment will be located and created
    //! @return a loop segment that has been created from SSE_DOMAIN
    LoopSegment LocatorLoopSegment::Locate( const assemble::DomainInterface &SSE_DOMAIN) const
    {
      // find the sse denoted by "m_SSELocator" in "PROTEIN_MODEL"
      const util::SiPtr< const assemble::SSE> located_sse( m_SSELocator.Locate( SSE_DOMAIN));

      // make sure that the sse was able to be located
      BCL_Assert
      (
        located_sse.IsDefined(), "sse could not be located with chain " +
        util::Format()( m_SSELocator.GetChainID()) + " starting at " +
        util::Format()( m_SSELocator.GetSSEID().First()) + " and ending at " +
        util::Format()( m_SSELocator.GetSSEID().Second())
      );

      // get a shptr to a clone of "located_sse"
      const util::ShPtr< assemble::SSE> new_sse( located_sse->Clone());

      // make sure "new_sse" is defined
      BCL_Assert( new_sse.IsDefined(), "new_sse is not defined");

      // create a LoopSegment out of "new_sse" and "m_IsRigid"
      const LoopSegment loop_segment( new_sse, m_IsRigid);

      // make sure the sse in "loop_segment" is defined after construction
      BCL_Assert( loop_segment.GetSSE().IsDefined(), "sse not defined");

      // return the created LoopSegment
      return loop_segment;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorLoopSegment::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSELocator, ISTREAM);
      io::Serialize::Read( m_IsRigid, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorLoopSegment::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSELocator, OSTREAM, INDENT);
      io::Serialize::Write( m_IsRigid, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_locator_missing_coordinates.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> LocatorMissingCoordinates::s_Instance
    (
      util::Enumerated< LocatorMissingCoordinates>::AddInstance( new LocatorMissingCoordinates())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from members
    //! @param IGNORE_TERMS ignore terminal loops
    LocatorMissingCoordinates::LocatorMissingCoordinates( bool IGNORE_TERMS) :
      m_IgnoreTerms( IGNORE_TERMS)
    {
    }

    //! @brief clone function
    //! @return pointer to a new LocatorMissingCoordinates
    LocatorMissingCoordinates *LocatorMissingCoordinates::Clone() const
    {
      return new LocatorMissingCoordinates( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &LocatorMissingCoordinates::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &LocatorMissingCoordinates::GetAlias() const
    {
      static const std::string s_alias( "LocatorMissingCoordinates");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LocatorMissingCoordinates::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Locates sequence spans with missing backbone coordinates in a protein model.");
      serializer.AddInitializer
      (
        "ignore termini",
        "ignore terminal loop regions",
        io::Serialization::GetAgent( &m_IgnoreTerms)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief return regions with undefined backbone coordinates in the given protein model
    //! @param MODEL protein model for which to return regions with undefined backbone coordinates
    //! @return regions with undefined backbone coordinates
    storage::Vector< LocatorMissingCoordinates::Span> LocatorMissingCoordinates::Locate
    (
      const assemble::ProteinModel &MODEL
    ) const
    {
      storage::Vector< Span> spans;
      const util::SiPtrVector< const biol::AASequence> chains( MODEL.GetSequences());
      for( auto chain_it( chains.Begin()), chain_it_end( chains.End()); chain_it != chain_it_end; ++chain_it)
      {
        spans.Append( Locate( **chain_it));
      }

      return spans;
    }

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return regions with undefined backbone coordinates in the given sequence
    //! @param CHAIN sequence for which to return regions with undefined backbone coordinates
    //! @return regions with undefined backbone coordinates
    storage::Vector< LocatorMissingCoordinates::Span> LocatorMissingCoordinates::Locate( const biol::AASequence &CHAIN) const
    {
      storage::Vector< Span> spans;
      const util::ShPtrVector< biol::AABase> aas( CHAIN.GetData());
      util::ShPtr< biol::AABase> def_n;
      util::ShPtr< biol::AABase> def_c;
      for( auto res_it( aas.Begin()), res_it_end( aas.End()); res_it != res_it_end; ++res_it)
      {
        const biol::AABase &current_aa( **res_it);
        const bool current_defined( current_aa.HasDefinedCoordinates());
        if( !current_defined)
        {
          // find the next residue with defined backbone coordinates
          for( auto res_find_it( res_it + 1); res_find_it != res_it_end; ++res_find_it)
          {
            if( ( **res_find_it).HasDefinedCoordinates())
            {
              def_c = *res_find_it;
              res_it = res_find_it + 1;
              break;
            }
          }

          // determine the parameters of the span
          int n_id( CHAIN.GetFirstAA()->GetSeqID());
          int c_id( CHAIN.GetLastAA()->GetSeqID());
          const char chain_id( CHAIN.GetChainID());
          if( def_n.IsDefined())
          {
            n_id = def_n->GetSeqID() + 1;
          }
          if( def_c.IsDefined())
          {
            c_id = def_c->GetSeqID() - 1;
          }

          if( !m_IgnoreTerms || ( n_id != CHAIN.GetFirstAA()->GetSeqID() && c_id != CHAIN.GetLastAA()->GetSeqID()))
          {
            const Span span( n_id, c_id, chain_id);
            spans.PushBack( span);
          }

          def_n = def_c;
          def_c.Reset();
        }
        else
        {
          def_n = *res_it;
        }
      }

      return spans;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_locator_unconnected_segments.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> LocatorUnconnectedSegments::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorUnconnectedSegments())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorUnconnectedSegments::LocatorUnconnectedSegments()
    {
    }

    //! @brief clone function
    //! @return pointer to a new LocatorUnconnectedSegments
    LocatorUnconnectedSegments *LocatorUnconnectedSegments::Clone() const
    {
      return new LocatorUnconnectedSegments( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &LocatorUnconnectedSegments::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief locates unconnected segments in a protein model and computes a parameterization of the segment
    //! @detail two segments are considered unconnected if there is at least one residue without coordinates in
    //! between
    //! @param MODEL protein model for which to find unconnected segments
    //! @return parameterizations of unconnected segments in the given protein model
    util::ShPtrVector< LoopParameters> LocatorUnconnectedSegments::Locate
    (
      const assemble::ProteinModel &MODEL
    ) const
    {
      // get all loops in the model and filter out the terminal ones and fully defined ones
      const util::SiPtrVector< const assemble::SSE> loops( MODEL.GetSSEs( biol::GetSSTypes().COIL));
      util::SiPtrVector< const assemble::SSE> loops_filtered;
      for( auto loop_it( loops.Begin()), loop_it_end( loops.End()); loop_it != loop_it_end; ++loop_it)
      {
        const assemble::SSE &sse( **loop_it);
        const int num_residues( MODEL.GetChain( sse.GetChainID())->GetNumberAAs());
        if( sse.GetFirstAA()->GetSeqID() != 1 && sse.GetLastAA()->GetSeqID() != num_residues)
        {
          // check if all coordinates in this loop are defined
          const util::ShPtrVector< biol::AABase> &residues( sse.GetData());
          bool partially_undefined( false);
          for( auto res_it( residues.Begin()), res_it_end( residues.End()); res_it != res_it_end; ++res_it)
          {
            const biol::AABase &current_res( **res_it);
            if( !current_res.HasDefinedCoordinates())
            {
              partially_undefined = true;
              break;
            }
          }
          if( partially_undefined)
          {
            loops_filtered.PushBack( *loop_it);
          }
        }
      }

      // compute the parameterizations for all remaining loops
      util::ShPtrVector< LoopParameters> segments;
      for
      (
        auto loop_it( loops_filtered.Begin()), loop_it_end( loops_filtered.End());
        loop_it != loop_it_end;
        ++loop_it
      )
      {
        // get the anchor residues for this loop
        const int anchor_1_seq_id( ( **loop_it).GetFirstAA()->GetSeqID() - 1);
        const int anchor_2_seq_id( ( **loop_it).GetLastAA()->GetSeqID() + 1);
        const char chain_id( ( **loop_it).GetChainID());
        const util::SiPtrVector< const biol::AABase> &residues( MODEL.GetChain( chain_id)->GetAminoAcids());
        const biol::AABase &anchor_1( *residues( anchor_1_seq_id - 1));
        const biol::AABase &anchor_2( *residues( anchor_2_seq_id - 1));

        // compute the parameterization of the loop
        if( anchor_2.GetSeqID() - anchor_1.GetSeqID() > 0)
        {
          segments.PushBack( LoopParameters::Create( anchor_1, anchor_2));
        }
      }

      return segments;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief reads members from a given input stream
    //! @param ISTREAM input stream to read members from
    //! @return input stream which members were read from
    std::istream &LocatorUnconnectedSegments::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief writes members into a given output stream
    //! @param OSTREAM output stream to write members into
    //! @param INDENT number of indentations
    //! @return output stream into which members were written
    std::ostream &LocatorUnconnectedSegments::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_loop_domain.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_atom.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_aa_back_bone_completer.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "fold/bcl_fold_locator_loop_domain.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LoopDomain::s_Instance
    (
      GetObjectInstances().AddInstance( new LoopDomain())
    );

    //! @brief return command line flag for specifying loop domains via a file
    //! @return command line flag for specifying loop domains via a file
    util::ShPtr< command::FlagInterface> &LoopDomain::GetFlagLoopDomainFilename()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "loop_domain",
          "\tSpecific loop domain(s) should be built. If this flag is not given, then all loops will be built."
        )
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_filename
      (
        new command::Parameter
        (
          "loop_domain_filename", "\tfilename for loop domain file", "loop_domain.txt"
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_filename);
      }

      // end
      return s_flag;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LoopDomain::LoopDomain() :
      m_LoopSegments()
    {
    }

    //! @brief constructor taking parameters to create member variables
    //! @param SEGMENTS list of LoopSegments which will be used to create "m_LoopSegments"
    LoopDomain::LoopDomain
    (
      const storage::List< LoopSegment> &SEGMENTS
    ) :
      m_LoopSegments()
    {
      BCL_Assert( !SEGMENTS.IsEmpty(), "need at least one segment in loop domain");

      // build up m_LoopSegments
      for
      (
        storage::List< LoopSegment>::const_iterator
          segment_itr( SEGMENTS.Begin()), segment_itr_end( SEGMENTS.End());
        segment_itr != segment_itr_end;
        ++segment_itr
      )
      {
        // create const reference to current loop segment
        const LoopSegment &loop_segment( *segment_itr);

        // insert "loop_segment" into "loop_segment"
        m_LoopSegments.InsertElement( loop_segment);
      }
    }

    //! @brief copy constructor
    //! @param OTHER loop domain to be copied
    LoopDomain::LoopDomain( const LoopDomain &OTHER) :
      m_LoopSegments( OTHER.m_LoopSegments)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LoopSegment
    LoopDomain *LoopDomain::Clone() const
    {
      return new LoopDomain( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &LoopDomain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gives the directionality of the loop domain
    //! @return sequence direction in this case e_CTerminal since changes are propagated cterminally
    biol::AASequenceFlexibility::SequenceDirection LoopDomain::GetSequenceDirection() const
    {
      return biol::AASequenceFlexibility::e_CTerminal;
    }

    //! @brief GetSegments gives the set LoopSegments ordered by sequence that make up the loop domain
    //! @return the set LoopSegments ordered by sequence that make up the loop domain
    const storage::Set< LoopSegment, LoopSegmentSequenceOrder> &LoopDomain::GetSegments() const
    {
      return m_LoopSegments;
    }

    //! @brief finds the segment and replaces it with the given segment
    //! @param LOOP_SEGMENT segment that will replace the currently matching segment
    //! @return pair of iterator pointing to iterator where the replaced segment is and bool indicating success or not
    std::pair< storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator, bool>
    LoopDomain::ReplaceSegment( const LoopSegment &LOOP_SEGMENT)
    {
      // get iterator to segment where "LOOP_SEGMENT" is
      const storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator segment_itr
      (
        m_LoopSegments.Find( LOOP_SEGMENT)
      );

      // true if could not find loop segment containign "RESIDUE"
      if( segment_itr == m_LoopSegments.End())
      {
        BCL_MessageCrt( "could not find segment with sse " + LOOP_SEGMENT.GetSSE()->GetIdentification());
      }

      // remove the old segment and insert the new loop segment into m_LoopSegments
      m_LoopSegments.RemoveElement( segment_itr);
      std::pair< storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator, bool>
        insert_status( m_LoopSegments.Insert( LOOP_SEGMENT));
      BCL_Assert
      (
        insert_status.second, "failed to insert segment with sse " +
        LOOP_SEGMENT.GetSSE()->GetIdentification()
      );

      return insert_status;
    }

    //! @brief finds the segments and replaces them with the given segments
    //! @param LOOP_SEGMENTS segments that will replace the currently matching segments
      //! @return returns iter and bool to last replaced element
    std::pair< storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator, bool>
    LoopDomain::ReplaceSegment( const storage::List< LoopSegment> &LOOP_SEGMENTS)
    {
      std::pair< storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator, bool> status;
      for
      (
        storage::List< LoopSegment>::const_iterator
          segments_itr( LOOP_SEGMENTS.Begin()), segments_itr_end( LOOP_SEGMENTS.End());
        segments_itr != segments_itr_end;
        ++segments_itr
      )
      {
        status = ReplaceSegment( *segments_itr);
        BCL_Assert( status.second, "could not replace segment " + segments_itr->GetSSE()->GetIdentification());
      }

      return status;
    }

    //! @brief FindSegment provides an iterator to the segment containing a residue of interest
    //! @param RESIDUE the residue of interest for which the segment it is in is desired to be known
    //! @return iterator to the LoopSegment that contains RESIDUE
    storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator LoopDomain::FindSegment
    (
      const biol::AABase &RESIDUE
    ) const
    {
      // get the seq id of "RESIDUE"
      const int resi_seq_id( RESIDUE.GetSeqID());

      // get the chain id of RESIDUE
      const char resi_chain_id( RESIDUE.GetChainID());

      // find the segment where "RESIDUE" is and return iterator to it
      return FindSegment( resi_chain_id, resi_seq_id);
    }

    //! @brief FindSegment finds a residue of interest in the LoopDomain
    //! @param RESIDUE the residue of interest which should be found
    //! @return ShPtr pointing to the residue of interest
    util::ShPtr< biol::AABase>
    LoopDomain::FindResidue( const biol::AABase &RESIDUE) const
    {
      // find "RESIDUE"
      return FindResidue( assemble::LocatorAA( RESIDUE.GetChainID(), RESIDUE.GetSeqID()));
    }

    //! @brief FindSegment finds a residue of interest in the LoopDomain as described by a LocatorAA
    //! @param LOCATOR_AA the LocatorAA which describes the residue of iterest
    //! @return ShPtr pointing to the residue of interest as described by "LOCATOR_AA"
    util::ShPtr< biol::AABase> LoopDomain::FindResidue( const assemble::LocatorAA &LOCATOR_AA) const
    {
      // get the chain and seq ids out of "LOCATOR_AA"
      const int resi_seq_id( LOCATOR_AA.GetAAID());
      const char resi_chain_id( LOCATOR_AA.GetLocatorChain().GetChainID());

      // get an iterator to the segment where "resi_chain_id" and "resi_seq_id" are within
      const storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator segment_itr
      (
        FindSegment( resi_chain_id, resi_seq_id)
      );

      // true if the segment where the residue indicated by "LOCATOR_AA" would be could not be found
      if( segment_itr == m_LoopSegments.End())
      {
        // return
        BCL_MessageCrt( "could not locate segment for " + LOCATOR_AA.GetIdentification());

        // return empty pointer to an aabase
        return util::ShPtr< biol::AABase>();
      }

      // get the sse in the loopsegment denoted by "segment_itr"
      const util::ShPtr< assemble::SSE> segment_sse( segment_itr->GetSSE());

      // get ShPtr to the residue described by "LOCATOR_AA"
      const util::ShPtr< biol::AABase> located_residue( FindResidue( *segment_sse, resi_chain_id, resi_seq_id));

      // return "located_residue"
      return located_residue;
    }

    //! @brief SetResidue finds the pointer to residue of interest in the LoopDomain and sets the pointer to given ptr
    //! @param RESIDUE the ptr to residue of interest which should be found
    void LoopDomain::SetPtrToResidue( const util::ShPtr< biol::AABase> &RESIDUE)
    {
      BCL_Assert( RESIDUE.IsDefined(), " RESIDUE not defined");

      // get the chain and seq ids out of "LOCATOR_AA"
      const int resi_seq_id( RESIDUE->GetSeqID());
      const char resi_chain_id( RESIDUE->GetChainID());

      // get an iterator to the segment where "resi_chain_id" and "resi_seq_id" are within
      storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator segment_itr
      (
        FindSegment( resi_chain_id, resi_seq_id)
      );

      // true if the segment where the residue could not be found
      if( segment_itr == m_LoopSegments.End())
      {
        // return
        BCL_MessageCrt( "could not locate segment for " + RESIDUE->GetIdentification());
        return;
      }

      LoopSegment new_loop_segment
      (
        util::ShPtr< assemble::SSE>( segment_itr->GetSSE()->Clone()), segment_itr->IsRigid()
      );

      // get the sse in the loopsegment denoted by "segment_itr"
      assemble::SSE &segment_sse( new_loop_segment.GetSSEReference());

      // iterate through the sequence of "segment_sse"
      for
      (
        biol::AASequence::iterator sse_itr( segment_sse.Begin()), sse_itr_end( segment_sse.End());
          sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // true if chain id and seq id of "RESIDUE" and the amino acid denoted by "sse_itr" are the same
        if( ( *sse_itr)->GetChainID() == resi_chain_id && ( *sse_itr)->GetSeqID() == resi_seq_id)
        {
          // set shptr to aa denoted by "sse_itr"
          ( *sse_itr) = RESIDUE;
        }
      }

      // remove the old segment and insert the new loop segment into m_LoopSegments
      m_LoopSegments.RemoveElement( segment_itr);
      BCL_Assert
      (
        m_LoopSegments.Insert( new_loop_segment).second, "failed to insert segment with sse " +
        new_loop_segment.GetSSE()->GetIdentification()
      );
    }

    //! @brief finds the pointer to residue of interest in the LoopDomain and gives iterator to it
    //! @param RESIDUE the ptr to residue of interest which should be found
    //! @return iterator to residue
    biol::AASequence::const_iterator LoopDomain::FindResidueIterator( const biol::AABase &RESIDUE) const
    {
      // get the chain and seq ids out of "LOCATOR_AA"
      const int resi_seq_id( RESIDUE.GetSeqID());
      const char resi_chain_id( RESIDUE.GetChainID());

      // get an iterator to the segment where "resi_chain_id" and "resi_seq_id" are within
      const storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator segment_itr
      (
        FindSegment( resi_chain_id, resi_seq_id)
      );

      BCL_Assert( segment_itr != m_LoopSegments.End(), "could not locate segment for " + RESIDUE.GetIdentification());

      // get the sse in the loopsegment denoted by "segment_itr"
      const assemble::SSE &segment_sse( *segment_itr->GetSSE());

      // iterate through the sequence of "segment_sse"
      for
      (
        biol::AASequence::const_iterator sse_itr( segment_sse.Begin()), sse_itr_end( segment_sse.End());
          sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // true if chain id and seq id of "RESIDUE" and the amino acid denoted by "sse_itr" are the same
        if( ( *sse_itr)->GetChainID() == resi_chain_id && ( *sse_itr)->GetSeqID() == resi_seq_id)
        {
          // return shptr to aa denoted by "sse_itr"
          return sse_itr;
        }
      }

      return segment_sse.End();
    }

    //! @brief FindSegment gives iterator to the segment containing an AA of interest described by chain and seq id
    //! @param RESI_CHAIN_ID the chain id of the residue of interest
    //! @param RESI_SEQ_ID the seq id of the residue of interest
    //! @return iterator to the LoopSegment that contains the residue described by "RESI_CHAIN_ID" and "RESI_SEQ_ID"
    storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator LoopDomain::FindSegment
    (
      const char RESI_CHAIN_ID, const int RESI_SEQ_ID
    ) const
    {
      // loop through the segments until the one containing "RESIDUE" is found
      for
      (
        storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator
          segment_itr( m_LoopSegments.Begin()), segment_itr_end( m_LoopSegments.End());
        segment_itr != segment_itr_end;
        ++segment_itr
      )
      {
        // get the start and ending seq ids and chain id of the sse denoted by "segment_itr"
        const int sse_start_seq_id( segment_itr->GetSSE()->GetFirstAA()->GetSeqID());
        const int sse_last_seq_id( segment_itr->GetSSE()->GetLastAA()->GetSeqID());
        const char sse_chain_id( segment_itr->GetSSE()->GetChainID());

        // true if chain ids match and "RESI_SEQ_ID" is between "sse_start_seq_id" and "sse_last_seq_id"
        if( sse_start_seq_id <= RESI_SEQ_ID && sse_last_seq_id >= RESI_SEQ_ID && RESI_CHAIN_ID == sse_chain_id)
        {
          // return the iterator
          return segment_itr;
        }
      }

      // message that the segment was not found
      BCL_MessageDbg
      (
        "did not find segment with residue with chain id " + util::Format()( RESI_CHAIN_ID) +
        " and seq id " + util::Format()( RESI_SEQ_ID)
      );

      // return iterator to the end of "m_LoopSegments"
      return m_LoopSegments.End();
    }

    //! @brief FindResidue finds a residue of interest in an SSE of the loop domain as described by a chain and seq id
    //! @param SEGMENT_SSE the sse which contains the residue of interest
    //! @param CHAIN_ID the chain id of the residue of interest
    //! @param SEQ_ID the seq id of the residue of interest
    //! @return ShPtr pointing to the residue of interest
    util::ShPtr< biol::AABase> LoopDomain::FindResidue
    (
      const assemble::SSE &SEGMENT_SSE, const char CHAIN_ID, const int SEQ_ID
    ) const
    {
      // iterate through the sequence of "segment_sse"
      for
      (
        biol::AASequence::const_iterator sse_itr( SEGMENT_SSE.Begin()), sse_itr_end( SEGMENT_SSE.End());
          sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // true if chain id and seq id of "RESIDUE" and the amino acid denoted by "sse_itr" are the same
        if( ( *sse_itr)->GetChainID() == CHAIN_ID && ( *sse_itr)->GetSeqID() == SEQ_ID)
        {
          // return shptr to aa denoted by "sse_itr"
          return *sse_itr;
        }
      }

      // message that the residue could not be found
      BCL_MessageDbg
      (
        "could not find residue with chain id " + util::Format()( CHAIN_ID) + " and seq id "
        + util::Format()( SEQ_ID) + " in sse " + SEGMENT_SSE.GetIdentification()
      );

      // return empty shptr
      return util::ShPtr< biol::AABase>();
    }

    //! @brief GetChainID provides the chain id of the LoopDomain. Since residues must be from the same chain, it
    //! can get the chain id from any residue.
    //! @return the chain id of the loop domain
    const char &LoopDomain::GetChainID() const
    {
      // return the chain id of any of the components of the loop domain since it is checked that they are all the
      // same
      return m_LoopSegments.Begin()->GetSSE()->GetChainID();
    }

    //! @brief returns the residues in the loop domain in sequence order including anchor sse anchor residue and the
    //!        created psuedo residue
    //! @return map with the amino acids and a bool indicating whether or not the aa is part of a rigid segment or not
    storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> > LoopDomain::GetResidues() const
    {
      // map with residues and bool indicating if the residue is rigid or not
      storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> > residues;

      // iterate through all the segments
      for
      (
        storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator
          segment_itr( GetSegments().Begin()), segment_itr_end( GetSegments().End());
        segment_itr != segment_itr_end;
        ++segment_itr
      )
      {
        // get reference to the sse denoted by "segment_itr"
        const assemble::SSE &sse( *segment_itr->GetSSE());

        const bool is_rigid( segment_itr->IsRigid());

        // iterate through the amino acids of the current segment
        for
        (
          util::ShPtrVector< biol::AABase>::const_iterator aa_itr( sse.Begin()), aa_itr_end( sse.End());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          // insert the residue and whether or not it is rigid
          residues.PushBack( storage::Pair< util::ShPtr< biol::AABase>, bool>( *aa_itr, is_rigid));
        } // iterate through sse aas
      } // iterate through segments

      return residues;
    }

    //! @brief gives the residue that is attached to the anchor sse
    //!        i.e. the residue that is closest to point of attachment
    //! @return ShPtr to residue that is attached to the anchor sse
    const util::ShPtr< biol::AABase> &LoopDomain::GetMostProximalLoopSegmentAA() const
    {
      return GetSegments().Begin()->GetSSE()->GetFirstAA();
    }

    //! @brief gives the loop segment that is most distant in sequence to attachment to the anchor sse
    //!        this is the sse that the pseudo residue attaches to
    //! @return sse that the pseudo residue attaches to and is the most distant in sequence from anchor sse
    const assemble::SSE &LoopDomain::GetMostDistalLoopSegment() const
    {
      return ( --GetSegments().End())->GetConstSSEReference();
    }

    //! @brief gives a ShPtr to the residue following the given residue in sequence
    //! @param AA the residue for which the following residue will be found
    //! @return ShPtr to residue that follows AA in sequence
    util::ShPtr< biol::AABase> LoopDomain::FindFollowingResidue( const biol::AABase &AA) const
    {
      const storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> > residues( GetResidues());

      // need at least one residue, so that Last() is valid
      if( residues.IsEmpty())
      {
        return util::ShPtr< biol::AABase>();
      }

      // iterate through the list of residues until AA is found
      // go to one before end since if the last residue is reached, there is no following residue
      for
      (
        storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> >::const_iterator
          resi_itr( residues.Begin()), resi_itr_end( residues.Last());
        resi_itr != resi_itr_end;
        ++resi_itr
      )
      {
        const biol::AABase &resi( *resi_itr->First());

        if( ResiduesMatch( AA, resi))
        {
          ++resi_itr;
          // increment the iterator to go to next residue and return the following residue
          return resi_itr->First();
        }
      }

      return util::ShPtr< biol::AABase>();
    }

    //! @brief gives a ShPtr to the residue preceding the given residue in sequence
    //! @param AA the residue for which the preceding residue will be found
    //! @return ShPtr to residue that precedes AA in sequence
    util::ShPtr< biol::AABase> LoopDomain::FindPreviousResidue( const biol::AABase &AA) const
    {
      storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> > residues( GetResidues());

      // need at least one residue, so that Last() is valid
      if( residues.IsEmpty())
      {
        return util::ShPtr< biol::AABase>();
      }

      // iterate through the list of residues until AA is found
      // start at one after begin since if there is no previous residue for the first residue
      for
      (
        storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> >::const_iterator
          resi_itr( ++residues.Begin()), resi_itr_end( residues.End());
        resi_itr != resi_itr_end;
        ++resi_itr
      )
      {
        const biol::AABase &resi( *resi_itr->First());

        if( ResiduesMatch( AA, resi))
        {
          // decrement the iterator to go to previous residue and return the previous residue
          return ( --resi_itr)->First();
        }
      }

      return util::ShPtr< biol::AABase>();
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief sets the psi of a residue in the loop domain
    //! @param AA the amino acid that will be found and mutated
    //! @param PSI the psi angle that residue will be set to
    void LoopDomain::SetPsi( const biol::AABase &AA, const double PSI)
    {
      // get the current psi angle
      double current_psi( AA.Psi());

      // phi within aa is not defined
      if( !util::IsDefined( current_psi))
      {
        // use the neighbor for the phi
        const util::ShPtr< biol::AABase> following_residue( FindFollowingResidue( AA));

        // neighbor is defined
        if( following_residue.IsDefined())
        {
          current_psi = AA.CalculatePsi( following_residue->GetAtom( biol::GetAtomTypes().N));
        }
        // no neighbor defined, psi is undefined, no loop domain change required
        else
        {
          return;
        }
      }

      const storage::VectorND< 2, double> phi_psi_change( 0.0, PSI - current_psi);

      BCL_MessageDbg
      (
        "changing psi by: " + util::Format()( phi_psi_change.Second()) + " from AA: " + AA.GetIdentification() +
        " in cterm direction"
      );

      storage::Set< LoopSegment, LoopSegmentSequenceOrder> new_segments;

      // iterate over loop segments
      storage::VectorND< 2, math::TransformationMatrix3D> transformations;

      storage::Set< LoopSegment, LoopSegmentSequenceOrder>::iterator itr( m_LoopSegments.Begin()), itr_end( m_LoopSegments.End());
      for( ; itr != itr_end; ++itr)
      {
        if( itr->IsRigid())
        {
          new_segments.Insert( *itr);
          continue;
        }

        if( itr->GetSSE()->FindAABySeqID( AA.GetSeqID()) == itr->GetSSE()->End())
        {
          new_segments.Insert( *itr);
          continue;
        }

        // amino acid is part of that non rigid loop segment
        util::ShPtr< assemble::SSE> new_sse( itr->GetSSE().HardCopy());
        transformations =
          biol::AASequenceFlexibility::ChangePhiPsi
          (
            *new_sse,
            AA.GetSeqID(),
            phi_psi_change,
            biol::AASequenceFlexibility::e_CTerminal
          );
        new_segments.Insert( LoopSegment( new_sse, itr->IsRigid()));
        ++itr;

        break;
      }

      for( ; itr != itr_end; ++itr)
      {
        util::ShPtr< assemble::SSE> new_sse( itr->GetSSE().HardCopy());
        new_sse->Transform( transformations.Second());
        new_segments.Insert( LoopSegment( new_sse, itr->IsRigid()));
      }

      m_LoopSegments = new_segments;
    }

    //! @brief sets the phi of a residue in the loop domain
    //! @param AA the amino acid that will be found and mutated
    //! @param PHI the phi angle that residue will be set to
    void LoopDomain::SetPhi( const biol::AABase &AA, const double PHI)
    {
      // get the current phi angle
      double current_phi( AA.Phi());

      // phi within aa is not defined
      if( !util::IsDefined( current_phi))
      {
        // use the neighbor for the phi
        const util::ShPtr< biol::AABase> previous_residue( FindPreviousResidue( AA));

        // neighbor is defined
        if( previous_residue.IsDefined())
        {
          current_phi = AA.CalculatePhi( previous_residue->GetAtom( biol::GetAtomTypes().C));
        }
        // no neighbor defined, phi is undefined, no loop domain change required
        else
        {
          return;
        }
      }

      const storage::VectorND< 2, double> phi_psi_change( PHI - current_phi, 0.0);

      BCL_MessageDbg
      (
        "changing phi by: " + util::Format()( phi_psi_change.First()) + " from AA: " + AA.GetIdentification() +
        " in cterm direction"
      );

      storage::Set< LoopSegment, LoopSegmentSequenceOrder> new_segments;

      // iterate over loop segments
      storage::VectorND< 2, math::TransformationMatrix3D> transformations;

      storage::Set< LoopSegment, LoopSegmentSequenceOrder>::iterator itr( m_LoopSegments.Begin()), itr_end( m_LoopSegments.End());
      for( ; itr != itr_end; ++itr)
      {
        if( itr->IsRigid())
        {
          new_segments.Insert( *itr);
          continue;
        }

        if( itr->GetSSE()->FindAABySeqID( AA.GetSeqID()) == itr->GetSSE()->End())
        {
          new_segments.Insert( *itr);
          continue;
        }

        // amino acid is part of that non rigid loop segment
        util::ShPtr< assemble::SSE> new_sse( itr->GetSSE().HardCopy());
        transformations =
          biol::AASequenceFlexibility::ChangePhiPsi
          (
            *new_sse,
            AA.GetSeqID(),
            phi_psi_change,
            biol::AASequenceFlexibility::e_CTerminal
          );
        new_segments.Insert( LoopSegment( new_sse, itr->IsRigid()));
        ++itr;

        break;
      }

      for( ; itr != itr_end; ++itr)
      {
        util::ShPtr< assemble::SSE> new_sse( itr->GetSSE().HardCopy());
        new_sse->Transform( transformations.Second());
        new_segments.Insert( LoopSegment( new_sse, itr->IsRigid()));
      }

      m_LoopSegments = new_segments;
    }

    //! @brief return the points that can be used for CCD
    //! @param PROTEIN_MODEL the model, to find the adjacent sse in to connect to
    //! @return target and moving points
    storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair> LoopDomain::TargetAndMovingPointsForCCD
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair> points;

      util::SiPtr< const assemble::SSE> sp_left_sse;
      util::SiPtr< const assemble::SSE> sp_right_sse;

      // get the sses - c is flexible side
      if( GetSequenceDirection() == biol::AASequenceFlexibility::e_CTerminal)
      {
        sp_left_sse = ( --m_LoopSegments.End())->GetSSE();
        storage::VectorND< 2, util::SiPtr< const assemble::SSE> > adjacent_sses( PROTEIN_MODEL.GetAdjacentSSEs( *sp_left_sse));
        if( !adjacent_sses.Second().IsDefined())
        {
          return points;
        }
        sp_right_sse = adjacent_sses.Second();
      }
      // n is the flexible side
      else if( GetSequenceDirection() == biol::AASequenceFlexibility::e_NTerminal)
      {
        sp_right_sse = m_LoopSegments.Begin()->GetSSE();
        storage::VectorND< 2, util::SiPtr< const assemble::SSE> > adjacent_sses( PROTEIN_MODEL.GetAdjacentSSEs( *sp_right_sse));
        if( !adjacent_sses.First().IsDefined())
        {
          return points;
        }
        sp_left_sse = adjacent_sses.First();
      }
      else
      {
        return points;
      }

      // amino acids
      const biol::AABase &left_aa( *sp_left_sse->GetLastAA());
      const biol::AABase &right_aa( *sp_right_sse->GetFirstAA());

      // pseudo atoms to superimpose
      const storage::Map< biol::AtomType, biol::Atom> pseudo_atoms( biol::AABackBoneCompleter::GenerateHNCA( left_aa));
      const storage::Map< biol::AtomType, biol::Atom>::const_iterator itr_end( pseudo_atoms.End());

      // hydrogen
      {
        const storage::Map< biol::AtomType, biol::Atom>::const_iterator itr( pseudo_atoms.Find( biol::GetAtomTypes().H));
        const linal::Vector3D &actual_hydrogen_coord( right_aa.GetAtom( biol::GetAtomTypes().H).GetCoordinates());

        if( itr != itr_end && itr->second.GetCoordinates().IsDefined() && actual_hydrogen_coord.IsDefined())
        {
          if( GetSequenceDirection() == biol::AASequenceFlexibility::e_CTerminal)
          {
            points.PushBack
            (
              coord::CyclicCoordinateDescent::TargetAndMovingPointPair
              (
                actual_hydrogen_coord,
                itr->second.GetCoordinates()
              )
            );
          }
          else if( GetSequenceDirection() == biol::AASequenceFlexibility::e_NTerminal)
          {
            points.PushBack
            (
              coord::CyclicCoordinateDescent::TargetAndMovingPointPair
              (
                itr->second.GetCoordinates(),
                actual_hydrogen_coord
              )
            );
          }
        }
      }

      // nitrogen
      {
        const storage::Map< biol::AtomType, biol::Atom>::const_iterator itr( pseudo_atoms.Find( biol::GetAtomTypes().N));
        const linal::Vector3D &actual_nitrogen_coord( right_aa.GetAtom( biol::GetAtomTypes().N).GetCoordinates());

        if( itr != itr_end && itr->second.GetCoordinates().IsDefined() && actual_nitrogen_coord.IsDefined())
        {
          if( GetSequenceDirection() == biol::AASequenceFlexibility::e_CTerminal)
          {
            points.PushBack
            (
              coord::CyclicCoordinateDescent::TargetAndMovingPointPair
              (
                actual_nitrogen_coord,
                itr->second.GetCoordinates()
              )
            );
          }
          else if( GetSequenceDirection() == biol::AASequenceFlexibility::e_NTerminal)
          {
            points.PushBack
            (
              coord::CyclicCoordinateDescent::TargetAndMovingPointPair
              (
                itr->second.GetCoordinates(),
                actual_nitrogen_coord
              )
            );
          }
        }
      }

      // carbon alpha
      {
        const storage::Map< biol::AtomType, biol::Atom>::const_iterator itr( pseudo_atoms.Find( biol::GetAtomTypes().CA));
        const linal::Vector3D &actual_calpha_coord( right_aa.GetAtom( biol::GetAtomTypes().CA).GetCoordinates());

        if( itr != itr_end && itr->second.GetCoordinates().IsDefined() && actual_calpha_coord.IsDefined())
        {
          if( GetSequenceDirection() == biol::AASequenceFlexibility::e_CTerminal)
          {
            points.PushBack
            (
              coord::CyclicCoordinateDescent::TargetAndMovingPointPair
              (
                actual_calpha_coord,
                itr->second.GetCoordinates()
              )
            );
          }
          else if( GetSequenceDirection() == biol::AASequenceFlexibility::e_NTerminal)
          {
            points.PushBack
            (
              coord::CyclicCoordinateDescent::TargetAndMovingPointPair
              (
                itr->second.GetCoordinates(),
                actual_calpha_coord
              )
            );
          }
        }
      }

      // end
      return points;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LoopDomain::Read( std::istream &ISTREAM)
    {
      io::Serialize::Read( m_LoopSegments, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LoopDomain::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      io::Serialize::Write( m_LoopSegments, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief places the sses from a loop domain into a protein model
    //! @param PROTEIN_MODEL the protein model whose sses will be replaced
    //! @return ShPtr to ProteinModel which has had its sses replaced with the sses of LOOP_DOMAIN
    util::ShPtr< assemble::ProteinModel> LoopDomain::UpdateProteinModel
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // create a ShPtr copy to "PROTEIN_MODEL"
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // iterate over the loop segments of "LOOP_DOMAIN" in order to replace them in "PROTEIN_MODEL"
      for
      (
        storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator
          segment_itr( GetSegments().Begin()), segment_itr_end( GetSegments().End());
        segment_itr != segment_itr_end;
        ++segment_itr
      )
      {
        // create const reference to the sse in the loop segment currently denoted by "segment_itr"
        const util::ShPtr< assemble::SSE> &current_sse( segment_itr->GetSSE());

        // replace "current_sse" in "temp_model" and make sure the replace was successful
        BCL_Assert( new_model->Replace( current_sse), "failed to replace " + current_sse->GetIdentification());
      }

      // return "temp_model" which has had its sses replaced by the sses of "LOOP_DOMAIN"
      return new_model;
    }

    //! @brief determines if the seq id and chain id of two residues are the same
    //! @param RESI_A first residue
    //! @param RESI_B second residue
    //! @return boolean true if the seqid and chain ids match - false otherwise
    bool LoopDomain::ResiduesMatch( const biol::AABase &RESI_A, const biol::AABase &RESI_B)
    {
      return RESI_A.GetChainID() == RESI_B.GetChainID() && RESI_A.GetSeqID() == RESI_B.GetSeqID();
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_loop_domain_c_to_n.h"

// includes from bcl - sorted alphabetically
#include "storage/bcl_storage_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LoopDomainCToN::s_Instance
    (
      GetObjectInstances().AddInstance( new LoopDomainCToN())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LoopDomainCToN::LoopDomainCToN() :
      LoopDomain()
    {
    }

    //! @brief constructor taking parameters to create member variables
    //! @param SEGMENTS list of LoopSegments which will be used to create "m_LoopSegments"
    LoopDomainCToN::LoopDomainCToN
    (
      const storage::List< LoopSegment> &SEGMENTS
    ) :
      LoopDomain( SEGMENTS)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LoopDomainCToN
    LoopDomainCToN *LoopDomainCToN::Clone() const
    {
      return new LoopDomainCToN( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LoopDomainCToN::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gives the directionality of the loop domain
    //! @return sequence direction in this case e_NTerminal since changes are propagated nterminally
    biol::AASequenceFlexibility::SequenceDirection LoopDomainCToN::GetSequenceDirection() const
    {
      return biol::AASequenceFlexibility::e_NTerminal;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief returns the residues in the loop domain in sequence order including anchor sse anchor residue and the
    //!        created psuedo residue
    //! @return map with the amino acids and a bool indicating whether or not the aa is part of a rigid segment or not
    storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> > LoopDomainCToN::GetResidues() const
    {
      // map with residues and bool indicating if the residue is rigid or not
      storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> > residues;

      // iterate through all the segments
      for
      (
        storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator
          segment_itr( GetSegments().Begin()), segment_itr_end( GetSegments().End());
        segment_itr != segment_itr_end;
        ++segment_itr
      )
      {
        // get reference to the sse denoted by "segment_itr"
        const assemble::SSE &sse( *segment_itr->GetSSE());

        const bool is_rigid( segment_itr->IsRigid());

        // iterate through the amino acids of the current segment
        for
        (
          util::ShPtrVector< biol::AABase>::const_iterator aa_itr( sse.Begin()), aa_itr_end( sse.End());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          // insert the residue and whether or not it is rigid
          residues.PushBack( storage::Pair< util::ShPtr< biol::AABase>, bool>( *aa_itr, is_rigid));
        } // iterate through sse aas
      } // iterate through segments

      return residues;
    }

    //! @brief gives the residue that is attached to the anchor sse
    //!        i.e. the residue that is closest to point of attachment
    //! @return ShPtr to residue that is attached to the anchor sse
    const util::ShPtr< biol::AABase> &LoopDomainCToN::GetMostProximalLoopSegmentAA() const
    {
      return ( --GetSegments().End())->GetSSE()->GetLastAA();
    }

    //! @brief gives the loop segment that is most distant in sequence to attachment to the anchor sse
    //!        this is the sse that the pseudo residue attaches to
    //! @return sse that the pseudo residue attaches to and is the most distant in sequence from anchor sse
    const assemble::SSE &LoopDomainCToN::GetMostDistalLoopSegment() const
    {
      return GetSegments().Begin()->GetConstSSEReference();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief sets the phi of a residue in the loop domain
    //! @param AA the amino acid that will be found and mutated
    //! @param PHI the phi angle that residue will be set to
    void LoopDomainCToN::SetPhi( const biol::AABase &AA, const double PHI)
    {
      // get the current phi angle
      double current_phi( AA.Phi());

      // phi within aa is not defined
      if( !util::IsDefined( current_phi))
      {
        // use the neighbor for the phi
        const util::ShPtr< biol::AABase> previous_residue( FindPreviousResidue( AA));

        // neighbor is defined
        if( previous_residue.IsDefined())
        {
          current_phi = AA.CalculatePhi( previous_residue->GetAtom( biol::GetAtomTypes().C));
        }
        // no neighbor defined, phi is undefined, no loop domain change required
        else
        {
          return;
        }
      }

      const storage::VectorND< 2, double> phi_psi_change( PHI - current_phi, 0.0);
      BCL_MessageDbg
      (
        "changing phi by: " + util::Format()( phi_psi_change.First()) + " from AA: " + AA.GetIdentification() +
        " in nterm direction"
      );

      storage::Set< LoopSegment, LoopSegmentSequenceOrder> new_segments;

      // iterate over loop segments
      storage::VectorND< 2, math::TransformationMatrix3D> transformations;

      storage::Set< LoopSegment, LoopSegmentSequenceOrder>::reverse_iterator itr( m_LoopSegments.ReverseBegin()), itr_end( m_LoopSegments.ReverseEnd());
      for( ; itr != itr_end; ++itr)
      {
        if( itr->IsRigid())
        {
          new_segments.Insert( *itr);
          continue;
        }

        if( itr->GetSSE()->FindAABySeqID( AA.GetSeqID()) == itr->GetSSE()->End())
        {
          new_segments.Insert( *itr);
          continue;
        }

        // amino acid is part of that non rigid loop segment
        util::ShPtr< assemble::SSE> new_sse( itr->GetSSE().HardCopy());
        transformations =
          biol::AASequenceFlexibility::ChangePhiPsi
          (
            *new_sse,
            AA.GetSeqID(),
            phi_psi_change,
            biol::AASequenceFlexibility::e_NTerminal
          );
        new_segments.Insert( LoopSegment( new_sse, itr->IsRigid()));
        ++itr;

        break;
      }

      for( ; itr != itr_end; ++itr)
      {
        util::ShPtr< assemble::SSE> new_sse( itr->GetSSE().HardCopy());
        new_sse->Transform( transformations.First());
        new_segments.Insert( LoopSegment( new_sse, itr->IsRigid()));
      }

      m_LoopSegments = new_segments;
    }

    //! @brief sets the psi of a residue in the loop domain
    //! @param AA the amino acid that will be found and mutated
    //! @param PSI the psi angle that residue will be set to
    void LoopDomainCToN::SetPsi( const biol::AABase &AA, const double PSI)
    {
      // get the current psi angle
      double current_psi( AA.Psi());

      // phi within aa is not defined
      if( !util::IsDefined( current_psi))
      {
        // use the neighbor for the phi
        const util::ShPtr< biol::AABase> following_residue( FindFollowingResidue( AA));

        // neighbor is defined
        if( following_residue.IsDefined())
        {
          current_psi = AA.CalculatePsi( following_residue->GetAtom( biol::GetAtomTypes().N));
        }
        // no neighbor defined, psi is undefined, no loop domain change required
        else
        {
          return;
        }
      }

      const storage::VectorND< 2, double> phi_psi_change( 0.0, PSI - current_psi);

      BCL_MessageDbg
      (
        "changing psi by: " + util::Format()( phi_psi_change.Second()) + " from AA: " + AA.GetIdentification() +
        " in nterm direction"
      );

      storage::Set< LoopSegment, LoopSegmentSequenceOrder> new_segments;

      // iterate over loop segments
      storage::VectorND< 2, math::TransformationMatrix3D> transformations;

      storage::Set< LoopSegment, LoopSegmentSequenceOrder>::reverse_iterator itr( m_LoopSegments.ReverseBegin()), itr_end( m_LoopSegments.ReverseEnd());
      for( ; itr != itr_end; ++itr)
      {
        if( itr->IsRigid())
        {
          new_segments.Insert( *itr);
          continue;
        }

        if( itr->GetSSE()->FindAABySeqID( AA.GetSeqID()) == itr->GetSSE()->End())
        {
          new_segments.Insert( *itr);
          continue;
        }

        // amino acid is part of that non rigid loop segment
        util::ShPtr< assemble::SSE> new_sse( itr->GetSSE().HardCopy());
        transformations =
          biol::AASequenceFlexibility::ChangePhiPsi
          (
            *new_sse,
            AA.GetSeqID(),
            phi_psi_change,
            biol::AASequenceFlexibility::e_NTerminal
          );
        new_segments.Insert( LoopSegment( new_sse, itr->IsRigid()));
        ++itr;
        break;
      }

      for( ; itr != itr_end; ++itr)
      {
        util::ShPtr< assemble::SSE> new_sse( itr->GetSSE().HardCopy());
        new_sse->Transform( transformations.First());
        new_segments.Insert( LoopSegment( new_sse, itr->IsRigid()));
      }

      m_LoopSegments = new_segments;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LoopDomainCToN::Read( std::istream &ISTREAM)
    {
      // read members
      LoopDomain::Read( ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LoopDomainCToN::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      LoopDomain::Write( OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_loop_library.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_atom.h"
#include "command/bcl_command_command_state.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "linal/bcl_linal_matrix_inversion_gauss_jordan.h"
#include "pdb/bcl_pdb_factory.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> LoopLibrary::s_Instance
    (
      util::Enumerated< LoopLibrary>::AddInstance( new LoopLibrary())
    );

    //! map of loop libraries
    storage::HashMap< std::string, util::ShPtr< LoopLibrary> > LoopLibrary::s_LoopLibraries =
      storage::HashMap< std::string, util::ShPtr< LoopLibrary> >();

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LoopLibrary::LoopLibrary() :
      m_DistanceBinWidth(),
      m_AngleBinWidth(),
      m_LoopTemplates(),
      m_LibraryFileName()
    {
    }

    //! @brief construct from loop template library
    //! @param LIBRARY_FILE_NAME path to the loop template library
    //! @param DISTANCE_BIN_WIDTH width of the bins to discretize the euclidean distance
    //! @param ANGLE_BIN_WIDTH width of the bins to discretize the Euler angles
    LoopLibrary::LoopLibrary
    (
      const std::string &LIBRARY_FILE_NAME,
      double DISTANCE_BIN_WIDTH,
      double ANGLE_BIN_WIDTH
    ) :
      m_DistanceBinWidth( DISTANCE_BIN_WIDTH),
      m_AngleBinWidth( ANGLE_BIN_WIDTH),
      m_LoopTemplates(),
      m_LibraryFileName( LIBRARY_FILE_NAME)
    {
      std::ostringstream oss;
      ReadInitializerSuccessHook( util::ObjectDataLabel(), oss);
    }

    //! @brief returns a loop library from the given file
    //! @param LIBRARY_FILE_NAME path to the loop template library
    //! @param DISTANCE_BIN_WIDTH width of the bins to discretize the euclidean distance
    //! @param ANGLE_BIN_WIDTH width of the bins to discretize the Euler angles
    util::ShPtr< LoopLibrary> LoopLibrary::CreateLoopLibrary
    (
      const std::string &LIBRARY_FILE_NAME,
      double DISTANCE_BIN_WIDTH,
      double ANGLE_BIN_WIDTH
    )
    {
      if( command::CommandState::GetGlobalCommandState().IsInStaticInitialization())
      {
        return util::ShPtr< LoopLibrary>();
      }
      // compute hash key for the given parameters
      std::ostringstream oss;
      oss << LIBRARY_FILE_NAME << "\t" << DISTANCE_BIN_WIDTH << "\t" << ANGLE_BIN_WIDTH;
      const std::string key( oss.str());

      // if a library with this key does not exist, create one
      if( s_LoopLibraries.Find( key) == s_LoopLibraries.End())
      {
        util::ShPtr< LoopLibrary> sp_library( new LoopLibrary( LIBRARY_FILE_NAME, DISTANCE_BIN_WIDTH, ANGLE_BIN_WIDTH));
        s_LoopLibraries[ key] = sp_library;
        return sp_library;
      }
      return s_LoopLibraries[ key];
    }

    //! @brief clone function
    //! @return pointer to a new LoopLibrary
    LoopLibrary *LoopLibrary::Clone() const
    {
      return new LoopLibrary( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &LoopLibrary::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the default distance bin width
    //! @return default distance bin width
    double LoopLibrary::GetDefaultDistanceBinWidth()
    {
      static double s_DefaultDistanceBinWidth( 2.0);
      return s_DefaultDistanceBinWidth;
    }

    //! @brief returns the default angle bin width
    //! @return default angle bin width
    double LoopLibrary::GetDefaultAngleBinWidth()
    {
      static double s_DefaultAngleBinWidth( 3.14159265359 / 180.0 * 35.0);
      return s_DefaultAngleBinWidth;
    }

    //! @brief returns the loop templates in the library
    //! @return the loop templates in the library
    const storage::HashMap< std::string, util::ShPtrVector< LoopParameters> > &LoopLibrary::GetTemplates() const
    {
      return m_LoopTemplates;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &LoopLibrary::GetAlias() const
    {
      static const std::string s_name( "LoopLibrary");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LoopLibrary::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Stores loop conformations to close gaps.");
      serializer.AddInitializer
      (
        "distance bin width",
        "bin width for the coordinates of the translation vector",
        io::Serialization::GetAgent( &m_DistanceBinWidth),
        "2.0"
      );
      serializer.AddInitializer
      (
        "rotation bin width",
        "bin width for the rotation angles",
        io::Serialization::GetAgent( &m_AngleBinWidth),
        "0.61"
      );
      serializer.AddInitializer
      (
        "loop library",
        "path to the file containing the loop template library",
        io::Serialization::GetAgent( &m_LibraryFileName)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief read a loop template library from the given input stream
    //! @param ISTREAM input stream from which to read the loop template library
    void LoopLibrary::ReadLibrary( std::istream &ISTREAM)
    {
      BCL_MessageStd( "Reading loop template library.");

      // read in the number of templates in the library
      size_t num_templates( 0);
      ISTREAM >> num_templates;

      // read in each template and insert it into the hash map
      for( size_t i( 0); i < num_templates; ++i)
      {
        LoopParameters loop;
        ISTREAM >> loop;
        AddTemplate( loop);
      }
    }

    //! @brief extends the template library by recombining template to form larger templates
    //! @param map in the format <sequence length>:<number of new templates> to specify how many additional
    //! templates should be generated
    void LoopLibrary::RecombineTemplates( const storage::HashMap< size_t, size_t> &COUNTS)
    {
      // iterate over the given map and create the templates for each given length
      for( auto map_it( COUNTS.Begin()), map_it_end( COUNTS.End()); map_it != map_it_end; ++map_it)
      {
        // create the templates from the already existing template library
        const size_t &length( map_it->first);
        const size_t &count( map_it->second);
        util::ShPtrVector< LoopParameters> templates( GenerateTemplates( length, count));

        // add the newly created templates to the template library
        for( auto temp_it( templates.Begin()), temp_it_end( templates.End()); temp_it != temp_it_end; ++temp_it)
        {
          AddTemplate( **temp_it);
        }
      }
    }

    //! @brief returns suitable templates for the given loop parameters
    //! @param LOOP_PARAMS loop parameters for which to find templates
    //! @return loop templates for the given parameters
    util::ShPtrVector< LoopParameters> LoopLibrary::FindTemplates( const LoopParameters &LOOP_PARAMS) const
    {
      // find suitable templates or return an empty vector
      storage::HashMap< std::string, util::ShPtrVector< LoopParameters> >::const_iterator result_it
      (
        m_LoopTemplates.Find( ComputeKey( LOOP_PARAMS))
      );
      return result_it != m_LoopTemplates.End() ? result_it->second : util::ShPtrVector< LoopParameters>();
    }

    //! @brief returns suitable templates for the given loop length
    //! @param LENGTH sequence length of the loop
    //! @return loop templates for the given sequence length
    util::ShPtrVector< LoopParameters> LoopLibrary::FindTemplates( size_t LENGTH) const
    {
      // find suitable templates or return an empty vector
      storage::HashMap< size_t, util::ShPtrVector< LoopParameters> >::const_iterator result_it
      (
        m_LoopTemplatesLength.Find( LENGTH)
      );
      return result_it != m_LoopTemplatesLength.End() ? result_it->second : util::ShPtrVector< LoopParameters>();
    }

    //! @brief combines the two given templates to one larger template
    //! @param TEMPLATE_N the n-terminal template to be combined
    //! @param TEMPLATE_C the c-terminal template to be combined
    //! @return the template resulting from combination of the two given templates
    util::ShPtr< LoopParameters> LoopLibrary::Combine
    (
      const LoopParameters &TEMPLATE_N, const LoopParameters &TEMPLATE_C
    )
    {
      // compute the resulting sequence distance spanned by the combined template
      const size_t seq_dist( TEMPLATE_N.GetSequenceDistance() + TEMPLATE_C.GetSequenceDistance() + 1);

      // combine the dihedral angles of the smaller templates
      const storage::Vector< double> &angles_n( TEMPLATE_N.GetAngles());
      const storage::Vector< double> &angles_c( TEMPLATE_C.GetAngles());
      storage::Vector< double> angles( angles_n);
      angles.Append( angles_c);

      // construct the sequence
      biol::AASequence new_template( biol::GetAAClasses().e_AABackBone, seq_dist + 2, 'A');
      assemble::SSE new_loop( new_template, biol::GetSSTypes().STRAND);
      new_loop.SetToIdealConformationInPlace();
      biol::AASequenceFlexibility::SetPhiPsi
      (
        new_loop,
        1,
        storage::VectorND< 2, double>( 0.0, angles( 0)),
        biol::AASequenceFlexibility::SequenceDirection::e_CTerminal
      );
      int seq_id( 2);
      for( auto it( angles.Begin() + 1), it_end( angles.End() - 1); it != it_end; it += 2, ++seq_id)
      {
        storage::VectorND< 2, double> phi_psi( *it, *( it + 1));
        biol::AASequenceFlexibility::SetPhiPsi
        (
          new_loop,
          seq_id,
          phi_psi,
          biol::AASequenceFlexibility::SequenceDirection::e_CTerminal
        );
      }
      biol::AASequenceFlexibility::SetPhiPsi
      (
        new_loop,
        seq_dist + 2,
        storage::VectorND< 2, double>( angles( angles.GetSize() - 1), 0.0),
        biol::AASequenceFlexibility::SequenceDirection::e_CTerminal
      );

      const biol::AABase &res_next( *new_loop.GetMembers()( 1));
      const biol::Atom c_next( res_next.GetAtom( biol::GetAtomTypes().N));
      for( size_t i( 1); i <= seq_dist; ++i)
        {
          const biol::AABase &res_prev( *new_loop.GetMembers()( i-1));
          const biol::AABase &res_next( *new_loop.GetMembers()( i+1));
          const biol::Atom c_prev( res_prev.GetAtom( biol::GetAtomTypes().C));
          const biol::Atom n_prev( res_next.GetAtom( biol::GetAtomTypes().N));
        }
      const biol::AABase &res_before( *new_loop.GetMembers()( 5));
      const biol::Atom n_before( res_before.GetAtom( biol::GetAtomTypes().C));

      // construct the template from the fitted sequence
      const util::ShPtr< LoopParameters> sp_new_loop
      (
        LoopParameters::Create( *new_loop.GetFirstAA(), *new_loop.GetLastAA(), angles)
      );

      return sp_new_loop;
    }

    //! @brief creates a given number of loop templates of the given length
    //! @param LENGTH sequence length of the generated loop templates
    //! @param COUNT how many loop templates to generate
    //! @return generated loop templates
    util::ShPtrVector< LoopParameters> LoopLibrary::GenerateTemplates( size_t LENGTH, size_t COUNT) const
    {
      BCL_MessageStd( "Generating additional loop templates.");

      // the algorithm only works for template lengths >= 3
      BCL_Assert( LENGTH >= 3, "template length must be 3 or greater");

      // the templates get combined at the anchor point leading to a longer effective length
      const size_t length( LENGTH - 1);

      // generate the given number of templates of the given sequence length
      util::ShPtrVector< LoopParameters> new_templates;
      for( size_t i( 0); i < COUNT; ++i)
      {
        // try different template lengths until a fitting combination is found
        bool fit( false);
        size_t iterations( 0);
        while( !fit && iterations < 50)
        {
          // set the lengths of the templates that are to be combined
          const size_t length_1( random::GetGlobalRandom().SizeT( math::Range< size_t>( 1, length - 1)));
          const size_t length_2( length - length_1);

          // get templates of the given lengths
          storage::HashMap< size_t, util::ShPtrVector< LoopParameters> >::const_iterator result_it_1
          (
            m_LoopTemplatesLength.Find( length_1)
          );
          storage::HashMap< size_t, util::ShPtrVector< LoopParameters> >::const_iterator result_it_2
          (
            m_LoopTemplatesLength.Find( length_2)
          );
          if( result_it_1 == m_LoopTemplatesLength.End() || result_it_2 == m_LoopTemplatesLength.End())
          {
            ++iterations;
            continue;
          }
          fit = true;
          const util::ShPtrVector< LoopParameters> templates_1( result_it_1->second);
          const util::ShPtrVector< LoopParameters> templates_2( result_it_2->second);

          // randomly select a template from the found ones
          const LoopParameters template_1
          (
            **random::GetGlobalRandom().Iterator( templates_1.Begin(), templates_1.End(), templates_1.GetSize())
          );
          const LoopParameters template_2
          (
            **random::GetGlobalRandom().Iterator( templates_2.Begin(), templates_2.End(), templates_2.GetSize())
          );

          // combine the two templates and add the new templates to the result
          const util::ShPtr< LoopParameters> sp_new_template( Combine( template_1, template_2));
          new_templates.PushBack( sp_new_template);
        }
      }

      return new_templates;
    }

    //! @brief estimates how many templates of different lengths are needed to close the loops for the given
    //! protein models
    //! @param MODELS models for which the loop regions shall be constructed
    //! @return estimation of the number of additional templates required
    util::ShPtr< storage::HashMap< size_t, size_t> > LoopLibrary::EstimateTemplateRequirement
    (
      const util::ShPtrVector< assemble::ProteinModel> &MODELS
    )
    {
      BCL_MessageStd( "Estimating how many additional loop templates are needed.");

      // count the loops and their respective lengths in the given set of protein models
      util::ShPtr< storage::HashMap< size_t, size_t> > sp_estimate( new storage::HashMap< size_t, size_t>());
      for( auto model_it( MODELS.Begin()), model_it_end( MODELS.End()); model_it != model_it_end; ++model_it)
      {
        // get the loops in the current model
        const util::SiPtrVector< const assemble::SSE> loops( ( **model_it).GetSSEs( biol::GetSSTypes().COIL));

        // determine loop lengths and frequency and record them in the hash map
        for( auto loop_it( loops.Begin()), loop_it_end( loops.End()); loop_it != loop_it_end; ++loop_it)
        {
          const size_t length( ( **loop_it).GetSize());
          if( sp_estimate->Count( length) == 0)
          {
            sp_estimate->Insert( storage::Pair< size_t, size_t>( length, 1));
          }
          else
          {
            ++( *sp_estimate)[ length];
          }
        }
      }

      // for frequently occurring loops and longer loop lengths, estimate that more templates are needed
      for( auto est_it( sp_estimate->Begin()), est_it_end( sp_estimate->End()); est_it != est_it_end; ++est_it)
      {
        est_it->second = est_it->second * 10000;
      }

      return sp_estimate;
    }

    //! @brief Set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @param ERROR_STREAM stream with which to write errors
    //! @return return code indicating success or failure
    bool LoopLibrary::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
    {
      if( !command::CommandState::GetGlobalCommandState().IsInStaticInitialization())
      {
        // read the loop template library file
        io::IFStream lib_file;
        io::File::MustOpenIFStream( lib_file, m_LibraryFileName);
        ReadLibrary( lib_file);
        io::File::CloseClearFStream( lib_file);
      }

      return true;
    }

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief computes the hash key for the given loop parameters
    //! @param LOOP_PARAMS loop parameters for which to compute the hash key
    //! @return hash key for the given loop parameters
    std::string LoopLibrary::ComputeKey( const LoopParameters &LOOP_PARAMS) const
    {
      // get the geometrical parameters for the computation of the hash key
      const size_t seq_dist( LOOP_PARAMS.GetSequenceDistance());
      const linal::Vector3D &translation( LOOP_PARAMS.GetTranslation());
      const linal::Vector3D &euler_angles( LOOP_PARAMS.GetRotation());

      // convert the angle bin width into radians
      const double angle_bin_width( m_AngleBinWidth / 180.0 * math::g_Pi);

      // bin the geometrical parameters
      const size_t t_x( translation( 0) / m_DistanceBinWidth);
      const size_t t_y( translation( 1) / m_DistanceBinWidth);
      const size_t t_z( translation( 2) / m_DistanceBinWidth);
      const size_t r_x( euler_angles( 0) / angle_bin_width);
      const size_t r_y( euler_angles( 1) / angle_bin_width);
      const size_t r_z( euler_angles( 2) / angle_bin_width);

      // compute the hash key from the geometrical parameters
      const std::string key
      (
        ToString( seq_dist) + ToString( t_x) + ToString( t_y) + ToString( t_z) +
        ToString( r_x) + ToString( r_y) + ToString( r_z)
      );

      return key;
    }

    //! @brief adds the given loop template to the template library
    //! @param LOOP_PARAMS loop which shall be added to the library
    void LoopLibrary::AddTemplate( const LoopParameters &LOOP_PARAMS)
    {
      // compute the hash key of the loop and add the template to the library
      const std::string key( ComputeKey( LOOP_PARAMS));
      const util::ShPtr< LoopParameters> sp_loop( util::CloneToShPtr( LOOP_PARAMS));
      m_LoopTemplates[ key].PushBack( sp_loop);

      // add the loop templates by sequence length
      const size_t length( sp_loop->GetSequenceDistance());
      m_LoopTemplatesLength[ length].PushBack( sp_loop);
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_loop_parameters.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_atom.h"
#include "io/bcl_io_serialization.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> LoopParameters::s_Instance
    (
      GetObjectInstances().AddInstance( new LoopParameters())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LoopParameters::LoopParameters() :
      m_Translation(),
      m_RotationAngles(),
      m_Anchors(),
      m_ChainID(),
      m_DihedralAngles()
    {
    }

    //! @brief construct from members
    //! @param TRANSLATION translational span of the loop
    //! @param ROTATION rotation angles of the second anchor with respect to the first anchor
    //! @param ANCHORS sequence ids of the anchor points of the loop
    //! @param CHAIN_ID chain id of the loop
    //! @param ANGLES dihedral angles of the loop
    LoopParameters::LoopParameters
    (
      const linal::Vector3D &TRANSLATION,
      const linal::Vector3D &ROTATION,
      const storage::Vector< int> &ANCHORS,
      const char &CHAIN_ID,
      const storage::Vector< double> &ANGLES
    ) :
      m_Translation( TRANSLATION),
      m_RotationAngles( ROTATION),
      m_Anchors( ANCHORS),
      m_ChainID( CHAIN_ID),
      m_DihedralAngles( ANGLES)
    {
      // make sure that the correct number of dihedral angles was provided for this length of the loop
      BCL_Assert
      (
        m_DihedralAngles.IsEmpty() || m_DihedralAngles.GetSize() == 2 * GetSequenceDistance() + 2,
        "Number of dihedral angles should either be 0 or two times the sequence distance plus two angles."
      );
    }

    //! @brief clone function
    //! @return pointer to a new LoopParameters
    LoopParameters *LoopParameters::Clone() const
    {
      return new LoopParameters( *this);
    }

    //! @brief creates a parameterization of a loop from the given anchor points and dihedral angles
    //! @param FIRST_ANCHOR first anchor point of the loop
    //! @param SECOND_ANCHOR second anchor point of the loop
    //! @param ANGLES dihedral angles of the loop
    //! @return parameterization of the loop defined by the given arguments
    util::ShPtr< LoopParameters> LoopParameters::Create
    (
      const biol::AABase &FIRST_ANCHOR,
      const biol::AABase &SECOND_ANCHOR,
      const storage::Vector< double> &ANGLES
    )
    {
      // compute the local coordinate system of the first anchor
      const storage::VectorND< 3, linal::Vector3D> coord_system( GetLocalCoordinateSystem( FIRST_ANCHOR));

      // compute the translation
      const linal::Vector3D translation_global
      (
        SECOND_ANCHOR.GetCA().GetCoordinates() - FIRST_ANCHOR.GetCA().GetCoordinates()
      );
      const linal::Vector3D translation_local
      (
        translation_global * coord_system.First(),  // local x-coordinate
        translation_global * coord_system.Second(), // local y-coordinate
        translation_global * coord_system.Third()   // local z-coordinate
      );

      // compute the rotation angles for the local coordinate system
      const storage::VectorND< 3, linal::Vector3D> coord_system_2( GetLocalCoordinateSystem( SECOND_ANCHOR));
      const linal::Vector3D rotation_angles( GetEulerAngles( coord_system, coord_system_2));

      // get the sequence ids of the anchors
      storage::Vector< int> anchor_ids;
      anchor_ids.PushBack( FIRST_ANCHOR.GetSeqID());
      anchor_ids.PushBack( SECOND_ANCHOR.GetSeqID());

      // get the chain id of the anchors
      const char &chain_id( FIRST_ANCHOR.GetChainID());

      // create the parameterization wrapper
      util::ShPtr< LoopParameters> sp_param
      (
        new LoopParameters( translation_local, rotation_angles, anchor_ids, chain_id, ANGLES)
      );

      return sp_param;
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &LoopParameters::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the translational span of the loop
    //! @return translational span of the loop
    const linal::Vector3D &LoopParameters::GetTranslation() const
    {
      return m_Translation;
    }

    //! @brief returns the rotation angles of the second anchor with respect to the first anchor
    //! @return rotation angles of the second anchor with respect to the first anchor
    const linal::Vector3D &LoopParameters::GetRotation() const
    {
      return m_RotationAngles;
    }

    //! @brief returns the sequence ids of the anchor points of the loop
    //! @return sequence ids of the anchor points of the loop
    const storage::Vector< int> &LoopParameters::GetAnchors() const
    {
      return m_Anchors;
    }

    //! @brief returns the chain of the anchor points of the loop
    //! @return chain id of the anchor points of the loop
    const char &LoopParameters::GetChainID() const
    {
      return m_ChainID;
    }

    //! @brief returns the sequence distance spanned by the loop
    //! @return sequence distance spanned by the loop
    size_t LoopParameters::GetSequenceDistance() const
    {
      return std::abs( m_Anchors( 1) - m_Anchors( 0)) - 1;
    }

    //! @brief returns the dihedral angles of the loop
    //! @return dihedral angles of the loop
    const storage::Vector< double> &LoopParameters::GetAngles() const
    {
      return m_DihedralAngles;
    }

    //! @brief returns the sequence direction of the loop
    //! @return sequence direction of the loop
    biol::AASequenceFlexibility::SequenceDirection LoopParameters::GetSequenceDirection() const
    {
      // determine the sequence direction based of the sequence ids of the anchors
      if( m_Anchors( 0) < m_Anchors( 1))
      {
        return biol::AASequenceFlexibility::e_CTerminal;
      }
      else
      {
        return biol::AASequenceFlexibility::e_NTerminal;
      }
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &LoopParameters::GetAlias() const
    {
      static const std::string s_name( "LoopParameters");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LoopParameters::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Stores the conformation and orientation of a loop.");
      serializer.AddInitializer
      (
        "translation",
        "translation vector between the anchor residues of the loop",
        io::Serialization::GetAgent( &m_Translation)
      );
      serializer.AddInitializer
      (
        "rotation",
        "rotation angles in extrinsic x-y-z convention between the anchor residues of the loop",
        io::Serialization::GetAgent( &m_RotationAngles)
      );
      serializer.AddInitializer
      (
        "anchor ids",
        "sequence id of the loop's anchor residues",
        io::Serialization::GetAgentWithSizeLimits( &m_Anchors, 2, 2)
      );
      serializer.AddInitializer
      (
        "chain id",
        "chain id of the loop",
        io::Serialization::GetAgent( &m_ChainID)
      );
      serializer.AddInitializer
      (
        "dihedral angles",
        "dihedral angles of the loop including n-terminal psi-angle and c-terminal phi-angle",
        io::Serialization::GetAgent( &m_DihedralAngles)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief returns the local coordinate system of the given amino acid
    //! @param AMINO_ACID amino aid to return the local coordinate system for
    //! @return local coordinate system of the given amino acid
    storage::VectorND< 3, linal::Vector3D> LoopParameters::GetLocalCoordinateSystem
    (
      const biol::AABase &AMINO_ACID
    )
    {
      // get the coordinates to compute the local coordinate system
      const linal::Vector3D &ca_coord( AMINO_ACID.GetAtom( biol::GetAtomTypes().CA).GetCoordinates());
      const linal::Vector3D &c_coord( AMINO_ACID.GetAtom( biol::GetAtomTypes().C).GetCoordinates());
      const linal::Vector3D &o_coord( AMINO_ACID.GetAtom( biol::GetAtomTypes().O).GetCoordinates());

      // compute the orthonormal base of the local coordinate system
      const linal::Vector3D z_axis( ( c_coord - ca_coord).Normalize());
      const linal::Vector3D ca_o( o_coord - ca_coord);
      const linal::Vector3D y_axis( ( ca_o - ( ca_o * z_axis) * z_axis).Normalize());
      const linal::Vector3D x_axis( linal::CrossProduct( z_axis, y_axis));
      const storage::VectorND< 3, linal::Vector3D> base( x_axis, y_axis, z_axis);

      return base;
    }

    //! @brief computes the Euler angles between the given frames according to z-x'-z'' convention
    //! @param FRAME_A the global coordinate system with axes being the row vectors
    //! @param FRAME_B the local coordinate system with axes being the row vectors
    //! @return Euler angles between the coordinate systems according to z-x'-z'' convention
    linal::Vector3D LoopParameters::GetEulerAngles
    (
      const storage::VectorND< 3, linal::Vector3D> &FRAME_A,
      const storage::VectorND< 3, linal::Vector3D> &FRAME_B
    )
    {
      // convert the coordinate systems into matrices
      linal::Matrix3x3< double> frame_a( 0.0);
      frame_a.ReplaceRow( 0, FRAME_A.First());
      frame_a.ReplaceRow( 1, FRAME_A.Second());
      frame_a.ReplaceRow( 2, FRAME_A.Third());
      linal::Matrix3x3< double> frame_b( 0.0);
      frame_b.ReplaceRow( 0, FRAME_B.First());
      frame_b.ReplaceRow( 1, FRAME_B.Second());
      frame_b.ReplaceRow( 2, FRAME_B.Third());

      // compute the Euler angles between the two frames
      return linal::Matrix3x3< double>::ComputeEulerAnglesXYZ( frame_a, frame_b);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_loop_segment.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LoopSegment::s_Instance
    (
      GetObjectInstances().AddInstance( new LoopSegment())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LoopSegment::LoopSegment() :
      m_SSE(),
      m_IsRigid()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param SSE the sse which the loop segment refers to
    //! @param IS_RIGID boolean indicating if the dihedral angles of the LoopSegment can be changed or not
    LoopSegment::LoopSegment( const util::ShPtr< assemble::SSE> &SSE, const bool IS_RIGID) :
      m_SSE( SSE),
      m_IsRigid( IS_RIGID)
    {
    }

    //! @brief copy constructor
    //! @param OTHER loop segment to be copied
    LoopSegment::LoopSegment( const LoopSegment &OTHER) :
      m_SSE(),
      m_IsRigid( OTHER.m_IsRigid)
    {
      if( OTHER.m_SSE.IsDefined())
      {
        m_SSE = util::ShPtr< assemble::SSE>( OTHER.m_SSE->Clone());
      }
    }

    //! @brief Clone function
    //! @return pointer to new LoopSegment
    LoopSegment *LoopSegment::Clone() const
    {
      return new LoopSegment( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &LoopSegment::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetSSE gives the sse which the loop segment refers to
    //! @return "m_SSE" the sse which the loop segment refers to
    const util::ShPtr< assemble::SSE> &LoopSegment::GetSSE() const
    {
      return m_SSE;
    }

    //! @brief GetSSE gives the sse which the loop segment refers to
    //! @return "m_SSE" the sse which the loop segment refers to
    util::ShPtr< assemble::SSE> &LoopSegment::GetSSE()
    {
      return m_SSE;
    }

    //! @brief GetSSE gives the sse which the loop segment refers to
    //! @return "m_SSE" the sse which the loop segment refers to
    assemble::SSE &LoopSegment::GetSSEReference()
    {
      return *m_SSE;
    }

    //! @brief GetSSE gives the sse which the loop segment refers to
    //! @return "m_SSE" the sse which the loop segment refers to
    const assemble::SSE &LoopSegment::GetConstSSEReference() const
    {
      return *m_SSE;
    }

    //! @brief IsRigid gives boolean indicating if the dihedral angles of the LoopSegment can be changed or not
    //! @return "m_IsRigid" the boolean indicating if the dihedral angles of the LoopSegment can be changed or not
    bool LoopSegment::IsRigid() const
    {
      return m_IsRigid;
    }

    //! @brief gives iterator to residue provided
    //! @param AA_BASE residue for which an iterator will be given
    //! @return iterator to the provided residue
    biol::AASequence::iterator LoopSegment::GetAAIterator( const biol::AABase &AA_BASE)
    {
      // iterate over the sse
      for
      (
        biol::AASequence::iterator itr( m_SSE->Begin()), itr_end( m_SSE->End());
        itr != itr_end;
        ++itr
      )
      {
        if( ( *itr)->GetChainID() == AA_BASE.GetChainID() && ( *itr)->GetSeqID() == AA_BASE.GetSeqID())
        {
          return itr;
        }
      }

      return m_SSE->End();
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LoopSegment::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSE, ISTREAM);
      io::Serialize::Read( m_IsRigid, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LoopSegment::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSE, OSTREAM, INDENT);
      io::Serialize::Write( m_IsRigid, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_loop_segment_sequence_order.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_compare.h"
#include "fold/bcl_fold_locator_loop_segment.h"
#include "fold/bcl_fold_loop_segment.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
    //! @brief return true if SEGMENT_A comes before SEGMENT_B in sequence
    //! @param SEGMENT_A first LoopSegment
    //! @param SEGMENT_B second LoopSegment
    //! @return true if SEGMENT_A comes before SEGMENT_B in sequence
    bool LoopSegmentSequenceOrder::operator()
    (
      const LoopSegment &SEGMENT_A, const LoopSegment &SEGMENT_B
    ) const
    {
      // make sure the chain ids match
      BCL_Assert
      (
        SEGMENT_A.GetSSE()->GetChainID() == SEGMENT_B.GetSSE()->GetChainID(), "chain id of segments in are different"
      );

      // determine which segment comes before the other in sequence
      return assemble::SSELessThanNoOverlap().operator()( SEGMENT_A.GetSSE(), SEGMENT_B.GetSSE());
    }

    //! @brief return true if SEGMENT_LOCATOR_A comes before SEGMENT_LOCATOR_B in sequence
    //! @param SEGMENT_LOCATOR_A first LoopSegment
    //! @param SEGMENT_LOCATOR_B second LoopSegment
    //! @return true if SEGMENT_LOCATOR_A comes before SEGMENT_LOCATOR_B in sequence
    bool LoopSegmentSequenceOrder::operator()
    (
      const LocatorLoopSegment &SEGMENT_LOCATOR_A, const LocatorLoopSegment &SEGMENT_LOCATOR_B
    ) const
    {
      // make sure that the chain ids match
      BCL_Assert
      (
        SEGMENT_LOCATOR_A.GetLocatorSSE().GetChainID() == SEGMENT_LOCATOR_B.GetLocatorSSE().GetChainID(),
        "chain id of segment locators in are different"
      );

      // get the start and end seq ids of the first locator
      const storage::VectorND< 2, int> segment_a_start_end( SEGMENT_LOCATOR_A.GetLocatorSSE().GetSSEID());

      // get the start seq id of the second locator
      const int segment_b_start( SEGMENT_LOCATOR_B.GetLocatorSSE().GetSSEID().First());

      // true if the start and end seq id's of the firsts loop segment sse are less than "segment_b_start"
      if
      (
        ( segment_a_start_end.First() < segment_b_start)
        &&
        ( segment_a_start_end.Second() < segment_b_start)
      )
      {
        // return true since "SEGMENT_LOCATOR_A" is less than "SEGMENT_LOCATOR_B"
        return true;
      }

      // else return larger
      return false;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_aa_phi.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"
#include "fold/bcl_fold_mutate_aa_rotate.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateAAPhi::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateAAPhi())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateAAPhi::MutateAAPhi() :
      m_Rotation()
    {
    }

    //! @brief constructor taking a desired rotation amount in radians
    //! @param ROTATION the desired phi rotation amount in radians
    MutateAAPhi::MutateAAPhi( const double ROTATION) :
      m_Rotation( ROTATION)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateAAPhi
    MutateAAPhi *MutateAAPhi::Clone() const
    {
      return new MutateAAPhi( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateAAPhi::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief GetTransformationMatrix gives the transformation matrix that is necessary to rotate phi of a residue
    //! @param RESIDUE the residue for which the transformation matrix will be calculated
    //! @return the transformation matrix that is necessary to rotate phi of "RESIDUE" by "m_Rotation"
    math::TransformationMatrix3D MutateAAPhi::GetTransformationMatrix( const biol::AABase &RESIDUE) const
    {
      // return the transformation matrix from the MutateAARotate created by GetMutateAARotate from RESIDUE
      return GetMutateAARotate( RESIDUE).GetTransformationMatrix();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param RESIDUE Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< biol::AABase> MutateAAPhi::operator()( const biol::AABase &RESIDUE) const
    {
      // create a new residue based on the desired phi change
      const math::MutateResult< biol::AABase> new_aa( GetMutateAARotate( RESIDUE)( RESIDUE));

      // return the "new_aa"
      return new_aa;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateAAPhi::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Rotation, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateAAPhi::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Rotation, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief GetMutateAARotate provides the MutateAARotate object necesssary to do the desired phi change
    //! @param RESIDUE is the residue whose phi is going to be changed
    //! @return the MutateAARotate object necesssary to do the desired phi change
    MutateAARotate MutateAAPhi::GetMutateAARotate( const biol::AABase &RESIDUE) const
    {
      // get the coordinates of the nitrogen of "RESIDUE"
      const linal::Vector3D &n_atom_coordinates( RESIDUE.GetAtom( biol::GetAtomTypes().N).GetCoordinates());

      // get the ca coordinates from "RESIDUE"
      const linal::Vector3D &ca_atom_coordinates( RESIDUE.GetCA().GetCoordinates());

      // create a LineSegment3D "rotation_axis" which will be used as the phi rotation axis with N as origin
      const coord::LineSegment3D rotation_axis( n_atom_coordinates, ca_atom_coordinates);

      // create a MutateAARotate object out of "rotation_axis", "ca_atom_coordinates", and "m_Rotation"
      const MutateAARotate rotate( rotation_axis, ca_atom_coordinates, m_Rotation);

      // return the MutateAARotate which can be used to perform the desired phi rotation
      return rotate;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_aa_psi.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"
#include "linal/bcl_linal_vector_3d_operations.h"
#include "math/bcl_math_mutate_result.h"
#include "math/bcl_math_rotation_matrix_3d.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateAAPsi::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateAAPsi())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateAAPsi::MutateAAPsi() :
      m_Rotation()
    {
    }

    //! @brief constructor taking a desired rotation amount in radians
    //! @param ROTATION the desired psi rotation amount in radians
    MutateAAPsi::MutateAAPsi( const double ROTATION) :
      m_Rotation( ROTATION)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateAAPsi
    MutateAAPsi *MutateAAPsi::Clone() const
    {
      return new MutateAAPsi( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateAAPsi::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief GetTransformationMatrix gives the transformation matrix that is necessary to rotate psi of a residue
    //! @param RESIDUE the residue for which the transformation matrix will be calculated
    //! @return the transformation matrix that is necessary to rotate psi of "RESIDUE" by "m_Rotation"
    math::TransformationMatrix3D MutateAAPsi::GetTransformationMatrix( const biol::AABase &RESIDUE) const
    {
      // get the C coordinates of "RESIDUE"
      const linal::Vector3D &c_atom_coordinates( RESIDUE.GetAtom( biol::GetAtomTypes().C).GetCoordinates());

      // get the CA coordinates of "RESIDUE"
      const linal::Vector3D &ca_atom_coordinates( RESIDUE.GetCA().GetCoordinates());

      // create a LineSegment3D "rotation_axis" which will be used as the psi rotation axis with CA as origin
      const coord::LineSegment3D rotation_axis( ca_atom_coordinates, c_atom_coordinates);

      // create TransformationMatrix3D and add the necessary transformations for rotating psi by "m_Rotation"
      math::TransformationMatrix3D transform( -ca_atom_coordinates);
      transform( math::RotationMatrix3D( rotation_axis.GetDirection(), m_Rotation));
      transform( ca_atom_coordinates);

      // return "transform"
      return transform;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param RESIDUE Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< biol::AABase> MutateAAPsi::operator()( const biol::AABase &RESIDUE) const
    {
      // create a ShPtr to a new residue
      util::ShPtr< biol::AABase> new_aa( RESIDUE.Clone());

      // just rotate the oxygen atom of the residue if it exists
      // get the Oxygen from this amino acid
      const biol::Atom &oxygen( RESIDUE.GetAtom( biol::GetAtomTypes().O));

      // if the type is defined, thus the oxygen atom exists
      if( oxygen.GetType().IsDefined())
      {
        // make a copy of the atom
        biol::Atom new_oxygen( oxygen);

        // apply the psi transformation
        new_oxygen.Transform( GetTransformationMatrix( RESIDUE));

        // set the oxygen of "new_aa" to "new_oxygen"
        new_aa->SetAtom( new_oxygen);
      }

      // create mutate result with "new_aa"
      const math::MutateResult< biol::AABase> mutate_result( new_aa, *this);

      // return "mutate_result"
      return mutate_result;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateAAPsi::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Rotation, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateAAPsi::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Rotation, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_aa_rotate.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "linal/bcl_linal_vector_3d_operations.h"
#include "math/bcl_math_mutate_result.h"
#include "math/bcl_math_rotation_matrix_3d.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateAARotate::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateAARotate())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateAARotate::MutateAARotate() :
      m_RotationAxis(),
      m_RotationOrigin(),
      m_Rotation()
    {
    }

    //! @brief constructor taking the member variable parameters
    //! @param ROTATION_AXIS the axis around which the rotation will take place
    //! @param ROTATION_ORIGIN the origin point around which the rotation will occur
    //! @param ROTATION the amount of rotation
    MutateAARotate::MutateAARotate
    (
      const coord::LineSegment3D &ROTATION_AXIS, const linal::Vector3D &ROTATION_ORIGIN, const double ROTATION
    ) :
      m_RotationAxis( ROTATION_AXIS),
      m_RotationOrigin( ROTATION_ORIGIN),
      m_Rotation( ROTATION)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateAARotate
    MutateAARotate *MutateAARotate::Clone() const
    {
      return new MutateAARotate( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateAARotate::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief GetTransformationMatrix gives the transformation matrix that is necessary to rotate a residue
    //! @return the transformation matrix that is necessary to rotate "RESIDUE" according to member variables
    math::TransformationMatrix3D MutateAARotate::GetTransformationMatrix() const
    {
      // create TransformationMatrix3D "transform" and initialize with translation to the origin of rotation
      math::TransformationMatrix3D transform( -m_RotationOrigin);

      // add the desired rotation according to "m_RotationAxis" and "m_Rotation" to "transform"
      transform( math::RotationMatrix3D( m_RotationAxis.GetDirection(), m_Rotation));

      // add the translation of moving back to the original position
      transform( m_RotationOrigin);

      // return the transformation matrix "transform"
      return transform;
    }

    //! @brief GetRotationAxis provides the axis around which the rotation will take place
    //! @return the axis around which the rotation will take place
    const coord::LineSegment3D &MutateAARotate::GetRotationAxis() const
    {
      return m_RotationAxis;
    }

    //! @brief GetRotationOrigin gives the origin point around which the rotation will occur
    //! @return the origin point around which the rotation will occur
    const linal::Vector3D &MutateAARotate::GetRotationOrigin() const
    {
      return m_RotationOrigin;
    }

    //! @brief GetRotation gives the amount of rotation
    //! @return the amount of rotation
    double MutateAARotate::GetRotation() const
    {
      return m_Rotation;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param RESIDUE Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< biol::AABase> MutateAARotate::operator()( const biol::AABase &RESIDUE) const
    {
      // create ShPtr to new residue copy of "RESIDUE" which will be rotated
      util::ShPtr< biol::AABase> new_aa( RESIDUE.Clone());

      // transform "new_aa" according to the transformation matrix provided by GetTransformationMatrix
      new_aa->Transform( GetTransformationMatrix());

      // return the transformed "new_aa" in a MutateResult object
      return math::MutateResult< biol::AABase>( new_aa, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateAARotate::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_RotationAxis, ISTREAM);
      io::Serialize::Read( m_RotationOrigin, ISTREAM);
      io::Serialize::Read( m_Rotation, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateAARotate::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_RotationAxis, OSTREAM, INDENT);
      io::Serialize::Write( m_RotationOrigin, OSTREAM, INDENT);
      io::Serialize::Write( m_Rotation, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_aa_sequence_grow.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "biol/bcl_biol_aa_sequence_factory.h"
#include "biol/bcl_biol_aa_sequence_flexibility.h"
#include "fold/bcl_fold_mutation_residue.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateAASequenceGrow::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateAASequenceGrow())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateAASequenceGrow::MutateAASequenceGrow() :
      m_PhiPsiGenerator(),
      m_AnchorSequence()
    {
    }

    //! @brief constructor from member variables
    //! @param PHI_PSI_GENERATOR the method that will produce phi and psi angles as the sequence grows
    //! @param N_TERMINAL_AA_SEQUENCE the starting sequence which will be grown onto
    MutateAASequenceGrow::MutateAASequenceGrow
    (
      const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GENERATOR,
      const util::SiPtr< const biol::AASequence> &N_TERMINAL_AA_SEQUENCE
    ) :
      m_PhiPsiGenerator( PHI_PSI_GENERATOR),
      m_AnchorSequence( N_TERMINAL_AA_SEQUENCE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateAASequenceInitializeCoordinates
    MutateAASequenceGrow *MutateAASequenceGrow::Clone() const
    {
      return new MutateAASequenceGrow( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateAASequenceGrow::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param SEQUENCE_TO_GROW Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< biol::AASequence> MutateAASequenceGrow::operator()
    (
      const biol::AASequence &SEQUENCE_TO_GROW
    ) const
    {
      const math::MutateResult< biol::AASequence> empty_result( util::ShPtr< biol::AASequence>(), *this);

      // make sure "m_AnchorSequence" is defined
      if( !m_AnchorSequence.IsDefined())
      {
        BCL_MessageCrt( "anchor sequence pointer is not defined");
        return empty_result;
      }

      // make sure that both of the sequences have at least one residue in them
      if( m_AnchorSequence->GetData().IsEmpty())
      {
        BCL_MessageCrt( "anchor sequence is empty");
        return empty_result;
      }
      if( SEQUENCE_TO_GROW.GetData().IsEmpty())
      {
        BCL_MessageCrt( "given sequence to grow is empty");
        return empty_result;
      }

      // create an sse of ideal strand sequence for the sequence to grow
      assemble::SSE new_sequence( SEQUENCE_TO_GROW, biol::GetSSTypes().STRAND);
      new_sequence.SetToIdealConformationAtOrigin();

      util::ShPtr< biol::AABase> previous_aa( m_AnchorSequence->GetLastAA());

      // iterate over new sequence and sample conformation
      for
      (
        biol::AASequence::iterator itr( new_sequence.Begin()), itr_end( new_sequence.End());
        itr != itr_end;
        previous_aa = *itr, ++itr
      )
      {
        util::ShPtr< biol::AABase> &current_aa( *itr);
        util::ShPtr< biol::AABase> next_aa;
        {
          biol::AASequence::iterator next_itr( itr + 1);
          if( next_itr != itr_end)
          {
            next_aa = *next_itr;
          }
        }

        MutationResidue current_mutation_residue( current_aa, previous_aa, next_aa);

        // generate phi psi
        const storage::VectorND< 2, double> new_phi_psi
        (
          m_PhiPsiGenerator->operator()( current_mutation_residue)
        );

        const storage::VectorND< 2, double> new_phi_psi_change( biol::AASequenceFlexibility::CalculatePhiPsiChange( new_sequence, current_aa->GetSeqID(), new_phi_psi));
        biol::AASequenceFlexibility::ChangePhiPsi( new_sequence, current_aa->GetSeqID(), new_phi_psi_change, biol::AASequenceFlexibility::e_CTerminal);

        // for first amino acid, use phi to connect to anchor sse
        if( itr == new_sequence.Begin())
        {
          BCL_MessageDbg( "attaching grow sequence on cterm of " + m_AnchorSequence->GetSequenceIdentification() + " with phi: " + util::Format()( new_phi_psi.First()));
          const math::TransformationMatrix3D transform( biol::AASequenceFactory::TransformationAppend( *m_AnchorSequence, *current_aa, new_phi_psi.First()));
          new_sequence.Transform( transform);
        }
      }

      util::ShPtr< biol::AASequence> sp_grown_seq( m_AnchorSequence->Clone());
      sp_grown_seq->AppendSequence( new_sequence);

      // return result
      return math::MutateResult< biol::AASequence>( sp_grown_seq, *this);
    }

    //! @brief grows the given sequence by connecting the cterminus to the anchor residue then growing nterminally
    //! @param SEQUENCE_TO_GROW sequence for which coordinates will be added
    //! @return MutateResult contains the sequence with newly assigned coordinates grown onto the anchor residue
    math::MutateResult< biol::AASequence>
    MutateAASequenceGrow::GrowTowardsNTerminus( const biol::AASequence &SEQUENCE_TO_GROW) const
    {
      const math::MutateResult< biol::AASequence> empty_result( util::ShPtr< biol::AASequence>(), *this);

      // make sure "m_AnchorSequence" is defined
      if( !m_AnchorSequence.IsDefined())
      {
        BCL_MessageCrt( "anchor sequence pointer is not defined");
        return empty_result;
      }

      // make sure that both of the sequences have at least one residue in them
      if( m_AnchorSequence->GetData().IsEmpty())
      {
        BCL_MessageCrt( "anchor sequence is empty");
        return empty_result;
      }
      if( SEQUENCE_TO_GROW.GetData().IsEmpty())
      {
        BCL_MessageCrt( "given sequence to grow is empty");
        return empty_result;
      }

      // create an sse of ideal strand sequence for the sequence to grow
      assemble::SSE new_sequence( SEQUENCE_TO_GROW, biol::GetSSTypes().STRAND);
      new_sequence.SetToIdealConformationAtOrigin();

      util::ShPtr< biol::AABase> previous_aa;

      // iterate over new sequence and sample conformation
      for
      (
        biol::AASequence::iterator itr( new_sequence.Begin()), itr_end( new_sequence.End());
        itr != itr_end;
        previous_aa = *itr, ++itr
      )
      {
        util::ShPtr< biol::AABase> &current_aa( *itr);
        util::ShPtr< biol::AABase> next_aa;
        {
          biol::AASequence::iterator next_itr( itr + 1);
          if( next_itr != itr_end)
          {
            next_aa = *next_itr;
          }
        }

        MutationResidue current_mutation_residue( current_aa, previous_aa, next_aa);

        // generate phi psi
        const storage::VectorND< 2, double> new_phi_psi
        (
          m_PhiPsiGenerator->operator()( current_mutation_residue)
        );

        const storage::VectorND< 2, double> new_phi_psi_change( biol::AASequenceFlexibility::CalculatePhiPsiChange( new_sequence, current_aa->GetSeqID(), new_phi_psi));
        biol::AASequenceFlexibility::ChangePhiPsi( new_sequence, current_aa->GetSeqID(), new_phi_psi_change, biol::AASequenceFlexibility::e_CTerminal);

        // for last amino acid, use phi to connect to anchor sse
        if( !next_aa.IsDefined())
        {
          BCL_MessageDbg( "attaching grow sequence on nterm of " + m_AnchorSequence->GetSequenceIdentification() + " with phi: " + util::Format()( new_phi_psi.First()));
          const math::TransformationMatrix3D transform( biol::AASequenceFactory::TransformationPrepend( *current_aa, *m_AnchorSequence, new_phi_psi.First()));
          new_sequence.Transform( transform);
        }
      }

      util::ShPtr< biol::AASequence> sp_grown_seq( new biol::AASequence( new_sequence));
      sp_grown_seq->AppendSequence( *m_AnchorSequence);

      // return result
      return math::MutateResult< biol::AASequence>( sp_grown_seq, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateAASequenceGrow::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_PhiPsiGenerator, ISTREAM);
      io::Serialize::Read( m_AnchorSequence, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateAASequenceGrow::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_PhiPsiGenerator, OSTREAM, INDENT);
      io::Serialize::Write( m_AnchorSequence, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_aa_set_phi.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "fold/bcl_fold_mutate_aa_phi.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateAASetPhi::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateAASetPhi())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateAASetPhi::MutateAASetPhi() :
      m_PreviousC(),
      m_DesiredPhi()
    {
    }

    //! @brief constructor taking member variables
    //! @param PREVIOUS_C the C atom of the residue previous to the residue whose phi will be changed
    //! @param DESIRED_PHI the desired phi angle value in radians
    MutateAASetPhi::MutateAASetPhi( const biol::Atom &PREVIOUS_C, const double DESIRED_PHI) :
      m_PreviousC( PREVIOUS_C),
      m_DesiredPhi( DESIRED_PHI)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateAASetPhi
    MutateAASetPhi *MutateAASetPhi::Clone() const
    {
      return new MutateAASetPhi( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateAASetPhi::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief GetTransformationMatrix gives the transformation matrix that is necessary to set phi of a residue
    //! @param RESIDUE the residue for which the transformation matrix will be calculated
    //! @return the transformation matrix that is necessary to set phi of "RESIDUE" to "m_DesiredPhi"
    math::TransformationMatrix3D MutateAASetPhi::GetTransformationMatrix( const biol::AABase &RESIDUE) const
    {
      // return the transformation matrix that is necessary to set phi of "RESIDUE" to "m_DesiredPhi"
      return GetMutateAAPhi( RESIDUE).GetTransformationMatrix( RESIDUE);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param RESIDUE Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< biol::AABase> MutateAASetPhi::operator()( const biol::AABase &RESIDUE) const
    {
      // get the residue with phi mutated as desired in a MutateResult object
      const math::MutateResult< biol::AABase> mutated_phi( GetMutateAAPhi( RESIDUE)( RESIDUE));

      // return "mutated_phi"
      return mutated_phi;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateAASetPhi::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_PreviousC, ISTREAM);
      io::Serialize::Read( m_DesiredPhi, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateAASetPhi::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_PreviousC, OSTREAM, INDENT);
      io::Serialize::Write( m_DesiredPhi, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief GetMutateAAPhi provides the MutateAAPhi object necesssary to set phi as desired
    //! @param RESIDUE is the residue whose phi is going to be set
    //! @return the MutateAAPhi object necesssary to set phi as desired
    MutateAAPhi MutateAASetPhi::GetMutateAAPhi( const biol::AABase &RESIDUE) const
    {
      // calculate the rotation that is needed to set phi to "m_DesiredPhi"
      double current_phi( RESIDUE.Phi());
      if( !util::IsDefined( current_phi))
      {
        current_phi = RESIDUE.CalculatePhi( m_PreviousC);
      }
      const double rotation( m_DesiredPhi - current_phi);

      // message the needed rotation to set phi to "m_DesiredPhi"
      BCL_MessageDbg
      (
        "current phi is " + util::Format()( current_phi)
        + " desired phi is " + util::Format()( m_DesiredPhi)
        + " needed rotation is " + util::Format()( rotation)
      );

      // create a MutateAAPhi object using "rotation"
      const MutateAAPhi phi_mutate( -rotation);

      // return MutateAAPhi which can be used to set phi of "RESIDUE" as desired
      return phi_mutate;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_aa_set_psi.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "fold/bcl_fold_mutate_aa_psi.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateAASetPsi::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateAASetPsi())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateAASetPsi::MutateAASetPsi() :
      m_FollowingN(),
      m_DesiredPsi()
    {
    }

    //! @brief constructor taking member variables
    //! @param FOLLOWING_N the N atom of the residue following the residue whose psi will be changed
    //! @param DESIRED_PSI the desired psi angle value in radians
    MutateAASetPsi::MutateAASetPsi( const biol::Atom &FOLLOWING_N, const double DESIRED_PSI) :
      m_FollowingN( FOLLOWING_N),
      m_DesiredPsi( DESIRED_PSI)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateAASetPsi
    MutateAASetPsi *MutateAASetPsi::Clone() const
    {
      return new MutateAASetPsi( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateAASetPsi::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief GetTransformationMatrix gives the transformation matrix that is necessary to set psi of a residue
    //! @param RESIDUE the residue for which the transformation matrix will be calculated
    //! @return the transformation matrix that is necessary to set psi of "RESIDUE" to "m_DesiredPsi"
    math::TransformationMatrix3D MutateAASetPsi::GetTransformationMatrix( const biol::AABase &RESIDUE) const
    {
      // return the transformation matrix that is necessary to set psi of "RESIDUE" to "m_DesiredPsi"
      return GetMutateAAPsi( RESIDUE).GetTransformationMatrix( RESIDUE);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param RESIDUE Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< biol::AABase> MutateAASetPsi::operator()( const biol::AABase &RESIDUE) const
    {
      // get the residue with psi mutated as desired in a MutateResult object
      const math::MutateResult< biol::AABase> mutated_psi( GetMutateAAPsi( RESIDUE).operator()( RESIDUE));

      // return "mutated_psi"
      return mutated_psi;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateAASetPsi::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_FollowingN, ISTREAM);
      io::Serialize::Read( m_DesiredPsi, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateAASetPsi::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_FollowingN, OSTREAM, INDENT);
      io::Serialize::Write( m_DesiredPsi, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief GetMutateAAPsi provides the MutateAAPsi object necesssary to set psi as desired
    //! @param RESIDUE is the residue whose psi is going to be set
    //! @return the MutateAAPsi object necesssary to set psi as desired
    MutateAAPsi MutateAASetPsi::GetMutateAAPsi( const biol::AABase &RESIDUE) const
    {
      // calculate the rotation that is needed to set psi to "m_DesiredPsi"
      double current_psi( RESIDUE.Psi());
      if( !util::IsDefined( current_psi))
      {
        current_psi = RESIDUE.CalculatePsi( m_FollowingN);
      }
      const double rotation( m_DesiredPsi - current_psi);

      // message the needed rotation to set phi to "m_DesiredPhi"
      BCL_MessageDbg
      (
        "current Psi is " + util::Format()( RESIDUE.CalculatePsi( m_FollowingN))
        + " desired Psi is " + util::Format()( m_DesiredPsi)
        + " needed rotation is " + util::Format()( rotation)
      );

      // create a MutateAAPsi object using "rotation"
      const MutateAAPsi psi_mutate( -rotation);

      // return MutateAAPsi which can be used to set psi of "RESIDUE" as desired
      return psi_mutate;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_domain_flip.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    // instantiate instance
    const util::SiPtr< const util::ObjectInterface> MutateDomainFlip::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateDomainFlip())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a single flip axis, flip internal and and a flip all boolean
    //! @param FLIP_AXIS Axis to apply the flip around
    //! @param FLIP_INTERNAL boolean to flip internally
    //! @param FLIP_ALL boolean to decide whether to flip all strands or only few
    //! @param USE_DIFFERENT_FLIP_AXES boolean to decide whether to use different flip axes for each flip
    MutateDomainFlip::MutateDomainFlip
    (
      const coord::Axis FLIP_AXIS,
      const bool FLIP_INTERNAL,
      const bool FLIP_ALL,
      const bool USE_DIFFERENT_FLIP_AXES
    ) :
      m_FlipAxes( FLIP_AXIS),
      m_FlipInternal( FLIP_INTERNAL),
      m_FlipAll( FLIP_ALL),
      m_UseDifferentFlipAxes( USE_DIFFERENT_FLIP_AXES)
    {
      // check the flip booleans
      BCL_Assert
      (
        m_FlipInternal || ( m_FlipAll && !m_FlipInternal), "Flip internal cannot be false if flip all was false!"
      );
    }

    //! @brief constructor from a set of flip axis, flip internal and and a flip all boolean
    //! @param FLIP_AXES Set of axes to apply the flip around, (randomly chosen at flip time)
    //! @param FLIP_INTERNAL boolean to flip internally
    //! @param FLIP_ALL boolean to decide whether to flip all strands or only few
    //! @param USE_DIFFERENT_FLIP_AXES boolean to decide whether to use different flip axes for each flip
    MutateDomainFlip::MutateDomainFlip
    (
      const storage::Set< coord::Axis> &FLIP_AXES,
      const bool FLIP_INTERNAL,
      const bool FLIP_ALL,
      const bool USE_DIFFERENT_FLIP_AXES
    ) :
      m_FlipAxes( FLIP_AXES),
      m_FlipInternal( FLIP_INTERNAL),
      m_FlipAll( FLIP_ALL),
      m_UseDifferentFlipAxes( USE_DIFFERENT_FLIP_AXES)
    {
      // make sure the given set of axes is not empty
      BCL_Assert( !m_FlipAxes.IsEmpty(), "The given set of flip axes is empty!");

      // check the flip booleans
      BCL_Assert
      (
        m_FlipInternal || ( m_FlipAll && !m_FlipInternal), "Flip internal cannot be false if flip all was false!"
      );
    }

    //! @brief Clone function
    //! @return pointer to new MutateDomainFlip
    MutateDomainFlip *MutateDomainFlip::Clone() const
    {
      return new MutateDomainFlip( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateDomainFlip::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return flip axes
    //! @return flip axes
    const storage::Set< coord::Axis> &MutateDomainFlip::GetFlipAxes() const
    {
      return m_FlipAxes;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a Domain and return a mutated Domain
    //! @param THIS_DOMAIN Domain which will be mutated
    //! @return MutateResult with the mutated Domain
    math::MutateResult< assemble::Domain> MutateDomainFlip::operator()( const assemble::Domain &THIS_DOMAIN) const
    {
      // initialize an empty Domain ShPtr
      static util::ShPtr< assemble::Domain> s_empty_domain;

      // make sure the Domain has at least two SSEs
      if( THIS_DOMAIN.GetNumberSSEs() < 2)
      {
        // warn user and return
        BCL_MessageVrb( "The given domain has less than 2 SSEs, therefore skipping");
        return math::MutateResult< assemble::Domain>( s_empty_domain, *this);
      }

      // make a copy of the Domain
      util::ShPtr< assemble::Domain> new_domain( THIS_DOMAIN.Clone());

      // collect the list of SSEs to flip
      util::SiPtrVector< const assemble::SSE> sses_to_flip( new_domain->GetSSEs());

      // initialize transformation to be applied
      math::TransformationMatrix3D transformation;

      // determine the random flip axes
      coord::Axis flip_axis( *random::GetGlobalRandom().Iterator( m_FlipAxes.Begin(), m_FlipAxes.End(), m_FlipAxes.GetSize()));

      // if flipping externally
      if( !m_FlipInternal)
      {
        BCL_MessageDbg( "Flipping externally");

        // make a copy of the domain orientation
        math::TransformationMatrix3D domain_orientation( new_domain->GetOrientation());

        // build up the transformation matrix
        // first move the origin
        transformation = math::Inverse( domain_orientation);

        // apply the flip along the random axis
        transformation( flip_axis, math::g_Pi);

        // transform back
        transformation( domain_orientation);
      }
      // else if flipping internally
      else
      {
        // collect the list of SSEs to flip
        const size_t nr_sses( sses_to_flip.GetSize());
        BCL_MessageDbg( "Flipping internally ");

        // if flip all is not selected
        if( !m_FlipAll)
        {
          // determine how many SSEs to flip
          const size_t nr_flips( random::GetGlobalRandom().Random< size_t>( 1, nr_sses));
          const size_t nr_sses_unflipped( nr_sses - nr_flips);
          BCL_MessageDbg
          (
            "Flipping internally " + util::Format()( nr_flips) + " SSEs out of " + util::Format()( nr_sses)
          );

          // iterate number of SSEs to left unflipped times
          for( size_t ctr( 0); ctr < nr_sses_unflipped; ++ctr)
          {
            // remove a random element
            sses_to_flip.RemoveRandomElement();
          }
        }
      }

      // now iterate over the SSEs to flip
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          sse_itr( sses_to_flip.Begin()), sse_itr_end( sses_to_flip.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // get the next strand
        const assemble::SSE &this_sse( **sse_itr);

        // if internal flip
        if( m_FlipInternal)
        {
          // if the boolean to use different axis is given
          if( m_UseDifferentFlipAxes)
          {
            // then get a new random axis
            flip_axis = *random::GetGlobalRandom().Iterator( m_FlipAxes.Begin(), m_FlipAxes.End(), m_FlipAxes.GetSize());
          }
          // update the transformation so that it's specific to this SSE
          // first step is to move to the origin
          transformation = math::Inverse( this_sse.GetOrientation());
          // rotate apply the flip
          transformation( flip_axis, math::g_Pi);
          // move back to the original location
          transformation( this_sse.GetOrientation());
        }

        BCL_MessageDbg
        (
          "Flipping " + this_sse.GetIdentification() + " around axis " + flip_axis.GetName()
        );

        // make a copy of this SSE and apply the transformation
        util::ShPtr< assemble::SSE> new_sse( this_sse.Clone());
        new_sse->Transform( transformation);

        // replace the corresponding SSE with the new_sse in the new_domain
        new_domain->Replace( new_sse);
      }

      // end
      return math::MutateResult< assemble::Domain>( new_domain, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateDomainFlip::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_FlipAxes, ISTREAM);
      io::Serialize::Read( m_FlipInternal, ISTREAM);
      io::Serialize::Read( m_FlipAll, ISTREAM);
      io::Serialize::Read( m_UseDifferentFlipAxes, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateDomainFlip::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // read members
      io::Serialize::Write( m_FlipAxes, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_FlipInternal, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_FlipAll, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_UseDifferentFlipAxes, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_domain.h"
#include "fold/bcl_fold_mutate_domain_merge_consecutive_ss_types.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateDomainMergeConsecutiveSSTypes::MutateDomainMergeConsecutiveSSTypes() :
      m_Scheme( GetStaticClassName< MutateDomainMergeConsecutiveSSTypes>()),
      m_SSType()
    {
    }

    //! @brief default constructor
    MutateDomainMergeConsecutiveSSTypes::MutateDomainMergeConsecutiveSSTypes( const biol::SSType &SSTYPE) :
      m_Scheme( GetStaticClassName< MutateDomainMergeConsecutiveSSTypes>()),
      m_SSType( SSTYPE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateDomainMergeConsecutiveSSTypes
    MutateDomainMergeConsecutiveSSTypes *MutateDomainMergeConsecutiveSSTypes::Clone() const
    {
      return new MutateDomainMergeConsecutiveSSTypes( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateDomainMergeConsecutiveSSTypes::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns scheme
    //! @return the scheme of the object
    const std::string &MutateDomainMergeConsecutiveSSTypes::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////
    math::MutateResult< bcl::assemble::Domain> MutateDomainMergeConsecutiveSSTypes::operator()
    (
      const assemble::Domain &DOMAINS
    ) const
    {
      util::ShPtr< assemble::Domain> new_domain( DOMAINS.Clone());
      util::SiPtrVector< const assemble::SSE> domain_sses( DOMAINS.GetSSEs());
      storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> sses( domain_sses.Begin(), domain_sses.End());

      // iterate over all SSEs
      for
      (
        storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
        itr( sses.Begin()), next( sses.Begin()), itr_end( sses.End()); next != itr_end;
      )
      {
        ++next;
        if( next == itr_end)
        {
          break;
        }

        // check if the current SSEs type matches the next ones
        if( ( *itr)->GetType() == ( *next)->GetType())
        {
          util::ShPtr< assemble::SSE> new_sse( ( *itr)->Clone());

          // keep iterating and assembling the new sse while the type is still the same
          while( ( *next)->GetType() == ( *itr)->GetType() && ( *itr)->GetType() == m_SSType && next != itr_end)
          {
            new_sse->AppendSequence( ( **next), false);

            // remove the sse just appended to the new sse out of the old domain
            new_domain->Remove( **next);
            ++next;
          }

          // remove the current position out of the old domain
          new_domain->Remove( **itr);

          // insert the new sse into the domain to fill up the gap left by the merged ones
          new_domain->Insert( new_sse);
        }

        // reset the iterator to the current position right after the last merged SSE
        itr = next;
      }

      return math::MutateResult< assemble::Domain>( new_domain, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateDomainMergeConsecutiveSSTypes::Read( std::istream &ISTREAM)
    {
      io::Serialize::Read( m_SSType, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateDomainMergeConsecutiveSSTypes::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {

      io::Serialize::Write( m_SSType, OSTREAM) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM);
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_domain_shuffle.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateDomainShuffle::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateDomainShuffle())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a max number swaps and scheme
    //! @param MAX_NUMBER_SWAPS Maximum number of swaps within one mutate
    //! @param BEND whether to bend the SSE after swapping to match the original phi/psi angles
    //! @param SCHEME Scheme to be used
    MutateDomainShuffle::MutateDomainShuffle
    (
      const size_t MAX_NUMBER_SWAPS,
      const bool BEND,
      const std::string &SCHEME
    ) :
      m_MaxNumberSwaps( MAX_NUMBER_SWAPS),
      m_Bend( BEND),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateDomainShuffle
    MutateDomainShuffle *MutateDomainShuffle::Clone() const
    {
      return new MutateDomainShuffle( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateDomainShuffle::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateDomainShuffle::GetAlias() const
    {
      static const std::string s_name( "MutateDomainShuffle");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateDomainShuffle::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Shuffles locations and orientations of SSEs in domains.");
      serializer.AddInitializer
      (
        "maximum steps",
        "maximum number of steps",
        io::Serialization::GetAgent( &m_MaxNumberSwaps)
      );
      serializer.AddInitializer
      (
        "bend",
        "whether to adjust swapped SSEs to the dihedral angles of the previous SSE",
        io::Serialization::GetAgent( &m_Bend)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a Domain and return a mutated Domain
    //! @param THIS_DOMAIN Domain which will be mutated
    //! @return MutateResult with the mutated Domain
    math::MutateResult< assemble::Domain> MutateDomainShuffle::operator()( const assemble::Domain &THIS_DOMAIN) const
    {
      // static empty domain
      static util::ShPtr< assemble::Domain> s_empty_domain;

      // get the sses from the Domain
      util::SiPtrVector< const assemble::SSE> sses( THIS_DOMAIN.GetSSEs());

      // if there are less than 2 SSEs
      if( sses.GetSize() < 2)
      {
        // warn user and return failed MutateResult
        BCL_MessageVrb
        (
          "The given domain has only " + util::Format()( sses.GetSize()) + " SSEs therefore skipping this move"
        );
        return math::MutateResult< assemble::Domain>( s_empty_domain, *this);
      }

      // determine total number of swaps
      const size_t number_swaps
      (
        random::GetGlobalRandom().Random< size_t>( 1, std::min( m_MaxNumberSwaps, THIS_DOMAIN.GetNumberSSEs() / 2))
      );

      BCL_MessageVrb( "Number of swaps to apply " + util::Format()( number_swaps));

      // new sses
      util::ShPtr< assemble::SSE> new_sses;

      // construct a new Domain
      util::ShPtr< assemble::Domain> new_domain( THIS_DOMAIN.Clone());

      // iterate over swaps
      for( size_t nr_swap( 0); nr_swap < number_swaps; ++nr_swap)
      {
        // pick a strand
        util::SiPtrVector< const assemble::SSE>::iterator itr_a
        (
          random::GetGlobalRandom().Iterator( sses.Begin(), sses.End(), sses.GetSize())
        );

        // make a copy of the SSE
        util::ShPtr< assemble::SSE> sse_a( ( *itr_a)->Clone());

        // remove the first SSE
        sses.RemoveElement( itr_a);

        // pick a second strand
        util::SiPtrVector< const assemble::SSE>::iterator itr_b
        (
          random::GetGlobalRandom().Iterator( sses.Begin(), sses.End(), sses.GetSize())
        );

        // make a copy of the SSE
        util::ShPtr< assemble::SSE> sse_b( ( *itr_b)->Clone());

        // remove the second SSE
        sses.RemoveElement( itr_b);

        BCL_MessageVrb
        (
          "Swap #" + util::Format()( nr_swap) + " " + sse_a->GetIdentification() + " with " + sse_b->GetIdentification()
        );

        // if the SSEs need to be bent and the SSEs are the same type
        if( m_Bend && sse_a->GetType() == sse_b->GetType())
        {
          // make a copy of the first SSE
          const util::ShPtr< assemble::SSE> sse_a_copy( sse_a->Clone());

          // fit the sses
          sse_a->FitToSSE( *sse_b);
          sse_b->FitToSSE( *sse_a_copy);
        }
        // don't bend the SSEs, keep their current phi/psi angles
        else
        {
          // prepare transformation from a to b and b to a
          math::TransformationMatrix3D transform_ab( math::Inverse( sse_a->GetOrientation()));
          transform_ab( sse_b->GetOrientation());
          math::TransformationMatrix3D transform_ba( math::Inverse( sse_b->GetOrientation()));
          transform_ba( sse_a->GetOrientation());

          // apply the transformations
          sse_a->Transform( transform_ab);
          sse_b->Transform( transform_ba);
        }

        // do the replace within the domain
        new_domain->Replace( sse_a);
        new_domain->Replace( sse_b);
      }

      // end
      return math::MutateResult< assemble::Domain>( new_domain, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateDomainShuffle::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_MaxNumberSwaps, ISTREAM);
      io::Serialize::Read( m_Bend, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateDomainShuffle::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_MaxNumberSwaps, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Bend, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_domain_sse_pair_trim.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateDomainSSEPairTrim::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateDomainSSEPairTrim())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateDomainSSEPairTrim::MutateDomainSSEPairTrim() :
      m_Scheme(),
      m_MinSSESizes(),
      m_NumberResiduesToTrim()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param SCHEME the scheme for this mutate
    //! @param MIN_SSE_SIZES minimum SSE sizes to be allowed when shrinking
    //! @param NUMBER_RESIS_TO_TRIM the total number of residues that will possibly be trimmed
    MutateDomainSSEPairTrim::MutateDomainSSEPairTrim
    (
      const size_t NUMBER_RESIS_TO_TRIM,
      const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES,
      const std::string &SCHEME
    ) :
      m_Scheme( SCHEME),
      m_MinSSESizes( MIN_SSE_SIZES),
      m_NumberResiduesToTrim( NUMBER_RESIS_TO_TRIM)
    {

    }

    //! @brief Clone function
    //! @return pointer to new MutateDomainSSEPairTrim
    MutateDomainSSEPairTrim *MutateDomainSSEPairTrim::Clone() const
    {
      return new MutateDomainSSEPairTrim( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateDomainSSEPairTrim::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &MutateDomainSSEPairTrim::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a domain
    //! @param DOMAIN domain which will be mutated
    //! @return MutateResult with the mutated domain
    math::MutateResult< assemble::Domain>
    MutateDomainSSEPairTrim::operator()( const assemble::Domain &THIS_DOMAIN) const
    {
      // static empty domain
      static util::ShPtr< assemble::Domain> s_empty_domain;

      // get the sses from this domain - these are ordered by sequence by the domain
      const util::SiPtrVector< const assemble::SSE> domain_sses( THIS_DOMAIN.GetSSEs());

      // true if there are not two sses in the domain
      if( domain_sses.GetSize() != 2)
      {
        return math::MutateResult< assemble::Domain>( s_empty_domain, *this);
      }

      // get the combination of trimming that gives the lowest ratio of euclidian distance to connecting residues
      storage::VectorND< 2, util::ShPtr< assemble::SSE> > best_trimmed_sses
      (
        GetBestTrimmedSSEs( *domain_sses.FirstElement(), *domain_sses.LastElement())
      );

      // true if either of the best sses are not defined
      if( !best_trimmed_sses.First().IsDefined() || !best_trimmed_sses.Second().IsDefined())
      {
        return math::MutateResult< assemble::Domain>( s_empty_domain, *this);
      }

      util::ShPtr< assemble::Domain> new_domain( THIS_DOMAIN.Clone());

      // remove the two old sses
      BCL_Assert
      (
        new_domain->Remove( *domain_sses.FirstElement()),
        "could not remove sse " + domain_sses.FirstElement()->GetIdentification()
      );
      BCL_Assert
      (
        new_domain->Remove( *domain_sses.LastElement()),
        "could not remove sse " + domain_sses.LastElement()->GetIdentification()
      );

      // insert both new sses
      BCL_Assert
      (
        new_domain->Insert( best_trimmed_sses.First()),
        "could not Insert sse " + best_trimmed_sses.First()->GetIdentification()
      );
      BCL_Assert
      (
        new_domain->Insert( best_trimmed_sses.Second()),
        "could not Insert sse " + best_trimmed_sses.Second()->GetIdentification()
      );

      return math::MutateResult< assemble::Domain>( new_domain, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateDomainSSEPairTrim::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_MinSSESizes, ISTREAM);
      io::Serialize::Read( m_NumberResiduesToTrim, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateDomainSSEPairTrim::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_MinSSESizes, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_NumberResiduesToTrim, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    storage::VectorND< 2, util::ShPtr< assemble::SSE> > MutateDomainSSEPairTrim::GetBestTrimmedSSEs
    (
      const assemble::SSE &SSE_N_TERMINAL, const assemble::SSE &SSE_C_TERMINAL
    ) const
    {
      // to hold the best combination of trimmed sses
      util::ShPtr< assemble::SSE> best_sse_a;
      util::ShPtr< assemble::SSE> best_sse_b;

      // to keep track of the smallest ratio of distance per residue observed
      double best_dist_per_resi( std::numeric_limits< double>::max());

      // iterate through the possible number of residues to trim
      for( size_t aa_removed_a( 0); aa_removed_a <= m_NumberResiduesToTrim; ++aa_removed_a)
      {
        // trim the number of residues off of first sse. c terminus of sse coming first in sequence will be changed
        util::ShPtr< assemble::SSE> trim_sse_n_terminal
        (
          TrimSSE( SSE_N_TERMINAL, biol::AASequenceFlexibility::e_CTerminal, aa_removed_a)
        );

        if( !trim_sse_n_terminal.IsDefined())
        {
          continue;
        }

        for
        (
          size_t aa_removed_b( 0); aa_removed_b <= ( m_NumberResiduesToTrim - aa_removed_a);
          ++aa_removed_b
        )
        {
          // trim number of residues off of second sse. n terminus of sse coming second in sequence will be changed
          util::ShPtr< assemble::SSE> trim_sse_c_terminal
          (
            TrimSSE( SSE_C_TERMINAL, biol::AASequenceFlexibility::e_NTerminal, aa_removed_b)
          );

          if( !trim_sse_c_terminal.IsDefined())
          {
            continue;
          }

          // get the ratio of euclidian distance to number of residues
          const double dist_per_resi( CalculateDistancePerResidue( *trim_sse_n_terminal, *trim_sse_c_terminal));

          BCL_MessageDbg( "trim_sse_n_terminal " + trim_sse_n_terminal->GetIdentification());
          BCL_MessageDbg( "trim_sse_c_terminal " + trim_sse_c_terminal->GetIdentification());
          BCL_MessageDbg( "dist_per_resi " + util::Format()( dist_per_resi));

          // true if this is the best combination seen so far
          if( dist_per_resi < best_dist_per_resi)
          {
            best_dist_per_resi = dist_per_resi;
            best_sse_a = trim_sse_n_terminal;
            best_sse_b = trim_sse_c_terminal;
          }
        }
      }

      const storage::VectorND< 2, util::ShPtr< assemble::SSE> > best_trimmed_sses( best_sse_a, best_sse_b);

      return best_trimmed_sses;
    }

    util::ShPtr< assemble::SSE> MutateDomainSSEPairTrim::TrimSSE
    (
      const assemble::SSE &SSE, const biol::AASequenceFlexibility::SequenceDirection &SEQUENCE_DIRECTION,
      const size_t NUM_RESI_TO_REMOVE
    ) const
    {
      // true if the trimmed sse will be too short according to the desired minimum sse sizes
      storage::Map< biol::SSType, size_t>::const_iterator type_size( m_MinSSESizes.Find( SSE.GetType()));
      BCL_Assert
      (
        type_size != m_MinSSESizes.End(), "could not find ss type " + SSE.GetType().GetName() + " in min sse sizes "
        + util::Format()( m_MinSSESizes)
      );

      if( int( SSE.GetSize()) - int( NUM_RESI_TO_REMOVE) < int( type_size->second))
      {
        return util::ShPtr< assemble::SSE>();
      }

      // index of starting subsequence for trimmed sse
      const size_t start_pos
      (
        SEQUENCE_DIRECTION == biol::AASequenceFlexibility::e_NTerminal ? NUM_RESI_TO_REMOVE : 0
      );

      // the length of the subsequence for the trimmed sse
      const size_t length( SSE.GetSize() - NUM_RESI_TO_REMOVE);

      // the sequence for the trimed sse
      const biol::AASequence sequence( SSE.SubSequence( start_pos, length));

      // the trimmed sse
      const util::ShPtr< assemble::SSE> new_sse( new assemble::SSE( sequence, SSE.GetType()));

      // return the new sse
      return new_sse;
    }

    double MutateDomainSSEPairTrim::CalculateDistancePerResidue
    (
      const assemble::SSE &SSE_N_TERMINAL, const assemble::SSE &SSE_C_TERMINAL
    ) const
    {
      // get c terminal residue of n terminal sse
      const biol::AABase &c_terminal_aa( *SSE_N_TERMINAL.GetLastAA());

      // get n terminal residue of c terminal sse
      const biol::AABase &n_terminal_aa( *SSE_C_TERMINAL.GetFirstAA());

      const double euclidian_distance( biol::GetPeptideBondLength( c_terminal_aa, n_terminal_aa));
      const size_t sequence_distance( biol::CalculateSequenceDistance( SSE_N_TERMINAL, SSE_C_TERMINAL));
      BCL_MessageDbg( "euclidian_distance " + util::Format()( euclidian_distance));
      BCL_MessageDbg( "sequence_distance " + util::Format()( sequence_distance));

      return euclidian_distance / sequence_distance;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_domain_sse_split.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateDomainSSESplit::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateDomainSSESplit())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateDomainSSESplit::MutateDomainSSESplit() :
      m_Scheme(),
      m_StandardDeviation(),
      m_RandomNumberGenerator( random::GetGlobalRandom())
    {
    }

    //! @brief default constructor
    //! @param SCHEME the scheme for this mutate
    //! @param STANDARD_DEVIATION standard deviation of gaussian distribution that biases splitting towards the middle
    //! @param RNG the random number generator that should be used
    MutateDomainSSESplit::MutateDomainSSESplit
    (
      const std::string &SCHEME, const double STANDARD_DEVIATION, const random::DistributionInterface &RNG
    ) :
      m_Scheme( SCHEME),
      m_StandardDeviation( STANDARD_DEVIATION),
      m_RandomNumberGenerator( RNG)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateDomainSSESplit
    MutateDomainSSESplit *MutateDomainSSESplit::Clone() const
    {
      return new MutateDomainSSESplit( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateDomainSSESplit::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &MutateDomainSSESplit::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a domain
    //! @param DOMAIN domain which will be mutated
    //! @return MutateResult with the mutated domain
    math::MutateResult< assemble::Domain>
    MutateDomainSSESplit::operator()( const assemble::Domain &THIS_DOMAIN) const
    {
      // static empty domain
      static util::ShPtr< assemble::Domain> s_empty_domain;

      // get the sses from this domain
      const util::SiPtrVector< const assemble::SSE> domain_sses( THIS_DOMAIN.GetSSEs());

      if( domain_sses.IsEmpty())
      {
        return math::MutateResult< assemble::Domain>( s_empty_domain, *this);
      }

      // make copy of the domain
      util::ShPtr< assemble::Domain> new_domain( THIS_DOMAIN.Clone());

      // iterate through the sses in order to split them
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          sse_itr( domain_sses.Begin()), sse_itr_end( domain_sses.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // the current sse that will be split
        const assemble::SSE &current_sse( **sse_itr);

        // split the current sse
        storage::VectorND< 2, util::ShPtr< assemble::SSE> > splitted_sses( SplitSSE( current_sse));

        // true if the sse could not be split
        if( !splitted_sses.First().IsDefined() || !splitted_sses.Second().IsDefined())
        {
          // go to next sse in the domain
          continue;
        }

        // remove the current sse from the domain
        BCL_Assert( new_domain->Remove( current_sse), "could not remove " + current_sse.GetIdentification());

        // insert the two new sses into the domain
        BCL_Assert
        (
          new_domain->Insert( splitted_sses.First()), "could not remove " + splitted_sses.First()->GetIdentification()
        );
        BCL_Assert
        (
          new_domain->Insert( splitted_sses.Second()),
          "could not remove " + splitted_sses.Second()->GetIdentification()
        );
      }

      return math::MutateResult< assemble::Domain>( new_domain, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateDomainSSESplit::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);
      io::Serialize::Read( m_StandardDeviation, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateDomainSSESplit::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_StandardDeviation, OSTREAM, INDENT) << "\n";

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief splits an sse at a random position determined by the random number generator
    //! @param CURRENT_SSE the sse which will be split
    //! @return vectorND 2 with 2 shared pointers to sses which were created from the split sse
    storage::VectorND< 2, util::ShPtr< assemble::SSE> >
    MutateDomainSSESplit::SplitSSE( const assemble::SSE &CURRENT_SSE) const
    {
      static const size_t min_split_size( 1);
      // the length of the sse
      const size_t sse_length( CURRENT_SSE.GetSize());

      // true if the sse length is not sufficient to split
      if( sse_length <= min_split_size)
      {
        BCL_MessageDbg
        (
          "cannot split an sse with less than " + util::Format()( min_split_size) +
          " residues " + CURRENT_SSE.GetIdentification()
        );

        return storage::VectorND< 2, util::ShPtr< assemble::SSE> >();
      }

      // get the seq id to split at
      size_t split_point( GetSplitPoint( sse_length));

      // true if the split point is outside the sequence range of the sse
      if( split_point < min_split_size)
      {
        split_point = min_split_size;
      }
      else if( split_point > sse_length - min_split_size)
      {
        split_point = sse_length - min_split_size;
      }

      // get the subsequences
      const biol::AASequence sequence_a( CURRENT_SSE.SubSequence( 0, split_point));
      const biol::AASequence sequence_b( CURRENT_SSE.SubSequence( split_point, sse_length - split_point));

      BCL_MessageDbg( "first  split part sequence is " +  sequence_a.GetSequenceIdentification());
      BCL_MessageDbg( "second split part sequence is " +  sequence_b.GetSequenceIdentification());

      // make the two new sses
      const util::ShPtr< assemble::SSE> new_sse_a( new assemble::SSE( sequence_a, CURRENT_SSE.GetType()));
      const util::ShPtr< assemble::SSE> new_sse_b( new assemble::SSE( sequence_b, CURRENT_SSE.GetType()));

      // will be returned
      const storage::VectorND< 2, util::ShPtr< assemble::SSE> > sses( new_sse_a, new_sse_b);

      // return the sses
      return sses;
    }

    size_t MutateDomainSSESplit::GetSplitPoint( const size_t SSE_LENGTH) const
    {
      // the middle of the sequence of this sse
      const double random( m_RandomNumberGenerator.Random( double( 0), double( 1)));

      BCL_MessageDbg( "random number for splitting is " + util::Format()( random));
      BCL_MessageDbg( "SSE_LENGTH for splitting is " + util::Format()( SSE_LENGTH));

      double sum( 0);

      // u
      const double mid_point( double( SSE_LENGTH) / 2.0);
      BCL_MessageDbg( "mid_point is " + util::Format()( mid_point));

      // s
      const double range( double( SSE_LENGTH) / 2.0);
      BCL_MessageDbg( "range is " + util::Format()( range));

      size_t cut_point( util::GetUndefinedDouble());

      for( size_t pos( 1); pos < SSE_LENGTH; ++pos)
      {
        const double current_probability
        (
          ( 1.0 / ( 2.0 * range)) * ( 1.0 + cos( ( ( pos - mid_point) / range) * math::g_Pi))
        );
        sum += current_probability;
        BCL_MessageDbg( "current_probability is " + util::Format()( current_probability));
        BCL_MessageDbg( "sum is " + util::Format()( sum));

        if( sum > random)
        {
          cut_point = pos;
          BCL_MessageDbg( "cut_point is " + util::Format()( cut_point));
          break;
        }
      }

      BCL_Assert( util::IsDefined( cut_point), "cut point is undefined");

      return cut_point;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_domain_transformation.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateDomainTransformation::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateDomainTransformation())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateDomainTransformation::MutateDomainTransformation() :
      m_Transformer()
    {
    }

    //! @brief constructor taking parameters
    //! @param TRANSFORMER method to transform the transformation matrix 3d of the domain
    MutateDomainTransformation::MutateDomainTransformation
    (
      const util::ShPtr< math::MutateInterface< math::TransformationMatrix3D> > &TRANSFORMER
    ) :
      m_Transformer( TRANSFORMER)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateDomainTransformation
    MutateDomainTransformation *MutateDomainTransformation::Clone() const
    {
      return new MutateDomainTransformation( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateDomainTransformation::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param MUTATE_DOMAIN the domain that is going to be mutated
    //! @return mutate result pointing to mutated domain
    math::MutateResult< assemble::Domain>
    MutateDomainTransformation::operator()( const assemble::Domain &MUTATE_DOMAIN) const
    {
      // get current orientation of the domain
      const math::TransformationMatrix3D current_orientation( MUTATE_DOMAIN.GetOrientation());

      // mutate the current orientation
      const math::MutateResult< math::TransformationMatrix3D> mutated_orientation
      (
        m_Transformer->operator()( current_orientation)
      );

      // make new domain copied from old domain
      util::ShPtr< assemble::Domain> new_domain( MUTATE_DOMAIN.Clone());

      // set the new domain to the the new orientation
      new_domain->Transform( *mutated_orientation.GetArgument());

      // make mutate result out of mutated domain
      const math::MutateResult< assemble::Domain> mutate_result( new_domain, *this);

      return mutate_result;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateDomainTransformation::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Transformer, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateDomainTransformation::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Transformer, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_loop_domain_dihedral.h"

// includes from bcl - sorted alphabetically
#include "fold/bcl_fold_loop_domain.h"
#include "fold/bcl_fold_mutation_residue.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_result.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateLoopDomainDihedral::s_Instance
    (
      util::Enumerated< math::MutateInterface< LoopDomain> >::AddInstance( new MutateLoopDomainDihedral())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateLoopDomainDihedral::MutateLoopDomainDihedral() :
      m_ResiduesToChangeCollector(),
      m_DihedralGenerator()
    {
    }

    //! @brief constructor taking parameters
    //! @param RESIDUES_TO_CHANGE_COLLECTOR the method for collecting residues to change their dihedral angles
    //! @param DIHEDRAL_GENERATOR the method that determines what the dihedral angles should be set to
    MutateLoopDomainDihedral::MutateLoopDomainDihedral
    (
      const util::ShPtr
      <
        find::CollectorInterface< storage::List< MutationResidue>, LoopDomain>
      > &RESIDUES_TO_CHANGE_COLLECTOR,
      const util::ShPtr
      <
        math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> >
      > &DIHEDRAL_GENERATOR
    ) :
      m_ResiduesToChangeCollector( *RESIDUES_TO_CHANGE_COLLECTOR),
      m_DihedralGenerator( *DIHEDRAL_GENERATOR)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateLoopDomainDihedral
    MutateLoopDomainDihedral *MutateLoopDomainDihedral::Clone() const
    {
      return new MutateLoopDomainDihedral( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateLoopDomainDihedral::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateLoopDomainDihedral::GetAlias() const
    {
      static const std::string s_name( "MutateLoopDomainDihedral");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateLoopDomainDihedral::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Changes the dihedral angles of a loop domain in a protein model.");
      serializer.AddInitializer
      (
        "collector",
        "method of collecting a loop domain in a protein model",
        io::Serialization::GetAgent( &m_ResiduesToChangeCollector)
      );
      serializer.AddInitializer
      (
        "generator",
        "method to determine the new dihedral angles",
        io::Serialization::GetAgent( &m_DihedralGenerator)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param LOOP_DOMAIN Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< LoopDomain> MutateLoopDomainDihedral::operator()( const LoopDomain &LOOP_DOMAIN) const
    {
      // make a clone copy into a ShPtr of "LOOP_DOMAIN" which will be mutated
      util::ShPtr< LoopDomain> new_loop_domain( LOOP_DOMAIN.Clone());

      // collet all of the residues that will be mutated in "new_loop_domain"
      storage::List< MutationResidue> aas_to_change( m_ResiduesToChangeCollector->Collect( *new_loop_domain));

      // iterate through the list of residues to mutate and mutate them
      for
      (
        storage::List< MutationResidue>::iterator
          aa_to_change_itr( aas_to_change.Begin()), aa_to_change_itr_end( aas_to_change.End());
        aa_to_change_itr != aa_to_change_itr_end;
        ++aa_to_change_itr
      )
      {
        // get a set of phi and psi angles which will be given to the residue currently denoted by "aa_to_change_itr"
        const storage::VectorND< 2, double> phi_psi( m_DihedralGenerator->operator()( *aa_to_change_itr));

        // make sure the mutation residue is defined
        BCL_Assert( aa_to_change_itr->GetMutationResidue().IsDefined(), "mutation residue is not defined");

        // true if phi is defined
        if( util::IsDefined( phi_psi.First()))
        {
          BCL_MessageDbg
          (
            "setting phi of resi " + aa_to_change_itr->GetMutationResidue()->GetIdentification()
            + " to " + util::Format()( phi_psi.First())
          );
          new_loop_domain->SetPhi( *aa_to_change_itr->GetMutationResidue(), phi_psi.First());
        }
        // true if psi is defined
        if( util::IsDefined( phi_psi.Second()))
        {
          BCL_MessageDbg
          (
            "setting psi of resi " + aa_to_change_itr->GetMutationResidue()->GetIdentification()
            + " to " + util::Format()( phi_psi.Second())
          );
          new_loop_domain->SetPsi( *aa_to_change_itr->GetMutationResidue(), phi_psi.Second());
        }
      } //< loop through mutation residues

      // iterate through the domain and set the geometry of the non rigid sses
      for
      (
        storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator
          segment_itr( new_loop_domain->GetSegments().Begin()), segment_itr_end( new_loop_domain->GetSegments().End());
        segment_itr != segment_itr_end;
        ++segment_itr
      )
      {
        // if not rigid need to set geometry
        if( !segment_itr->IsRigid())
        {
          // set geometry
          util::ShPtr< assemble::SSE> new_sse( segment_itr->GetSSE()->Clone());
          new_sse->SetGeometry();
          std::pair< storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator, bool> replace_status
          (
            new_loop_domain->ReplaceSegment( LoopSegment( new_sse, segment_itr->IsRigid()))
          );
          segment_itr = replace_status.first;
        }
      }

      // create mutate result "mutate_result" out of "new_loop_domain"
      math::MutateResult< LoopDomain> mutate_result( new_loop_domain, *this);

      // return "mutate_result"
      return mutate_result;
    }

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_membrane_chain_move.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_chain.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_atom.h"
#include "biol/bcl_biol_membrane.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_interface.h"
#include "math/bcl_math_mutate_result.h"
#include "math/bcl_math_transformation_matrix_3d.h"
#include "util/bcl_util_enumerated.h"

// include other forward headers - sorted alphabetically

namespace bcl
{
  namespace fold
  {

    //! single instance of this class
    const util::SiPtr< util::ObjectInterface> MutateMembraneChainMove::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateMembraneChainMove())
    );

    //! @brief default constructor
    MutateMembraneChainMove::MutateMembraneChainMove() :
      m_ReceptorChainIDs(),
      m_LigandChainIDs(),
      m_MaxTranslationX( 1.0),
      m_MaxTranslationY( 1.0),
      m_MaxTranslationZ( 1.0),
      m_MaxPhi( 1.0),
      m_MaxTheta( 1.0),
      m_MaxPsi( 1.0)
    {
    }

    //! @brief explicit constructor from given arguments
    //! @param RECEPTOR_CHAIN_IDS chain IDs of the receptor
    //! @param LIGAND_CHAIN_IDS chain IDs of the ligand
    //! @param MAX_TRANSLATION_X maximally allowed single-step translation along the x axis
    //! @param MAX_TRANSLATION_Y maximally allowed single-step translation along the y axis
    //! @param MAX_TRANSLATION_Z maximally allowed single-step translation along the y axis
    //! @param MAX_PHI maximally allowed single-step phi rotation angle
    //! @param MAX_THETA maximally allowed single-step theta rotation angle
    //! @param MAX_PSI maximally allowed single-step psi rotation angle
    MutateMembraneChainMove::MutateMembraneChainMove
    (
      const std::string &RECEPTOR_CHAIN_IDS,
      const std::string &LIGAND_CHAIN_IDS,
      double MAX_TRANSLATION_X,
      double MAX_TRANSLATION_Y,
      double MAX_TRANSLATION_Z,
      double MAX_PHI,
      double MAX_THETA,
      double MAX_PSI
    ) :
      m_ReceptorChainIDs( RECEPTOR_CHAIN_IDS),
      m_LigandChainIDs( LIGAND_CHAIN_IDS),
      m_MaxTranslationX( MAX_TRANSLATION_X),
      m_MaxTranslationY( MAX_TRANSLATION_Y),
      m_MaxTranslationZ( MAX_TRANSLATION_Z),
      m_MaxPhi( MAX_PHI),
      m_MaxTheta( MAX_THETA),
      m_MaxPsi( MAX_PSI)
    {
    }

    //! @brief Clone function
    //! @return a pointer to a copy of this object
    MutateMembraneChainMove *MutateMembraneChainMove::Clone() const
    {
      return new MutateMembraneChainMove( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief get the name of this class
    //! @return the name of this class
    const std::string &MutateMembraneChainMove::GetClassIdentifier() const
    {
      return GetStaticClassName( this);
    }

    //! @brief get the chain IDs of the receptor
    //! @return the chain IDs of the receptor
    const std::string &MutateMembraneChainMove::GetReceptorChainIDs() const
    {
      return m_ReceptorChainIDs;
    }

    //! @brief get the chain IDs of the ligand
    //! @return the chain IDs of the ligand
    const std::string &MutateMembraneChainMove::GetLigandChainIDs() const
    {
      return m_LigandChainIDs;
    }

    //! @brief get the maximum translation along the x axis
    //! @return maximum translation along the x axis
    double MutateMembraneChainMove::GetMaxTranslationX() const
    {
      return m_MaxTranslationX;
    }

    //! @brief get the maximum translation along the y axis
    //! @return maximum translation along the y axis
    double MutateMembraneChainMove::GetMaxTranslationY() const
    {
      return m_MaxTranslationY;
    }

    //! @brief get the maximum translation along the z axis
    //! @return maximum translation along the z axis
    double MutateMembraneChainMove::GetMaxTranslationZ() const
    {
      return m_MaxTranslationZ;
    }

    //! @brief get the maximum of the phi Euler angle
    //! @return maximum of the phi Euler angle
    double MutateMembraneChainMove::GetMaxPhi() const
    {
      return m_MaxPhi;
    }

    //! @brief get the maximum of the theta Euler angle
    //! @return maximum of the theta Euler angle
    double MutateMembraneChainMove::GetMaxTheta() const
    {
      return m_MaxTheta;
    }

    //! @brief get the maximum of the psi Euler angle
    //! @return maximum of the psi Euler angle
    double MutateMembraneChainMove::GetMaxPsi() const
    {
      return m_MaxPsi;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateMembraneChainMove::GetAlias() const
    {
      static const std::string s_alias( "MutateMembraneChainMove");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateMembraneChainMove::GetSerializer() const
    {
      io::Serializer serializer;

      // add initializers
      serializer.AddInitializer
      (
        "receptor chain ids",
        "chain IDs for the receptor",
        io::Serialization::GetAgent( &m_ReceptorChainIDs)
      );
      serializer.AddInitializer
      (
        "ligand chain ids",
        "chain IDs for the ligand",
        io::Serialization::GetAgent( &m_LigandChainIDs)
      );
      serializer.AddInitializer
      (
        "max translation x",
        "maximum angstroms of translation along the x axis",
        io::Serialization::GetAgent( &m_MaxTranslationX),
        "1.0"
      );
      serializer.AddInitializer
      (
        "max translation y",
        "maximum angstroms of translation along the y axis",
        io::Serialization::GetAgent( &m_MaxTranslationY),
        "1.0"
      );
      serializer.AddInitializer
      (
        "max translation z",
        "maximum angstroms of translation along the z axis",
        io::Serialization::GetAgent( &m_MaxTranslationZ),
        "1.0"
      );
      serializer.AddInitializer
      (
        "max phi",
        "maximum randians of the phi Euler angle",
        io::Serialization::GetAgent( &m_MaxPhi),
        "1.0"
      );
      serializer.AddInitializer
      (
        "max theta",
        "maximum randians of the theta Euler angle",
        io::Serialization::GetAgent( &m_MaxTheta),
        "1.0"
      );
      serializer.AddInitializer
      (
        "max psi",
        "maximum randians of the psi Euler angle",
        io::Serialization::GetAgent( &m_MaxPsi),
        "1.0"
      );

      // return the serializer
      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @param LIGAND
    //! @return
    math::MutateResult< assemble::ProteinModel>
      MutateMembraneChainMove::operator()( const assemble::ProteinModel &MODEL) const
    {
      // make sure that receptor chain IDs and ligand chain IDs are set
      if( m_LigandChainIDs.empty() || m_ReceptorChainIDs.empty())
      {
        SetReceptorLigandChainIDs( MODEL);
      }

      // create a copy of the ligand
      const assemble::ProteinModel ligand
      (
        MODEL.GetChains( m_LigandChainIDs)
      );

      // get receptor
      const assemble::ProteinModel receptor
      (
        MODEL.GetChains( m_ReceptorChainIDs)
      );

      // try to get the membrane
      util::ShPtr< assemble::ProteinModelData> sp_data( MODEL.GetProteinModelData());
      util::ShPtr< biol::Membrane> sp_membrane( sp_data->GetData( assemble::ProteinModelData::e_Membrane));

      // make sure that the membrane is defined
      if( !sp_membrane.IsDefined())
      {
        BCL_MessageCrt( "No defined membrane is found!");
        return math::MutateResult< assemble::ProteinModel>( util::ShPtr< assemble::ProteinModel>(), *this);
      }

      //
      double global_rotation_angle
      (
        random::GetGlobalRandom().Double( math::Range< double>( -math::g_Pi, math::g_Pi))
      );

      // random rotaion around z axis
      math::RotationMatrix3D rotaion_z( linal::Vector3D( 0.0, 0.0, 1.0), global_rotation_angle);

      // random translations
      double translation_x
      (
        random::GetGlobalRandom().Double( math::Range< double>( -m_MaxTranslationX, m_MaxTranslationX))
      );
      double translation_y
      (
        random::GetGlobalRandom().Double( math::Range< double>( -m_MaxTranslationY, m_MaxTranslationY))
      );
      double translation_z
      (
        random::GetGlobalRandom().Double( math::Range< double>( -m_MaxTranslationZ, m_MaxTranslationZ))
      );
      linal::Vector3D translation( translation_x, translation_y, translation_z);

      // transformation matrix
      math::TransformationMatrix3D transformation3d( rotaion_z);
      transformation3d.SetTranslation( translation);

      // do global transformation on the ligand
      // perform deep copy of ligand without affecting other objects that might have pointer to this ligand
      util::ShPtr< assemble::ProteinModel> sp_ligand_hard_copy( ligand.HardCopy());
      sp_ligand_hard_copy->Transform( transformation3d);

      linal::Vector3D ligand_center( sp_ligand_hard_copy->GetCenter());
      sp_ligand_hard_copy->Translate( -ligand_center);

      // local random rotations
      double phi
      (
        random::GetGlobalRandom().Double( math::Range< double>( -m_MaxPhi, m_MaxPhi))
      );
      double theta
      (
        random::GetGlobalRandom().Double( math::Range< double>( -m_MaxTheta, m_MaxTheta))
      );
      double psi
      (
        random::GetGlobalRandom().Double( math::Range< double>( -m_MaxPsi, m_MaxPsi))
      );
      math::RotationMatrix3D rotation3D( phi, theta, psi);

      // transformation matrix
      transformation3d.SetUnit();
      transformation3d.SetRotation( rotation3D);

      // transform the ligand
      sp_ligand_hard_copy->Transform( transformation3d);
      sp_ligand_hard_copy->Translate( ligand_center);

      // create a docked model
      util::ShPtrVector< assemble::Chain> all_chains( receptor.GetChains());
      all_chains.Append( sp_ligand_hard_copy->GetChains());
      util::ShPtr< assemble::ProteinModel> sp_docked_model( new assemble::ProteinModel( all_chains));
      sp_docked_model->SetProteinModelData( sp_data);

      // return the ligand
      return math::MutateResult< assemble::ProteinModel>( sp_docked_model, *this);

    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief set the chain IDs for the ligand
    void MutateMembraneChainMove::SetReceptorLigandChainIDs( const assemble::ProteinModel &MODEL) const
    {
      // ligand chain IDs
      std::string ligand_chain_ids;

      // get all chains of this protein model
      util::ShPtrVector< assemble::Chain> all_chains( MODEL.GetChains());

      // number of amino acids in the entire model
      size_t min_chain_size( MODEL.GetNumberAAs());

      // determine the movable chain, which is the smallest chain
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          itr( all_chains.Begin()), itr_end( all_chains.End());
        itr != itr_end;
        ++itr
      )
      {
        // number of amino acids in current chain
        size_t current_chain_size( ( *itr)->GetNumberAAs());
        if( current_chain_size < min_chain_size)
        {
          min_chain_size = current_chain_size;
          ligand_chain_ids = ( *itr)->GetChainID();
        }
      }

      // set ligand chain IDs
      m_LigandChainIDs = ligand_chain_ids;

      // get all chain IDs
      std::string all_chain_ids( MODEL.GetChainIDs());

      // remove ligand chain IDs from all chain IDs
      for
      (
        std::string::const_iterator itr( ligand_chain_ids.begin()), itr_end( ligand_chain_ids.end());
          itr != itr_end;
        ++itr
      )
      {
        all_chain_ids.erase
        (
          std::remove( all_chain_ids.begin(), all_chain_ids.end(), *itr),
          all_chain_ids.end()
        );
      }

      // set receptor chain IDs
      m_ReceptorChainIDs = all_chain_ids;
    }

  } // namespace fold
} // namespace bcl

// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_membrane.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_membrane.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateMembrane::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateMembrane())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateMembrane::MutateMembrane() :
      m_Move(),
      m_Scheme( GetStaticClassName< MutateMembrane>())
    {
    }

    //! @brief constructor from a Move and a scheme
    //! @param MOVE function that performs the move on the membrane
    //! @param SCHEME scheme to be used
    MutateMembrane::MutateMembrane
    (
      const coord::MoveInterface &MOVE,
      const std::string &SCHEME
    ) :
      m_Move( MOVE.Clone()),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateMembrane
    MutateMembrane *MutateMembrane::Clone() const
    {
      return new MutateMembrane( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateMembrane::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief performs the mutate on the membrane associated with the passed protein model
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateMembrane::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // skip if move not defined
      if( !m_Move.IsDefined())
      {
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // hard copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.HardCopy());

      // try to get the membrane
      util::ShPtr< assemble::ProteinModelData> sp_data( PROTEIN_MODEL.GetProteinModelData().HardCopy());
      util::ShPtr< biol::Membrane> sp_membrane( sp_data->GetData( assemble::ProteinModelData::e_Membrane).HardCopy());

      // skip if no membrane found
      if( !sp_membrane.IsDefined() || !sp_membrane->IsDefined())
      {
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // apply the move
      m_Move->Move( *sp_membrane);

      // set the membrane data
      sp_data->Replace( assemble::ProteinModelData::e_Membrane, sp_membrane);
      new_model->SetProteinModelData( sp_data);

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateMembrane::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Move, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateMembrane::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Move, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_multimer.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_protein_model_multiplier.h"
#include "coord/bcl_coord_move_translate_random.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateMultimer::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateMultimer())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from members
    //! @param IS_DIHEDRAL is dihedral symmetry
    //! @param SCHEME scheme for the mutate
    MutateMultimer::MutateMultimer( const bool IS_DIHEDRAL, const std::string &SCHEME) :
      m_IsDihedral( IS_DIHEDRAL),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateMultimer
    MutateMultimer *MutateMultimer::Clone() const
    {
      return new MutateMultimer( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateMultimer::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateMultimer::GetAlias() const
    {
      static const std::string s_name( "MutateMultimer");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateMultimer::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription
      (
        "Translates the protomer towards or away from the symmetry axis to change to multimer."
      );
      serializer.AddInitializer
      (
        "is dihedral",
        "whether symmetry is dihedral",
        io::Serialization::GetAgent( &m_IsDihedral)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief performs the mutate on the multiplier associated with the passed protein model
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateMultimer::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // get the multiplier
      util::ShPtr< assemble::ProteinModelData> sp_data( PROTEIN_MODEL.GetProteinModelData().HardCopy());
      util::ShPtr< assemble::ProteinModelMultiplier> sp_multiplier
      (
        sp_data->GetData( assemble::ProteinModelData::e_Multiplier).HardCopy()
      );

      // return if no multiplier
      if( !sp_multiplier.IsDefined())
      {
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // hard copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.HardCopy());

      // dihedral symmetry
      if( m_IsDihedral)
      {
        // translate in a random direction
        coord::MoveTranslateRandom random_translate( 0.0, 5.0, false);
        random_translate.Move( *new_model);
      }
      // cyclic symmetry
      else
      {
        // get the protein center
        const linal::Vector3D protein_center( PROTEIN_MODEL.GetCenter());

        // calculate footpoint on the axis
        const linal::Vector3D footpoint
        (
          linal::CalculateFootpoint
          (
            protein_center,
            sp_multiplier->GetCenter(),
            sp_multiplier->GetAxis( coord::GetAxes().e_Z)
          )
        );

        // get the vector from the footpoint to the protein
        const linal::Vector3D vector( footpoint - protein_center);

        // get a random number between -0.5 and 0.5
        const double distance_modifier( random::GetGlobalRandom().Double( math::Range< double>( -0.5, 0.5)));

        // apply a random translation toward or away from the axis
        new_model->Translate( distance_modifier * vector);
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_ensemble_add.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinEnsembleAdd::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinEnsembleAdd())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinEnsembleAdd::MutateProteinEnsembleAdd() :
      m_ProteinPool()
    {
    }

    //! @brief constructor taking a pool of all possible protein models that could be swapped
    //! @param PROTEIN_POOL a pool of all possible protein models that could be swapped
    MutateProteinEnsembleAdd::MutateProteinEnsembleAdd
    (
      const util::ShPtr< assemble::ProteinEnsemble> &PROTEIN_POOL
    ) :
      m_ProteinPool( PROTEIN_POOL)
    {
      // sort the ensemble
      m_ProteinPool->Sort( std::less< util::ShPtr< assemble::ProteinModel> >());
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinEnsembleSwap
    MutateProteinEnsembleAdd *MutateProteinEnsembleAdd::Clone() const
    {
      return new MutateProteinEnsembleAdd( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinEnsembleAdd::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_ENSEMBLE ensemble of proteins to be mutated
    //! @return MutateResult with ProteinEnsemble after the mutate
    math::MutateResult< assemble::ProteinEnsemble>
    MutateProteinEnsembleAdd::operator()( const assemble::ProteinEnsemble &PROTEIN_ENSEMBLE) const
    {
      // returned if the mutate cannot occur
      static util::ShPtr< assemble::ProteinEnsemble> s_empty;

      // true if pool is undefined
      if( !m_ProteinPool.IsDefined())
      {
        return math::MutateResult< assemble::ProteinEnsemble>( s_empty, *this);
      }

      // true if the pool is empty
      if( m_ProteinPool->IsEmpty())
      {
        return math::MutateResult< assemble::ProteinEnsemble>( s_empty, *this);
      }

      // make a new copy of the current ensemble
      util::ShPtr< assemble::ProteinEnsemble> new_ensemble( PROTEIN_ENSEMBLE.Clone());

      // true if there are no models currently in the ensemble
      if( PROTEIN_ENSEMBLE.IsEmpty())
      {
        // can just add random model from m_ProteinPool
        new_ensemble->InsertElement
        (
          *random::GetGlobalRandom().Iterator( m_ProteinPool->Begin(), m_ProteinPool->End(), m_ProteinPool->GetSize())
        );

        // return the mutated ensemble
        return math::MutateResult< assemble::ProteinEnsemble>( new_ensemble, *this);
      }

      // holds the models that are in the pool but not in "PROTEIN_ENSEMBLE"
      assemble::ProteinEnsemble swappable_models
      (
        m_ProteinPool->Difference
        (
          *new_ensemble, std::less< util::ShPtr< assemble::ProteinModel> >()
        )
      );

      // true if the there are no models eligible to be swapped (maybe PROTEIN_ENSEMBLE already contains all models)
      if( swappable_models.IsEmpty())
      {
        BCL_MessageDbg( "no models to swap");
        return math::MutateResult< assemble::ProteinEnsemble>( s_empty, *this);
      }

      // add a random model from the pool of swappable models into the new ensemble
      new_ensemble->InsertElement
      (
        *random::GetGlobalRandom().Iterator( swappable_models.Begin(), swappable_models.End(), swappable_models.GetSize())
      );

      // return the mutated ensemble
      return math::MutateResult< assemble::ProteinEnsemble>( new_ensemble, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinEnsembleAdd::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ProteinPool, ISTREAM);

      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinEnsembleAdd::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ProteinPool, OSTREAM, INDENT);

      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_ensemble_remove.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinEnsembleRemove::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinEnsembleRemove())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinEnsembleRemove::MutateProteinEnsembleRemove()
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinEnsembleRemove
    MutateProteinEnsembleRemove *MutateProteinEnsembleRemove::Clone() const
    {
      return new MutateProteinEnsembleRemove( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinEnsembleRemove::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_ENSEMBLE ensemble of proteins to be mutated
    //! @return MutateResult with ProteinEnsemble after the mutate
    math::MutateResult< assemble::ProteinEnsemble>
    MutateProteinEnsembleRemove::operator()( const assemble::ProteinEnsemble &PROTEIN_ENSEMBLE) const
    {
      // returned if the mutate cannot occur
      static util::ShPtr< assemble::ProteinEnsemble> s_empty;

      // true if the protein ensemble has size 0 or 1, should not remove anything
      if( PROTEIN_ENSEMBLE.GetSize() < 2)
      {
        return math::MutateResult< assemble::ProteinEnsemble>( s_empty, *this);
      }

      // make a new copy of the current ensemble
      util::ShPtr< assemble::ProteinEnsemble> new_ensemble( PROTEIN_ENSEMBLE.Clone());

      // remove a random model from the current ensemble
      new_ensemble->RemoveElement
      (
        random::GetGlobalRandom().Iterator( new_ensemble->Begin(), new_ensemble->End(), new_ensemble->GetSize())
      );

      // return mutate result with new ensemble
      return math::MutateResult< assemble::ProteinEnsemble>( new_ensemble, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinEnsembleRemove::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinEnsembleRemove::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_add_sheet_from_template.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_pick_sses_random.h"
#include "assemble/bcl_assemble_sheet_template_handler.h"
#include "assemble/bcl_assemble_sse_pool.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelAddSheetFromTemplate::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelAddSheetFromTemplate())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from placer
    //! @param PLACER object used to place the sheet in the protein model
    MutateProteinModelAddSheetFromTemplate::MutateProteinModelAddSheetFromTemplate
    (
      const PlacementInterface< assemble::Domain, assemble::ProteinModel> &PLACER
    ) :
      m_Placer( util::CloneToShPtr( PLACER))
    {
    }

    //! @brief returns a pointer to a new MutateProteinModelAddSheetFromTemplate
    //! @return pointer to a new MutateProteinModelAddSheetFromTemplate
    MutateProteinModelAddSheetFromTemplate *MutateProteinModelAddSheetFromTemplate::Clone() const
    {
      return new MutateProteinModelAddSheetFromTemplate( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &MutateProteinModelAddSheetFromTemplate::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &MutateProteinModelAddSheetFromTemplate::GetScheme() const
    {
      static const std::string s_scheme( "add_sheet_from_template");
      return s_scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief adds a sheet to the given protein model and returns the mutated model
    //! @detail a random number of strands is selected from the SSE pool of the given model and fitted to a sheet
    //! template in the library before being added to the given protein model
    //! @param MODEL protein model to add the sheet to
    //! @return the mutated protein model with additional information regarding the mutation
    math::MutateResult< assemble::ProteinModel> MutateProteinModelAddSheetFromTemplate::operator()
    (
      const assemble::ProteinModel &MODEL
    ) const
    {
      // undefined protein model which will be returned if application of the mutate fails
      util::ShPtr< assemble::ProteinModel> sp_result_model;

      // get the strands from the SSE pool which are not overlapping with SSEs in the protein model
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      util::SiPtrList< const assemble::SSE> non_overlapping_strands
      (
        sp_pool->GetNonOverlappingSSEs( MODEL, biol::GetSSTypes().STRAND)
      );

      //! a sheet can only be formed if there are at least two strands available for insertion
      const size_t number_strands( non_overlapping_strands.GetSize());
      if( number_strands < 2)
      {
        return math::MutateResult< assemble::ProteinModel>( sp_result_model, *this);
      }

      // randomly choose how many strands from the pool to form the sheet from and pick them from the list
      const size_t num_strands_to_pick( random::GetGlobalRandom().Random< size_t>( 2, number_strands));
      const storage::Set< biol::SSType> sse_types_to_pick( biol::GetSSTypes().STRAND);
      const util::SiPtrList< const assemble::SSE> picked_strands
      (
        assemble::PickSSEsRandom( sse_types_to_pick, num_strands_to_pick).Pick( non_overlapping_strands)
      );

      // pick a random template from the library that has a proper number of strands of the right sequence length
      util::SiPtrVector< const assemble::SSE> targets;
      for
      (
        util::SiPtrList< const assemble::SSE>::const_iterator it( picked_strands.Begin()), it_end( picked_strands.End());
        it != it_end;
        ++it
      )
      {
        targets.PushBack( *it);
      }
      const assemble::FoldTemplate &fold_template( assemble::SheetTemplateHandler::GetRandomTemplate( targets));

      // application of the mutate failed if no adequate template could be found
      if( fold_template.GetGeometries().IsEmpty())
      {
        return math::MutateResult< assemble::ProteinModel>( sp_result_model, *this);
      }

      // fit the selected strands to the template and compute where to place the sheet in the model
      util::ShPtr< assemble::Domain> sp_new_sheet( fold_template.FitSSEs( targets).Clone());
      const storage::Pair< math::TransformationMatrix3D, bool> placement( m_Placer->Place( *sp_new_sheet, MODEL));
      const math::TransformationMatrix3D &trans_matrix( placement.First());
      sp_new_sheet->Transform( trans_matrix);
      const util::SiPtrVector< const assemble::SSE> sses_to_insert( sp_new_sheet->GetSSEs());

      // add the sheet to the model
      sp_result_model = util::ShPtr< assemble::ProteinModel>( MODEL.Clone());
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator it( sses_to_insert.Begin()), it_end( sses_to_insert.End());
        it != it_end;
        ++it
       )
      {
        sp_result_model->Insert( util::CloneToShPtr( **it));
      }

      return math::MutateResult< assemble::ProteinModel>( sp_result_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read object from input stream
    //! @param ISTREAM input stream to read object from
    //! @return input stream which was read from
    std::istream &MutateProteinModelAddSheetFromTemplate::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write object into  output stream
    //! @param OSTREAM output stream to write object into
    //! @param INDENT number of indentations to separate members
    //! @return output stream object was written into
    std::ostream &MutateProteinModelAddSheetFromTemplate::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_chain_move.h"
// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_atom.h"
#include "biol/bcl_biol_membrane.h"
#include "math/bcl_math_mutate_interface.h"
#include "math/bcl_math_mutate_result.h"
#include "math/bcl_math_transformation_matrix_3d.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_sh_ptr.h"
#include "util/bcl_util_si_ptr_vector.h"

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< util::ObjectInterface> MutateProteinModelChainMove::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelChainMove())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelChainMove::MutateProteinModelChainMove() :
      m_MaxTranslationXY( 5.0),
      m_MaxTranslationZ( 5.0),
      m_MaxRotationAngle( 0.0),
      m_MaxInternalRotationAngle( 0.0)
    {
      // nothing else to do
    }

    //!
    //!
    //! @param MAX_TRANSLATION_XY
    //! @param MAX_TRANSLATION_Z
    //! @param MAX_ROTATION_ANGLE
    //!
    MutateProteinModelChainMove::MutateProteinModelChainMove
    (
      const double MAX_TRANSLATION_XY,
      const double MAX_TRANSLATION_Z,
      const double MAX_ROTATION_ANGLE,
      const double MAX_INTERNAL_ROTATION_ANGLE
    ) :
      m_MaxTranslationXY( MAX_TRANSLATION_XY),
      m_MaxTranslationZ( MAX_TRANSLATION_Z),
      m_MaxRotationAngle( MAX_ROTATION_ANGLE),
      m_MaxInternalRotationAngle( MAX_INTERNAL_ROTATION_ANGLE)
    {
      // nothing else to do
    }

    //!
    //! @brief Clone function
    //! @return a pointer to a copy of this object
    //!
    MutateProteinModelChainMove *MutateProteinModelChainMove::Clone() const
    {
      return new MutateProteinModelChainMove( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //!
    //! @brief Get the name of this class
    //! @return the name of this class
    //!
    const std::string &MutateProteinModelChainMove::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateProteinModelChainMove::GetAlias() const
    {
      static const std::string s_name( "MutateProteinModelChainMove");
      return s_name;
    }

    //!
    //!
    //! @return
    //!
    io::Serializer MutateProteinModelChainMove::GetSerializer() const
    {
      io::Serializer serializer;

      serializer.AddInitializer
      (
        "max translation xy",
        "allowed maximum translation in x, y direction for each step of mutate",
        io::Serialization::GetAgent( &m_MaxTranslationXY)
      );

      serializer.AddInitializer
      (
        "max translation z",
        "allowed maximum translation in z direction for each step of mutate",
        io::Serialization::GetAgent( &m_MaxTranslationZ)
      );

      serializer.AddInitializer
      (
        "max rotation angle",
        "allowed maximum rotation angle for each step of mutate",
        io::Serialization::GetAgent( &m_MaxRotationAngle)
      );

      serializer.AddInitializer
      (
        "max internal rotation angle",
        "allowed maximum angle for internal rotation of the ligand",
        io::Serialization::GetAgent( &m_MaxInternalRotationAngle)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //!
    //!
    //! @param PROTEIN_MODEL
    //! @return
    //!
    char MutateProteinModelChainMove::GetLigandChainID( const assemble::ProteinModel &COMPLEX)
    {
      // char that holds the ID of the movable chain
      char movable_chain_id( COMPLEX.GetChainIDs()[ 0]);

      // get all chains of this protein model
      util::ShPtrVector< assemble::Chain> all_chains( COMPLEX.GetChains());

      // determine the movable chain, which is the smallest chain
      size_t min_chain_size( COMPLEX.GetNumberAAs());
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          itr( all_chains.Begin()), itr_end( all_chains.End());
        itr != itr_end;
        ++itr
      )
      {
        size_t current_chain_size( ( *itr)->GetNumberAAs());
        if( current_chain_size < min_chain_size)
        {
          min_chain_size = current_chain_size;
          movable_chain_id = ( *itr)->GetChainID();
        }
      }

      // return the ID of the movable chain
      return movable_chain_id;
    }

    //!
    //! @brief Generate placement for the given Chain at a random orientation with respect to a located Chain in the model
    //! @param MOVABLE_CHAIN chain to be moved
    //! @param PROTEIN_MODEL the given protein model to which the chain is to be added
    //! @return
    //!
    storage::Pair< math::TransformationMatrix3D, bool> MutateProteinModelChainMove::PlaceLigand
    (
      const assemble::Chain &LIGAND,
      const assemble::ProteinModel &COMPLEX
    ) const
    {

      // vector for holding fixed chains
      util::ShPtrVector< assemble::Chain> receptor_chains;

      // add fixed chains
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          itr( COMPLEX.GetChains().Begin()), itr_end( COMPLEX.GetChains().End());
        itr != itr_end;
        ++itr
      )
      {
        if( ( *itr)->GetChainID() != LIGAND.GetChainID())
        {
          receptor_chains.PushBack( *itr);
        }
      }

      //
      util::ShPtr< assemble::ProteinModel> receptor( new assemble::ProteinModel( receptor_chains));

      //! @TODO
      BCL_Debug( receptor->GetCenterOfMass());

      //
//        math::TransformationMatrix3D transformation
//        (
//          coord::OrientationInterface::GenerateRandomTransformationAroundCenter
//          (
//            m_MaxTranslationXY,
//            m_MaxRotationAngle,
//            receptor->GetCenterOfMass()
//          )
//        );

      math::RotationMatrix3D rotation
      (
        math::RotationMatrix3D().SetRand( m_MaxRotationAngle)
      );

      math::TransformationMatrix3D transformation( rotation);

      BCL_Debug( transformation);

      //
      double translation_xy( static_cast< double>( std::rand()) / static_cast< double>( RAND_MAX) * m_MaxTranslationXY);

      linal::Vector3D translation( translation_xy, translation_xy, 0.0);
      transformation.SetTranslation( translation);

      BCL_Debug( transformation);

      //

      //
      // transformation( math::RotationMatrix3D().SetRand( m_MaxRotationAngle));
      // transformation( linal::Vector3D().SetRandomTranslation( linal::Vector3D( m_MaxTranslationXY, m_MaxTranslationXY, m_MaxTranslationZ)));

      //
      // transformation( sp_fixed_part->GetOrientation());

      //
      return storage::Pair< math::TransformationMatrix3D, bool>( transformation, true);
    }

    //! @brief
    //! @param COMPLEX
    void MutateProteinModelChainMove::PreDock( assemble::ProteinModel &COMPLEX, bool MEMBRANE)
    {
      // get ligand
      assemble::ProteinModel ligand( GetLigand( COMPLEX));

      // get receptor
      assemble::ProteinModel receptor( GetReceptor( COMPLEX));

      // if is membrane protein complex
      if( MEMBRANE)
      {
        // move the receptor and the ligand into the membrane
        util::ShPtr< biol::Membrane> sp_membrane
        (
          COMPLEX.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane)
        );

        // if the membrane is defined, move the ligand center to the membrane center
        if( sp_membrane.IsDefined())
        {
          // calculate ligand geometric center
          linal::Vector3D ligand_center( coord::CenterOfMass( ligand.GetAtomCoordinates(), true));

          // move the ligand to the origin
          ligand.Translate( sp_membrane->GetOrientation().GetOrigin() - ligand_center + linal::Vector3D( 100, 100, 0));
        }
      }

      // translate the ligand onto the receptor so that they become in contact
      ligand.Translate( ComputeReceptorLigandShortestDistance( receptor, ligand).second);

//      util::ShPtr< assemble::ProteinModel> sp_model( COMPLEX.HardCopy());
//      sp_model->Replace( sp_ligand);
//      COMPLEX = *sp_model;
    }

    //!
    //!
    //! @param PROTEIN_MODEL
    //! @return
    //!
    math::MutateResult< assemble::ProteinModel> MutateProteinModelChainMove::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {

      // get the ID of the movable chain
      const char ligand_chain_id( GetLigandChainID( PROTEIN_MODEL));

      // get the movable chain
      const util::ShPtr< assemble::Chain> sp_ligand( PROTEIN_MODEL.GetChain( ligand_chain_id));

      // get the placement for the movable chain
      const storage::Pair< math::TransformationMatrix3D, bool> placement( PlaceLigand( *sp_ligand, PROTEIN_MODEL));

      // return if there is no placement defined
      if( !placement.Second())
      {
        return math::MutateResult< assemble::ProteinModel>( util::ShPtr< assemble::ProteinModel>(), *this);
      }

      math::TransformationMatrix3D transform( placement.First());

      // a copy of PROTEIN_MODEL
      util::ShPtr< assemble::ProteinModel> sp_model( PROTEIN_MODEL.HardCopy());

      // create a copy of the movable chain
      util::ShPtr< assemble::Chain> sp_ligand_copy( sp_ligand->HardCopy());

      // move the ligand to a new location
      sp_ligand_copy->Transform( transform);

      // rotate the ligand internally
      const linal::Vector3D ligand_com( coord::CenterOfMass( sp_ligand_copy->GetAtomCoordinates(), true));
      math::TransformationMatrix3D internal_rotation( -ligand_com);
      internal_rotation( math::RotationMatrix3D().SetRand( m_MaxInternalRotationAngle));
      internal_rotation( ligand_com);
      sp_ligand_copy->Transform( internal_rotation);

      // replace movable chain
      sp_model->Replace( sp_ligand_copy);

      // return the mutated model
      return math::MutateResult< assemble::ProteinModel>( sp_model, *this);
    }

    //!
    //!
    //! @param COMPLEX
    //! @return
    //!
    const util::ShPtr< assemble::Chain> &MutateProteinModelChainMove::GetLigand
    (
      const assemble::ProteinModel &COMPLEX
    )
    {
      return COMPLEX.GetChain( GetLigandChainID( COMPLEX));
    }

    //!
    //!
    //! @param COMPLEX
    //! @return
    //!
    util::ShPtrVector< assemble::Chain> MutateProteinModelChainMove::GetReceptor
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    )
    {
      // get the receptor chain id(s)
      std::string chain_ids( PROTEIN_MODEL.GetChainIDs());
      size_t ligand_chain_id_pos( chain_ids.find( GetLigandChainID( PROTEIN_MODEL)));
      chain_ids.erase( ligand_chain_id_pos, 1);

      // return the receptor chains
      return PROTEIN_MODEL.GetChains( chain_ids);
    }

    //! @brief computes the shortest distance between the ligand chain and all receptor chain(s)
    //! @param LIGAND the ligand chain
    //! @param RECEPTOR the receptor chain(s)
    //! @return
    std::pair< double, linal::Vector3D> MutateProteinModelChainMove::ComputeReceptorLigandShortestDistance
    (
      const assemble::ProteinModel &RECEPTOR,
      const assemble::ProteinModel &LIGAND
    )
    {
      // get all ligand atoms and all receptor atoms
      util::SiPtrVector< const biol::Atom> lig_atoms( LIGAND.GetAtoms());
      util::SiPtrVector< const biol::Atom> rec_atoms( RECEPTOR.GetAtoms());

      // maximum possible double values
      double shortest_distance
      (
        linal::Distance( ( *lig_atoms.Begin())->GetCoordinates(), ( *rec_atoms.Begin())->GetCoordinates())
      );
      linal::Vector3D shortest_distance_vector3d;

      // iterate over ligand atoms
      for
      (
        auto lig_atom_itr( lig_atoms.Begin()), lig_atom_itr_end( lig_atoms.End());
          lig_atom_itr != lig_atom_itr_end;
        ++lig_atom_itr
      )
      {
        // iterate over atoms in the receptor
        for
        (
          auto rec_atom_itr( rec_atoms.Begin()), rec_atom_itr_end( rec_atoms.End());
            rec_atom_itr != rec_atom_itr_end;
          ++rec_atom_itr
        )
        {
          // current distance
          double current_distance
          (
            linal::Distance( ( *lig_atom_itr)->GetCoordinates(), ( *rec_atom_itr)->GetCoordinates())
          );

          // update shortest distance
          if( current_distance < shortest_distance)
          {
            shortest_distance = current_distance;
            shortest_distance_vector3d = ( *rec_atom_itr)->GetCoordinates() - ( *lig_atom_itr)->GetCoordinates();
          }
        }
      }

      return std::pair< double, linal::Vector3D>( shortest_distance, shortest_distance_vector3d);
    }
  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_compress.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelCompress::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelCompress())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelCompress::MutateProteinModelCompress() :
      m_CompressionRange( math::Range< double>( 0.97, 1.00)),
      m_Scheme( GetStaticClassName< MutateProteinModelCompress>())
    {
    }

    //! @brief constructor from a specified compression factor and a scheme
    //! @param COMPRESSION_FACTOR compression factor
    //! @param SCHEME Scheme to be used
    MutateProteinModelCompress::MutateProteinModelCompress
    (
      const double COMPRESSION_FACTOR,
      const std::string &SCHEME
    ) :
      m_CompressionRange( COMPRESSION_FACTOR, COMPRESSION_FACTOR),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from a compression factor range
    //! @param COMPRESSION_FACTOR_RANGE compression factor range composed of an lower and an upper value, and a scheme
    //! @param SCHEME Scheme to be used
    MutateProteinModelCompress::MutateProteinModelCompress
    (
      const math::Range< double> &COMPRESSION_FACTOR_RANGE,
      const std::string &SCHEME
    ) :
      m_CompressionRange( COMPRESSION_FACTOR_RANGE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief clone
    MutateProteinModelCompress *MutateProteinModelCompress::Clone() const
    {
      return new MutateProteinModelCompress( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelCompress::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns compression range
    //! @return compression range
    const math::Range< double> MutateProteinModelCompress::GetCompressionRange() const
    {
      return m_CompressionRange;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL ProteinModel which will be mutated
    //! @return MutateResult ProteinModel after mutation
    math::MutateResult< assemble::ProteinModel> MutateProteinModelCompress::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty result
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // make sure the protein model at least has 2 SSEs
      if( PROTEIN_MODEL.GetSSEs().GetSize() < 2)
      {
        // end
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // determine the scaling factor
      // if it's just one value then use it, if it's a range then pick a random factor from the specified range
      const double compression_factor
      (
        m_CompressionRange.GetMin() == m_CompressionRange.GetMax() ?
          m_CompressionRange.GetMin() : random::GetGlobalRandom().Double( m_CompressionRange)
      );

      // copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( new assemble::ProteinModel());

      // calculate the center of mass
      const linal::Vector3D model_center( PROTEIN_MODEL.GetCenterOfSSEs());

      // iterate over all chains
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator chain_itr( PROTEIN_MODEL.GetChains().Begin()),
          chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // initialize a new chain
        util::ShPtr< assemble::Chain> sp_chain( new assemble::Chain( ( *chain_itr)->GetSequence()));

        // iterate over all the SSEs in the chain
        for
        (
          storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
            sse_itr( ( *chain_itr)->GetData().Begin()), sse_itr_end( ( *chain_itr)->GetData().End());
          sse_itr != sse_itr_end; ++sse_itr
        )
        {
          // make a copy of the SSE
          util::ShPtr< assemble::SSE> new_sse( ( *sse_itr)->Clone());

          // get the translation axis
          const linal::Vector3D translation_axis( ( *sse_itr)->GetCenter() - model_center);

          // apply the translation along the calculated axis
          new_sse->Translate( translation_axis * ( compression_factor - double( 1.0)));

          // insert the SSE
          sp_chain->Insert( new_sse);
        }

        // insert this chain into the model
        new_model->Insert( sp_chain);
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelCompress::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_CompressionRange, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelCompress::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_CompressionRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "coord/bcl_coord_move_interface.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModel::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModel())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModel::MutateProteinModel() :
      m_Move(),
      m_Scheme( GetStaticClassName< MutateProteinModel>())
    {
    }

    //! @brief constructor from a Move and a scheme
    //! @param MOVE function that performs the move on the protein
    //! @param SCHEME scheme to be used
    MutateProteinModel::MutateProteinModel
    (
      const coord::MoveInterface &MOVE,
      const std::string &SCHEME
    ) :
      m_Move( MOVE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief clone
    MutateProteinModel *MutateProteinModel::Clone() const
    {
      return new MutateProteinModel( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModel::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateProteinModel::GetAlias() const
    {
      static const std::string s_alias( "MutateProteinModel");
      return s_alias;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateProteinModel::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Changes a protein model using the provided mover.");
      serializer.AddInitializer
      (
        "mover",
        "mutates the protein model",
        io::Serialization::GetAgent( &m_Move)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModel::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      BCL_MessageVrb( "using Move: " + util::Format()( m_Move));

      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // skip if move not defined
      if( !m_Move.IsDefined())
      {
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // hard copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.HardCopy());

      // make a result to be returned that stores this ShPtr
      math::MutateResult< assemble::ProteinModel> result( new_model, *this);

      // move the model
      m_Move->Move( *new_model);

      // end
      return result;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_domain_add.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_fold_template.h"
#include "assemble/bcl_assemble_fold_template_handler.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! initialize deviation range
    const math::Range< double> MutateProteinModelDomainAdd::s_Deviation( 0.0, 5.0);

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelDomainAdd::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelDomainAdd())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelDomainAdd::MutateProteinModelDomainAdd() :
      m_CollectorDomain(),
      m_FitToFoldTemplate( false),
      m_Scheme( GetStaticClassName< MutateProteinModelDomainAdd>())
    {
    }

    //! @brief construct from a domain collector and a scheme
    //! @param DOMAIN_COLLECTOR domain collector to be used to get a domain
    //! @param FIT_TO_FOLD_TEMPLATE bool whether to fit the domain to a fold template prior to adding
    //! @param SCHEME Scheme to be used
    MutateProteinModelDomainAdd::MutateProteinModelDomainAdd
    (
      const find::CollectorInterface< util::ShPtrVector< assemble::Domain>, assemble::DomainInterface> &DOMAIN_COLLECTOR,
      const bool FIT_TO_FOLD_TEMPLATE,
      const std::string &SCHEME
    ) :
      m_CollectorDomain( DOMAIN_COLLECTOR.Clone()),
      m_FitToFoldTemplate( FIT_TO_FOLD_TEMPLATE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelDomainAdd
    MutateProteinModelDomainAdd *MutateProteinModelDomainAdd::Clone() const
    {
      return new MutateProteinModelDomainAdd( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelDomainAdd::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a ProteinModel and return a mutated ProteinModel
    //! @param PROTEIN_MODEL ProteinModel which will be mutated
    //! @return MutateResult with the mutated ProteinModel
    math::MutateResult< assemble::ProteinModel> MutateProteinModelDomainAdd::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // get possible domains from the collector
      const util::ShPtrVector< assemble::Domain> domains( m_CollectorDomain->Collect( PROTEIN_MODEL));

      // if no domains were collected
      if( domains.IsEmpty())
      {
        // warn the user
        BCL_MessageStd( "No domains collected, skipping " + m_Scheme);

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // get a random domain
      util::ShPtr< assemble::Domain> sp_domain
      (
        *random::GetGlobalRandom().Iterator( domains.Begin(), domains.End(), domains.GetSize())
      );

      // create a new protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // get the SSEs in the domain
      const util::SiPtrVector< const assemble::SSE> domain_sses( sp_domain->GetSSEs());
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator sse_itr( domain_sses.Begin()),
          sse_itr_end( domain_sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // remove the SSE from the protein model
        new_model->Remove( **sse_itr);
      }

      // if the domain should be fit into a fold template
      if( m_FitToFoldTemplate)
      {
        // get a random template
        const assemble::FoldTemplate fold_template
        (
          assemble::FoldTemplateHandler::GetRandomSubTemplate( sp_domain->GetSSEs())
        );

        // if a random template could not be found
        if( fold_template.GetGeometries().IsEmpty())
        {
          // warn the user
          BCL_MessageStd( "Unable to find suitable fold template, skipping " + m_Scheme);

          // return empty result
          return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
        }

        // get the domain from fitting the SSEs into the template
        sp_domain = util::ShPtr< assemble::Domain>( fold_template.FitSSEs( sp_domain->GetSSEs()).Clone());
      }

      // initialize transformation matrix with move from domain orientation to origin
      math::TransformationMatrix3D transform( math::Inverse( sp_domain->GetOrientation()));

      // create a range to choose the random rotation from
      const math::Range< double> angle_range( 0.0, 2.0 * math::g_Pi);

      // rotate the transformation matrix with a random rotation
      transform
      (
        math::RotationMatrix3D
        (
          random::GetGlobalRandom().Double( angle_range),
          random::GetGlobalRandom().Double( angle_range),
          random::GetGlobalRandom().Double( angle_range)
        )
      );

      // set the translation vector to be along the Z-axis of the rotation matrix
      const linal::Vector3D translation_vector( transform.GetRotation().GetAxis( coord::GetAxes().e_Z));

      // translate to the center of the protein model
      const linal::Vector3D protein_center( new_model->GetCenter());
      transform( protein_center);

      // move the domain to the center of the protein model
      sp_domain->Transform( transform);

      // create a line segment from the center pointing outwards
      const coord::LineSegment3D line_segment_forward
      (
        protein_center,
        protein_center + 1000.0 * translation_vector
      );

      // collect the coordinates in the protein model
      const util::SiPtrVector< const linal::Vector3D> coords_a
      (
        new_model->GetAtomCoordinates( storage::Set< biol::AtomType>( biol::GetAtomTypes().CA))
      );

      // get the distance to the edge of the protein model
      const double protein_edge_distance( GetMaxDistanceFromCenter( line_segment_forward, coords_a));

      // collect the coordinates in the domain
      const util::SiPtrVector< const linal::Vector3D> coords_b
      (
        sp_domain->GetAtomCoordinates( storage::Set< biol::AtomType>( biol::GetAtomTypes().CA))
      );

      // create a line segment from the center pointing outwards
      const coord::LineSegment3D line_segment_reverse
      (
        protein_center,
        protein_center - 1000.0 * translation_vector
      );

      // get the distance to the edge of the domain
      const double domain_edge_distance( GetMaxDistanceFromCenter( line_segment_reverse, coords_b));

      // get a random deviation for the translation
      const double random_deviation( random::GetGlobalRandom().Double( s_Deviation));

      // move the domain to the determined position
      sp_domain->Translate
      (
        ( protein_edge_distance + domain_edge_distance + random_deviation) * translation_vector
      );

      // iterate over the SSEs
      const util::SiPtrVector< const assemble::SSE> sses( sp_domain->GetSSEs());
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator sse_itr( sses.Begin()), sse_itr_end( sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // insert the sse into the protein model
        new_model->Insert( util::ShPtr< assemble::SSE>( ( *sse_itr)->Clone()));
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelDomainAdd::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_CollectorDomain, ISTREAM);
      io::Serialize::Read( m_FitToFoldTemplate, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelDomainAdd::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_CollectorDomain, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_FitToFoldTemplate, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief takes a set of coordinates and returns the farthest distance from the beginning of the line segment
    //! @param LINE_SEGMENT line segment that contains the point and direction to be used
    //! @param COORDS coordinates to be checked
    //! @return the farthest distance from the beginning of the line segment
    double MutateProteinModelDomainAdd::GetMaxDistanceFromCenter
    (
      const coord::LineSegment3D &LINE_SEGMENT,
      const util::SiPtrVector< const linal::Vector3D> &COORDS
    )
    {
      // initialize the maximum distance from the center of the model
      double max_distance( 0.0);

      // iterate over the coordinates
      for
      (
        util::SiPtrVector< const linal::Vector3D>::const_iterator coord_itr( COORDS.Begin()),
          coord_itr_end( COORDS.End());
        coord_itr != coord_itr_end; ++coord_itr
      )
      {
        // if the coordinate is within 5 angstroms from the line segment
        if( coord::CalculateDistancePointFromLineSegment( LINE_SEGMENT, **coord_itr).First() < 5.0)
        {
          // update the max distance if this distance from the center is greater
          max_distance = std::max( max_distance, linal::Distance( LINE_SEGMENT.GetStartPoint(), **coord_itr));
        }
      }

      // end
      return max_distance;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_domain.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "math/bcl_math_mutate_move_wrapper.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelDomain::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelDomain())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelDomain::MutateProteinModelDomain() :
      m_Collector(),
      m_Locator(),
      m_Mutate(),
      m_Scheme( GetStaticClassName< MutateProteinModelDomain>())
    {
    }

    //! @brief constructor from a CollectorInterface and a MutateInterface
    //! @param COLLECTOR Collector that returns Domains from a given ProteinModel
    //! @param MOVE Move that works on a Domain
    //! @param SCHEME Scheme to be used
    MutateProteinModelDomain::MutateProteinModelDomain
    (
      const find::CollectorInterface< util::ShPtrVector< assemble::Domain>, assemble::ProteinModel> &COLLECTOR,
      const coord::MoveInterface &MOVE,
      const std::string &SCHEME
    ) :
      m_Collector( COLLECTOR.Clone()),
      m_Locator(),
      m_Mutate( new math::MutateMoveWrapper< assemble::Domain>( MOVE)),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from a CollectorInterface and a MutateInterface
    //! @param COLLECTOR Collector that returns Domains from a given ProteinModel
    //! @param MUTATE Mutate that works on a Domain
    //! @param SCHEME Scheme to be used
    MutateProteinModelDomain::MutateProteinModelDomain
    (
      const find::CollectorInterface< util::ShPtrVector< assemble::Domain>, assemble::ProteinModel> &COLLECTOR,
      const math::MutateInterface< assemble::Domain> &MUTATE,
      const std::string &SCHEME
    ) :
      m_Collector( COLLECTOR.Clone()),
      m_Locator(),
      m_Mutate( MUTATE.Clone()),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from a LocatorInterface and a MutateInterface
    //! @param LOCATOR Locator that returns a Domain from a given ProteinModel
    //! @param MOVE Move that works on a Domain
    //! @param SCHEME Scheme to be used
    MutateProteinModelDomain::MutateProteinModelDomain
    (
      const find::LocatorInterface< util::ShPtr< assemble::Domain>, assemble::ProteinModel> &LOCATOR,
      const coord::MoveInterface &MOVE,
      const std::string &SCHEME
    ) :
      m_Collector(),
      m_Locator( LOCATOR.Clone()),
      m_Mutate( new math::MutateMoveWrapper< assemble::Domain>( MOVE)),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from a LocatorInterface and a MutateInterface
    //! @param LOCATOR Locator that returns a Domain from a given ProteinModel
    //! @param MUTATE Mutate that works on a Domain
    //! @param SCHEME Scheme to be used
    MutateProteinModelDomain::MutateProteinModelDomain
    (
      const find::LocatorInterface< util::ShPtr< assemble::Domain>, assemble::ProteinModel> &LOCATOR,
      const math::MutateInterface< assemble::Domain> &MUTATE,
      const std::string &SCHEME
    ) :
      m_Collector(),
      m_Locator( LOCATOR.Clone()),
      m_Mutate( MUTATE.Clone()),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelDomain
    MutateProteinModelDomain *MutateProteinModelDomain::Clone() const
    {
      return new MutateProteinModelDomain( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelDomain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that tkes a ProteinModel and return a mutated ProteinModel
    //! @param PROTEIN_MODEL ProteinModel which will be mutated
    //! @return MutateResult with the mutated ProteinModel
    math::MutateResult< assemble::ProteinModel> MutateProteinModelDomain::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty result
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      BCL_MessageVrb( " mutate domain: " + m_Scheme);

      // store ShPtr to domain
      util::ShPtr< assemble::Domain> this_domain;

      // if locator is given
      if( m_Locator.IsDefined())
      {
        this_domain = m_Locator->Locate( PROTEIN_MODEL);
      }
      // if collector is defined
      else if( m_Collector.IsDefined())
      {
        // use the collector to get the domains
        util::ShPtrVector< assemble::Domain> domains( m_Collector->Collect( PROTEIN_MODEL));

        // if there are no domains
        if( domains.IsEmpty())
        {
          BCL_MessageVrb( "No domains found returning failure");
          return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
        }
        // pick one of the domains randomly
        this_domain = ( domains( random::GetGlobalRandom().Random< size_t>( domains.GetSize() - 1)));
      }

      // if domain is not defined
      if( !this_domain.IsDefined())
      {
        BCL_MessageVrb( "Found domain is not defined");
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // apply the mutate to this domain and store the result
      math::MutateResult< assemble::Domain> domain_mutate_result( m_Mutate->operator ()( *this_domain));

      // if the mutate was not successful
      if( !domain_mutate_result.GetArgument().IsDefined())
      {
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }
      // otherwise create a new model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace the mutated domain within the new_model
      new_model->Replace( domain_mutate_result.GetArgument()->GetData());

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelDomain::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Collector, ISTREAM);
      io::Serialize::Read( m_Locator, ISTREAM);
      io::Serialize::Read( m_Mutate, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelDomain::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Collector, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Locator, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Mutate, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << '\n';

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "fold/bcl_fold_mutate_protein_model_filter_conformations.h"
#include "math/bcl_math_mutate_result.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelFilterConformations::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelFilterConformations())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelFilterConformations::MutateProteinModelFilterConformations() :
      m_ConformationCollector(),
      m_Scheme( GetStaticClassName< MutateProteinModelFilterConformations>())
    {
    }

    //! @brief constructor taking parameters
    //! @param LOCATOR the method for locating an alternative conformation
    //! @param SCHEME Scheme to be used
    MutateProteinModelFilterConformations::MutateProteinModelFilterConformations
    (
      const util::ShPtr
      <
        find::CollectorInterface< util::SiPtrList< const assemble::ProteinModel>, assemble::ProteinModel>
      > &COLLECTOR,
      const std::string &SCHEME
    ) :
      m_ConformationCollector( COLLECTOR),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelFilterConformations
    MutateProteinModelFilterConformations *MutateProteinModelFilterConformations::Clone() const
    {
      return new MutateProteinModelFilterConformations( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelFilterConformations::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////
  
  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel>
    MutateProteinModelFilterConformations::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // static empty model
      const math::MutateResult< assemble::ProteinModel> empty_result( util::ShPtr< assemble::ProteinModel>(), *this);

      // collect the desired models
      const util::SiPtrList< const assemble::ProteinModel> filtered_models
      (
        m_ConformationCollector->Collect( PROTEIN_MODEL)
      );

      // if no models were collected
      if( filtered_models.IsEmpty())
      {
        return empty_result;
      }

      // initialize new ensemble using the first collected model
      util::ShPtr< assemble::ProteinEnsemble> model( new assemble::ProteinEnsemble( *filtered_models.FirstElement()));

      // insert the rest of the collected models
      for
      (
        util::SiPtrList< const assemble::ProteinModel>::const_iterator
          model_itr( ++filtered_models.Begin()), //< start at the second element
          model_itr_end( filtered_models.End());
        model_itr != model_itr_end;
        ++model_itr
      )
      {
        model->InsertElement( util::ShPtr< assemble::ProteinEnsemble>( ( *model_itr)->HardCopy()));
      }

      // return the mutated model
      return math::MutateResult< assemble::ProteinModel>( model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelFilterConformations::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ConformationCollector, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelFilterConformations::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ConformationCollector, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_fix_loop_closure_wrapper.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "fold/bcl_fold_mutate_protein_model_sse_pair_clash.h"
#include "fold/bcl_fold_mutate_protein_model_sse_pair_fix_loop_closure.h"
#include "io/bcl_io_directory.h"
#include "io/bcl_io_file.h"
#include "pdb/bcl_pdb_factory.h"
#include "score/bcl_score_aa_pair_hi_res_clash.h"
#include "score/bcl_score_loop_closure.h"
#include "score/bcl_score_protein_model_membrane_topology.h"
#include "score/bcl_score_protein_model_sse_linear_loop_proximity.h"
// external includes - sorted alphabetically

// Define this to visualize all clash removals
//#define DEBUG_BCL_FOLD_MUTATE_CLASH_RESOLVER

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelFixLoopClosureWrapper::MutateProteinModelFixLoopClosureWrapper
    (
      const math::MutateInterface< assemble::ProteinModel> &MUTATE_A,
      const std::string &SCHEME
    ) :
      m_PrimaryMutate
      (
        MUTATE_A,
        MutateProteinModelSSEPairClash(),
        false,
        MUTATE_A.GetScheme()
      )
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelFixLoopClosureWrapper
    MutateProteinModelFixLoopClosureWrapper *MutateProteinModelFixLoopClosureWrapper::Clone() const
    {
      return new MutateProteinModelFixLoopClosureWrapper( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelFixLoopClosureWrapper::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelFixLoopClosureWrapper::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      static util::ShPtr< assemble::ProteinModel> s_empty_model;
      // initialize empty model

      // max times to retry mutate. Since mutates are very fast relative to scoring, it is fast to run a given mutate
      // many times before giving up
      static size_t s_MaxRetries( 10);

      // loop closure score
      static score::LoopClosure s_closure( size_t( 1), 0.0, 1.0);

      // sse clash score
      static score::AAPairHiResClash s_Clash;

      // linear loop proximity score
      static score::ProteinModelSSELinearLoopProximity s_lin_loop_prox;

      // membrane topology score
      static score::ProteinModelMembraneTopology s_topology;
      static bool s_MPTopologyInitialized( s_topology.InitializeFromFlag());

      for( size_t i( 0); i < s_MaxRetries; ++i)
      {
        math::MutateResult< assemble::ProteinModel> result( m_PrimaryMutate( PROTEIN_MODEL));
        if( !result.GetArgument().IsDefined())
        {
          return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
        }
        if
        (
          s_closure( *result.GetArgument()) < 0.5
          && s_lin_loop_prox( *result.GetArgument()) < 1.5
          && s_Clash( *result.GetArgument()) < 0.5
          && ( !s_MPTopologyInitialized || s_topology( *result.GetArgument()) < 0.5)
        )
        {
          return math::MutateResult< assemble::ProteinModel>( result.GetArgument(), *this);
        }
      }

      // return
      return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelFixLoopClosureWrapper::Read( std::istream &ISTREAM)
    {
      // return
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelFixLoopClosureWrapper::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_grow_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_aa.h"
#include "assemble/bcl_assemble_locator_sse.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_mutate_aa_sequence_grow.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelGrowSSE::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelGrowSSE())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelGrowSSE::MutateProteinModelGrowSSE() :
      m_LocatorSSE(),
      m_PhiPsiGenerator(),
      m_AnchorAA(),
      m_GrowingDirection()
    {
    }

    //! @brief constructor taking parameters
    //! @param LOCATOR_SSE the locator which will be used to find the sse which is going to be grown
    //! @param PHI_PSI_GEN method used in order to generate phi and psi angles as the loop domain is grown
    //! @param ANCHOR_AA locator to residue to which the n-terminus of the growing sse will be anchored (connected to)
    //! @param GROWING_DIRECTION growing direction of the sse
    MutateProteinModelGrowSSE::MutateProteinModelGrowSSE
    (
      const util::ShPtr
      <
        find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface>
      > &LOCATOR_SSE,
      const util::ShPtr
      <
        math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> >
      > &PHI_PSI_GEN,
      const util::ShPtr
      <
        find::LocatorInterface< util::SiPtr< const biol::AABase>, assemble::ProteinModel>
      > &ANCHOR_AA,
      const biol::AASequenceFlexibility::SequenceDirection GROWING_DIRECTION
    ) :
      m_LocatorSSE( LOCATOR_SSE),
      m_PhiPsiGenerator( PHI_PSI_GEN),
      m_AnchorAA( ANCHOR_AA),
      m_GrowingDirection( GROWING_DIRECTION)
    {
      BCL_Assert
      (
        GROWING_DIRECTION == biol::AASequenceFlexibility::e_NTerminal ||
        GROWING_DIRECTION == biol::AASequenceFlexibility::e_CTerminal,
        "SSEs can be grown only towards NTerminal or CTerminal, direction provided was: " +
        biol::AASequenceFlexibility::GetSequenceDirectionName( m_GrowingDirection)
      );
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelGrowSSE
    MutateProteinModelGrowSSE *MutateProteinModelGrowSSE::Clone() const
    {
      return new MutateProteinModelGrowSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelGrowSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param PROTEIN_MODEL Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< assemble::ProteinModel> MutateProteinModelGrowSSE::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // true if the sse should be grown in the c terminal direction
      if( m_GrowingDirection == biol::AASequenceFlexibility::e_CTerminal)
      {
        return GrowTowardsCTerminus( PROTEIN_MODEL);
      }

      // at this point, the sse should be grown in the n nterminal direction
      return GrowTowardsNTerminus( PROTEIN_MODEL);
    }

    //! @brief operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param PROTEIN_MODEL Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< assemble::ProteinModel> MutateProteinModelGrowSSE::GrowTowardsCTerminus
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      const util::SiPtr< const assemble::SSE> sse( m_LocatorSSE->Locate( PROTEIN_MODEL));
      BCL_Assert( sse.IsDefined(), "sse could not be found");

      // sequence will be built up as the sse is grown
      biol::AASequence new_sse_sequence( util::ShPtrVector< biol::AABase>(), sse->GetChainID());

      // get the anchor aa
      const util::SiPtr< const biol::AABase> anchor_aa( m_AnchorAA->Locate( PROTEIN_MODEL));

      // assert the anchor residue could be found
      BCL_Assert( anchor_aa.IsDefined(), "could not locate residue with locator " + util::Format()( m_AnchorAA));

      // create sequence out of the anchor aa
      const biol::AASequence anchor_seq( util::ShPtrVector< biol::AABase>( 1, util::ShPtr< biol::AABase>( anchor_aa->Clone())), anchor_aa->GetChainID());

      // create a MutateAASequenceGrow to be used for growing the located SSE
      const MutateAASequenceGrow grower( m_PhiPsiGenerator, util::SiPtr< const biol::AASequence>( anchor_seq));

      // grow the sequence of interest
      const math::MutateResult< biol::AASequence> growing_result( grower( *sse));
      const util::ShPtr< biol::AASequence> &grown_sequence( growing_result.GetArgument());

      BCL_Assert( grown_sequence.IsDefined(), "grown sequence is not defined");

      // new protein model
      util::ShPtr< assemble::ProteinModel> new_protein_model( PROTEIN_MODEL.Clone());

      // create a new final SSE which contains all residues except the first one
      // since the first residue is actually the last residue of the anchor SSE
      util::ShPtr< assemble::SSE> final_new_sse
      (
        new assemble::SSE( grown_sequence->SubSequence( 1, grown_sequence->GetSize() - 1), biol::GetSSTypes().COIL)
      );

      // locate the anchor SSE from the model
      util::SiPtr< const assemble::SSE> anchor_sse
      (
        assemble::LocatorAA( anchor_aa->GetChainID(), anchor_aa->GetSeqID()).LocateSSE( PROTEIN_MODEL)
      );
      BCL_Assert( anchor_sse.IsDefined(), "Anchor sse was not found which contained " + anchor_aa->GetIdentification());
      // make a new SSE and update its last member with the first amino acid from grown sequence
      util::ShPtr< assemble::SSE> new_anchor_sse( anchor_sse->Clone());
      new_anchor_sse->GetData().LastElement() = grown_sequence->GetFirstAA();
      // replace it
      new_protein_model->ReplaceWithOverlapping( new_anchor_sse);
      // now we can add the final_new_sse
      new_protein_model->Replace( final_new_sse);
      // create mutate result from "replaced_sse_model"
      math::MutateResult< assemble::ProteinModel> mutate_result( new_protein_model, *this);

      // return
      return mutate_result;
    }

    //! @brief operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param PROTEIN_MODEL Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< assemble::ProteinModel> MutateProteinModelGrowSSE::GrowTowardsNTerminus
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      const util::SiPtr< const assemble::SSE> sse( m_LocatorSSE->Locate( PROTEIN_MODEL));
      BCL_Assert( sse.IsDefined(), "sse could not be found");

      // sequence will be built up as the sse is grown
      biol::AASequence new_sse_sequence( util::ShPtrVector< biol::AABase>(), sse->GetChainID());

      // get the anchor aa
      const util::SiPtr< const biol::AABase> anchor_aa( m_AnchorAA->Locate( PROTEIN_MODEL));

      // assert the anchor residue could be found
      BCL_Assert( anchor_aa.IsDefined(), "could not locate residue with locator " + util::Format()( m_AnchorAA));

      // create sequence out of the anchor aa
      const biol::AASequence anchor_seq
      (
        util::ShPtrVector< biol::AABase>( 1, util::ShPtr< biol::AABase>( anchor_aa->Clone())), anchor_aa->GetChainID()
      );

      // create a MutateAASequenceGrow to be used for growing the located SSE
      const MutateAASequenceGrow grower( m_PhiPsiGenerator, util::SiPtr< const biol::AASequence>( anchor_seq));

      // grow the sequence of interest
      const math::MutateResult< biol::AASequence> growing_result( grower.GrowTowardsNTerminus( *sse));

      const util::ShPtr< biol::AASequence> &grown_sequence( growing_result.GetArgument());

      BCL_Assert( grown_sequence.IsDefined(), "grown sequence is not defined");

      // new protein model
      util::ShPtr< assemble::ProteinModel> new_protein_model( PROTEIN_MODEL.Clone());

      // create a new final SSE which contains all residues except the last one
      // since the last residue is actually the first residue of the anchor SSE
      util::ShPtr< assemble::SSE> final_new_sse
      (
        new assemble::SSE( grown_sequence->SubSequence( 0, grown_sequence->GetSize() - 1), biol::GetSSTypes().COIL)
      );

      // locate the anchor SSE from the model
      util::SiPtr< const assemble::SSE> anchor_sse
      (
        assemble::LocatorAA( anchor_aa->GetChainID(), anchor_aa->GetSeqID()).LocateSSE( PROTEIN_MODEL)
      );
      BCL_Assert( anchor_sse.IsDefined(), "Anchor sse was not found which contained " + anchor_aa->GetIdentification());
      // make a new SSE and update its first member with the last amino acid from grown sequence
      util::ShPtr< assemble::SSE> new_anchor_sse( anchor_sse->Clone());
      new_anchor_sse->GetData().FirstElement() = grown_sequence->GetLastAA();
      // replace it
      new_protein_model->ReplaceWithOverlapping( new_anchor_sse);
      // now we can add the final_new_sse
      new_protein_model->Replace( final_new_sse);
      // create mutate result from "replaced_sse_model"
      math::MutateResult< assemble::ProteinModel> mutate_result( new_protein_model, *this);

      // return
      return mutate_result;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelGrowSSE::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_LocatorSSE,       ISTREAM);
      io::Serialize::Read( m_PhiPsiGenerator,  ISTREAM);
      io::Serialize::Read( m_AnchorAA,         ISTREAM);
      io::Serialize::Read( m_GrowingDirection, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelGrowSSE::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_LocatorSSE,       OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PhiPsiGenerator,  OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AnchorAA,         OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_GrowingDirection, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief static function that grows all the missing coil regions in the given ProteinModel
    //!        splits the coil and grows first part N to C and the second part C to N
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @param PHI_PSI_GEN method used in order to generate phi and psi angles as the loop domain is grown
    //! @return ShPtr to ProteinModel with the loops grown
    util::ShPtr< assemble::ProteinModel> MutateProteinModelGrowSSE::GrowAllMissingCoilsBidirectional
    (
      const assemble::ProteinModel &PROTEIN_MODEL,
      const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GEN
    )
    {
      // create a model to keep track as we grow loops
      util::ShPtr< assemble::ProteinModel> sp_model( PROTEIN_MODEL.Clone());
      sp_model->AddLoops( true, false);

      // iterate over chains
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()),
          chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // get all the SSEs for this chain
        const util::SiPtrVector< const assemble::SSE> all_sses( ( *chain_itr)->GetSSEs());

        // iterate over all coils
        for
        (
          util::SiPtrVector< const assemble::SSE>::const_iterator
            sse_itr( all_sses.Begin()), sse_itr_end( all_sses.End());
          sse_itr != sse_itr_end; ++sse_itr
        )
        {
          // create reference
          const assemble::SSE &this_sse( **sse_itr);

          // check if this coil has undefined coordinates
          if( this_sse.GetType() != biol::GetSSTypes().COIL || this_sse.HasDefinedCoordinates())
          {
            continue;
          }

          // true if at nterminal sse i.e. very first sse in chain
          if( sse_itr == all_sses.Begin())
          {
            BCL_MessageDbg( "growing nterminal sse " + this_sse.GetIdentification());
            // grow sse
            GrowSSE( **sse_itr, sp_model, biol::AASequenceFlexibility::e_NTerminal, PHI_PSI_GEN);
            continue;
          }
          // true if at cterminal sse i.e. last sse in the chain
          else if( sse_itr == --all_sses.End())
          {
            BCL_MessageDbg( "growing cterminal sse " + this_sse.GetIdentification());
            // grow sse
            GrowSSE( **sse_itr, sp_model, biol::AASequenceFlexibility::e_CTerminal, PHI_PSI_GEN);
            continue;
          }

          BCL_Assert( sp_model->Remove( this_sse), "could not remove " + this_sse.GetIdentification());

          // create n terminal segment
          const size_t nterm_segment_size( this_sse.GetSize() - this_sse.GetSize() / 2);
          if( nterm_segment_size > 0)
          {
            const biol::AASequence new_nterm_seq( this_sse.SubSequence( 0, nterm_segment_size));
            util::ShPtr< assemble::SSE> nterm_sse( new assemble::SSE( new_nterm_seq, this_sse.GetType()));
            BCL_Assert( sp_model->Insert( nterm_sse), "could not insert " + nterm_sse->GetIdentification());
            GrowSSE( *nterm_sse, sp_model, biol::AASequenceFlexibility::e_CTerminal, PHI_PSI_GEN);
          }

          // create c terminal segment
          const size_t cterm_segment_size( this_sse.GetSize() - nterm_segment_size);
          if( cterm_segment_size > 0)
          {
            const biol::AASequence new_cterm_seq( this_sse.SubSequence( nterm_segment_size, cterm_segment_size));
            util::ShPtr< assemble::SSE> cterm_sse( new assemble::SSE( new_cterm_seq, this_sse.GetType()));
            BCL_Assert( sp_model->Insert( cterm_sse), "could not insert " + cterm_sse->GetIdentification());
            GrowSSE( *cterm_sse, sp_model, biol::AASequenceFlexibility::e_NTerminal, PHI_PSI_GEN);
          }
        }
      }

      // end
      return sp_model;
    }

    //! @brief grows coordinates for specified sses
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @param PHI_PSI_GEN method used in order to generate phi and psi angles as the loop domain is grown
    //! @param LOCATOR_SSES the specific sses that will be grown
    //! @return ptr to protein model that has the grown sses as specifed
    util::ShPtr< assemble::ProteinModel> MutateProteinModelGrowSSE::GrowSpecifiedCoilsBidirectional
    (
      const assemble::ProteinModel &START_MODEL,
      const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GEN,
      const util::SiPtrVector< const assemble::LocatorSSE> &LOCATOR_SSES
    )
    {
      // create a model to keep track as we grow loops
      util::ShPtr< assemble::ProteinModel> sp_model( START_MODEL.Clone());
      sp_model->AddLoops( true, false);

      // iterate over the sse locators
      for
      (
        util::SiPtrVector< const assemble::LocatorSSE>::const_iterator
        locator_itr( LOCATOR_SSES.Begin()), locator_itr_end( LOCATOR_SSES.End());
        locator_itr != locator_itr_end; ++locator_itr
      )
      {
        util::SiPtr< const assemble::SSE> located_sse( ( *locator_itr)->Locate( START_MODEL));
        BCL_Assert( located_sse.IsDefined(), "could not locate sse " + ( *locator_itr)->GetIdentification());

        // create reference
        const assemble::SSE &this_sse( *located_sse);

        // true if at nterminal sse i.e. very first sse in chain
        const util::SiPtrVector< const assemble::SSE> chain_sses
        (
          START_MODEL.GetChain( ( *locator_itr)->GetChainID())->GetSSEs()
        );
        if( located_sse == chain_sses.FirstElement())
        {
          BCL_MessageDbg( "growing nterminal sse " + this_sse.GetIdentification());
          // grow sse and get locator
          GrowSSE( this_sse, sp_model, biol::AASequenceFlexibility::e_NTerminal, PHI_PSI_GEN);
          continue;
        }
        // true if at cterminal sse i.e. last sse in the chain
        else if( located_sse == chain_sses.LastElement())
        {
          BCL_MessageDbg( "growing cterminal sse " + this_sse.GetIdentification());
          // grow sse and get locator
          GrowSSE( this_sse, sp_model, biol::AASequenceFlexibility::e_CTerminal, PHI_PSI_GEN);
          continue;
        }

        // size of n and c terminal segments
        const size_t nterm_segment_size( this_sse.GetSize() - this_sse.GetSize() / 2);
        const size_t cterm_segment_size( this_sse.GetSize() - nterm_segment_size);

        // construct the n and c terminal sub sequences
        const biol::AASequence new_nterm_seq( this_sse.SubSequence( 0, nterm_segment_size));
        const biol::AASequence new_cterm_seq( this_sse.SubSequence( nterm_segment_size, cterm_segment_size));
        BCL_Assert( ( new_nterm_seq.GetSize() + new_cterm_seq.GetSize()) == this_sse.GetSize(), "size wrong");

        // construct n and c terminal sses and put them into the model after removing the sse they were created from
        util::ShPtr< assemble::SSE> nterm_sse( new assemble::SSE( new_nterm_seq, this_sse.GetType()));
        util::ShPtr< assemble::SSE> cterm_sse( new assemble::SSE( new_cterm_seq, this_sse.GetType()));
        BCL_Assert( sp_model->Remove( this_sse), "could not remove " + this_sse.GetIdentification());
        BCL_Assert( sp_model->Insert( nterm_sse), "could not insert " + nterm_sse->GetIdentification());
        BCL_Assert( sp_model->Insert( cterm_sse), "could not insert " + cterm_sse->GetIdentification());

        GrowSSE( *nterm_sse, sp_model, biol::AASequenceFlexibility::e_CTerminal, PHI_PSI_GEN);
        GrowSSE( *cterm_sse, sp_model, biol::AASequenceFlexibility::e_NTerminal, PHI_PSI_GEN);
      }

      // end
      return sp_model;
    }

    //! @brief grows a given sse in a protein model
    //! @param SSE the sse in the protein model that will be grown
    //! @param MODEL the protein model in which the sse will be grown
    //! @param DIRECTION the direction the sse needs to be grown
    //! @param PHI_PSI_GEN the method for generating the phi and psi angles to be assigned to the sse
    void MutateProteinModelGrowSSE::GrowSSE
    (
      const assemble::SSE &SSE,
      util::ShPtr< assemble::ProteinModel> &MODEL,
      const biol::AASequenceFlexibility::SequenceDirection &DIRECTION,
      const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GEN
    )
    {
      // construct locator for SSE
      const util::ShPtr< assemble::LocatorSSE> sp_sse_locator
      (
        new assemble::LocatorSSE
        (
          SSE.GetChainID(), SSE.GetFirstAA()->GetSeqID(), SSE.GetLastAA()->GetSeqID()
        )
      );

      // construct locator for anchor res
      util::ShPtr< assemble::LocatorAA> sp_anchor_aa_locator;

      // true if C to N direction - anchor aa is next aa in sequence
      if( DIRECTION == biol::AASequenceFlexibility::e_NTerminal)
      {
        sp_anchor_aa_locator =
          util::ShPtr< assemble::LocatorAA>
         (
           new assemble::LocatorAA( SSE.GetChainID(), SSE.GetLastAA()->GetSeqID() + 1)
         );
      }
      else //< N to C direction - anchor aa is previous aa in sequence
      {
        sp_anchor_aa_locator =
          util::ShPtr< assemble::LocatorAA>
         (
           new assemble::LocatorAA( SSE.GetChainID(), SSE.GetFirstAA()->GetSeqID() - 1)
         );
      }

      BCL_MessageDbg
      (
        "\tanchor aa locator => chain: " + util::Format()( sp_anchor_aa_locator->GetLocatorChain().GetChainID()) +
        " id: " + util::Format()( sp_anchor_aa_locator->GetAAID())
      );
      BCL_MessageDbg
      (
        "\tdirection: " + biol::AASequenceFlexibility::GetSequenceDirectionName( DIRECTION)
      );

      // construct a mutate and apply it
      MODEL =
        MutateProteinModelGrowSSE( sp_sse_locator, PHI_PSI_GEN, sp_anchor_aa_locator, DIRECTION)( *MODEL).GetArgument();
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_loop_domain_ccd.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_collector_loop_domain.h"
#include "fold/bcl_fold_collector_loop_domain_random.h"
#include "fold/bcl_fold_loop_domain.h"
#include "fold/bcl_fold_mutate_loop_domain_dihedral.h"
#include "fold/bcl_fold_phi_psi_generator_ccd.h"
#include "math/bcl_math_mutate_result.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelLoopDomainCCD::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelLoopDomainCCD())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelLoopDomainCCD::MutateProteinModelLoopDomainCCD() :
      m_DomainCollector(),
      m_DomainLocator(),
      m_RandomNumberGenerator( random::GetGlobalRandom()),
      m_RandomFraction( 1.0, 1.0)
    {
    }

    //! @brief constructor taking member parameters
    //! @param DOMAIN_COLLECTOR the collector to collect possible loop domains for mutating
    //! @param RANDOM_NUMBER_GENERATOR the random number generator that should be used
    //! @param RANDOM_FRACTION_RANGE range a random fraction is drawn from and multiplied with suggested rotation
    MutateProteinModelLoopDomainCCD::MutateProteinModelLoopDomainCCD
    (
      const util::ShPtr< find::CollectorInterface< util::ShPtrList< LoopDomain>, assemble::DomainInterface> > &DOMAIN_COLLECTOR,
      const random::DistributionInterface &RANDOM_NUMBER_GENERATOR,
      const math::Range< double> &RANDOM_FRACTION_RANGE
    ) :
      m_DomainCollector( DOMAIN_COLLECTOR),
      m_DomainLocator(),
      m_RandomNumberGenerator( RANDOM_NUMBER_GENERATOR),
      m_RandomFraction( RANDOM_FRACTION_RANGE)
    {
    }

    //! @brief constructor taking member parameters
    //! @param DOMAIN_LOCATOR the locator to locate loop domain for mutating
    //! @param RANDOM_NUMBER_GENERATOR the random number generator that should be used
    //! @param RANDOM_FRACTION bool indicating if random fraction of the optimal rotation should be taken
    MutateProteinModelLoopDomainCCD::MutateProteinModelLoopDomainCCD
    (
      const util::ShPtr< find::LocatorInterface< util::ShPtr< LoopDomain>, assemble::DomainInterface> > &DOMAIN_LOCATOR,
      const random::DistributionInterface &RANDOM_NUMBER_GENERATOR,
      const math::Range< double> &RANDOM_FRACTION_RANGE
    ) :
      m_DomainCollector(),
      m_DomainLocator( DOMAIN_LOCATOR),
      m_RandomNumberGenerator( RANDOM_NUMBER_GENERATOR),
      m_RandomFraction( RANDOM_FRACTION_RANGE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelLoopDomainCCD
    MutateProteinModelLoopDomainCCD *MutateProteinModelLoopDomainCCD::Clone() const
    {
      return new MutateProteinModelLoopDomainCCD( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelLoopDomainCCD::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateProteinModelLoopDomainCCD::GetAlias() const
    {
      static const std::string s_name( "MutateProteinModelLoopDomainCCD");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateProteinModelLoopDomainCCD::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Changes dihedral angles of residues in loop regions.");
      serializer.AddInitializer
      (
        "random fraction range",
        "range of the random multiplier to apply to the suggested rotation angle",
        io::Serialization::GetAgent( &m_RandomFraction),
        "(1.0, 1.0)"
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @param ERROR_STREAM stream with which to write errors
    //! @return return code indicating success or failure
    bool MutateProteinModelLoopDomainCCD::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM
    )
    {
      // create the domain locator
      util::ShPtr< find::CollectorInterface< util::ShPtrList< LoopDomain>, assemble::DomainInterface> > sp_unclosed_loop_collector
      (
        new CollectorLoopDomain( true, 0.08)
      );
      m_DomainCollector = sp_unclosed_loop_collector;

      return true;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param PROTEIN_MODEL Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< assemble::ProteinModel> MutateProteinModelLoopDomainCCD::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static variable to hold undefined model pointer
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // initialize empty loop domain
      util::ShPtr< LoopDomain> loop_domain;

      // if locator is defined
      if( m_DomainLocator.IsDefined())
      {
        loop_domain = m_DomainLocator->Locate( PROTEIN_MODEL);
      }
      // otherwise use collector and pick one randomly
      else
      {
        // collect loop domains
        util::ShPtrList< LoopDomain> loop_domains( m_DomainCollector->Collect( PROTEIN_MODEL));

        // if no loop domains
        if( loop_domains.IsEmpty())
        {
          BCL_MessageCrt( "No loop domains were found in the model");
          return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
        }

        // pick one randomly
        loop_domain = *random::GetGlobalRandom().Iterator( loop_domains.Begin(), loop_domains.End(), loop_domains.GetSize());
      }

      // create a method for collecting residues to mutate
      const util::ShPtr< CollectorLoopDomainRandom> mutation_residue_collector
      (
        // initialize with CollectorLoopDomainRandom which will randomly select one of the residues in "loop_domain"
        new CollectorLoopDomainRandom( 1, m_RandomNumberGenerator)
      );

      // create list of TargetAndMovingPointPair objects
      const storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair> target_and_moving_points
      (
        loop_domain->TargetAndMovingPointsForCCD( PROTEIN_MODEL)
      );

      // need points
      if( target_and_moving_points.IsEmpty())
      {
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // create a ShPtr to a PhiPsiGeneratorCCD which will be used to generate phi and psi angles
      const util::ShPtr< PhiPsiGeneratorCCD> phi_psi_generator
      (
        new PhiPsiGeneratorCCD
        (
          target_and_moving_points,
          m_RandomNumberGenerator,
          loop_domain->GetSequenceDirection(),
          m_RandomFraction
        )
      );

      // create a MutateLoopDomainDihedral which will be used to mutate "loop_domain"
      // and initialize it with "mutation_residue_collector" and "phi_psi_generator"
      const MutateLoopDomainDihedral domain_mutator( mutation_residue_collector, phi_psi_generator);

      // create a mutated loop domain "mutated_loop" as provided by "domain_mutator"
      util::ShPtr< LoopDomain> mutated_loop( domain_mutator( *loop_domain).GetArgument());

      // make sure that "mutated_loop" is defined
      if( !mutated_loop.IsDefined())
      {
        BCL_MessageCrt( "mutated_loop_domain is not defined");
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

//      // make sure the atoms of the anchor atom is set correctly
//      mutated_loop->SetAnchorResidueOxygen( PROTEIN_MODEL);

      // create a ShPtr to the protein model where its sses have been replaced with those of "mutated_loop"
      util::ShPtr< assemble::ProteinModel> replaced_sse_model
      (
        // updated the protein mdoel according to the mutated loop
        mutated_loop->UpdateProteinModel( PROTEIN_MODEL)
      );

      // create mutate result "mutate_result" out of "replaced_sse_model"
      return math::MutateResult< assemble::ProteinModel>( replaced_sse_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_loop_domain.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_loop_domain.h"
#include "math/bcl_math_mutate_result.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelLoopDomain::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelLoopDomain())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelLoopDomain::MutateProteinModelLoopDomain() :
      m_DomainCollector(),
      m_DomainMutate()
    {
    }

    //! @brief constructor taking member variable types
    //! @param LOOP_DOMAIN_COLLECTOR the method for collecting loop domains in a protein model
    //! @param DOMAIN_MUTATE the method for mutating a loop domain
    MutateProteinModelLoopDomain::MutateProteinModelLoopDomain
    (
      const util::ShPtr< find::CollectorInterface< util::ShPtrList< LoopDomain>, assemble::DomainInterface> > &LOOP_DOMAIN_COLLECTOR,
      const util::ShPtr< math::MutateInterface< LoopDomain> > &DOMAIN_MUTATE
    ) :
      m_DomainCollector( *LOOP_DOMAIN_COLLECTOR),
      m_DomainMutate( *DOMAIN_MUTATE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelLoopDomainDihedral
    MutateProteinModelLoopDomain *MutateProteinModelLoopDomain::Clone() const
    {
      return new MutateProteinModelLoopDomain( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelLoopDomain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateProteinModelLoopDomain::GetAlias() const
    {
      static const std::string s_name( "MutateProteinModelLoopDomain");
      return s_name;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateProteinModelLoopDomain::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Changes the loop domain of a protein model.");
      serializer.AddInitializer
      (
        "collector",
        "method of collecting a loop domain in a protein model",
        io::Serialization::GetAgent( &m_DomainCollector)
      );
      serializer.AddInitializer
      (
        "mutate",
        "mutate for changing the loop domain",
        io::Serialization::GetAgent( &m_DomainMutate)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param PROTEIN_MODEL Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< assemble::ProteinModel> MutateProteinModelLoopDomain::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static variable to hold undefined model pointer
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // collect loop domains
      util::ShPtrList< LoopDomain> loop_domains( m_DomainCollector->Collect( PROTEIN_MODEL));

      // if no loop domains
      if( loop_domains.IsEmpty())
      {
        BCL_MessageCrt( "No loop domains were found in the model");
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // pick one randomly
      util::ShPtr< LoopDomain> selected_domain
      (
        *random::GetGlobalRandom().Iterator( loop_domains.Begin(), loop_domains.End(), loop_domains.GetSize())
      );

      // mutate selected domain
      util::ShPtr< LoopDomain> mutated_loop( m_DomainMutate->operator()( *selected_domain).GetArgument());

      // make sure "mutated_loop" is defined
      BCL_Assert( mutated_loop.IsDefined(), "mutated_loop is not defined");

      // get ShPtr to protein model where its sses have been replaced with sses of mutated_loop
      util::ShPtr< assemble::ProteinModel> replaced_sse_model
      (
        // iterate through the loop domain and replace the sses in the protein model
        mutated_loop->UpdateProteinModel( PROTEIN_MODEL)
      );

      // create a mutate result from "replaced_sse_model"
      math::MutateResult< assemble::ProteinModel> mutate_result( replaced_sse_model, *this);

      // return "mutate_result"
      return mutate_result;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_loop_domain_grow.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_aa_sequence_factory.h"
#include "fold/bcl_fold_loop_domain.h"
#include "fold/bcl_fold_mutate_aa_sequence_grow.h"
#include "fold/bcl_fold_mutation_residue.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelLoopDomainGrow::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelLoopDomainGrow())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelLoopDomainGrow::MutateProteinModelLoopDomainGrow() :
      m_LocatorLoopDomain(),
      m_PhiPsiGenerator()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param LOOP_DOMAIN_LOCATOR the locator which will be used to find a Loop Domain in a protein model
    //! @param PHI_PSI_GENERATOR method to be used in order to generate phi and psi angles as the loop domain is grown
    MutateProteinModelLoopDomainGrow::MutateProteinModelLoopDomainGrow
    (
      const util::ShPtr< find::LocatorInterface< util::ShPtr< LoopDomain>, assemble::DomainInterface> > &LOOP_DOMAIN_LOCATOR,
      const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GENERATOR
    ) :
      m_LocatorLoopDomain( LOOP_DOMAIN_LOCATOR),
      m_PhiPsiGenerator( PHI_PSI_GENERATOR)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelLoopDomainGrow
    MutateProteinModelLoopDomainGrow *MutateProteinModelLoopDomainGrow::Clone() const
    {
      return new MutateProteinModelLoopDomainGrow( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelLoopDomainGrow::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param PROTEIN_MODEL Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< assemble::ProteinModel> MutateProteinModelLoopDomainGrow::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      const math::MutateResult< assemble::ProteinModel> empty_result( util::ShPtr< assemble::ProteinModel>(), *this);

      // create LoopDomain from "PROTEIN_MODEL" with "m_LocatorLoopDomain"
      util::ShPtr< LoopDomain> loop_domain( m_LocatorLoopDomain->Locate( PROTEIN_MODEL));

      if( loop_domain->GetSequenceDirection() != biol::AASequenceFlexibility::e_CTerminal)
      {
        BCL_MessageCrt( "cannot work with loop domains for nterminal flexibility.");
        return empty_result;
      }

      // get a const reference to the loop segments in "loop_domain"
      const storage::Set< LoopSegment, LoopSegmentSequenceOrder> &loop_segments( loop_domain->GetSegments());

      // make sure the first loop segment is not rigid
      if( loop_segments.Begin()->IsRigid())
      {
        BCL_MessageCrt( "first loop segment should not be rigid");
        return empty_result;
      }

      // find adjacent sse
      const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > adjecent_sses( PROTEIN_MODEL.GetAdjacentSSEs( *loop_segments.Begin()->GetSSE()));

      if( !adjecent_sses.First().IsDefined())
      {
        BCL_MessageCrt( "cannot grow domain without an adjacent sse in protein model");
        return empty_result;
      }

      // connect the first segment to the n-terminal anchor sse
      const util::ShPtr< assemble::SSE> connected_n_c_sse
      (
        ConnectNonRigidSSE( *adjecent_sses.First(), *loop_segments.Begin()->GetSSE())
      );

      loop_domain->ReplaceSegment( LoopSegment( connected_n_c_sse, loop_segments.Begin()->IsRigid()));

      // now iterate through the rest of the loop segments and grow or connect them
      for
      (
        storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator
          segment_itr_a( loop_segments.Begin()), segment_itr_b( ++loop_segments.Begin()),
          segment_itr_end( loop_segments.End());
        segment_itr_a != segment_itr_end && segment_itr_b != segment_itr_end;
      )
      {
        // get pointer to the n terminarl sse which will be used as the anchor point
        const util::ShPtr< assemble::SSE> &n_terminal_sse( segment_itr_a->GetSSE());

        const bool n_terminal_sse_is_rigid( segment_itr_a->IsRigid());

        // Consecutive rigid loop segments following the loop segment denoted by "segment_itr_b" are moved
        // in conjunction with "segment_itr_b" since they must be a part of the same rigid domain as "segment_itr_b"
        // is in. Rigid segments should have coordinates, so they can all be connected as a rigid body.
        // If "segment_itr_b" is not rigid, it is assumed to not have coordinates and will be grown from scratch
        // from the n terminal anchor sse denoted by "n_terminal_sse". Even if it has coordinates, if it is
        // not rigid, it will be grown from scratch.

        // true if the segment denoted by "segment_itr_b" is not rigid
        if( !segment_itr_b->IsRigid())
        {
          BCL_MessageStd( "segment_itr_b is not rigid " + segment_itr_b->GetSSE()->GetIdentification());

          const storage::VectorND< 2, util::ShPtr< assemble::SSE> > connected_n_c_sses
          (
            ConnectNonRigidSSE( *n_terminal_sse, *segment_itr_b->GetSSE())
          );
          loop_domain->ReplaceSegment( LoopSegment( connected_n_c_sses.First(), segment_itr_a->IsRigid()));

            std::pair< storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator, bool> status
            (
              loop_domain->ReplaceSegment( LoopSegment( connected_n_c_sses.Second(), segment_itr_b->IsRigid()))
            );

          // set a to position of last replaced segment and b to next segment
          segment_itr_a = status.first;
          segment_itr_b = segment_itr_a;
          ++segment_itr_b;
        }
        else //< segment pointed by to "segment_itr_b" is rigid
        {
          // create ShPtr list of sses which will hold the sses that need to be connect along with "segment_itr_b"
          storage::List< LoopSegment> c_terminal_sses( 1, *segment_itr_b);

          // create c-terminal sequence which will have concatenated sequences of sses connected with "segment_itr_b"
          biol::AASequence c_terminal_sequence( *segment_itr_b->GetSSE());

          BCL_MessageStd( "segment_itr_b is rigid " + segment_itr_b->GetSSE()->GetIdentification());

          // increase the iterators
          ++segment_itr_a;
          ++segment_itr_b;

          // stop if segment_itr_b is at the end
          if( segment_itr_b == segment_itr_end)
          {
            // connect sequences
            const storage::Pair< util::ShPtr< assemble::SSE>, storage::List< LoopSegment> > connected_n_c_sses
            (
              ConnectRigidSequence( *n_terminal_sse, c_terminal_sequence, c_terminal_sses)
            );

            loop_domain->ReplaceSegment( LoopSegment( connected_n_c_sses.First(), segment_itr_a->IsRigid()));
            loop_domain->ReplaceSegment( connected_n_c_sses.Second());

            // break out of for loop
            break;
          }

          // collect consecutive segments that are also rigid so that they can all be moved together
          while( segment_itr_b->IsRigid())
          {
            // add sse denoted by "segment_itr_b" to "c_terminal_sses"
            c_terminal_sses.PushBack( *segment_itr_b);

            // append the sequence of "segment_itr_b" to "c_terminal_sequence"
            c_terminal_sequence.AppendSequence( *segment_itr_b->GetSSE());

            // increase iterators
            ++segment_itr_a;
            ++segment_itr_b;

            // stop if segment_itr_b is at the end
            if( segment_itr_b == segment_itr_end)
            {
              // break out of while loop
              break;
            }
          }

          // connect to "n_terminal_sse" all the sequences in "c_terminal_sequence" as a rigid body
          const storage::Pair< util::ShPtr< assemble::SSE>, storage::List< LoopSegment> > connected_n_c_sses
          (
            ConnectRigidSequence( *n_terminal_sse, c_terminal_sequence, c_terminal_sses)
          );

          loop_domain->ReplaceSegment( LoopSegment( connected_n_c_sses.First(), n_terminal_sse_is_rigid));

          std::pair< storage::Set< LoopSegment, LoopSegmentSequenceOrder>::const_iterator, bool> status
          (
            loop_domain->ReplaceSegment( connected_n_c_sses.Second())
          );

          // set a to position of last replaced segment and b to next segment
          segment_itr_a = status.first;
          segment_itr_b = segment_itr_a;
          ++segment_itr_b;
        }
      }

      // new protein model
      util::ShPtr< assemble::ProteinModel> new_protein_model( PROTEIN_MODEL.Clone());

      // iterate through the loop domain and replace the sses in the protein model
      util::ShPtr< assemble::ProteinModel> replaced_sse_model
      (
        loop_domain->UpdateProteinModel( *new_protein_model)
      );

      // create mutate result from "replaced_sse_model"
      math::MutateResult< assemble::ProteinModel> mutate_result( replaced_sse_model, *this);

      // return "mutate_result"
      return mutate_result;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelLoopDomainGrow::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_LocatorLoopDomain, ISTREAM);
      io::Serialize::Read( m_PhiPsiGenerator, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelLoopDomainGrow::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_LocatorLoopDomain, OSTREAM, INDENT);
      io::Serialize::Write( m_PhiPsiGenerator, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief ConnectNonRigidSSE connects a non rigid c-terminal sse to an n-terminal anchor sse
    //! @param N_TERMINAL_SSE the sse which will have a c-terminal portion connected to it
    //! @param C_TERMINAL_SSE the non-rigid c-terminal sse which will be connected to "N_TERMINAL_SSE"
    util::ShPtr< assemble::SSE> MutateProteinModelLoopDomainGrow::ConnectNonRigidSSE
    (
      const assemble::SSE &N_TERMINAL_SSE, const assemble::SSE &C_TERMINAL_SSE
    ) const
    {
      // create a MutateAASequenceGrow to be used for growing the c-terminal sequence
      const MutateAASequenceGrow grower( m_PhiPsiGenerator, util::SiPtr< const biol::AASequence>( N_TERMINAL_SSE));

      // grow the c-terminal sequence onto the n-terminal sequence and get the resulting aasequence
      const util::ShPtr< biol::AASequence> connected_sequence( grower( C_TERMINAL_SSE).GetArgument());

      // make sure the new aa sequence is defined
      BCL_Assert( connected_sequence.IsDefined(), "connected sequence is not defined");

      // make sure the sizes add up for the connected sequence and the two unconnected sequences
      BCL_Assert
      (
        connected_sequence->GetSize() == ( N_TERMINAL_SSE.GetSize() + C_TERMINAL_SSE.GetSize()),
        "size is " + util::Format()( connected_sequence->GetSize()) + " but should be " +
        util::Format()( N_TERMINAL_SSE.GetSize() + C_TERMINAL_SSE.GetSize())
      );

      // make new sse for c-terminal loop segment sequence
      const util::ShPtr< assemble::SSE> new_cterminal_loop_segment
      (
        new assemble::SSE
        (
          connected_sequence->SubSequence( N_TERMINAL_SSE.GetSize(), C_TERMINAL_SSE.GetSize()),
          C_TERMINAL_SSE.GetType()
        )
      );

      return new_cterminal_loop_segment;
    }

    //! @brief ConnectRigidSequence connects a non rigid c-terminal sse to an n-terminal anchor sse
    //! @param N_TERMINAL_SSE the sse which will have a c-terminal portion connected to it
    //! @param C_TERMINAL_SEQUENCE
    //! @param C_TERMINAL_SSES the non-rigid c-terminal sse which will be connected to "N_TERMINAL_SSE"
    storage::Pair< util::ShPtr< assemble::SSE>, storage::List< LoopSegment> >
    MutateProteinModelLoopDomainGrow::ConnectRigidSequence
    (
      const assemble::SSE &N_TERMINAL_SSE,
      const biol::AASequence &C_TERMINAL_SEQUENCE,
      const storage::List< LoopSegment> &C_TERMINAL_SSES
    ) const
    {
      // create a MutationResidue object for the first residue in "C_TERMINAL_SEQUENCE"
      MutationResidue c_terminal_start_mutation_residue
      (
        C_TERMINAL_SEQUENCE.GetFirstAA(),
        N_TERMINAL_SSE.GetLastAA(),
        util::ShPtr< biol::AABase>()
      );

      // create a MutationResidue object for the last residue in "n_terminal_sse"
      MutationResidue n_terminal_end_mutation_residue
      (
        N_TERMINAL_SSE.GetLastAA(),
        util::ShPtr< biol::AABase>(),
        C_TERMINAL_SEQUENCE.GetFirstAA()
      );

      // get the phi that the first residue in "C_TERMINAL_SEQUENCE" will have
      const double phi( m_PhiPsiGenerator->operator()( c_terminal_start_mutation_residue).First());

      // make sure phi is defined
      BCL_Assert( util::IsDefined( phi), "phi is not defined");

      // get the psi that the last residue in "n_terminal_sse" will have
      const double psi( m_PhiPsiGenerator->operator()( n_terminal_end_mutation_residue).Second());

      // make sure psi is defined
      BCL_Assert( util::IsDefined( psi), "psi is not defined");

      // connect "C_TERMINAL_SEQUENCE" and "n_terminal_sse" and get the ShPtr to the new connected sequence
      util::ShPtr< biol::AASequence> connected_sequence( new biol::AASequence( N_TERMINAL_SSE));
      biol::AASequenceFactory::AppendSequence( *connected_sequence, C_TERMINAL_SEQUENCE, phi, psi);

      // set a size_t to zero to which will keep track of the starting positions of sses in "connected_sequence"
      size_t sse_start_index( 0);

      // update the nterminal sse
      // make new sse for nterminal sse
      util::ShPtr< assemble::SSE> new_nterminal_sse
      (
        new assemble::SSE
        (
          connected_sequence->SubSequence( 0, N_TERMINAL_SSE.GetSize()), N_TERMINAL_SSE.GetType()
        )
      );

      // increase sse start index by the size of "n_terminal_sse"
      sse_start_index += N_TERMINAL_SSE.GetSize();

      storage::List< LoopSegment> new_sses;

      // update the c-terminal sses
      for
      (
        storage::List< LoopSegment>::const_iterator
          c_terminal_sses_itr( C_TERMINAL_SSES.Begin()), c_terminal_sses_itr_end( C_TERMINAL_SSES.End());
        c_terminal_sses_itr != c_terminal_sses_itr_end;
        ++c_terminal_sses_itr
      )
      {
        // get shptr to current sse denoted by "c_terminal_sses_itr"
        const assemble::SSE &current_sse( *c_terminal_sses_itr->GetSSE());

        // get identifier of "current_sse_identifier" which will be used as a correctness check
        const std::string current_sse_identifier( current_sse.GetIdentification());

        // make new sse for current sse
        util::ShPtr< assemble::SSE> new_current_sse
        (
          new assemble::SSE
          (
            connected_sequence->SubSequence( sse_start_index, current_sse.GetSize()), current_sse.GetType()
          )
        );

        // increase "sse_start_index" to the position of the start of the next sse
        sse_start_index += current_sse.GetSize();

        new_sses.PushBack( LoopSegment( new_current_sse, c_terminal_sses_itr->IsRigid()));

        // get the identification of the changed "current_sse"
        const std::string new_current_sse_identifier( current_sse.GetIdentification());

        // make sure the two identifications are the same, otherwise something went wrong
        BCL_Assert
        (
          current_sse_identifier == new_current_sse_identifier, "after setting sse the identifier has changed from " +
          current_sse_identifier + " to " + new_current_sse_identifier
        );
      }

      return storage::Pair< util::ShPtr< assemble::SSE>, storage::List< LoopSegment> >( new_nterminal_sse, new_sses);
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_loop_resize.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_aa_sequence_factory.h"
#include "fold/bcl_fold_mutation_residue.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelLoopResize::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelLoopResize())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelLoopResize::MutateProteinModelLoopResize() :
      MutateProteinModelSSEResize(),
      m_MaxSSESizes(),
      m_PhiPsiGenerator()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param LOCATOR locator that decides which sse in the protein model to mutate
    //! @param EXTEND_PROBABILITY probability for extending (1.0 - EXTEND_PROBABILITY for shrinking)
    //! @param LENGTH_CHANGE_RANGE range of number of residues that are to be added or removed in one mutate to one end
    //! @param MIN_SSE_SIZES minimum SSE sizes to be allowed when shrinking
    //! @param MAX_SSE_SIZES minimum SSE sizes to be allowed when extending
    //! @param GROWING_DIRECTION the side of the sse that changes will occur on
    //! @param PHI_PSI_GENERATOR the method that will be used in order to generate phi and psi angles if extending
    //! @param GROWING_DIRECTION the side of the sse that changes will occur on
    //! @param DISALLOW_OVERLAP true if extension of sse into neighboring sse is not allowed-else (replaces both sses)
    //! @param SCHEME the scheme of this mutate
    MutateProteinModelLoopResize::MutateProteinModelLoopResize
    (
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &LOCATOR,
      const double &EXTEND_PROBABILITY,
      const math::Range< size_t> &LENGTH_CHANGE_RANGE,
      const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES,
      const storage::Map< biol::SSType, size_t> &MAX_SSE_SIZES,
      const biol::AASequenceFlexibility::SequenceDirection &GROWING_DIRECTION,
      const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GENERATOR,
      const bool DISALLOW_OVERLAP,
      const std::string &SCHEME
    ) :
      MutateProteinModelSSEResize
      (
        LOCATOR, EXTEND_PROBABILITY, LENGTH_CHANGE_RANGE, GROWING_DIRECTION, false, MIN_SSE_SIZES, SCHEME
      ),
      m_MaxSSESizes( MAX_SSE_SIZES),
      m_PhiPsiGenerator( PHI_PSI_GENERATOR),
      m_DisallowOverlap( DISALLOW_OVERLAP)
    {
      BCL_Assert
      (
        m_Side == biol::AASequenceFlexibility::e_NTerminal ||
        m_Side == biol::AASequenceFlexibility::e_CTerminal,
        "Can only grow loops in either "
        + biol::AASequenceFlexibility::DirectionEnum( biol::AASequenceFlexibility::e_NTerminal).GetString()
        + " or "
        + biol::AASequenceFlexibility::DirectionEnum( biol::AASequenceFlexibility::e_CTerminal).GetString()
        + " direction but specified as "
        + biol::AASequenceFlexibility::DirectionEnum( m_Side).GetString()
      );
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelLoopResize
    MutateProteinModelLoopResize *MutateProteinModelLoopResize::Clone() const
    {
      return new MutateProteinModelLoopResize( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelLoopResize::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator taking an ARGUMENT and returning a mutated object of t_ArgumentType
    //! @param PROTEIN_MODEL Argument of interest
    //! @return MutateResult that results from mutating to the argument
    math::MutateResult< assemble::ProteinModel> MutateProteinModelLoopResize::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model pointer
      const math::MutateResult< assemble::ProteinModel> empty_result( util::ShPtr< assemble::ProteinModel>(), *this);

      // locate sse to grow
      const util::SiPtr< const assemble::SSE> located_sse( m_SSELocator->Locate( PROTEIN_MODEL));

      // if sse cannot be located
      if( !located_sse.IsDefined())
      {
        // return empty result
        return empty_result;
      }

      // report selected sse to be extended/shrunk
      BCL_MessageDbg( "selected sse to be extended/shrunk: " + located_sse->GetIdentification());

      // determine whether to extend or shrink
      const bool extend( random::GetGlobalRandom().Double() <= m_ExtendProbability);

      // determine step size
      const size_t step_size( random::GetGlobalRandom().Random< size_t>( m_LengthChangeRange));

      // make a ShPtr to an SSE
      util::ShPtr< assemble::SSE> new_sse;

      // true if sse will shrink
      if( !extend)
      {
        // find the min sse size
        const storage::Map< biol::SSType, size_t>::const_iterator itr( m_MinSSESizes.Find( located_sse->GetType()));
        const size_t min_sse_size( itr == m_MinSSESizes.End() ? 0 : itr->second);

        // is sse long enough
        if( step_size > located_sse->GetSize())
        {
          return empty_result;
        }

        // calculate the size of SSE after the shrinking
        const size_t length_after_shrink( located_sse->GetSize() - step_size);

        // is the sse long enough after shrinking
        if( length_after_shrink < min_sse_size)
        {
          return empty_result;
        }

        // true if the n terminus of sse is being shrunk
        switch( m_Side)
        {
          case biol::AASequenceFlexibility::e_NTerminal:
          {
            new_sse =
              util::ShPtr< assemble::SSE>
              (
                new assemble::SSE( located_sse->SubSequence( step_size, length_after_shrink), located_sse->GetType())
              );
            break;
          }
          case biol::AASequenceFlexibility::e_CTerminal:
          {
            new_sse =
              util::ShPtr< assemble::SSE>
              (
                new assemble::SSE( located_sse->SubSequence( 0, length_after_shrink), located_sse->GetType())
              );
            break;
          }
          default:
            return empty_result;
        }
      }

      // sse will be extended
      else
      {
        // find the max sse size
        const storage::Map< biol::SSType, size_t>::const_iterator itr( m_MaxSSESizes.Find( located_sse->GetType()));
        const size_t max_sse_size( itr == m_MaxSSESizes.End() ? util::GetUndefined< size_t>() : itr->second);

        // determine how many residues to extend
        const size_t extend_size( random::GetGlobalRandom().Random< size_t>( m_LengthChangeRange));

        // sse too long
        if( located_sse->GetSize() + extend_size > max_sse_size)
        {
          return empty_result;
        }

        // check for overlap
        if( m_DisallowOverlap && WillOverlap( PROTEIN_MODEL, extend_size, *located_sse, m_Side))
        {
          // return empty result
          return empty_result;
        }

        // create a copy of the located SSE and store it in new_sse
        new_sse = util::ShPtr< assemble::SSE>( located_sse->Clone());

        // create a reference to the sequence
        const biol::AASequence &full_sequence( *PROTEIN_MODEL.GetChain( located_sse->GetChainID())->GetSequence());

        // true if extend on n terminal side
        if( m_Side == biol::AASequenceFlexibility::e_NTerminal)
        {
          const biol::AASequence subsequence( full_sequence.SubSequence( located_sse->GetFirstAA()->GetSeqID() - extend_size - 1, extend_size));
          BCL_MessageDbg( "subsequence size for prepending " + util::Format()( subsequence.GetSize()));
          new_sse = PrependSequence( *located_sse, subsequence);
        }

        // true if extend on c terminal side
        else if( m_Side == biol::AASequenceFlexibility::e_CTerminal)
        {
          const biol::AASequence subsequence( full_sequence.SubSequence( located_sse->GetLastAA()->GetSeqID(), extend_size));
          BCL_MessageDbg( "subsequence size for appending " + util::Format()( subsequence.GetSize()));
          BCL_MessageDbg( "subsequence appending " + util::Format()( subsequence.GetSequenceIdentification()));
          new_sse = AppendSequence( *located_sse, subsequence);
        }
      }

      // print out sse after extend/shrink
      BCL_MessageDbg( "sse after extended/shrunk: " + new_sse->GetIdentification());

      // copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // insert the new SSE by replacing the old one
      if( new_sse->GetSize() > 0)
      {
        new_model->ReplaceWithOverlapping( new_sse);
      }
      else
      {
        new_model->Remove( *located_sse);
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelLoopResize::Read( std::istream &ISTREAM)
    {
      // read members
      MutateProteinModelSSEResize::Read( ISTREAM);
      io::Serialize::Read( m_MaxSSESizes    , ISTREAM);
      io::Serialize::Read( m_PhiPsiGenerator, ISTREAM);
      io::Serialize::Read( m_DisallowOverlap, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelLoopResize::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      MutateProteinModelSSEResize::Write(      OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MaxSSESizes    , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PhiPsiGenerator, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_DisallowOverlap, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief prepends an aa sequence to the nterminal side of an sse
    //! @param SSE the sse to which a sequence will be prepended
    //! @param SEQUENCE the sequence that will be prepended to the sse
    //! @return sse which has been created by prepending the provided sequence onto n-terminus of the sse
    util::ShPtr< assemble::SSE>
    MutateProteinModelLoopResize::PrependSequence( const assemble::SSE &SSE, const biol::AASequence &SEQUENCE) const
    {
      util::ShPtr< assemble::SSE> new_sse( SSE.Clone());

      // iterate over the sequence to prepend it
      for
      (
        biol::AASequence::const_reverse_iterator aa_itr( SEQUENCE.ReverseBegin()), aa_itr_end( SEQUENCE.ReverseEnd());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // copy aa and set to strand ideal conformation
        util::ShPtr< biol::AABase> new_aa( ( *aa_itr)->Clone());
        new_aa->SetToIdealConformation( biol::GetSSTypes().STRAND, math::TransformationMatrix3D());

        // get the phi psi angles
        const MutationResidue mutation_resi( new_aa, util::ShPtr< biol::AABase>(), util::ShPtr< biol::AABase>());
        const storage::VectorND< 2, double> phi_psi( m_PhiPsiGenerator->operator ()( mutation_resi));
        BCL_MessageDbg( "PrependSequence phi psi is " + util::Format()( phi_psi));

        // prepend the current aa to the sse
        BCL_MessageDbg( "Prepending residue " + new_aa->GetIdentification() + " onto sse " + new_sse->GetIdentification());
        biol::AASequenceFactory::PrependAA( *new_aa, *new_sse, phi_psi.First(), phi_psi.Second());
        BCL_MessageDbg( "prepended " + new_aa->GetIdentification());
      }

      return new_sse;
    }

    //! @brief appends an aa sequence to the cterminal side of an sse
    //! @param SSE the sse to which a sequence will be appended
    //! @param SEQUENCE the sequence that will be appended to the sse
    //! @return sse which has been created by appending the provided sequence onto c-terminus of the sse
    util::ShPtr< assemble::SSE>
    MutateProteinModelLoopResize::AppendSequence( const assemble::SSE &SSE, const biol::AASequence &SEQUENCE) const
    {
      util::ShPtr< assemble::SSE> new_sse( SSE.Clone());

      // iterate over the sequence to append it
      for
      (
        biol::AASequence::const_iterator aa_itr( SEQUENCE.Begin()), aa_itr_end( SEQUENCE.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // copy aa and set to strand ideal conformation
        util::ShPtr< biol::AABase> new_aa( ( *aa_itr)->Clone());
        new_aa->SetToIdealConformation( biol::GetSSTypes().STRAND, math::TransformationMatrix3D());

        // get the phi psi angles
        const MutationResidue mutation_resi( new_aa, util::ShPtr< biol::AABase>(), util::ShPtr< biol::AABase>());
        const storage::VectorND< 2, double> phi_psi( m_PhiPsiGenerator->operator ()( mutation_resi));
        BCL_MessageDbg( "AppendSequence phi psi is " + util::Format()( phi_psi));
        BCL_MessageDbg( "Appending residue " + new_aa->GetIdentification() + " onto sse " + new_sse->GetIdentification());

        // prepend the current aa to the sse
        biol::AASequenceFactory::AppendAA( *new_sse, *new_aa, phi_psi.First(), phi_psi.Second());
        BCL_MessageDbg( "appended " + new_aa->GetIdentification());
      }

      return new_sse;
    }

    bool MutateProteinModelLoopResize::WillOverlap
    (
      const assemble::ProteinModel &MODEL, const size_t EXTENSION_AMOUNT, const assemble::SSE &CURRENT_SSE,
      const biol::AASequenceFlexibility::SequenceDirection &EXTENSION_DIRECTION
    )
    {
      // make sure that extending won't overlap with neighboring sse
      const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > neighbor_sses
      (
        MODEL.GetNeighborSSEs( CURRENT_SSE)
      );

      // true if the left neighbor is defined and extension will occur on the nterminal side
      if( neighbor_sses.First().IsDefined() && EXTENSION_DIRECTION == biol::AASequenceFlexibility::e_NTerminal)
      {
        const assemble::SSE &left_sse( *neighbor_sses.First());

        const int current_sse_seq_id( CURRENT_SSE.GetFirstAA()->GetSeqID());
        const int left_sse_seq_id( left_sse.GetLastAA()->GetSeqID());

        // true if the sses will overlap
        if( left_sse_seq_id + int( EXTENSION_AMOUNT) >= current_sse_seq_id)
        {
          BCL_MessageDbg
          (
            "extending " + CURRENT_SSE.GetIdentification() + " by "
            + util::Format()( EXTENSION_AMOUNT) + " will overlap with sse " + left_sse.GetIdentification()
          );
          return true;
        }
      }
      else if( EXTENSION_DIRECTION == biol::AASequenceFlexibility::e_NTerminal)//< ntermini
      {
        // not enough residues prior in sequence to add
        if( int( CURRENT_SSE.GetFirstAA()->GetSeqID() - int( EXTENSION_AMOUNT)) < int( 1))
        {
          BCL_MessageDbg
          (
            "extending " + CURRENT_SSE.GetIdentification() + " by "
            + util::Format()( EXTENSION_AMOUNT) + " will run out of sequence to add"
          );
          return true;
        }
      }

      // true if the right neighbor is defined and extension will occur on the cterminal side
      if( neighbor_sses.Second().IsDefined() && EXTENSION_DIRECTION == biol::AASequenceFlexibility::e_CTerminal)
      {
        const assemble::SSE &right_sse( *neighbor_sses.Second());

        const int current_sse_seq_id( CURRENT_SSE.GetLastAA()->GetSeqID());
        const int right_sse_seq_id( right_sse.GetFirstAA()->GetSeqID());

        // true if the sses will overlap
        if( current_sse_seq_id + int( EXTENSION_AMOUNT) >= right_sse_seq_id)
        {
          BCL_MessageDbg
          (
            "extending " + CURRENT_SSE.GetIdentification() + " by "
            + util::Format()( EXTENSION_AMOUNT) + " will overlap with sse " + right_sse.GetIdentification()
          );
          return true;
        }
      }
      else if( EXTENSION_DIRECTION == biol::AASequenceFlexibility::e_CTerminal) //< ctermini
      {
        // not enough residues at end of sequence to add
        const int cterm_seq_id( MODEL.GetChain( CURRENT_SSE.GetChainID())->GetSequence()->GetLastAA()->GetSeqID());
        if
        (
          int( cterm_seq_id - CURRENT_SSE.GetLastAA()->GetSeqID()) < int( EXTENSION_AMOUNT)
        )
        {
          BCL_MessageDbg
          (
            "extending " + CURRENT_SSE.GetIdentification() + " by "
            + util::Format()( EXTENSION_AMOUNT) + " will run out of sequence to add"
          );
          return true;
        }
      }

      return false;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_move_aa.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelMoveAA::s_Instance
    (
      GetObjectInstances().AddInstance
      (
        new MutateProteinModelMoveAA
        (
          util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> >(),
          math::Range< size_t>( 1, 1),
          biol::AASequenceFlexibility::s_NumberSequenceDirections,
          storage::Map< biol::SSType, size_t>(),
          util::ShPtr< math::MutateInterface< assemble::SSE> >(),
          ""
        )
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from max number of residues to move
    //! @param SSE_LOCATOR locator that decides which SSE in the protein model to find an adjacent one to
    //! @param RESIDUES_TO_MOVE_RANGE range of number of residues to move
    //! @param SEQUENCE_SIDE side on sequence to move aas
    //! @param MIN_SSE_SIZE minimum SSE sizes to be allowed as result after moving aas
    //! @param SP_MUTATE_LOCATED_SSE optional mutate that is applied to the located and modified sse before it is added to the model
    //! @param SCHEME the scheme
    MutateProteinModelMoveAA::MutateProteinModelMoveAA
    (
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &SSE_LOCATOR,
      const math::Range< size_t> &RESIDUES_TO_MOVE_RANGE,
      const biol::AASequenceFlexibility::SequenceDirection &SEQUENCE_SIDE,
      const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE,
      const util::ShPtr< math::MutateInterface< assemble::SSE> > &SP_MUTATE_LOCATED_SSE,
      const std::string &SCHEME
    ) :
      m_SSELocator( SSE_LOCATOR),
      m_ResdiuesToMoveRange( RESIDUES_TO_MOVE_RANGE),
      m_SSESide( SEQUENCE_SIDE),
      m_MinSSESize( MIN_SSE_SIZE),
      m_MutateLocatedSSE( SP_MUTATE_LOCATED_SSE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelMoveAA
    MutateProteinModelMoveAA *MutateProteinModelMoveAA::Clone() const
    {
      return new MutateProteinModelMoveAA( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelMoveAA::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &MutateProteinModelMoveAA::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that mutates a protein model by shifting AAs between SSEs
    //! @param PROTEIN_MODEL
    //! @return MutateResult that results from mutating to the PROTEIN_MODEL
    math::MutateResult< assemble::ProteinModel>
    MutateProteinModelMoveAA::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // empty result
      const math::MutateResult< assemble::ProteinModel> empty_result( util::ShPtr< assemble::ProteinModel>(), *this);

      // locate the sse in the protein model
      const util::SiPtr< const assemble::SSE> located_sse( m_SSELocator->Locate( PROTEIN_MODEL));

      // was sse located
      if( !located_sse.IsDefined())
      {
        return empty_result;
      }

      // find adjacent sse
      const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > adjacent_sses( PROTEIN_MODEL.GetAdjacentSSEs( *located_sse));

      util::SiPtr< const assemble::SSE> sse1;
      util::SiPtr< const assemble::SSE> sse2;

      size_t nr_res( random::GetGlobalRandom().Random( m_ResdiuesToMoveRange));

      // update sses according to sequence direction
      if( m_SSESide == biol::AASequenceFlexibility::e_NTerminal && adjacent_sses.First().IsDefined())
      {
        sse1 = adjacent_sses.First();
        sse2 = located_sse;
        // check if length after move is still acceptable
        const storage::Map< biol::SSType, size_t>::const_iterator min_sse_size_itr( m_MinSSESize.Find( sse1->GetType()));
        if
        (
             min_sse_size_itr != m_MinSSESize.End()
          && min_sse_size_itr->second + nr_res > sse1->GetSize()
        )
        {
          BCL_MessageVrb
          (
            "cannot move " + util::Format()( nr_res) + " aas, since the resulting sse would be too short: " +
            sse1->GetIdentification() + "\t" + " min size: " + util::Format()( min_sse_size_itr->second)
          )
          return empty_result;
        }
      }
      else if( m_SSESide == biol::AASequenceFlexibility::e_CTerminal && adjacent_sses.Second().IsDefined())
      {
        sse1 = located_sse;
        sse2 = adjacent_sses.Second();
        const storage::Map< biol::SSType, size_t>::const_iterator min_sse_size_itr( m_MinSSESize.Find( sse2->GetType()));
        if
        (
             min_sse_size_itr != m_MinSSESize.End()
          && min_sse_size_itr->second + nr_res > sse2->GetSize()
        )
        {
          BCL_MessageVrb
          (
            "cannot move " + util::Format()( nr_res) + " aas, since the resulting sse would be too short: " +
            sse2->GetIdentification() + "\t" + " min size: " + util::Format()( min_sse_size_itr->second)
          )
          return empty_result;
        }
      }
      // no adjacent sse for the sequence side was found
      else
      {
        return empty_result;
      }

      // create two new sses
      const biol::AASequenceFlexibility::SequenceDirection move_direction
      (
        m_SSESide == biol::AASequenceFlexibility::e_NTerminal ? biol::AASequenceFlexibility::e_CTerminal : biol::AASequenceFlexibility::e_NTerminal
      );
      storage::VectorND< 2, util::ShPtr< assemble::SSE> > moved_sses( MoveAAs( *sse1, *sse2, nr_res, move_direction));

      // unsuccessful move
      if( !moved_sses.First().IsDefined() && !moved_sses.Second().IsDefined())
      {
        return empty_result;
      }

      // mutate sse if desired
      if( m_MutateLocatedSSE.IsDefined())
      {
        // mutate the second sse, which was the previously located
        if( m_SSESide == biol::AASequenceFlexibility::e_NTerminal && moved_sses.Second().IsDefined())
        {
          const math::MutateResult< assemble::SSE> result_sse_mutate( m_MutateLocatedSSE->operator ()( *moved_sses.Second()));
          if( result_sse_mutate.GetArgument().IsDefined())
          {
            moved_sses.Second() = result_sse_mutate.GetArgument();
          }
        }
        // mutate the first sse, which was the previously located
        else if( m_SSESide == biol::AASequenceFlexibility::e_CTerminal && moved_sses.First().IsDefined())
        {
          const math::MutateResult< assemble::SSE> result_sse_mutate( m_MutateLocatedSSE->operator ()( *moved_sses.First()));
          if( result_sse_mutate.GetArgument().IsDefined())
          {
            moved_sses.First() = result_sse_mutate.GetArgument();
          }
        }
      }

      // create new protein model
      util::ShPtr< assemble::ProteinModel> sp_new_model( PROTEIN_MODEL.Clone());
      sp_new_model->Remove( *sse1);
      sp_new_model->Remove( *sse2);

      // replace the old sses with the new sses
      if( moved_sses.First().IsDefined())
      {
        sp_new_model->Insert( moved_sses.First());
      }
      if( moved_sses.Second().IsDefined())
      {
        sp_new_model->Insert( moved_sses.Second());
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( sp_new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelMoveAA::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSELocator         , ISTREAM);
      io::Serialize::Read( m_ResdiuesToMoveRange, ISTREAM);
      io::Serialize::Read( m_Scheme             , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelMoveAA::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSELocator         , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ResdiuesToMoveRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme             , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief move a given number of amino acids in a given direction between two adjacent sses
    //! @param SSE_LEFT n-terminal SSE
    //! @param SSE_RIGHT c-terminal SSE
    //! @param NUMBER_AAS the number of amino acids to move from one sse to another
    //! @param DIRECTION the sequence direstion - c-terminal move from left to right, n-terminal right to left
    //! @return 2 new SSE with the same type as the given ones - if the number of AAs was larger than the size, the
    //!         ShPtr will be undefined
    storage::VectorND< 2, util::ShPtr< assemble::SSE> > MutateProteinModelMoveAA::MoveAAs
    (
      const assemble::SSE &SSE_LEFT,
      const assemble::SSE &SSE_RIGHT,
      const size_t NUMBER_AAS,
      const biol::AASequenceFlexibility::SequenceDirection &DIRECTION
    )
    {
      storage::VectorND< 2, util::ShPtr< assemble::SSE> > result;

      BCL_MessageDbg( "sses before moving aa:\n" + SSE_LEFT.GetIdentification() + '\n' + SSE_RIGHT.GetIdentification());

      // true if the distance is not defined
      if( !biol::AABase::AreAminoAcidsPeptideBonded( *SSE_LEFT.GetLastAA(), *SSE_RIGHT.GetFirstAA(), true))
      {
        BCL_MessageCrt( "cannot move amino acids between SSEs that are not peptide bonded!");
        return result;
      }

      // copy of nr aas, in case they need to be corrected
      size_t nr_res( NUMBER_AAS);

      // move residues up in sequence to next SSE
      if( DIRECTION == biol::AASequenceFlexibility::e_CTerminal)
      {
        BCL_MessageDbg( "sses after moving aa:");
        if( nr_res < SSE_LEFT.GetSize())
        {
          result.First() = util::ShPtr< assemble::SSE>( new assemble::SSE( SSE_LEFT.SubSequence( 0, SSE_LEFT.GetSize() - nr_res), SSE_LEFT.GetType()));
          BCL_MessageDbg( result.First()->GetIdentification());
        }

        // reduce the number of residues if necessary
        nr_res = std::min( nr_res, SSE_LEFT.GetSize());

        // sequence for other sse
        biol::AASequence seq2( SSE_RIGHT);
        seq2.PrependSequence( SSE_LEFT.SubSequence( SSE_LEFT.GetSize() - nr_res, nr_res));

        // new sse
        result.Second() = util::ShPtr< assemble::SSE>( new assemble::SSE( seq2, SSE_RIGHT.GetType()));
        BCL_MessageDbg( result.Second()->GetIdentification());
      }
      // move residues down in sequence to previous sse
      else if( DIRECTION == biol::AASequenceFlexibility::e_NTerminal)
      {
        BCL_MessageDbg( "sses after moving aa:");
        if( nr_res < SSE_RIGHT.GetSize())
        {
          result.Second() = util::ShPtr< assemble::SSE>( new assemble::SSE( SSE_RIGHT.SubSequence( nr_res, SSE_RIGHT.GetSize() - nr_res), SSE_RIGHT.GetType()));
          BCL_MessageDbg( result.Second()->GetIdentification());
        }

        // reduce the number of residues if necessary
        nr_res = std::min( nr_res, SSE_RIGHT.GetSize());
        biol::AASequence seq1( SSE_LEFT);
        seq1.AppendSequence( SSE_RIGHT.SubSequence( 0, nr_res));

        // new sse
        result.First() = util::ShPtr< assemble::SSE>( new assemble::SSE( seq1, SSE_LEFT.GetType()));
        BCL_MessageDbg( result.First()->GetIdentification());
      }

      // end
      return result;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_multiple_geometries.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_fold_template_handler.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_pool.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelMultipleGeometries::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelMultipleGeometries())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelMultipleGeometries::MutateProteinModelMultipleGeometries() :
      m_FoldTemplate(),
      m_TemplateSizeProbabilities( 0.0, 1.0, 0.0),
      m_Scheme( GetStaticClassName< MutateProteinModelMultipleGeometries>())
    {
    }

    //! @brief constructor from a fold template and scheme
    //! @param FOLD_TEMPLATE fold template to be used
    //! @param SCHEME Scheme to be used
    MutateProteinModelMultipleGeometries::MutateProteinModelMultipleGeometries
    (
      const assemble::FoldTemplate &FOLD_TEMPLATE,
      const std::string &SCHEME
    ) :
      m_FoldTemplate( FOLD_TEMPLATE),
      m_TemplateSizeProbabilities( 0.0, 1.0, 0.0),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from a fold template handler and scheme
    //! @param PROBABILITIES probability of fitting into a small, equal, or large template, respectively
    //! @param SCHEME Scheme to be used
    MutateProteinModelMultipleGeometries::MutateProteinModelMultipleGeometries
    (
      const storage::VectorND< 3, double> &PROBABILITIES,
      const std::string &SCHEME
    ) :
      m_FoldTemplate(),
      m_TemplateSizeProbabilities( PROBABILITIES),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelMultipleGeometries
    MutateProteinModelMultipleGeometries *MutateProteinModelMultipleGeometries::Clone() const
    {
      return new MutateProteinModelMultipleGeometries( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelMultipleGeometries::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator taking a protein model and returning a mutate object of protein model type
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelMultipleGeometries::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      BCL_Assert( sp_pool.IsDefined(), "No pool stored for the given model");

      // get non-overlapping SSEs from the pool
      storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> pool_no_overlap
      (
        sp_pool->GetRandomNonOverlappingSet()
      );

      // if no sses were found
      if( pool_no_overlap.IsEmpty())
      {
        // return an empty model
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // initialize vector of helices and strands
      util::SiPtrVector< const assemble::SSE> combined_sses( pool_no_overlap.Begin(), pool_no_overlap.End());

      // copy the fold template member so that it can be changed if it is empty
      assemble::FoldTemplate fold_template( m_FoldTemplate);

      // check if the given fold template is empty
      if( fold_template.GetGeometries().IsEmpty())
      {
        // get a random number based on the probabilities (between 0 and the sum)
        double random_double
        (
          random::GetGlobalRandom().Double
          (
            math::Range< double>
            (
              0.0,
              m_TemplateSizeProbabilities.First() +
              m_TemplateSizeProbabilities.Second() +
              m_TemplateSizeProbabilities.Third()
            )
          )
        );

        // if fitting into a small template
        if( random_double <= m_TemplateSizeProbabilities.First())
        {
          // remove roughly 1/3 of the SSEs
          for( size_t i( 0), i_end( combined_sses.GetSize() / 3); i != i_end; ++i)
          {
            combined_sses.RemoveRandomElement();
          }
        }

        // if fitting into a small or equal template
        if( random_double <= m_TemplateSizeProbabilities.First() + m_TemplateSizeProbabilities.Second())
        {
          fold_template = assemble::FoldTemplateHandler::GetRandomTemplate( combined_sses);
        }
        // if fitting into a large template
        else
        {
          fold_template = assemble::FoldTemplateHandler::GetRandomSubTemplate( combined_sses);
        }
      }

      // if the fold template is empty, return an empty model
      if( fold_template.GetGeometries().IsEmpty())
      {
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      BCL_MessageVrb
      (
        "Using fold template from PDB ID " + fold_template.GetPDBID() + " for the mutate"
      );

      // fit the SSEs to the fold template which returns a domain
      const assemble::Domain fitted_domain( fold_template.FitSSEs( combined_sses));

      // get a new protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // iterate through the SSEs in the domain
      const util::SiPtrVector< const assemble::SSE> domain_sses( fitted_domain.GetSSEs());
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator sse_itr( domain_sses.Begin()),
          sse_itr_end( domain_sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // insert the SSE into the model
        new_model->Insert( util::ShPtr< assemble::SSE>( ( *sse_itr)->Clone()));
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelMultipleGeometries::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_FoldTemplate, ISTREAM);
      io::Serialize::Read( m_TemplateSizeProbabilities, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelMultipleGeometries::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_FoldTemplate, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_TemplateSizeProbabilities, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_pair_strands.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sheet.h"
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_placement_strand_next_to_sheet.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelPairStrands::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelPairStrands())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a scheme
    MutateProteinModelPairStrands::MutateProteinModelPairStrands() :
      m_Scheme( GetStaticClassName< MutateProteinModelPairStrands>())
    {
    }

    //! @brief constructor from a scheme
    //! @param SCHEME scheme of this mutate
    MutateProteinModelPairStrands::MutateProteinModelPairStrands( const std::string &SCHEME) :
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelPairStrands
    MutateProteinModelPairStrands *MutateProteinModelPairStrands::Clone() const
    {
      return new MutateProteinModelPairStrands( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelPairStrands::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelPairStrands::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize static failure return value
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // if no or only one strand in the model
      if( PROTEIN_MODEL.GetNumberSSE( biol::GetSSTypes().STRAND) <= 1)
      {
        BCL_MessageVrb( "One or less strands in this model yet, skipping pairing strands");
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }
      // collect all the Sheets in the model
      util::ShPtrVector< assemble::Domain> sheets_unfiltered( assemble::CollectorSheet().Collect( PROTEIN_MODEL));
      util::ShPtrVector< assemble::Domain> sheets;

      // iterate over the sheet
      for
      (
        util::ShPtrVector< assemble::Domain>::iterator
          sheet_itr( sheets_unfiltered.Begin()), sheet_itr_end( sheets_unfiltered.End());
        sheet_itr != sheet_itr_end; ++sheet_itr
      )
      {
        // if the sheet is of type beta-barrel then remove it
        if( ( *sheet_itr)->GetTopology()->GetType() == assemble::Topology::e_Sheet)
        {
          sheets.PushBack( *sheet_itr);
        }
      }

      // if there is only one sheet ( which will happen with one sheet with at least two strands in it
      if( sheets.GetSize() == 1)
      {
        BCL_MessageVrb( "Only one sheet found in this model yet, skipping pairing strands");
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // initialize vector to store individual strands that are not in any sheet
      util::ShPtrVector< assemble::Domain> sheets_with_single_strands;

      // iterate over the sheets
      for
      (
        util::ShPtrVector< assemble::Domain>::iterator sheet_itr( sheets.Begin()), sheet_itr_end( sheets.End());
        sheet_itr != sheet_itr_end; ++sheet_itr
      )
      {
        // if there is only one strand in the Sheet
        if( ( *sheet_itr)->GetNumberSSEs() == 1)
        {
          sheets_with_single_strands.PushBack( *sheet_itr);
        }
      }

      // if there are no unpaired strands
      if( sheets_with_single_strands.IsEmpty())
      {
        BCL_MessageVrb( "No unpaired strands in this model yet, skipping pairing strands");
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // now we know that there are at least one unpaired strands
      // so pick one randomly
      util::ShPtrVector< assemble::Domain>::iterator random_itr
      (
        random::GetGlobalRandom().Iterator
        (
          sheets_with_single_strands.Begin(),
          sheets_with_single_strands.End(),
          sheets_with_single_strands.GetSize()
        )
      );

      // make sure the random iterator returned correctly
      BCL_Assert
      (
        random_itr != sheets_with_single_strands.End(),
        "Error occurred in picking a random sheet with a single unpaired strand"
      );

      // make a copy of this SSE
      util::ShPtr< assemble::SSE> new_sse( ( *random_itr)->GetSSEs().FirstElement()->Clone());

      // idealize the new SSE
      new_sse->SetToIdealConformationAtOrigin();

      // now we have to pick the sheet to move this pair next to
      // first create the iterator to pick the sheet
      util::ShPtrVector< assemble::Domain>::const_iterator random_sheet_itr;

      // if there are more unpaired strands
      if( sheets_with_single_strands.GetSize() >= 2)
      {
        // remove the picked strand
        sheets_with_single_strands.Remove( random_itr);

        // pick another sheet with single strand randomly
        random_sheet_itr =
          random::GetGlobalRandom().Iterator
          (
            sheets_with_single_strands.Begin(),
            sheets_with_single_strands.End(),
            sheets_with_single_strands.GetSize()
          );
        // make sure the random iterator returned correctly
        BCL_Assert
        (
          random_sheet_itr != sheets_with_single_strands.End(),
          "Error occurred in picking a random sheet to pair the strand with"
        );

      }
      // otherwise, if there was only one unpaired strand then we have to pick one of the sheets with multiple strands
      else
      {
        // remove the picked single strand from sheets list
        sheets.Remove( std::find( sheets.Begin(), sheets.End(), *random_itr));

        // now get a random sheet to place next to
        random_sheet_itr =
          random::GetGlobalRandom().Iterator
          (
            sheets.Begin(),
            sheets.End(),
            sheets.GetSize()
          );
        // make sure the random iterator returned correctly
        BCL_Assert
        (
          random_sheet_itr != sheets.End(),
          "Error occurred in picking a random sheet to pair the strand with"
        );
      }

      // calculate the placement
      storage::Pair< math::TransformationMatrix3D, bool> transformation
      (
        PlacementStrandNextToSheet().Place( *new_sse, **random_sheet_itr)
      );

      // make sure the placement was calculated correctly
      BCL_Assert
      (
        transformation.Second(),
        "The placement failed for placing unpaired strand next to sheet"
      );

      // apply the transformation to new sse
      new_sse->Transform( transformation.First());

      // make a new model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace the one in model with the new SSE
      new_model->Replace( new_sse);

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelPairStrands::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelPairStrands::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "fold/bcl_fold_mutate_protein_model_replicate_conformation.h"
#include "math/bcl_math_mutate_result.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelReplicateConformation::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelReplicateConformation())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelReplicateConformation::MutateProteinModelReplicateConformation() :
      m_ConformationCollector(),
      m_NumberReplications(),
      m_Scheme( GetStaticClassName< MutateProteinModelReplicateConformation>())
    {
    }

    //! @brief constructor taking parameters
    //! @param LOCATOR the method for locating the conformation to replicate
    //! @param NUMBER_REPLICATIONS the number of times each collected conformation should be copied
    //! @param SCHEME Scheme to be used
    MutateProteinModelReplicateConformation::MutateProteinModelReplicateConformation
    (
      const util::ShPtr
      <
        find::CollectorInterface< util::SiPtrList< const assemble::ProteinModel>, assemble::ProteinModel>
      > &CONFORMATION,
      int NUMBER_REPLICATIONS,
      const std::string &SCHEME
    ) :
      m_ConformationCollector( CONFORMATION),
      m_NumberReplications( NUMBER_REPLICATIONS),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelReplicateConformation
    MutateProteinModelReplicateConformation *MutateProteinModelReplicateConformation::Clone() const
    {
      return new MutateProteinModelReplicateConformation( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelReplicateConformation::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////
  
  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel>
    MutateProteinModelReplicateConformation::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // static empty model
      const math::MutateResult< assemble::ProteinModel> empty_result( util::ShPtr< assemble::ProteinModel>(), *this);

      // try to locate the desired models
      util::SiPtrList< const assemble::ProteinModel> conformations( m_ConformationCollector->Collect( PROTEIN_MODEL));

      // if the desired conformation could not be found
      if( conformations.IsEmpty())
      {
        return empty_result;
      }

      // create new model from the first element located conformation
      util::ShPtr< assemble::ProteinEnsemble> new_model
      (
        new assemble::ProteinEnsemble( *conformations.FirstElement())
      );

      // copy the first model one less than the desired number of times, since it is already set as the model
      for( int copy( 0); copy < m_NumberReplications; ++copy)
      {
        // make new copy of the conformation
        util::ShPtr< assemble::ProteinModel> model_copy( conformations.FirstElement()->HardCopy());

        new_model->InsertElement( model_copy);
      }

      // iterate through the rest of the conformations
      for
      (
        util::SiPtrList< const assemble::ProteinModel>::const_iterator
          model_itr( ++conformations.Begin()), //< start at the second element
          model_itr_end( conformations.End());
        model_itr != model_itr_end;
        ++model_itr
      )
      {
        // copy the rest of the models the desired number of times
        for( int copy( 0); copy < m_NumberReplications + 1; ++copy)
        {
          new_model->InsertElement( util::ShPtr< assemble::ProteinModel>( ( *model_itr)->HardCopy()));
        }
      }

      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelReplicateConformation::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ConformationCollector, ISTREAM);
      io::Serialize::Read( m_NumberReplications, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelReplicateConformation::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ConformationCollector, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_NumberReplications, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_add.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_sse_random.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "biol/bcl_biol_membrane.h"
#include "fold/bcl_fold_mutate_protein_model_sse_remove.h"
#include "fold/bcl_fold_mutate_sse_bend_ramachandran.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSEAdd::MutateProteinModelSSEAdd() :
      m_SSEPoolPicker(),
      m_Placement(),
      m_Scheme( GetStaticClassName< MutateProteinModelSSEAdd>())
    {
    }

    //! @brief constructor from a PickCriteriaInterface, PlacementInterface and a scheme
    //! @param PICKER picker to be used for picking sses from the pool
    //! @param PLACEMENT placement to place the picked sse in the model
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEAdd::MutateProteinModelSSEAdd
    (
      const find::PickCriteriaInterface
      <
        util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::DomainInterface
      > &PICKER,
      const PlacementInterface< assemble::SSE, assemble::ProteinModel> &PLACEMENT,
      const std::string &SCHEME
    ) :
      m_SSEPoolPicker( PICKER.Clone()),
      m_Placement( PLACEMENT),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from a PickCriteriaInterface, PlacementInterface amd a scheme
    //! @param SP_PICKER ShPtr to picker to be used for picking sses from the pool
    //! @param SP_PLACEMENT ShPtr to placement to place the picked sse in the model
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEAdd::MutateProteinModelSSEAdd
    (
      const util::ShPtr
      <
        find::PickCriteriaInterface
        <
          util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::DomainInterface
        >
      > &SP_PICKER,
      const util::ShPtr< PlacementInterface< assemble::SSE, assemble::ProteinModel> > &SP_PLACEMENT,
      const std::string &SCHEME
    ) :
      m_SSEPoolPicker( *SP_PICKER),
      m_Placement( *SP_PLACEMENT),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSEAdd
    MutateProteinModelSSEAdd *MutateProteinModelSSEAdd::Clone() const
    {
      return new MutateProteinModelSSEAdd( *this);
    };

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSEAdd::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelSSEAdd)
    );

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelSSEAdd::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSEAdd::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      if( !sp_pool.IsDefined())
      {
        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // choose a random sse from the SSEs that do not overlap with SSEs in PROTEIN_MODEL
      util::SiPtrList< const assemble::SSE> non_overlapping_sses( sp_pool->GetNonOverlappingSSEs( PROTEIN_MODEL));

      // if there are no overlapping sses left display messsage and return
      if( non_overlapping_sses.IsEmpty())
      {
        // warn user
        BCL_MessageVrb( "skipping adding, no non-overlapping sses left in pool");
//        static fold::MutateProteinModelSSERemove s_remover
//        (
//          MutateProteinModelSSERemove
//          (
//            util::ShPtr< assemble::LocatorSSERandom>( new assemble::LocatorSSERandom()),
//            "remove_random"
//          )
//        );
//        math::MutateResult< assemble::ProteinModel> result( s_remover( PROTEIN_MODEL));
//        if( result.GetArgument().IsDefined())
//        {
//          return operator()( *result.GetArgument());
//        }

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // called the picker to pick an sse from the pool to be placed in the protein model
      const util::SiPtr< const assemble::SSE> sse_from_pool( m_SSEPoolPicker->Pick( non_overlapping_sses, PROTEIN_MODEL));

      // if pick could not find one just return
      if( !sse_from_pool.IsDefined())
      {
        // output the picker that failed
        BCL_MessageVrb( "undefined sse picked by " + util::Format()( *m_SSEPoolPicker));

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // report selected sse from pool to be added
      BCL_MessageVrb( "sse from pool to be added " + sse_from_pool->GetIdentification());

      // initialize transformation
      storage::Pair< math::TransformationMatrix3D, bool> transformation;

      // if protein model is empty insert this sse at the center
      if( PROTEIN_MODEL.GetSSEs().IsEmpty())
      {
        transformation = m_Placement->Place( *sse_from_pool);
      }
      // if PROTEIN MODEL is not empty
      else
      {
        // get the placement
        transformation = m_Placement->Place( *sse_from_pool, PROTEIN_MODEL);
      }

      // if the placement was not successful in finding a good placement
      if( !transformation.Second())
      {
        BCL_MessageStd( "The provided transformation is not successful, skipping the add!");

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // make a copy of the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // get membrane for current protein model
      const util::ShPtr< biol::Membrane> sp_membrane
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane)
      );

      // create a copy of the selected sse assuming the sse from the pool is already
      // in the ideal conformation and in origin
      util::ShPtr< assemble::SSE> this_sse( sse_from_pool->Clone());

      // transform with the assemble transformation matrix3D
      this_sse->Transform( transformation.First());

      static MutateSSEBendRamachandran s_bender( math::Range< size_t>( 1000, 1000), biol::AASequenceFlexibility::e_Bidirectional);
      this_sse = s_bender( *this_sse, sp_membrane).GetArgument();

      // print sses before the add and after the add
      BCL_MessageDbg( "#SSEs in model before: " + util::Format()( new_model->GetNumberSSEs()));

      // add to protein model
      new_model->Insert( this_sse);

      // print sses before the add and after the add
      BCL_MessageDbg( "#SSEs in model after: " + util::Format()( new_model->GetNumberSSEs()));

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_add_multiple.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSEAddMultiple::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSSEAddMultiple())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSEAddMultiple::MutateProteinModelSSEAddMultiple() :
      m_SSEPool(),
      m_Placement(),
      m_Scheme( GetStaticClassName< MutateProteinModelSSEAddMultiple>())
    {
    }

    //! @brief constructor from a SSEPool, a PlacementDomainInterface and a scheme
    //! @param SSE_POOL ShPtr to pool of SSEs to be used
    //! @param PLACEMENT placement for the SSEs in the pool into the model
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEAddMultiple::MutateProteinModelSSEAddMultiple
    (
      const util::ShPtr< assemble::SSEPool> &SSE_POOL,
      const PlacementDomainInterface &PLACEMENT,
      const std::string &SCHEME
    ) :
      m_SSEPool( SSE_POOL),
      m_Placement( PLACEMENT.Clone()),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from a ShPtr to a SSEPool, a ShPtr to PlacementDomainInterface and a scheme
    //! @param SSE_POOL ShPtr to pool of SSEs to be used
    //! @param SP_PLACEMENT ShPtr to placement for the SSEs in the pool into the model
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEAddMultiple::MutateProteinModelSSEAddMultiple
    (
      const util::ShPtr< assemble::SSEPool> &SSE_POOL,
      const util::ShPtr< PlacementDomainInterface> &SP_PLACEMENT,
      const std::string &SCHEME
    ) :
      m_SSEPool( SSE_POOL),
      m_Placement( SP_PLACEMENT),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSEAddMultiple
    MutateProteinModelSSEAddMultiple *MutateProteinModelSSEAddMultiple::Clone() const
    {
      return new MutateProteinModelSSEAddMultiple( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelSSEAddMultiple::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator taking a protein model and returning a mutate object of protein model type
    //! @param PROTEIN_MODEL protein model of interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSEAddMultiple::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model( new assemble::ProteinModel());

      // return empty model if no SSEs in pool
      if( m_SSEPool->GetSize() == 0)
      {
        BCL_MessageStd( "Skipping Adding Multiple SSEs: no SSEs in pool");

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // initialize temp SSEs set
      const storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> sses
      (
        m_SSEPool->GetRandomNonOverlappingSet()
      );

      // initialize ShPtr Set
      storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap> sp_sses;

      // iterate through the SSEs
      for
      (
        storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr( sses.Begin()), sse_itr_end( sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        sp_sses.Insert( util::ShPtr< assemble::SSE>( ( *sse_itr)->Clone()));
      }

      // get the map of transformation matrices from the placement
      storage::Pair
      <
        storage::Map< util::SiPtr< const assemble::SSE>, math::TransformationMatrix3D>,
        bool
      > transformations
      (
        m_Placement->Place( assemble::Domain( sp_sses))
      );

      // if the placement was not successful
      if( !transformations.Second())
      {
        BCL_MessageStd
        (
          "The provided transformations were not successful, skipping the add multiple SSEs"
        );

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // create a new protein model using the chain information
      util::ShPtr< assemble::ProteinModel> new_model( new assemble::ProteinModel( PROTEIN_MODEL.GetEmptyChains()));

      // iterate through the SSEs
      for
      (
        storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
          sse_itr( sp_sses.Begin()), sse_itr_end( sp_sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // create an iterator on the map
        storage::Map< util::SiPtr< const assemble::SSE>, math::TransformationMatrix3D>::iterator map_itr
        (
          transformations.First().Find( util::SiPtr< const assemble::SSE>( **sse_itr))
        );

        // if the iterator is valid
        if( map_itr != transformations.First().End())
        {
          // create temp SSE
          util::ShPtr< assemble::SSE> this_sse( ( *sse_itr)->Clone());

          // set this sse to origin
          this_sse->Transform( math::Inverse( this_sse->GetOrientation()));

          // apply the proper transformation
          this_sse->Transform( map_itr->second);

          // insert the SSE into the protein model
          new_model->Insert( this_sse);
        }
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSEAddMultiple::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSEPool, ISTREAM);
      io::Serialize::Read( m_Placement, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelSSEAddMultiple::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSEPool, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Placement, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "find/bcl_find_locator_interface.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_result.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSE::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelSSE())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSE::MutateProteinModelSSE() :
      m_Locator(),
      m_Mutate(),
      m_Scheme( GetStaticClassName< MutateProteinModelSSE>())
    {
    }

    //! @brief constructor from a SSE locator, a SSE Mutate and a scheme
    //! @param LOCATOR function that chooses the sse
    //! @param MUTATE function that performs the mutate on the sse
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSE::MutateProteinModelSSE
    (
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &LOCATOR,
      const util::ShPtr< math::MutateInterface< assemble::SSE> > &MUTATE,
      const std::string &SCHEME
    ) :
      m_Locator( *LOCATOR),
      m_Mutate( *MUTATE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief clone
    MutateProteinModelSSE *MutateProteinModelSSE::Clone() const
    {
      return new MutateProteinModelSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateProteinModelSSE::GetAlias() const
    {
      static const std::string s_alias( "MutateProteinModelSSE");
      return s_alias;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateProteinModelSSE::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Changes a protein model using the provided mutate.");
      serializer.AddInitializer
      (
        "locator",
        "locates SSEs to mutate",
        io::Serialization::GetAgent( &m_Locator)
      );
      serializer.AddInitializer
      (
        "mutate",
        "mutates the protein model",
        io::Serialization::GetAgent( &m_Mutate)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSE::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // choose a random sse and make copy
      const util::SiPtr< const assemble::SSE> located_sse( m_Locator->Locate( PROTEIN_MODEL));

      // if there was no sse found, return an empty result
      if( !located_sse.IsDefined())
      {
        BCL_MessageVrb( "could not find sse for mutating: " + util::Format()( *m_Locator));

        // return result with no model
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // create a copy of the model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // report selected sse from protein model to be moved
      BCL_MessageVrb( "selected sse to be mutated: " + located_sse->GetIdentification());

      // call the mutate and get the result
      math::MutateResult< assemble::SSE> result_sse( m_Mutate->operator ()( *located_sse));

      // if not successful
      if( !result_sse.GetArgument().IsDefined())
      {
        BCL_MessageVrb( "could not mutate sse : " + located_sse->GetIdentification());

        // return result with no model
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // replace the sse with the mutated copy of the same sse
      new_model->Replace( result_sse.GetArgument());

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_move.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "math/bcl_math_mutate_result.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSEMove::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelSSEMove())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSEMove::MutateProteinModelSSEMove() :
      m_Locator(),
      m_Placement(),
      m_Scheme( GetStaticClassName< MutateProteinModelSSEMove>())
    {
    }

    //! @brief constructor from a locator and placement and a scheme
    //! @param LOCATOR ShPtr to LocatorInterface to be used
    //! @param PLACEMENT ShPtr to PlacementInterface to be used
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEMove::MutateProteinModelSSEMove
    (
      const find::LocatorCriteriaInterface
      <
        util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface
      > &LOCATOR,
      const PlacementInterface< assemble::SSE, assemble::ProteinModel> &PLACEMENT,
      const std::string &SCHEME
    ) :
      m_Locator( LOCATOR),
      m_Placement( PLACEMENT),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from ShPtrs to a locator and placement and a scheme
    //! @param SP_LOCATOR ShPtr to LocatorInterface to be used
    //! @param SP_PLACEMENT ShPtr to PlacementInterface to be used
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEMove::MutateProteinModelSSEMove
    (
      const util::ShPtr
      <
        find::LocatorCriteriaInterface
        <
          util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface
        >
      > &SP_LOCATOR,
      const util::ShPtr< PlacementInterface< assemble::SSE, assemble::ProteinModel> > &SP_PLACEMENT,
      const std::string &SCHEME
    ) :
      m_Locator( *SP_LOCATOR),
      m_Placement( *SP_PLACEMENT),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSEMove
    MutateProteinModelSSEMove *MutateProteinModelSSEMove::Clone() const
    {
      return new MutateProteinModelSSEMove( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSEMove::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get scheme
    //! @return scheme
    const std::string &MutateProteinModelSSEMove::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that moves an SSE
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSEMove::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // create the ShPtr to model
      util::ShPtr< assemble::ProteinModel> sp_model;

      // try to locate sse
      const util::SiPtr< const assemble::SSE> sp_located_sse( m_Locator->Locate( PROTEIN_MODEL, PROTEIN_MODEL));

      // no sse located
      if( !sp_located_sse.IsDefined())
      {
        return math::MutateResult< assemble::ProteinModel>( sp_model, *this);
      }

      // find placement for the sse
      const storage::Pair< math::TransformationMatrix3D, bool> place( m_Placement->Place( *sp_located_sse, PROTEIN_MODEL));

      // is there a placement defined
      if( !place.Second())
      {
        return math::MutateResult< assemble::ProteinModel>( sp_model, *this);
      }

      // create the transformation
      math::TransformationMatrix3D transform( sp_located_sse->GetOrientation());
      transform.Invert();
      transform( place.First());

      // create a copy of the sse to tranform
      util::ShPtr< assemble::SSE> sp_sse( sp_located_sse->Clone());

      // transform to new location
      sp_sse->Transform( transform);

      // create new protein model
      sp_model = util::ShPtr< assemble::ProteinModel>( PROTEIN_MODEL.Clone());

      // replace
      BCL_Assert( sp_model->Replace( sp_sse), "cannot replace sse: " + sp_sse->GetIdentification());

      // end
      return math::MutateResult< assemble::ProteinModel>( sp_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_pair_align_and_pull.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "score/bcl_score_aa_pair_hi_res_clash.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSEPairAlignAndPull::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSSEPairAlignAndPull())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSEPairAlignAndPull::MutateProteinModelSSEPairAlignAndPull() :
      m_Collector(),
      m_Pull( false),
      m_Scheme( GetStaticClassName< MutateProteinModelSSEPairAlignAndPull>())
    {
    }

    //! @brief construct from Collector, max translation and rotation
    //! @param SP_COLLECTOR ShPtr to collector of SSE pairs
    //! @param MAX_TRANSLATION maximum translation allowed
    //! @param MAX_ROTATION maximum rotation allowed
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEPairAlignAndPull::MutateProteinModelSSEPairAlignAndPull
    (
      const util::ShPtr
      <
        find::CollectorInterface
        <
          storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface
        >
      > &SP_COLLECTOR,
      const bool &PULL,
      const std::string &SCHEME
    ) :
      m_Collector( SP_COLLECTOR),
      m_Pull( PULL),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSEPairAlignAndPull
    MutateProteinModelSSEPairAlignAndPull *MutateProteinModelSSEPairAlignAndPull::Clone() const
    {
      return new MutateProteinModelSSEPairAlignAndPull( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelSSEPairAlignAndPull::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSEPairAlignAndPull::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // if no pair is available
      if( PROTEIN_MODEL.GetNumberSSEs() < size_t( 2))
      {
        // warn user
        BCL_MessageVrb( "unable to find a pair of sses");

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      auto sses( PROTEIN_MODEL.GetSSEs());
      size_t sse_id_a( random::GetGlobalRandom().Random( sses.GetSize() - 1));
      size_t sse_id_b( random::GetGlobalRandom().Random( sses.GetSize() - 2));
      if( sse_id_b >= sse_id_a)
      {
        ++sse_id_b;
      }
      static const double s_max_align_dist_wo_pull( 20.0);
      static const size_t s_max_tries( 100);
      for
      (
        size_t tries( 0);
        !m_Pull
        && linal::Distance( sses( sse_id_a)->GetCenter(), sses( sse_id_b)->GetCenter()) > s_max_align_dist_wo_pull
        && tries < s_max_tries;
        ++tries
      )
      {
        sse_id_a = random::GetGlobalRandom().Random( sses.GetSize() - 1);
        sse_id_b = random::GetGlobalRandom().Random( sses.GetSize() - 2);
        if( sse_id_b >= sse_id_a)
        {
          ++sse_id_b;
        }
      }

      // calculate the sse_packing
      const assemble::SSEGeometryPacking sse_pack( *sses( sse_id_a), *sses( sse_id_b));

      // pick either sse
      util::ShPtr< assemble::SSE> mutated_sse
      (
        sses( sse_id_a)->Clone()
      );

      BCL_MessageVrb( "mutated sse " + mutated_sse->GetIdentification() + " relative to " + sses( sse_id_b)->GetIdentification());

      // generate TransformationMatrix3D and place sse in origin
      const linal::Vector3D center_a( mutated_sse->GetCenter());
      mutated_sse->Translate( -center_a);
      coord::LineSegment3D main_axis_recentered_b
      (
        ( sses( sse_id_b)->GetMainAxis().GetStartPoint() - sses( sse_id_b)->GetMainAxis().GetEndPoint()) / 2.0,
        ( sses( sse_id_b)->GetMainAxis().GetEndPoint() - sses( sse_id_b)->GetMainAxis().GetStartPoint()) / 2.0
      );
      if( random::GetGlobalRandom().Boolean())
      {
        main_axis_recentered_b = coord::LineSegment3D( main_axis_recentered_b.GetStartPoint(), main_axis_recentered_b.GetEndPoint());
      }
      math::TransformationMatrix3D transform( mutated_sse->GetMainAxis(), main_axis_recentered_b);
      mutated_sse->Transform( transform);
      mutated_sse->Translate( center_a);

      linal::Vector3D translation_dir( sses( sse_id_b)->GetCenter() - center_a);
      static score::AAPairHiResClash s_aaclash;
      const double true_dist( translation_dir.Norm());
      translation_dir.Normalize();
      transform.SetTranslation( linal::Vector3D());

      mutated_sse->Transform( transform);
      if( m_Pull && s_aaclash( *mutated_sse, *sses( sse_id_b)) < 0.5)
      {
        double max_remaining_translation( std::max( true_dist - 5.0, 0.0));
        while( max_remaining_translation > 0.1)
        {
          double amnt_to_translate( std::max( 0.1, max_remaining_translation * 0.5));
          mutated_sse->Translate( translation_dir * amnt_to_translate);
          if( s_aaclash( *mutated_sse, *sses( sse_id_b)) > 0.5)
          {
            mutated_sse->Translate( translation_dir * -amnt_to_translate);
            max_remaining_translation = amnt_to_translate;
          }
          else
          {
            max_remaining_translation -= amnt_to_translate;
          }
        }
      }

      // make copy of proteinmodel
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace mutated sse
      new_model->Replace( mutated_sse);

      // return
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSEPairAlignAndPull::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Collector, ISTREAM);
      io::Serialize::Read( m_Pull, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelSSEPairAlignAndPull::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Collector, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Pull, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_pair_clash.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "io/bcl_io_directory.h"
#include "io/bcl_io_file.h"
#include "pdb/bcl_pdb_factory.h"
#include "score/bcl_score_aa_pair_hi_res_clash.h"

// external includes - sorted alphabetically

// Define this to visualize all clash removals
//#define DEBUG_BCL_FOLD_MUTATE_CLASH_RESOLVER

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSEPairClash::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSSEPairClash())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSEPairClash::MutateProteinModelSSEPairClash( const size_t &MAX_SSES_TO_MOVE) :
      m_Scheme
      (
        "sse_clash_remover_"
        + ( MAX_SSES_TO_MOVE == util::GetUndefinedSize_t() ? std::string( "all") : util::Format()( MAX_SSES_TO_MOVE))
      ),
      m_MaxSSEsToMove( MAX_SSES_TO_MOVE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSEPairClash
    MutateProteinModelSSEPairClash *MutateProteinModelSSEPairClash::Clone() const
    {
      return new MutateProteinModelSSEPairClash( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelSSEPairClash::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSEPairClash::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      static score::AAPairHiResClash s_clash;
      static assemble::VoxelGridAA s_voxel_grid( s_clash.GetDistanceCutoff());
      double prev_clash_score( s_clash( PROTEIN_MODEL));

      static size_t n_times_called( 0);

      ++n_times_called;
      if( prev_clash_score < 0.05)
      {
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      storage::Vector< storage::Pair< util::SiPtr< const assemble::SSE>, linal::Vector3D> >
      sse_moves
      (
        s_voxel_grid.GetMinSSEMoveIDsToRemoveClashes
        (
          PROTEIN_MODEL.GetSSEs(),
          PROTEIN_MODEL.GetAminoAcids(),
          false
        )
      );

      // if no pair is available
      if( sse_moves.IsEmpty())
      {
        // warn user
        BCL_MessageVrb( "unable to find a pair of clashing SSEs!");

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // make copy of proteinmodel
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      sse_moves.Shuffle();

      if( m_MaxSSEsToMove < sse_moves.GetSize())
      {
        sse_moves.Resize( m_MaxSSEsToMove);
      }
      // iterate over clashing SSEs
      util::ShPtr< assemble::ProteinModel> new_model_b;
      const size_t max_rounds( 20);
      size_t rnd( 0);
      double total_move_dist( 0.0);
      size_t n_sses_moved( 0);

#ifdef DEBUG_BCL_FOLD_MUTATE_CLASH_RESOLVER
      io::OFStream out;
      const std::string folder( "/tmp/clash_itr_" + util::Format()( n_times_called) + "/");
      pdb::Factory factory;
      io::Directory::MkDir( folder);
      io::File::MustOpenOFStream( out, folder + "itr0.pdb");
      factory.WriteModelToPDB( PROTEIN_MODEL, out);
      io::File::CloseClearFStream( out);
#endif
      while( !sse_moves.IsEmpty() && ++rnd <= max_rounds)
      {
        for( auto itr( sse_moves.Begin()), itr_end( sse_moves.End()); itr != itr_end; ++itr)
        {
          // calculate the sse_packing
          BCL_MessageVrb( "mutated sse " + itr->First()->GetIdentification() + " " + util::Format()( itr->Second().ToString()));
          util::ShPtr< assemble::SSE> mutated_sse( itr->First()->Clone());

          // apply transformation
          total_move_dist += itr->Second().Norm();
          mutated_sse->Translate( -itr->Second());

          // replace mutated sse
          new_model->Replace( mutated_sse);
          ++n_sses_moved;
#ifdef DEBUG_BCL_FOLD_MUTATE_CLASH_RESOLVER
          io::File::MustOpenOFStream( out, folder + "itr" + util::Format()( rnd) + "_sse" + util::Format()( n_sses_moved) + ".pdb");
          factory.WriteModelToPDB( *new_model, out);
          io::File::CloseClearFStream( out);
#endif
        }
        new_model_b = util::ShPtr< assemble::ProteinModel>( new_model->Clone());
        sse_moves = s_voxel_grid.GetMinSSEMoveIDsToRemoveClashes
                    (
                      new_model_b->GetSSEs(),
                      new_model_b->GetAminoAcids(),
                      false
                    );
      }
      #ifdef DEBUG_BCL_FOLD_MUTATE_CLASH_RESOLVER
      const double new_clash_score( s_clash( *new_model));
      if( sse_moves.GetSize() && new_clash_score > 0.5)
      {
        BCL_MessageVrb
        (
          "Iteration " + util::Format()( n_times_called) +
          " Gave up removing clashes... remaining clash score "
          + util::Format()( prev_clash_score)
          + ". Remaining moves: " + util::Format()( sse_moves.GetSize())
          + " initial score: + " + util::Format()( prev_clash_score)
          + " final score: " + util::Format()( new_clash_score)
          + " # moved "
          + util::Format()( n_sses_moved) + " distance moved: " + util::Format()( total_move_dist)
        );
      }
      else
      {
        BCL_MessageStd
        (
          "Iteration " + util::Format()( n_times_called) +
          " Fixed clashes in " + util::Format()( rnd) + " rounds of clash removal. # moved "
          + util::Format()( n_sses_moved) + " distance moved: " + util::Format()( total_move_dist)
          + " remaining score: " + util::Format()( new_clash_score)
        );
      }
      #endif
      // return
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSEPairClash::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelSSEPairClash::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_pair.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSEPair::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSSEPair())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSEPair::MutateProteinModelSSEPair() :
      m_Collector(),
      m_TranslationRange(),
      m_RotationRange(),
      m_Scheme( GetStaticClassName< MutateProteinModelSSEPair>())
    {
    }

    //! @brief construct from Collector, max translation and rotation
    //! @param SP_COLLECTOR ShPtr to collector of SSE pairs
    //! @param MAX_TRANSLATION maximum translation allowed
    //! @param MAX_ROTATION maximum rotation allowed
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEPair::MutateProteinModelSSEPair
    (
      const util::ShPtr
      <
        find::CollectorInterface
        <
          storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface
        >
      > &SP_COLLECTOR,
      const double MAX_TRANSLATION,
      const double MAX_ROTATION,
      const std::string &SCHEME
    ) :
      m_Collector( SP_COLLECTOR),
      m_TranslationRange( 0.0, MAX_TRANSLATION),
      m_RotationRange( 0.0, MAX_ROTATION),
      m_Scheme( SCHEME)
    {
    }

    //! @brief construct from Collector, min and max rotation and translation
    //! @param SP_COLLECTOR ShPtr to collector of SSE pairs
    //! @param TRANSLATION_RANGE range that specifies min and max translations
    //! @param ROTATION_RANGE range that specifies min and max rotations
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEPair::MutateProteinModelSSEPair
    (
      const util::ShPtr
      <
        find::CollectorInterface
        <
          storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface
        >
      > &SP_COLLECTOR,
      const math::Range< double> &TRANSLATION_RANGE,
      const math::Range< double> &ROTATION_RANGE,
      const std::string &SCHEME
    ) :
      m_Collector( SP_COLLECTOR),
      m_TranslationRange( TRANSLATION_RANGE),
      m_RotationRange( ROTATION_RANGE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSEPair
    MutateProteinModelSSEPair *MutateProteinModelSSEPair::Clone() const
    {
      return new MutateProteinModelSSEPair( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelSSEPair::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSEPair::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // collect possible sse pairs
      const storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > > sse_pairs
      (
        m_Collector->Collect( PROTEIN_MODEL)
      );

      // if no pair is available
      if( sse_pairs.IsEmpty())
      {
        // warn user
        BCL_MessageVrb( "unable to find a pair of sses");

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // pick random sse pair
      const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > &sse_pair
      (
        *random::GetGlobalRandom().Iterator( sse_pairs.Begin(), sse_pairs.End(), sse_pairs.GetSize())
      );

      // calculate the sse_packing
      const assemble::SSEGeometryPacking sse_pack( *sse_pair.First(), *sse_pair.Second());

      // pick either sse
      util::ShPtr< assemble::SSE> mutated_sse
      (
        sse_pair( !random::GetGlobalRandom().Boolean())->Clone()
      );

      BCL_MessageVrb( "mutated sse " + mutated_sse->GetIdentification());

      // generate TransformationMatrix3D and place sse in origin
      math::TransformationMatrix3D transform( -mutated_sse->GetCenter());

      // apply random translation around axis defined by the shortest connection between the two sses
      transform
      (
        math::RotationMatrix3D
        (
          sse_pack.GetShortestConnection().GetDirection(),
          random::GetGlobalRandom().Sign() *
          random::GetGlobalRandom().Double( m_RotationRange)
        )
      );

      // transform back to original position
      transform( mutated_sse->GetCenter());

      // translate along shortest connection
      transform
      (
        linal::Vector3D( linal::Vector3D( sse_pack.GetShortestConnection().GetDirection()).Normalize())
        * double( random::GetGlobalRandom().Sign())
        * random::GetGlobalRandom().Double( m_TranslationRange)
      );

      // apply transformation
      mutated_sse->Transform( transform);

      // make copy of proteinmodel
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace mutated sse
      new_model->Replace( mutated_sse);

      // return
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSEPair::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Collector, ISTREAM);
      io::Serialize::Read( m_TranslationRange, ISTREAM);
      io::Serialize::Read( m_RotationRange, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelSSEPair::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Collector, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_TranslationRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_RotationRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_pair_fix_loop_closure.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "io/bcl_io_directory.h"
#include "io/bcl_io_file.h"
#include "pdb/bcl_pdb_factory.h"
#include "score/bcl_score_aa_pair_hi_res_clash.h"
#include "score/bcl_score_loop_closure.h"

// external includes - sorted alphabetically

// Define this to visualize all clash removals
//#define DEBUG_BCL_FOLD_MUTATE_LOOP_CLOSURE_RESOLVER

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSEPairFixLoopClosure::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSSEPairFixLoopClosure())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSEPairFixLoopClosure::MutateProteinModelSSEPairFixLoopClosure( const size_t &MAX_SSES_TO_MOVE) :
      m_Scheme
      (
        "directed_loop_closure_"
        + ( MAX_SSES_TO_MOVE == util::GetUndefinedSize_t() ? std::string( "all") : util::Format()( MAX_SSES_TO_MOVE))
      ),
      m_MaxSSEsToMove( MAX_SSES_TO_MOVE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSEPairFixLoopClosure
    MutateProteinModelSSEPairFixLoopClosure *MutateProteinModelSSEPairFixLoopClosure::Clone() const
    {
      return new MutateProteinModelSSEPairFixLoopClosure( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelSSEPairFixLoopClosure::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the weighted average distance between two sses based on the length of the coil between them
    double MutateProteinModelSSEPairFixLoopClosure::GetTypicalLoopLength( const size_t &N_RESIDUES) const
    {
      // R^2 = 0.986
      return 2.445 + 4.84 * std::log( double( N_RESIDUES));
    }

    //! @brief get the weighted average distance between two sses based on the length of the coil between them
    double MutateProteinModelSSEPairFixLoopClosure::GetMaxLoopLength( const size_t &N_RESIDUES) const
    {
      return 2.1136 + 2.5609 * double( N_RESIDUES);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSEPairFixLoopClosure::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      static score::LoopClosure s_closure( size_t( 1), 0.0, 1.0);
      double prev_score( s_closure( PROTEIN_MODEL));

      // make copy of proteinmodel
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      static size_t n_times_called( 0);

      ++n_times_called;
      if( prev_score < 0.05)
      {
        return math::MutateResult< assemble::ProteinModel>( new_model, *this);
      }

#ifdef DEBUG_BCL_FOLD_MUTATE_LOOP_CLOSURE_RESOLVER
      io::OFStream out;
      const std::string folder( "/tmp/loop_itr_" + util::Format()( n_times_called) + "/");
      pdb::Factory factory;
      io::Directory::MkDir( folder);
      io::File::MustOpenOFStream( out, folder + "start.pdb");
      factory.WriteModelToPDB( PROTEIN_MODEL, out);
      io::File::CloseClearFStream( out);
#endif
      // Find all sses that violate the loop closure score on either side
      for
      (
        auto chain_itr( new_model->GetChains().Begin()), chain_itr_end( new_model->GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        assemble::Chain &chain( **chain_itr);
        // need at least two sses in the chain
        if( chain.GetNumberSSEs() < 2)
        {
          continue;
        }
        {
          auto sse_itr( chain.GetData().Begin()), sse_itr_b( ++chain.GetData().Begin());
          const storage::Pair< size_t, double> seq_euclid_dist_first
          (
            score::LoopClosure::SequenceAndEuclideanDistanceWithExclusion( **sse_itr, **sse_itr_b, 1)
          );
          // for the first two SSEs, check whether the N-terminal SSE is too far from the second.
          if( util::IsDefined( seq_euclid_dist_first.First()) && util::IsDefined( seq_euclid_dist_first.Second()))
          {
            const double max_length( GetMaxLoopLength( seq_euclid_dist_first.First()));
            if( seq_euclid_dist_first.Second() > max_length)
            {
              const assemble::SSE &sseb( **sse_itr_b);
              // too far, so move N-terminus to fix
              util::ShPtr< assemble::SSE> new_sse( ( *sse_itr)->Clone());
              const double typical_length( GetTypicalLoopLength( seq_euclid_dist_first.First()));
              new_sse->Translate( sseb.BeginOfZ() + linal::Vector3D().SetRandomTranslation( typical_length) - new_sse->EndOfZ());
              chain.Replace( new_sse);
            }
          }
        }
        if( chain.GetNumberSSEs() == size_t( 2))
        {
          continue;
        }
        {
          auto sse_itr_last( --chain.GetData().End()), sse_itr_pre_last( ----chain.GetData().End());
          const storage::Pair< size_t, double> seq_euclid_dist_last
          (
            score::LoopClosure::SequenceAndEuclideanDistanceWithExclusion( **sse_itr_pre_last, **sse_itr_last, 1)
          );
          // for the first two SSEs, check whether the C-terminal SSE is too far from the previous.
          if( util::IsDefined( seq_euclid_dist_last.First()) && util::IsDefined( seq_euclid_dist_last.Second()))
          {
            const double max_length( GetMaxLoopLength( seq_euclid_dist_last.First()));
            if( seq_euclid_dist_last.Second() > max_length)
            {
              const assemble::SSE &ssea( **sse_itr_pre_last);
              // too far, so move C-terminus to fix
              util::ShPtr< assemble::SSE> new_sse( ( *sse_itr_last)->Clone());
              const double typical_length( GetTypicalLoopLength( seq_euclid_dist_last.First()));
              new_sse->Translate( ssea.EndOfZ() + linal::Vector3D().SetRandomTranslation( typical_length) - new_sse->BeginOfZ());
              chain.Replace( new_sse);
            }
          }
        }
        if( chain.GetNumberSSEs() == size_t( 3))
        {
          continue;
        }

        // iterate through the sses of "CHAIN" and look for chains whose loops are too far away
        bool did_something( true);
        while( did_something)
        {
          did_something = false;
          for
          (
            auto sse_itr_b( ++chain.GetData().Begin()),
              sse_itr_c( ++++chain.GetData().Begin()),
              sse_itr_last( --chain.GetData().End());
            sse_itr_b != sse_itr_last;
            sse_itr_b = sse_itr_c++
          )
          {
            auto sse_itr( sse_itr_b);
            --sse_itr;
            const storage::Pair< size_t, double> seq_euclid_dist_left
            (
              score::LoopClosure::SequenceAndEuclideanDistanceWithExclusion( **sse_itr, **sse_itr_b, 1)
            );

            // loop is undefined
            if( !util::IsDefined( seq_euclid_dist_left.First()) || !util::IsDefined( seq_euclid_dist_left.Second()))
            {
              continue;
            }

            const storage::Pair< size_t, double> seq_euclid_dist_right
            (
              score::LoopClosure::SequenceAndEuclideanDistanceWithExclusion( **sse_itr_b, **sse_itr_c, 1)
            );

            // loop is undefined
            if( !util::IsDefined( seq_euclid_dist_right.First()) || !util::IsDefined( seq_euclid_dist_right.Second()))
            {
              continue;
            }

            const double max_left( GetMaxLoopLength( seq_euclid_dist_left.First()));
            const double max_right( GetMaxLoopLength( seq_euclid_dist_right.First()));
            if( seq_euclid_dist_left.Second() <= max_left && seq_euclid_dist_right.Second() <= max_right)
            {
              continue;
            }
            util::ShPtr< assemble::SSE> new_sse( ( *sse_itr_b)->Clone());
            bool is_fixed( false);

            const assemble::SSE &ssea( **sse_itr);
            const assemble::SSE &sseb( *new_sse);
            const assemble::SSE &ssec( **sse_itr_c);
            const double pref_left( GetTypicalLoopLength( seq_euclid_dist_left.First()));
            const double pref_right( GetTypicalLoopLength( seq_euclid_dist_right.First()));
            const coord::LineSegment3D original_line( sseb.GetMainAxis());
            for( size_t i( 0); i < size_t( 10); ++i)
            {
              const math::TransformationMatrix3D trans
              (
                sseb.GetMainAxis(),
                coord::LineSegment3D
                (
                  ssea.EndOfZ() + linal::Vector3D().SetRandomTranslation( random::GetGlobalRandom().Boolean() ? pref_left : max_left),
                  ssec.BeginOfZ() + linal::Vector3D().SetRandomTranslation( random::GetGlobalRandom().Boolean() ? pref_right : max_right)
                )
              );
              new_sse->Transform( trans);
              const storage::Pair< size_t, double> seq_euclid_dist_left_updated
              (
                score::LoopClosure::SequenceAndEuclideanDistanceWithExclusion( **sse_itr, *new_sse, 1)
              );
              const storage::Pair< size_t, double> seq_euclid_dist_right_updated
              (
                score::LoopClosure::SequenceAndEuclideanDistanceWithExclusion( *new_sse, **sse_itr_c, 1)
              );
              if( seq_euclid_dist_right_updated.Second() <= max_right && seq_euclid_dist_left_updated.Second() <= max_left)
              {
                is_fixed = true;
                BCL_MessageVrb( "Resolved loop_closure on " + util::Format()( i) + "th iteration");
              }
            }
            if( !is_fixed)
            {
              const math::TransformationMatrix3D trans
              (
                sseb.GetMainAxis(),
                original_line
              );
              new_sse->Transform( trans);
            }
            else
            {
              did_something = true;
              chain.Replace( new_sse);
            }
          }
        }
      }
      new_model->GetChangeSignal().Emit( *new_model);

#ifdef DEBUG_BCL_FOLD_MUTATE_LOOP_CLOSURE_RESOLVER
      io::File::MustOpenOFStream( out, folder + "end.pdb");
      factory.WriteModelToPDB( *new_model, out);
      io::File::CloseClearFStream( out);
#endif

      // return
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSEPairFixLoopClosure::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelSSEPairFixLoopClosure::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_pair_hinge.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "coord/bcl_coord_movable_eccentric.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSEPairHinge::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSSEPairHinge())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSEPairHinge::MutateProteinModelSSEPairHinge() :
      m_Collector(),
      m_Move(),
      m_MoveHinge( false),
      m_Scheme( GetStaticClassName< MutateProteinModelSSEPairHinge>())
    {
    }

    //! @brief constructor from a CollectorInterface, MoveInterface and a scheme
    //! @param COLLECTOR function that chooses the sses
    //! @param MOVE function that performs the move on the sse
    //! @param MOVE_HINGE whether the hinge should be also moved
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEPairHinge::MutateProteinModelSSEPairHinge
    (
      const find::CollectorInterface< storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface> &COLLECTOR,
      const coord::MoveInterface &MOVE,
      const bool MOVE_HINGE,
      const std::string &SCHEME
    ) :
      m_Collector( COLLECTOR.Clone()),
      m_Move( MOVE.Clone()),
      m_MoveHinge( MOVE_HINGE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from ShPtrs to CollectorInterface, MoveInterface and a scheme
    //! @param SP_COLLECTOR ShPtr to function that chooses the sses
    //! @param SP_MOVE ShPtr to function that performs the move on the sse
    //! @param MOVE_HINGE whether the hinge should be also moved
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEPairHinge::MutateProteinModelSSEPairHinge
    (
      const util::ShPtr< find::CollectorInterface< storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface> > &SP_COLLECTOR,
      const util::ShPtr< coord::MoveInterface> &SP_MOVE,
      const bool MOVE_HINGE,
      const std::string &SCHEME
    ) :
      m_Collector( *SP_COLLECTOR),
      m_Move( SP_MOVE),
      m_MoveHinge( MOVE_HINGE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief clone
    MutateProteinModelSSEPairHinge *MutateProteinModelSSEPairHinge::Clone() const
    {
      return new MutateProteinModelSSEPairHinge( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSEPairHinge::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL ProteinModel which will be mutated
    //! @return MutateResult ProteinModel after mutation
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSEPairHinge::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty result
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // collect possible sse pairs
      const storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > > sse_pairs( m_Collector->Collect( PROTEIN_MODEL));

      // if no pair is available
      if( sse_pairs.IsEmpty())
      {
        // warn user
        BCL_MessageVrb( "unable to find a pair of sses");

        // return empty model
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // pick random sse pair
      const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > &sse_pair
      (
        *random::GetGlobalRandom().Iterator( sse_pairs.Begin(), sse_pairs.End(), sse_pairs.GetSize())
      );

      // get a random number to decide which of the pair SSEs to assign as hinge
      const size_t index_for_hinge( random::GetGlobalRandom().Boolean());

      BCL_MessageVrb
      (
        "Hinge sse " + sse_pair( index_for_hinge)->GetIdentification() +
        "\nmutated_sse " + sse_pair( !index_for_hinge)->GetIdentification() +
        "with m_MoveHinge " + util::Format()( m_MoveHinge)
      );

      // create a new domain
      assemble::Domain this_domain;

      // initialize hinge to domain
      util::SiPtr< const coord::MovableInterface> hinge( this_domain);

      // insert the non-hinge sse into domain
      this_domain.Insert( util::ShPtr< assemble::SSE>( sse_pair( !index_for_hinge)->Clone()));

      // if m_MoveHinge boolean is set
      if( m_MoveHinge)
      {
        // insert the hinge into data
        this_domain.Insert( util::ShPtr< assemble::SSE>( sse_pair( index_for_hinge)->Clone()));
      }

      // constructor the MovableEccentric from domain and the hinge
      coord::MovableEccentric movable_eccentric( this_domain, *sse_pair( index_for_hinge));

      // move the MovableEccentric
      m_Move->Move( movable_eccentric);

      // copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace the sses in the protein model contained in this domain with the moved copies
      new_model->Replace( this_domain.GetData());

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSEPairHinge::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Collector, ISTREAM);
      io::Serialize::Read( m_Move, ISTREAM);
      io::Serialize::Read( m_MoveHinge, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelSSEPairHinge::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Collector, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Move, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MoveHinge, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_remove.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "find/bcl_find_locator_interface.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSERemove::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelSSERemove())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSERemove::MutateProteinModelSSERemove() :
      m_Locator(),
      m_Scheme( GetStaticClassName< MutateProteinModelSSERemove>())
    {
    }

    //! @brief constructor from a locator and a scheme
    //! @param LOCATOR function that chooses the sse
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSERemove::MutateProteinModelSSERemove
    (
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &LOCATOR,
      const std::string &SCHEME
    ) :
      m_Locator( *LOCATOR),
      m_Scheme( SCHEME)
    {
    }

    //! @brief clone
    MutateProteinModelSSERemove *MutateProteinModelSSERemove::Clone() const
    {
      return new MutateProteinModelSSERemove( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSERemove::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &MutateProteinModelSSERemove::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSERemove::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // if there is only one sse in the protein model do not remove it and return
      if( PROTEIN_MODEL.GetNumberSSEs() == 1)
      {
        // warn user
        BCL_MessageVrb( "Only one SSE in protein model, skipping remove");

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // choose a random sse and make copy
      const util::SiPtr< const assemble::SSE> located_sse( m_Locator->Locate( PROTEIN_MODEL));

      // if sse cannot be located
      if( !located_sse.IsDefined())
      {
        // warn user
        BCL_MessageVrb( "could not find sse in model to be removed: " + util::Format()( *m_Locator));

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // report selected sse from pool to be added
      BCL_MessageVrb( "sse to be removed: " + located_sse->GetIdentification());

      // copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace the sse with the mutated hardcopy of the same sse
      new_model->Remove( *located_sse);

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSERemove::Read( std::istream &ISTREAM)
    {
      // read members
      // return
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateProteinModelSSERemove::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_resize.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_result.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSEResize::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelSSEResize())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSEResize::MutateProteinModelSSEResize() :
      m_SSELocator(),
      m_ExtendProbability( 0.5),
      m_LengthChangeRange(),
      m_Side(),
      m_RecenterAfterResize(),
      m_MinSSESizes(),
      m_Scheme( GetStaticClassName< MutateProteinModelSSEResize>())
    {
    }

    //! @brief constructor from a locator, an extend/shrink probability, length increment and a boolean flag
    //! @param SSE_LOCATOR locator that decides which sse in the proteinmodel to mutate
    //! @param EXTEND_PROBABILITY probability for extending (1.0 - EXTEND_PROBABILITY for shrinking)
    //! @param LENGTH_CHANGE_RANGE range of number of residues that are to be added or removed in one mutate to one end
    //! @param SEQUENCE_SIDE side of sequence to modify
    //! @param RECENTER_AFTER_RESIZE boolean to whether recenter the sse after resize to its original center
    //! @param MIN_SSE_SIZES map of minimum SSE sizes to be allowed when shrinking
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSEResize::MutateProteinModelSSEResize
    (
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &SSE_LOCATOR,
      const double &EXTEND_PROBABILITY,
      const math::Range< size_t> &LENGTH_CHANGE_RANGE,
      const biol::AASequenceFlexibility::SequenceDirection &SEQUENCE_SIDE,
      const bool RECENTER_AFTER_RESIZE,
      const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES,
      const std::string &SCHEME
    ) :
      m_SSELocator( *SSE_LOCATOR),
      m_ExtendProbability( EXTEND_PROBABILITY),
      m_LengthChangeRange( LENGTH_CHANGE_RANGE),
      m_Side( SEQUENCE_SIDE),
      m_RecenterAfterResize( RECENTER_AFTER_RESIZE),
      m_MinSSESizes( MIN_SSE_SIZES),
      m_Scheme( SCHEME)
    {
      static const math::Range< double> s_default_range( 0.0, 1.0);
      // check that probability is within range
      BCL_Assert
      (
        s_default_range.IsWithin( m_ExtendProbability),
        "The given probability should be within range: " + util::Format()( s_default_range.GetString()) + " " +
        util::Format()( EXTEND_PROBABILITY)
      );
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSEResize
    MutateProteinModelSSEResize *MutateProteinModelSSEResize::Clone() const
    {
      return new MutateProteinModelSSEResize( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateProteinModelSSEResize::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return extend probability
    //! @return extend probability
    const double &MutateProteinModelSSEResize::GetExtendProbability() const
    {
      return m_ExtendProbability;
    }

    //! @brief return length change range
    //! @return length change range
    const math::Range< size_t> &MutateProteinModelSSEResize::GetLengthChangeRange() const
    {
      return m_LengthChangeRange;
    }

    //! @brief return which ends are changed
    //! @return sequence direction
    biol::AASequenceFlexibility::SequenceDirection MutateProteinModelSSEResize::GetSide() const
    {
      return m_Side;
    }

    //! @brief returns min sse sizes
    //! @return min sse sizes
    const storage::Map< biol::SSType, size_t> &MutateProteinModelSSEResize::GetMinSSESizes() const
    {
      return m_MinSSESizes;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSEResize::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      const math::MutateResult< assemble::ProteinModel> empty_result( util::ShPtr< assemble::ProteinModel>(), *this);

      // locate an sse and make copy
      const util::SiPtr< const assemble::SSE> located_sse( m_SSELocator->Locate( PROTEIN_MODEL));

      // if sse cannot be located or the located sse is not helix or strand
      if( !located_sse.IsDefined() || located_sse->GetType() > biol::GetSSTypes().STRAND)
      {
        // return empty result
        return empty_result;
      }

      // report selected sse to be extended/shrunk
      BCL_MessageVrb( "selected sse to be extended/shrunk: " + located_sse->GetIdentification());

      // determine whether to extend or shrink
      const bool extend( random::GetGlobalRandom().Double() <= m_ExtendProbability);

      // determine step size
      const size_t step_size( random::GetGlobalRandom().Random< size_t>( m_LengthChangeRange));

      // make a ShPtr to an SSE
      util::ShPtr< assemble::SSE> new_sse;

      // if shrinking is picked
      if( !extend)
      {
        // find the min sse size
        const storage::Map< biol::SSType, size_t>::const_iterator itr( m_MinSSESizes.Find( located_sse->GetType()));
        const size_t min_sse_size( itr == m_MinSSESizes.End() ? 0 : itr->second);

        // is sse long enough
        if( m_Side == biol::AASequenceFlexibility::e_Bidirectional ? 2 * step_size > located_sse->GetSize() : step_size > located_sse->GetSize())
        {
          return empty_result;
        }

        // calculate the size of SSE after the shrinking
        const size_t length_after_shrink
        (
          m_Side == biol::AASequenceFlexibility::e_Bidirectional ? located_sse->GetSize() - 2 * step_size : located_sse->GetSize() - step_size
        );

        // remaining sse long enough?
        if( length_after_shrink < min_sse_size)
        {
          return empty_result;
        }

        // where to shrink
        switch( m_Side)
        {
          // if both ends are shrunk
          case biol::AASequenceFlexibility::e_Bidirectional:
          {
            // assign the new sequence
            new_sse =
              util::ShPtr< assemble::SSE>
              (
                new assemble::SSE( located_sse->SubSequence( step_size, length_after_shrink), located_sse->GetType())
              );
            break;
          }
          case biol::AASequenceFlexibility::e_NTerminal:
          {
            new_sse =
              util::ShPtr< assemble::SSE>
              (
                new assemble::SSE( located_sse->SubSequence( step_size, length_after_shrink), located_sse->GetType())
              );
            break;
          }
          case biol::AASequenceFlexibility::e_CTerminal:
          {
            new_sse =
              util::ShPtr< assemble::SSE>
              (
                new assemble::SSE( located_sse->SubSequence( 0, length_after_shrink), located_sse->GetType())
              );
            break;
          }
          default:
          {
            // return empty result
            return empty_result;
          }
        }
      }

      // if extending
      else
      {
        // create a copy of the located SSE and store it in new_sse
        new_sse = util::ShPtr< assemble::SSE>( located_sse->Clone());

        // create a reference to the sequence
        const biol::AASequence &full_sequence( *PROTEIN_MODEL.GetChain( located_sse->GetChainID())->GetSequence());

        // if extending from both sides
        if( m_Side == biol::AASequenceFlexibility::e_Bidirectional || m_Side == biol::AASequenceFlexibility::e_NTerminal)
        {
          // if there are not enough residues to extend to front ( < step_size), then extend as much as you can
          const size_t extend_size( std::min< size_t>( step_size, located_sse->GetFirstAA()->GetSeqID() - 1));

          // get the residues from the full sequence
          new_sse->PrependSequence
          (
            full_sequence.SubSequence( located_sse->GetFirstAA()->GetSeqID() - extend_size - 1, extend_size)
          );
        }
        // otherwise decide on the end to extend
        if( m_Side == biol::AASequenceFlexibility::e_Bidirectional || m_Side == biol::AASequenceFlexibility::e_CTerminal)
        {
          // store number of residues in the chain
          const size_t nr_residues( full_sequence.GetSize());

          // if there are not enough residues to extend to front ( < step_size), then extend as much as you can
          const size_t extend_size( std::min( nr_residues - located_sse->GetLastAA()->GetSeqID(), step_size));

          // get the residues from the full sequence
          new_sse->AppendSequence( full_sequence.SubSequence( located_sse->GetLastAA()->GetSeqID(), extend_size));
        }

        // make sure the extending does not make this SSE overlap with any other in the protein model
        // except the original SSE we started with
        const util::SiPtrList< const assemble::SSE> overlapping_sses( PROTEIN_MODEL.GetOverlappingSSEs( *new_sse));

        // if more than one
        if( overlapping_sses.GetSize() > 1)
        {
          // warn user
          BCL_MessageVrb
          (
            "Extending causes overlap with " + util::Format()( overlapping_sses.GetSize()) + " SSEs, therefore skipping"
          );
          // return empty result
          return empty_result;
        }
      }

      // print out sse after extend/shrink
      BCL_MessageDbg( "sse after extended/shrunk: " + new_sse->GetIdentification());

      // copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // if only one end is changed, recenter the new sse
      if( m_RecenterAfterResize && m_Side != biol::AASequenceFlexibility::e_Bidirectional)
      {
        const linal::Vector3D translation_to_old_center( located_sse->GetCenter() - new_sse->GetCenter());
        new_sse->Translate( translation_to_old_center);
      }

      // insert the new SSE by replacing the old one
      if( new_sse->GetSize() > 0)
      {
        new_model->ReplaceWithOverlapping( new_sse);
      }
      else
      {
        new_model->Remove( *located_sse);
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateProteinModelSSEResize::GetAlias() const
    {
      static const std::string s_alias( "MutateProteinModelSSEResize");
      return s_alias;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateProteinModelSSEResize::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Resizes SSEs in a protein model");
      serializer.AddInitializer
      (
        "locator",
        "locator for finding SSEs",
        io::Serialization::GetAgent( &m_SSELocator)
      );
      serializer.AddInitializer
      (
        "extend probability",
        "probability to extend an SSE",
        io::Serialization::GetAgent( &m_ExtendProbability)
      );
      serializer.AddInitializer
      (
        "length range",
        "range or residues to add or remove",
        io::Serialization::GetAgent( &m_LengthChangeRange)
      );
      serializer.AddInitializer
      (
        "sequence direction",
        "sequence direction of the resize",
        io::Serialization::GetAgent( &m_Side)
      );
      serializer.AddInitializer
      (
        "recenter",
        "recenter SSE after the resize",
        io::Serialization::GetAgent( &m_RecenterAfterResize)
      );
      serializer.AddInitializer
      (
        "min sse sizes",
        "minimum sizes of SSEs considered for resizing",
        io::Serialization::GetAgent( &m_MinSSESizes)
      );

      return serializer;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_seed.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_aa_sequence_factory.h"
#include "fold/bcl_fold_mutate_protein_model_move_aa.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSESeed::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSSESeed())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSESeed::MutateProteinModelSSESeed()
    {
    }

    //! @brief constructor from a locator and other things
    //! @param SSE_LOCATOR locator that decides to which sse the seed sse is added
    //! @param SEED_LENGTH_RANGE number of residues to construct in seed sse, in addition to the cut
    //! @param DIRECTION the side of the located sse to which the seed sse is attached to
    //! @param SP_MUTATE_SEED optional mutate that is applied to the generated seed before it is added to the model
    //! @param CUT_IN_RANGE number of amino acids to cut into the located sse
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSESeed::MutateProteinModelSSESeed
    (
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &SSE_LOCATOR,
      const math::Range< size_t> &SEED_LENGTH_RANGE,
      const biol::AASequenceFlexibility::SequenceDirection &DIRECTION,
      const util::ShPtr< math::MutateInterface< assemble::SSE> > &SP_MUTATE_SEED,
      const math::Range< size_t> &CUT_IN_RANGE,
      const std::string &SCHEME
    ) :
      m_SSELocator( SSE_LOCATOR),
      m_SeedLengthRange( SEED_LENGTH_RANGE),
      m_Direction( DIRECTION),
      m_MutateSeed( SP_MUTATE_SEED),
      m_CutInRange( CUT_IN_RANGE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSESeed
    MutateProteinModelSSESeed *MutateProteinModelSSESeed::Clone() const
    {
      return new MutateProteinModelSSESeed( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSESeed::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &MutateProteinModelSSESeed::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator taking an PROTEIN_MODEL and returning a protein model with an additional sse
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSESeed::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // locate an sse and make copy
      const util::SiPtr< const assemble::SSE> located_sse( m_SSELocator->Locate( PROTEIN_MODEL));

      // empty model for failed mutate
      const math::MutateResult< assemble::ProteinModel> empty_result( util::ShPtr< assemble::ProteinModel>(), *this);

      // if sse cannot be located or the located sse is not helix or strand
      if( !located_sse.IsDefined() || located_sse->GetType() > biol::GetSSTypes().STRAND)
      {
        // warn user
        BCL_MessageVrb
        (
          "could not find sse to add seed sse to: " + util::Format()( *m_SSELocator)
        );

        // return empty result
        return empty_result;
      }

      // determine length of seed
      const size_t seed_length( random::GetGlobalRandom().Random< size_t>( m_SeedLengthRange));

      // create a reference to the sequence
      const biol::AASequence &full_sequence( *PROTEIN_MODEL.GetChain( located_sse->GetChainID())->GetSequence());

      biol::AASequence extended_sse( *located_sse);
      util::ShPtr< assemble::SSE> sp_new_sse;

      // seed length large 0
      if( seed_length > 0)
      {
        // grow on right side
        if( m_Direction == biol::AASequenceFlexibility::e_CTerminal)
        {
          // if there are not enough aas in the full sequence
          if( int( located_sse->GetLastAA()->GetSeqID() + seed_length) > full_sequence.GetLastAA()->GetSeqID())
          {
            BCL_MessageVrb( "full sequence does not have enough residues for seed sse on c term of: " + located_sse->GetIdentification());
            return empty_result;
          }

          // prepare seed
          assemble::SSE seed_seq( full_sequence.SubSequence( located_sse->GetLastAA()->GetSeqID(), seed_length), located_sse->GetType());
          seed_seq.SetToIdealConformationAtOrigin();

          // attach seed, so that it has correct peptide bond to previous SSE
          const math::TransformationMatrix3D trans( biol::AASequenceFactory::TransformationAppend( *located_sse, *seed_seq.GetFirstAA(), located_sse->GetType()->GetIdealPhi()));
          seed_seq.Transform( trans);
          sp_new_sse = util::ShPtr< assemble::SSE>( new assemble::SSE( seed_seq, biol::GetSSTypes().COIL));
        }
        // grow on left side
        else if( m_Direction == biol::AASequenceFlexibility::e_NTerminal)
        {
          // if there are not enough aas in the full sequence
          if( located_sse->GetFirstAA()->GetSeqID() < int( full_sequence.GetFirstAA()->GetSeqID() + seed_length))
          {
            BCL_MessageVrb( "full sequence does not have enough residues for seed sse on n term of: " + located_sse->GetIdentification());
            return empty_result;
          }

          // prepare seed
          assemble::SSE seed_seq( full_sequence.SubSequence( located_sse->GetFirstAA()->GetSeqID() - seed_length - 1, seed_length), located_sse->GetType());
          seed_seq.SetToIdealConformationAtOrigin();

          // calculate adequate tranformation for attachement
          const math::TransformationMatrix3D trans( biol::AASequenceFactory::TransformationPrepend( *seed_seq.GetLastAA(), *located_sse, located_sse->GetType()->GetIdealPhi()));
          seed_seq.Transform( trans);
          sp_new_sse = util::ShPtr< assemble::SSE>( new assemble::SSE( seed_seq, biol::GetSSTypes().COIL));
        }
        // unable to grow
        else
        {
          BCL_MessageVrb( "sequence direction incompatible");
          return empty_result;
        }
      }

      // copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // cut in if desired
      const size_t cut_in_residues( random::GetGlobalRandom().Random( m_CutInRange));
      if( cut_in_residues >= located_sse->GetSize())
      {
        return empty_result;
      }

      if( cut_in_residues > 0)
      {
        BCL_MessageDbg
        (
          "cutting seed into located sse: " + located_sse->GetIdentification() + " by " + util::Format()( cut_in_residues) + " residues"
        );
        if( m_Direction == biol::AASequenceFlexibility::e_CTerminal)
        {
          if( sp_new_sse.IsDefined())
          {
            const storage::VectorND< 2, util::ShPtr< assemble::SSE> > moved_sses
            (
              MutateProteinModelMoveAA::MoveAAs( *located_sse, *sp_new_sse, cut_in_residues, m_Direction)
            );
            if( !moved_sses.First().IsDefined() && !moved_sses.Second().IsDefined())
            {
              return empty_result;
            }
            new_model->Remove( *located_sse);
            if( moved_sses.First().IsDefined())
            {
              new_model->Insert( moved_sses.First());
            }
            sp_new_sse = moved_sses.Second();
          }
          // split the sse
          else
          {
            const util::ShPtr< assemble::SSE> sp_sse_shorter( new assemble::SSE( located_sse->SubSequence( 0, located_sse->GetSize() - cut_in_residues), located_sse->GetType()));
            new_model->ReplaceWithOverlapping( sp_sse_shorter);
            sp_new_sse = util::ShPtr< assemble::SSE>( new assemble::SSE( located_sse->SubSequence( located_sse->GetSize() - cut_in_residues - 1, cut_in_residues), biol::GetSSTypes().COIL));
          }
        }
        else if( m_Direction == biol::AASequenceFlexibility::e_NTerminal)
        {
          if( sp_new_sse.IsDefined())
          {
            const storage::VectorND< 2, util::ShPtr< assemble::SSE> > moved_sses
            (
              MutateProteinModelMoveAA::MoveAAs( *sp_new_sse, *located_sse, cut_in_residues, m_Direction)
            );
            if( !moved_sses.First().IsDefined() && !moved_sses.Second().IsDefined())
            {
              return empty_result;
            }
            new_model->Remove( *located_sse);
            if( moved_sses.Second().IsDefined())
            {
              new_model->Insert( moved_sses.Second());
            }
            sp_new_sse = moved_sses.First();
          }
          else
          {
            const util::ShPtr< assemble::SSE> sp_sse_shorter( new assemble::SSE( located_sse->SubSequence( cut_in_residues, located_sse->GetSize() - cut_in_residues), located_sse->GetType()));
            new_model->ReplaceWithOverlapping( sp_sse_shorter);
            sp_new_sse = util::ShPtr< assemble::SSE>( new assemble::SSE( located_sse->SubSequence( 0, cut_in_residues), biol::GetSSTypes().COIL));
          }
        }
      }

      // mutate the seed if requested
      if( m_MutateSeed.IsDefined())
      {
        const math::MutateResult< assemble::SSE> result_seed_mutate( m_MutateSeed->operator ()( *sp_new_sse));
        if( result_seed_mutate.GetArgument().IsDefined())
        {
          sp_new_sse = result_seed_mutate.GetArgument();
        }
      }

      // insert the new SSE by replacing the old one
      if( !new_model->Insert( sp_new_sse))
      {
        BCL_MessageVrb( "seed sse overlaps with existing sse: " + sp_new_sse->GetIdentification());
        return empty_result;
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSESeed::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSELocator     , ISTREAM);
      io::Serialize::Read( m_SeedLengthRange, ISTREAM);
      io::Serialize::Read( m_Direction      , ISTREAM);
      io::Serialize::Read( m_MutateSeed     , ISTREAM);
      io::Serialize::Read( m_CutInRange     , ISTREAM);
      io::Serialize::Read( m_Scheme         , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelSSESeed::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSELocator     , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SeedLengthRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Direction      , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MutateSeed     , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_CutInRange     , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme         , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_split.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_placement_sse_short_loop.h"
#include "math/bcl_math_mutate_result.h"
#include "math/bcl_math_running_average_sd.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! @brief the default scheme for this class
    const std::string &MutateProteinModelSSESplit::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "mutate_split_sse");
      return s_default_scheme;
    }

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSESplit::s_Instance
    (
      GetObjectInstances().AddInstance
      (
        new MutateProteinModelSSESplit
        (
          sspred::GetMethods().e_Undefined,
          util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> >(),
          storage::Map< biol::SSType, size_t>(),
          math::Range< size_t>( 0, 0)
        )
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from locator and mutate
    //! @param SS_METHOD the method to use to locate the largest drop in the ss prediction for the located sse
    //! @param SP_LOCATE_SSE locator of sse from domain
    //! @param MIN_SSE_SIZES min sse sizes for the resultant SSEs
    //! @param SPLIT_COIL_LENGTH_RANGE range of length of the coil to be inserted after the split
    //! @param SCHEME the scheme
    MutateProteinModelSSESplit::MutateProteinModelSSESplit
    (
      const sspred::Method &SS_METHOD,
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &SP_LOCATE_SSE,
      const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES,
      const math::Range< size_t> &SPLIT_COIL_LENGTH_RANGE,
      const std::string &SCHEME
    ) :
      m_Method( SS_METHOD),
      m_SSELocator( SP_LOCATE_SSE),
      m_MinSSESizes( MIN_SSE_SIZES),
      m_SplitCoilLengthRange( SPLIT_COIL_LENGTH_RANGE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSESplit
    MutateProteinModelSSESplit *MutateProteinModelSSESplit::Clone() const
    {
      return new MutateProteinModelSSESplit( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSESplit::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &MutateProteinModelSSESplit::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that mutates a single SSE in a given ProteinModel by splitting a single sse
    //! @param PROTEIN_MODEL ProteinModel from which a single SSE will be splitted
    //! @return MutateResult that results from mutating to the PROTEIN_MODEL
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSESplit::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize static undefined pointer to ProteinModel
      static const util::ShPtr< assemble::ProteinModel> sp_undefined_model;

      // locate a sse from the pool
      const util::SiPtr< const assemble::SSE> located_sse( m_SSELocator->Locate( PROTEIN_MODEL));

      // was locating successful
      if( !located_sse.IsDefined())
      {
        return math::MutateResult< assemble::ProteinModel>( sp_undefined_model, *this);
      }

      // length of sse to split
      const size_t seq_length( located_sse->GetSize());

      // length of coil
      const size_t coil_length( random::GetGlobalRandom().Random( m_SplitCoilLengthRange));

      // find the min SSE size, set it to 0 if not containted in the min sse sizes map for that type
      storage::Map< biol::SSType, size_t>::const_iterator sse_size_itr( m_MinSSESizes.Find( located_sse->GetType()));
      const size_t min_size( sse_size_itr == m_MinSSESizes.End() ? 0 : sse_size_itr->second);

      // need enough residues to split
      if( seq_length < coil_length + 2 * min_size)
      {
        return math::MutateResult< assemble::ProteinModel>( sp_undefined_model, *this);
      }

      // initialize left and right coil lengths
      const size_t left_coil_length( coil_length / 2);
      const size_t right_coil_length( coil_length - left_coil_length);

      // find the position to split
      const util::SiPtr< const biol::AABase> sp_aa
      (
        FindSplitPosition( *located_sse, m_Method, min_size + left_coil_length, min_size + right_coil_length)
      );

      // no drop split pos could be identified
      if( !sp_aa.IsDefined())
      {
        return math::MutateResult< assemble::ProteinModel>( sp_undefined_model, *this);
      }

      // determine the split positions for the left and the right SSE
      const size_t split_pos_left
      (
        sp_aa->GetSeqID() - located_sse->GetFirstAA()->GetSeqID() - left_coil_length
      );
      const size_t split_pos_right
      (
        sp_aa->GetSeqID() - located_sse->GetFirstAA()->GetSeqID() + right_coil_length
      );

      // construct two individual SSEs
      util::ShPtr< assemble::SSE> sp_sse_left
      (
        new assemble::SSE( located_sse->SubSequence( 0, split_pos_left), located_sse->GetType())
      );
      util::ShPtr< assemble::SSE> sp_sse_right
      (
        new assemble::SSE
        (
          located_sse->SubSequence( split_pos_right, seq_length - split_pos_right), located_sse->GetType()
        )
      );

      // decide on which one to keep intact in the same place as the original SSE
      bool keep_left_intact( random::GetGlobalRandom().Boolean());

      // if loop of 0 then always add to top, otherwise more chance to add side by side the longer the loop is
      const double add_to_top_probability
      (
        coil_length == 0 ? 1.0 : std::min( 1.0, 2.0 / coil_length)
      );
      // construct the placement object
      const PlacementSSEShortLoop placer( coil_length, add_to_top_probability);

      // determine which SSE to keep intact and which one to move
      const util::ShPtr< assemble::SSE> sp_sse_intact( keep_left_intact ? sp_sse_left : sp_sse_right);
      util::ShPtr< assemble::SSE> sp_sse_placed( keep_left_intact ? sp_sse_right : sp_sse_left);

      // calculate the placement
      const storage::Pair< math::TransformationMatrix3D, bool> placement( placer.Place( *sp_sse_placed, *sp_sse_intact));

      BCL_MessageVrb
      (
        "split sse: " + located_sse->GetIdentification() + " at : " +
        sp_aa->GetIdentification() +
        " into " + sp_sse_left->GetIdentification() + " and " + sp_sse_right->GetIdentification()
      );

      // make sure it is valid
      if( !placement.Second())
      {
        BCL_MessageStd
        (
          "Unable to calculate a placement for the split SSEs for SSE: " + located_sse->GetIdentification()
        );
      }
      else
      {
        // construct transformation initialized with the inverse that will move the selected sse to origin
        math::TransformationMatrix3D trans( sp_sse_placed->GetOrientation());
        trans.Invert();
        trans( placement.First());

        // apply the transformation to the split SSE to be moved
        sp_sse_placed->Transform( trans);
      }

      // clone the model
      util::ShPtr< assemble::ProteinModel> sp_new_model( PROTEIN_MODEL.Clone());

      // replace with overlapping for the moved SSE
      BCL_Assert
      (
        sp_new_model->ReplaceWithOverlapping( sp_sse_placed),
        "Replacement of the following SSE with overlapping one failed: " + sp_sse_placed->GetIdentification()
      );

      // insert the intact SSE and assert insertion
      BCL_Assert
      (
        sp_new_model->Insert( sp_sse_intact), "Insertion of following SSE failed: " + sp_sse_intact->GetIdentification()
      );

      // end
      return math::MutateResult< assemble::ProteinModel>( sp_new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSESplit::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Method         , ISTREAM);
      io::Serialize::Read( m_SSELocator     , ISTREAM);
      io::Serialize::Read( m_MinSSESizes    , ISTREAM);
      io::Serialize::Read( m_SplitCoilLengthRange, ISTREAM);
      io::Serialize::Read( m_Scheme         , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelSSESplit::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Method         , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SSELocator     , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MinSSESizes    , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SplitCoilLengthRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme         , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief find the amino acid right to the highest difference for the given sspred::Method and SSType and report the difference
    //! @param ELEMENT the secondary structure element
    //! @param SSMETHOD the ssprediction method
    //! @param NR_RESIDUES_TO_EXCLUDE number of residues to exclude from both sides
    //! @return Pair of difference and the amino acid to the left
    storage::Pair< util::SiPtr< const biol::AABase>, double>
    MutateProteinModelSSESplit::FindLargestSSPredDifferencePosition
    (
      const assemble::SSE &ELEMENT,
      const sspred::Method &SSMETHOD,
      const size_t NR_RESIDUES_TO_EXCLUDE
    )
    {
      // initialize the pair
      storage::Pair< util::SiPtr< const biol::AABase>, double> aa_diff( util::SiPtr< const biol::AABase>(), 0.0);

      // sequence too short
      if( ELEMENT.GetSize() < 2 * NR_RESIDUES_TO_EXCLUDE)
      {
        return aa_diff;
      }

      // sstype
      const biol::SSType sstype( ELEMENT.GetType());

      // iterator for amino acids
      assemble::SSE::const_iterator itr( ELEMENT.Begin() + NR_RESIDUES_TO_EXCLUDE);
      const assemble::SSE::const_iterator itr_end( ELEMENT.End() - NR_RESIDUES_TO_EXCLUDE);

      // first aa
      aa_diff.First() = *itr;
      double left_prediction( ( *itr)->GetSSPrediction( SSMETHOD)->GetThreeStatePrediction()( sstype));

      // next aa
      ++itr;

      // iterate over all aas
      while( itr != itr_end)
      {
        const double prediction( ( *itr)->GetSSPrediction( SSMETHOD)->GetThreeStatePrediction()( sstype));
        const double difference( prediction - left_prediction);

        // update the highest difference if necessary
        if( math::Absolute( difference) > math::Absolute( aa_diff.Second()))
        {
          aa_diff.First() = *itr;
          aa_diff.Second() = difference;
        }

        // go to next
        left_prediction = prediction;
        ++itr;
      }

      // if largest difference is 0, do not return a position
      if( aa_diff.Second() == 0.0)
      {
        aa_diff.First() = util::SiPtr< const biol::AABase>();
      }

      // end
      return aa_diff;
    }

    //! @brief find the amino acid right to the highest difference for the given sspred::Method and SSType and report the difference
    //! @param ELEMENT the secondary structure element
    //! @param SSMETHOD the ssprediction method
    //! @param NR_RESIDUES_TO_EXCLUDE_LEFT number of residues to exclude from the left side
    //! @param NR_RESIDUES_TO_EXCLUDE_RIGHT number of residues to exclude from the right side
    //! @return Pair of difference and the amino acid to the left
    util::SiPtr< const biol::AABase>
    MutateProteinModelSSESplit::FindSplitPosition
    (
      const assemble::SSE &ELEMENT,
      const sspred::Method &SSMETHOD,
      const size_t NR_RESIDUES_TO_EXCLUDE_LEFT,
      const size_t NR_RESIDUES_TO_EXCLUDE_RIGHT
    )
    {
      // initialize return value
      util::SiPtr< const biol::AABase> sp_aa;

      // sequence too short
      if( ELEMENT.GetSize() < NR_RESIDUES_TO_EXCLUDE_LEFT + NR_RESIDUES_TO_EXCLUDE_RIGHT)
      {
        return sp_aa;
      }

      // sstype
      const biol::SSType sstype( ELEMENT.GetType());

      // iterator for amino acids
      assemble::SSE::const_iterator itr( ELEMENT.Begin() + NR_RESIDUES_TO_EXCLUDE_LEFT);
      const assemble::SSE::const_iterator itr_end( ELEMENT.End() - NR_RESIDUES_TO_EXCLUDE_RIGHT);

      math::RunningAverageSD< double> stats_mean_sd;

      // iterate over all amino acid
      for( ; itr != itr_end; ++itr)
      {
        // make sure there is a prediction
        if( !( *itr)->GetSSPrediction( SSMETHOD).IsDefined())
        {
          return sp_aa;
        }

        const double this_prob( ( *itr)->GetSSPrediction( SSMETHOD)->GetThreeStatePrediction()( sstype));
        stats_mean_sd += this_prob;
      }

      // calculate the cutoff
      const double cutoff( stats_mean_sd.GetAverage() - stats_mean_sd.GetStandardDeviation());

      // store sum
      double sum( 0.0);

      // iterate again
      for( itr = ELEMENT.Begin() + NR_RESIDUES_TO_EXCLUDE_LEFT; itr != itr_end; ++itr)
      {
        const double this_prob( ( *itr)->GetSSPrediction( SSMETHOD)->GetThreeStatePrediction()( sstype));

        // if larger than cutoff skip
        if( this_prob > cutoff)
        {
          continue;
        }

        // sum
        sum += cutoff - this_prob;
      }

      // get a random number [0,sum]
      const double random( random::GetGlobalRandom().Random( sum));

      // initialize running sum
      double running_sum( 0.0);

      // re-initialize iterator
      itr = ELEMENT.Begin() + NR_RESIDUES_TO_EXCLUDE_LEFT;

      while( itr != itr_end)
      {
        // get sspred probability
        const double this_prob( ( *itr)->GetSSPrediction( SSMETHOD)->GetThreeStatePrediction()( sstype));

        // if larger than cutoff skip
        if( this_prob > cutoff)
        {
          ++itr;
          continue;
        }

        // update running sum
        running_sum += cutoff - this_prob;

        // if in correct sum interval identified by the random number, then break
        if( running_sum >= random)
        {
          sp_aa = *itr;
          break;
        }
        ++itr;
      }

      // end
      return sp_aa;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_swap_body.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSESwapBody::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSSESwapBody())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSESwapBody::MutateProteinModelSSESwapBody() :
      m_BodyRestraint(),
      m_BodyPicker(),
      m_Locator(),
      m_Scheme( GetStaticClassName< MutateProteinModelSSESwapBody>())
    {
    }

    //! @brief constructor taking each of the member variable types
    //! @param BODY_RESTRAINT ShPtr to a restraint::Body which will be "m_BodyRestraint"
    //! @param BODY_PICKER ShPtr to a PickerInterface which will be "m_BodyPicker"
    //! @param LOCATOR ShPtr to a LocatorInterface which will by "m_Locator"
    MutateProteinModelSSESwapBody::MutateProteinModelSSESwapBody
    (
      const util::ShPtr< restraint::Body> &BODY_RESTRAINT,
      const util::ShPtr
      <
        find::PickCriteriaInterface< util::ShPtr< assemble::SSEGeometryInterface>, util::ShPtrVector< assemble::SSEGeometryInterface>, assemble::SSEGeometryInterface>
      > &BODY_PICKER,
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &LOCATOR,
      const std::string &SCHEME
    ) :
      m_BodyRestraint( BODY_RESTRAINT),
      m_BodyPicker( BODY_PICKER),
      m_Locator( LOCATOR),
      m_Scheme( SCHEME)
    {
        BCL_Assert( m_BodyPicker.IsDefined(), "body picker pointer that is passed in constructor needs to be defined for move to work");
    }

    //! @brief clone
    MutateProteinModelSSESwapBody *MutateProteinModelSSESwapBody::Clone() const
    {
      return new MutateProteinModelSSESwapBody( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSESwapBody::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel>
    MutateProteinModelSSESwapBody::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // true if PROTEIN_MODEL has no sses in it
      if( PROTEIN_MODEL.GetSSEs().IsEmpty())
      {
        // then return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // create ShPtr to an SSE "new_sse" and initialize with a Clone of the SSE located by "m_Locator" out of
      // PROTEIN_MODEL. "new_sse" will be swapped from its current position into a restraint body
      util::ShPtr< assemble::SSE> new_sse( m_Locator->Locate( PROTEIN_MODEL)->Clone());

      BCL_Assert( m_BodyPicker.IsDefined(), "body picker pointer needs to be defined for move to work");

      // create ShPtr to a assemble::SSEGeometryInterface "unoccupied_body" and initialize with the assemble::SSEGeometryInterface chosen by "m_BodyPicker"
      // out of the bodies that are not occupied by any of the SSE's in PROTEIN_MODEL
      // this is the body which "new_sse" will be moved into
      const util::ShPtr< assemble::SSEGeometryInterface> unoccupied_body
      (
        m_BodyPicker->Pick( m_BodyRestraint->GetUnoccupied( PROTEIN_MODEL.GetSSEs()), *new_sse)
      );

      // true if unoccupied_body is not defined (i.e. all density rods are occupied by sses of the protein model,
      // there is no empty density rod)
      if( !unoccupied_body.IsDefined())
      {
        // then return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // create TransformationMatrix3D "transform_new_sse" and initialize with the inverse transformation matrix
      // of "new_sse" which "moves" the transformation matrix to the origin so
      // rotations of "new_sse" will occur internally
      math::TransformationMatrix3D transform_new_sse( math::Inverse( new_sse->GetOrientation()));

      // apply the transformation matrix of "unoccupied_body" to "transform_new_sse"
      transform_new_sse( unoccupied_body->GetOrientation());

      // move "new_sse" to the position of "unoccupied_body" based on "transform_new_sse"
      new_sse->Transform( transform_new_sse);

      // create ShPtr to a ProteinModel "new_model" and initialize with a clone of "PROTEIN_MODEL"
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace "sse" in "new_model" with "new_sse"
      new_model->Replace( new_sse);

      // return MutateResult constructed from "new_model" and this mutate object
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSESwapBody::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_BodyRestraint, ISTREAM);
      io::Serialize::Read( m_BodyPicker, ISTREAM);
      io::Serialize::Read( m_Locator, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @return output stream which was written to
    std::ostream &MutateProteinModelSSESwapBody::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_BodyRestraint, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_BodyPicker, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Locator, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_swap.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_sse_random.h"
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSESwap::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelSSESwap)
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSESwap::MutateProteinModelSSESwap() :
      m_Locator(),
      m_Bend( false),
      m_Scheme( GetStaticClassName< MutateProteinModelSSESwap>())
    {
    }

    //! @brief constructor from a locator and a scheme
    //! @param LOCATOR locator to be used
    //! @param BEND whether to bend the SSE after swapping to match the original phi/psi angles
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSESwap::MutateProteinModelSSESwap
    (
      const find::LocatorCriteriaInterface
      <
        util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE
      > &LOCATOR,
      const bool BEND,
      const std::string &SCHEME
    ) :
      m_Locator( *LOCATOR.Clone()),
      m_Bend( BEND),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from a ShPtr to a locator and a scheme
    //! @param SP_LOCATOR ShPtr to locator to be used
    //! @param BEND whether to bend the SSE after swapping to match the original phi/psi angles
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSESwap::MutateProteinModelSSESwap
    (
      const util::ShPtr
      <
        find::LocatorCriteriaInterface
        <
          util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE
        >
      > &SP_LOCATOR,
      const bool BEND,
      const std::string &SCHEME
    ) :
      m_Locator( *SP_LOCATOR),
      m_Bend( BEND),
      m_Scheme( SCHEME)
    {
    }

    //! @brief clone
    MutateProteinModelSSESwap *MutateProteinModelSSESwap::Clone() const
    {
      return new MutateProteinModelSSESwap( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSESwap::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSESwap::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // if it has no SSEs or only one SSE
      if
      (
        PROTEIN_MODEL.GetNumberSSE( biol::GetSSTypes().HELIX) < 2 &&
        PROTEIN_MODEL.GetNumberSSE( biol::GetSSTypes().STRAND) < 2
      )
      {
        // then return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // randomly locate a sse from the protein model, this sse will serve as criterion of finding an sse to swap with
      const util::SiPtr< const assemble::SSE> located_sse_a( assemble::LocatorSSERandom().Locate( PROTEIN_MODEL));

      // assert located_sse_a is defined
      BCL_Assert( located_sse_a.IsDefined(), "could not find sse a in model");

      // create temporary util::SiPtr< const SSE> of all the sses in protein model
      util::SiPtrVector< const assemble::SSE> sse_vector( PROTEIN_MODEL.GetSSEs());
      // convert to list
      util::SiPtrList< const assemble::SSE> sse_list( sse_vector.Begin(), sse_vector.End());

      // find the located sse in the list
      util::SiPtrList< const assemble::SSE>::iterator
        sse_list_itr( std::find( sse_list.Begin(), sse_list.End(), located_sse_a));

      // make sure it was found
      BCL_Assert( sse_list_itr != sse_list.End(), "The located SSE was not found in the model when searched");

      // remove it from the list
      sse_list.Remove( sse_list_itr);

      // locate sse that is going to be swapped with located_sse_a
      const util::SiPtr< const assemble::SSE> located_sse_b
      (
        m_Locator->Locate( sse_list, *located_sse_a)
      );

      // if located_sse_b is not defined (e.g. because located_sse_a was the only sse of its type in the model)
      if( !located_sse_b.IsDefined())
      {
        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // report selected sse from pool to be swapped
      BCL_MessageVrb( "selected sse A to be swapped: " + located_sse_a->GetIdentification());
      BCL_MessageVrb( "selected sse B to be swapped: " + located_sse_b->GetIdentification());

      // make copies of both SSEs
      util::ShPtr< assemble::SSE> new_sse_a( located_sse_a->Clone()), new_sse_b( located_sse_b->Clone());

      // if the SSEs need to be bent
      if( m_Bend)
      {
        // fit the sses
        new_sse_a->FitToSSE( *located_sse_b);
        new_sse_b->FitToSSE( *located_sse_a);
      }
      // don't bend the SSEs, keep their current phi/psi angles
      else
      {
        // transform sse_a to position of b
        math::TransformationMatrix3D transform_ab( math::Inverse( located_sse_a->GetOrientation()));
        transform_ab( located_sse_b->GetOrientation());

        // transform sseb to position of a
        math::TransformationMatrix3D transform_ba( math::Inverse( located_sse_b->GetOrientation()));
        transform_ba( located_sse_a->GetOrientation());

        new_sse_a->Transform( transform_ab);
        new_sse_b->Transform( transform_ba);
      }

      // make copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace the sse with the swapped hardcopies of sse a and b
      new_model->Replace( new_sse_a);
      new_model->Replace( new_sse_b);

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_swap_multimer.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_protein_model_multiplier.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSESwapMultimer::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSSESwapMultimer())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from scheme
    //! @param BEND whether to bend the SSE after swapping to match the original phi/psi angles
    //! @param SCHEME scheme
    MutateProteinModelSSESwapMultimer::MutateProteinModelSSESwapMultimer
    (
      const bool BEND,
      const std::string &SCHEME
    ) :
      m_Bend( BEND),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSSESwapMultimer
    MutateProteinModelSSESwapMultimer *MutateProteinModelSSESwapMultimer::Clone() const
    {
      return new MutateProteinModelSSESwapMultimer( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSESwapMultimer::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSESwapMultimer::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // cast a pointer to the multiplier data
      const util::ShPtr< assemble::ProteinModelMultiplier> sp_multiplier
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Multiplier)
      );

      // if the pointer is null
      if( !sp_multiplier.IsDefined())
      {
        // warn the user
        BCL_MessageStd
        (
          "Protein model multiplier not defined, unable to swap SSE with another subunit"
        );

        // return the normal score
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // generate the multimer
      const assemble::ProteinModel multimer_model( sp_multiplier->operator ()( PROTEIN_MODEL));

      // get the number of chains per subunit
      const size_t nr_chains( PROTEIN_MODEL.GetNumberOfChains());

      // get the number of subunits
      const size_t nr_subunits( multimer_model.GetNumberOfChains() / nr_chains);

      // get a random sse
      const util::SiPtrVector< const assemble::SSE> sses( PROTEIN_MODEL.GetSSEs());
      util::ShPtr< assemble::SSE> random_sse
      (
        ( *random::GetGlobalRandom().Iterator( sses.Begin(), sses.End(), sses.GetSize()))->Clone()
      );

      // get the chain id containing the sse to swap, random if it is before or after
      const util::ShPtr< assemble::Chain> swap_chain
      (
        random::GetGlobalRandom().Boolean() ?
          multimer_model.GetChain( char( random_sse->GetChainID() + nr_chains)) :
          multimer_model.GetChain( char( random_sse->GetChainID() + nr_chains * ( nr_subunits - 1)))
      );

      // get the sses in the chain
      util::SiPtrVector< const assemble::SSE> chain_sses( swap_chain->GetSSEs( random_sse->GetType()));

      // iterate through the sses
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator sse_itr( chain_sses.Begin()),
          sse_itr_end( chain_sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // if the SSE matches the random SSE
        if
        (
          ( *sse_itr)->GetFirstAA()->GetPdbID() == random_sse->GetFirstAA()->GetPdbID() &&
          ( *sse_itr)->GetLastAA()->GetPdbID() == random_sse->GetLastAA()->GetPdbID()
        )
        {
          // if the SSE should be bent
          if( m_Bend)
          {
            // fit the SSE
            random_sse->FitToSSE( **sse_itr);
          }
          else
          // don't bend
          {
            // move the random SSE to that position
            random_sse->Transform( math::Inverse( random_sse->GetOrientation()));
            random_sse->Transform( ( *sse_itr)->GetOrientation());
          }
          break;
        }
      }

      // make a copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace the random SSE
      new_model->Replace( random_sse);

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSSESwapMultimer::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Bend, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelSSESwapMultimer::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Bend, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace fold
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_swap_with_pool.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_sse_random.h"
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSESwapWithPool::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance( new MutateProteinModelSSESwapWithPool())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSESwapWithPool::MutateProteinModelSSESwapWithPool() :
      m_Locator(),
      m_Bend( false),
      m_Scheme( GetStaticClassName< MutateProteinModelSSESwapWithPool>())
    {
    }

    //! @brief constructor from a Locator and a scheme
    //! @param LOCATOR Locator that locates an SSE from model to swap with pool
    //! @param BEND whether to bend the SSE after swapping to match the original phi/psi angles
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSESwapWithPool::MutateProteinModelSSESwapWithPool
    (
      const find::LocatorCriteriaInterface
      <
        util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE
      > &LOCATOR,
      const bool BEND,
      const std::string &SCHEME
    ) :
      m_Locator( LOCATOR),
      m_Bend( BEND),
      m_Scheme( SCHEME)
    {
    }

    //! @brief constructor from a ShPtr to Locator and a scheme
    //! @param SP_LOCATOR ShPtr to locator that locates an SSE from model to swap with pool
    //! @param BEND whether to bend the SSE after swapping to match the original phi/psi angles
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSESwapWithPool::MutateProteinModelSSESwapWithPool
    (
      const util::ShPtr
      <
        find::LocatorCriteriaInterface
        <
          util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE
        >
      > &SP_LOCATOR,
      const bool BEND,
      const std::string &SCHEME
    ) :
      m_Locator( *SP_LOCATOR),
      m_Bend( BEND),
      m_Scheme( SCHEME)
    {
    }

    //! @brief clone
    MutateProteinModelSSESwapWithPool *MutateProteinModelSSESwapWithPool::Clone() const
    {
      return new MutateProteinModelSSESwapWithPool( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSESwapWithPool::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateProteinModelSSESwapWithPool::GetAlias() const
    {
      static const std::string s_alias( "MutateProteinModelSSESwapWithPool");
      return s_alias;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateProteinModelSSESwapWithPool::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Swaps two SSEs of the same type.");
      serializer.AddInitializer
      (
        "locator",
        "locates an SSE in a protein model",
        io::Serialization::GetAgent( &m_Locator)
      );
      serializer.AddInitializer
      (
        "bend",
        "bend SSEs after swapping",
        io::Serialization::GetAgent( &m_Bend)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSESwapWithPool::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // declare static random sse picker
      static const assemble::PickSSERandom random_sse_picker;

      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // if empty model
      if( PROTEIN_MODEL.GetSSEs().IsEmpty())
      {
        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // choose a random sse and make copy
      const util::SiPtr< const assemble::SSE> sse_from_model( assemble::LocatorSSERandom().Locate( PROTEIN_MODEL));

      // assert sse_from_model is defined
      BCL_Assert( sse_from_model.IsDefined(), "could not find sse in model");

      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      // if empty pool
      if( !sp_pool.IsDefined())
      {
        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // report selected sse from model to be swapped
      BCL_MessageVrb( "sse to be swapped with pool: " + sse_from_model->GetIdentification());

      // get non-overlapping SSEs from the pool
      util::SiPtrList< const assemble::SSE> non_overlapping_sses( sp_pool->GetNonOverlappingSSEs( PROTEIN_MODEL));

      // locate sse that is going to be swapped with located_sse_a
      const util::SiPtr< const assemble::SSE> sse_from_pool( m_Locator->Locate( non_overlapping_sses, *sse_from_model));

      // if the SSE was not defined
      if( !sse_from_pool.IsDefined())
      {
        BCL_MessageVrb( "Could not pick random non-overlapping sse from pool");
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // make a copy of the sse from the pool
      util::ShPtr< assemble::SSE> sse_to_be_inserted( sse_from_pool->Clone());

      // if the SSE should be bent
      if( m_Bend)
      {
        // fit the SSE
        sse_to_be_inserted->FitToSSE( *sse_from_model);
      }
      else
      // just place an ideal SSE at the location
      {
        // set the body of the sse_from_pool to located sse
        sse_to_be_inserted->Transform( sse_from_model->GetOrientation());
      }

      // copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // remove located sse
      new_model->Remove( *sse_from_model);

      // insert the sse from pool
      new_model->Insert( sse_to_be_inserted);

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_sse_swap_with_pool_overlap.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "fold/bcl_fold_placement_sse_short_loop.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSSESwapWithPoolOverlap::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::ProteinModel> >::AddInstance
      (
        new MutateProteinModelSSESwapWithPoolOverlap()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSSESwapWithPoolOverlap::MutateProteinModelSSESwapWithPoolOverlap() :
      m_Collector(),
      m_SingleSwapsOnly(),
      m_Bend( false),
      m_Scheme( GetStaticClassName< MutateProteinModelSSESwapWithPoolOverlap>())
    {
    }

    //! @brief constructor from a Collector, single swap boolean and a scheme
    //! @param COLLECTOR collector to be used
    //! @param SINGLE_SWAPS_ONLY use single swaps only
    //! @param BEND whether to bend the SSE after swapping to match the original phi/psi angles
    //! @param SCHEME Scheme to be used
    MutateProteinModelSSESwapWithPoolOverlap::MutateProteinModelSSESwapWithPoolOverlap
    (
      const util::ShPtr
      <
        find::CollectorCriteriaInterface
        <
          util::SiPtrList< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE
        >
      > &COLLECTOR,
      const bool SINGLE_SWAPS_ONLY,
      const bool BEND,
      const std::string &SCHEME
    ) :
      m_Collector( *COLLECTOR),
      m_SingleSwapsOnly( SINGLE_SWAPS_ONLY),
      m_Bend( BEND),
      m_Scheme( SCHEME)
    {
    }

    //! @brief clone
    MutateProteinModelSSESwapWithPoolOverlap *MutateProteinModelSSESwapWithPoolOverlap::Clone() const
    {
      return new MutateProteinModelSSESwapWithPoolOverlap( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSSESwapWithPoolOverlap::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateProteinModelSSESwapWithPoolOverlap::GetAlias() const
    {
      static const std::string s_alias( "MutateProteinModelSSESwapWithPoolOverlap");
      return s_alias;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateProteinModelSSESwapWithPoolOverlap::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Swaps two SSEs of the same type.");
      serializer.AddInitializer
      (
        "collector",
        "collect SSEs from a list",
        io::Serialization::GetAgent( &m_Collector)
      );
      serializer.AddInitializer
      (
        "bend",
        "bend SSEs after swapping",
        io::Serialization::GetAgent( &m_Bend)
      );
      serializer.AddInitializer
      (
        "single swaps",
        "disallow multiple swaps",
        io::Serialization::GetAgent( &m_SingleSwapsOnly)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelSSESwapWithPoolOverlap::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize static random picker
      static const assemble::PickSSERandom random_sse_picker;

      // initialize empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // if empty model
      if( PROTEIN_MODEL.GetSSEs().IsEmpty())
      {
        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // get the pool from the given ProteinModel and make sure it is valid
      const util::ShPtr< assemble::SSEPool> sp_pool
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      if( !sp_pool.IsDefined())
      {
        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // find sses in protein model that have at least one overlapping sse in the pool
      const util::SiPtrList< const assemble::SSE>
      eligible_sses
      (
        PROTEIN_MODEL.GetOverlappingSSEs( sp_pool->GetNonIdenticalSSEs( PROTEIN_MODEL))
      );

      // if there are no eligible sses
      if( eligible_sses.IsEmpty())
      {
        // warn user
        BCL_MessageVrb( "no sses in the protein model overlap with the pool");

        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // chose one of these sses randomly
      const util::SiPtr< const assemble::SSE> located_sse( random_sse_picker.Pick( eligible_sses));

      // make sure the sse is found correctly
      BCL_Assert( located_sse.IsDefined(), "could not find sses in model using " + util::Format()( random_sse_picker));

      // report selected sse from pool to be swapped
      BCL_MessageVrb( "sse to be swapped with pool: " + located_sse->GetIdentification());

      // find overlapping sses from the protein model and collect the subset of the overlapping SSEs
      util::SiPtrList< const assemble::SSE> overlapping_sses
      (
        m_Collector->Collect( sp_pool->GetOverlappingSSEs( *located_sse), *located_sse)
      );

      // if none of the sses in overlapping_sses_vector fulfilled the criterion, return empty result
      if( overlapping_sses.IsEmpty())
      {
        // return empty result
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // make a copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // boolean to indicate if swapping with multiple overlapping was possible
      bool swap_multiple( false);

      // if there are more than one overlapping SSE
      if( !m_SingleSwapsOnly && overlapping_sses.GetSize() > 1)
      {
        // see if there are any pair of these overlapping SSEs
        // that do not overlap with each other and also do not overlap with anything else in the model

        // make a new list
        util::SiPtrList< const assemble::SSE> possible_sses;

        // iterate over the list
        for
        (
          util::SiPtrList< const assemble::SSE>::const_iterator
            pool_itr( overlapping_sses.Begin()), pool_itr_end( overlapping_sses.End());
          pool_itr != pool_itr_end; ++pool_itr
        )
        {
          // if this SSE overlaps with only one SSE, thus if it does not overlap with another SSE other than the located_sse
          if( PROTEIN_MODEL.GetOverlappingSSEs( **pool_itr).GetSize() == 1)
          {
            possible_sses.PushBack( *pool_itr);
          }
        }

        // if there are enough SSEs left
        if( possible_sses.GetSize() >= 2)
        {
          // make a list of possible pairs
          storage::Vector< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > > possible_pairs;

          // iterate over the possible SSEs
          for
          (
            util::SiPtrList< const assemble::SSE>::const_iterator
              sse_itr_a( possible_sses.Begin()), sse_itr_end( possible_sses.End());
            sse_itr_a != sse_itr_end; ++sse_itr_a
          )
          {
             // initialize sse_itr_b
            util::SiPtrList< const assemble::SSE>::const_iterator sse_itr_b( sse_itr_a);
            ++sse_itr_b;

            // iterate while not reaching end
            while( sse_itr_b != sse_itr_end)
            {
              // if two sses do not overlap
              if( !biol::DoOverlap( **sse_itr_a, **sse_itr_b))
              {
                possible_pairs.PushBack
                (
                  storage::VectorND< 2, util::SiPtr< const assemble::SSE> >( **sse_itr_a, **sse_itr_b)
                );
                possible_pairs.PushBack
                (
                  storage::VectorND< 2, util::SiPtr< const assemble::SSE> >( **sse_itr_b, **sse_itr_a)
                );
              }
              ++sse_itr_b;

            } // sse_itr_b
          } // sse_itr_a

          // if such pairs were found
          if( !possible_pairs.IsEmpty())
          {
            // pick one randomly
            storage::VectorND< 2, util::SiPtr< const assemble::SSE> > sse_pair( possible_pairs.RemoveRandomElement());

            // make a copy of both SSEs
            util::ShPtr< assemble::SSE> sse_from_pool_a( sse_pair.First()->Clone());
            util::ShPtr< assemble::SSE> sse_from_pool_b( sse_pair.Second()->Clone());

            // if the SSE should be bent
            if( m_Bend)
            {
              // fit the sequence
              sse_from_pool_a->FitToSSE( *located_sse);
            }
            // just place an ideal SSE
            else
            {
              // put the first one in located SSEs place
              sse_from_pool_a->Transform( located_sse->GetOrientation());
            }

            // replace with located SSE
            new_model->ReplaceWithOverlapping( sse_from_pool_a);

            // now add the second one using short loop placement
            storage::Pair< math::TransformationMatrix3D, bool> transformation
            (
              PlacementSSEShortLoop().Place( *sse_from_pool_b, *new_model)
            );

            // if the placement was successful
            if( transformation.Second())
            {
              // apply the transformation
              sse_from_pool_b->Transform( transformation.First());

              // insert into model
              new_model->Insert( sse_from_pool_b);
            }

            // set the boolean
            swap_multiple = true;
          }
        }
      }

      // if swap multiple was not possible
      if( !swap_multiple)
      {

        // pick one randomly from overlapping_sses
        util::SiPtr< const assemble::SSE> overlapping_sse( random_sse_picker.Pick( overlapping_sses));

        // assert that one was picked correctly
        BCL_Assert( overlapping_sse.IsDefined(), "Could not pick random overlapping sse from pool");

        // make a copy of the sse from the pool
        util::ShPtr< assemble::SSE> sse_from_pool( overlapping_sse->Clone());

        // if the SSE should be bent
        if( m_Bend)
        {
          // fit the sequence
          sse_from_pool->FitToSSE( *located_sse);
        }
        // just place an ideal SSE
        else
        {
          // set the body of the sse_from_pool to located sse
          sse_from_pool->Transform( located_sse->GetOrientation());
        }

        // replace the located_sse with sse_from_pool
        new_model->ReplaceWithOverlapping( sse_from_pool);
      }

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_strand_switch_sheet.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sheet.h"
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelStrandSwitchSheet::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelStrandSwitchSheet())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelStrandSwitchSheet::MutateProteinModelStrandSwitchSheet() :
      m_Placement(),
      m_Scheme( GetStaticClassName< MutateProteinModelStrandSwitchSheet>())
    {
    }

    //! @brief constructor from a placement and a scheme
    //! @param PLACEMENT reference to the PlacementStrandNextToSheet to be used
    //! @param SCHEME Scheme to be used
    MutateProteinModelStrandSwitchSheet::MutateProteinModelStrandSwitchSheet
    (
      const PlacementStrandNextToSheet &PLACEMENT,
      const std::string &SCHEME
    ) :
      m_Placement( PLACEMENT),
      m_Scheme( SCHEME)
    {

    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelStrandSwitchSheet
    MutateProteinModelStrandSwitchSheet *MutateProteinModelStrandSwitchSheet::Clone() const
    {
      return new MutateProteinModelStrandSwitchSheet( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelStrandSwitchSheet::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator taking an ProteinModel and returning a mutated ProteinModel
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateProteinModelStrandSwitchSheet::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // make an empty return pointer
      static util::ShPtr< assemble::ProteinModel> s_empty_result;

      // initialize the static sheet collector
      static const assemble::CollectorSheet s_sheet_collector;

      // collect all the sheets in the model
      const util::ShPtrVector< assemble::Domain> sheet_vector( s_sheet_collector.Collect( PROTEIN_MODEL));

      // if there are not at least two sheets
      if( sheet_vector.GetSize() < 2)
      {
        // then this move can't be applied
        return math::MutateResult< assemble::ProteinModel>( s_empty_result, *this);
      }

      // create a SiPtrVector of sheets
      util::SiPtrVector< const assemble::Domain> possible_sheets( sheet_vector);

      // pick two randomly
      const util::SiPtr< const assemble::Domain> receiver_sheet( possible_sheets.RemoveRandomElement());
      const util::SiPtr< const assemble::Domain> donator_sheet( possible_sheets.RemoveRandomElement());

      // now pick one of the edge from the donator sheet
      util::SiPtr< const assemble::SSEGeometryInterface> sse_to_move
      (
        random::GetGlobalRandom().Boolean() ?
          donator_sheet->GetTopology()->GetElements().FirstElement() :
          donator_sheet->GetTopology()->GetElements().LastElement()
      );

      // make a copy of the SSE
      util::ShPtr< assemble::SSE> new_sse( sse_to_move->Clone());
      // check the dynamic cast
      BCL_Assert( new_sse.IsDefined(), "The dynamic cast has failed from SSEGeometryInterface to SSE")

      // get the placement
      storage::Pair< math::TransformationMatrix3D, bool> placement
      (
        m_Placement.Place( *new_sse, *receiver_sheet)
      );

      // if the placement failed
      if( !placement.Second())
      {
        return math::MutateResult< assemble::ProteinModel>( s_empty_result, *this);
      }

      // build up the transformation that moves it to origin and then moves to the placement determined
      math::TransformationMatrix3D transformation( math::Inverse( new_sse->GetOrientation()));
      transformation( placement.First());

      // apply the transformation
      new_sse->Transform( transformation);

      // make a copy of the model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // replace the sse
      new_model->Replace( new_sse);

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelStrandSwitchSheet::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Placement, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelStrandSwitchSheet::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Placement, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "fold/bcl_fold_mutate_protein_model_switch_conformation.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelSwitchConformation::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelSwitchConformation())
    );
  
  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelSwitchConformation::MutateProteinModelSwitchConformation() :
      m_ConformationLocator(),
      m_Scheme( GetStaticClassName< MutateProteinModelSwitchConformation>())
    {
    }

    //! @brief constructor taking parameters
    //! @param LOCATOR the method for locating an alternative conformation
    //! @param SCHEME Scheme to be used
    MutateProteinModelSwitchConformation::MutateProteinModelSwitchConformation
    (
      const util::ShPtr
      <
        find::LocatorInterface< util::SiPtr< const assemble::ProteinModel>, assemble::ProteinModel>
      > &CONFORMATION,
      const std::string &SCHEME
    ) :
      m_ConformationLocator( CONFORMATION),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelSwitchConformation
    MutateProteinModelSwitchConformation *MutateProteinModelSwitchConformation::Clone() const
    {
      return new MutateProteinModelSwitchConformation( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelSwitchConformation::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel>
    MutateProteinModelSwitchConformation::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // static empty model
      const math::MutateResult< assemble::ProteinModel> empty_result( util::ShPtr< assemble::ProteinModel>(), *this);

      // try to locate an alternative conformation
      util::SiPtr< const assemble::ProteinModel> located_conformation( m_ConformationLocator->Locate( PROTEIN_MODEL));

      // if no new conformation could be found
      if( !located_conformation.IsDefined())
      {
        return empty_result;
      }

      // copy the protein model
      util::ShPtr< assemble::ProteinModel> new_model( located_conformation->Clone());

      // copy the conformational ensemble from PROTEIN_MODEL
      assemble::ProteinEnsemble conformations( PROTEIN_MODEL.GetConformationalEnsemble());

      // find the index of the located conformation in the list of conformations
      const size_t index( conformations.GetEnsembleData().Find( located_conformation));

      // if the index of the located conformation could not be determined
      if( index >= conformations.GetSize())
      {
        BCL_MessageDbg( "could not determine index of located conformation");
        return empty_result;
      }

      // remove the located conformation from the list of them since it will be the conformation represented by the
      // protein model
      conformations.GetEnsembleData().RemoveElements( index);

      // clone PROTEIN_MODEL
      util::ShPtr< assemble::ProteinModel> old_model_copy( PROTEIN_MODEL.Clone());

      // copy the conformational ensemble from old_model_copy
      assemble::ProteinEnsemble old_model_copy_conformations( PROTEIN_MODEL.GetConformationalEnsemble());

      // reset the conformations in old_model_copy_conformations
      old_model_copy_conformations.Reset();

      // set the conformations in old_model_copy so that it does not have any conformational ensemble on its own
      old_model_copy->SetConformationalEnsemble( old_model_copy_conformations);

      // add PROTEIN_MODEL to the conformational ensemble
      conformations.InsertElement( old_model_copy);

      // set the conformations in the new model
      new_model->SetConformationalEnsemble( conformations);

      // return the new model
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelSwitchConformation::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ConformationLocator, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelSwitchConformation::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ConformationLocator, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_protein_model_thread_sequence.h"

// includes from bcl - sorted alphabetically
#include "align/bcl_align_alignment_interface.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_aa_compare.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateProteinModelThreadSequence::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateProteinModelThreadSequence())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateProteinModelThreadSequence::MutateProteinModelThreadSequence() :
      m_Alignment(),
      m_PrintStructuralProblemResidues(),
      m_Scheme()
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param CHAIN_ALIGNMENT for each chain, the alignment that should be used
    //! @param SCHEME the scheme of the mutate
    MutateProteinModelThreadSequence::MutateProteinModelThreadSequence
    (
      const storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > &CHAIN_ALIGNMENT,
      const std::string &SCHEME,
      const bool PRINT_STRUCTURAL_PROBLEM_AAS
    ) :
      m_Alignment( CHAIN_ALIGNMENT),
      m_PrintStructuralProblemResidues( PRINT_STRUCTURAL_PROBLEM_AAS),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateProteinModelThreadSequence
    MutateProteinModelThreadSequence *MutateProteinModelThreadSequence::Clone() const
    {
      return new MutateProteinModelThreadSequence( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateProteinModelThreadSequence::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &MutateProteinModelThreadSequence::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel>
    MutateProteinModelThreadSequence::operator()( const assemble::ProteinModel &PROTEIN_MODEL) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      // copy the model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // iterate through the alignments for each chain
      for
      (
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::const_iterator
          align_itr( m_Alignment.Begin()), align_itr_end( m_Alignment.End());
        align_itr != align_itr_end;
        ++align_itr
      )
      {
        // the current chain the current alignment corresponds to
        const char chain_id( align_itr->first);

        // get the chain out of the protein model
        const util::ShPtr< assemble::Chain> current_chain( new_model->GetChain( chain_id));

        // true if the chain does not exist in the protein model
        if( !current_chain.IsDefined())
        {
          // go to next alignment and chain
          continue;
        }

        // thread the sequence onto the chain according to the current alignment
        const util::ShPtr< assemble::Chain> new_chain
        (
          ThreadSequenceOntoChain( *current_chain, *align_itr->second)
        );

        // replace the new chain in the protein model
        const util::ShPtr< assemble::ProteinModel> current_model( UpdateChainInModel( *new_model, new_chain));

        // set the new model to the current model with the current chain just threaded
        new_model = current_model;

        if( m_PrintStructuralProblemResidues)
        {
          util::GetLogger() << OutputStructurallyProbematicSequenceRegions( *current_chain, *align_itr->second)
            << "\n";
        }
      }

      // construct mutate result
      const math::MutateResult< assemble::ProteinModel> mutate_result( new_model, *this);

      // return mutate result
      return mutate_result;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateProteinModelThreadSequence::Read( std::istream &ISTREAM)
    {
      // read members
      BCL_Exit( "cannot read Alignments", 1);
      io::Serialize::Read( m_Alignment, ISTREAM);
      io::Serialize::Read( m_PrintStructuralProblemResidues, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateProteinModelThreadSequence::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Alignment, OSTREAM, INDENT);
      io::Serialize::Write( m_PrintStructuralProblemResidues, OSTREAM, INDENT);
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief uses a sequence alignment to assign coordinates from a chain onto a sequence with unknown structure
    //! @param CHAIN the coordinates that will be assigned to sequence of unknown structure
    //! @param ALIGNMENT the sequence alignment indicating which residues to assign which coordinates to
    //! @return shptr to chain which has the second sequence from the alignment but coordinates from the CHAIN param
    util::ShPtr< assemble::Chain> MutateProteinModelThreadSequence::ThreadSequenceOntoChain
    (
      const assemble::Chain &CHAIN, const align::AlignmentInterface< biol::AABase> &ALIGNMENT
    )
    {
      // make sure the alignment has two sequences
      BCL_Assert
      (
        ALIGNMENT.GetDepth() == 2, "the alignment needs to have 2 sequences but has "
        + util::Format()( ALIGNMENT.GetDepth())
      );

      // get the current chain sequence id
      const std::string chain_seq_id( CHAIN.GetSequence()->GetSequenceId());

      // get the sequence ids of the alignment
      const storage::List< std::string> alignment_seq_ids( ALIGNMENT.GetSequenceIds());

      // known coordinates for iterating through
      const biol::AASequence &coord_seq( *CHAIN.GetSequence());
      biol::AASequence::const_iterator seq_itr( coord_seq.Begin()), seq_itr_end( coord_seq.End());

      // will hold the sequence from the second in the alignment but coordinates from the CHAIN
      util::ShPtr< biol::AASequence> new_sequence( new biol::AASequence());

      // the assignments from the alignment
      const util::ShPtrList< align::Assignment< biol::AABase> > &assignments( ALIGNMENT.GetAssignments());

      // iterate through the assignments
      for
      (
        util::ShPtrList< align::Assignment< biol::AABase> >::const_iterator
          assign_itr( assignments.Begin()), assign_itr_end( assignments.End());
        assign_itr != assign_itr_end && seq_itr != seq_itr_end;
        ++assign_itr
      )
      {
        // make sure the current assignment is defined and get a reference to it
        BCL_Assert( assign_itr->IsDefined(), "assignment is not defined");
        const align::Assignment< biol::AABase> &current_assign( **assign_itr);

        // get the members from the assignment
        const util::SiPtrList< const biol::AABase> &members( current_assign.GetMembers());

        // should only be two members in the assignment
        BCL_Assert( members.GetSize() == 2, "members size is not 2 but " + util::Format()( members.GetSize()));

        // sequence with known coordinates (from CHAIN) is the first sequence
        const util::SiPtr< const biol::AABase> &member_start_seq( members.FirstElement());

        // sequence with unknown coordinates but is the desired sequence is the second sequence
        const util::SiPtr< const biol::AABase> &member_new_seq( members.LastElement());

        // true if both residues in the alignment are defined
        if( member_start_seq.IsDefined() && member_new_seq.IsDefined())
        {
          // make new aa data from the new sequence
          const util::ShPtr< biol::AAData> new_data( member_new_seq->GetData()->Clone());

          // make new residue from the new data
          util::ShPtr< biol::AABase> new_aa( ( *( *seq_itr)->GetAAClass())->Empty( new_data));

          //  assert matching aa types from the sequence of known coordinates and from the chain and alignment
          BCL_Assert
          (
            member_start_seq->GetType() == ( *seq_itr)->GetType(),
            "types differ for : template sequence from alignment : " + member_start_seq->GetIdentification() +
            " versus coordinate sequence from pdb :" + ( *seq_itr)->GetIdentification()
          );

          BCL_MessageDbg( "adding new residue " + new_aa->GetIdentification());

          // get the atoms from the sequence of known structure
          const util::SiPtrVector< const biol::Atom> &atoms( ( *seq_itr)->GetAtoms());

          // set the atoms and coordinates of the new residue
          new_aa->SetAtoms( atoms);

          // add the residue to the new sequence
          new_sequence->PushBack( new_aa);

          // go to next residue with known coordinates
          ++seq_itr;
        }
        // aa of desired sequence is not defined (gap in desired sequence)
        else if( member_start_seq.IsDefined() && !member_new_seq.IsDefined())
        {
          // go to next residue with known coordinates
          ++seq_itr;

          // go to next residues
          continue;
        }
        // aa of known coordinates is not defined (gap in sequence of known coordinates)
        else if( !member_start_seq.IsDefined() && member_new_seq.IsDefined())
        {
          // make new aa data
          const util::ShPtr< biol::AAData> new_data( member_new_seq->GetData()->Clone());

          // make new residue - won't have any coordinates
          const util::ShPtr< biol::AABase> new_aa( ( *( *seq_itr)->GetAAClass())->Empty( new_data));

          BCL_MessageDbg( "adding new residue " + new_aa->GetIdentification());

          // add new residue to the new sequence
          new_sequence->PushBack( new_aa);
        }
        else
        {
          BCL_Exit( "both the starting sequence and desired sequence are undefined in alignment", 1);
        }
      }

      // set the chain of the new sequence
      new_sequence->SetChainID( coord_seq.GetChainID());

      BCL_MessageDbg( "SetChainID to |" + util::Format()( new_sequence->GetChainID()) + "|");

      // make vector of sses with the entire new sequence as a coil sse
      const util::ShPtrVector< assemble::SSE> sses
      (
        1, util::ShPtr< assemble::SSE>( new assemble::SSE( *new_sequence, biol::GetSSTypes().COIL))
      );

      // create a new chain
      const util::ShPtr< assemble::Chain> new_chain( new assemble::Chain( new_sequence, sses));

      // return the new chain
      return new_chain;
    }

    //! @brief replaces a chain in a model
    //! @param MODEL the model in which the chain will be replaced
    //! @param CHAIN the chain which will replace existing chain in the provided model
    //! @return shptr to a new protein model with the desired chain replaced
    util::ShPtr< assemble::ProteinModel>
    MutateProteinModelThreadSequence::UpdateChainInModel
    (
      const assemble::ProteinModel &MODEL, const util::ShPtr< assemble::Chain> &CHAIN
    )
    {
      // make new model
      util::ShPtr< assemble::ProteinModel> current_model( new assemble::ProteinModel());

      // set the data of the model
      current_model->SetProteinModelData( MODEL.GetProteinModelData());

      // insert the chains into the current model
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( MODEL.GetChains().Begin()), chain_itr_end( MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // true if the current chain is not the one that should be replaced
        if( ( *chain_itr)->GetChainID() != CHAIN->GetChainID())
        {
          BCL_MessageDbg( "inserting chain " + util::Format()( ( *chain_itr)->GetChainID()));
          current_model->Insert( *chain_itr);
        }
        else //< need to insert the new chain
        {
          current_model->Insert( CHAIN);
        }
      }

      // return the updated model
      return current_model;
    }

    //! @brief uses a sequence alignment to and chain to determine which stretches of unknown structure need rebuilt
    //!        This could be due e.g. to not having coordinates from the template structure, or if there are gaps in
    //!        the sequence of unknown structure (since this will likely lead to a chain break).
    //! @param CHAIN the coordinates that will be assigned to sequence of unknown structure
    //! @param ALIGNMENT the sequence alignment indicating which residues to assign which coordinates to
    //! @return string which has the regions of the sequence of unknown structure which most likely need rebuilt
    std::string MutateProteinModelThreadSequence::OutputStructurallyProbematicSequenceRegions
    (
      const assemble::Chain &CHAIN, const align::AlignmentInterface< biol::AABase> &ALIGNMENT
    )
    {
      // make sure the alignment has two sequences
      BCL_Assert
      (
        ALIGNMENT.GetDepth() == 2, "the alignment needs to have 2 sequences but has "
        + util::Format()( ALIGNMENT.GetDepth())
      );
      // known coordinates for iterating through
      const biol::AASequence &coord_seq( *CHAIN.GetSequence());
      biol::AASequence::const_iterator seq_itr( coord_seq.Begin()), seq_itr_end( coord_seq.End());

      // the assignments from the alignment
      const util::ShPtrList< align::Assignment< biol::AABase> > &assignments( ALIGNMENT.GetAssignments());

      storage::Set< util::SiPtr< const biol::AABase>, biol::AALessThanSeqID> problem_resis;

      util::SiPtr< const biol::AABase> last_defined_new_seq;

      // iterate through the assignments
      for
      (
        util::ShPtrList< align::Assignment< biol::AABase> >::const_iterator
          assign_itr( assignments.Begin()), assign_itr_end( assignments.End());
        assign_itr != assign_itr_end && seq_itr != seq_itr_end;
        ++assign_itr
      )
      {
        // make sure the current assignment is defined and get a reference to it
        BCL_Assert( assign_itr->IsDefined(), "assignment is not defined");
        const align::Assignment< biol::AABase> &current_assign( **assign_itr);

        // get the members from the assignment
        const util::SiPtrList< const biol::AABase> &members( current_assign.GetMembers());

        // should only be two members in the assignment
        BCL_Assert( members.GetSize() == 2, "members size is not 2 but " + util::Format()( members.GetSize()));

        // sequence with known coordinates (from CHAIN) is the first sequence
        const util::SiPtr< const biol::AABase> &member_start_seq( members.FirstElement());

        // sequence with unknown coordinates but is the desired sequence is the second sequence
        const util::SiPtr< const biol::AABase> &member_new_seq( members.LastElement());

        if( member_new_seq.IsDefined())
        {
          last_defined_new_seq = member_new_seq;
        }

        // true if both residues in the alignment are defined
        if( member_start_seq.IsDefined() && member_new_seq.IsDefined())
        {
          // go to next residue with known coordinates
          ++seq_itr;
        }
        // aa of desired sequence is not defined (gap in desired sequence)
        else if( member_start_seq.IsDefined() && !member_new_seq.IsDefined())
        {
          if( last_defined_new_seq.IsDefined())
          {
//              BCL_Assert
//              (
//                problem_resis.Insert( last_defined_new_seq).second, "could not insert " + last_defined_new_seq->GetIdentification()
//              );

            problem_resis.Insert( last_defined_new_seq);
          }

          // go to next residue with known coordinates
          ++seq_itr;

          // go to next residues
          continue;
        }
        // aa of known coordinates is not defined (gap in sequence of known coordinates)
        else if( !member_start_seq.IsDefined() && member_new_seq.IsDefined())
        {
          BCL_Assert( member_new_seq.IsDefined(), "resi is not defined");
          BCL_Assert
          (
            problem_resis.Insert( member_new_seq).second, "could not insert " + member_new_seq->GetIdentification()
          );
        }
        else
        {
          BCL_Exit( "both the starting sequence and desired sequence are undefined in alignment", 1);
        }
      }

      std::string problem_residues;
      util::SiPtr< const biol::AABase> region_start_aa( *problem_resis.Begin());
      util::SiPtr< const biol::AABase> region_previous_aa( region_start_aa);
      int previous_seq_id( region_start_aa->GetSeqID() - 1);
      for
      (
        storage::Set< util::SiPtr< const biol::AABase>, biol::AALessThanSeqID>::const_iterator
          resi_itr( problem_resis.Begin()), resi_itr_end( problem_resis.End());
        resi_itr != resi_itr_end;
        ++resi_itr
      )
      {
        if( ( *resi_itr)->GetSeqID() == previous_seq_id + 1)
        {
          previous_seq_id = ( *resi_itr)->GetSeqID();
          region_previous_aa = ( *resi_itr);
        }
        else
        {
          BCL_Assert( resi_itr->IsDefined(), "resi is not defined");
          problem_residues += region_start_aa->GetIdentification() + " to " + region_previous_aa->GetIdentification() + "\n";
          region_start_aa = ( *resi_itr);
          region_previous_aa = ( *resi_itr);
          previous_seq_id = ( *resi_itr)->GetSeqID();
        }
      }

      problem_residues += region_start_aa->GetIdentification() + " to " + region_previous_aa->GetIdentification() + "\n";

      return problem_residues;
    }

    //! @brief determines if a residue has any defined coordinates
    //! @param RESI the residue that will be checked to see if it has any defined coordinates
    //! @return boolean true if there are any defined atom coordinates in RESI - false otherwise
    bool MutateProteinModelThreadSequence::HasAnyDefinedCoordinates( const biol::AABase &RESI)
    {
      const util::SiPtrVector< const linal::Vector3D> &coords( RESI.GetAtomCoordinates());

      bool has_any_defined_coords( false);
      for
      (
        util::SiPtrVector< const linal::Vector3D>::const_iterator
          coord_itr( coords.Begin()), coord_itr_end( coords.End());
        coord_itr != coord_itr_end;
        ++coord_itr
      )
      {
        if( coord_itr->IsDefined())
        {
          has_any_defined_coords = true;
        }
      }

      return has_any_defined_coords;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_mutate_protein_model_fix_loop_closure_wrapper.h"
#include "fold/bcl_fold_mutate_protein_model_sse_pair_clash.h"
#include "fold/bcl_fold_mutate_protein_model_sse_pair_fix_loop_closure.h"
#include "fold/bcl_fold_mutates.h"
#include "math/bcl_math_mutate_combine.h"
#include "util/bcl_util_enumerate.hpp"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    Mutates::Mutates()
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &Mutates::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief adds a mutate to the enumerated mutates
    //! @param SP_MUTATE ShPtr to Mutate to add
    Mutates::EnumType Mutates::AddMutate( const util::ShPtr< math::MutateInterface< assemble::ProteinModel> > &SP_MUTATE)
    {
      return AddEnum( SP_MUTATE->GetScheme(), SP_MUTATE);
    }

    //! @brief adds a mutate to the enumerated mutates
    //! @param MUTATE Mutate to add
    Mutates::EnumType Mutates::AddMutate( const math::MutateInterface< assemble::ProteinModel> &MUTATE)
    {
      // construct ShPtr
      util::ShPtr< math::MutateInterface< assemble::ProteinModel> > sp_mutate( MUTATE.Clone());

      return AddEnum( sp_mutate->GetScheme(), sp_mutate);
    }

    //! @brief function for adding a new enum
    //! @param NAME name of the current enum
    //! @param OBJECT object to be enumerated
    Mutates::EnumType &Mutates::AddEnum
    (
      const std::string &NAME,
      const util::ShPtr< math::MutateInterface< assemble::ProteinModel> > &OBJECT
    )
    {
      util::ShPtr< math::MutateInterface< assemble::ProteinModel> > combined
      (
        new MutateProteinModelFixLoopClosureWrapper( *OBJECT, OBJECT->GetScheme())
      );
      return util::Enumerate< util::ShPtr< math::MutateInterface< assemble::ProteinModel> >, Mutates>::AddEnum( NAME, combined);
    }

    //! @brief construct on access function for all Mutates
    //! @return reference to only instances of Mutates
    Mutates &GetMutates()
    {
      return Mutates::GetEnums();
    }

  } // namespace fold

  namespace util
  {

  /////////////////////////////
  // explicit instantiations //
  /////////////////////////////

    template class BCL_API Enumerate< ShPtr< math::MutateInterface< assemble::ProteinModel> >, fold::Mutates>;

  } // namespace util
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sheet_cycle.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate instance
    const util::SiPtr< const util::ObjectInterface> MutateSheetCycle::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSheetCycle())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from applicable bools and ranges
    //! @param PRESERVE_SHEET_GEOMETRY boolean to whether to keep the sheet geometry intact
    //! @param PRESERVE_STRAND_ORIENTATIONS boolean to whether to keep the orientations of individiual strands intact
    //! @param ROTATE_SUBSET boolean to whether to rotate a subset
    //! @param NUMBER_ROTATIONS minimum and maximum number of rotations
    //! @param NUMBER_ROTATIONS minimum and maximum number of strands in the rotation group
    MutateSheetCycle::MutateSheetCycle
    (
      const bool PRESERVE_SHEET_GEOMETRY,
      const bool PRESERVE_STRAND_ORIENTATIONS,
      const bool ROTATE_SUBSET,
      const math::Range< size_t> &NUMBER_ROTATIONS,
      const math::Range< size_t> &SUBSET_SIZE
    ) :
      m_PreserveSheetGeometry( PRESERVE_SHEET_GEOMETRY),
      m_PreserveStrandOrientations( PRESERVE_STRAND_ORIENTATIONS),
      m_RotateSubset( ROTATE_SUBSET),
      m_NumberRotations( NUMBER_ROTATIONS),
      m_SubsetSize( SUBSET_SIZE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateSheetCycle
    MutateSheetCycle *MutateSheetCycle::Clone() const
    {
      return new MutateSheetCycle( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateSheetCycle::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a Sheet and return a mutated Sheet
    //! @param SHEET Sheet which will be mutated
    //! @return MutateResult with the mutated Sheet
    math::MutateResult< assemble::Domain> MutateSheetCycle::operator()( const assemble::Domain &SHEET) const
    {
      // initialize an empty Sheet ShPtr to
      static util::ShPtr< assemble::Domain> s_empty_sheet;

      // make sure the passed domain has a valid topology and is of type sheet or beta-barrel
      if
      (
        !SHEET.GetTopology().IsDefined() ||
        !
        (
          SHEET.GetTopology()->GetType() == assemble::Topology::e_Sheet ||
          SHEET.GetTopology()->GetType() == assemble::Topology::e_BetaBarrel
        )
      )
      {
        // warn user and return
        BCL_MessageVrb( "The given domain is not a sheet or a barrel");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // store the number of strands
      const size_t nr_strands( SHEET.GetNumberSSEs());

      // make sure the Sheet has at least two strands
      if( nr_strands < 2)
      {
        // warn user and return
        BCL_MessageVrb( "The given sheet has less than 2 strands, therefore skipping");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // make a copy of the Sheet
      util::ShPtr< assemble::Domain> new_sheet( SHEET.Clone());

      // decide on the rotation direction
      bool rotate_direction( random::GetGlobalRandom().Boolean());

      // initialize rotation count
      const size_t nr_rotations
      (
        random::GetGlobalRandom().SizeT
        (
          math::Range< size_t>
          (
            nr_strands > ( m_NumberRotations.GetMin() + 1) ? m_NumberRotations.GetMin() : 1,
            nr_strands > ( m_NumberRotations.GetMax() + 1) ? m_NumberRotations.GetMax() : nr_strands - 1
          )
        )
      );

      // construct a vector of sses to be rotated
      util::SiPtrVector< const assemble::SSEGeometryInterface> strands_to_rotate;

      // if all of the strands will be rotated
      // or the number of strands  is already equal to/less than the given minimum subset size
      if( !m_RotateSubset || nr_strands <= m_SubsetSize.GetMin())
      {
        strands_to_rotate = SHEET.GetTopology()->GetElements();
      }
      // if a subset will be rotated
      else
      {
        // decide on the size of the subset
        const size_t subset_size
        (
          // subset size can't be larger than nr_strands
          random::GetGlobalRandom().SizeT
          (
            math::Range< size_t>
            (
              m_SubsetSize.GetMin(),
              m_SubsetSize.GetMax() >= nr_strands ? nr_strands : m_SubsetSize.GetMax()
            )
          )
        );

        // now pick a random location in the the sheet vector
        size_t index( random::GetGlobalRandom().SizeT( math::Range< size_t>( 0, nr_strands - 1)));

        // while the subset is still not full
        while( strands_to_rotate.GetSize() < subset_size)
        {
          // insert this SSE into the subset
          strands_to_rotate.PushBack( SHEET.GetTopology()->GetElements()( index));

            // increment the index
          ++index;

          // if the last is reached than set index to 0
          if( index == nr_strands)
          {
            index = 0;
          }
        }
      }

      // initialize nr_selected_strands
      const size_t nr_selected_strands( strands_to_rotate.GetSize());

      // iterate over each SSE
      for( size_t sse_index( 0); sse_index < nr_selected_strands; ++sse_index)
      {
        // calculate the index of the reference SSE, the SSE to which's position this SSE will move to
        const size_t sse_index_new
        (
          rotate_direction ?
            ( sse_index + nr_rotations) % nr_selected_strands :
            ( nr_selected_strands + sse_index - nr_rotations) % nr_selected_strands
        );

        // make a pointer of the old and reference SSE
        util::SiPtr< const assemble::SSEGeometryInterface> reference_sse( strands_to_rotate( sse_index_new));
        // make a copy of the SSE
        // this is doing dynamic cast and we have to make sure
        util::ShPtr< assemble::SSE> new_sse( strands_to_rotate( sse_index)->Clone());
        BCL_Assert( new_sse.IsDefined(), "The dynamic cast from SSEGeometryInterface to SSE failed!");

        // build up the transformation
        math::TransformationMatrix3D transformation;

        // if preserving sheet geometry
        if( m_PreserveSheetGeometry)
        {
          // first move the new SSE to origin
          transformation( math::Inverse( new_sse->GetOrientation()));

          // if the strand orientations are to be preserved
          if( m_PreserveStrandOrientations)
          {
            // calculate z twist angle
            const double z_twist
            (
              linal::Dihedral
              (
                new_sse->GetMainAxis().GetEndPoint(), new_sse->GetCenter(),
                reference_sse->GetCenter(), reference_sse->GetMainAxis().GetEndPoint()
              )
            );

            // calculate x twist angle
            const double x_twist
            (
              linal::Dihedral
              (
                new_sse->GetCenter() + new_sse->GetAxis( coord::GetAxes().e_X),
                new_sse->GetCenter(),
                reference_sse->GetCenter(),
                reference_sse->GetCenter() + reference_sse->GetAxis( coord::GetAxes().e_X)
              )
            );

            // calculate x and z orientations
            const assemble::SSEGeometryPacking::Orientation z_orientation
            (
              assemble::SSEGeometryPacking::OrientationFromTwistAngle( z_twist)
            );
            const assemble::SSEGeometryPacking::Orientation x_orientation
            (
              assemble::SSEGeometryPacking::OrientationFromTwistAngle( x_twist)
            );

            BCL_MessageDbg
            (
              "Comparing " + new_sse->GetIdentification() + " and " + reference_sse->GetIdentification()
            );
            BCL_MessageDbg
            (
              "Z-orient: " + util::Format()( math::Angle::Degree( z_twist)) + " => " + util::Format()( z_orientation)
            );
            BCL_MessageDbg
            (
              "X-orient: " + util::Format()( math::Angle::Degree( x_twist)) + " => " + util::Format()( x_orientation)
            );

            // if both z and x orientation are out of place
            if
            (
              z_orientation == assemble::SSEGeometryPacking::e_AntiParallel &&
              x_orientation == assemble::SSEGeometryPacking::e_AntiParallel
            )
            {
              BCL_MessageDbg( "Y-flip");
              // apply y flip
              transformation( coord::GetAxes().e_Y, math::g_Pi);
            }
            // if only x orientation is antiparallel
            if
            (
              z_orientation == assemble::SSEGeometryPacking::e_Parallel &&
              x_orientation == assemble::SSEGeometryPacking::e_AntiParallel
            )
            {
              BCL_MessageDbg( "Z-flip");
              // apply a z flip
              transformation( coord::GetAxes().e_Z, math::g_Pi);
            }
            // if only z orientation is antiparallel
            if
            (
              z_orientation == assemble::SSEGeometryPacking::e_AntiParallel &&
              x_orientation == assemble::SSEGeometryPacking::e_Parallel
            )
            {
              BCL_MessageDbg( "X-flip");
              // apply a x flip
              transformation( coord::GetAxes().e_X, math::g_Pi);
            }
          }

          // apply the orientation of the reference SSE
          transformation( reference_sse->GetOrientation());

        }
        // else if the sheet geometry is not to be preserved
        else
        {
          // then the transformation is just a translation
          // no need to bother preserving strand orientations, since that's done implicitly
          transformation( reference_sse->GetCenter() - new_sse->GetCenter());
        }

        // apply the transformation
        new_sse->Transform( transformation);

        // insert into the new Sheet
        new_sheet->Replace( new_sse);
      }

      // end
      return math::MutateResult< assemble::Domain>( new_sheet, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSheetCycle::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_PreserveSheetGeometry, ISTREAM);
      io::Serialize::Read( m_PreserveStrandOrientations, ISTREAM);
      io::Serialize::Read( m_RotateSubset, ISTREAM);
      io::Serialize::Read( m_NumberRotations, ISTREAM);
      io::Serialize::Read( m_SubsetSize, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateSheetCycle::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // read members
      io::Serialize::Write( m_PreserveSheetGeometry, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PreserveStrandOrientations, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_RotateSubset, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_NumberRotations, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SubsetSize, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sheet_divide.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateSheetDivide::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSheetDivide( 4, 2, false))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from min sheet and divided sheet sizes, and minimum and maximum translations
    //! @param MIN_SHEET_SIZE minimum number of strands in the sheet to be divided
    //! @param MIN_DIVIDED_SHEET_SIZE minimum number of strand in the divided sheet
    //! @param FORM_BETA_SANDWICH whether to form a beta sandwich
    //! @param MIN_TRANSLATIONS minimum translation along x,y and z axis
    //! @param MAX_TRANSLATIONS maximum translation along x,y and z axis
    MutateSheetDivide::MutateSheetDivide
    (
      const size_t MIN_SHEET_SIZE,
      const size_t MIN_DIVIDED_SHEET_SIZE,
      const bool FORM_BETA_SANDWICH,
      const linal::Vector3D &MIN_TRANSLATIONS,
      const linal::Vector3D &MAX_TRANSLATIONS
    ) :
      m_MinSheetSize( MIN_SHEET_SIZE),
      m_MinDividedSheetSize( MIN_DIVIDED_SHEET_SIZE),
      m_FormBetaSandwich( FORM_BETA_SANDWICH),
      m_MinTranslations( MIN_TRANSLATIONS),
      m_MaxTranslations( MAX_TRANSLATIONS)
    {
      // make sure the given sheet size large enough to make sure both sheets after division are at least m_MinDividedSheetSize
      BCL_Assert
      (
        MIN_SHEET_SIZE >= 2 * MIN_DIVIDED_SHEET_SIZE,
        "The given min sheet size " + util::Format()( MIN_SHEET_SIZE) +
        " should be at least twice the min divided sheet size " + util::Format()( MIN_DIVIDED_SHEET_SIZE)
      );

      // make sure the min divided sheet size is at least two
      BCL_Assert
      (
        MIN_DIVIDED_SHEET_SIZE >= 1,
        "The given min divided sheet size should be at least 1 not " + util::Format()( MIN_DIVIDED_SHEET_SIZE)
      );
    }

    //! @brief Clone function
    //! @return pointer to new MutateSheetDivide
    MutateSheetDivide *MutateSheetDivide::Clone() const
    {
      return new MutateSheetDivide( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateSheetDivide::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a Sheet and return a mutated Sheet
    //! @param SHEET Sheet which will be mutated
    //! @return MutateResult with the mutated Sheet
    math::MutateResult< assemble::Domain> MutateSheetDivide::operator()( const assemble::Domain &SHEET) const
    {
      // initialize empty sheet to return
      static util::ShPtr< assemble::Domain> s_empty_sheet;

      // make sure the passed domain has a valid topology and is of type sheet or beta-barrel
      if
      (
        !SHEET.GetTopology().IsDefined() ||
        !(
           SHEET.GetTopology()->GetType() == assemble::Topology::e_Sheet ||
           SHEET.GetTopology()->GetType() == assemble::Topology::e_BetaBarrel
         )
      )
      {
        // warn user and return
        BCL_MessageVrb( "The given domain is not a sheet or a barrel");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // store the total number of strand
      const size_t total_nr_strands( SHEET.GetNumberSSEs());

      // if not enough strands
      if( total_nr_strands < m_MinSheetSize)
      {
        BCL_MessageDbg( "The sheet has less than minimum required number of strands");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // create a new sheet
      util::ShPtr< assemble::Domain> new_sheet( SHEET.Clone());

      // make a copy of the order vector
      util::SiPtrVector< const assemble::SSEGeometryInterface> order_vector( SHEET.GetTopology()->GetElements());

      // locate the dividing index
      const size_t dividing_index
      (
        random::GetGlobalRandom().SizeT
        (
          math::Range< size_t>( m_MinDividedSheetSize, total_nr_strands - m_MinDividedSheetSize)
        )
      );

      // random boolean left or right
      const bool left_or_right( random::GetGlobalRandom().Boolean());

      // construct the new vector
      util::SiPtrVector< const assemble::SSEGeometryInterface> subsheet
      (
        left_or_right ?
          order_vector.SubSiPtrVector( 0, dividing_index) :
          order_vector.SubSiPtrVector( dividing_index, total_nr_strands - dividing_index)
      );

      // construct the vector that contains the part of the sheet that will stay intact
      util::SiPtrVector< const assemble::SSEGeometryInterface> subsheet_intact
      (
        left_or_right ?
          order_vector.SubSiPtrVector( dividing_index, total_nr_strands - dividing_index) :
          order_vector.SubSiPtrVector( 0, dividing_index)
      );

      // initialize translation that will be applied
      linal::Vector3D translation;

      // if sandwich
      if( m_FormBetaSandwich)
      {
        // calculate the center of the subsheet intact and the subsheet
        linal::Vector3D center_subsheet_intact( subsheet_intact( ( subsheet_intact.GetSize() - 1) / 2)->GetCenter());
        linal::Vector3D center_subsheet( subsheet( ( subsheet.GetSize() - 1) / 2)->GetCenter());

        // calculate the translation that will move the center of subsheet to center of subsheet_intact
        translation += ( center_subsheet_intact - center_subsheet);

        // now determine the x translation that will be move sheet apart
        // this can be determined randomly in the of preferred distances
        const linal::Vector3D x_translation
        (
          SHEET.GetOrientation().GetAxis( coord::GetAxes().e_X) *
          random::GetGlobalRandom().Sign() *
          random::GetGlobalRandom().Double
          (
            contact::GetTypes().SHEET_SHEET->GetPreferredDistanceRange()
          )
        );

        // sum up the translations
        translation += x_translation;
      }
      // else
      else
      {

        // determine the order of y axis
        // this needs to point away from the sheet so that y translation does not overlap the subsheet with
        // the other part of the sheet that is not selected
        // the y axis of a sheet by default points from left to right in the sheet order vector
        // therefore if we picked the left side
        // then we want to translate in the opposite direction of the y axis of the sheet
        const linal::Vector3D y_axis
        (
          left_or_right ?
            -SHEET.GetOrientation().GetAxis( coord::GetAxes().e_Y) :
            SHEET.GetOrientation().GetAxis( coord::GetAxes().e_Y)
        );

        // now determine the translations in each axis
        // x and z translation can be in either direction
        const linal::Vector3D x_translation
        (
          SHEET.GetOrientation().GetAxis( coord::GetAxes().e_X) *
          random::GetGlobalRandom().Sign() *
          random::GetGlobalRandom().Double
          (
            math::Range< double>( m_MinTranslations( coord::GetAxes().e_X), m_MaxTranslations( coord::GetAxes().e_X))
          )
        );
        const linal::Vector3D z_translation
        (
          SHEET.GetOrientation().GetAxis( coord::GetAxes().e_Z) *
          random::GetGlobalRandom().Sign() *
          random::GetGlobalRandom().Double
          (
            math::Range< double>( m_MinTranslations( coord::GetAxes().e_Z), m_MaxTranslations( coord::GetAxes().e_Z))
          )
        );

        // y translation only occurs in the direction of the calculated axis as explained previously
        const linal::Vector3D y_translation
        (
          SHEET.GetOrientation().GetAxis( coord::GetAxes().e_Y) *
          random::GetGlobalRandom().Double
          (
            math::Range< double>( m_MinTranslations( coord::GetAxes().e_Y), m_MaxTranslations( coord::GetAxes().e_Y))
          )
        );

        // sum up the translations
        translation = ( x_translation + y_translation + z_translation);
      }

      // now iterate over the sses in the subset
      for
      (
        util::SiPtrVector< const assemble::SSEGeometryInterface>::const_iterator
          sse_itr( subsheet.Begin()), sse_itr_end( subsheet.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // make a copy of this sse
        util::ShPtr< assemble::SSE> new_sse( ( *sse_itr)->Clone());
        // check the dynamic cast succeeded
        BCL_Assert( new_sse.IsDefined(), "The dynamic cast from SSEGeometryInterface to SSE failed!");

        // apply the translation
        new_sse->Translate( translation);

        // replace in the new sheet
        new_sheet->Replace( new_sse);
      }

      // end
      return math::MutateResult< assemble::Domain>( new_sheet, *this);

    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSheetDivide::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_MinSheetSize, ISTREAM);
      io::Serialize::Read( m_MinDividedSheetSize, ISTREAM);
      io::Serialize::Read( m_FormBetaSandwich, ISTREAM);
      io::Serialize::Read( m_MinTranslations, ISTREAM);
      io::Serialize::Read( m_MaxTranslations, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateSheetDivide::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_MinSheetSize, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MinDividedSheetSize, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_FormBetaSandwich, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MinTranslations, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MaxTranslations, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sheet_fit_to_template.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_fold_template.h"
#include "math/bcl_math_mutate_result.h"
#include "quality/bcl_quality_rmsd.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateSheetFitToTemplate::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSheetFitToTemplate())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief returns a pointer to a new MutateSheetFitToTemplate
    //! @return pointer to a new MutateSheetFitToTemplate
    MutateSheetFitToTemplate *MutateSheetFitToTemplate::Clone() const
    {
      return new MutateSheetFitToTemplate( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &MutateSheetFitToTemplate::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief fits the given sheet to a randomly selected template
    //! @param SHEET sheet to be fitted
    //! @return the fitted sheet and a boolean indicating if the application of the mutate was successful
    math::MutateResult< assemble::Domain> MutateSheetFitToTemplate::operator()( const assemble::Domain &SHEET) const
    {
      BCL_MessageTop( "Fitting sheet to template");

      // initialize a undefined domain
      static util::ShPtr< assemble::Domain> s_sp_undefined_domain;

      // make sure the passed domain is a sheet and has at least 2 strands
      if
      (
        SHEET.GetNumberSSEs() < 2 &&
        (
          SHEET.GetTopology()->GetType() != assemble::Topology::e_Sheet ||
          SHEET.GetTopology()->GetType() != assemble::Topology::e_BetaBarrel
        )
      )
      {
        BCL_MessageVrb( "The provided sheet has less than 2 strands or is not a sheet, skipping.");
        return math::MutateResult< assemble::Domain>( s_sp_undefined_domain, *this);
      }

      // get the ordered vector of strands in the sheet and cast to SSE pointers from SSEGeometryInterface pointers
      util::SiPtrVector< const assemble::SSE> ordered_strands( SHEET.GetTopology()->GetElements());

      // make sure the cast was successful
      if( !ordered_strands.IsDefined())
      {
        BCL_MessageCrt( "The cast to SSE pointers from SSEGeometryInterface pointers failed!");
        return math::MutateResult< assemble::Domain>( s_sp_undefined_domain, *this);
      }

      // randomly reverse the vector
      if( random::GetGlobalRandom().Boolean())
      {
        util::SiPtrVector< const assemble::SSE> temp_vector
        (
          ordered_strands.ReverseBegin(),
          ordered_strands.ReverseEnd()
        );
        ordered_strands = temp_vector;
      }

      // get a random template that has the same number of strands
      const assemble::FoldTemplate &fold_template( assemble::SheetTemplateHandler::GetRandomTemplate( ordered_strands));

      // application of the mutate failed if no suitable template was found
      if( fold_template.GetGeometries().IsEmpty())
      {
        return math::MutateResult< assemble::Domain>( s_sp_undefined_domain, *this);
      }

      // fit the SSEs to the template
      util::ShPtr< assemble::Domain> sp_new_sheet( fold_template.FitSSEs( ordered_strands).Clone());

      // now we need to move the fitted strands close to their original locations
      // first calculate the transformation needed
      math::TransformationMatrix3D transformation
      (
        quality::RMSD::SuperimposeCoordinates
        (
          SHEET.GetAtomCoordinates(),
          sp_new_sheet->GetAtomCoordinates()
        )
      );

      // make sure the transformation is defined
      if( !transformation.IsDefined())
      {
        BCL_MessageCrt( "The transformation of the sheet failed!");
        return math::MutateResult< assemble::Domain>( s_sp_undefined_domain, *this);
      }

      // transform the new strands
      sp_new_sheet->Transform( transformation);

      return math::MutateResult< assemble::Domain>( sp_new_sheet, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read object from input stream
    //! @param ISTREAM input stream to read object from
    //! @return input stream which was read from
    std::istream &MutateSheetFitToTemplate::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write object into  output stream
    //! @param OSTREAM output stream to write object into
    //! @param INDENT number of indentations to separate members
    //! @return output stream object was written into
    std::ostream &MutateSheetFitToTemplate::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sheet_order.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "coord/bcl_coord_move_rotate_defined.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateSheetOrder::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSheetOrder())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateSheetOrder::MutateSheetOrder() :
      m_ParallelProbability( 0.0)
    {
    }

    //! @brief constructor from a parallel conformation probability
    //! @param PARALLEL_PROBABILITY probability of ordering strands in a parallel conformation
    MutateSheetOrder::MutateSheetOrder( const double PARALLEL_PROBABILITY) :
      m_ParallelProbability( PARALLEL_PROBABILITY)
    {
      BCL_Assert
      (
        PARALLEL_PROBABILITY >= 0.0 && PARALLEL_PROBABILITY <= 1.0,
        "The given probability for ordering in parallel conformation should be between 0 and 1"
      );
    }

    //! @brief Clone function
    //! @return pointer to new MutateSheetOrder
    MutateSheetOrder *MutateSheetOrder::Clone() const
    {
      return new MutateSheetOrder( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateSheetOrder::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateSheetOrder::GetAlias() const
    {
      static const std::string s_name( "MutateSheetOrder");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateSheetOrder::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Orders strands in a sheet by sequence order.");
      serializer.AddInitializer
      (
        "parallel probability",
        "probability of ordering into parallel conformation",
        io::Serialization::GetAgent( &m_ParallelProbability)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator to sort the strands in the given sheet by sequence order
    //! @param SHEET Sheet to be mutated
    //! @return MutateResult that contains the mutated sheet
    math::MutateResult< assemble::Domain> MutateSheetOrder::operator()( const assemble::Domain &SHEET) const
    {
      // construct undefined sh ptr
      util::ShPtr< assemble::Domain> sp_undefined_domain;

      // make sure given domain is a sheet
      BCL_Assert
      (
        SHEET.GetTopology().IsDefined() &&
        (
          SHEET.GetTopology()->GetType() == assemble::Topology::e_Sheet ||
          SHEET.GetTopology()->GetType() == assemble::Topology::e_BetaBarrel
        ),
        "The given domain is not a sheet or a barrel"
      );

      // if there are less than two strands
      if( SHEET.GetNumberSSEs() < 2)
      {
        BCL_MessageVrb( "The given sheet has less than 2 strands");
        return math::MutateResult< assemble::Domain>( sp_undefined_domain, *this);
      }

      // determine to order parallel or not
      const bool order_parallel( random::GetGlobalRandom().Double() < m_ParallelProbability);

      // construct new sheet
      util::ShPtr< assemble::Domain> sp_sheet( new assemble::Domain());

      // get the subset of strands to be sorted and cast them to SSEs
      util::SiPtrVector< const assemble::SSE> strands( SHEET.GetTopology()->GetElements());

      // store the y flip
      // this is chosen instead of x flip to preserve the side chain orientations
      const coord::MoveRotateDefined y_flip( coord::MoveRotateDefined::GetFlipMove( coord::GetAxes().e_Y));

      // copy the first strands
      util::ShPtr< assemble::SSE> sp_first_strand( strands.FirstElement()->Clone());

      // decide to flip this or not randomly
      const bool flip_first( random::GetGlobalRandom().Boolean());

      // boolean whether previous strand was flipped or not
      bool is_previous_flipped( false);

      // iterate over strands
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          strand_itr( strands.Begin()), strand_itr_end( strands.End());
        strand_itr != strand_itr_end; ++strand_itr
      )
      {
        // boolean whether this strand should be flipped
        bool flip_this_strand( false);

        // if its the first SSE
        if( strand_itr == strands.Begin())
        {
          // then flip this only if flip_first was set to true
          flip_this_strand = flip_first;
        }
        else
        {
          // boolean whether this is parallel to the first one
          bool is_parallel
          (
            SHEET.GetTopology()->GetPackingForSSEGeometryPair
            (
              util::SiPtr< const assemble::SSEGeometryInterface>( *strand_itr),
              util::SiPtr< const assemble::SSEGeometryInterface>( *( strand_itr - 1))
            ).GetOrientation() ==
            assemble::SSEGeometryPacking::e_Parallel
          );

          // boolean whether this is parallel to previous one after changes to previous
          // it's still parallel only if it was parallel or the previous was flipped, but not both
          const bool is_parallel_after_changes( is_previous_flipped ^ is_parallel);

          // we want to flip if we're ordering anti-parallel and it's antiparallel to previous but not both
          flip_this_strand = order_parallel ^ is_parallel_after_changes;
        }

        // make a copy of the strand
        util::ShPtr< assemble::SSE> sp_new_strand( ( *strand_itr)->Clone());

        // if flip is requested
        if( flip_this_strand)
        {
          // apply flip
          y_flip.Move( *sp_new_strand);
        }

        // insert into sheet
        sp_sheet->Insert( sp_new_strand);

        // update boolean
        is_previous_flipped = flip_this_strand;
      }

      // sort and return the result
      return math::MutateResult< assemble::Domain>( sp_sheet, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSheetOrder::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ParallelProbability, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateSheetOrder::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ParallelProbability, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sheet_register_fix.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "biol/bcl_biol_atom.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    // instantiate instance
    const util::SiPtr< const util::ObjectInterface> MutateSheetRegisterFix::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSheetRegisterFix())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Clone function
    //! @return pointer to new MutateSheetRegisterFix
    MutateSheetRegisterFix *MutateSheetRegisterFix::Clone() const
    {
      return new MutateSheetRegisterFix( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateSheetRegisterFix::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a Sheet and return a mutated Sheet
    //! @param SHEET Sheet which will be mutated
    //! @return MutateResult with the mutated Sheet
    math::MutateResult< assemble::Domain> MutateSheetRegisterFix::operator()( const assemble::Domain &SHEET) const
    {
      // initialize an empty Sheet ShPtr to
      static util::ShPtr< assemble::Domain> s_empty_sheet;

      // make sure the passed domain has a valid topology and is of type sheet or beta-barrel
      if
      (
        !SHEET.GetTopology().IsDefined() ||
        !(
           SHEET.GetTopology()->GetType() == assemble::Topology::e_Sheet ||
           SHEET.GetTopology()->GetType() == assemble::Topology::e_BetaBarrel
         )
      )
      {
        // warn user and return
        BCL_MessageVrb( "The given domain is not a sheet or a barrel");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // make sure the Sheet has at least two strands
      if( SHEET.GetNumberSSEs() < 2)
      {
        // warn user and return
        BCL_MessageVrb( "The given sheet has less than 2 strands, therefore skipping");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // make a copy of the Sheet
      util::ShPtr< assemble::Domain> new_sheet( SHEET.Clone());

      // get all SSEs by doing dynamic cast on the SSEGeometryInterface vector
      util::SiPtrVector< const assemble::SSE> sse_vector( SHEET.GetTopology()->GetElements());
      // check the dynamic cast
      BCL_Assert( sse_vector.IsDefined(), "The dynamic cast has failed from Topology geometries to SSEs");

      // build up the translation vector
      // first SSE stays the same
      storage::Vector< linal::Vector3D> translation_vector;
      linal::Vector3D prev_translation;
      BCL_MessageVrb( "Calculating z_translations")

      // iterate over SSEs in this sheet using the SSE vector
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
        strand_itr( sse_vector.Begin() + 1),
          strand_itr_end( sse_vector.End());
        strand_itr != strand_itr_end; ++strand_itr
      )
      {
        // create references on the ShPtrs for this strand and next strand
        const util::SiPtr< const assemble::SSE> &sp_prev_strand( *( strand_itr - 1));
        const util::SiPtr< const assemble::SSE> &sp_this_strand( *strand_itr);

        // create a reference on the SSEGeometryPacking for these two strands
        const assemble::SSEGeometryPacking &strand_pack
        (
          SHEET.GetTopology()->GetPackingForSSEGeometryPair( *sp_prev_strand, *sp_this_strand)
        );

        // find the possible hydrogen bonding residues
        const linal::Vector3D this_translation
        (
          CalculateTranslationForHydrogenBonding
          (
            strand_pack, *sp_prev_strand, *sp_this_strand
          )
        );

        BCL_MessageVrb
        (
          "sses: " + sp_prev_strand->GetIdentification() + " vs " + sp_this_strand->GetIdentification()
        );
        BCL_MessageVrb
        (
          "frags: " + strand_pack.GetFirstSSEGeometry()->GetIdentification() +
          " vs " + strand_pack.GetSecondSSEGeometry()->GetIdentification()
        );
        BCL_MessageVrb
        (
          "translation: " + util::Format()( this_translation)
        );

        // update the previous translation
        prev_translation += this_translation;

        BCL_MessageVrb
        (
          "prev translation after update: " + util::Format()( prev_translation)
        );

        // update the vector
        translation_vector.PushBack( prev_translation);
      }

      // create iterator on the z_translation_vector
      storage::Vector< linal::Vector3D>::const_iterator translation_itr( translation_vector.Begin());
      const storage::Vector< linal::Vector3D>::const_iterator translation_itr_end( translation_vector.End());

      BCL_MessageVrb( "Appyling z_translations");

      // now iterate again over the Sheet to apply the translations
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
        strand_itr( sse_vector.Begin() + 1),
          strand_itr_end( sse_vector.End());
        strand_itr != strand_itr_end && translation_itr != translation_itr_end;
        ++strand_itr, ++translation_itr
      )
      {
        // create references on the ShPtrs for this strand and next strand
        const util::SiPtr< const assemble::SSE> &sp_prev_strand( *( strand_itr - 1));
        const util::SiPtr< const assemble::SSE> &sp_this_strand( *strand_itr);

        // create a reference on the SSEGeometryPacking for these two strands
        const assemble::SSEGeometryPacking &strand_pack
        (
          SHEET.GetTopology()->GetPackingForSSEGeometryPair( *sp_prev_strand, *sp_this_strand)
        );

        BCL_MessageVrb
        (
          "sses: " + sp_prev_strand->GetIdentification() + " vs " + sp_this_strand->GetIdentification()
        );
        BCL_MessageVrb
        (
          "frags: " + strand_pack.GetFirstSSEGeometry()->GetIdentification() +
          " vs " + strand_pack.GetSecondSSEGeometry()->GetIdentification()
        );
        BCL_MessageVrb( "translation: " + util::Format()( *translation_itr));

        // make a copy of this strand
        util::ShPtr< assemble::SSE> new_strand( sp_this_strand->Clone());

        // apply the translation
        new_strand->Translate( *translation_itr);

        // do replace
        new_sheet->Replace( new_strand);
      }

      // end
      return math::MutateResult< assemble::Domain>( new_sheet, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSheetRegisterFix::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateSheetRegisterFix::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief finds possible hydrogen bonding pair residues from a StrandPacking objects
    //! @param STRAND_PACK SSEGeometryPacking between two strands
    //! @param STRAND_A first strand of interest
    //! @param STRAND_B second strand of interest
    //! @return possible hydrogen bonding pair residues from a StrandPacking objects
    linal::Vector3D MutateSheetRegisterFix::CalculateTranslationForHydrogenBonding
    (
      const assemble::SSEGeometryPacking &STRAND_PACK,
      const assemble::SSE &STRAND_A,
      const assemble::SSE &STRAND_B
    )
    {
      // create references on the first and second sequence and sse pack
//      const SSE &sse_a( *STRAND_PACK.First().First());
//      const SSE &sse_b( *STRAND_PACK.First().Second());
      const assemble::SSE &sse_a( STRAND_A);
      const assemble::SSE &sse_b( STRAND_B);

      // create boolean whether the first sequence was hydrogen donator
      storage::VectorND< 2, util::SiPtr< const biol::AABase> > best_pair;
      double best_distance( 20.0);

      // first locate the closest amino acids
      // iterate over both sequences
      for
      (
        biol::AASequence::const_iterator aa_itr_a( sse_a.Begin()), aa_itr_a_end( sse_a.End());
        aa_itr_a != aa_itr_a_end; ++aa_itr_a
      )
      {
        for
        (
          biol::AASequence::const_iterator aa_itr_b( sse_b.Begin()), aa_itr_b_end( sse_b.End());
          aa_itr_b != aa_itr_b_end; ++aa_itr_b
        )
        {
          // calculate distance between N of aa_itr_a, and O of aa_itr_b
          const double this_distance
          (
            linal::Distance( ( *aa_itr_a)->GetCA().GetCoordinates(), ( *aa_itr_b)->GetCA().GetCoordinates())
          );

          // if the distance is less than the best distance
          if( this_distance < best_distance)
          {
            // find if CA-CB vector face the same direction
            // calculate dihedral
            const double dihedral
            (
              linal::Dihedral
              (
                ( *aa_itr_a)->GetFirstSidechainAtom().GetCoordinates(),
                ( *aa_itr_a)->GetCA().GetCoordinates(),
                ( *aa_itr_b)->GetCA().GetCoordinates(),
                ( *aa_itr_b)->GetFirstSidechainAtom().GetCoordinates()
              )
            );

            // if they are facing the same way
            if( dihedral < math::g_Pi / 2)
            {
              // update the best distance and pair information
              best_distance = this_distance;
              best_pair.First() = **aa_itr_a;
              best_pair.Second() = **aa_itr_b;
            }
          }
        }
      }

      BCL_MessageVrb
      (
        "CAs to adjust " + best_pair.First()->GetIdentification() + " and " + best_pair.Second()->GetIdentification()
        + " at distance " + util::Format()( best_distance)
      );

      // find the expected CA coordinate ( this will be off the z axis of sse_b)
      const linal::Vector3D ca_expected
      (
        best_pair.First()->GetCA().GetCoordinates() + STRAND_PACK.GetShortestConnection().GetDirection()
      );

      BCL_MessageVrb( "expect CA position: " + util::Format()( ca_expected));
      // now find the translation required from current_ca to ca_expected
      const linal::Vector3D translation
      (
        ( ca_expected - best_pair.Second()->GetCA().GetCoordinates())
      );

      // now find the component of this translation along the z-axis
      const double z_translation
      (
        translation * sse_b.GetAxis( coord::GetAxes().e_Z)
      );

      // return value
      return z_translation * sse_b.GetAxis( coord::GetAxes().e_Z);
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sheet_register_shift.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    // instantiate instance
    const util::SiPtr< const util::ObjectInterface> MutateSheetRegisterShift::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSheetRegisterShift())
    );

    //! @brief static function to return default shift probabilities
    //! @return default shift probabilities
    const storage::VectorND< 2, double> &MutateSheetRegisterShift::GetDefaultShiftProbabilities()
    {
      // initialize static const shift probabilities vector
      static const storage::VectorND< 2, double> s_default_probabilities( 0.5, 0.5);

      // end
      return s_default_probabilities;
    }

    //! @brief static function to return CA z-translation for a single residue
    //! @return CA z-translation for a single residue
    double MutateSheetRegisterShift::GetCAShiftAlongZAxis()
    {
      // have a static double
      static const double s_ca_shift( 3.425);

      // end
      return s_ca_shift;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a shift probabilities vector
    //! @param SHIFT_PROBABILITIES vector that contains probabilities from regular and flip shift
    MutateSheetRegisterShift::MutateSheetRegisterShift
    (
      const storage::VectorND< 2, double> &SHIFT_PROBABILITIES
    ) :
      m_ShiftProbabilities( SHIFT_PROBABILITIES)
    {
      // make sure the probabilities are both positive
      BCL_Assert
      (
        m_ShiftProbabilities.First() >= 0.0 && m_ShiftProbabilities.Second() >= 0.0,
        "The shift probabilities should be both >= 0.0 not " + util::Format()( m_ShiftProbabilities)
      );

      // normalize the probabilities
      const double sum( m_ShiftProbabilities.First() + m_ShiftProbabilities.Second());
      m_ShiftProbabilities.First() /= sum;
      m_ShiftProbabilities.Second() /= sum;
    }

    //! @brief Clone function
    //! @return pointer to new MutateSheetRegisterShift
    MutateSheetRegisterShift *MutateSheetRegisterShift::Clone() const
    {
      return new MutateSheetRegisterShift( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateSheetRegisterShift::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a Sheet and return a mutated Sheet
    //! @param SHEET Sheet which will be mutated
    //! @return MutateResult with the mutated Sheet
    math::MutateResult< assemble::Domain> MutateSheetRegisterShift::operator()( const assemble::Domain &SHEET) const
    {
      // initialize an empty Sheet ShPtr to
      static util::ShPtr< assemble::Domain> s_empty_sheet;

      // make sure the passed domain has a valid topology and is of type sheet or beta-barrel
      if
      (
        !SHEET.GetTopology().IsDefined() ||
        !(
           SHEET.GetTopology()->GetType() == assemble::Topology::e_Sheet ||
           SHEET.GetTopology()->GetType() == assemble::Topology::e_BetaBarrel
         )
      )
      {
        // warn user and return
        BCL_MessageVrb( "The given domain is not a sheet or a barrel");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // make sure the Sheet has at least two strands
      if( SHEET.GetNumberSSEs() < 2)
      {
        // warn user and return
        BCL_MessageVrb( "The given sheet has less than 2 strands, therefore skipping");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // make a copy of the Sheet
      util::ShPtr< assemble::Domain> new_sheet( SHEET.Clone());

      // get all SSEs by doing dynamic cast on the SSEGeometryInterface vector
      util::SiPtrVector< const assemble::SSE> sse_vector( SHEET.GetTopology()->GetElements());

      // check the dynamic cast
      BCL_Assert( sse_vector.IsDefined(), "The dynamic cast has failed from Topology geometries to SSEs");

      // get a random iterator
      util::SiPtrVector< const assemble::SSE>::const_iterator prev_strand_itr
      (
        random::GetGlobalRandom().Iterator
        (
          sse_vector.Begin(),
          sse_vector.End() - 1,
          sse_vector.GetSize() - 1
        )
      );

      // create an iterator to store the reference sse
      util::SiPtrVector< const assemble::SSE>::const_iterator this_strand_itr( prev_strand_itr + 1);

      // create references on the ShPtrs for this strand and next strand
      const util::SiPtr< const assemble::SSE> &sp_prev_strand( *prev_strand_itr);
      const util::SiPtr< const assemble::SSE> &sp_this_strand( *this_strand_itr);

      // create a reference on the SSEGeometryPacking for these two strands
      const assemble::SSEGeometryPacking &strand_pack
      (
        SHEET.GetTopology()->GetPackingForSSEGeometryPair( *sp_prev_strand, *sp_this_strand)
      );

      BCL_MessageVrb
      (
        "sses: " + sp_prev_strand->GetIdentification() + " vs " + sp_this_strand->GetIdentification()
      );
      BCL_MessageVrb
      (
        "frags: " + strand_pack.GetFirstSSEGeometry()->GetIdentification() +
        " vs " + strand_pack.GetSecondSSEGeometry()->GetIdentification()
      );

      // determine whether to shift or flip-twist
      bool flip_shift( random::GetGlobalRandom().Double() >= m_ShiftProbabilities.First());

      // determine random direction for the shift
      int direction( random::GetGlobalRandom().Sign());

      // initialize translation
      linal::Vector3D translation;

      // make a copy of this SSE
      util::ShPtr< assemble::SSE> new_strand( sp_this_strand->Clone());

      if( flip_shift)
      {
        BCL_MessageVrb( "applying flip shift");
        // set the translation along the Z axis in random direction of length from first CA to the second CA
        translation =
          strand_pack.GetSecondSSEGeometry()->GetAxis( coord::GetAxes().e_Z) * direction * GetCAShiftAlongZAxis();

        // build up the z flip transformation
        math::TransformationMatrix3D transformation( math::Inverse( sp_this_strand->GetOrientation()));
        transformation( coord::GetAxes().e_Z, math::g_Pi);
        transformation( sp_this_strand->GetOrientation());

        // apply the transformation
        new_strand->Transform( transformation);
      }
      // if no flip
      else
      {
        BCL_MessageVrb( "applying regular shift");
        // set the translation along the Z axis in random direction of length from first CA to third CA
        translation =
          strand_pack.GetSecondSSEGeometry()->GetAxis( coord::GetAxes().e_Z) * direction * GetCAShiftAlongZAxis() * 2;
      }

      // apply the translation
      new_strand->Translate( translation);

      BCL_MessageVrb( "translation: " + util::Format()( translation));

      // replace into new sheet
      new_sheet->Replace( new_strand);

      // now iterate over the strands after
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          strand_itr( this_strand_itr + 1), strand_itr_end( sse_vector.End());
        strand_itr != strand_itr_end;
        ++strand_itr
      )
      {
        // make a hardcopy of this SSE
        util::ShPtr< assemble::SSE> copy_strand( ( *strand_itr)->Clone());

        // if the flip_shift was selected
        if( flip_shift)
        {
          // build up the z flip transformation
          math::TransformationMatrix3D transformation( math::Inverse( copy_strand->GetOrientation()));
          transformation( coord::GetAxes().e_Z, math::g_Pi);
          transformation( copy_strand->GetOrientation());

          // apply the transformation
          copy_strand->Transform( transformation);
        }

        // apply the translation
        copy_strand->Translate( translation);

        // replace into new sheet
        new_sheet->Replace( copy_strand);
      }

      // end
      return math::MutateResult< assemble::Domain>( new_sheet, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSheetRegisterShift::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ShiftProbabilities, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateSheetRegisterShift::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ShiftProbabilities, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sheet_sort.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateSheetSort::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSheetSort())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateSheetSort::MutateSheetSort() :
      m_ReverseSortProbability( 0.0)
    {
    }

    //! @brief constructor from a reverse sort probability
    //! @param REVERSE_SORT_PROBABILITY probability of sorting the strands in reverse order
    MutateSheetSort::MutateSheetSort
    (
      const double REVERSE_SORT_PROBABILITY
    ) :
      m_ReverseSortProbability( REVERSE_SORT_PROBABILITY)
    {
      BCL_Assert
      (
        REVERSE_SORT_PROBABILITY >= 0.0 && REVERSE_SORT_PROBABILITY <= 1.0,
        "The given probability for reverse sorting should be between 0 and 1"
      );
    }

    //! @brief Clone function
    //! @return pointer to new MutateSheetSort
    MutateSheetSort *MutateSheetSort::Clone() const
    {
      return new MutateSheetSort( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateSheetSort::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateSheetSort::GetAlias() const
    {
      static const std::string s_name( "MutateSheetSort");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateSheetSort::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Sorts strands in a sheet by sequence order.");
      serializer.AddInitializer
      (
        "reverse sort probability",
        "probability of sorting strands in reverse order",
        io::Serialization::GetAgent( &m_ReverseSortProbability)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief operator to sort the strands in the given sheet by sequence order
    //! @param SHEET Sheet to be mutated
    //! @return MutateResult that contains the mutated sheet
    math::MutateResult< assemble::Domain> MutateSheetSort::operator()( const assemble::Domain &SHEET) const
    {
      // make sure given domain is a sheet
      BCL_Assert
      (
        SHEET.GetTopology().IsDefined() &&
        (
          SHEET.GetTopology()->GetType() == assemble::Topology::e_Sheet ||
          SHEET.GetTopology()->GetType() == assemble::Topology::e_BetaBarrel
        ),
        "The given domain is not a sheet or a barrel"
      );

      // determine to reverse order
      const bool reverse_order( random::GetGlobalRandom().Double() < m_ReverseSortProbability);

      // construct new sheet
      util::ShPtr< assemble::Domain> sp_sheet( new assemble::Domain());

      // get the subset of strands to be sorted and cast them to SSEs
      util::SiPtrVector< const assemble::SSE> strands( SHEET.GetTopology()->GetElements());
      // check that the cast worked
      BCL_Assert( strands.IsDefined(), "The dynamic cast failed from geometry to SSEs");

      // get the list of strands from domain which should be sorted by sequence order
      util::SiPtrVector< const assemble::SSE> strands_sorted( SHEET.GetSSEs());

      // if reverse order is requested
      if( reverse_order)
      {
        // reverse the sorted strands
        std::reverse( strands_sorted.Begin(), strands_sorted.End());
      }

      // construct a topology and update the elements for the new sheet
      util::ShPtr< assemble::Topology> sp_topology( new assemble::Topology());
      sp_topology->SetType( SHEET.GetTopology()->GetType());
      sp_topology->SetElements( strands_sorted);
      sp_topology->SetOrientationFromType();
      sp_sheet->SetTopology( sp_topology);

      // iterate strands and sorted strands at the same time
      for( size_t i( 0); i < strands.GetSize(); ++i)
      {
        // build transformation to move it to origin
        math::TransformationMatrix3D transformation( strands_sorted( i)->GetOrientation());
        transformation.Invert();

        // update the transformation to move it back to the sheet
        transformation( strands( i)->GetOrientation());

        // make a copy of the SSE
        util::ShPtr< assemble::SSE> sp_new_sse( strands_sorted( i)->Clone());

        // apply the transformation and add the transformed strand to sheet
        sp_new_sse->Transform( transformation);
        sp_sheet->Insert( sp_new_sse);
      }

      // sort and return the result
      return math::MutateResult< assemble::Domain>( sp_sheet, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSheetSort::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ReverseSortProbability, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateSheetSort::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ReverseSortProbability, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sheet_twist.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    // instantiate instance
    const util::SiPtr< const util::ObjectInterface> MutateSheetTwist::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSheetTwist())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateSheetTwist::MutateSheetTwist() :
      m_AngleRange( math::Range< double>( 0.0, math::Angle::Radian( 10.0)))
    {
    }

    //! @brief constructor from an angle range
    //! @param ANGLE_RANGE range of changes in the twist angles in radians to be applied
    MutateSheetTwist::MutateSheetTwist( const math::Range< double> ANGLE_RANGE) :
      m_AngleRange( ANGLE_RANGE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateSheetTwist
    MutateSheetTwist *MutateSheetTwist::Clone() const
    {
      return new MutateSheetTwist( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutateSheetTwist::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateSheetTwist::GetAlias() const
    {
      static const std::string s_name( "MutateSheetTwist");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateSheetTwist::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Adjusts twist angles in a sheet to random values.");
      serializer.AddInitializer
      (
        "angle range",
        "range of allowed twist angles",
        io::Serialization::GetAgent( &m_AngleRange)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes a Sheet and return a mutated Sheet
    //! @param SHEET Sheet which will be mutated
    //! @return MutateResult with the mutated Sheet
    math::MutateResult< assemble::Domain> MutateSheetTwist::operator()( const assemble::Domain &SHEET) const
    {
      // initialize an empty Sheet ShPtr to
      static util::ShPtr< assemble::Domain> s_empty_sheet;

      // make sure the passed domain has a valid topology and is of type sheet or beta-barrel
      if
      (
        !SHEET.GetTopology().IsDefined() ||
        !(
           SHEET.GetTopology()->GetType() == assemble::Topology::e_Sheet ||
           SHEET.GetTopology()->GetType() == assemble::Topology::e_BetaBarrel
         )
      )
      {
        // warn user and return
        BCL_MessageVrb( "The given domain is not a sheet or a barrel");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // make sure the Sheet has at least two strands
      if( SHEET.GetNumberSSEs() < 2)
      {
        // warn user and return
        BCL_MessageVrb( "The given sheet has less than 2 strands, therefore skipping");
        return math::MutateResult< assemble::Domain>( s_empty_sheet, *this);
      }

      // make a copy of the Sheet
      util::ShPtr< assemble::Domain> new_sheet( SHEET.Clone());

      // iterate over SSEs in this sheet using the SSE vector
      for
      (
        util::SiPtrVector< const assemble::SSEGeometryInterface>::const_iterator
          sse_itr( SHEET.GetTopology()->GetElements().Begin()), sse_itr_end( SHEET.GetTopology()->GetElements().End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // get the next strand
        const assemble::SSEGeometryInterface &this_strand( **sse_itr);

        // pick randomly the angle change to be applied
        const double angle_change
        (
          random::GetGlobalRandom().Double( m_AngleRange) * double( random::GetGlobalRandom().Sign())
        );
        BCL_MessageVrb( "Angle selected " + util::Format()( angle_change));

        // construct the transformation need for the angle change
        // first step is to move to the origin
        math::TransformationMatrix3D transformation( math::Inverse( this_strand.GetOrientation()));
        // rotate with the angle change along the y axis
        transformation( coord::GetAxes().e_Y, angle_change);
        // move back to the original location
        transformation( this_strand.GetOrientation());

        // make a copy of this strand and apply the transformation
        // since this is a dynamic we have to make sure it was valid
        util::ShPtr< assemble::SSE> new_strand( this_strand.Clone());
        BCL_Assert( new_strand.IsDefined(), "The dynamic cast from SSEGeometryInterface to SSE failed!");
        new_strand->Transform( transformation);

        // replace the corresponding strand with the new strand in the new sheet
        new_sheet->Replace( new_strand);
      }

      // end
      return math::MutateResult< assemble::Domain>( new_sheet, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSheetTwist::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_AngleRange, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateSheetTwist::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // read members
      io::Serialize::Write( m_AngleRange, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sse_bend_ramachandran.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "assemble/bcl_assemble_sse.h"
#include "biol/bcl_biol_atom.h"
#include "biol/bcl_biol_membrane.h"
#include "biol/bcl_biol_ramachandran.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_result.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateSSEBendRamachandran::s_Instance
    (
      util::Enumerated< math::MutateInterface< assemble::SSE> >::AddInstance( new MutateSSEBendRamachandran())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateSSEBendRamachandran::MutateSSEBendRamachandran() :
      m_NrChanges( math::Range< size_t>( 1, 1)),
      m_BendingDirection( biol::AASequenceFlexibility::e_Bidirectional),
      m_Scheme( GetStaticClassName< MutateSSEBendRamachandran>())
    {
    }

    //! @brief constructor from a range of number of residues to change and a scheme
    //! @param NR_RESIDUES_TO_CHANGE_RANGE ange of number of residues to change
    //! @param BENDING_DIRECTION direction the phi/psi changes should be propagated towards
    //! @param SCHEME Scheme to be used
    MutateSSEBendRamachandran::MutateSSEBendRamachandran
    (
      const math::Range< size_t> &NR_RESIDUES_TO_CHANGE_RANGE,
      const biol::AASequenceFlexibility::SequenceDirection BENDING_DIRECTION,
      const std::string &SCHEME
    ) :
      m_NrChanges( NR_RESIDUES_TO_CHANGE_RANGE),
      m_BendingDirection( BENDING_DIRECTION),
      m_Scheme( SCHEME)
    {
      // make sure the min range is one
      BCL_Assert
      (
        m_NrChanges.GetMin() >= 1,
        "The minimum number of changes has to be at least one" + util::Format()( m_NrChanges)
      );
    }

    //! @brief Clone function
    //! @return pointer to new MutateSSEBendRamachandran
    MutateSSEBendRamachandran *MutateSSEBendRamachandran::Clone() const
    {
      return new MutateSSEBendRamachandran( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateSSEBendRamachandran::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateSSEBendRamachandran::GetAlias() const
    {
      static const std::string s_alias( "MutateSSEBendRamachandran");
      return s_alias;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateSSEBendRamachandran::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Applies bendings to an SSE based on the Ramachandran distribution.");
      serializer.AddInitializer
      (
        "num changes",
        "number of residues to change simultaneously",
        io::Serialization::GetAgent( &m_NrChanges)
      );
      serializer.AddInitializer
      (
        "direction",
        "sequence direction in which to propagate the change",
        io::Serialization::GetAgent( &m_BendingDirection)
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes an SSE and bends amino acids and returns the new SSE
    //! @param THIS_SSE SSE of interest to bend
    //! @return math::MutateResult that has a new SSE with one or more amino acids with new phi/psi values
    math::MutateResult< assemble::SSE> MutateSSEBendRamachandran::operator()( const assemble::SSE &THIS_SSE) const
    {
      return this->operator()( THIS_SSE, util::SiPtr< const biol::Membrane>());
    }

    //! @brief operator that takes an SSE and bends amino acids and returns the new SSE
    //! @param THIS_SSE SSE of interest to bend
    //! @return math::MutateResult that has a new SSE with one or more amino acids with new phi/psi values
    math::MutateResult< assemble::SSE> MutateSSEBendRamachandran::operator()
    (
      const assemble::SSE &THIS_SSE,
      const util::SiPtr< const biol::Membrane> &MEMBRANE
    ) const
    {
      // make a copy of the selected SSE
      util::ShPtr< assemble::SSE> new_sse( THIS_SSE.Clone());

      // determine the number of changes
      const size_t total_nr_changes
      (
        random::GetGlobalRandom().SizeT
        (
          math::Range< size_t>
          (
            std::min( m_NrChanges.GetMin(), THIS_SSE.GetSize()), std::min( m_NrChanges.GetMax(), THIS_SSE.GetSize())
          )
        )
      );

      BCL_MessageVrb
      (
        "The number of amino acids to set phi/psi " + util::Format()( total_nr_changes)
      );

      // get the amino acids
      util::SiPtrVector< const biol::AABase> amino_acids( THIS_SSE.GetMembers());

      // iterate until requested nr_changes
      for( size_t nr_change( 0); nr_change != total_nr_changes; ++nr_change)
      {
        // get a random amino acid
        const util::SiPtr< const biol::AABase> this_aa( amino_acids.RemoveRandomElement());

        // skip unknown amino acids since we don't have a probability distribution for them
        if( this_aa->GetType() == biol::GetAATypes().UNK)
        {
          BCL_MessageVrb
          (
            "amino acid " + this_aa->GetIdentification() + " skipped"
          );
          continue;
        }

        // get environment type in which the current amino acid can be found
        const biol::EnvironmentType current_environment_type
        (
          MEMBRANE.IsDefined() && MEMBRANE->IsDefined() ?
          MEMBRANE->DetermineEnvironmentType( this_aa->GetFirstSidechainAtom().GetCoordinates()) :
          biol::GetEnvironmentTypes().e_Solution
        );

        // skip undefined environment
        if( !current_environment_type.IsDefined())
        {
          continue;
        }

        // get a random phi psi using ramachandran to set for this amino acid
        storage::VectorND< 2, double> new_phi_psi
        (
          biol::Ramachandran::GetDefaultInstance().GetRandomPhiPsi( this_aa->GetType(), THIS_SSE.GetType(), current_environment_type)
        );

        // message
        BCL_MessageVrb
        (
          "amino acid " + this_aa->GetIdentification() +
          " new phi: " + util::Format()( new_phi_psi.First()) + " psi: " + util::Format()( new_phi_psi.Second())
        );

        // use AASequence flexibility to set phi/psi
        biol::AASequenceFlexibility::SetPhiPsi( *new_sse, this_aa->GetSeqID(), new_phi_psi, m_BendingDirection);
      }

      // set the geometries of the sse
      new_sse->SetGeometry();

      // return the result
      return math::MutateResult< assemble::SSE>( new_sse, *this);
    }

    //! @brief virtual operator taking an ARGUMENT and returning a mutate object of t_ArgumentType
    //! @param PROTEIN_MODEL protein model interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::ProteinModel> MutateSSEBendRamachandran::operator()
    (
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // static empty model
      static util::ShPtr< assemble::ProteinModel> s_empty_model;

      auto sses( PROTEIN_MODEL.GetSSEs());

      // get random iterator on the list
      util::SiPtrVector< const assemble::SSE>::const_iterator random_iterator
      (
        random::GetGlobalRandom().Iterator( sses.Begin(), sses.End(), sses.GetSize())
      );

      // if there was no sse found, return an empty result
      if( random_iterator == sses.End())
      {
        // return result with no model
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // randomly pick an sse
      util::SiPtr< const assemble::SSE> random_sse( *random_iterator);

      // get membrane for current protein model
      const util::ShPtr< biol::Membrane> sp_membrane
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Membrane)
      );

      // create a copy of the model
      util::ShPtr< assemble::ProteinModel> new_model( PROTEIN_MODEL.Clone());

      // report selected sse from protein model to be moved
      BCL_MessageVrb( "selected sse to be mutated: " + random_sse->GetIdentification());

      // call the mutate and get the result
      math::MutateResult< assemble::SSE> result_sse( this->operator()( *random_sse, sp_membrane));

      // if not successful
      if( !result_sse.GetArgument().IsDefined())
      {
        BCL_MessageVrb( "could not mutate sse : " + random_sse->GetIdentification());

        // return result with no model
        return math::MutateResult< assemble::ProteinModel>( s_empty_model, *this);
      }

      // replace the sse with the mutated copy of the same sse
      new_model->Replace( result_sse.GetArgument());

      // end
      return math::MutateResult< assemble::ProteinModel>( new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sse_bend_random.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> MutateSSEBendRandom::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSSEBendRandom())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateSSEBendRandom::MutateSSEBendRandom() :
      m_PhiChangeRange( math::Angle::Radian( -20.0), math::Angle::Radian( 20.0)),
      m_PsiChangeRange( math::Angle::Radian( -20.0), math::Angle::Radian( 20.0)),
      m_BendingDirection( biol::AASequenceFlexibility::e_Bidirectional),
      m_Scheme( GetStaticClassName< MutateSSEBendRandom>())
    {
    }

    //! @brief constructor phi/psi change ranges and a scheme
    //! @param PHI_CHANGE_RANGE range for phi changes
    //! @param PSI_CHANGE_RANGE range for psi changes
    //! @param BENDING_DIRECTION direction the phi/psi changes should be propagated towards
    //! @param SCHEME Scheme to be used
    MutateSSEBendRandom::MutateSSEBendRandom
    (
      const math::Range< double> &PHI_CHANGE_RANGE,
      const math::Range< double> &PSI_CHANGE_RANGE,
      const biol::AASequenceFlexibility::SequenceDirection BENDING_DIRECTION,
      const std::string &SCHEME
    ) :
      m_PhiChangeRange( PHI_CHANGE_RANGE),
      m_PsiChangeRange( PSI_CHANGE_RANGE),
      m_BendingDirection( BENDING_DIRECTION),
      m_Scheme( SCHEME)
    {
    }

    //! @brief clone
    MutateSSEBendRandom *MutateSSEBendRandom::Clone() const
    {
      return new MutateSSEBendRandom( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateSSEBendRandom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get phi change range
    //! @return phi change range
    const math::Range< double> &MutateSSEBendRandom::GetPhiChangeRange() const
    {
      return m_PhiChangeRange;
    }

    //! @brief get phi change range
    //! @return phi change range
    const math::Range< double> &MutateSSEBendRandom::GetPsiChangeRange() const
    {
      return m_PsiChangeRange;
    }

    //! @brief return bending direction
    //! @return bending direction
    biol::AASequenceFlexibility::SequenceDirection MutateSSEBendRandom::GetBendingDirection() const
    {
      return m_BendingDirection;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that changes phi/psi angles of a random amino acid in the given SSE
    //! @param THIS_SSE SSE interest
    //! @return MutateResult with ProteinModel after the mutate
    math::MutateResult< assemble::SSE> MutateSSEBendRandom::operator()
    (
      const assemble::SSE &THIS_SSE
    ) const
    {
      // make a copy of the selected SSE
      util::ShPtr< assemble::SSE> new_sse( THIS_SSE.Clone());

      // decide on a random amino acid to pick
      const int seq_id
      (
        random::GetGlobalRandom().Integer
        (
          math::Range< int>( new_sse->GetFirstAA()->GetSeqID(), new_sse->GetLastAA()->GetSeqID())
        )
      );

      // calculate the phi psi change
      const storage::VectorND< 2, double> phi_psi_change
      (
        random::GetGlobalRandom().Double( m_PhiChangeRange), random::GetGlobalRandom().Double( m_PsiChangeRange)
      );

      // use the AASequence flexibility to bend the sequence
      biol::AASequenceFlexibility::ChangePhiPsi( *new_sse, seq_id, phi_psi_change, m_BendingDirection);

      // set the geometries
      new_sse->SetGeometry();

      // end
      return math::MutateResult< assemble::SSE>( new_sse, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSSEBendRandom::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_PhiChangeRange, ISTREAM);
      io::Serialize::Read( m_PsiChangeRange, ISTREAM);
      io::Serialize::Read( m_BendingDirection, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &MutateSSEBendRandom::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_PhiChangeRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PsiChangeRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_BendingDirection, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sse_bend_template.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_fold_template.h"
#include "assemble/bcl_assemble_fold_template_handler.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateSSEBendTemplate::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSSEBendTemplate())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateSSEBendTemplate::MutateSSEBendTemplate() :
      m_SSEGeometryCompare( new assemble::SSEGeometryWithinSizeTolerance()),
      m_Scheme( GetStaticClassName< MutateSSEBendTemplate>())
    {
    }

    //! @brief construct from SSE geometry comparison function
    //! @param SSE_GEOMETRY_COMPARE SSE geometry comparison function
    //! @param SCHEME Scheme to be used
    MutateSSEBendTemplate::MutateSSEBendTemplate
    (
      const math::BinaryFunctionInterface< assemble::SSE, assemble::SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE,
      const std::string &SCHEME
    ) :
      m_SSEGeometryCompare( SSE_GEOMETRY_COMPARE.Clone()),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateSSEBendTemplate
    MutateSSEBendTemplate *MutateSSEBendTemplate::Clone() const
    {
      return new MutateSSEBendTemplate( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateSSEBendTemplate::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that takes an SSE and bends amino acids and returns the new SSE
    //! @param THIS_SSE SSE of interest to bend
    //! @return math::MutateResult that has a new SSE bent according to the random geometry from a fold template
    math::MutateResult< assemble::SSE> MutateSSEBendTemplate::operator()( const assemble::SSE &THIS_SSE) const
    {
      // initialize static undefined SSE
      static const util::ShPtr< assemble::SSE> sp_undefined_sse;

      // create a single element vector from the sse
      const util::SiPtr< const assemble::SSE> sp_sse( THIS_SSE);
      const util::SiPtrVector< const assemble::SSE> sse_vector( sp_sse);

      // get a random, single-geometry fold template
      const assemble::FoldTemplate fold_template
      (
        assemble::FoldTemplateHandler::GetRandomSubTemplate( sse_vector, *m_SSEGeometryCompare)
      );

      // if no fold template was found
      if( fold_template.GetGeometries().IsEmpty())
      {
        // return undefined mutate result
        return math::MutateResult< assemble::SSE>( sp_undefined_sse, *this);
      }

      // fit the sse
      const assemble::Domain fit_sse_domain( fold_template.FitSSEs( sse_vector));

      // if the domain is empty
      const util::SiPtrVector< const assemble::SSE> domain_sse_vector( fit_sse_domain.GetSSEs());
      if( domain_sse_vector.IsEmpty())
      {
        // return undefined mutate result
        return math::MutateResult< assemble::SSE>( sp_undefined_sse, *this);
      }

      // get the new sse
      util::ShPtr< assemble::SSE> new_sse( domain_sse_vector.FirstElement()->Clone());

      // move the new sse to the position of the original sse
      math::TransformationMatrix3D transform( math::Inverse( new_sse->GetOrientation()));
      transform( THIS_SSE.GetOrientation());
      new_sse->Transform( transform);

      // end
      return math::MutateResult< assemble::SSE>( new_sse, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSSEBendTemplate::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSEGeometryCompare, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateSSEBendTemplate::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSEGeometryCompare, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace fold

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_sse_type.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateSSEType::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateSSEType( storage::Set< biol::SSType>()))
    );

    //! @brief the default scheme
    //! @return reference to default scheme as string
    const std::string &MutateSSEType::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "sse_type");
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor
    //! @param POSSIBLE_TYPES set of types that sses can be set to
    //! @param SCHEME the scheme of the mutate
    MutateSSEType::MutateSSEType
    (
      const storage::Set< biol::SSType> &POSSIBLE_TYPES,
      const std::string &SCHEME
    ) :
      m_PossibleTypes( POSSIBLE_TYPES),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MutateSSEType
    MutateSSEType *MutateSSEType::Clone() const
    {
      return new MutateSSEType( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateSSEType::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief change the sse type and the conformation accordingly
    //! @param ELEMENT the sse to change
    //! @return MutateResult that results from mutating to the SSE
    math::MutateResult< assemble::SSE> MutateSSEType::operator()( const assemble::SSE &ELEMENT) const
    {
      // reduce the set of types to be considered
      storage::Set< biol::SSType> remaining_types( m_PossibleTypes);
      remaining_types.Erase( ELEMENT.GetType());

      // if there are no types left to set it to
      if( remaining_types.IsEmpty())
      {
        return math::MutateResult< assemble::SSE>( util::ShPtr< assemble::SSE>(), *this);
      }

      // get a random new type
      const storage::Set< biol::SSType>::const_iterator itr
      (
        random::GetGlobalRandom().Iterator( remaining_types.Begin(), remaining_types.End(), remaining_types.GetSize())
      );

      // create a new sse from the sequence and the new sstype
      const util::ShPtr< assemble::SSE> sp_sse( new assemble::SSE( ELEMENT, *itr));

      BCL_MessageDbg( "changed sstype: " + ELEMENT.GetIdentification() + '\t' + sp_sse->GetIdentification());

      // return the result
      return math::MutateResult< assemble::SSE>( sp_sse, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutateSSEType::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_PossibleTypes, ISTREAM);
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutateSSEType::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_PossibleTypes, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme,        OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutate_tree.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_mutates.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_decision_node.h"
#include "storage/bcl_storage_table.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

    //! @brief conversion to a string from a MutateTypes
    //! @param MUTATE_TYPE the mutate type to get a string for
    //! @return a string representing that mutate type
    const std::string &MutateTree::GetMutateTypeName( const MutateTypes &MUTATE_TYPE)
    {
       static const std::string s_descriptors[] =
       {
         "add", "remove", "swap", "sse", "helix", "strand", "ssepair", "helixpair",
         "helixdomain", "sheet", "domain", "model", "ensemble", "undefined"
       };
       return s_descriptors[ size_t( MUTATE_TYPE)];
    }

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutateTree::s_Instance
    (
      GetObjectInstances().AddInstance( new MutateTree())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutateTree::MutateTree() :
      m_MutateTypeProbabilities(),
      m_MutateProbabilities()
    {
    }

    //! @brief constructor from a weight table
    //! @param WEIGHT_TABLE table with mutate weights
    MutateTree::MutateTree( const storage::Table< double> &WEIGHT_TABLE) :
      m_MutateTypeProbabilities(),
      m_MutateProbabilities()
    {
      // initialize from the table
      InitializeFromTable( WEIGHT_TABLE);
    }

    //! @brief Clone function
    //! @return pointer to new MutateTree
    MutateTree *MutateTree::Clone() const
    {
      return new MutateTree( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &MutateTree::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &MutateTree::GetAlias() const
    {
      static const std::string s_name( "MutateTree");
      return s_name;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief reset all the information in the tree
    void MutateTree::Reset()
    {
      // iterate over the mutate type probabilities and set to 0
      for
      (
        storage::Map< MutateTypesEnum, double>::iterator
          itr( m_MutateTypeProbabilities.Begin()), itr_end( m_MutateTypeProbabilities.End());
        itr != itr_end; ++itr
      )
      {
        itr->second = 0.0;
      }

      // iterate over the mutate probabilities and set to 0
      for
      (
        storage::Map< MutateTypesEnum, storage::Map< Mutate, double> >::iterator
          itr_a( m_MutateProbabilities.Begin()), itr_a_end( m_MutateProbabilities.End());
        itr_a != itr_a_end; ++itr_a
      )
      {
        // iterate over all the mutates for this type
        for
        (
          storage::Map< Mutate, double>::iterator itr_b( itr_a->second.Begin()), itr_b_end( itr_a->second.End());
          itr_b != itr_b_end; ++itr_b
        )
        {
          itr_b->second = 0.0;
        }
      }
    }

    //! @brief sets the probability for a given mutate enum
    //! @param MUTATE_ENUM enum of the mutate of interest
    //! @param PROBABILITY probability of the mutate to be assigned
    void MutateTree::SetMutateProbability( const Mutate &MUTATE_ENUM, const double PROBABILITY)
    {
      // first get the corresponding mutate type
      const MutateTypes mutate_type( ParseMutateType( MUTATE_ENUM.GetName()));

      // make sure it is not undefined
      BCL_Assert
      (
        mutate_type != s_NumberMutateTypes, "The given mutate name does not conform to standards " +
        MUTATE_ENUM.GetName()
      );

      // set the probability
      m_MutateProbabilities[ mutate_type][ MUTATE_ENUM] = PROBABILITY;
    }

    //! @brief sets the default probability for a given mutate enum
    //! @param MUTATE_ENUM enum of the mutate of interest
    //! @param PROBABILITY probability of the mutate to be assigned
    void MutateTree::SetDefaultMutateProbability( const Mutate &MUTATE_ENUM, const double PROBABILITY)
    {
      // first get the corresponding mutate type
      const MutateTypes mutate_type( ParseMutateType( MUTATE_ENUM.GetName()));

      // make sure it is not undefined
      BCL_Assert
      (
        mutate_type != s_NumberMutateTypes, "The given mutate name does not conform to standards " +
        MUTATE_ENUM.GetName()
      );

      // set the probability
      m_MutateProbabilities[ mutate_type][ MUTATE_ENUM] = PROBABILITY;

      // set the set status to not set
      SetMutateSet( MUTATE_ENUM, false);
    }

    //! @brief gets the probability for a given mutate enum
    //! @param MUTATE_ENUM enum of the mutate of interest
    //! @return probability of the mutate
    double MutateTree::GetMutateProbability( const Mutate &MUTATE_ENUM) const
    {
      // first get the corresponding mutate type
      const MutateTypes mutate_type( ParseMutateType( MUTATE_ENUM.GetName()));

      // get an iterator to the mutate type
      storage::Map< MutateTypesEnum, storage::Map< Mutate, double> >::const_iterator type_itr
      (
        m_MutateProbabilities.Find( mutate_type)
      );
      if( type_itr == m_MutateProbabilities.End())
      {
        return 0.0;
      }

      // get an iterator to the mutate
      storage::Map< Mutate, double>::const_iterator mutate_itr( type_itr->second.Find( MUTATE_ENUM));

      // end
      return mutate_itr == type_itr->second.End() ? 0.0 : mutate_itr->second;
    }

    //! @brief sets the probability for a given mutate
    //! @param MUTATE_NAME Name of the mutate of interest
    //! @param PROBABILITY probability of the mutate to be assigned
    void MutateTree::SetMutateProbability( const std::string &MUTATE_NAME, const double PROBABILITY)
    {
      // get the corresponding enum
      const Mutate mutate( GetMutates().GetEnumFromName( MUTATE_NAME));

      BCL_Assert( mutate.IsDefined(), "no enum with name: " + MUTATE_NAME);

      // call with enum
      SetMutateProbability( mutate, PROBABILITY);
    }
    //! @brief get the probability of a given mutate type
    //! @param MUTATE_TYPE mutate type of interest
    //! return probability of mutate type
    double MutateTree::GetMutateTypeProbability( const MutateTypes &MUTATE_TYPE) const
    {
      // get an iterator to the mutate type
      storage::Map< MutateTypesEnum, double>::const_iterator type_itr
        (
         m_MutateTypeProbabilities.Find( MUTATE_TYPE)
         );

      // make sure it was found
      BCL_Assert
        (
         type_itr != m_MutateTypeProbabilities.End(),
         "The given mutate name does not conform to standards "
         );

      // end
      return type_itr->second;
    }

    //! @brief set the probabilities for a specific mutate type
    //! @param MUTATE_TYPE MutateTypes of interest
    //! @param PROBABILITY Probability to set to
    void MutateTree::SetMutateTypeProbability( const MutateTypes &MUTATE_TYPE, const double PROBABILITY)
    {
      m_MutateTypeProbabilities[ MUTATE_TYPE] = PROBABILITY;
      m_MutateTypeSet[ MUTATE_TYPE] = true;
    }

    //! @brief set the default probabilities for a specific mutate type
    //! @param MUTATE_TYPE MutateTypes of interest
    //! @param PROBABILITY Probability to set to
    void MutateTree::SetDefaultMutateTypeProbability( const MutateTypes &MUTATE_TYPE, const double PROBABILITY)
    {
      m_MutateTypeProbabilities[ MUTATE_TYPE] = PROBABILITY;
      m_MutateTypeSet[ MUTATE_TYPE] = false;
    }

    //! @brief gets the set status for a given mutate type
    //! @param MUTATE_TYPE type of the mutate of interest
    //! @return set status of the mutate type
    bool MutateTree::GetMutateTypeSet( const MutateTypes &MUTATE_TYPE) const
    {
      // get an iterator to the mutate type
      storage::Map< MutateTypesEnum, bool>::const_iterator type_itr
        (
         m_MutateTypeSet.Find( MUTATE_TYPE)
         );
      if( type_itr == m_MutateTypeSet.End())
        {
          return false;
        }
      // end
      return type_itr->second;
    }

    //! @brief set the mutate type to having been set
    //! @param MUTATE_TYPE mutate type of interest
    //! @param SET whether or not it has been set
    void MutateTree::SetMutateTypeSet( const MutateTypes &MUTATE_TYPE, const bool SET)
    {
      m_MutateTypeSet[ MUTATE_TYPE] = SET;
    }

    //! @brief get whether or not the probability of the given mutate type is zero
    //! @param MUTATE_TYPE mutate type of interest
    //! @return whether or not the probability is zero
    bool MutateTree::GetMutateTypeZero( const MutateTypes &MUTATE_TYPE) const
    {
      storage::Map< MutateTypesEnum, double>::const_iterator type_itr
      (
        m_MutateTypeProbabilities.Find( MUTATE_TYPE)
      );

      return type_itr == m_MutateTypeProbabilities.End() || type_itr->second == 0.0;
    }

    //! @brief get whether or not a given mutate has been set
    //! @param MUTATE mutate of interest
    //! @return whether or not this mutate has been set
    bool MutateTree::GetMutateSet( const Mutate &MUTATE) const
    {
      // get an iterator to the mutate type
      storage::Map< Mutate, bool>::const_iterator set_itr
      (
        m_MutateSet.Find( MUTATE)
      );

      return set_itr != m_MutateSet.End() && set_itr->second;
    }

    //! @brief set the mutate to having been set
    //! @param MUTATE mutate of interest
    //! @param SET whether or not it has been set
    void MutateTree::SetMutateSet( const Mutate &MUTATE, const bool SET)
    {
      m_MutateSet[ MUTATE] = SET;
    }

    //! @brief get whether or not the probability of the given mutate is zero
    //! @param MUTATE mutate of interest
    //! @return whether or not the probability is zero
    bool MutateTree::GetMutateZero( const Mutate &MUTATE_ENUM) const
    {
      // first get the corresponding mutate type
      const MutateTypes mutate_type( ParseMutateType( MUTATE_ENUM.GetName()));

      // get an iterator to the mutate type
      storage::Map< MutateTypesEnum, storage::Map< Mutate, double> >::const_iterator type_itr
        (
         m_MutateProbabilities.Find( mutate_type)
         );

      // make sure it was found
      if( type_itr == m_MutateProbabilities.End())
      {
        return 0.0;
      }

      // get an iterator to the mutate
      storage::Map< Mutate, double>::const_iterator mutate_itr( type_itr->second.Find( MUTATE_ENUM));

      return mutate_itr == type_itr->second.End() || mutate_itr->second == 0.0;
    }

    //! @brief parses the given mutate name and returns the mutate type
    //! @param MUTATE_NAME name of the mutate
    //! @return corresponding mutate type
    MutateTree::MutateTypes MutateTree::ParseMutateType( const std::string &MUTATE_NAME)
    {
      // get the substring until the first "_"
      const size_t first_underscore( MUTATE_NAME.find_first_of( '_'));

      // if it was not found
      BCL_Assert( first_underscore != std::string::npos, "Following mutate does not exist: " + MUTATE_NAME);

      // form the substring
      const std::string mutate_type_name( MUTATE_NAME.substr( 0, first_underscore));

      // find the matching enum (returns s_NumberMutateTypes if none have this name)
      return MutateTypesEnum( mutate_type_name);
    }

    //! @brief create a table from mutate tree
    //! @return table created from the mutate tree
    storage::Table< double> MutateTree::CreateTable() const
    {
      // initialize table
      storage::Table< double> table( storage::Vector< std::string>::Create( "weights", "final_weights"));

      // iterate over the mutate types
      for
      (
        storage::Map< MutateTypesEnum, double>::const_iterator
          map_itr( m_MutateTypeProbabilities.Begin()), map_itr_end( m_MutateTypeProbabilities.End());
        map_itr != map_itr_end; ++map_itr
      )
      {
        // insert the name
        table.InsertRow
        (
          GetMutateTypeName( map_itr->first),
          storage::Vector< double>::Create( map_itr->second, map_itr->second)
        );
      }

      // iterate over the mutate tree
      for
      (
        storage::Map< MutateTypesEnum, storage::Map< Mutate, double> >::const_iterator
          node_itr( m_MutateProbabilities.Begin()), node_itr_end( m_MutateProbabilities.End());
        node_itr != node_itr_end; ++node_itr
      )
      {
        // create a reference on this leaf map
        const storage::Map< Mutate, double> &this_map( node_itr->second);

        // now iterate over the leaves
        for
        (
          storage::Map< Mutate, double>::const_iterator
            mutate_itr( this_map.Begin()), mutate_itr_end( this_map.End());
          mutate_itr != mutate_itr_end; ++mutate_itr
        )
        {
          // get the probability of the mutate type
          const storage::Map< MutateTypesEnum, double>::const_iterator type_itr
          (
            m_MutateTypeProbabilities.Find( node_itr->first)
          );
          BCL_Assert
          (
            type_itr != m_MutateTypeProbabilities.End(),
            "Unable to find mutate type for " + mutate_itr->first.GetName()
          );

          // insert the leaf into the table
          table.InsertRow
          (
            mutate_itr->first.GetName(),
            storage::Vector< double>::Create
            (
              mutate_itr->second,
              type_itr->second * mutate_itr->second
            )
          );
        }
      }

      // end
      return table;
    }

    //! @brief creates the mutate function using all the mutates in the mutate tree
    //! @return the mutate function constructed from all the mutates in the mutate tree
    util::ShPtr< math::MutateInterface< assemble::ProteinModel> > MutateTree::ConstructMutates() const
    {
      // initialize object distribution for all nodes
      math::ObjectProbabilityDistribution< math::MutateInterface< assemble::ProteinModel> > all_nodes;

      // iterate over all nodes
      for
      (
        storage::Map< MutateTypesEnum, double>::const_iterator
          map_itr( m_MutateTypeProbabilities.Begin()), map_itr_end( m_MutateTypeProbabilities.End());
        map_itr != map_itr_end; ++map_itr
      )
      {
        // create variables to hold the type and the probability
        const MutateTypes mutate_type( map_itr->first);
        const std::string mutate_type_name( GetMutateTypeName( mutate_type));
        const double mutate_type_prob( map_itr->second);

        // see if there is an entry for this mutate type
        storage::Map< MutateTypesEnum, storage::Map< Mutate, double> >::const_iterator itr( m_MutateProbabilities.Find( mutate_type));

        // if not found
        if( itr == m_MutateProbabilities.End())
        {
          // then skip to next one
          continue;
        }

        // create reference on the mutate map for this type
        const storage::Map< Mutate, double> &this_mutate_map( itr->second);

        BCL_MessageVrb
        (
          "mutate_type: " + mutate_type_name + " " + util::Format()( mutate_type_prob)
        );

        // warn user if node probability is set to 0 but there are corresponding leaves
        if( mutate_type_prob == 0.0)
        {
          if( !this_mutate_map.IsEmpty())
          {
            BCL_MessageVrb
            (
              "The mutate node " + mutate_type_name +
              " has a 0 probability, therefore following mutates will not be used\n" + util::Format()( this_mutate_map)
            );
          }
        }
        else if( this_mutate_map.IsEmpty())
        {
          BCL_MessageVrb( "No mutates in this node therefore skipping " + mutate_type_name);
        }
        else
        {
          // build a object probability distribution for this node
          math::ObjectProbabilityDistribution< math::MutateInterface< assemble::ProteinModel> > this_node;

          // iterate over mutates of this type and add them to this node
          for
          (
            storage::Map< Mutate, double>::const_iterator
              mutate_itr( this_mutate_map.Begin()), mutate_itr_end( this_mutate_map.End());
            mutate_itr != mutate_itr_end; ++mutate_itr
          )
          {
            // store the mutate name
            const std::string mutate_name( mutate_itr->first.GetName());
            const double mutate_prob( mutate_itr->second);

            BCL_MessageVrb
            (
              "mutate " + mutate_name + " " + util::Format()( mutate_prob)
            );

            // if 0.0 probability skip over
            if( mutate_prob == 0.0)
            {
              BCL_MessageVrb( "Skipping this mutate with 0 probability " + mutate_name);
              continue;
            }

            // insert into the map the mutate and the probability
            this_node.PushBack( mutate_prob, **mutate_itr->first);
          }
          // construct decision node push it into all_nodes
          all_nodes.PushBack( mutate_type_prob, math::MutateDecisionNode< assemble::ProteinModel>( this_node, map_itr->first.GetString()));
        }
      }

      // construct the decision node from all nodes and return
      return util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
      (
        new math::MutateDecisionNode< assemble::ProteinModel>( all_nodes, "MutateDecisionNode")
      );
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer MutateTree::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Stores mutates with associated probabilities for MCM approximation");
      serializer.AddInitializer
      (
        "mutate type probabilities",
        "assignment of probabilities to the different mutate types",
        io::Serialization::GetAgent( &m_MutateTypeProbabilities)
      );
      serializer.AddInitializer
      (
        "mutate probabilities",
        "assignment of probabilities to the different mutates",
        io::Serialization::GetAgent( &m_MutateProbabilities)
      );

      return serializer;
    }

    //! @brief merge two mutate trees
    void MutateTree::Merge( const MutateTree &MUTATE_TREE)
    {
      // set mutate type probabilities
      storage::Map< MutateTypesEnum, double> mutate_types( MUTATE_TREE.GetMutateTypeProbabilities());
      for( auto type_itr( mutate_types.Begin()), type_itr_end( mutate_types.End()); type_itr != type_itr_end; ++type_itr)
        {
          // if it has not been set or the new tree is setting it to zero
          if( !GetMutateTypeSet( type_itr->first) || MUTATE_TREE.GetMutateTypeZero( type_itr->first))
            {
              // set the tree's probability to that of MUTATE_TREE
              const double type_prob( MUTATE_TREE.GetMutateTypeProbability( type_itr->first));
              SetMutateTypeProbability( type_itr->first, type_prob);
              SetMutateTypeSet( type_itr->first, true);
            }
        }

      // set mutate probabilities according to the second tree
      storage::Map< MutateTypesEnum, storage::Map< Mutate, double> > mutates( MUTATE_TREE.GetMutateProbabilities());
      for( auto node_itr( mutates.Begin()), node_itr_end( mutates.End()); node_itr != node_itr_end; node_itr++)
      {
        // create a reference on this leaf map
         const storage::Map< Mutate, double> &this_map( node_itr->second);

        //iterate over the leaves
         for( auto mutate_itr( this_map.Begin()), mutate_itr_end( this_map.End()); mutate_itr != mutate_itr_end; ++mutate_itr)
         {
           // set new mutate probabilities if they haven't already been set or the new probability is zero
           if( !GetMutateSet( mutate_itr->first) || MUTATE_TREE.GetMutateZero( mutate_itr->first))
           {
             const double mutate_prob( MUTATE_TREE.GetMutateProbability( mutate_itr->first));
             SetMutateProbability( mutate_itr->first, mutate_prob);
             SetMutateSet( mutate_itr->first, true);
           }
         }
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief initializes the mutate tree using a given table
    //! @param WEIGHT_TABLE table that contains the weights for mutates
    void MutateTree::InitializeFromTable( const storage::Table< double> &WEIGHT_TABLE)
    {
      // if the weight table does not have a row named weights
      if( !WEIGHT_TABLE.HasRow( "weights"))
      {
        // make sure at least it has column weights
        BCL_Assert
        (
          WEIGHT_TABLE.GetHeader().HasColumn( "weights"),
          "The given mutate weight table has no rows or columns named \"weights\""
        );

        // then transpose the table
        storage::Table< double> weight_table_transposed( WEIGHT_TABLE.GetTransposedTable());

        // now call this function with the transposed table
        return InitializeFromTable( weight_table_transposed);
      }

      // get the map from the table
      storage::Map< std::string, double> weights_read( WEIGHT_TABLE[ "weights"].ConvertToMap());

      // iterate over each mutate type
      for( size_t i( 0); i < s_NumberMutateTypes; ++i)
      {
        // construct mutate type
        MutateTypes this_type = MutateTypes( i);
        MutateTypesEnum wrapper( this_type);

        // try to find the probability for this mutate type
        storage::Map< std::string, double>::iterator type_itr( weights_read.Find( wrapper));

        // if there was no probability
        if( type_itr == weights_read.End())
        {
          // insert with 0 probability
          m_MutateTypeProbabilities[ this_type] = 0.0;
        }
        // otherwise
        else
        {
          // insert the weight
          m_MutateTypeProbabilities[ this_type] = type_itr->second;

          // remove from the list
          weights_read.RemoveElement( type_itr);
        }
      }

      // now iterate over remaining ones - they should be all mutates
      for
      (
        storage::Map< std::string, double>::const_iterator
          map_itr( weights_read.Begin()), map_itr_end( weights_read.End());
        map_itr != map_itr_end; ++map_itr
      )
      {
        // store the string and probability
        const std::string mutate_name( map_itr->first);
        const double mutate_prob( map_itr->second);

        // parse the mutate type and type name
        const MutateTypes this_type( ParseMutateType( mutate_name));
        const std::string this_typename( GetMutateTypeName( this_type));

        // make sure it is not an undefined mutate type
        BCL_Assert( this_type != s_NumberMutateTypes, "this mutate name is not valid! " + mutate_name);

        // find the corresponding mutate
        const Mutate &mutate( GetMutates().GetEnumFromName( mutate_name));

        // make sure it is not undefined
        BCL_Assert( mutate != GetMutates().e_Undefined, "There is no mutate with the given name " + mutate_name);

        // if the node has zero probability
        if( m_MutateTypeProbabilities[ this_type] == 0.0)
        {
          // warn user
          BCL_MessageVrb
          (
            "Following mutate won't be used since the node it belongs has a 0 probability " + mutate_name
          );
        }
        // if the node has non zero probability then insert
        else
        {
          // otherwise insert into corresponding node
          m_MutateProbabilities[ this_type][ mutate] = mutate_prob;
        }
      }
    }

  } // namespace fold

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_mutation_residue.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> MutationResidue::s_Instance
    (
      GetObjectInstances().AddInstance( new MutationResidue())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    MutationResidue::MutationResidue() :
      m_MutationResidue(),
      m_PreviousResidue(),
      m_FollowingResidue()
    {
    }

    //! @brief constructor taking member variables
    //! @param RESIDUE_TO_MUTATE the residue of interest
    //! @param RESIDUE_A residue to either side of the residue to mutate
    //! @param RESIDUE_B residue to either side of residue to mutate
    MutationResidue::MutationResidue
    (
      const util::ShPtr< biol::AABase> &RESIDUE_TO_MUTATE,
      const util::ShPtr< biol::AABase> &RESIDUE_A,
      const util::ShPtr< biol::AABase> &RESIDUE_B
    ) :
      m_MutationResidue( RESIDUE_TO_MUTATE),
      m_PreviousResidue(),
      m_FollowingResidue()
    {
      BCL_Assert( m_MutationResidue.IsDefined(), "m_MutationResidue residue is not defined");
      if( RESIDUE_TO_MUTATE.IsDefined())
      {
        BCL_MessageDbg( "residue to mutate " + RESIDUE_TO_MUTATE->GetIdentification());
      }
      if( RESIDUE_A.IsDefined())
      {
        BCL_MessageDbg( "RESIDUE_A " + RESIDUE_A->GetIdentification());
      }
      if( RESIDUE_B.IsDefined())
      {
        BCL_MessageDbg( "RESIDUE_B " + RESIDUE_B->GetIdentification());
      }
      SortResidues( RESIDUE_A, RESIDUE_B);
    }

    //! @brief constructor from iterator to residue to mutate and the map of all the residues
    //! @param RESIDUE_TO_MUTATE residue indicated to mutate
    //! @param ALL_RESIDUES all residues that could be mutated
    MutationResidue::MutationResidue
    (
      const storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> >::const_iterator RESIDUE_TO_MUTATE,
      const storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> > &ALL_RESIDUES
    ) :
      m_MutationResidue( RESIDUE_TO_MUTATE->First()),
      m_PreviousResidue(),
      m_FollowingResidue()
    {
      BCL_Assert( m_MutationResidue.IsDefined(), "mutation residue is not defined");

      if( ALL_RESIDUES.GetSize() < 2)
      {
        BCL_MessageDbg( "single residue");
        return;
      }

      // true if first residue
      if( RESIDUE_TO_MUTATE == ALL_RESIDUES.Begin())
      {
        BCL_MessageDbg( "at first residue");
        SortResidues( util::ShPtr< biol::AABase>(), ( ++ALL_RESIDUES.Begin())->First());
      }

      // true if last residue
      else if( RESIDUE_TO_MUTATE == --ALL_RESIDUES.End())
      {
        BCL_MessageDbg( "at last residue");
        SortResidues( util::ShPtr< biol::AABase>(), ( ----ALL_RESIDUES.End())->First());
      }

      // interior residue
      else
      {
        BCL_MessageDbg( "at interior residue");
        storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> >::const_iterator itr_a( RESIDUE_TO_MUTATE);
        --itr_a;
        storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> >::const_iterator itr_b( RESIDUE_TO_MUTATE);
        ++itr_b;
        BCL_MessageDbg( "surrounding residue a " + itr_a->First()->GetIdentification());
        BCL_MessageDbg( "surrounding residue b " + itr_b->First()->GetIdentification());
        BCL_MessageDbg( "RESIDUE_TO_MUTATE still the same? " + RESIDUE_TO_MUTATE->First()->GetIdentification());
        SortResidues( itr_a->First(), itr_b->First());
      }

    }

    //! @brief Clone function
    //! @return pointer to new MutationResidue
    MutationResidue *MutationResidue::Clone() const
    {
      return new MutationResidue( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MutationResidue::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetPreviousResidue gives the residue preceding the residue of interest in sequence
    //! @return the residue preceding the residue of interest in sequence
    const util::ShPtr< biol::AABase> &MutationResidue::GetPreviousResidue() const
    {
      return m_PreviousResidue;
    }

    //! @brief GetFollowingResidue gives the residue proceding the residue of interest in sequence
    //! @return the residue proceding the residue of interest in sequence
    const util::ShPtr< biol::AABase> &MutationResidue::GetFollowingResidue() const
    {
      return m_FollowingResidue;
    }

    //! @brief GetMutationResidue gives the residue of interest
    //! @return the residue of interest
    const util::ShPtr< biol::AABase> &MutationResidue::GetMutationResidue() const
    {
      return m_MutationResidue;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MutationResidue::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_MutationResidue, ISTREAM);
      io::Serialize::Read( m_PreviousResidue, ISTREAM);
      io::Serialize::Read( m_FollowingResidue, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &MutationResidue::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_MutationResidue, OSTREAM, INDENT);
      io::Serialize::Write( m_PreviousResidue, OSTREAM, INDENT);
      io::Serialize::Write( m_FollowingResidue, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief assigns the member variables to the proper residue
    //! @param RESIDUE_A first residue
    //! @param RESIDUE_B second residue
    void MutationResidue::SortResidues
    (
      const util::ShPtr< biol::AABase> &RESIDUE_A, const util::ShPtr< biol::AABase> &RESIDUE_B
    )
    {
      const int mut_seq_id( m_MutationResidue->GetSeqID());

      // true if neither pointer is defined, just assign them
      if( !RESIDUE_A.IsDefined() && !RESIDUE_B.IsDefined())
      {
        BCL_MessageDbg( "neither residue is defined");
        m_PreviousResidue  = RESIDUE_A;
        m_FollowingResidue = RESIDUE_B;
      }

      // true if both are defined
      else if( RESIDUE_A.IsDefined() && RESIDUE_B.IsDefined())
      {
        BCL_MessageDbg( "sorting residue " + RESIDUE_A->GetIdentification() + " and " + RESIDUE_B->GetIdentification());
        // make sure they have the same chain ids as the mutation residue
        BCL_Assert
        (
          RESIDUE_A->GetChainID() == RESIDUE_B->GetChainID() &&
          RESIDUE_A->GetChainID() == m_MutationResidue->GetChainID(),
          "chain ids don't match"
        );

        // get the seq ids
        const int seq_id_a( RESIDUE_A->GetSeqID()), seq_id_b( RESIDUE_B->GetSeqID());

        // make sure the seq ids are not the same
        BCL_Assert( seq_id_a != seq_id_b, "seq ids are the same");

        // set the residues
        m_PreviousResidue = seq_id_a < seq_id_b ? RESIDUE_A : RESIDUE_B;
        m_FollowingResidue = m_PreviousResidue == RESIDUE_A ? RESIDUE_B : RESIDUE_A;

        BCL_Assert( m_PreviousResidue->GetSeqID() < mut_seq_id, "previous residue is not less in sequence");
        BCL_Assert( m_FollowingResidue->GetSeqID() > mut_seq_id, "following residue is not greater in sequence");

      } //< end if both are defined

      // true if RESIDUE_A is defined only
      else if( RESIDUE_A.IsDefined())
      {
        BCL_MessageDbg( "sorting residue a" + RESIDUE_A->GetIdentification());
        // make sure has same chain id as mutation residue
        BCL_Assert( RESIDUE_A->GetChainID() == m_MutationResidue->GetChainID(), "chain ids don't match");

        const int seq_id_a( RESIDUE_A->GetSeqID());

        m_PreviousResidue = seq_id_a < mut_seq_id ? RESIDUE_A : RESIDUE_B;
        m_FollowingResidue = m_PreviousResidue.IsDefined() ? RESIDUE_B : RESIDUE_A;
      }

      // true if RESIDUE_B is defined only
      else if( RESIDUE_B.IsDefined())
      {
        BCL_MessageDbg( "sorting residue b" + RESIDUE_B->GetIdentification());
        // make sure has same chain id as mutation residue
        BCL_Assert( RESIDUE_B->GetChainID() == m_MutationResidue->GetChainID(), "chain ids don't match");

        const int seq_id_b( RESIDUE_B->GetSeqID());

        m_PreviousResidue = seq_id_b < mut_seq_id ? RESIDUE_B : RESIDUE_A;
        m_FollowingResidue = m_PreviousResidue.IsDefined() ? RESIDUE_A : RESIDUE_B;
      }
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_phi_psi_generator_ccd.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_atom.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PhiPsiGeneratorCCD::s_Instance
    (
      GetObjectInstances().AddInstance( new PhiPsiGeneratorCCD())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PhiPsiGeneratorCCD::PhiPsiGeneratorCCD() :
      m_TargetAndMovingPoints(),
      m_RandomNumberGenerator( random::GetGlobalRandom()),
      m_Direction( biol::AASequenceFlexibility::e_CTerminal),
      m_RandomFraction( 1.0, 1.0)
    {
    }

    //! @brief constructor taking member variable parameters
    //! @param TARGET_AND_MOVING_POINTS the list of target and moving points whose distances will be minimized
    //! @param RANDOM_NUMBER_GENERATOR the random number generator that should be used
    //! @param DIRECTION indicates if the rotation needs to occur in the C to N direction
    //! @param RANDOM_FRACTION_RANGE range a random fraction is drawn from and multiplied with suggested rotation
    PhiPsiGeneratorCCD::PhiPsiGeneratorCCD
    (
      const storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair> &TARGET_AND_MOVING_POINTS,
      const random::DistributionInterface &RANDOM_NUMBER_GENERATOR,
      const biol::AASequenceFlexibility::SequenceDirection &DIRECTION,
      const math::Range< double> &RANDOM_FRACTION_RANGE
    ) :
      m_TargetAndMovingPoints( TARGET_AND_MOVING_POINTS),
      m_RandomNumberGenerator( RANDOM_NUMBER_GENERATOR),
      m_Direction( DIRECTION),
      m_RandomFraction( RANDOM_FRACTION_RANGE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new PhiPsiGeneratorCCD
    PhiPsiGeneratorCCD *PhiPsiGeneratorCCD::Clone() const
    {
      return new PhiPsiGeneratorCCD( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &PhiPsiGeneratorCCD::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator taking MutationResidue and returning storage::VectorND< 2, double> with phi psi, respectively
    //! @param MUTATION_RESIDUE MutationResidue whose phi or psi will be changed
    //! @return phi or psi value, respectively, which will minimize the distance between target and moving points.
    //!         the other value will be undefined
    storage::VectorND< 2, double> PhiPsiGeneratorCCD::operator()( const MutationResidue &MUTATION_RESIDUE) const
    {
      // result initialized as undefined
      storage::VectorND< 2, double> phi_psi( util::GetUndefined< double>(), util::GetUndefined< double>());

      // get a random boolean indicating whether to rotate around phi or psi
      // "rotate_phi" is true  if rotation around phi will occur
      // "rotate_phi" is false if rotation around psi will occur
      const bool rotate_phi( m_RandomNumberGenerator.Boolean());

      // message if rotation around phi will occur or not
      BCL_MessageDbg( "rotate phi is " + util::Format()( rotate_phi));

      // create a CyclicCoordinateDescent which will be used to do the ccd calculation
      const coord::CyclicCoordinateDescent ccd;

      // define the rotation axis depending on whether phi or psi is being rotated around
      // also calculate the current value of whichever dihedral angle is being changed
      coord::LineSegment3D rotation_axis;
      double current_dihedral_angle;

      // true if rotation around phi will occur
      if( rotate_phi)
      {
        // set the origin and end-point of the rotation axis
        rotation_axis.SetStartPoint
        (
          MUTATION_RESIDUE.GetMutationResidue()->GetCA().GetCoordinates()
        );
        rotation_axis.SetEndPoint( MUTATION_RESIDUE.GetMutationResidue()->GetAtom( biol::GetAtomTypes().N).GetCoordinates());

        // calculate phi and set "current_dihedral_angle" to it
        current_dihedral_angle = MUTATION_RESIDUE.GetMutationResidue()->Phi();

        // does amino acid have internal phi
        if( !util::IsDefined( current_dihedral_angle))
        {
          // if it does not have internal phi, previous aa is required
          if( !MUTATION_RESIDUE.GetPreviousResidue().IsDefined())
          {
            return phi_psi;
          }
          current_dihedral_angle = MUTATION_RESIDUE.GetMutationResidue()->CalculatePhi
          (
            MUTATION_RESIDUE.GetPreviousResidue()->GetAtom( biol::GetAtomTypes().C)
          );
        }
      }
      else // rotation around psi will occur
      {
        // set the origin and end-point of the rotation axis
        rotation_axis.SetStartPoint( MUTATION_RESIDUE.GetMutationResidue()->GetAtom( biol::GetAtomTypes().C).GetCoordinates());
        rotation_axis.SetEndPoint
        (
          MUTATION_RESIDUE.GetMutationResidue()->GetCA().GetCoordinates()
        );

        // calculate psi and set "current_dihedral_angle" to it
        current_dihedral_angle = MUTATION_RESIDUE.GetMutationResidue()->Psi();

        // does amino acid have internal psi
        if( !util::IsDefined( current_dihedral_angle))
        {
          // if it does not have internal phi, following aa is required
          if( !MUTATION_RESIDUE.GetFollowingResidue().IsDefined())
          {
            return phi_psi;
          }
          current_dihedral_angle = MUTATION_RESIDUE.GetMutationResidue()->CalculatePsi
          (
            MUTATION_RESIDUE.GetFollowingResidue()->GetAtom( biol::GetAtomTypes().N)
          );
        }
      }

      // dihedral could not be determined
      if( !util::IsDefined( current_dihedral_angle))
      {
        return phi_psi;
      }

      // invert the rotation axis, if direction is c terminal
      if( m_Direction == biol::AASequenceFlexibility::e_CTerminal)
      {
        rotation_axis = rotation_axis.GetReverse();
      }

      // message how many target and moving points are left for the ccd calculation
      BCL_MessageDbg
      (
        "number of points being used is " + util::Format()( m_TargetAndMovingPoints.GetSize())
      );

//        // calculate the starting distance so that it can be output and checked against to make sure the ccd is working
//        // i.e. the ending sum distance should be less than this starting distance
//        double starting_sum_distance( fold::LocatorLoopDomain::CalculateDistanceSum( m_TargetAndMovingPoints));
//
//        // message the starting distance
//        BCL_MessageDbg( "starting sum difference is " + util::Format()( starting_sum_distance));
//
//        // message the starting dihedral angle
//        BCL_MessageDbg( "current dihedral angle is " + util::Format()( current_dihedral_angle));

      // calculate optimal rotation to minimize distance and put the results in
      const coord::CyclicCoordinateDescent::ResultsAndCoefficients rotation_result
      (
        ccd.GetOptimalRotationandDistance( rotation_axis, m_TargetAndMovingPoints)
      );

      // get the optimal rotation value from "rotation_result"
      const double optimal_rotation( rotation_result.GetOptimalRotation());

      // message the optimal rotation
      BCL_MessageDbg( "optimal rotation is " + util::Format()( optimal_rotation));

      // get a random number between 0 and 1 which will be used as the fraction of optimal rotation
      const double random_number( m_RandomNumberGenerator.Random( m_RandomFraction));

      // message the random fraction
      BCL_MessageDbg( "random fraction is " + util::Format()( random_number));

      // use "optimal_rotation" and "random_number" to determine the rotation that will be used
      double rotation( optimal_rotation * random_number);

      // message the effective rotation
      BCL_MessageDbg( "effective rotation will be " + util::Format()( rotation));

//        // calculate how far away from the target the moving points will be after "rotation"
//        const double distance_difference_sum
//        (
//          ccd.CalculateDistanceSum
//          (
//            rotation,
//            rotation_result.GetCoefficientA(), rotation_result.GetCoefficientB(), rotation_result.GetCoefficientC()
//          )
//        );
//
//        // message the resulting distance sum
//        BCL_MessageDbg( "resulting sum difference is " + util::Format()( distance_difference_sum));
//
//        // make sure that the resulting distance sum is less or equal within tolerance to the starting distance sum
//        BCL_Assert
//        (
//          starting_sum_distance > distance_difference_sum ||
//          math::EqualWithinTolerance( starting_sum_distance, distance_difference_sum),
//          "starting distance is " + util::Format()( starting_sum_distance) +
//          " while ending distance sum would be " + util::Format()( distance_difference_sum)
//        );

      // calculate what the dihedral angle needs to be. Negate rotation so that it happens in the correct direction
      const double new_dihedral_angle( current_dihedral_angle - rotation);

      // message what the new dihedral angle will be
      BCL_MessageDbg( "new dihedral angle will be " + util::Format()( new_dihedral_angle));

      // put the "new_dihedral_angle" into the correct place in vectorND "phi_psi"
      // "new_dihedral_angle" will be first if phi was rotated around, otherwise "new_dihedral_angle" will be second
      if( rotate_phi) //< rotated around phi
      {
        // set phi to "new_dihedral_angle"
        phi_psi.First() = new_dihedral_angle;
      }
      else //< rotated around psi
      {
        // set psi as "new_dihedral_angle"
        phi_psi.Second() = new_dihedral_angle;
      }

      // return the phi and psi values
      return phi_psi;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PhiPsiGeneratorCCD::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_TargetAndMovingPoints, ISTREAM);
      io::Serialize::Read( m_Direction, ISTREAM);
      io::Serialize::Read( m_RandomFraction, ISTREAM);

      // return "ISTREAM"
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &PhiPsiGeneratorCCD::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_TargetAndMovingPoints, OSTREAM, INDENT);
      io::Serialize::Write( m_Direction, OSTREAM, INDENT);
      io::Serialize::Write( m_RandomFraction, OSTREAM, INDENT);

      // return "OSTREAM"
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_phi_psi_generator_ramachandran.h"

// includes from bcl - sorted alphabetically
#include "fold/bcl_fold_mutation_residue.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PhiPsiGeneratorRamachandran::s_Instance
    (
      util::Enumerated< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > >::AddInstance
      (
        new PhiPsiGeneratorRamachandran()
      )
    );

    //! @brief get default instance
    //! @return default instance behind a pointer
    const math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > &
    PhiPsiGeneratorRamachandran::GetDefaultInstance()
    {
      // initialize static instance
      static const PhiPsiGeneratorRamachandran s_instance( biol::Ramachandran::GetDefaultInstance());

      // end
      return s_instance;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PhiPsiGeneratorRamachandran::PhiPsiGeneratorRamachandran() :
      m_Ramachandran( biol::Ramachandran())
    {
    }

    //! @brief constructor from a ramachandran object
    //! @param RAMACHANDRAN instance of Ramachandran to be used
    PhiPsiGeneratorRamachandran::PhiPsiGeneratorRamachandran( const biol::Ramachandran &RAMACHANDRAN) :
       m_Ramachandran( RAMACHANDRAN)
    {
    }

    //! @brief Clone function
    //! @return pointer to new PhiPsiGeneratorRamachandran
    PhiPsiGeneratorRamachandran *PhiPsiGeneratorRamachandran::Clone() const
    {
      return new PhiPsiGeneratorRamachandran( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &PhiPsiGeneratorRamachandran::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &PhiPsiGeneratorRamachandran::GetAlias() const
    {
      static const std::string s_alias( "PhiPsiGeneratorRamachandran");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer PhiPsiGeneratorRamachandran::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Generate random pairs of phi psi angles.");
      serializer.AddInitializer
      (
        "distribution",
        "phi psi distribution from which to generate the angles",
        io::Serialization::GetAgent( &m_Ramachandran),
        "Ramachandran"
      );

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator taking MutationResidue and returning storage::VectorND< 2, double> with phi psi, respectively
    //! @param RESIDUE MutationResidue whose phi or psi will be changed
    //! @return phi or psi value, respectively, randomly selected based on a ramachandran distribution
    storage::VectorND< 2, double> PhiPsiGeneratorRamachandran::operator()( const MutationResidue &RESIDUE) const
    {
      BCL_Assert( RESIDUE.GetMutationResidue().IsDefined(), "mutation residue is not defined");
      // get random phi and psi
      const storage::VectorND< 2, double> random_phi_psi
      (
        m_Ramachandran->GetRandomPhiPsi( RESIDUE.GetMutationResidue()->GetType())
      );

      // return "random_phi_psi"
      return random_phi_psi;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_placement_domain.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> PlacementDomain::s_Instance
    (
      GetObjectInstances().AddInstance( new PlacementDomain())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PlacementDomain::PlacementDomain()
    {
    }

    //! @brief returns a pointer to a new PlacementDomain
    //! @return pointer to a new PlacementDomain
    PlacementDomain *PlacementDomain::Clone() const
    {
      return new PlacementDomain( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &PlacementDomain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief computes a transformation matrix for the placement of the given domain in the given protein model
    //! @param SELECTED_DOMAIN domain which shall be placed in the protein model
    //! @param PROTEIN_MODEL protein model in which the domain shall be placed
    //! @return the matrix defining the transformation to be applied on the given domain to place it in the given
    //! protein model and a boolean value indicating if the computation of the transformation matrix was successful
    storage::Pair< math::TransformationMatrix3D, bool> PlacementDomain::Place
    (
      const assemble::Domain &SELECTED_DOMAIN,
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // holds the SSE in which neighborhood to place the domain
      util::SiPtr< const assemble::SSE> p_neighbor_sse;

      // find the SSE in the model with the smallest sequence distance to the domain TODO
      util::SiPtrVector< const assemble::SSE> tmp( PROTEIN_MODEL.GetSSEs());
      util::SiPtrList< const assemble::SSE> sses_in_model( tmp.Begin(), tmp.End());

      // if no suitable SSE could be found pick a random SSE
      if( !p_neighbor_sse.IsDefined())
      {
        p_neighbor_sse = assemble::PickSSERandom().Pick( sses_in_model);
      }

      // compute the transformation matrix for the starting from the orientation of the selected SSE
      math::TransformationMatrix3D transformation;
      if( p_neighbor_sse.IsDefined())
      {
        transformation( p_neighbor_sse->GetOrientation());
      }

      // add random transformations TODO add randomized flipping etc
      const random::DistributionInterface &random( random::GetGlobalRandom());
      transformation
      (
        random.Random< double>( 0.0, 10.0), random.Random< double>( 0.0, 10.0), random.Random< double>( 0.0, 10.0)
      );

      return storage::Pair< math::TransformationMatrix3D, bool>( transformation, true);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read object from input stream
    //! @param ISTREAM input stream to read object from
    //! @return input stream which was read from
    std::istream &PlacementDomain::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write object into  output stream
    //! @param OSTREAM output stream to write object into
    //! @param INDENT number of indentations to separate members
    //! @return output stream object was written into
    std::ostream &PlacementDomain::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_placement_domain_using_fold_template.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_fold_template.h"
#include "assemble/bcl_assemble_fold_template_handler.h"
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> PlacementDomainUsingFoldTemplate::s_Instance
    (
      GetObjectInstances().AddInstance( new PlacementDomainUsingFoldTemplate())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor with body deviations
    //! @param BODY_DEVIATION positive values get a larger template, and negative values exclude SSEs
    PlacementDomainUsingFoldTemplate::PlacementDomainUsingFoldTemplate
    (
      const int &BODY_DEVIATION
    ) :
      m_BodyDeviation( BODY_DEVIATION)
    {
    }

    //! @brief Clone function
    //! @return pointer to new PlacementDomainUsingFoldTemplate
    PlacementDomainUsingFoldTemplate *PlacementDomainUsingFoldTemplate::Clone() const
    {
      return new PlacementDomainUsingFoldTemplate( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &PlacementDomainUsingFoldTemplate::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief determines transformation matrices for placing SSEs from a Domain into a protein model
    //! @param DOMAIN_TO_PLACE domain containing SSEs to be placed
    //! @param PROTEIN_MODEL model that domain will be placed into
    //! @return transformation matrices for placing SSEs from a Domain into a protein model
    storage::Pair< storage::Map< util::SiPtr< const assemble::SSE>, math::TransformationMatrix3D>, bool>
    PlacementDomainUsingFoldTemplate::Place
    (
      const assemble::DomainInterface &DOMAIN_TO_PLACE, const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      return Place( DOMAIN_TO_PLACE);
    }

    //! @brief determines transformation matrices for placing SSEs from a Domain into a protein model
    //! @param DOMAIN_TO_PLACE domain containing SSEs to be placed
    //! @return transformation matrices for placing SSEs from a Domain into a protein model
    storage::Pair< storage::Map< util::SiPtr< const assemble::SSE>, math::TransformationMatrix3D>, bool>
    PlacementDomainUsingFoldTemplate::Place
    (
      const assemble::DomainInterface &DOMAIN_TO_PLACE
    ) const
    {
      // initialize map
      storage::Map< util::SiPtr< const assemble::SSE>, math::TransformationMatrix3D> matrices;

      // copy SSEs
      util::SiPtrVector< const assemble::SSE> helices( DOMAIN_TO_PLACE.GetSSEs( biol::GetSSTypes().HELIX));
      util::SiPtrVector< const assemble::SSE> strands( DOMAIN_TO_PLACE.GetSSEs( biol::GetSSTypes().STRAND));

      // return empty vector if domain is empty
      if( helices.GetSize() == 0 && strands.GetSize() == 0)
      {
        BCL_MessageStd( "No SSEs in domain to place into a fold template");
        return storage::Pair< storage::Map< util::SiPtr< const assemble::SSE>, math::TransformationMatrix3D>, bool>
        (
          matrices, false
        );
      }

      // if sses should be excluded
      if( m_BodyDeviation < 0)
      {
        const size_t sses_to_exclude( -m_BodyDeviation);

        // warn the user and break if the number of sses to exclude is greater than or equal to the number of total sses
        if( sses_to_exclude >= helices.GetSize() + strands.GetSize())
        {
          BCL_MessageStd
          (
            "The number of SSEs to exclude from the fold template placement"
            " is larger than or equal to the total number of SSEs."
          );
          return storage::Pair< storage::Map< util::SiPtr< const assemble::SSE>, math::TransformationMatrix3D>, bool>
          (
            matrices, false
          );
        }

        // iterate through the SSEs to exclude
        for( size_t i( 0); i != sses_to_exclude; ++i)
        {
          // decide whether to remove helix or strand
          bool remove_helix( random::GetGlobalRandom().Boolean());

          // true if remove helix was chosen
          if( remove_helix)
          {
            // if there are no helical elements to remove, remove a strand instead
            if( helices.GetSize() == 0)
            {
              remove_helix = false;
            }
          }
          // otherwise a strand was chosen
          else
          {
            // if there are no strand elements to remove, remove a helix instead
            if( strands.GetSize() == 0)
            {
              remove_helix = true;
            }
          }

          // true if a helix is to be removed
          if( remove_helix)
          {
            // remove a random helical element
            helices.RemoveRandomElement();
            }
          // otherwise remove a strand
          else
          {
            // remove a random strand element
            strands.RemoveRandomElement();
          }
        }
      }

      // sort the SSEs by size
      std::sort( helices.Begin(), helices.End(), assemble::SSELessThanBySize());
      std::sort( strands.Begin(), strands.End(), assemble::SSELessThanBySize());

      // determine the number of helices and strands in the fold template
      storage::Pair< size_t, size_t> number_of_sses( helices.GetSize(), strands.GetSize());
      size_t added_helices( 0);
      size_t added_strands( 0);

      // if a larger template is requested
      if( m_BodyDeviation > 0)
      {
        // iterate through the sses to add
        for( int i( 0); i != m_BodyDeviation; ++i)
        {
          // decide whether to add a helix or strand
          const bool add_helix( random::GetGlobalRandom().Boolean());

          // increment proper sse
          add_helix ? ++added_helices : ++added_strands;
        }
      }

      // update the sse count
      number_of_sses.First() += added_helices;
      number_of_sses.Second() += added_strands;

      // store random fold template from the probability distribution
      assemble::FoldTemplate fold_template
      (
        assemble::FoldTemplateHandler::GetRandomTemplate( number_of_sses.First(), number_of_sses.Second())
      );
      BCL_MessageDbg( "Fold template generated from PDB: " + fold_template.GetPDBID());

      // calculate the topology
      fold_template.CalculateTopology();

      // if a larger template was requested
      if( m_BodyDeviation > 0)
      {
        // get a subdomain from the template
        fold_template =
          fold_template.GetSubDomain( number_of_sses.First() - added_helices, number_of_sses.Second() - added_strands);
      }

      // get the helical and strand geometries
      util::SiPtrVector< const assemble::SSEGeometryPhiPsi> helical_geometries( fold_template.GetHelicalGeometries());
      util::SiPtrVector< const assemble::SSEGeometryPhiPsi> strand_geometries( fold_template.GetStrandGeometries());
      // create iterators on the geometries in the template
      util::SiPtrVector< const assemble::SSEGeometryPhiPsi>::const_iterator helix_geometry_itr( helical_geometries.Begin());
      const util::SiPtrVector< const assemble::SSEGeometryPhiPsi>::const_iterator helix_geometry_itr_end( helical_geometries.End());
      util::SiPtrVector< const assemble::SSEGeometryPhiPsi>::const_iterator strand_geometry_itr( strand_geometries.Begin());
      const util::SiPtrVector< const assemble::SSEGeometryPhiPsi>::const_iterator strand_geometry_itr_end( strand_geometries.End());

      // iterate through the helices
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          helix_itr( helices.Begin()), helix_itr_end( helices.End());
        helix_itr != helix_itr_end && helix_geometry_itr != helix_geometry_itr_end;
        ++helix_itr, ++helix_geometry_itr
      )
      {
        // create transformation matrix and move to new position
        math::TransformationMatrix3D transform( math::Inverse( ( *helix_itr)->GetOrientation()));
        transform( ( *helix_geometry_itr)->GetOrientation());

        //insert into map
        matrices[ *helix_itr] = transform;
      }

      // iterate through the strands
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator
          strand_itr( strands.Begin()), strand_itr_end( strands.End());
        strand_itr != strand_itr_end && strand_geometry_itr != strand_geometry_itr_end;
        ++strand_itr, ++strand_geometry_itr
      )
      {
        // create transformation matrix and move to new position
        math::TransformationMatrix3D transform( math::Inverse( ( *strand_itr)->GetOrientation()));
        transform( ( *strand_geometry_itr)->GetOrientation());

        //insert into map
        matrices[ *strand_itr] = transform;
      }

      // return the transformation matrices
      return storage::Pair< storage::Map< util::SiPtr< const assemble::SSE>, math::TransformationMatrix3D>, bool>
      (
        matrices, true
      );
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PlacementDomainUsingFoldTemplate::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_BodyDeviation, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &PlacementDomainUsingFoldTemplate::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_BodyDeviation, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_placement_sse_distance_restraint.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "fold/bcl_fold_placement_sse_next_to_sse.h"
#include "restraint/bcl_restraint_atom_distance.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PlacementSSEDistanceRestraint::s_Instance
    (
      GetObjectInstances().AddInstance( new PlacementSSEDistanceRestraint())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PlacementSSEDistanceRestraint::PlacementSSEDistanceRestraint()
    {
    }

    //! @brief construct from restraints
    //! @param RESTRAINTS restraints to be used
    PlacementSSEDistanceRestraint::PlacementSSEDistanceRestraint
    (
      const util::ShPtr< util::ShPtrVector< restraint::AtomDistance> > &RESTRAINTS
    ) :
      m_Restraints( RESTRAINTS)
    {
    }

    //! @brief Clone function
    //! @return pointer to new PlacementSSENOE
    PlacementSSEDistanceRestraint *PlacementSSEDistanceRestraint::Clone() const
    {
      return new PlacementSSEDistanceRestraint( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PlacementSSEDistanceRestraint::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief generate placement for the given SSE at a random orientation wrt to a located SSE from the given model
    //! @param SELECTED_SSE SiPtr to SSE to be placed
    //! @param PROTEIN_MODEL to which the SSE is going to be added
    storage::Pair< math::TransformationMatrix3D, bool> PlacementSSEDistanceRestraint::Place
    (
      const assemble::SSE &SELECTED_SSE,
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      static const math::TransformationMatrix3D s_def_transformation;

      // if no restraints were found
      if( !m_Restraints.IsDefined() || m_Restraints->IsEmpty())
      {
        return storage::Pair< math::TransformationMatrix3D, bool>( s_def_transformation, false);
      }

      // get the protein model sses
      const util::SiPtrVector< const assemble::SSE> model_sses( PROTEIN_MODEL.GetSSEs());

      // if the model is empty
      if( model_sses.IsEmpty())
      {
        // place the sse at the origin
        return storage::Pair< math::TransformationMatrix3D, bool>( s_def_transformation, true);
      }

      // create map to hold # restraints between SSEs
      storage::Map< util::SiPtr< const assemble::SSE>, size_t> restraint_map;

      // iterate over the SSEs
      size_t number_restraints( 0);
      for
      (
        util::SiPtrVector< const assemble::SSE>::const_iterator sse_itr( model_sses.Begin()),
          sse_itr_end( model_sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // iterate through the restraints and track the total number
        for
        (
          util::ShPtrVector< restraint::AtomDistance>::const_iterator restraint_itr( m_Restraints->Begin()),
            restraint_itr_end( m_Restraints->End());
          restraint_itr != restraint_itr_end; ++restraint_itr
        )
        {
          // if the restraint is between the SSEs
          if( ContainsRestraint( SELECTED_SSE, **sse_itr, **restraint_itr))
          {
            ++number_restraints;
            // if the SSE is in the map
            if( restraint_map.Has( *sse_itr))
            {
              // increment the count
              ++restraint_map[ *sse_itr];
            }
            // the SSE is not in the map
            else
            {
              // set the count to 1
              restraint_map[ *sse_itr] = 1;
            }
          }
        }
      }

      // randomly select an SSE weighted by its number of restraints
      int weight_index( random::GetGlobalRandom().Random< int>( 0, number_restraints));

      // iterate over the map
      util::SiPtr< const assemble::SSE> sp_random_sse;
      for
      (
        storage::Map< util::SiPtr< const assemble::SSE>, size_t>::const_iterator map_itr( restraint_map.Begin()),
          map_itr_end( restraint_map.End());
         map_itr != map_itr_end; ++map_itr
      )
      {
        weight_index -= map_itr->second;
        if( weight_index <= 0)
        {
          sp_random_sse = map_itr->first;
        }
      }

      // return a placement using PlacementSSENextToSSE
      return PlacementSSENextToSSE::Place( SELECTED_SSE, *sp_random_sse);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PlacementSSEDistanceRestraint::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &PlacementSSEDistanceRestraint::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief checks if the restraint is between 2 SSEs
    //! @param SSE_A first SSE
    //! @param SSE_B second SSE
    //! @param RESTRAINT distance restraint
    //! @return whether the restraint is between 2 SSEs
    bool PlacementSSEDistanceRestraint::ContainsRestraint
    (
      const assemble::SSE &SSE_A,
      const assemble::SSE &SSE_B,
      const restraint::AtomDistance &RESTRAINT
    )
    {
      return
        (
          HasResidue( SSE_A, RESTRAINT.GetData().First()) &&
          HasResidue( SSE_B, RESTRAINT.GetData().Second())
        ) ||
        (
          HasResidue( SSE_B, RESTRAINT.GetData().First()) &&
          HasResidue( SSE_A, RESTRAINT.GetData().Second())
        );
    }

    //! @brief checks if the SSE has the residue in the locator
    //! @param SELECTED_SSE SSE to be checked
    //! @param LOCATOR locator from the restraint
    //! @return whether the SSE has the residue in the locator
    bool PlacementSSEDistanceRestraint::HasResidue
    (
      const assemble::SSE &SELECTED_SSE,
      const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR
    )
    {
      // if the chain id doesn't match
      if( !LOCATOR.IsDefined() || SELECTED_SSE.GetChainID() != LOCATOR->GetChainID() || SELECTED_SSE.GetSize() == 0)
      {
        return false;
      }

      // construct a range
      const math::Range< int> seq_id_range
      (
        SELECTED_SSE.GetFirstAA()->GetSeqID(), SELECTED_SSE.GetLastAA()->GetSeqID()
      );

      // return whether the seq id is in the range
      return seq_id_range.IsWithin( LOCATOR->GetSeqID());
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_placement_sse_into_body.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "find/bcl_find_pick_criteria_interface.h"
#include "restraint/bcl_restraint_body.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> PlacementSSEIntoBody::s_Instance
    (
      GetObjectInstances().AddInstance( new PlacementSSEIntoBody())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PlacementSSEIntoBody::PlacementSSEIntoBody() :
      m_BodyRestraint(),
      m_BodyPicker(),
      m_Orientation()
    {
    }

    //! @brief construct from the three member types
    //! @param RESTRAINT ShPtr to a restraint::Body which will be "m_BodyRestraint"
    //! @param BODY_PICKER ShPtr to a PickCriteriaInterface which will be "m_BodyPicker"
    //! @param ORIENTATION ShPtr to a FunctionInterface which will be "m_Orientation"
    PlacementSSEIntoBody::PlacementSSEIntoBody
    (
      const util::ShPtr< restraint::Body> &RESTRAINT,
      const util::ShPtr
      <
        find::PickCriteriaInterface< util::ShPtr< assemble::SSEGeometryInterface>, util::ShPtrVector< assemble::SSEGeometryInterface>, assemble::SSEGeometryInterface>
      > &BODY_PICKER,
      util::ShPtr< math::MutateInterface< math::TransformationMatrix3D> > &ORIENTATION
    ) :
      m_BodyRestraint( RESTRAINT),
      m_BodyPicker( BODY_PICKER),
      m_Orientation( ORIENTATION)
    {
    }

    //! @brief virtual copy constructor
    PlacementSSEIntoBody *PlacementSSEIntoBody::Clone() const
    {
      return new PlacementSSEIntoBody( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PlacementSSEIntoBody::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetBodyRestraint returns a const reference to "m_BodyRestraint"
    //! @return returns a const reference to "m_BodyRestraint"
    const util::ShPtr< restraint::Body> &PlacementSSEIntoBody::GetBodyRestraint() const
    {
      return m_BodyRestraint;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Place returns transformatin matrix for the placement of an SSE into a ProteinModel
    //! @param SSE SSE which is to be placed
    //! @param PROTEIN_MODEL into which the SSE will be placed
    //! @return the transformationmatrix3d to place SSE in PROTEIN_MODEL
    storage::Pair< math::TransformationMatrix3D, bool> PlacementSSEIntoBody::Place
    (
      const assemble::SSE &SSE,
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // make sure that "m_BodyPicker" is defined
      BCL_Assert( m_BodyPicker.IsDefined(), "m_BodyPicker ShPtr is not defined");

      // return storage::Pair given by DetermineTransformatinMatrix3DandBool given a body picked by "m_BodyPicker"
      // out of the bodies that are not occupied by an of the SSEs in "PROTEIN_MODEL"
      return DetermineTransformatinMatrix3DandBool
      (
        m_BodyPicker->Pick( m_BodyRestraint->GetUnoccupied( PROTEIN_MODEL.GetSSEs()), SSE)
      );
    }

    //! returns placement for the t_ObjectType without taking ProteinModel into consideration i.e. if it is empty
    //! @param SSE SSE which is to be placed
    //! @return the transformationmatrix3d to place SSE in PROTEIN_MODEL
    storage::Pair< math::TransformationMatrix3D, bool> PlacementSSEIntoBody::Place
    (
      const assemble::SSE &SSE
    ) const
    {
      // make sure that "m_BodyPicker" is defined
      BCL_Assert( m_BodyPicker.IsDefined(), "m_BodyPicker ShPtr is not defined");

      // return storage::Pair given by DetermineTransformatinMatrix3DandBool given a body picked by "m_BodyPicker"
      // and "SSE"
      return DetermineTransformatinMatrix3DandBool( m_BodyPicker->Pick( *m_BodyRestraint->GetBody(), SSE));
    }

    //! @brief DetermineTransformationMatrix3DandBool figures out what the transformation matrix and bool should be
    //! @param RESTRAINT_BODY that was chosen to be the body into which the SSE will be placed
    //! @return the transformationmatrix3d to place SSE in PROTEIN_MODEL and a bool whether successful or not
    storage::Pair< math::TransformationMatrix3D, bool> PlacementSSEIntoBody::DetermineTransformatinMatrix3DandBool
    (
      const util::ShPtr< assemble::SSEGeometryInterface> &RESTRAINT_BODY
    ) const
    {
      // true if "RESTRAINT_BODY" is not defined meaning no "assemble::SSEGeometryInterface" could be picked by "m_BodyRestraint"
      if( !RESTRAINT_BODY.IsDefined())
      {
        // write message
        BCL_MessageDbg( "RESTRAINT_BODY is not defined\n");

        // no "assemble::SSEGeometryInterface" could be picked by "m_BodyRestraint" so return empty math::TransformationMatrix3D()
        // and a boolean of false
        return storage::Pair< math::TransformationMatrix3D, bool>( math::TransformationMatrix3D(), false);
      }
      else //< "RESTRAINT_BODY" is defined so there is a restraint body to be placed into
      {
        // write message
        BCL_MessageDbg
        (
          "RESTRAINT_BODY is defined\n"
        );

        // output body extents of the "RESTRAINT_BODY"
        BCL_MessageDbg
        (
          "body is defined with main axis: \n " +
          util::Format()( RESTRAINT_BODY->GetMainAxis())
        );

        // create storage::Pair "result_pair" and initialize with TransformationMatrix3D for putting an SSE into the
        // restraint body and true bool
        storage::Pair< math::TransformationMatrix3D, bool> result_pair
        (
          // the TransformationMatrix3D is determined by "m_Orientation" according to "RESTRAINT_BODY"
          math::TransformationMatrix3D( *m_Orientation->operator()( RESTRAINT_BODY->GetOrientation()).GetArgument()),
          true
        );

        // end
        return result_pair;
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PlacementSSEIntoBody::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_BodyRestraint, ISTREAM);
      io::Serialize::Read( m_BodyPicker, ISTREAM);
      io::Serialize::Read( m_Orientation, ISTREAM);

      return ISTREAM;
    }

    //! @brief read from std::ostream
    //! @param OSTREAM input stream
    //! @return ostream which was read from
    std::ostream &PlacementSSEIntoBody::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // read members
      io::Serialize::Write( m_BodyRestraint, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_BodyPicker, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Orientation, OSTREAM, INDENT);

      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_placement_sse_next_to_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "contact/bcl_contact_types.h"
#include "find/bcl_find_locator_criteria_interface.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> PlacementSSENextToSSE::s_Instance
    (
      util::Enumerated< PlacementInterface< assemble::SSE, assemble::ProteinModel> >::AddInstance( new PlacementSSENextToSSE())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PlacementSSENextToSSE::PlacementSSENextToSSE() :
      m_NeighborSSELocator()
    {
    }

    //! @brief constructor from a LocatorCriteriaInterface
    //! @param LOCATOR_CRITERIA LocatorCriteriaInterface to be used
    PlacementSSENextToSSE::PlacementSSENextToSSE
    (
      const find::LocatorCriteriaInterface
      <
        util::SiPtr< const assemble::SSE>,
        assemble::DomainInterface,
        assemble::SSE
      > &LOCATOR_CRITERIA
    ) :
      m_NeighborSSELocator( LOCATOR_CRITERIA.Clone())
    {
    }

    //! @brief constructor from a ShPtr to LocatorCriteriaInterface
    //! @param SP_LOCATOR_CRITERIA ShPtr to LocatorCriteriaInterface to be used
    PlacementSSENextToSSE::PlacementSSENextToSSE
    (
      const util::ShPtr
      <
        find::LocatorCriteriaInterface
        <
          util::SiPtr< const assemble::SSE>,
          assemble::DomainInterface,
          assemble::SSE
        >
      > &SP_LOCATOR_CRITERIA
    ) :
      m_NeighborSSELocator( *SP_LOCATOR_CRITERIA)
    {
    }

    //! @brief Clone function
    //! @return pointer to new PlacementSSENextToSSE
    PlacementSSENextToSSE *PlacementSSENextToSSE::Clone() const
    {
      return new PlacementSSENextToSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PlacementSSENextToSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &PlacementSSENextToSSE::GetAlias() const
    {
      static const std::string s_alias( "PlacementSSENextToSSE");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer PlacementSSENextToSSE::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Places an SSE next to other SSEs in a protein model.");
      serializer.AddInitializer
      (
        "locator",
        "locator for neighboring SSEs",
        io::Serialization::GetAgent( &m_NeighborSSELocator)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief generate placement for the given SSE at a random orientation wrt to a located SSE from the given model
    //! @param SELECTED_SSE SiPtr to SSE to be placed, it needs to be in the origin
    //! @param PROTEIN_MODEL to which the SSE is going to be added
    storage::Pair< math::TransformationMatrix3D, bool> PlacementSSENextToSSE::Place
    (
      const assemble::SSE &SELECTED_SSE,
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize neighbor_sse
      util::SiPtr< const assemble::SSE> neighbor_sse;

      // if there is only one sse in the model set it to neighbor_sse
      if( PROTEIN_MODEL.GetSSEs().GetSize() == 1)
      {
        neighbor_sse = PROTEIN_MODEL.GetSSEs().FirstElement();
      }
      // else if more than one SSE
      else
      {
        // locate the neighbor sse using m_NeighborSSELocator
        neighbor_sse = m_NeighborSSELocator->Locate( PROTEIN_MODEL, SELECTED_SSE);
      }

      // if the neighbor sse is empty
      if( !neighbor_sse.IsDefined())
      {
        // give a warning and return
        BCL_MessageCrt( "No neighbor sses are located!");
        return storage::Pair< math::TransformationMatrix3D, bool>( math::TransformationMatrix3D(), false);
      }

      BCL_MessageVrb( "neighbor SSE selected: " + neighbor_sse->GetIdentification());

      // calculate the transformation and return
      return Place( SELECTED_SSE, *neighbor_sse);
    }

    //! @brief generate placement for the given SSE at a random orientation wrt to a located SSE from the given model
    //! @param SELECTED_SSE SiPtr to SSE to be placed
    //! @param NEIGHBOR_SSE reference SSE
    storage::Pair< math::TransformationMatrix3D, bool> PlacementSSENextToSSE::Place
    (
      const assemble::SSE &SELECTED_SSE,
      const assemble::SSE &NEIGHBOR_SSE
    )
    {
      // initialize the transformation matrix that will be applied to this sse
      math::TransformationMatrix3D transformation;

      // decide whether to flip
      if( random::GetGlobalRandom().Boolean())
      {
        // apply a flip around a random axis
        transformation( coord::Axis( random::GetGlobalRandom().Random< size_t>( 2)), math::g_Pi);
      }

      // decide positive or negative translation along random_axis
      const int translation_sign( random::GetGlobalRandom().Sign());

      // create the contact type
      contact::Type contact_type( contact::GetTypes().TypeFromSSTypes( SELECTED_SSE, NEIGHBOR_SSE));

      // initialize translation vector and the distance
      linal::Vector3D translation_direction;

      // if helix helix
      if( contact_type == contact::GetTypes().HELIX_HELIX)
      {
        // determine a random angle between -90 and +90
        const double angle( random::GetGlobalRandom().Random< double>( -math::g_Pi / 2.0, math::g_Pi / 2.0));

        // use this angle to determine a random unit vector on xy plane and scale the translation
        translation_direction = linal::Vector3D( cos( angle), sin( angle), 0.0);
      }
      // if the selected_sse is a helix and the neighbor sse is strand
      else if( contact_type == contact::GetTypes().HELIX_SHEET)
      {
        // then we can only use x axis
        translation_direction = linal::Vector3D( 1.0, 0.0, 0.0);
      }
      // if the selected SSE is a strand and the neighbor sse is helix
      else if( contact_type == contact::GetTypes().SHEET_HELIX)
      {
        // determine a random angle between -90 and +90
        const double angle( random::GetGlobalRandom().Random< double>( -math::g_Pi / 2.0, math::g_Pi / 2.0));

        // use this angle to determine a random unit vector on xy plane
        translation_direction = linal::Vector3D( cos( angle), sin( angle), 0.0);

        // we also need a rotation around Z to make sure the strand side chains are facing the helix
        transformation( math::RotationMatrix3D( coord::GetAxes().e_Z, -angle));

      }
      else if( contact_type == contact::GetTypes().STRAND_STRAND)
      {
        // determine randomly to use x (SHEET_SHEET) or y axis( STRAND_STRAND)
        const coord::Axis
            trans_axis( random::GetGlobalRandom().Boolean() ? coord::GetAxes().e_X : coord::GetAxes().e_Y);

        // set the translation direction
        translation_direction( trans_axis) = 1.0;

        // if sheet sheet was selected update the distance and tilt angle
        if( trans_axis == coord::GetAxes().e_X)
        {
          // update contact_type
          contact_type = contact::GetTypes().SHEET_SHEET;
        }
      }
      else
      {
        // if no valid contact type found then return undefined transformation
        BCL_MessageCrt
        (
          "undefined contact type! " + contact_type.GetName() +
          " selected SSE: " + SELECTED_SSE.GetIdentification() +
          " neighbor SSE: " + NEIGHBOR_SSE.GetIdentification()
        );
        return storage::Pair< math::TransformationMatrix3D, bool>( math::TransformationMatrix3D(), false);
      }

      // get a random distance within the range specified by the contact type
      const double distance( random::GetGlobalRandom().Double( contact_type->GetPreferredDistanceRange()));

      // get a random tilt angle within the range allowed by the contact type
      const double tilt_angle( random::GetGlobalRandom().Double( contact_type->GetTiltAngleRange()));

      // decide positive or negative internal translation along z axis
      const int z_translation_sign( random::GetGlobalRandom().Sign());

      // length difference
      const double length_difference( NEIGHBOR_SSE.GetLength() - SELECTED_SSE.GetLength());

      // initialize internal z translation
      linal::Vector3D z_translation
      (
        0.0, 0.0,
        double( z_translation_sign) * random::GetGlobalRandom().Double
        (
          math::Range< double>
          (
            std::min( 0.0, length_difference / 2.0),
            std::max( length_difference / 2.0, 0.0)// half the length difference
          )
        )
      );

      // if not adding a strand
      if( SELECTED_SSE.GetType() != biol::GetSSTypes().STRAND)
      {
        // decide on a internal z rotation
        const double internal_z_rotation( random::GetGlobalRandom().Random< double>( 0.0, 2 * math::g_Pi));

        // rotate around Z
        transformation( math::RotationMatrix3D( coord::GetAxes().e_Z, internal_z_rotation));
      }

      // rotate the transformation by the tilt angle along the translation axis
      transformation( math::RotationMatrix3D( translation_direction, tilt_angle));

      // form the translation vector
      linal::Vector3D translation( translation_direction * distance * translation_sign);

      // now apply the internal z translation
      transformation( z_translation);

      // apply the calculated translation to transformation
      transformation( translation);

      // apply the orientation of neighbor sse to transformation
      transformation( NEIGHBOR_SSE.GetOrientation());

      // return
      return storage::Pair< math::TransformationMatrix3D, bool>( transformation, true);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_placement_sse_short_loop.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "contact/bcl_contact_types.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! minimum loop distance
    const double PlacementSSEShortLoop::s_MinLoopDistance( 2.0);

    //! maxiumum loop distance
    const double PlacementSSEShortLoop::s_MaxLoopDistance( 15.0);

    //! maximum loop distance per residue
    const double PlacementSSEShortLoop::s_MaxDistancePerResidue( 3.04964);

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> PlacementSSEShortLoop::s_Instance
    (
      util::Enumerated< PlacementInterface< assemble::SSE, assemble::ProteinModel> >::AddInstance( new PlacementSSEShortLoop())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PlacementSSEShortLoop::PlacementSSEShortLoop() :
      m_MaxShortLoopLength( 7),
      m_AddToTopProbability( 0.5),
      m_MaxHingeAngleAddingToTop( math::g_Pi / 3.0)
    {
    }

    //! @brief constructor from a maximum short loop length
    //! @param MAX_SHORT_LOOP_LENGTH maximum number of residues between SSEs to be classified as short loop
    //! @param ADD_TO_TOP_PROBABILITY probability that determines how frequently the SSE will be added to the top of the SSE
    //! @param MAX_HINGE_ANGLE_ADDING_TO_TOP max hinge angle to be used when adding to top
    PlacementSSEShortLoop::PlacementSSEShortLoop
    (
      const size_t MAX_SHORT_LOOP_LENGTH,
      const double ADD_TO_TOP_PROBABILITY,
      const double MAX_HINGE_ANGLE_ADDING_TO_TOP
    ) :
      m_MaxShortLoopLength( MAX_SHORT_LOOP_LENGTH),
      m_AddToTopProbability( ADD_TO_TOP_PROBABILITY),
      m_MaxHingeAngleAddingToTop( MAX_HINGE_ANGLE_ADDING_TO_TOP)
    {

    }

    //! @brief Clone function
    //! @return pointer to new PlacementSSEShortLoop
    PlacementSSEShortLoop *PlacementSSEShortLoop::Clone() const
    {
      return new PlacementSSEShortLoop( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PlacementSSEShortLoop::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief generate placement for given SSE at a random orientation wrt to a located SSE in PROTEIN_MODEL
    //! @param SELECTED_SSE SiPtr to SSE to be placed, it needs to be in the origin
    //! @param PROTEIN_MODEL to which the SSE is going to be added
    //! @return the transformationmatrix3d to place the SSE in the PROTEIN_MODEL
    storage::Pair< math::TransformationMatrix3D, bool> PlacementSSEShortLoop::Place
    (
      const assemble::SSE &SELECTED_SSE,
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // store eligible sses that have short loops to SELECTED_SSE
      util::SiPtrList< const assemble::SSE> eligible_sses
      (
        PROTEIN_MODEL.GetSSEsWithShortLoops( SELECTED_SSE, m_MaxShortLoopLength)
      );

      // initialize neighbor_sse
      util::SiPtr< const assemble::SSE> neighbor_sse;

      // if no eligible sses are found
      if( eligible_sses.IsEmpty())
      {
        // message
        BCL_MessageVrb( "No sses with short loops were found!");

        // return false placement
        return storage::Pair< math::TransformationMatrix3D, bool>( math::TransformationMatrix3D(), false);
      }

      // else if there is only one eligible sse
      if( eligible_sses.GetSize() == 1)
      {
        // return that sses transformation
        neighbor_sse = eligible_sses.FirstElement();
      }
      // if more than one pick one
      else
      {
        neighbor_sse = assemble::PickSSERandom().Pick( eligible_sses);
      }

      // if the neighbor sse is empty
      if( !neighbor_sse.IsDefined())
      {
        // give a warning and return
        BCL_MessageCrt( "SSE picked with short loop is undefined!!!");
        return storage::Pair< math::TransformationMatrix3D, bool>( math::TransformationMatrix3D(), false);
      }

      // calculate the placement and return it
      return Place( SELECTED_SSE, *neighbor_sse);
    }

    //! @brief generate placement for given SSE at a random orientation wrt to NEIGHBOR_SSE
    //! @param SELECTED_SSE SiPtr to SSE to be placed
    //! @param NEIGHBOR_SSE neighbor SSE
    //! @return the transformationmatrix3d to place the SSE next to NEIGHBOR_SSE
    storage::Pair< math::TransformationMatrix3D, bool> PlacementSSEShortLoop::Place
    (
      const assemble::SSE &SELECTED_SSE,
      const assemble::SSE &NEIGHBOR_SSE
    ) const
    {
      // if any of the given SSEs are loops then return undefined transformation
      if( !SELECTED_SSE.GetType()->IsStructured() || !NEIGHBOR_SSE.GetType()->IsStructured())
      {
        return storage::Pair< math::TransformationMatrix3D, bool>( math::TransformationMatrix3D(), false);
      }

      // create the contact type
      contact::Type contact_type( contact::GetTypes().TypeFromSSTypes( SELECTED_SSE, NEIGHBOR_SSE));

      // determine if selected_sse comes before or after neighbor sse
      const bool selected_sse_comes_first( SELECTED_SSE.GetFirstAA()->GetSeqID() < NEIGHBOR_SSE.GetFirstAA()->GetSeqID());

      // calculate the sequence distance and loop distance
      const size_t seq_dist( biol::CalculateSequenceDistance( SELECTED_SSE, NEIGHBOR_SSE));
      const double ideal_loop_distance( s_MaxDistancePerResidue * seq_dist);
      const double max_loop_distance( std::min( s_MaxLoopDistance, ideal_loop_distance));

      // decide whether to to regular placement or add at the end
      const bool add_at_top( random::GetGlobalRandom().Double() < m_AddToTopProbability);

      // if adding at the top
      if( add_at_top)
      {
        // calculate maximum allowed loop distance
        const double loop_distance
        (
          seq_dist == 0 ?
          s_MinLoopDistance : // if broken SSEs use min loop distance, otherwise use random within range
          random::GetGlobalRandom().Double( math::Range< double>( s_MinLoopDistance, max_loop_distance))
        );

        // calculate z translation
        linal::Vector3D z_translation
        (
          0.0, 0.0,
          double( math::ConvertBooleanToSign( !selected_sse_comes_first)) *
          ( ( NEIGHBOR_SSE.GetLength() / 2.0) + ( SELECTED_SSE.GetLength() / 2.0) + loop_distance)
        );

        // decide on which direction the SSE should be facing
        const double arc_angle( random::GetGlobalRandom().Random< double>( 0, 2.0 * math::g_Pi));

        // determine rotation axis
        linal::Vector3D rotation_axis( cos( arc_angle), sin( arc_angle), 0.0);

        // decide on a hinge angle
        // 0 is complete z translation only, while -90 or 90 means perpendicular
        const double hinge_angle
        (
          random::GetGlobalRandom().Double
          (
            math::Range< double>( -m_MaxHingeAngleAddingToTop, m_MaxHingeAngleAddingToTop)
          )
        );

        // form transformation
        math::TransformationMatrix3D transformation;

        // apply a random rotation around z axis
        const double z_rotation_angle( random::GetGlobalRandom().Random< double>( 0.0, 2.0 * math::g_Pi));
        transformation( coord::GetAxes().e_Z, z_rotation_angle);

        // find the translation to move the end of the SSE which will connect the loop to origin
        // if selected SSE comes first it's the C terminal edge, so we have to move down
        // otherwise it's the N terminal edge, so we have to move up
        linal::Vector3D translate_loop_end_to_center
        (
          0.0, 0.0, SELECTED_SSE.GetLength() / 2.0 * double( math::ConvertBooleanToSign( !selected_sse_comes_first))
        );

        // move the loop end to origin
        transformation( translate_loop_end_to_center);

        // apply the tilt angle
        transformation( math::RotationMatrix3D( rotation_axis, hinge_angle));

        // move it back up
        transformation( -translate_loop_end_to_center);

        // apply translation
        transformation( z_translation);

        // apply the neighbor sse's orientation
        transformation( NEIGHBOR_SSE.GetOrientation());

        // return
        return storage::Pair< math::TransformationMatrix3D, bool>( transformation, true);

      }
      // adding next to it
      else
      {
        // decide on a flip axis
        const coord::Axis flip_axis( random::GetGlobalRandom().Boolean() ? coord::GetAxes().e_X : coord::GetAxes().e_Y);

        // initialize translation direction
        linal::Vector3D translation_direction;

        // initialize the transformation matrix that will be applied to this sse
        math::TransformationMatrix3D transformation;

        // if helix helix
        if( contact_type == contact::GetTypes().HELIX_HELIX)
        {
          // determine a random angle between -90 and +90
          const double angle( random::GetGlobalRandom().Random< double>( 0.0, 2.0 * math::g_Pi));

          // use this angle to determine a random unit vector on xy plane and scale the translation
          translation_direction = linal::Vector3D( cos( angle), sin( angle), 0.0);
        }
        // if the selected_sse is a helix and the neighbor sse is strand
        else if( contact_type == contact::GetTypes().HELIX_SHEET)
        {
          // then we can only use x axis
          translation_direction = linal::Vector3D( random::GetGlobalRandom().Sign(), 0.0, 0.0);
        }
        // if the selected SSE is a strand and the neighbor sse is helix
        else if( contact_type == contact::GetTypes().SHEET_HELIX)
        {
          // determine a random angle between -90 and +90
          const double angle( random::GetGlobalRandom().Random< double>( 0.0, 2.0 * math::g_Pi));

          // use this angle to determine a random unit vector on xy plane
          translation_direction = linal::Vector3D( cos( angle), sin( angle), 0.0);

          // we also need a rotation around Z to make sure the strand side chains are facing the helix
          transformation( coord::GetAxes().e_Z, -angle);

        }
        else if( contact_type == contact::GetTypes().STRAND_STRAND)
        {
          // determine randomly to use x (SHEET_SHEET) or y axis( STRAND_STRAND)
          const coord::Axis trans_axis( random::GetGlobalRandom().Boolean() ? coord::GetAxes().e_X : coord::GetAxes().e_Y);

          // set the translation direction
          translation_direction( trans_axis) = random::GetGlobalRandom().Sign();

          // if sheet sheet was selected update the distance and tilt angle
          if( trans_axis == coord::GetAxes().e_X)
          {
            // update contact_type
            contact_type = contact::GetTypes().SHEET_SHEET;
          }
        }
        else
        {
          // if no valid contact type found then return undefined transformation
          BCL_MessageCrt( "undefined contact type!" + contact_type.GetName());
          return storage::Pair< math::TransformationMatrix3D, bool>( math::TransformationMatrix3D(), false);
        }

        // calculate the loop distance min
        double loop_distance_min( contact_type->GetPreferredDistanceRange().GetMin());

        // calculate the loop distance max
        // if the min is larger than max, which would happen if the loop is very short, then set it to min
        double loop_distance_max
        (
          std::max( std::min( contact_type->GetPreferredDistanceRange().GetMax(), max_loop_distance), loop_distance_min)
        );

        // calculate distance
        const double loop_distance( random::GetGlobalRandom().Random< double>( loop_distance_min, loop_distance_max));

        // length difference
        const double length_difference( ( NEIGHBOR_SSE.GetLength() - SELECTED_SSE.GetLength()) / 2.0);

        // calculate z_translation_amount
        const double z_translation_amount
        (
          // if selected SSE comes first the translation has to be -Z
          // if neighbor SSE is longer then translation should be positive
          double( math::ConvertBooleanToSign( !selected_sse_comes_first)) * length_difference
        );

        // calculate the twist angle
        const double tilt_angle( random::GetGlobalRandom().Double( contact_type->GetTiltAngleRange()));

        // find the translation to move the end of the SSE which will connect the loop to origin
        // if selected SSE comes first it's the C terminal edge, so we have to move down
        // otherwise it's the N terminal edge, so we have to move up
        linal::Vector3D translate_loop_end_to_center
        (
          0.0, 0.0, double( math::ConvertBooleanToSign( !selected_sse_comes_first)) * SELECTED_SSE.GetLength() / 2.0
        );

        // if not adding a strand
        if( SELECTED_SSE.GetType() != biol::GetSSTypes().STRAND)
        {
          // decide on a internal z rotation
          const double internal_z_rotation( random::GetGlobalRandom().Random< double>( 0.0, 2.0 * math::g_Pi));

          // rotate around Z
          transformation( math::RotationMatrix3D( coord::GetAxes().e_Z, internal_z_rotation));
        }

        // flip around flip axis
        transformation( math::RotationMatrix3D( flip_axis, math::g_Pi));

        // rotate the transformation by the tilt angle along the translation axis
        transformation( math::RotationMatrix3D( translation_direction, tilt_angle));

        // apply the translation
        transformation( translation_direction * loop_distance);

        // apply the z-translation
        transformation( linal::Vector3D( 0.0, 0.0, z_translation_amount));

        // apply the rotation of the neighbor SSE
        transformation( NEIGHBOR_SSE.GetOrientation());

        // return
        return storage::Pair< math::TransformationMatrix3D, bool>( transformation, true);
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_placement_strand_next_to_sheet.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sheet.h"
#include "assemble/bcl_assemble_domain.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> PlacementStrandNextToSheet::s_Instance
    (
      util::Enumerated< PlacementInterface< assemble::SSE, assemble::ProteinModel> >::AddInstance( new PlacementStrandNextToSheet())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a flip probability and a distance deviation
    //! @param FLIP_PROBABILITY probability of applying a flip the strand around a random axis
    PlacementStrandNextToSheet::PlacementStrandNextToSheet( const double FLIP_PROBABILITY) :
      m_FlipProbability( FLIP_PROBABILITY)
    {
      BCL_Assert
      (
        m_FlipProbability >= 0.0 && m_FlipProbability <= 1.0,
        "The flip probability should be in the range [0..1] not " + util::Format()( FLIP_PROBABILITY)
      );
    }

    //! @brief Clone function
    //! @return pointer to new PlacementStrandNextToSheet
    PlacementStrandNextToSheet *PlacementStrandNextToSheet::Clone() const
    {
      return new PlacementStrandNextToSheet( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &PlacementStrandNextToSheet::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &PlacementStrandNextToSheet::GetAlias() const
    {
      static const std::string s_alias( "PlacementStrandNextToSheet");
      return s_alias;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer PlacementStrandNextToSheet::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Places a strand next to a sheet.");
      serializer.AddInitializer
      (
        "flip_probability",
        "probability of flipping a strand around a random axis",
        io::Serialization::GetAgent( &m_FlipProbability)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief find the placement for the given strand SELECTED_STRAND with respect to a sheet in PROTEIN_MODEL
    //! @param SELECTED_STRAND SiPtr to strand to be placed
    //! @param PROTEIN_MODEL to which the SELECTED_STRAND is going to be added
    //! @return the transformationmatrix3d to place the SELECTED_STRAND in the PROTEIN_MODEL
    storage::Pair< math::TransformationMatrix3D, bool> PlacementStrandNextToSheet::Place
    (
      const assemble::SSE &SELECTED_STRAND,
      const assemble::ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize a static transformation and boolean pair to return in case of failures
      static const storage::Pair< math::TransformationMatrix3D, bool>
        s_failure_return( math::TransformationMatrix3D(), false);

      // make sure the provided sse is strand
      BCL_Assert
      (
        SELECTED_STRAND.GetType() == biol::GetSSTypes().STRAND,
        "The provided SSE should be a strand not of type " + SELECTED_STRAND.GetType().GetName()
      );

      // collect the sheets from the given ProteinModel
      util::ShPtrVector< assemble::Domain> collected_sheets( assemble::CollectorSheet().Collect( PROTEIN_MODEL));

      // initialize variable to hold the sheet of interest
      util::ShPtr< assemble::Domain> this_sheet;

      // if there are no sheets found
      if( collected_sheets.IsEmpty())
      {
        // warn user and return failure
        BCL_MessageVrb( "No sheets found in the model therefore skipping this move");
        return s_failure_return;
      }
      // if there is only one sheet than pick it
      else if( collected_sheets.GetSize() == 1)
      {
        this_sheet = collected_sheets.FirstElement();
      }
      // otherwise pick one randomly
      else
      {
        this_sheet =
          collected_sheets
          (
            random::GetGlobalRandom().SizeT
            (
              math::Range< size_t>( 0, collected_sheets.GetSize() - 1)
            )
          );
      }

      // make sure the sheet is not empty
      BCL_Assert( this_sheet->GetNumberSSEs() > 0, "The selected sheet is empty this should not have happened!!");

      // issue message
      BCL_MessageVrb( "Following sheet was selected:\n " + this_sheet->GetIdentification());

      // calculate the placement and return
      return Place( SELECTED_STRAND, *this_sheet);
    }

    //! @brief find the placement for the given strand SELECTED_STRAND with respect to a sheet in SHEET
    //! @param SELECTED_STRAND SiPtr to strand to be placed
    //! @param SHEET to which the SELECTED_STRAND is going to be added
    //! @return the transformationmatrix3d to place the SELECTED_STRAND in the SHEET
    storage::Pair< math::TransformationMatrix3D, bool> PlacementStrandNextToSheet::Place
    (
      const assemble::SSE &SELECTED_STRAND,
      const assemble::Domain &SHEET
    ) const
    {
      // initialize a static transformation and boolean pair to return in case of failures
      static const storage::Pair< math::TransformationMatrix3D, bool>
        s_failure_return( math::TransformationMatrix3D(), false);

      // make sure the passed domain has a valid topology and is of type sheet or beta-barrel
      if
      (
        !SHEET.GetTopology().IsDefined() || SHEET.GetTopology()->GetType() != assemble::Topology::e_Sheet
      )
      {
        // warn user and return
        BCL_MessageVrb( "The given domain is not a sheet");
        return s_failure_return;
      }

      // initialize the transformation matrix that will be applied to this sse
      math::TransformationMatrix3D transformation;

      // initialize the distance using the randomly determined from the given ranges
      const double distance( random::GetGlobalRandom().Double( contact::GetTypes().STRAND_STRAND->GetPreferredDistanceRange()));

      // if the sheet has only one strand
      if( SHEET.GetNumberSSEs() == 1)
      {
        BCL_MessageVrb( "only one strand found in the sheet");
        // make a reference on the only strand in the sheet
        const assemble::SSE &this_strand( *SHEET.GetSSEs().FirstElement());

        // get a random sign to determine direction
        const int direction( random::GetGlobalRandom().Sign());

        // get a random twist angle between allowed ranges and multiply with translation sign
        // since we do the rotation always around the y axis
        const double twist_angle
        (
          random::GetGlobalRandom().Double( contact::GetTypes().STRAND_STRAND->GetTiltAngleRange()) * direction
        );

        // initialize the translation vector that translate along Y axis
        linal::Vector3D this_translation( 0, direction * distance, 0);

        // rotate the translation vector with neighbor sses rotation
        this_translation.Rotate( this_strand.GetRotation());

        BCL_MessageVrb( "The twist angle is " + util::Format()( math::Angle::Degree( twist_angle)));
        // apply the twist rotation
        transformation( math::RotationMatrix3D( coord::GetAxes().e_Y, twist_angle));

        // apply the orientation of the strand
        transformation( this_strand.GetOrientation());

        // apply the calculated translation to transformation
        transformation( this_translation);
      }
      // if more than one strand
      else
      {
        // decide whether to add before or after
        const bool add_after( random::GetGlobalRandom().Boolean());

        BCL_MessageVrb( "multiple strands in the sheet, add after: " + util::Format()( add_after));

        // initialize variable to store the edge strand
        const util::SiPtr< const assemble::SSEGeometryInterface> sp_edge_strand
        (
          add_after ?
            SHEET.GetTopology()->GetElements().LastElement() :
            SHEET.GetTopology()->GetElements().FirstElement()
        );
        // initialize variables to store the edge_strand and reference_strand
        const util::SiPtr< const assemble::SSEGeometryInterface> sp_reference_strand
        (
          add_after ?
            SHEET.GetTopology()->GetElements()( SHEET.GetNumberSSEs() - 2) :
            SHEET.GetTopology()->GetElements()( 1)
        );

        // get the StrandPacking information
        const assemble::SSEGeometryPacking &this_packing
        (
          SHEET.GetTopology()->GetPackingForSSEGeometryPair( *sp_edge_strand, *sp_reference_strand)
        );

        // make sure the orientation was found
        BCL_Assert
        (
          this_packing.GetOrientation() != assemble::SSEGeometryPacking::e_UndefinedOrientation,
          "Orientation was undefined for these two strands!"
        );

        BCL_MessageVrb
        (
          "edge_strand: " + sp_edge_strand->GetIdentification() +
          " reference_strand: " + sp_reference_strand->GetIdentification()
        );
        BCL_MessageVrb
        (
          "edge_frag: " + this_packing.GetFirstSSEGeometry()->GetIdentification() +
          " reference_frag: " + this_packing.GetSecondSSEGeometry()->GetIdentification()
        );

        // get the translation vector from reference to edge
        linal::Vector3D translation_vector
        (
          this_packing.GetFirstSSEGeometry()->GetCenter() - this_packing.GetSecondSSEGeometry()->GetCenter()
        );

        // make a copy of the transformation of selected_strand and edge
        math::TransformationMatrix3D selected_trans( SELECTED_STRAND.GetOrientation());
        math::TransformationMatrix3D edge_trans( sp_edge_strand->GetOrientation());

        // calculate the twist angle from edge to reference
        double twist_angle
        (
          linal::Dihedral
          (
            sp_edge_strand->GetCenter() + sp_edge_strand->GetAxis( coord::GetAxes().e_Z),
            sp_edge_strand->GetCenter(),
            sp_reference_strand->GetCenter(),
            sp_reference_strand->GetCenter() + sp_reference_strand->GetAxis( coord::GetAxes().e_Z)
          )
        );
        // calculate the line connecting two origins
        linal::Vector3D next_spot( sp_edge_strand->GetCenter() + translation_vector);
        const double translation_x_proj_angle
        (
          linal::ProjAngle( translation_vector, sp_edge_strand->GetAxis( coord::GetAxes().e_Y))
        );

        BCL_MessageVrb
        (
          "The translation-x proj angle is: " + util::Format()( math::Angle::Degree( translation_x_proj_angle)) + " degrees "
          + util::Format()( translation_x_proj_angle) + " radians"
        );
        // if projection angle of x axis is smaller than the 90 degrees with respect to translation
        // meaning it was anti-parallel
        if( translation_x_proj_angle <= ( math::g_Pi / 2.0))
        {
          BCL_MessageVrb
          (
            "The translation-x proj angle is less than 90 degrees"
          );
          // revert the twist angle
          twist_angle *= -1.0;
        }

        // apply the twist angle rotation
        transformation( math::RotationMatrix3D( coord::GetAxes().e_Y, twist_angle));

        // apply the transformation of the edge strand
        transformation( sp_edge_strand->GetOrientation());

        // apply the translation
        transformation( translation_vector);
      }

      // if flip was selected
      if( random::GetGlobalRandom().Double() < m_FlipProbability)
      {
        // decide on around which axis to flip around ( X or Y or Z)
        const coord::Axis flip_axis( random::GetGlobalRandom().Random< size_t>( 2));

        // issue message
        BCL_MessageVrb( "Flip will be applied along axis " + flip_axis.GetName());

        // make a copy of the transformation
        math::TransformationMatrix3D transformation_copy( transformation);

        transformation( math::Inverse( transformation_copy));
        // apply a flip along the x or y axis
        transformation( flip_axis, math::g_Pi);
        transformation( transformation_copy);
      }

      // initialize the transformation matrix that will be applied to this sse
      return storage::Pair< math::TransformationMatrix3D, bool>( transformation, true);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protein_geometry.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_sequence_factory.h"
#include "biol/bcl_biol_atom.h"
#include "linal/bcl_linal_matrix3x3.h"
#include "linal/bcl_linal_vector_3d_operations.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> ProteinGeometry::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinGeometry())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinGeometry::ProteinGeometry()
    {
    }

    //! @brief clone function
    //! @return pointer to a new ProteinGeometry
    ProteinGeometry *ProteinGeometry::Clone() const
    {
      return new ProteinGeometry( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &ProteinGeometry::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief returns the local coordinate system of the given amino acid
    //! @param AMINO_ACID amino aid to return the local coordinate system for
    //! @return local coordinate system of the given amino acid
    linal::Matrix3x3< double> ProteinGeometry::GetLocalCoordinateSystem( const biol::AABase &AMINO_ACID)
    {
      // get the coordinates to compute the local coordinate system
      const linal::Vector3D &ca_coord( AMINO_ACID.GetAtom( biol::GetAtomTypes().CA).GetCoordinates());
      const linal::Vector3D &cb_coord( AMINO_ACID.GetAtom( biol::GetAtomTypes().CB).GetCoordinates());
      const linal::Vector3D &n_coord( AMINO_ACID.GetAtom( biol::GetAtomTypes().N).GetCoordinates());

      // compute the orthonormal base of the local coordinate system
      const linal::Vector3D y_axis( ( n_coord - ca_coord).Normalize());
      const linal::Vector3D ca_cb( cb_coord - ca_coord);
      const linal::Vector3D ca_cb_y( ( ca_cb * y_axis) * y_axis);
      const linal::Vector3D x_axis( ( ca_cb - ca_cb_y).Normalize());
      const linal::Vector3D z_axis( linal::CrossProduct( x_axis, y_axis).Normalize());

      // create the matrix defining the coordinate system
      linal::Matrix3x3< double> base( util::GetUndefinedDouble());
      for( size_t i( 0); i < 3; ++i)
      {
        base( 0, i) = x_axis( i);
      }
      for( size_t i( 0); i < 3; ++i)
      {
        base( 1, i) = y_axis( i);
      }
      for( size_t i( 0); i < 3; ++i)
      {
        base( 2, i) = z_axis( i);
      }

      return base;
    }

    //! @brief fits the given loop to the given template and returns a new protein model containing the loop
    //! @param PROTEIN_MODEL protein model to containing the loop
    //! @param LOOP loop to be the given template
    //! @param TEMPLATE template used to fit the loop to
    //! @return new protein model containing the fitted loop
    util::ShPtr< assemble::ProteinModel> ProteinGeometry::FitToTemplate
    (
      const assemble::ProteinModel &PROTEIN_MODEL, const LoopParameters &LOOP, const LoopParameters &TEMPLATE
    )
    {
      // get the amino acids which need to be fitted
      const assemble::Chain &chain( *PROTEIN_MODEL.GetChain( LOOP.GetChainID()));
      const util::SiPtrVector< const biol::AABase> res_tmp( chain.GetAminoAcids());
      const util::SiPtrVector< const biol::AABase> residues
      (
        res_tmp[ LOOP.GetAnchors()( 0)], // first residue in the loop to be fitted
        res_tmp[ LOOP.GetAnchors()( 1)]  // last residue in the loop to be fitted
      );

      // get an initial conformation of the loop
      const biol::AASequence &sequence( *chain.GetSequence());
      const size_t length( LOOP.GetAnchors()( 1) - LOOP.GetAnchors()( 0) - 1);
      util::ShPtr< assemble::SSE> sp_loop
      (
        new assemble::SSE( sequence.SubSequence( LOOP.GetAnchors()( 0), length), biol::GetSSTypes().COIL)
      );
      sp_loop->SetType( biol::GetSSTypes().STRAND);
      sp_loop->SetToIdealConformationInPlace();
      sp_loop->SetType( biol::GetSSTypes().COIL);

      // fit the sequence to the template
      const storage::Vector< double> &angles( TEMPLATE.GetAngles());
      int seq_id( LOOP.GetAnchors()( 0) + 1);
      for( auto it( angles.Begin() + 1), it_end( angles.End() - 1); it != it_end; it += 2, ++seq_id)
      {
        storage::VectorND< 2, double> phi_psi( *it, *( it + 1));
        biol::AASequenceFlexibility::SetPhiPsi
        (
          *sp_loop, seq_id, phi_psi, biol::AASequenceFlexibility::SequenceDirection::e_CTerminal
        );
      }

      // attach the sequence to the anchor residue
      const int n_term_id( sp_loop->GetFirstMember()->GetSeqID());
      const biol::AABase &n_term_loop( *sp_loop->GetFirstMember());
      util::ShPtrVector< biol::AABase> n_term_res( 1, *chain.GetSequence()->FindAABySeqID( n_term_id - 1));
      biol::AASequence n_term_seq( n_term_res, n_term_res( 0)->GetChainID());
      const math::TransformationMatrix3D transform
      (
        biol::AASequenceFactory::TransformationAppend( n_term_seq, n_term_loop, angles( 1))
      );
      sp_loop->Transform( transform);

      util::ShPtr< assemble::ProteinModel> sp_new_model( PROTEIN_MODEL.HardCopy());
      for( auto res_it( sp_loop->Begin()), res_it_end( sp_loop->End()); res_it != res_it_end; ++res_it)
      {
        const biol::AABase &new_residue( **res_it);
        const int seq_id( new_residue.GetSeqID());
        biol::AABase &residue( **sp_new_model->GetChain( sp_loop->GetChainID())->GetSequence()->FindAABySeqID( seq_id));
        const util::SiPtrVector< const biol::Atom> new_atoms( new_residue.GetAtoms());
        residue.SetAtoms( new_atoms);
      }
      sp_new_model->ConnectSSEToChainData();

      return sp_new_model;
    }

    //! @brief combines the two given sequence at the given merging point
    //! @detail the given sequences are merged at the given merging points, which denote the residue index.
    //! merging points 5 and 3 results in the fifth residue of the n-terminal sequence being connected top the
    //! third residue of the c-terminal sequence
    //! @param SEQ_N n-terminal sequence to be merged
    //! @param SEQ_C c-terminal sequence to be merged
    //! @param MERGE_N merging point of the n-terminal sequence
    //! @param MERGE_C merging point of the c-terminal sequence
    util::ShPtr< biol::AASequence> ProteinGeometry::CombineSequences
    (
      const biol::AASequence &SEQ_N,
      const biol::AASequence &SEQ_C,
      int MERGE_N,
      int MERGE_C
     )
    {
      // truncate the sequences to be consistent with the merging points
      const biol::AASequence seq_n( SEQ_N.SubSequence( 0, MERGE_N + 1));
      biol::AASequence seq_c( SEQ_C.SubSequence( MERGE_C, SEQ_C.GetSize() - MERGE_C));

      // make chain and sequence ids of c-terminal sequence consistent with n-terminal sequence
      int n_new_id( ( **seq_n.GetMembers().Last()).GetSeqID());
      const char n_chain_id( SEQ_N.GetChainID());
      for( auto aa_it( seq_c.Begin()); aa_it != seq_c.End(); ++aa_it)
      {
        util::ShPtr< biol::AAData> sp_res_data( new biol::AAData( *( **aa_it).GetData()));
        sp_res_data->SetSeqID( ++n_new_id);
        sp_res_data->SetChainID( n_chain_id);
        ( **aa_it).SetData( sp_res_data);
      }

      // determine the phi- and psi-angles of the merging points in the n- and c-terminal sequences
      double phi( 0.0);
      if( MERGE_C != 0)
      {
        // compute the phi-angle for the residue located at the merging point
        const biol::AABase &merge_res_prev( *SEQ_C.GetMembers()( MERGE_C - 1));
        const biol::AABase &merge_res( *SEQ_C.GetMembers()( MERGE_C));
        phi = merge_res.CalculatePhi( merge_res_prev.GetAtom( biol::GetAtomTypes().C));
      }
      else
      {
        // cannot compute the phi-angle for the first residue in the sequence
        BCL_MessageVrb( "Cannot compute phi-angle of c-terminal sequence. Using random angle instead.");
        phi = random::GetGlobalRandom().Double( math::Range< double>( 0, 2 * math::g_Pi));
      }
      double psi( 0.0);
      if( MERGE_N < ( int) SEQ_N.GetSize() - 1)
      {
        // compute the phi-angle for the residue located at the merging point
        const biol::AABase &merge_res_suc( *SEQ_N.GetMembers()( MERGE_N + 1));
        const biol::AABase &merge_res( *SEQ_N.GetMembers()( MERGE_N));
        psi = merge_res.CalculatePsi( merge_res_suc.GetAtom( biol::GetAtomTypes().N));
      }
      else
      {
        // cannot compute the phi-angle for the first residue in the sequence
        BCL_MessageVrb( "Cannot compute psi-angle of n-terminal sequence. Using random angle instead.");
        psi = random::GetGlobalRandom().Double( math::Range< double>( 0, 2 * math::g_Pi));
      }

      // append the c-terminal sequence to the n-terminal sequence
      util::ShPtr< biol::AASequence> sp_new_sequence( new biol::AASequence( seq_n));
      biol::AASequenceFactory::AppendSequence( *sp_new_sequence, seq_c, phi, psi);

      return sp_new_sequence;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief reads members from a given input stream
    //! @param ISTREAM input stream to read members from
    //! @return input stream which members were read from
    std::istream &ProteinGeometry::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief writes members into a given output stream
    //! @param OSTREAM output stream to write members into
    //! @param INDENT number of indentations
    //! @return output stream into which members were written
    std::ostream &ProteinGeometry::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_assembly.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "fold/bcl_fold_default_flags.h"
#include "fold/bcl_fold_default_mutates.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_setup.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolAssembly::ProtocolAssembly()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolAssembly
    ProtocolAssembly *ProtocolAssembly::Clone() const
    {
      return new ProtocolAssembly( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolAssembly &ProtocolAssembly::GetInstance()
    {
      static ProtocolAssembly s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolAssembly::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolAssembly::GetAlias() const
    {
      static const std::string s_name( "ProtocolAssembly");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolAssembly::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Protocol that modifies the default protocol to use only large-scale mutates");

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolAssembly::GetAllFlags() const
    {
      // construct static vector to hold the flags
      static const util::ShPtrVector< command::FlagInterface> s_flags;

      // end
      return s_flags;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolAssembly::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolAssembly::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolAssembly::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolAssembly::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolAssembly::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolAssembly::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolAssembly::InitializeMutates()
    {
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolAssembly::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      // reset MutateTree
      MUTATE_TREE.Reset();

      // get the pool using the empty model
      util::ShPtr< assemble::SSEPool> sp_pool
      (
        GetSetup().GetEmptyModel()->GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      BCL_Assert( sp_pool.IsDefined(), "pool is not initialized!");

      // get the average number of helices and strands, and calculate the ratios
      const storage::Pair< double, double> avg_sse_counts( sp_pool->CalculateAverageHelixStrandCounts());
      const double avg_helix_count( avg_sse_counts.First());
      const double avg_strand_count( avg_sse_counts.Second());
      const double avg_sse_count( avg_helix_count + avg_strand_count);
      const double avg_helix_ratio( avg_helix_count / avg_sse_count);
      const double avg_strand_ratio( avg_strand_count / avg_sse_count);

      BCL_MessageStd
      (
        "average helix/strand/sse counts from pool :" + util::Format()( avg_helix_count) + " / " +
         util::Format()( avg_strand_count) + " / " + util::Format()( avg_sse_count) + " / "
      );

      // initialize variables that are based on the counts
      const bool has_helix( avg_helix_count > 0);
      const bool has_strand( avg_strand_count > 0);
      const bool has_helixdomain( avg_helix_count >= 1.5);
      const bool has_helixpair( avg_helix_count >= 1.5);
      const bool has_sheet( avg_strand_count >= 1.5);

      // first choose probabilities for add, remove, swap, move
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Add,         0.075);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Remove,      0.025);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Swap,        0.10);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSE,         0.10);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Helix,       0.20 * avg_helix_ratio);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Strand,      0.20 * avg_strand_ratio);
      const double ssepair_weight(                                     0.20);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSEPair,     ssepair_weight);
      const double domain_weight(                                      0.30);

      // if has a helix pair
      if( has_helixpair)
      {
        // update helix pair weight
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_HelixPair, ssepair_weight * avg_helix_ratio);
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSEPair,   ssepair_weight * avg_strand_ratio);
      }

      // update domain weights
      if( has_helixdomain)
      {
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_HelixDomain, domain_weight * avg_helix_ratio);
      }
      if( has_sheet)
      {
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Sheet,       domain_weight * avg_strand_ratio);
      }

      // adds
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_AddSSENextToSSE     , 0.75);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_AddSSEShortLoop     , 0.25);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_AddStrandNextToSheet, 1.00 * avg_strand_ratio);
      // remove
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_RemoveRandom        , 0.5);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_RemoveUnpairedStrand, 0.5);

      // swap
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SwapSSEs       , 0.8);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SwapSSEWithPool, 0.2);
      // if the pool is overlapping
      if( sp_pool->IsOverlapping())
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SwapSSEWithPoolOverlap, 0.2);
      }

      // single SSE moves
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEMoveNext        , 3.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEMoveShortLoop   , 3.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEFurthestMoveNext, 3.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETranslateLarge  , 3.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETranslateXLarge , 1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETranslateYLarge , 1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETranslateZLarge , 1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSERotateLarge     , 3.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSERotateXLarge    , 1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSERotateYLarge    , 1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSERotateZLarge    , 1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETransformLarge  , 6.0);

      // if secondary structure prediction were provided and resizing was not disabled
      if
      (
        sspred::Methods::GetFlagReadSSPredictions()->GetFlag() &&
        DefaultFlags::GetFlagEnableSSEResize()->GetFlag()
      )
      {
        // average number of non overlapping sses
        const double number_non_overlapping_long_sses( sp_pool->CountLongNonOverlappingSSEs( 30, 20));
        const double split_probability( ( 2.0 + 4.0 * number_non_overlapping_long_sses) / DefaultMutates::GetInstance().m_SSESplit.GetSize());

        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEResizeCTerm, 1.5);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEResizeNTerm, 1.5);

        // iterate over ss prediction methods
        for
        (
          storage::Map< sspred::Method, Mutate>::const_iterator
            sspred_itr( DefaultMutates::GetInstance().m_SSESplit.Begin()),
            sspred_itr_end( DefaultMutates::GetInstance().m_SSESplit.End());
          sspred_itr != sspred_itr_end;
          ++sspred_itr
        )
        {
          MUTATE_TREE.SetMutateProbability( sspred_itr->second, split_probability);
        }
      }

      // single helix moves
      if( has_helix)
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixMoveNext,         2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixMoveShortLoop,    2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixFurthestMoveNext, 2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixTranslateXYLarge, 2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixTranslateZLarge,  2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixRotateXYLarge,    2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixRotateZLarge,     2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixTransformXYLarge, 2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixTransformZLarge,  2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixFlipXY,           2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixFlipZ,            2.0);
      }

      // single strand moves
      if( has_strand)
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_StrandMoveNext,          2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_StrandFurthestMoveNext,  2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_StrandMoveSheet,         2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_StrandFurthestMoveSheet, 2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_StrandTranslateZLarge,   2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_StrandFlipX,             2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_StrandFlipY,             2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_StrandFlipZ,             2.0);
      }

      // sse pair moves
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEPairTranslateNoHingeLarge, 2.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEPairTranslateLarge,        2.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEPairRotateLarge,           2.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEPairTransformLarge,        2.0);

      // helix pair moves
      if( has_helixpair)
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixPairRotateZLargeNoHinge, 1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixPairRotateZLargeHinge,   1.0);
      }

      // helix domain moves
      if( has_helixdomain)
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixDomainShuffle,         8.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixDomainTranslateLarge, 2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixDomainRotateLarge,    2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixDomainTransformLarge, 2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixDomainFlipExt,        2.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixDomainFlipInt,        2.0);
      }

      // sheet moves
      if( has_sheet)
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetRotateLarge,        1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetTranslateLarge,     1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetTransformLarge,     1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetPairStrands,        1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetSwitchStrand,       1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetFlipExt,            1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetFlipInt,            1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_flip_int_sub,        1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_flip_int_sub_diff,   1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_divide_sandwich,     1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_divide,              1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_twist_large,         1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_shuffle,             4.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_cycle,               1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_cycle_intact,        1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_cycle_subset,        1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_cycle_subset_intact, 1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_register_shift,      1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_register_shift_flip, 1.0);
      }
    }
    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolAssembly::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolAssembly::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns string containing short description of the protocol
    //! @return string containing short description of the protocol
    const std::string &ProtocolAssembly::GetDescription() const
    {
      // initialize static const string variable to hold the description
      static const std::string s_description
      (
        "assembly protocol for de novo folding"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolAssembly::GetReadMe() const
    {
      // initialize static const string variable to hold the readme
      static const std::string s_readme
      (
        "The assembly protocol consists of large amplitude translation or rotations and moves that add or remove SSEs. "
        "Other moves central to this phase shuffle beta-strands within beta-sheets or break large beta-sheets to "
        "create beta-sandwiches."
      );

      // end
      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolAssembly::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolAssembly::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_create.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "fold/bcl_fold_default_flags.h"
#include "fold/bcl_fold_default_mutates.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_setup.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolCreate::ProtocolCreate()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolCreate
    ProtocolCreate *ProtocolCreate::Clone() const
    {
      return new ProtocolCreate( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolCreate &ProtocolCreate::GetInstance()
    {
      static ProtocolCreate s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolCreate::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolCreate::GetAlias() const
    {
      static const std::string s_name( "ProtocolCreate");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolCreate::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Initial protocol for de-novo folding. Gets all SSEs into the model w/o clashes or loop-closure issues");

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolCreate::GetAllFlags() const
    {
      // construct static vector to hold the flags
      static const util::ShPtrVector< command::FlagInterface> s_flags;

      // end
      return s_flags;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolCreate::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolCreate::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolCreate::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolCreate::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolCreate::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolCreate::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolCreate::InitializeMutates()
    {
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolCreate::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      // reset MutateTree
      MUTATE_TREE.Reset();

      // get the pool using the empty model
      util::ShPtr< assemble::SSEPool> sp_pool
      (
        GetSetup().GetEmptyModel()->GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      BCL_Assert( sp_pool.IsDefined(), "pool is not initialized!");

      // get the average number of helices and strands, and calculate the ratios
      const storage::Pair< double, double> avg_sse_counts( sp_pool->CalculateAverageHelixStrandCounts());
      const double avg_helix_count( avg_sse_counts.First());
      const double avg_strand_count( avg_sse_counts.Second());
      const double avg_sse_count( avg_helix_count + avg_strand_count);
      const double avg_strand_ratio( avg_strand_count / avg_sse_count);

      // first choose probabilities for add, remove, swap, move
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Add,         0.75);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Remove,      0.25);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Swap,        0.25);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSE,         0.01);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Helix,       0.01);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Strand,      0.01);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSEPair,     0.01);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_HelixPair,   0.01);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_HelixDomain, 0.01);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Sheet,       0.01);

      // adds
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_AddSSENextToSSE     , 0.375);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_AddSSEShortLoop     , 0.5);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_AddStrandNextToSheet, 1.00 * avg_strand_ratio);

      // remove
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_RemoveRandom   , 1.00);

      // swap
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SwapSSEs       , 1.00);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SwapSSEWithPool, 1.00);
    }
    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolCreate::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolCreate::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns string containing short description of the protocol
    //! @return string containing short description of the protocol
    const std::string &ProtocolCreate::GetDescription() const
    {
      // initialize static const string variable to hold the description
      static const std::string s_description
      (
        "assembly protocol for de novo folding"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolCreate::GetReadMe() const
    {
      // initialize static const string variable to hold the readme
      static const std::string s_readme
      (
        "This protocol consists solely of adding sses and swapping them them those already in the pool."
      );

      // end
      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolCreate::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolCreate::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_default.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_printer_protein_model_movie.h"
#include "assemble/bcl_assemble_protein_model_inverter.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "fold/bcl_fold_default_flags.h"
#include "fold/bcl_fold_default_mutates.h"
#include "fold/bcl_fold_default_scores.h"
#include "mc/bcl_mc_movie_printers.h"
#include "mc/bcl_mc_printer_combined.h"
#include "mc/bcl_mc_stage.h"
#include "opti/bcl_opti_criterion_number_iterations.h"
#include "opti/bcl_opti_criterion_unimproved.h"
#include "pdb/bcl_pdb_printer_score.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolDefault::ProtocolDefault()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolDefault
    ProtocolDefault *ProtocolDefault::Clone() const
    {
      return new ProtocolDefault( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolDefault &ProtocolDefault::GetInstance()
    {
      static ProtocolDefault s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolDefault::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolDefault::GetAlias() const
    {
      static const std::string s_name( "ProtocolDefault");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolDefault::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "default folding protocol");

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolDefault::GetAllFlags() const
    {
      return DefaultFlags::GetAllFlags();
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolDefault::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      // if a specified start model was not given and the model already does not have any SSEs
      if
      (
        !DefaultFlags::GetFlagStartModel()->GetFlag() &&
        START_MODEL.GetNumberSSEs() == 0
      )
      {
        AddRandomSSEToStartModel( START_MODEL);
      }
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolDefault::InitializeScores()
    {
      DefaultScores::GetInstance().InitializeScores();
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolDefault::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
      DefaultScores::GetInstance().ModifyScoreWeightSet( SCORE_WEIGHT_SET);
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolDefault::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
      CRITERION.InsertCriteria
      (
        opti::CriterionNumberIterations< assemble::ProteinModel, double>
        (
          STAGE.GetMaxNumberIterations()
        )
      );

      CRITERION.InsertCriteria
      (
        opti::CriterionUnimproved< assemble::ProteinModel, double>
        (
          STAGE.GetMaxNumberUnimprovedIterations()
        )
      );
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolDefault::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
      // construct model printer
      util::ShPtr< assemble::PrinterProteinModel> sp_model_printer
      (
        new assemble::PrinterProteinModel
        (
          GetSetup().GetPrefix(),
          GetSetup().GetStorage(),
          GetSetup().GetSuperimposeMeasure()
        )
      );
      PRINTER.Insert( sp_model_printer);

      // add movie printer if movie flag was given
      if( mc::MoviePrinterInterface::GetFlagMoviePrinter()->GetFlag())
      {
        // initialize mc movie printer
        util::ShPtr< mc::MoviePrinterInterface> sp_movie_printer
        (
          mc::MoviePrinter( mc::MoviePrinterInterface::GetParameterMoviePrinterType()->GetValue())
        );
        storage::Vector< std::string> row_names( STAGE.GetScoreFunction()->GetFunctionSchemes());
        row_names.PushBack( GetSetup().GetSuperimposeMeasure().GetName());
        sp_movie_printer->Initialize
        (
          mc::MoviePrinterInterface::GetParameterMoviePrefix()->GetValue(),
          storage::Vector< std::string>::Create
          (
            GetStaticClassName< storage::Table< double> >(),
            math::SumFunctionMixin< score::ProteinModel>::GetValueTableVerticalColumnNames()( 2)
          ),
          row_names,
          mc::MoviePrinterInterface::GetParameterMovieWidth()->GetNumericalValue< size_t>(),
          mc::MoviePrinterInterface::GetParameterMovieHeight()->GetNumericalValue< size_t>(),
          bool( mc::MoviePrinterInterface::GetParameterRayTrace()->GetNumericalValue< size_t>() > 0)
        );

        // construct protein model movie printer
        const util::ShPtr< assemble::PrinterProteinModelMovie> sp_model_movie_printer
        (
          new assemble::PrinterProteinModelMovie
          (
            mc::MoviePrinterInterface::GetParameterMoviePrefix()->GetValue(),
            sp_movie_printer,
            STAGE.GetScoreFunction(),
            GetSetup().GetStepStatuses(),
            GetSetup().GetSuperimposeMeasure(),
            GetSetup().GetQualityMeasures()
          )
        );

        // if pdb was given, use this as the starting structure
        if( DefaultFlags::GetFlagNativeModel()->GetFirstParameter()->GetWasSetInCommandLine())
        {
          sp_movie_printer->SetStartFrame( DefaultFlags::GetFlagNativeModel()->GetFirstParameter()->GetValue(), true);
        }

        // set the water mark
        sp_movie_printer->SetWaterMark();

        // add printer
        PRINTER.Insert( sp_model_movie_printer);
      }

    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolDefault::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
      FACTORY->AppendPrinter
      (
        util::ShPtr< util::FunctionInterface< assemble::ProteinModel, util::ShPtrList< pdb::Line> > >
        (
          new pdb::PrinterScore( STAGE.GetScoreFunction(), GetSetup().GetQualityMeasures())
        )
      );
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolDefault::InitializeMutates()
    {
      DefaultMutates::GetInstance().InitializeMutates();
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolDefault::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      DefaultMutates::GetInstance().ModifyMutateTree( MUTATE_TREE);
    }

    //! @brief reset the protocol (i.e. empty cache of scoring function)
    void ProtocolDefault::Reset()
    {
      // get the inverter
      util::ShPtr< assemble::ProteinModelInverter> sp_inverter( DefaultScores::GetInstance().GetProteinInverter());

      // reset it
      sp_inverter->Reset();
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolDefault::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolDefault::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      ModifyMutateTree( MUTATE_TREE);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolDefault::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "default protocol for de novo folding"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolDefault::GetReadMe() const
    {
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "The Default protocol initializes all mutates and scores. These are then modified by other protocols to suit "
        "specific needs."
      );

      // end
      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolDefault::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolDefault::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief adds a random SSE from the pool to the start model
    //! @param START_MODEL starting model
    void ProtocolDefault::AddRandomSSEToStartModel( assemble::ProteinModel &START_MODEL)
    {
      // get the pool from start model
      util::ShPtr< assemble::SSEPool> sp_pool
      (
        START_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      BCL_Assert( sp_pool.IsDefined(), "SSE pool is not initialized!");

      // insert a random sse from the pool
      START_MODEL.Insert( random::GetGlobalRandom().Iterator( sp_pool->Begin(), sp_pool->End(), sp_pool->GetSize())->HardCopy());
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_dock.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_locator_domain_specified.h"
#include "assemble/bcl_assemble_locator_sse.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "coord/bcl_coord_move_transform_random.h"
#include "fold/bcl_fold_default_flags.h"
#include "fold/bcl_fold_mutate_protein_model_domain.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_mutates.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_mutate_move_wrapper.h"
#include "math/bcl_math_mutate_result.h"
#include "pdb/bcl_pdb_factory.h"
#include "util/bcl_util_string_replacement.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolDock::ProtocolDock()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolDock
    ProtocolDock *ProtocolDock::Clone() const
    {
      return new ProtocolDock( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolDock &ProtocolDock::GetInstance()
    {
      static ProtocolDock s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolDock::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolDock::GetAlias() const
    {
      static const std::string s_name( "ProtocolDock");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolDock::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol to be applied to dock domains");

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolDock::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // insert all the flags in the vector
        s_all_flags_vector.PushBack( GetFlagDomainSpecification());
        s_all_flags_vector.PushBack( GetFlagPrintDomainToPymolScript());
        s_all_flags_vector.PushBack( pdb::Factory::GetFlagWritePDBResID());
      }

      // end
      return s_all_flags_vector;
    }

    //! @brief return command line flag for specifying the domains
    //! @return command line flag for specifying domains
    util::ShPtr< command::FlagInterface> &ProtocolDock::GetFlagDomainSpecification()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "domain_specify",
          "\tspecify the domains which should be moved"
        )
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_filename
      (
        new command::Parameter( "domain_specification_filename", "\tfull path and name of file specifying domain", "domain.txt")
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_filename);
      }

      // end
      return s_flag;
    }

    //! @brief return command line flag for specifying the domains
    //! @return command line flag for specifying domains
    util::ShPtr< command::FlagInterface> &ProtocolDock::GetFlagPrintDomainToPymolScript()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "print_domain",
          "\tprint domain to pymol script so that it can be selected on a structure"
        )
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_filename
      (
        new command::Parameter( "pymol_script_filename", "\tfull path and name of file to show domain", "domain.pml")
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_filename);
      }

      // end
      return s_flag;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolDock::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      const util::ShPtrList< assemble::LocatorSSE> &remove_sses( GetDomainMutates().Second());

      // iterate through the locators of sses to remove the located sses
      for
      (
        util::ShPtrList< assemble::LocatorSSE>::const_iterator
          locator_itr( remove_sses.Begin()), locator_itr_end( remove_sses.End());
        locator_itr != locator_itr_end;
        ++locator_itr
      )
      {
        util::SiPtr< const assemble::SSE> sse( ( *locator_itr)->Locate( START_MODEL));

        // if sse could not be located
        if( !sse.IsDefined())
        {
          BCL_MessageDbg( "could not locate sse " + ( *locator_itr)->GetSSEIDString());
          continue;
        }

        // remove sse
        BCL_Assert( START_MODEL.Remove( *sse), "could not remove sse " + sse->GetIdentification());
      }
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolDock::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolDock::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolDock::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolDock::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolDock::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolDock::InitializeMutates()
    {
      const util::ShPtrList< math::MutateInterface< assemble::ProteinModel> > &mutates( GetDomainMutates().First());

      // add the mutates
      for
      (
        util::ShPtrList< math::MutateInterface< assemble::ProteinModel> >::const_iterator
          mutate_itr( mutates.Begin()), mutate_itr_end( mutates.End());
          mutate_itr != mutate_itr_end;
        ++mutate_itr
      )
      {
        BCL_MessageDbg( "adding mutate for " + ( *mutate_itr)->GetScheme());
        GetMutates().AddMutate( *mutate_itr);
      }
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolDock::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      // reset all the probabilities
      MUTATE_TREE.Reset();
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Domain,    1.0);

      const util::ShPtrList< math::MutateInterface< assemble::ProteinModel> > &mutates( GetDomainMutates().First());

      // add the mutates
      for
      (
        util::ShPtrList< math::MutateInterface< assemble::ProteinModel> >::const_iterator
          mutate_itr( mutates.Begin()), mutate_itr_end( mutates.End());
          mutate_itr != mutate_itr_end;
        ++mutate_itr
      )
      {
        BCL_MessageDbg( "setting mutate probability for " + ( *mutate_itr)->GetScheme());
        MUTATE_TREE.SetMutateProbability( ( *mutate_itr)->GetScheme(),   1.0);
      }
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolDock::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolDock::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolDock::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "protocol to be applied to dock domains"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolDock::GetReadMe() const
    {
      // TODO: add readme for this protocol
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "readme for dock protocol"
      );

      // end
      return s_readme;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolDock::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolDock::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief second list is for sses that should be removed from starting model to minimize clashes during docking
    const storage::Pair
    <
      util::ShPtrList< math::MutateInterface< assemble::ProteinModel> >,
      util::ShPtrList< assemble::LocatorSSE>
    > &ProtocolDock::GetDomainMutates()
    {
      static storage::Pair
      <
        util::ShPtrList< math::MutateInterface< assemble::ProteinModel> >,
        util::ShPtrList< assemble::LocatorSSE>
      > mutates_removers;

      // initialize mutates if it is empty
      if( mutates_removers.First().IsEmpty())
      {
        io::OFStream pml_write;
        if( GetFlagPrintDomainToPymolScript()->GetFlag())
        {
          const std::string &pymol_domain_filename( GetFlagPrintDomainToPymolScript()->GetFirstParameter()->GetValue());

          io::File::MustOpenOFStream( pml_write, pymol_domain_filename);
        }
        static const std::string begin_domain_specifier( "DomainSpecifier");
        static const std::string end_domain_specifier( "DomainSpecifierEnd");
        const std::string &domain_filename( GetFlagDomainSpecification()->GetFirstParameter()->GetValue());
        io::IFStream read;
        io::File::MustOpenIFStream( read, domain_filename);

        std::string current_line;
        std::getline( read, current_line);
        current_line = util::TrimString( current_line);

        size_t domain_identifier( 0);

        while( !read.eof() && !current_line.empty())
        {
          BCL_Assert
          (
            current_line == begin_domain_specifier, "first line should be " + begin_domain_specifier +
            " but is " + current_line
          );
          // max translation line formatted "translate min = 1.0 max = 3.0" (space around "=" is optional)
          std::getline( read, current_line);
          BCL_MessageDbg( "current line is |" + current_line + "|");
          current_line = util::TrimString( current_line);
          util::StringReplacement replacer( util::StringReplacement::e_Any, "=", " ");
          replacer.ReplaceEachIn( current_line);
          // now that the ='s are spaces, can split based on spaces and it doesn't matter if spaces surrounded the ='s or not
          storage::Vector< std::string> split_line( util::SplitString( current_line));
          // make sure line has correct size
          BCL_Assert
          (
            split_line.GetSize() == 5, "split line should have 5 entries but is " + util::Format()( split_line) +
            "\nmake sure your line has format \"translate min = 1.0 max = 3.0\""
          );
          // get the min and max translation allowed for this domain
          const double min_translation( util::ConvertStringToNumericalValue< double>( split_line( 2)));
          const double max_translation( util::ConvertStringToNumericalValue< double>( split_line( 4)));
          BCL_MessageDbg
          (
            "translation is min " + util::Format()( min_translation) + " max " + util::Format()( max_translation)
          );

          // max rotation line formatted "rotate min = 1.0 max = 3.0" (space around "=" is optional)
          std::getline( read, current_line);
          current_line = util::TrimString( current_line);
          replacer.ReplaceEachIn( current_line);
          // now that the ='s are spaces, can split based on spaces and it doesn't matter if spaces surrounded the ='s or not
          split_line = util::SplitString( current_line);
          // make sure line has correct size
          BCL_Assert
          (
            split_line.GetSize() == 5, "split line should have 5 entries but is " + util::Format()( split_line) +
            "\nmake sure your line has format \"rotate min = 3.0 max = 3.14\""
          );
          const double min_rotation( util::ConvertStringToNumericalValue< double>( split_line( 2)));
          const double max_rotation( util::ConvertStringToNumericalValue< double>( split_line( 4)));
          BCL_MessageDbg
          (
            "rotation is min " + util::Format()( min_rotation) + " max " + util::Format()( max_rotation)
          );

          util::ShPtrList< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > sse_locators;
          std::string current;
          read >> current;
          BCL_MessageDbg( "current is |" + current + "|");
          bool remove( false);
          if( current == "REMOVE")
          {
            remove = true;
          }
          while( current != end_domain_specifier)
          {
            char chain_id;
            io::Serialize::Read( chain_id, read);
            int seq_id_start, seq_id_end;
            io::Serialize::Read( seq_id_start, read);
            io::Serialize::Read( seq_id_end, read);
            util::ShPtr< assemble::LocatorSSE> sse_locator
            (
              new assemble::LocatorSSE( chain_id, seq_id_start, seq_id_end, DefaultFlags::GetFlagPDBIDNumbering()->GetFlag())
            );
            if( remove)
            {
              mutates_removers.Second().PushBack( sse_locator);
            }
            else
            {
              sse_locators.PushBack( sse_locator);
            }
            BCL_MessageDbg
            (
              "remove is " + util::Format()( remove) + " domain " +
              util::Format()( domain_identifier) + " inserted locator " + util::Format()( chain_id) + " " +
              util::Format()( seq_id_start) + " " + util::Format()( seq_id_end)
            );

            read >> current;
            BCL_MessageDbg( "current is |" + current + "|");
            if( current == "REMOVE")
            {
              remove = true;
            }
            else
            {
              remove = false;
            }
          } //< end read all sses involved in this domain
          BCL_MessageDbg( "number of sses in this domain " + util::Format()( sse_locators.GetSize()));
          // locator for the domain
          const assemble::LocatorDomainSpecified domain_locator( sse_locators);

          // method to transform the domain
          const coord::MoveTransformRandom domain_move( min_translation, max_translation, min_rotation, max_rotation);

          const math::MutateMoveWrapper< assemble::Domain> domain_mutate( domain_move, false);

          const std::string scheme( "domain_transform_random_" + util::Format()( domain_identifier));

          if( GetFlagPrintDomainToPymolScript()->GetFlag())
          {
            domain_locator.WritePymolDomainFile( pml_write, scheme);
          }

          // mutate for the protein model
          util::ShPtr< math::MutateInterface< assemble::ProteinModel> > model_mutate
          (
            new MutateProteinModelDomain( domain_locator, domain_mutate, scheme)
          );

          mutates_removers.First().PushBack( model_mutate);
          ++domain_identifier;
          std::getline( read, current_line); //< get line twice since >> was used previously
          std::getline( read, current_line); //< so first getline call just returns rest of the line >> was called on
          current_line = util::TrimString( current_line);
          BCL_MessageDbg( "end current_line is |" + current_line + "|");
        } //< end read all domains

        BCL_MessageDbg( "number domains specified " + util::Format()( mutates_removers.First().GetSize()));
        BCL_MessageDbg( "number sses to be removed " + util::Format()( mutates_removers.Second().GetSize()));
      }

      // return the mutates
      return mutates_removers;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_em.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_sse_random.h"
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "assemble/bcl_assemble_sse_compare_type.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_flag_static_and_dynamic.h"
#include "command/bcl_command_parameter.h"
#include "command/bcl_command_parameter_check_enumerate.h"
#include "command/bcl_command_parameter_check_extension.h"
#include "command/bcl_command_parameter_check_file_existence.h"
#include "command/bcl_command_parameter_check_ranged.h"
#include "coord/bcl_coord_move_rotate_defined.h"
#include "coord/bcl_coord_move_rotate_random.h"
#include "coord/bcl_coord_move_translate_random.h"
#include "density/bcl_density_protein_agreements.h"
#include "density/bcl_density_simulators.h"
#include "find/bcl_find_collector_criteria_combined.h"
#include "find/bcl_find_locator_criteria.h"
#include "find/bcl_find_pick_body_extent.h"
#include "find/bcl_find_pick_body_random.h"
#include "find/bcl_find_pick_criteria_wrapper.h"
#include "fold/bcl_fold_default_mutates.h"
#include "fold/bcl_fold_default_scores.h"
#include "fold/bcl_fold_mutate_protein_model_sse.h"
#include "fold/bcl_fold_mutate_protein_model_sse_add.h"
#include "fold/bcl_fold_mutate_protein_model_sse_remove.h"
#include "fold/bcl_fold_mutate_protein_model_sse_swap.h"
#include "fold/bcl_fold_mutate_protein_model_sse_swap_body.h"
#include "fold/bcl_fold_mutate_protein_model_sse_swap_with_pool.h"
#include "fold/bcl_fold_mutate_protein_model_sse_swap_with_pool_overlap.h"
#include "fold/bcl_fold_mutate_sse_bend_random.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_placement_sse_into_body.h"
#include "fold/bcl_fold_score_weight_set.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_mutate_move_wrapper.h"
#include "pdb/bcl_pdb_factory.h"
#include "pdb/bcl_pdb_printer_body_assignment.h"
#include "restraint/bcl_restraint_contains_body_origin.h"
#include "restraint/bcl_restraint_handler_body.h"
#include "restraint/bcl_restraint_mutate_transformation_matrix_3d_rotate.h"
#include "score/bcl_score_body_assignment.h"
#include "score/bcl_score_body_connectivity_density.h"
#include "score/bcl_score_body_extent_agreement.h"
#include "score/bcl_score_restraint_body_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolEM::ProtocolEM()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolEM
    ProtocolEM *ProtocolEM::Clone() const
    {
      return new ProtocolEM( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolEM &ProtocolEM::GetInstance()
    {
      static ProtocolEM s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolEM::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolEM::GetAlias() const
    {
      static const std::string s_name( "ProtocolEM");
      return s_name;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolEM::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // insert all the flags in the vector
        s_all_flags_vector.PushBack( GetFlagBodyRestraint());
        s_all_flags_vector.PushBack( GetFlagPrintBodyAssignment());
        s_all_flags_vector.PushBack( GetFlagScoreDensityAgreement());
        s_all_flags_vector.PushBack( GetFlagScoreDensityConnectivity());
        s_all_flags_vector.PushBack( GetFlagEMRefinement());
      }

      // end
      return s_all_flags_vector;
    }

    //! @brief return command line flag for using body restraints
    //! @return command line flag for using body restraints
    util::ShPtr< command::FlagInterface> &ProtocolEM::GetFlagBodyRestraint()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "body_restraint",
          "\tuse body restraint"
        )
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_filename
      (
        new command::Parameter( "body_restraint_filename", "\tfull path and name of restraint file", "body_restraint_file.pdb")
      );
      static util::ShPtr< command::ParameterInterface> s_upper_tolerance_width
      (
        new command::Parameter
        (
          "upper_tolerance_width",
          "bodies which have a length less than this tolerance longer than restraint body will still 100% agree with restraint\t",
          "0.0"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_lower_tolerance_width
      (
        new command::Parameter
        (
          "lower_tolerance_width",
          "bodies which have a length less than this tolerance shorter than restraint body will still 100% agree with restraint\t",
          "0.0"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_upper_transition_width
      (
        new command::Parameter
        (
          "upper_transtion_width",
          "agreement above restraint will transition from 100% agreement to 0% agreement according to cosine curve across this width\t",
          "0.0"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_lower_transition_width
      (
        new command::Parameter
        (
          "lower_transtion_width",
          "agreement below restraint will transition from 100% agreement to 0% agreement according to cosine curve across this width\t",
          "0.0"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_energy_well_depth
      (
        new command::Parameter
        (
          "energy_well_depth",
          "the amount of bonus that should be given to energy if restraint is completely fulfilled\t",
          "-1.0"
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_filename);
        flag->PushBack( s_upper_tolerance_width);
        flag->PushBack( s_lower_tolerance_width);
        flag->PushBack( s_upper_transition_width);
        flag->PushBack( s_lower_transition_width);
        flag->PushBack( s_energy_well_depth);
      }
      // end
      return s_flag;
    }

    //! @brief return command line flag for writing body assignments when using EMFold
    //! @return command line flag for writing body assignments when using EMFold
    util::ShPtr< command::FlagInterface> &ProtocolEM::GetFlagPrintBodyAssignment()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "print_body_assignment", "\tuse enables writing of body assignment when used in EM-Fold protocol"
        )
      );

      // end
      return s_flag;
    }

    //! @brief return command line flag for using density agreement score
    //! @return command line flag for using density agreement score
    util::ShPtr< command::FlagInterface> &ProtocolEM::GetFlagScoreDensityAgreement()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStaticAndDynamic
        (
          "score_density_agreement",
          "\tflag to enable use of density agreement scores",
          command::Parameter
          (
            "agreement_score",
            "the agreement objective to be used",
            command::ParameterCheckEnumerate< density::ProteinAgreements>()
          ),
          0,
          density::GetProteinAgreements().GetEnumCount()
        )
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_filename
      (
        new command::Parameter
        (
          "density_map_filename",
          "\tfilename for density map (mrc/ccp4) file",
          command::ParameterCheckFileExistence(),
          ""
        )
      );
      static util::ShPtr< command::ParameterInterface> s_resolution
      (
        new command::Parameter
        (
          "resolution_density_map",
          "\tresolution of given electron density map [A] - will be used to simulate density and calculate correlation",
          command::ParameterCheckRanged< double>( 0.0, 100.0),
          "0.0"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_simulator
      (
        new command::Parameter
        (
          "simulator",
          "the simulator to be used to generate density maps from a atom structure",
          command::ParameterCheckEnumerate< density::Simulators>(),
          density::GetSimulators().e_Gaussian.GetName()
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStaticAndDynamic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_filename);
        flag->PushBack( s_resolution);
        flag->PushBack( s_simulator);
      }

      // end
      return s_flag;
    }

    //! @brief return command line flag for using density connectivity score
    //! @return command line flag for using density connectivity score
    util::ShPtr< command::FlagInterface> &ProtocolEM::GetFlagScoreDensityConnectivity()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "score_density_connectivity",
          "\tflag to enable use of density connectivity score that rewards models that connect SSEs in high density regions"
        )
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_filename
      (
        new command::Parameter
        (
          "density_map_filename", "\tfilename for density map (mrc) file", command::ParameterCheckExtension( ".mrc"), ""
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_filename);
      }

      // end
      return s_flag;
    }

    //! @brief return command line flag for using em fold refinement protocol
    //! @return command line flag for using em fold refinement protocol
    util::ShPtr< command::FlagInterface> &ProtocolEM::GetFlagEMRefinement()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "em_refinement",
          "\tenable use of refinement protocol for EM fold"
        )
      );

      // end
      return s_flag;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolEM::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      // make sure that if there is one sse that it is properly placed in a density rod
      if( START_MODEL.GetSSEs().GetSize() == 1)
      {
        // set extent tolerances for the length extent picker
        // these tolerances are set to discriminate between helices and strands only, no length discrimination
        linal::Vector3D extent_tolerances( 0.1, 0.1, 50.0);

        // set the length extent picker
        const find::PickBodyExtent picker_extent( extent_tolerances, extent_tolerances);

        // create ShPtr to a PickCriteriaInterface "pick" which is used to determine how a restraint body is
        // selected
        util::ShPtr
        <
          find::PickCriteriaInterface
          <
            util::ShPtr< assemble::SSEGeometryInterface>,
            util::ShPtrVector< assemble::SSEGeometryInterface>, assemble::SSEGeometryInterface
          >
        > pick
        (
          // picker_random.Clone()
          picker_extent.Clone()
        );

        // random sse locator
        const util::ShPtr< assemble::LocatorSSERandom> sp_locator_sse_random( new assemble::LocatorSSERandom());

        const MutateProteinModelSSESwapBody mutate
        (
          GetBodyRestraint(),
          pick,
          sp_locator_sse_random,
          "sse_em_move_into_empty_body"
        );

        math::MutateResult< assemble::ProteinModel> result( mutate( START_MODEL));
        BCL_Assert
        (
          result.GetArgument().IsDefined(),
          "Unable to place initial SSE into body, make sure density map body SSE content is similar to SSE pool "
          "used (i.e. don't use strands in pool if none in body restraint)"
        );

        START_MODEL = ( *result.GetArgument());
      }
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolEM::InitializeScores()
    {
      // if the body restraint flag is given
      if( GetFlagBodyRestraint()->GetFlag())
      {
        // body restraints score
        e_BodyRestraintScore = GetScores().AddScore( GetScoreBodyRestraint());
      }

      // if connectivity score flag was provided
      if( GetFlagScoreDensityConnectivity()->GetFlag())
      {
        // body connectivity density (connectivity score)
        e_BodyConnectivityDensityScore = GetScores().AddScore( GetScoreBodyConnectivityDensity());
      }

      // density agreement score
      if( GetFlagScoreDensityAgreement()->GetFlag())
      {
        const util::ShPtrVector< score::ProteinModel> scores( GetScoresDensityAgreement());
        // density agreement score
        for
        (
          util::ShPtrVector< score::ProteinModel>::const_iterator itr( scores.Begin()), itr_end( scores.End());
          itr != itr_end;
          ++itr
        )
        {
          m_DensityAgreementScores.Insert( GetScores().AddScore( *itr));
          BCL_MessageDbg( "added score: " + ( --m_DensityAgreementScores.End())->GetName());
        }
      }
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolEM::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
      // weights for EM specific score
      SCORE_WEIGHT_SET.SetWeight( e_BodyRestraintScore, 300.0);
      SCORE_WEIGHT_SET.SetWeight( e_BodyConnectivityDensityScore, 450.0);

      // iterate over density agreement scores
      for
      (
        storage::Set< Score>::const_iterator
          itr( m_DensityAgreementScores.Begin()), itr_end( m_DensityAgreementScores.End());
        itr != itr_end;
        ++itr
      )
      {
        SCORE_WEIGHT_SET.SetWeight( *itr, 1.0);
      }

      // if secondary structure predictions are provided
      for
      (
        storage::Map< sspred::Method, storage::VectorND< 2, Score> >::const_iterator
          sspred_itr( DefaultScores::GetInstance().m_SSPredScores.Begin()),
          sspred_itr_end( DefaultScores::GetInstance().m_SSPredScores.End());
        sspred_itr != sspred_itr_end;
        ++sspred_itr
      )
      {
        SCORE_WEIGHT_SET.SetWeight( sspred_itr->second.First(), 1.0);
        SCORE_WEIGHT_SET.SetWeight( sspred_itr->second.Second(), 1.0);
      }

      // density agreements 
      for
      (
        storage::Set< Score>::const_iterator
          itr( m_DensityAgreementScores.Begin()), itr_end( m_DensityAgreementScores.End());
        itr != itr_end;
        ++itr
      )
      {
        SCORE_WEIGHT_SET.SetWeight( *itr, 1.0);
      }
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEM::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEM::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEM::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
      // write body sse assignment was selected
      if( GetFlagPrintBodyAssignment()->GetFlag())
      {
        FACTORY->AppendPrinter
        (
          util::ShPtr< util::FunctionInterface< assemble::ProteinModel, util::ShPtrList< pdb::Line> > >
          (
            new pdb::PrinterBodyAssignment( GetBodyRestraints())
          )
        );
      }
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolEM::InitializeMutates()
    {
      // if the body restraint flag is given
      if( GetFlagBodyRestraint()->GetFlag())
      {
        InitializeBodyAddMutates();
      }

      // initialize first collector for use in locator 1
      // this collector collects all the sses that agree in type with the criterion sse
      const util::ShPtr
      <
        find::CollectorCriteriaInterface
        <
          util::SiPtrList< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE
        >
      > collector_same_sstype
      (
        // set up collector combined with single criterion (match type)
        new find::CollectorCriteriaCombined< assemble::SSE>
        (
          util::ShPtr< util::BinaryFunctionInterface< assemble::SSE, assemble::SSE, bool> >
          (
            new assemble::SSECompareType()
          )
        )
      );

      // initialize random picker (this picker will be used with both collectors)
      const util::ShPtr
      <
        find::PickCriteriaInterface
        <
          util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE
        >
      > picker
      (
        new find::PickCriteriaWrapper
        <
          util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE
        >
        (
          // set up picker with random picker
          assemble::PickSSERandom()
        )
      );

      // create locator to locate sses of same type
      const find::LocatorCriteria
      <
        util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE,
        util::SiPtrList< const assemble::SSE>
      > locator_ss_type( collector_same_sstype, picker);

      // random sse locator
      const util::ShPtr< assemble::LocatorSSERandom> sp_locator_sse_random( new assemble::LocatorSSERandom());

      // remove
      GetMutates().AddMutate( MutateProteinModelSSERemove( sp_locator_sse_random, "remove_em_random"));

      // swaps
      GetMutates().AddMutate( MutateProteinModelSSESwap( locator_ss_type, false, "swap_em_sses"));
      GetMutates().AddMutate( MutateProteinModelSSESwapWithPool( locator_ss_type, false, "swap_em_sse_with_pool"));

      // swap move with single swap only
      GetMutates().AddMutate
      (
        MutateProteinModelSSESwapWithPoolOverlap
        (
          collector_same_sstype, true, false, "swap_em_sse_with_pool_overlap_single_swap_only"
        )
      );

      // set the random picker
      const find::PickCriteriaWrapper
      <
        util::ShPtr< assemble::SSEGeometryInterface>,
        util::ShPtrVector< assemble::SSEGeometryInterface>,
        assemble::SSEGeometryInterface
      >
      picker_random =
        find::PickCriteriaWrapper
        <
          util::ShPtr< assemble::SSEGeometryInterface>,
          util::ShPtrVector< assemble::SSEGeometryInterface>,
          assemble::SSEGeometryInterface
        >( find::PickBodyRandom());

      // set extent tolerances for the length extent picker
      // these tolerances are set to discriminate between helices and strands only, no length discrimination
      linal::Vector3D extent_tolerances( 0.1, 0.1, 50.0);

      // important this is only half the length!!
//      linal::Vector3D extent_tolerances( 0.5, 0.5, 5.0);

      // set the length extent picker
      const find::PickBodyExtent picker_extent( extent_tolerances, extent_tolerances);

      // create ShPtr to a PickCriteriaInterface "pick" which is used to determine how a restraint body is
      // selected
      util::ShPtr
      <
        find::PickCriteriaInterface
        <
          util::ShPtr< assemble::SSEGeometryInterface>,
          util::ShPtrVector< assemble::SSEGeometryInterface>, assemble::SSEGeometryInterface
        >
      > pick
      (
        // picker_random.Clone()
        picker_extent.Clone()
      );

      if( GetFlagBodyRestraint()->GetFlag())
      {
        GetMutates().AddMutate
        (
          MutateProteinModelSSESwapBody
          (
            GetBodyRestraint(),
            pick,
            sp_locator_sse_random,
            "sse_em_move_into_empty_body"
          )
        );
      }

      GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveTranslateRandom( linal::Vector3D( 0.0, 0.0, 1.0), true)), false)), //for EM-Fold refinement step
          "sse_em_translate_random_z"
        )
      );

      GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( linal::Vector3D( math::g_Pi / 8.0, math::g_Pi / 8.0, 0), true)), false)), //for EM-Fold refinement step
          "sse_em_rotate_random_xy"
        )
      );

      GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_sse_random,
          util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( util::CloneToShPtr( coord::MoveRotateRandom( linal::Vector3D( 0.0, 0.0, math::g_Pi / 2.0), true)), false)), //for EM-Fold refinement step
          "sse_em_rotate_random_z"
        )
      );

      // get flips
      const util::ShPtr< coord::MoveInterface> x_flip( coord::MoveRotateDefined::GetFlipMove( coord::GetAxes().e_X).Clone());
      const util::ShPtr< coord::MoveInterface> y_flip( coord::MoveRotateDefined::GetFlipMove( coord::GetAxes().e_Y).Clone());
      const util::ShPtr< coord::MoveInterface> z_flip( coord::MoveRotateDefined::GetFlipMove( coord::GetAxes().e_Z).Clone());

      GetMutates().AddMutate( MutateProteinModelSSE( sp_locator_sse_random, util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( x_flip, false)), "sse_em_flip_x"));
      GetMutates().AddMutate( MutateProteinModelSSE( sp_locator_sse_random, util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( y_flip, false)), "sse_em_flip_y"));
      GetMutates().AddMutate( MutateProteinModelSSE( sp_locator_sse_random, util::CloneToShPtr( math::MutateMoveWrapper< assemble::SSE>( z_flip, false)), "sse_em_flip_z"));

      GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModelSSE
          (
            sp_locator_sse_random,
            util::CloneToShPtr
            (
              MutateSSEBendRandom
              (
                math::Range< double>( math::Angle::Radian( -5.0), math::Angle::Radian( 5.0)),
                math::Range< double>( math::Angle::Radian( -5.0), math::Angle::Radian( 5.0))
              )
            ),
            "sse_em_bend_random_small"
          )
        )
      );

    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolEM::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      // reset all the probabilities
      MUTATE_TREE.Reset();

      // if refinement flag given
      if( GetFlagEMRefinement()->GetFlag())
      {
        // first choose probabilities for add, remove, swap, move
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Add,    0.00);
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Remove, 0.00);
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Swap,   0.00);
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSE,   1.00);

        // now assign probabilities for individual mutates
        MUTATE_TREE.SetMutateProbability( "sse_em_bend_random_small",  10.0);
        MUTATE_TREE.SetMutateProbability( "sse_em_translate_random_z",  7.0);
        MUTATE_TREE.SetMutateProbability( "sse_em_rotate_random_xy",    7.0);
        MUTATE_TREE.SetMutateProbability( "sse_em_rotate_random_z",     7.0);
        MUTATE_TREE.SetMutateProbability( "sse_em_flip_z",              1.0);
      }

      // else if regular em protocol
      else
      {
        // first choose probabilities for add, remove, swap, move
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Add,    0.08);
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Remove, 0.15);
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Swap,   0.5);
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSE,   1.5);

        // now assign probabilities for individual mutates
        // adds
        // if the body restraint flag is given
        if( GetFlagBodyRestraint()->GetFlag())
        {
          MUTATE_TREE.SetMutateProbability( "add_em_sse_into_body_null",   1.0);
          MUTATE_TREE.SetMutateProbability( "add_em_sse_into_body_flip_x", 1.0);
          MUTATE_TREE.SetMutateProbability( "add_em_sse_into_body_flip_y", 1.0);
          MUTATE_TREE.SetMutateProbability( "add_em_sse_into_body_flip_z", 1.0);
        }
        // removes
        MUTATE_TREE.SetMutateProbability( "remove_em_random",   0.5);
        // swaps
        MUTATE_TREE.SetMutateProbability( "swap_em_sses",          0.7);
        MUTATE_TREE.SetMutateProbability( "swap_em_sse_with_pool", 0.3);
        MUTATE_TREE.SetMutateProbability( "swap_em_sse_with_pool_overlap_single_swap_only", 0.3);
        // moves
        MUTATE_TREE.SetMutateProbability( "sse_em_flip_x",          1.0);
        MUTATE_TREE.SetMutateProbability( "sse_em_flip_y",          1.0);
        MUTATE_TREE.SetMutateProbability( "sse_em_flip_z",          1.0);
        MUTATE_TREE.SetMutateProbability( "sse_em_rotate_random_z", 1.0);

        // if the body restraint flag is given
        if( GetFlagBodyRestraint()->GetFlag())
        {
          MUTATE_TREE.SetMutateProbability( "sse_em_move_into_empty_body", 3.0);
        }

        if( sspred::Methods::GetFlagReadSSPredictions()->GetFlag())
        {
          MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEResizeCTerm, 10.0);
          MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEResizeNTerm, 10.0);
        }
      }
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolEM::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolEM::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolEM::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Protocol for Using EM Density Maps");
      serializer.AddInitializer
        (
         "body restraint score",
         "score associated with the body restraint",
         io::Serialization::GetAgent( &e_BodyRestraintScore)
         );
      serializer.AddInitializer
        (
         "body connectivity score",
         "score associated with body connectivity",
         io::Serialization::GetAgent( &e_BodyConnectivityDensityScore)
         );
      serializer.AddInitializer
        (
         "density agreement score",
         "score associated with density agreement",
         io::Serialization::GetAgent( &m_DensityAgreementScores)
         );
      serializer.AddInitializer
        (
         "density map",
         "density map associated with the density agreement scores",
         io::Serialization::GetAgent( &m_AgreementScoreDensityMap)
         );

      return serializer;
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns string containing short description of the protocol
    //! @return string containing short description of the protocol
    const std::string &ProtocolEM::GetDescription() const
    {
      // initialize description string
      static const std::string s_description
      (
        "EM protocol folds proteins into medium resolution density maps"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolEM::GetReadMe() const
    {
      // create a static string to hold readme information
      static const std::string s_readme_text
      (
        "The EM protocol, or BCL::EMFold, folds proteins into medium resolution density maps. "
        "The Monte Carlo algorithm randomly samples moves that place predicted helices "
        "from the pool into these density rods. The results of the moves are scored by "
        "knowledge-based scores as well as scores that evaluate the agreement of the model "
        "with the experimental density map.\n\n"
        "When using BCL::EMFold in a publication, please cite the following "
        "publication describing the application's development:\n\n"
        "Lindert, S., Staritzbichler, R., Wotzel, N., Karakas, M., Stewart, P.L., "
        "and Meiler, J. (2009). EM-fold: De novo folding of alpha-helical proteins "
        "guided by intermediate-resolution electron microscopy density maps. "
        "Structure 17, 990-1003.\n\n"
        "Example command line flags for assembly:            \n"
        "-protocols EM                                       \n"
        "-nmodels 1                                          \n"
        "-fasta ????A.fasta                                  \n"
        "-pool ????.pool                                     \n"
        "-mc_number_iterations 2000 400                      \n"
        "-mc_temperature_fraction 0.25 0.05                  \n"
        "-protein_storage ./pdbs/                            \n"
        "-body_restraint ????.cst_body 2.5 2.5 5.0 5.0 -1.0  \n"
        "-print_body_assignment                              \n"
        "-message_level Critical                             \n"
        "-score_weightset_read ????.score                    \n"
        "-score_density_connectivity ????.mrc                \n"
        "-sspred JUFO PSIPRED                                \n"
        "-sspred_path_prefix ./sspred/ 1X91                  \n\n"
        "Example command line flags for refinement:          \n"
        "-protocols EM                                                            \n"
        "-nmodels 1                                                               \n"
        "-native ????.pdb                                                         \n"
        "-use_native_pool                                                         \n"
        "-quality RMSD                                                            \n"
        "-start_model ????_start.pdb                                              \n"
        "-score_density_agreement ????.mrc 4.6 TrilinearInterpolationGaussian CCC \n"
        "-fasta ????A.fasta                                                       \n"
        "-mc_number_iterations 2000 400                                           \n"
        "-mc_temperature_fraction 0.25 0.05                                       \n"
        "-protein_storage ./pdbs/                                                 \n"
        "-score_weightset_read ????.score                                         \n"
        "-em_refinement                                                           \n\n"
        "Speficific flags:\n"
        "-body_restraint ????.cst_body 500 1.0 1.0 2.0 2.0 -1.0 true \nThe file containing "
        "the restraints extracted from the density map, the weight for the occupancy score, "
        "and parameters describing the shape of the potential used in the occupancy score. "
        "-score_weightset weights_assembly.score The score file detailing which scores to use. "
        "-mc_number_iterations 2000 500 The number of total steps (2000) as well as rejected "
        "steps in a row (500) before the Monte Carlo search is stopped. \n\n"
        "The restraint file encodes the density rods as helices and looks "
        "like the following:\n\n"
        "SEQRES   1 A  152  PRO PRO LYS TRP LYS VAL LYS LYS GLN LYS LEU ALA GLU\n"
        "SEQRES   2 A  152  LYS ALA ALA ARG GLU ALA GLU LEU THR ALA LYS LYS ALA\n"
        "SEQRES   3 A  152  GLN ALA ARG GLN ALA LEU SER ILE TYR LEU ASN LEU PRO\n"
        "SEQRES   4 A  152  THR LEU ASP GLU ALA VAL ASN THR LEU LYS PRO TRP TRP\n"
        "SEQRES   5 A  152  PRO GLY LEU PHE ASP GLY ASP THR PRO ARG LEU LEU ALA\n"
        "SEQRES   6 A  152  CYS GLY ILE ARG ASP VAL LEU LEU GLU ASP VAL ALA GLN\n"
        "SEQRES   7 A  152  ARG ASN ILE PRO LEU SER HIS LYS LYS LEU ARG ARG ALA\n"
        "SEQRES   8 A  152  MET LYS ALA ILE THR ARG SER GLU SER TYR LEU CYS ALA\n"
        "SEQRES   9 A  152  MET LYS ALA GLY ALA CYS ARG TYR ASP THR GLU GLY TYR\n"
        "SEQRES  10 A  152  VAL THR GLU HIS ILE SER GLN GLU GLU GLU VAL TYR ALA\n"
        "SEQRES  11 A  152  ALA GLU ARG LEU ASP LYS ILE ARG ARG GLN ASN ARG ILE\n"
        "SEQRES  12 A  152  LYS ALA GLU LEU GLN ALA VAL LEU ASP\n"
        "HELIX    1   1 PRO A    2  SER A   33  1                                  32\n"
        "HELIX    5   5 GLY A   67  ARG A   79  1                                  13\n"
        "HELIX    6   6 SER A   84  ARG A   97  1                                  14\n"
        "HELIX    8   8 SER A  123  ASP A  152  1                                  30\n"
        "ATOM      8  N   PRO A   2     -34.913  10.141  21.737  1.00 45.99           N\n"
        "ATOM      9  CA  PRO A   2     -34.039  10.544  20.632  1.00 46.41           C\n"
        "ATOM     10  C   PRO A   2     -32.544  10.299  20.814  1.00 47.36           C\n"
        "ATOM     11  O   PRO A   2     -32.078   9.922  21.893  1.00 48.61           O\n"
        "ATOM     12  CB  PRO A   2     -34.341  12.030  20.469  1.00 45.93           C\n"
        "ATOM     13  CG  PRO A   2     -35.724  12.173  21.015  1.00 46.71           C\n"
        "ATOM     14  CD  PRO A   2     -35.693  11.293  22.226  1.00 46.13           C\n"
        "ATOM     15  N   LYS A   3     -31.807  10.533  19.730  1.00 47.24           N\n"
        "....\n\n"
        "The score file specifies used scores and should look like the following:\n\n"
        "bcl::storage::Table<double>         nr         co       rgyr     aadist   aasmooth "
        "aaneigh      aavmd     aanvec    annsasa      aaols    loop   ssepack_fr  strand_fr "
        "sum       rmsd    rmsd100\n"
        "weights                              0          0          0          0          0  "
        "0          0          0          0          0     265          0         0          "
        "0          0          0"
      );

      // return readme information
      return s_readme_text;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolEM::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolEM::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief creates the mutates for adding SSEs into the Protein model into body restraints
    void ProtocolEM::InitializeBodyAddMutates()
    {
      // initialize ssepool picker
      const util::ShPtr
      <
        find::PickCriteriaWrapper
        <
          util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::DomainInterface
        >
      > sp_picker_pool
      (
        new find::PickCriteriaWrapper
        <
          util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::DomainInterface
        >( assemble::PickSSERandom())
      );

      // set the random picker
      const find::PickCriteriaWrapper
      <
        util::ShPtr< assemble::SSEGeometryInterface>,
        util::ShPtrVector< assemble::SSEGeometryInterface>,
        assemble::SSEGeometryInterface
      >
      picker_random =
        find::PickCriteriaWrapper
        <
          util::ShPtr< assemble::SSEGeometryInterface>,
          util::ShPtrVector< assemble::SSEGeometryInterface>,
          assemble::SSEGeometryInterface
        >( find::PickBodyRandom());

      // set extent tolerances for the length extent picker
      // these tolerances are set to discriminate between helices and strands only, no length discrimination
      linal::Vector3D extent_tolerances( 0.1, 0.1, 50.0);

      // important this is only half the length!!
//      linal::Vector3D extent_tolerances( 0.5, 0.5, 5.0);

      // set the length extent picker
      const find::PickBodyExtent picker_extent( extent_tolerances, extent_tolerances);

      // create ShPtr to a PickCriteriaInterface "pick" which is used to determine how a restraint body is
      // selected
      util::ShPtr
      <
        find::PickCriteriaInterface
        <
          util::ShPtr< assemble::SSEGeometryInterface>,
          util::ShPtrVector< assemble::SSEGeometryInterface>, assemble::SSEGeometryInterface
        >
      > pick
      (
        // picker_random.Clone()
        picker_extent.Clone()
      );

      // create MutateTransformationMatrix3DNull for placing the sse into the body with the same orientation as the
      // body
      util::ShPtr< math::MutateInterface< math::TransformationMatrix3D> > orientation_null
      (
        new restraint::MutateTransformationMatrix3DNull()
      );

      // create MutateTransformationMatrix3DRotate for placing the sse into the body with the opposite orientation
      //  as the body according to the x-axis
      util::ShPtr< math::MutateInterface< math::TransformationMatrix3D> > orientation_flip_x_axis
      (
        new restraint::MutateTransformationMatrix3DRotate( coord::GetAxes().e_X, math::g_Pi, math::g_Pi)
      );

      // create MutateTransformationMatrix3DRotate for placing the sse into the body with the opposite orientation
      //  as the body according to the Y-axis
      util::ShPtr< math::MutateInterface< math::TransformationMatrix3D> > orientation_flip_y_axis
      (
        new restraint::MutateTransformationMatrix3DRotate( coord::GetAxes().e_Y, math::g_Pi, math::g_Pi)
      );

      // create MutateTransformationMatrix3DRotate for placing the sse into the body with orientation
      //  rotated with respect to the z-axis
      util::ShPtr< math::MutateInterface< math::TransformationMatrix3D> > orientation_rotate_z_axis
      (
        new restraint::MutateTransformationMatrix3DRotate( coord::GetAxes().e_Z, 2 * math::g_Pi, 0.0)
      );

    ////////////////
    // placements //
    ////////////////

      // create placement which just places an sse into a random body with matching orientations
      util::ShPtr< PlacementInterface< assemble::SSE, assemble::ProteinModel> > placement_null
      (
        new PlacementSSEIntoBody( GetBodyRestraints()->FirstElement(), pick, orientation_null)
      );

      // create placement which places an sse into a random body with orientation flipped by x-axis
      util::ShPtr< PlacementInterface< assemble::SSE, assemble::ProteinModel> > placement_flip_x
      (
        new PlacementSSEIntoBody( GetBodyRestraints()->FirstElement(), pick, orientation_flip_x_axis)
      );

      // create placement which places an sse into a random body with orientation flipped by y-axis
      util::ShPtr< PlacementInterface< assemble::SSE, assemble::ProteinModel> > placement_flip_y
      (
        new PlacementSSEIntoBody( GetBodyRestraints()->FirstElement(), pick, orientation_flip_y_axis)
      );

      // create placement which places an sse into a random body with orientation rotated about z-axis
      util::ShPtr< PlacementInterface< assemble::SSE, assemble::ProteinModel> > placement_rotate_z
      (
        new PlacementSSEIntoBody( GetBodyRestraints()->FirstElement(), pick, orientation_rotate_z_axis)
      );

      GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModelSSEAdd( sp_picker_pool, placement_null, "add_em_sse_into_body_null")
        )
      );

      GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModelSSEAdd( sp_picker_pool, placement_flip_x, "add_em_sse_into_body_flip_x")
        )
      );

      GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModelSSEAdd( sp_picker_pool, placement_flip_y, "add_em_sse_into_body_flip_y")
        )
      );

      GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModelSSEAdd( sp_picker_pool, placement_rotate_z, "add_em_sse_into_body_flip_z")
        )
      );
    }

    //! @brief return body restraint
    //! @return body restraint
    util::ShPtr< restraint::Body> ProtocolEM::GetBodyRestraint()
    {
    /////////////////////////////////////////////////////////////////////
    // move into empty density rod (specific to EM-Fold assembly step) //
    /////////////////////////////////////////////////////////////////////

      // create stream to restraint file
      io::IFStream read;
      io::File::MustOpenIFStream( read, GetFlagBodyRestraint()->GetFirstParameter()->GetValue());
      BCL_MessageStd
      (
        "read restraint file: " + GetFlagBodyRestraint()->GetFirstParameter()->GetValue()
      );

      // construct handler body in order to read in the restraints
      // (handler body is constructed with a method for determining if a restraint body is occupied)
      restraint::HandlerBody handler_body
      (
        // HandlerBody is constructed from ShPrt to FunctionInterface
        // (is method to determine if a restraint body is occupied, takes two coord::Bodies and returns bool)
        util::ShPtr< util::BinaryFunctionInterface< assemble::SSEGeometryInterface, assemble::SSE, bool> >
        (
          // this is derived from FunctionInterface and is method to determine if a restraint body is occupied
          new restraint::ContainsBodyOrigin()
        )
      );
      // returns the restraint::Body that HandlerBody created
      // although there is a ShPtrVector, there is only one restraint::Body per HandlerBody
      // this is the size where the fragment lengths are changed!!
      util::ShPtrVector< restraint::Body> density_map( handler_body.CreateRestraintsBody( read));
      io::File::CloseClearFStream( read);
      return density_map.FirstElement();
    }

    //! @brief GetScoresDensityAgreement creates the score objects for density agreement scores
    util::ShPtrVector< score::ProteinModel>
    ProtocolEM::GetScoresDensityAgreement()
    {
      const util::ShPtr< command::FlagStaticAndDynamic> agreement_scores_flag( GetFlagScoreDensityAgreement());

      // all parameters
      const util::ShPtrVector< command::ParameterInterface> &parameters
      (
        agreement_scores_flag->GetParameterList()
      );

      // mrc filename
      const std::string mrc_filename( parameters( 0)->GetValue());

      // resolution
      const double resolution_density_map( parameters( 1)->GetNumericalValue< double>());

      // density simulator
      const density::Simulator simulator( parameters( 2)->GetValue());

      // density agreement score
      storage::Set< density::ProteinAgreement> agreement_scores;
      for( util::ShPtrVector< command::ParameterInterface>::const_iterator itr( parameters.Begin() + 3), itr_end( parameters.End()); itr != itr_end; ++itr)
      {
        agreement_scores.Insert( density::ProteinAgreement( ( *itr)->GetValue()));
      }

      // protein model scores
      util::ShPtrVector< score::ProteinModel> protein_model_scores;

      if( agreement_scores.IsEmpty())
      {
        return protein_model_scores;
      }

      // instantiate Densitymap from mrc file
      io::IFStream read;
      m_AgreementScoreDensityMap = density::Map();
      BCL_MessageStd( "open density map: " + mrc_filename);
      BCL_Assert
      (
        io::File::TryOpenIFStream( read, mrc_filename, std::ios::binary),
        "unable to open file " + util::Format()( mrc_filename)
      );
      m_AgreementScoreDensityMap.ReadMRC( read, 0);
      io::File::CloseClearFStream( read);
      BCL_MessageStd( "density map has been read: " + mrc_filename);

      // SiPtr to m_AgreementScoreDensityMap
      util::SiPtr< density::Map> sp_map( new density::Map( m_AgreementScoreDensityMap));
      // iterate over all requested agreement scores and construct a protein model score
      for
      (
        storage::Set< density::ProteinAgreement>::const_iterator
          itr( agreement_scores.Begin()), itr_end( agreement_scores.End());
        itr != itr_end;
        ++itr
      )
      {
        protein_model_scores.PushBack
        (
          density::GetProteinAgreements().CreateProteinAgreement
          (
            *itr, simulator, sp_map, resolution_density_map
          )
        );
      }

      // return all scores
      return protein_model_scores;
    }

    //! @brief GetScoreBodyConnectivityDensity creates the score object for density connectivity score
    util::ShPtr< score::ProteinModel>
    ProtocolEM::GetScoreBodyConnectivityDensity()
    {
      // get restraints
      const util::ShPtr< restraint::Body> body_restraints( GetBodyRestraint());

      // instantiate Densitymap from mrc file
      io::IFStream read;
      util::ShPtr< density::Map> density_map( new density::Map);
      const std::string mrc_filename( GetFlagScoreDensityConnectivity()->GetFirstParameter()->GetValue());

      BCL_MessageStd( "open density map: " + mrc_filename);
      BCL_Assert
      (
        io::File::TryOpenIFStream( read, mrc_filename, std::ios::binary),
        "unable to open file " + util::Format()( mrc_filename)
      );
      density_map->ReadMRC( read, 0);
      io::File::CloseClearFStream( read);

      BCL_MessageStd( "density map has been read: " + mrc_filename);

      // construct density connectivity score
      util::ShPtr< score::ProteinModel> density_connectivity_score
      (
        new score::BodyConnectivityDensity( body_restraints, density_map)
      );

      //return density connectivity score
      return density_connectivity_score;
    }

    //! @brief GetBodyRestraintScore creates the scoring object for use with the body restraint
    //! @return the scoring object for use with the body restraint
    util::ShPtr< score::ProteinModel> ProtocolEM::GetScoreBodyRestraint()
    {
      const double upper_tolerance( GetFlagBodyRestraint()->GetParameterList()( 1)->GetNumericalValue< double>());
      const double lower_tolerance( GetFlagBodyRestraint()->GetParameterList()( 2)->GetNumericalValue< double>());
      const double upper_transition( GetFlagBodyRestraint()->GetParameterList()( 3)->GetNumericalValue< double>());
      const double lower_transition( GetFlagBodyRestraint()->GetParameterList()( 4)->GetNumericalValue< double>());
      const double energy_well_depth( GetFlagBodyRestraint()->GetParameterList()( 5)->GetNumericalValue< double>());

      // create score::BodyAssignment "assignment_score" as method for scoring agreement with a body restraint
      score::BodyAssignment assignment_score
      (
        util::ShPtr< math::BinaryFunctionInterface< assemble::SSEGeometryInterface, assemble::SSE, double> >
        (
          new score::BodyExtentAgreement
          (
            lower_tolerance,     //< lower tolerance
            lower_transition,    //< lower transition width
            upper_tolerance,     //< upper tolerance
            upper_transition,    //< upper transition width
            energy_well_depth,   //< energy well depth
            coord::GetAxes().e_Z //< axis of interest
          )
        )
      );

      // create score::Restraint "score_restraints" and return it
      return
      util::ShPtr< score::ProteinModel>
      (
        new score::RestraintBodyProteinModel
        (
          GetBodyRestraints(),
          // initialize with ShPtr to a function interface "assignment_score"
          assignment_score
        )
      );
    }

    //! @brief singleton function for creating static body restraints to be used during folding
    const util::ShPtr< util::ShPtrVector< restraint::Body> >
    &ProtocolEM::GetBodyRestraints()
    {
      // declare static variable restraints
      static
      util::ShPtr< util::ShPtrVector< restraint::Body> > restraints;

      // if restraints are not initialized
      if( !restraints.IsDefined())
      {
        // create HandlerAtomDistanceAssigned "handler" as method for determining if a restraint body is occupied
        restraint::HandlerBody handler
        (
          util::ShPtr< util::BinaryFunctionInterface< assemble::SSEGeometryInterface, assemble::SSE, bool> >
          (
            new restraint::ContainsBodyOrigin()
          )
        );

        // create string "restraint_filename" which has path for example restraint file
        const std::string restraint_filename( GetFlagBodyRestraint()->GetFirstParameter()->GetValue());

        // create stream to restraint file
        io::IFStream read;
        io::File::MustOpenIFStream( read, restraint_filename);
        BCL_MessageStd( "read restraint file: " + restraint_filename);

        // create restraints
        // initialize ShPtrVector with restraints from "restraint_filename"
        restraints = util::CloneToShPtr( handler.CreateRestraintsBody( read));

        io::File::CloseClearFStream( read);
      }

      // return
      return restraints;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_protein_model_conformation_by_score.h"
#include "assemble/bcl_assemble_printer_protein_model_ensemble.h"
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "fold/bcl_fold_protocol_ensemble.h"
#include "fold/bcl_fold_setup.h"
#include "mc/bcl_mc_printer_combined.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProtocolEnsemble::s_Instance
    (
      GetObjectInstances().AddInstance( new ProtocolEnsemble())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolEnsemble::ProtocolEnsemble()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolEnsemble
    ProtocolEnsemble *ProtocolEnsemble::Clone() const
    {
      return new ProtocolEnsemble( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolEnsemble::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolEnsemble::GetAlias() const
    {
      static const std::string s_name( "ProtocolEnsemble");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolEnsemble::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol to be applied to fold ensemble of models");

      return serializer;
    }

//    util::ShPtr< math::FunctionInterfaceSerializable< assemble::ProteinModel, double> > &ProtocolEnsemble::GetScore()
//    {
//      static util::ShPtr< math::FunctionInterfaceSerializable< assemble::ProteinModel, double> > s_score( new score::ProteinModelScoreSum());
//
//      return s_score;
//    }

//    util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
//    ProtocolEnsemble::GetMutateProteinModelSwitchConformation
//    (
//      const util::ShPtr< math::FunctionInterfaceSerializable< assemble::ProteinModel, double> > &SCORE
//    )
//    {
//      find::Locator
//      <
//        util::SiPtr< const assemble::ProteinModel>,
//        assemble::ProteinModel,
//        util::SiPtrList< const assemble::ProteinModel>
//      >
//      worst_score_locator
//      (
//        util::ShPtr< assemble::CollectorProteinModelConformationByScore> //< collector
//        (
//          new assemble::CollectorProteinModelConformationByScore
//          (
//            SCORE,
//            1, //< collect single worst
//            util::ShPtr< util::BinaryFunctionInterface< double, double, bool> >
//            (
//              new util::BinaryFunctionSTLWrapper< std::greater< double> >() //< sort by worst score
//            ),
//            true //< do consider current conformation
//          )
//        ),
//        util::ShPtr< assemble::PickProteinModelConformationRandom>( new assemble::PickProteinModelConformationRandom())//< picker
//      );
//
//      util::ShPtr< math::MutateInterface< assemble::ProteinModel> > mutate
//      (
//        new MutateProteinModelSwitchConformation
//        (
//          util::ShPtr
//          <
//            find::LocatorInterface< util::SiPtr< const assemble::ProteinModel>, assemble::ProteinModel>
//          >
//          (
//            worst_score_locator.Clone()
//          ),
//          "ensemble_swtch_conf_wrst_scr"
//        )
//      );
//
//      return mutate;
//    }
//
//    util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
//    ProtocolEnsemble::GetMutateCombineProteinModelSwitchConformation
//    (
//      const util::ShPtr< math::FunctionInterfaceSerializable< assemble::ProteinModel, double> > &SCORE,
//      const util::ShPtr< math::MutateInterface< assemble::ProteinModel> > &MUTATE
//    )
//    {
//      util::ShPtrList< math::MutateInterface< assemble::ProteinModel> > mutates;
//      mutates.PushBack( GetMutateProteinModelSwitchConformation( SCORE));
//      mutates.PushBack( MUTATE);
//
//      util::ShPtr< math::MutateInterface< assemble::ProteinModel> > combine
//      (
//        new math::MutateCombine< assemble::ProteinModel>( mutates, true, "ensemble_combine")
//      );
//
//      return combine;
//    }

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolEnsemble &ProtocolEnsemble::GetInstance()
    {
      static ProtocolEnsemble s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief return command line flag for specifying the domains
    //! @return command line flag for specifying domains
    util::ShPtr< command::FlagInterface> &ProtocolEnsemble::GetFlagEnsembleSize()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "ensemble_size",
          "\tThe size of the ensemble that should be used at the start of folding. "
          "i.e. how many models should be in the ensemble to start with.",
          command::Parameter( "number", "\tstart size of ensemble", "1")
        )
      );

      return s_flag;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolEnsemble::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // insert all the flags in the vector
        s_all_flags_vector.PushBack( GetFlagEnsembleSize());
      }

      // end
      return s_all_flags_vector;
    }

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolEnsemble::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      const size_t start_ensemble_size( GetFlagEnsembleSize()->GetFirstParameter()->GetNumericalValue< size_t>() - 1);
      if( !START_MODEL.GetConformationalEnsemble().IsEmpty())
      {
        BCL_MessageCrt
        (
          "conformation ensemble is not empty so not modifying start model\nSize is "
          + util::Format()( START_MODEL.GetConformationalEnsemble().GetSize())
        );
        return;
      }

      util::ShPtr< assemble::ProteinModelData> pmd_here( START_MODEL.GetProteinModelData());

      BCL_Assert( pmd_here->GetData( assemble::ProteinModelData::e_Pool).IsDefined(), "pool is not defined");

      BCL_MessageCrt( "model type is " + START_MODEL.GetClassIdentifier());

      // ensemble for folding
      assemble::ProteinEnsemble ensemble;

      // insert as the start model as many times as desired into the ensemble
      for( size_t num( 0); num < start_ensemble_size; ++num)
      {
        util::ShPtr< assemble::ProteinModel> new_model( START_MODEL.HardCopy());

        util::ShPtr< assemble::ProteinModelData> pmd( new_model->GetProteinModelData());
        BCL_Assert( pmd_here->GetData( assemble::ProteinModelData::e_Pool).IsDefined(), "START_MODEL pool is not defined");
        BCL_Assert
        (
          pmd->GetData( assemble::ProteinModelData::e_Pool).IsDefined(),
          "pool is not defined during multiplying creation"
        );

        ensemble.InsertElement( new_model);
      }

      START_MODEL.SetConformationalEnsemble( ensemble);

      for
      (
        assemble::ProteinEnsemble::const_iterator
          itr( START_MODEL.GetConformationalEnsemble().Begin()), itr_end( START_MODEL.GetConformationalEnsemble().End());
        itr != itr_end;
        ++itr
      )
      {
        util::ShPtr< assemble::ProteinModelData> pmd( ( *itr)->GetProteinModelData());

        BCL_Assert( pmd->GetData( assemble::ProteinModelData::e_Pool).IsDefined(), "pool is not defined after ensemble creation");
      }

      BCL_MessageCrt( "ensemble size is " + util::Format()( START_MODEL.GetConformationalEnsemble().End() - START_MODEL.GetConformationalEnsemble().Begin()));
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolEnsemble::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolEnsemble::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsemble::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsemble::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
      util::ShPtr< mc::PrintInterface< assemble::ProteinModel, double> > ensemble_printer
      (
        new assemble::PrinterProteinModelEnsemble
        (
          GetSetup().GetPrefix(),
          GetSetup().GetStorage(),
          GetSetup().GetSuperimposeMeasure()
        )
      );
      PRINTER.Insert( ensemble_printer);
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsemble::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolEnsemble::InitializeMutates()
    {

//
//      e_MutateEnsembleCombineSwitchConformationWorstScore = GetMutates().AddMutate
//      (
//        GetMutateCombineProteinModelSwitchConformation
//        (
//          util::ShPtr< math::FunctionInterfaceSerializable< assemble::ProteinModel, double> >( new score::ProteinModelScoreSum()),
//          util::ShPtr< math::MutateInterface< assemble::ProteinModel> >( new math::MutateDecisionNode< assemble::ProteinModel>())
//        )
//      );
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolEnsemble::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
//      const storage::Vector< double> mutate_type_probs( MUTATE_TREE.GetMutateTypeProbabilities().GetMappedValues());
//
//      const double total_probabilities( math::Statistics::Sum( mutate_type_probs.Begin(), mutate_type_probs.End()));
//
//      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Ensemble, total_probabilities);
//
//      MUTATE_TREE.SetMutateProbability( e_MutateEnsembleSwitchConformationWorstScore, 1);
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolEnsemble::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolEnsemble::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolEnsemble::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "protocol to be applied to fold ensemble of models"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolEnsemble::GetReadMe() const
    {
      // TODO: add readme for this protocol
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "readme for ensemble folding"
      );

      // end
      return s_readme;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolEnsemble::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolEnsemble::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////
  
  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_ensemble_filter.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_protein_model_conformation_by_score.h"
#include "assemble/bcl_assemble_printer_protein_model_ensemble.h"
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "command/bcl_command_flag_dynamic.h"
#include "command/bcl_command_parameter.h"
#include "fold/bcl_fold_score_weight_set.h"
#include "fold/bcl_fold_setup.h"
#include "io/bcl_io_file.h"
#include "mc/bcl_mc_printer_combined.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProtocolEnsembleFilter::s_Instance
    (
      GetObjectInstances().AddInstance( new ProtocolEnsembleFilter())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolEnsembleFilter::ProtocolEnsembleFilter()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolEnsembleFilter
    ProtocolEnsembleFilter *ProtocolEnsembleFilter::Clone() const
    {
      return new ProtocolEnsembleFilter( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolEnsembleFilter &ProtocolEnsembleFilter::GetInstance()
    {
      static ProtocolEnsembleFilter s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolEnsembleFilter::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolEnsembleFilter::GetAlias() const
    {
      static const std::string s_name( "ProtocolEnsembleFilter");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolEnsembleFilter::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Protocol to be applied for filtering an ensemble.");

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolEnsembleFilter::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // insert all the flags in the vector
        s_all_flags_vector.PushBack( GetFlagFilterScoreFunctions());
        s_all_flags_vector.PushBack( GetFlagFilterNumberToKeep());
      }

      // end
      return s_all_flags_vector;
    }

    //! @brief return command line flag for specifying the domains
    //! @return command line flag for specifying domains
    util::ShPtr< command::FlagInterface> &ProtocolEnsembleFilter::GetFlagFilterScoreFunctions()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagDynamic
        (
          "ensemble_filter_score_weights",
          "\tFilenames of score weight table formated files that will be used to construct score functions. The score"
          " functions will be used to filter the conformational ensemble. Multiple filenames can be provided. This"
          " flag should be used in conjunction with the \"ensemble_filter_num_to_keep\" flag. One weight file per"
          " number provided to that flag. According to each score function, the best N models will be kept.",
          command::Parameter( "score_weight_table_filename", "\tscore weight table filenames", "score_weights.tbl")
        )
      );

      return s_flag;
    }

    //! @brief return command line flag for specifying the domains
    //! @return command line flag for specifying domains
    util::ShPtr< command::FlagInterface> &ProtocolEnsembleFilter::GetFlagFilterNumberToKeep()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagDynamic
        (
          "ensemble_filter_number_to_keep",
          "\tThe number of models to keep based on the scoring weight table provided. The score"
          " functions will be used to filter the conformational ensemble. Multiple numbers can be provided. This"
          " flag should be used in conjunction with the \"ensemble_filter_score_weights\" flag. One weight file per"
          " number provided to that flag. According to each score function, the best N models will be kept.",
          command::Parameter( "number_to_keep", "\tsize_t", "1")
        )
      );

      return s_flag;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolEnsembleFilter::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      // get the vector that tells the number of models to keep for each score weight table
      const storage::Vector< int> numbers_to_keep( GetFlagFilterNumberToKeep()->GetNumericalList< int>());

      // get the vector of score weight table files
      const storage::Vector< std::string> score_weight_filenames( GetFlagFilterScoreFunctions()->GetStringList());

      BCL_Assert
      (
        numbers_to_keep.GetSize() == score_weight_filenames.GetSize(),
        "pass the same number of parameters to the flag "
        + GetFlagFilterNumberToKeep()->GetName() + " as passed to the flag "
        + GetFlagFilterScoreFunctions()->GetName()
        + "\nThe number of parameters passed were " + util::Format()( numbers_to_keep.GetSize()) + " and "
        + util::Format()( score_weight_filenames.GetSize()) + ", respectively"
      );

      // to hold all conformations that fulfill scoring filters
      util::SiPtrList< const assemble::ProteinModel> all_conformations;

      // iterate over the number of models to keep and the corresponding score weight table files
      for
      (
        storage::Vector< std::string>::const_iterator
          file_itr( score_weight_filenames.Begin()), file_itr_end( score_weight_filenames.End());
        file_itr != file_itr_end;
        ++file_itr
      )
      {
        // get the number of models to keep for the current score weight table
        const int num_to_keep( *( numbers_to_keep.Begin() + int( file_itr - score_weight_filenames.Begin())));

        BCL_MessageStd
        (
          "keeping " + util::Format()( num_to_keep) + " models for score weight table"
          " file " + *file_itr
        );

        // read in the score weight table
        io::IFStream read;
        io::File::MustOpenIFStream( read, *file_itr);
        storage::Table< double> score_weight_table;
        score_weight_table.ReadFormatted( read);

        // create a score weightset
        const ScoreWeightSet weightset( score_weight_table);

        // create score object to filter the ensemble
        const util::ShPtr< score::ProteinModelScoreSum> score_function( weightset.ConstructScoreSum());

        // create collector to get the models that fulfill the score function criteria
        const assemble::CollectorProteinModelConformationByScore collector
        (
          score_function,
          num_to_keep,
          util::ShPtr< util::BinaryFunctionInterface< double, double, bool> >
          (
            new util::BinaryFunctionSTLWrapper< std::less< double> >() //< collect best
          ),
          true
        );

        // get the conformations that fulfill the score criteria
        const util::SiPtrList< const assemble::ProteinModel> conformations( collector.Collect( START_MODEL));

        // append the conformations to the overall list that are desired
        all_conformations.Append( conformations);
      }

      BCL_MessageStd
      (
        "number conformations passing score filter "
        + util::Format()( all_conformations.GetSize())
      );

      // create new model using first model in the collected conformations
      util::ShPtr< assemble::ProteinModel> new_model( all_conformations.FirstElement()->Clone());

      // remove the first element from the collected conformations
      all_conformations.RemoveElement( all_conformations.Begin());

      // ensemble to hold the rest of the conformations
      assemble::ProteinEnsemble ensemble;

      BCL_MessageStd
      (
        "number conformations to add to ensemble "
        + util::Format()( all_conformations.GetSize())
      );

      // iterate through the rest of the conformations to put them into the ensemble
      for
      (
        util::SiPtrList< const assemble::ProteinModel>::const_iterator
          model_itr( all_conformations.Begin()), model_itr_end( all_conformations.End());
        model_itr != model_itr_end;
        ++model_itr
      )
      {
        // copy the model into a sh ptr
        util::ShPtr< assemble::ProteinModel> current_model( ( *model_itr)->Clone());

        // reset the conformational ensemble of the new model
        current_model->SetConformationalEnsemble( assemble::ProteinEnsemble());

        // insert the new model into the ensemble
        ensemble.InsertElement( current_model);
      }

      // set the conformational ensemble of the new model
      new_model->SetConformationalEnsemble( ensemble);

      START_MODEL = ( *new_model);
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolEnsembleFilter::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolEnsembleFilter::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsembleFilter::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsembleFilter::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
      util::ShPtr< mc::PrintInterface< assemble::ProteinModel, double> > ensemble_printer
      (
        new assemble::PrinterProteinModelEnsemble
        (
          GetSetup().GetPrefix(),
          GetSetup().GetStorage(),
          GetSetup().GetSuperimposeMeasure()
        )
      );
      PRINTER.Insert( ensemble_printer);
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsembleFilter::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolEnsembleFilter::InitializeMutates()
    {
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolEnsembleFilter::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolEnsembleFilter::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolEnsembleFilter::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolEnsembleFilter::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "Protocol to be applied for filtering an ensemble."
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolEnsembleFilter::GetReadMe() const
    {
      // TODO: add readme for this protocol
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "readme for protocol to be applied for filtering an ensemble."
      );

      // end
      return s_readme;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolEnsembleFilter::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolEnsembleFilter::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_ensemble_replicate_conformation.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_protein_model_conformations.h"
#include "assemble/bcl_assemble_printer_protein_model_ensemble.h"
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "fold/bcl_fold_mutate_protein_model_replicate_conformation.h"
#include "fold/bcl_fold_protocol_ensemble.h"
#include "fold/bcl_fold_setup.h"
#include "math/bcl_math_mutate_result.h"
#include "mc/bcl_mc_printer_combined.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProtocolEnsembleReplicateConformation::s_Instance
    (
      GetObjectInstances().AddInstance( new ProtocolEnsembleReplicateConformation())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolEnsembleReplicateConformation::ProtocolEnsembleReplicateConformation()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolEnsembleReplicateConformation
    ProtocolEnsembleReplicateConformation *ProtocolEnsembleReplicateConformation::Clone() const
    {
      return new ProtocolEnsembleReplicateConformation( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolEnsembleReplicateConformation &ProtocolEnsembleReplicateConformation::GetInstance()
    {
      static ProtocolEnsembleReplicateConformation s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolEnsembleReplicateConformation::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolEnsembleReplicateConformation::GetAlias() const
    {
      static const std::string s_name( "ProtocolEnsembleReplicateConformation");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolEnsembleReplicateConformation::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol to be applied for replicating the conformation of a model that is going to be folded.");

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolEnsembleReplicateConformation::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
      }

      // end
      return s_all_flags_vector;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolEnsembleReplicateConformation::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      // add one since the current conformation of focus is not included
      const int num_conformations( START_MODEL.GetConformationalEnsemble().GetSize() + 1);
      const int wanted_size( ProtocolEnsemble::GetFlagEnsembleSize()->GetFirstParameter()->GetNumericalValue< int>());

      // subtract one since if the division gives 1, no replications should take place
      const int num_replications( ( wanted_size - num_conformations) / num_conformations);

      BCL_MessageStd( "number of replications is " + util::Format()( num_replications));

      // create object for replicating the models in the ensemble
      MutateProteinModelReplicateConformation mutate
      (
        util::ShPtr< assemble::CollectorProteinModelConformations>
        (
          new assemble::CollectorProteinModelConformations( true)
        ),
        num_replications
      );

      // copy the models
      math::MutateResult< assemble::ProteinModel> mutate_result( mutate( START_MODEL));

      BCL_MessageStd
      (
        "ensemble size is " +
        util::Format()( mutate_result.GetArgument()->GetConformationalEnsemble().GetSize())
      );

      // set the start model to the result of the mutate - ensemble should have desired size and number of copies
      START_MODEL = ( *mutate_result.GetArgument());
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolEnsembleReplicateConformation::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolEnsembleReplicateConformation::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsembleReplicateConformation::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsembleReplicateConformation::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
      util::ShPtr< mc::PrintInterface< assemble::ProteinModel, double> > ensemble_printer
      (
        new assemble::PrinterProteinModelEnsemble
        (
          GetSetup().GetPrefix(),
          GetSetup().GetStorage(),
          GetSetup().GetSuperimposeMeasure()
        )
      );
      PRINTER.Insert( ensemble_printer);
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsembleReplicateConformation::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolEnsembleReplicateConformation::InitializeMutates()
    {
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolEnsembleReplicateConformation::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolEnsembleReplicateConformation::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolEnsembleReplicateConformation::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolEnsembleReplicateConformation::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "protocol to be applied for replicating the conformation of a model that is going to be folded."
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolEnsembleReplicateConformation::GetReadMe() const
    {
      // TODO: add readme for this protocol
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "readme for replicating the conformation of a model that is being folded when the ensemble protocol is used."
      );

      // end
      return s_readme;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolEnsembleReplicateConformation::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolEnsembleReplicateConformation::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_ensemble_switch_conformation.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_printer_protein_model_ensemble.h"
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "fold/bcl_fold_setup.h"
#include "mc/bcl_mc_printer_combined.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProtocolEnsembleSwitchConformation::s_Instance
    (
      GetObjectInstances().AddInstance( new ProtocolEnsembleSwitchConformation())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolEnsembleSwitchConformation::ProtocolEnsembleSwitchConformation()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolEnsembleSwitchConformation
    ProtocolEnsembleSwitchConformation *ProtocolEnsembleSwitchConformation::Clone() const
    {
      return new ProtocolEnsembleSwitchConformation( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolEnsembleSwitchConformation &ProtocolEnsembleSwitchConformation::GetInstance()
    {
      static ProtocolEnsembleSwitchConformation s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolEnsembleSwitchConformation::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolEnsembleSwitchConformation::GetAlias() const
    {
      static const std::string s_name( "ProtocolEnsembleSwitchConformation");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolEnsembleSwitchConformation::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol to be applied for switching the conformation of a model that is going to be folded.");

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolEnsembleSwitchConformation::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
      }

      // end
      return s_all_flags_vector;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolEnsembleSwitchConformation::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      START_MODEL = ( *SwitchConformation( START_MODEL));
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolEnsembleSwitchConformation::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolEnsembleSwitchConformation::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsembleSwitchConformation::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsembleSwitchConformation::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
      util::ShPtr< mc::PrintInterface< assemble::ProteinModel, double> > ensemble_printer
      (
        new assemble::PrinterProteinModelEnsemble
        (
          GetSetup().GetPrefix(),
          GetSetup().GetStorage(),
          GetSetup().GetSuperimposeMeasure()
        )
      );
      PRINTER.Insert( ensemble_printer);
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolEnsembleSwitchConformation::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolEnsembleSwitchConformation::InitializeMutates()
    {
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolEnsembleSwitchConformation::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolEnsembleSwitchConformation::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolEnsembleSwitchConformation::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolEnsembleSwitchConformation::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "protocol to be applied for switching the conformation of a model that is going to be folded."
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolEnsembleSwitchConformation::GetReadMe() const
    {
      // TODO: add readme for this protocol
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "readme for switching the conformation of a model that is being folded when the ensemble protocol is used."
      );

      // end
      return s_readme;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolEnsembleSwitchConformation::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolEnsembleSwitchConformation::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief changes the conformation of the provided protein model to another conformation it contains
    //! @param PROTEIN_MODEL the model whose conformation will be changed to another conformation it contains
    //! @return a shptr to a protein model that is a copy of the provided protein model but has a different
    //!         conformation of focus
    util::ShPtr< assemble::ProteinModel>
    ProtocolEnsembleSwitchConformation::SwitchConformation( const assemble::ProteinModel &PROTEIN_MODEL)
    {
      // get the conformational ensemble from PROTEIN_MODEL
      assemble::ProteinEnsemble conformations( PROTEIN_MODEL.GetConformationalEnsemble());

      // true if there are no conformations to switch
      if( conformations.IsEmpty())
      {
        BCL_MessageCrt( "There are no conformations to switch, just returning same model");
        return util::ShPtr< assemble::ProteinModel>( PROTEIN_MODEL.Clone());
      }

      // copy the first protein model in the ensemble
      util::ShPtr< assemble::ProteinModel> next_model( ( *conformations.Begin())->Clone());

      // remove the first conformation from the list since it will be the conformation of focus
      conformations.GetEnsembleData().RemoveElement( conformations.Begin());

      // clone PROTEIN_MODEL
      util::ShPtr< assemble::ProteinModel> old_model_copy( PROTEIN_MODEL.Clone());

      // set the conformations in old_model_copy so that it does not have any conformational ensemble on its own
      old_model_copy->SetConformationalEnsemble( assemble::ProteinEnsemble());

      // add old_model_copy to the conformational ensemble
      conformations.InsertElement( conformations.GetSize(), old_model_copy);

      // set the conformations in the new model
      next_model->SetConformationalEnsemble( conformations);

      // return the new model
      return next_model;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_loop_close.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_back_bone_completer.h"
#include "biol/bcl_biol_aa_complete.h"
#include "command/bcl_command_flag_static.h"
#include "fold/bcl_fold_collector_loop_domain.h"
#include "fold/bcl_fold_collector_loop_domain_random.h"
#include "fold/bcl_fold_criterion_loop_closure.h"
#include "fold/bcl_fold_handler_locator_loop_domain.h"
#include "fold/bcl_fold_loop_domain.h"
#include "fold/bcl_fold_mutate_loop_domain_dihedral.h"
#include "fold/bcl_fold_mutate_protein_model_grow_sse.h"
#include "fold/bcl_fold_mutate_protein_model_loop_domain.h"
#include "fold/bcl_fold_mutate_protein_model_loop_domain_ccd.h"
#include "fold/bcl_fold_phi_psi_generator_ramachandran.h"
#include "fold/bcl_fold_protocol_loop_coordinate_add.h"
#include "io/bcl_io_file.h"
#include "mc/bcl_mc_stage.h"
#include "pdb/bcl_pdb_printer_loop_closure.h"
#include "score/bcl_score_phi_psi_with_sspred.h"
#include "score/bcl_score_protein_model_loop_domain_closure.h"
#include "score/bcl_score_protein_model_sse.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolLoopClose::ProtocolLoopClose()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolLoopClose
    ProtocolLoopClose *ProtocolLoopClose::Clone() const
    {
      return new ProtocolLoopClose( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolLoopClose &ProtocolLoopClose::GetInstance()
    {
      static ProtocolLoopClose s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolLoopClose::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolLoopClose::GetAlias() const
    {
      static const std::string s_name( "ProtocolLoopClose");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolLoopClose::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol for closing loops");
      serializer.AddInitializer
        (
         "mutate loop domain CCD",
         "ccd loop domain move to bring end closer to the other side",
         io::Serialization::GetAgent( &e_MutateLoopDomainCCD)
         );
      serializer.AddInitializer
        (
         "mutate loop domain ramachandran",
         "loop domain phi psi change base on ramachandan",
         io::Serialization::GetAgent( &e_MutateLoopDomainRamachandran)
         );
      serializer.AddInitializer
        (
         "score loop domain closure",
         "score associated with loop domain closure",
         io::Serialization::GetAgent( &e_ScoreLoopDomainClosure)
         );
      serializer.AddInitializer
        (
         "score phi psi SSPred close",
         "score associated with the phi psi SS prediction",
         io::Serialization::GetAgent( &e_ScorePhiPsiSSPredClose)
         );

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolLoopClose::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // insert all the flags in the vector
        s_all_flags_vector.PushBack( LoopDomain::GetFlagLoopDomainFilename());
        s_all_flags_vector.PushBack( GetFlagRamachandranMutateProbability());
        s_all_flags_vector.PushBack( GetFlagUseFullFraction());
      }

      // end
      return s_all_flags_vector;
    }

    //! @brief return command line flag for specifying the probability of the mutate which selects a phi or psi change
    //!        from the ramachandran probability map (as opposed to the ccd mutate)
    //! @return command line flag for specifying the probability of the ramachandran phi psi mutate
    util::ShPtr< command::FlagInterface> &ProtocolLoopClose::GetFlagRamachandranMutateProbability()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "loop_rama_mutate_prob",
          "\tthe probability of the ramachandran phi psi mutate occurance"
        )
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_probability
      (
        new command::Parameter
        (
          "probability", "\tthe probability of the ramachandran phi psi mutate occuring", "0.1"
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_probability);
      }

      // end
      return s_flag;
    }

    //! @brief return command line flag for specifying if random fraction is to be used
    //! @return command line flag for specifying if random fraction is to be used
    util::ShPtr< command::FlagInterface> &ProtocolLoopClose::GetFlagUseFullFraction()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "ccd_fraction",
          "\tuse a fraction of the optimal rotation in the cyclic coordinate descent",
          command::Parameter
          (
            "fraction",
            "multiply the angle with a random number in the given range",
            math::Range< double>( 1.0, 1.0).GetString()
          )
        )
      );

      // end
      return s_flag;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolLoopClose::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      // complete the model with coordinates in missing places
      AddLoopCoordinates( START_MODEL);

      // split the coils, where they are not peptide bonded
      SplitCoilsAtNonPetideBond( START_MODEL);

      // add backbone hydrogens
      START_MODEL = *AddNitrogenHydrogens( START_MODEL);

      // initialize empty locator
      util::ShPtr< util::ShPtrList< LocatorLoopDomain> > sp_locator( new util::ShPtrList< LocatorLoopDomain>());

      // if a loop file was provided
      if( LoopDomain::GetFlagLoopDomainFilename()->GetFlag())
      {
        // read the given file
        io::IFStream read;
        io::File::MustOpenIFStream( read, LoopDomain::GetFlagLoopDomainFilename()->GetFirstParameter()->GetValue());

        // update sp_locator with the locators read from file
        *sp_locator = HandlerLocatorLoopDomain().HandleReadMultiple( read, START_MODEL);
      }
      else
      {
        // otherwise create locators using the SSE definitions from the model
        sp_locator = HandlerLocatorLoopDomain().CreateBidirectionalLocatorsForInteriorCoil( START_MODEL);
      }

      // print out the locator information
      for
      (
        util::ShPtrList< LocatorLoopDomain>::const_iterator
          domain_itr( sp_locator->Begin()), domain_itr_end( sp_locator->End());
        domain_itr != domain_itr_end;
        ++domain_itr
      )
      {
        BCL_MessageDbg( ( *domain_itr)->GetIdentification());
      }

      // get the protein model data
      util::ShPtr< assemble::ProteinModelData> sp_model_data( START_MODEL.GetProteinModelData());
      BCL_Assert( sp_model_data.IsDefined(), "sp_model_data is not defined");

      // try to see if the start model already has it
      util::ShPtr< util::ShPtrList< LocatorLoopDomain> > sp_loop_data
      (
        sp_model_data->GetData( assemble::ProteinModelData::e_LoopDomainLocators)
      );

      // if not defined insert it
      if( !sp_loop_data.IsDefined())
      {
        sp_model_data->Insert( assemble::ProteinModelData::e_LoopDomainLocators, sp_locator);
      }
      // otherwise replace it
      else
      {
        sp_model_data->Replace( assemble::ProteinModelData::e_LoopDomainLocators, sp_locator);
      }
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolLoopClose::InitializeScores()
    {
      // score to help align the atoms desired to be superimposed in order for the loop to be closed
      e_ScoreLoopDomainClosure = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelLoopDomainClosure()
          )
        )
      );

      // phi psi for loop building with ss prediction
      e_ScorePhiPsiSSPredClose = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSE
            (
              Scores::WrapCacheSSEScore
              (
                util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >
                (
                  new score::PhiPsiWithSSPred
                  (
                    sspred::Methods::GetCommandLineMethods(),
                    "phipsi_sspred_close"
                  )
                )
              ),
              false
            )
          )
        )
      );
      ProtocolLoopCoordinateAdd::GetInstance().InitializeScores();
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolLoopClose::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
      SCORE_WEIGHT_SET.Reset();

//      SCORE_WEIGHT_SET.SetWeight( ProtocolLoopCoordinateAdd::GetInstance().e_ScoreSSEPairConnectivity, 200.0);
      SCORE_WEIGHT_SET.SetWeight( ProtocolLoopCoordinateAdd::GetInstance().e_ScorePhiPsiCoil         , 100.0);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreLoopDomainClosure,                         5.0);

      if( sspred::Methods::GetFlagReadSSPredictions()->GetFlag())
      {
        SCORE_WEIGHT_SET.SetWeight( e_ScorePhiPsiSSPredClose, 5.0);
      }
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolLoopClose::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
      // construct the loop closure criterion and insert it into the terminate combine
      CRITERION.InsertCriteria
      (
        CriterionLoopClosure< assemble::ProteinModel, double>
        (
          0.08
        )
      );
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolLoopClose::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolLoopClose::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
      FACTORY->AppendPrinter
      (
        util::ShPtr< util::FunctionInterface< assemble::ProteinModel, util::ShPtrList< pdb::Line> > >
        (
          new pdb::PrinterLoopClosure
          (
            0.08
          )
        )
      );
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolLoopClose::InitializeMutates()
    {
      // was initialized?
      if( e_MutateLoopDomainCCD.IsDefined())
      {
        return;
      }
      // construct collector for unclosed loops
      util::ShPtr< find::CollectorInterface< util::ShPtrList< LoopDomain>, assemble::DomainInterface> >
      sp_unclosed_loop_collector
      (
        new CollectorLoopDomain
        (
          true,
          0.08
        )
      );

      math::Range< double> ccd_fraction;
      std::stringstream range_stream( GetFlagUseFullFraction()->GetFirstParameter()->GetValue());
      std::stringstream error_stream;
      BCL_Assert
      (
        ccd_fraction.FromStream( range_stream, error_stream),
        "Error while processing range from ccd flag: " + GetFlagUseFullFraction()->GetFirstParameter()->GetValue() +
        " " + error_stream.str()
      );

      // add Cyclic descent mutate
      e_MutateLoopDomainCCD = GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModelLoopDomainCCD
          (
            sp_unclosed_loop_collector,
            random::GetGlobalRandom(),
            ccd_fraction
          )
        )
      );

      // add ramachandran mutate
      e_MutateLoopDomainRamachandran = GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModelLoopDomain
          (
            sp_unclosed_loop_collector,
            util::ShPtr< math::MutateInterface< LoopDomain> >
            (
              new MutateLoopDomainDihedral
              (
                util::ShPtr< find::CollectorInterface< storage::List< MutationResidue>, LoopDomain> >
                (
                  new CollectorLoopDomainRandom( 1)
                ),
                util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > >
                (
                  PhiPsiGeneratorRamachandran::GetDefaultInstance().Clone()
                )
              )
            )
          )
        )
      );

      ProtocolLoopCoordinateAdd::GetInstance().InitializeMutates();
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolLoopClose::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      // reset all the probabilities
      MUTATE_TREE.Reset();

      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSE, 1.0);
      MUTATE_TREE.SetMutateProbability( e_MutateLoopDomainCCD, 1.0);
      MUTATE_TREE.SetMutateProbability
      (
        e_MutateLoopDomainRamachandran,
        GetFlagRamachandranMutateProbability()->GetFirstParameter()->GetNumericalValue< double>()
      );

      MUTATE_TREE.SetMutateProbability
      (
        ProtocolLoopCoordinateAdd::GetInstance().e_MutateCoilBendCTermPhiPsi5,
        0.25
      );
      MUTATE_TREE.SetMutateProbability
      (
        ProtocolLoopCoordinateAdd::GetInstance().e_MutateCoilBendNTermPhiPsi5,
        0.25
      );
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolLoopClose::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolLoopClose::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolLoopClose::GetDescription() const
    {
      static const std::string s_description( "Protocol Loop Close");
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolLoopClose::GetReadMe() const
    {
      static const std::string s_readme
      (
        "The loop close protocol is for tasks related to loops and closing loops using CCD. It can take a protein model "
        "with missing density and add the missing sequence and close the chain. It can do this for a single loop. It "
        "can also take a sequentially consecutive domain of sses and connect this loop domain. The purpose of this "
        "would be to explore other conformations that a rigid domain can adopt relative to flexible linking loops."
      );

      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolLoopClose::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolLoopClose::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief adds coordinates for residues that are in the protein model chain sequences, but are not within SSEs in
    //!        the protein model
    //! @param MODEL the protein model to be changed
    void ProtocolLoopClose::AddLoopCoordinates( assemble::ProteinModel &MODEL)
    {
      // create a phi psi generator
      static const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > >
      phi_psi_generator
      (
        PhiPsiGeneratorRamachandran::GetDefaultInstance().Clone()
      );

      // grow all the missing coils to some initial conformation
      MODEL = *MutateProteinModelGrowSSE::GrowAllMissingCoilsBidirectional( MODEL, phi_psi_generator);

      // test for peptide bonding
      MODEL.Join( biol::GetSSTypes().COIL, true);
    }

    //! @brief adds coordinates for nitrogen hydrogens to residues by converting them to AAComplete and calcualting ideal N-H positions
    //! @param MODEL the protein model
    util::ShPtr< assemble::ProteinModel> ProtocolLoopClose::AddNitrogenHydrogens( const assemble::ProteinModel &MODEL)
    {
      // create a new model
      util::ShPtr< assemble::ProteinModel> new_model( MODEL.Empty());

      // set the data
      new_model->SetProteinModelData( MODEL.GetProteinModelData());

      // iterate over all chains
      for
      (
        util::ShPtrVector< assemble::Chain>::const_iterator
          chain_itr( MODEL.GetChains().Begin()), chain_itr_end( MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        util::ShPtr< assemble::Chain> sp_chain( new assemble::Chain( ( *chain_itr)->GetSequence()));

        // pointer to last aa of previous sse
        util::SiPtr< const biol::AABase> last_aa_previous_sse;

        // iterate over SSEs
        for( assemble::Chain::const_ierator sse_itr( ( *chain_itr)->GetData().Begin()), sse_itr_end( ( *chain_itr)->GetData().End()); sse_itr != sse_itr_end; ++sse_itr)
        {
          biol::AASequence sequence( biol::GetAAClasses().e_AAComplete, 0, sp_chain->GetChainID());
          // iterate over sse
          biol::AASequence::const_iterator aa_itr( ( *sse_itr)->Begin()), aa_itr_end( ( *sse_itr)->End());

          // construct hydrogen for the first aa
          {
            util::ShPtr< biol::AAComplete> sp_aa_first( new biol::AAComplete( **aa_itr));

            // construct first hydrogen
            if( last_aa_previous_sse.IsDefined() && last_aa_previous_sse->DoesPrecede( *sp_aa_first) && biol::AABase::AreAminoAcidsPeptideBonded( *last_aa_previous_sse, *sp_aa_first, true))
            {
              const biol::Atom hydrogen( biol::AABackBoneCompleter::GenerateHydrogen( *sp_aa_first, last_aa_previous_sse->GetAtom( biol::GetAtomTypes().C).GetCoordinates()));
              sp_aa_first->SetAtom( hydrogen);
            }
            else
            {
              double phi( ( *sse_itr)->GetType()->GetIdealPhi());
              if( !util::IsDefined( phi))
              {
                phi = biol::GetSSTypes().HELIX->GetIdealPhi();
              }
              phi += math::g_Pi;

              const biol::Atom hydrogen
              (
                linal::CoordinatesDihedral
                (
                  sp_aa_first->GetAtom( biol::GetAtomTypes().N).GetCoordinates(),
                  sp_aa_first->GetAtom( biol::GetAtomTypes().CA).GetCoordinates(),
                  sp_aa_first->GetAtom( biol::GetAtomTypes().C).GetCoordinates(),
                  biol::GetAtomTypes().N->GetBondLength( biol::GetAtomTypes().H),
                  2 * math::g_Pi / 3,
                  phi
                ),
                biol::GetAtomTypes().H
              );
              sp_aa_first->SetAtom( hydrogen);
            }

            // insert the first amino acid
            sequence.PushBack( sp_aa_first);
          }

          // loop over all amino acids
          for( biol::AASequence::const_iterator aa_itr_next( aa_itr + 1); aa_itr_next != aa_itr_end; ++aa_itr, ++aa_itr_next)
          {
            util::ShPtr< biol::AAComplete> sp_aa( new biol::AAComplete( **aa_itr_next));

            // construct first hydrogen
            const biol::Atom hydrogen( biol::AABackBoneCompleter::GenerateHydrogen( *sp_aa, ( *aa_itr)->GetAtom( biol::GetAtomTypes().C).GetCoordinates()));
            sp_aa->SetAtom( hydrogen);
            sequence.PushBack( sp_aa);
          }
          last_aa_previous_sse = util::SiPtr< const biol::AABase>( *( *sse_itr)->GetLastAA());
          util::ShPtr< assemble::SSE> sp_sse( new assemble::SSE( sequence, ( *sse_itr)->GetType()));
          sp_chain->Insert( sp_sse);
        }

        new_model->Insert( sp_chain);
      }

      // end
      return new_model;
    }

    //! @brief split coils at non-petide connection
    //! @param MODEL the protein model to be changed
    void ProtocolLoopClose::SplitCoilsAtNonPetideBond( assemble::ProteinModel &MODEL)
    {
      // get all coils
      const util::SiPtrVector< const assemble::SSE> coils( MODEL.GetSSEs( biol::GetSSTypes().COIL));

      // iterate over all coils
      for( util::SiPtrVector< const assemble::SSE>::const_iterator itr( coils.Begin()), itr_end( coils.End()); itr != itr_end; ++itr)
      {
        const assemble::SSE &current( **itr);
        if( current.GetSize() < 2)
        {
          continue;
        }

        const util::ShPtrList< assemble::SSE> sses( SplitSSEAtNonPetideBond( current));
        MODEL.Remove( current);
        for( util::ShPtrList< assemble::SSE>::const_iterator coil_itr( sses.Begin()), coil_itr_end( sses.End()); coil_itr != coil_itr_end; ++coil_itr)
        {
          MODEL.Insert( *coil_itr);
        }
      }
    }

    //! @brief split sse into coils that are not connected
    //! @param SSE the sse to split
    //! @return list of coils
    util::ShPtrList< assemble::SSE> ProtocolLoopClose::SplitSSEAtNonPetideBond( const assemble::SSE &SS_ELEMENT)
    {
      util::ShPtrList< assemble::SSE> sses;

      assemble::SSE::const_iterator aa_itr( SS_ELEMENT.Begin()), aa_itr_end( SS_ELEMENT.End());

      while( aa_itr != aa_itr_end)
      {
        biol::AASequence new_seq( util::ShPtrVector< biol::AABase>(), SS_ELEMENT.GetChainID());

        // amino acids with undefined coordinates into new sse
        while( aa_itr != aa_itr_end && !( *aa_itr)->GetFirstSidechainAtom().GetCoordinates().IsDefined())
        {
          new_seq.PushBack( *aa_itr);
          ++aa_itr;
        }

        // found aa with undefined coordinates
        if( !new_seq.GetData().IsEmpty())
        {
          sses.PushBack( util::ShPtr< assemble::SSE>( new assemble::SSE( new_seq, SS_ELEMENT.GetType())));
          continue;
        }

        // peptide bond between amino acids
        new_seq.PushBack( *aa_itr);
        assemble::SSE::const_iterator aa_itr_next( aa_itr + 1);
        while( aa_itr_next != aa_itr_end && biol::AABase::AreAminoAcidsPeptideBonded( **aa_itr, **aa_itr_next, true))
        {
          ++aa_itr;
          ++aa_itr_next;
          new_seq.PushBack( *aa_itr);
        }

        // store coil
        sses.PushBack( util::ShPtr< assemble::SSE>( new assemble::SSE( new_seq, biol::GetSSTypes().COIL)));
        ++aa_itr;
      }

      // end
      return sses;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_loop_coordinate_add.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sse.h"
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "find/bcl_find_locator.h"
#include "fold/bcl_fold_collector_unconnected_sses.h"
#include "fold/bcl_fold_default_scores.h"
#include "fold/bcl_fold_handler_locator_loop_domain.h"
#include "fold/bcl_fold_locator_loop_domain.h"
#include "fold/bcl_fold_mutate_protein_model_loop_resize.h"
#include "fold/bcl_fold_mutate_protein_model_move_aa.h"
#include "fold/bcl_fold_mutate_protein_model_sse.h"
#include "fold/bcl_fold_mutate_protein_model_sse_seed.h"
#include "fold/bcl_fold_mutate_sse_bend_random.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_phi_psi_generator_ramachandran.h"
#include "fold/bcl_fold_score_weight_set.h"
#include "io/bcl_io_file.h"
#include "score/bcl_score_aa_pair_atom_clash.h"
#include "score/bcl_score_aa_sequence.h"
#include "score/bcl_score_aa_sequence_pair.h"
#include "score/bcl_score_loop_closure.h"
#include "score/bcl_score_phi_psi.h"
#include "score/bcl_score_protein_model_sse.h"
#include "score/bcl_score_protein_model_sse_neighbors.h"
#include "score/bcl_score_protein_model_sse_pairs.h"
#include "score/bcl_score_sse_pair_connectivity.h"
#include "score/bcl_score_sse_pair_gap.h"
#include "util/bcl_util_sh_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolLoopCoordinateAdd::ProtocolLoopCoordinateAdd()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolLoopCoordinateAdd
    ProtocolLoopCoordinateAdd *ProtocolLoopCoordinateAdd::Clone() const
    {
      return new ProtocolLoopCoordinateAdd( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolLoopCoordinateAdd &ProtocolLoopCoordinateAdd::GetInstance()
    {
      static ProtocolLoopCoordinateAdd s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolLoopCoordinateAdd::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolLoopCoordinateAdd::GetAlias() const
    {
      static const std::string s_name( "ProtocolLoopClose");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolLoopCoordinateAdd::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol for closing loops");
      serializer.AddInitializer
        (
         "mutate coil bend n term phi psi 45",
         "phi psi mutate for n terminus 45 degree",
         io::Serialization::GetAgent( &e_MutateCoilBendNTermPhiPsi45)
         );
      serializer.AddInitializer
        (
         "mutate coil bend n term phi 45",
         "phi mutate for n terminus 45 degree",
         io::Serialization::GetAgent( &e_MutateCoilBendNTermPhi45)
         );
      serializer.AddInitializer
        (
         "mutate coil bend n term psi 45",
         "psi mutate for n terminus 45 degree",
         io::Serialization::GetAgent( &e_MutateCoilBendNTermPsi45)
         );
      serializer.AddInitializer
        (
         "mutate coil bend c term phi psi 45",
         "phi psi mutate for c terminus 45 degree",
         io::Serialization::GetAgent( &e_MutateCoilBendCTermPhiPsi45)
         );
      serializer.AddInitializer
        (
         "mutate coil bend c term phi 45",
         "phi mutate for c terminus 45 degree",
         io::Serialization::GetAgent( &e_MutateCoilBendCTermPhi45)
         );
      serializer.AddInitializer
        (
         "mutate coil bend c term psi 45",
         "psi mutate for c terminus 45 degree",
         io::Serialization::GetAgent( &e_MutateCoilBendCTermPsi45)
         );
      serializer.AddInitializer
        (
         "mutate coil bend n term phi psi 5",
         "phi psi mutate for n terminus 5 degree",
         io::Serialization::GetAgent( &e_MutateCoilBendNTermPhiPsi5)
         );
      serializer.AddInitializer
        (
         "mutate coil bend c term phi psi 5",
         "phi psi mutate for c terminus 5 degree",
         io::Serialization::GetAgent( &e_MutateCoilBendCTermPhiPsi5)
         );
      serializer.AddInitializer
        (
         "mutate coil resize N term",
         "resize mutate for coil N terminus",
         io::Serialization::GetAgent( &e_MutateCoilResizeNTerm)
         );
      serializer.AddInitializer
        (
         "mutate coil resize C term",
         "resize mutate for coil C terminus",
         io::Serialization::GetAgent( &e_MutateCoilResizeCTerm)
         );
      serializer.AddInitializer
        (
         "mutate helix strand resize n term",
         "resize mutate for helix strand N terminus",
         io::Serialization::GetAgent( &e_MutateHelixStrandResizeNTerm)
         );
      serializer.AddInitializer
        (
         "mutate helix strand resize c term",
         "resize mutate for helix strand C terminus",
         io::Serialization::GetAgent( &e_MutateHelixStrandResizeCTerm)
         );
      serializer.AddInitializer
        (
         "mutate SSE seed N term",
         "add a coil as seed to an sse on left side",
         io::Serialization::GetAgent( &e_MutateSSESeedNTerm)
         );
      serializer.AddInitializer
      (
        "mutate SSE seed C term",
        "add a coil as seed to an sse on right side",
        io::Serialization::GetAgent( &e_MutateSSESeedCTerm)
       );
      serializer.AddInitializer
      (
        "mutate SSE seed cut N term",
        "add a coil as seed to an sse on left side cutting into the sse",
        io::Serialization::GetAgent( &e_MutateSSESeedCutNTerm)
       );
      serializer.AddInitializer
      (
        "mutate SSE seed cut C term",
        "add a coil as seed to an sse on right side cutting into the sse",
        io::Serialization::GetAgent( &e_MutateSSESeedCutCTerm)
       );
      serializer.AddInitializer
      (
        "mutate move AA N term",
        "move aas from one sse to the neighboring in nterm direction",
        io::Serialization::GetAgent( &e_MutateMoveAANTerm)
       );
      serializer.AddInitializer
      (
        "mutate move AA C term",
        "move aas from one sse to the neighboring in cterm direction",
        io::Serialization::GetAgent( &e_MutateMoveAACTerm)
       );
      serializer.AddInitializer
      (
        "score SSE interatom clash",
        "atom clash inter sse",
        io::Serialization::GetAgent( &e_ScoreSSEInterAtomClash)
       );
      serializer.AddInitializer
      (
        "score SSE intraatom clash",
        "atom clash intra sse",
        io::Serialization::GetAgent( &e_ScoreSSEIntraAtomClash)
       );
      serializer.AddInitializer
      (
        "score loop closure",
        "score the distance between two sse ends",
        io::Serialization::GetAgent( &e_ScoreSSEIntraAtomClash)
       );
      serializer.AddInitializer
      (
        "score phi psi coil",
        "phi psi",
        io::Serialization::GetAgent( &e_ScorePhiPsiCoil)
       );
      serializer.AddInitializer
      (
        "score sse pair gap",
        "scores the gap between two neighboring sses",
        io::Serialization::GetAgent( &e_ScoreSSEPairGap)
       );
      serializer.AddInitializer
      (
        "score sse pair connectivity",
        "scores the connectivity between two neighboring sses",
        io::Serialization::GetAgent( &e_ScoreSSEPairConnectivity)
       );

      return serializer;
    }

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolLoopCoordinateAdd::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // insert all the flags in the vector
        s_all_flags_vector.PushBack( GetFlagLoopDomainFilename());
      }

      // end
      return s_all_flags_vector;
    }

    //! @brief return command line flag for specifying loop domains via a file
    //! @return command line flag for specifying loop domains via a file
    util::ShPtr< command::FlagInterface> &ProtocolLoopCoordinateAdd::GetFlagLoopDomainFilename()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "loop_coord_add",
          "\tSpecific loop segment(s) should be built. If this flag is not given, then all loops missing coordinates will be built."
        )
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_filename
      (
        new command::Parameter
        (
          "loop_domain_filename", "\tfilename for loop domain file", "loop_domain.txt"
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_filename);
      }

      // end
      return s_flag;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolLoopCoordinateAdd::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      if( !GetFlagLoopDomainFilename()->GetFlag())
      {
        return;
      }

      // read the given file
      io::IFStream read;
      io::File::MustOpenIFStream( read, GetFlagLoopDomainFilename()->GetFirstParameter()->GetValue());

      // get the sses locators read from file
      util::ShPtrList< LocatorLoopDomain> locator_loop_domain
      (
        HandlerLocatorLoopDomain().HandleReadMultiple( read, START_MODEL)
      );

      BCL_Assert( !locator_loop_domain.IsEmpty(), "locator_loop_domain is empty");
      // get all the sse locators from all of the domains
      for
      (
        util::ShPtrList< LocatorLoopDomain>::const_iterator
          domain_itr( locator_loop_domain.Begin()), domain_itr_end( locator_loop_domain.End());
        domain_itr != domain_itr_end;
        ++domain_itr
      )
      {
        // remove all sses from start model that are defined in the domain locator
        util::SiPtrVector< const assemble::LocatorSSE> sse_locators( ( *domain_itr)->GetLocatorSSEs());
        for( util::SiPtrVector< const assemble::LocatorSSE>::const_iterator itr( sse_locators.Begin()), itr_end( sse_locators.End()); itr != itr_end; ++itr)
        {
          // locate the sse and remove it if it is defined
          const util::SiPtr< const assemble::SSE> located_sse( ( *itr)->Locate( START_MODEL));
          if( located_sse.IsDefined())
          {
            START_MODEL.Remove( *located_sse);
          }
        }
      }
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolLoopCoordinateAdd::InitializeScores()
    {
      // initialize score only once
      if( e_ScoreSSEInterAtomClash.IsDefined())
      {
        return;
      }

      // between sses aa clash checking all atoms of each aa
      e_ScoreSSEInterAtomClash = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSEPairs
            (
              Scores::WrapCacheSSEPairScore
              (
                util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> >
                (
                  new score::AASequencePair
                  (
                    score::AAPairAtomClash( 0.2, 0, "sse_inter_atom_clash"), false
                  )
                ),
                false // symmetric
              ),
              false // no normalization
            )
          )
        )
      );

      // sse internal clashes between all atoms of the residues
      e_ScoreSSEIntraAtomClash = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSE
            (
              Scores::WrapCacheSSEScore
              (
                util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >
                (
                  new score::AASequence
                  (
                    util::ShPtr< score::AAPairDistanceInterface>
                    (
                      new score::AAPairAtomClash( 0.2, 0, "sse_intra_atom_clash")
                    ),
                    false
                  )
                )
              ),
              false // no normalization
            )
          )
        )
      );

      // loop closure score
      e_ScoreLoopClosure = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModelSSEPairs>
          (
            new score::ProteinModelSSEPairs
            (
              Scores::WrapCacheSSEPairScore
              (
                util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> >
                (
                  new score::LoopClosure( 0, 15.0, 0.8, true)
                ),
                false // non symmetric
              ),
              false // no normalization
            )
          )
        )
      );

      // phi psi for loop building
      e_ScorePhiPsiCoil = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSE
            (
              Scores::WrapCacheSSEScore
              (
                util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >
                (
                  new score::PhiPsi
                  (
                    "phipsi_coil",
                    score::PhiPsi::GetDefaultHistogramFilename(),
                    storage::Set< biol::SSType>( biol::GetSSTypes().COIL)
                  )
                )
              ),
              false
            )
          )
        )
      );

      // between sses aa clash checking all atoms of each aa
      e_ScoreSSEPairGap = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSENeighbors
            (
              Scores::WrapCacheSSEPairScore
              (
                util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> >
                (
                  new score::SSEPairGap( 2.0, "sse_pair_gap")
                ),
                false // non symmetric
              ),
              false // no normalization
            )
          )
        )
      );

      // sse connectivity to help guide grown loops towards their correct neighboring sse
      e_ScoreSSEPairConnectivity = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSENeighbors
            (
              Scores::WrapCacheSSEPairScore
              (
                util::CloneToShPtr( score::SSEPairConnectivity( score::SSEPairConnectivity::GetDefaultScheme())),
                false // non symmetric
              ),
              false // normalization
            )
          )
        )
      );

      DefaultScores::GetInstance().InitializeScores();
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolLoopCoordinateAdd::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
      SCORE_WEIGHT_SET.Reset();

      // default scores
      SCORE_WEIGHT_SET.SetWeight( DefaultScores::GetInstance().e_ScoreAAPairClash        ,  10.0);
      SCORE_WEIGHT_SET.SetWeight( DefaultScores::GetInstance().e_ScoreAAPairDistance     ,   0.5);
      SCORE_WEIGHT_SET.SetWeight( DefaultScores::GetInstance().e_ScoreAANeighborCount    ,  50.0);

      SCORE_WEIGHT_SET.SetWeight(                              e_ScoreSSEInterAtomClash  ,  10.0);
      SCORE_WEIGHT_SET.SetWeight(                              e_ScoreSSEIntraAtomClash  ,  10.0);
      SCORE_WEIGHT_SET.SetWeight(                              e_ScorePhiPsiCoil         , 100.0);
      SCORE_WEIGHT_SET.SetWeight(                              e_ScoreSSEPairGap         , 100.0);
      SCORE_WEIGHT_SET.SetWeight(                              e_ScoreSSEPairConnectivity,   2.5);
      SCORE_WEIGHT_SET.SetWeight(                              e_ScoreLoopClosure        , 500.0);
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolLoopCoordinateAdd::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolLoopCoordinateAdd::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolLoopCoordinateAdd::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolLoopCoordinateAdd::InitializeMutates()
    {
      if( e_MutateCoilResizeNTerm.IsDefined())
      {
        return;
      }

      typedef find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> LocatorUnconnectedSSE;
      const util::ShPtr< assemble::PickSSERandom> sp_pick_sse_random( new assemble::PickSSERandom());

      const util::ShPtr< CollectorUnconnectedSSE> sp_collector_nterminal_flexible
      (
        new CollectorUnconnectedSSE
        (
          biol::AASequenceFlexibility::e_NTerminal,
          true,
          storage::Set< biol::SSType>( biol::GetSSTypes().COIL),
          false
        )
      );
      const util::ShPtr< LocatorUnconnectedSSE> sp_locator_nterminal_flexible
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          sp_collector_nterminal_flexible,
          sp_pick_sse_random
        )
      );
      const util::ShPtr< CollectorUnconnectedSSE> sp_collector_cterminal_flexible
      (
        new CollectorUnconnectedSSE
        (
          biol::AASequenceFlexibility::e_CTerminal,
          true,
          storage::Set< biol::SSType>( biol::GetSSTypes().COIL),
          false
        )
      );
      const util::ShPtr< LocatorUnconnectedSSE> sp_locator_cterminal_flexible
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          sp_collector_cterminal_flexible,
          sp_pick_sse_random
        )
      );

      const util::ShPtr< CollectorUnconnectedSSE> sp_coil_collector_nterminal
      (
        new CollectorUnconnectedSSE
        (
          biol::AASequenceFlexibility::e_NTerminal,
          false,
          storage::Set< biol::SSType>( biol::GetSSTypes().COIL),
          false
        )
      );
      const util::ShPtr< LocatorUnconnectedSSE> sp_locator_nterminal
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          sp_coil_collector_nterminal,
          sp_pick_sse_random
        )
      );
      const util::ShPtr< CollectorUnconnectedSSE> sp_coil_collector_cterminal
      (
        new CollectorUnconnectedSSE
        (
          biol::AASequenceFlexibility::e_CTerminal,
          false,
          storage::Set< biol::SSType>( biol::GetSSTypes().COIL),
          false
        )
      );
      const util::ShPtr< LocatorUnconnectedSSE> sp_locator_cterminal
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          sp_coil_collector_cterminal,
          sp_pick_sse_random
        )
      );

      const util::ShPtr< CollectorUnconnectedSSE> sp_collector_nterminal_helix_strand
      (
        new CollectorUnconnectedSSE
        (
          biol::AASequenceFlexibility::e_NTerminal,
          false,
          storage::Set< biol::SSType>( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND),
          false
        )
      );
      const util::ShPtr< LocatorUnconnectedSSE> sp_locator_nterminal_helix_strand
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          sp_collector_nterminal_helix_strand,
          sp_pick_sse_random
        )
      );
      const util::ShPtr< CollectorUnconnectedSSE> sp_collector_cterminal_helix_strand
      (
        new CollectorUnconnectedSSE
        (
          biol::AASequenceFlexibility::e_CTerminal,
          false,
          storage::Set< biol::SSType>( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND),
          false
        )
      );
      const util::ShPtr< LocatorUnconnectedSSE> sp_locator_cterminal_helix_strand
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          sp_collector_cterminal_helix_strand,
          sp_pick_sse_random
        )
      );

      const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > phi_psi_generator
      (
        new PhiPsiGeneratorRamachandran( biol::Ramachandran::GetDefaultHistogramFilename())
      );

      const double extend_probability( 0.75);
      const math::Range< size_t> min_max_change_range( 1, 2);

      const storage::Map< biol::SSType, size_t> min_sse_sizes
      (
        storage::Map< biol::SSType, size_t>::Create( std::pair< biol::SSType, size_t>( biol::GetSSTypes().COIL, 1))
      );

      const storage::Map< biol::SSType, size_t> max_sse_sizes
      (
        storage::Map< biol::SSType, size_t>::Create( std::pair< biol::SSType, size_t>( biol::GetSSTypes().COIL, 999))
      );

      // grow shrink n terminal loops
      e_MutateCoilResizeNTerm = GetMutates().AddMutate
      (
        MutateProteinModelLoopResize
        (
          sp_locator_nterminal,
          extend_probability,
          min_max_change_range,
          min_sse_sizes,
          max_sse_sizes,
          biol::AASequenceFlexibility::e_NTerminal,
          phi_psi_generator,
          true,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_nterminal_resize"
        )
      );

      // grow shrink c terminal loops
      e_MutateCoilResizeCTerm = GetMutates().AddMutate
      (
        MutateProteinModelLoopResize
        (
          sp_locator_cterminal,
          extend_probability,
          min_max_change_range,
          min_sse_sizes,
          max_sse_sizes,
          biol::AASequenceFlexibility::e_CTerminal,
          phi_psi_generator,
          true,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_cterminal_resize"
        )
      );

      const storage::Map< biol::SSType, size_t> min_helix_strand_sizes
        (
          storage::Map< biol::SSType, size_t>::Create
          (
            std::pair< biol::SSType, size_t>( biol::GetSSTypes().HELIX, 5),
            std::pair< biol::SSType, size_t>( biol::GetSSTypes().STRAND, 3)
          )
        );

      // extend probability
      const double sse_extend_prob( 0.0);

      // grow shrink n terminal helix or strand
      e_MutateHelixStrandResizeNTerm = GetMutates().AddMutate
      (
        MutateProteinModelSSEResize
        (
          sp_locator_nterminal_helix_strand,
          sse_extend_prob,
          math::Range< size_t>( 1, 1),
          biol::AASequenceFlexibility::e_NTerminal,
          false,
          min_helix_strand_sizes,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_nterm_sse_resize"
        )
      );

      // grow shrink c terminal helix or strand
      e_MutateHelixStrandResizeCTerm = GetMutates().AddMutate
      (
        MutateProteinModelSSEResize
        (
          sp_locator_cterminal_helix_strand,
          sse_extend_prob,
          math::Range< size_t>( 1, 1),
          biol::AASequenceFlexibility::e_CTerminal,
          false,
          min_helix_strand_sizes,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_cterm_sse_resize"
        )
      );

      // permitted change ranges for phi and psi
      const math::Range< double> empty_change_range( 0, 0);
      const math::Range< double> phi_angle_change_range45( -0.25 * math::g_Pi, 0.25 * math::g_Pi);
      const math::Range< double> psi_angle_change_range45( -0.25 * math::g_Pi, 0.25 * math::g_Pi);
      const math::Range< double> phi_angle_change_range5( - 1.0 / 36.0 * math::g_Pi, 1.0 / 36.0 * math::g_Pi);
      const math::Range< double> psi_angle_change_range5( - 1.0 / 36.0 * math::g_Pi, 1.0 / 36.0 * math::g_Pi);

      // benders
      const util::ShPtr< MutateSSEBendRandom> sp_bend_phi_psi_nterm45
      (
        new MutateSSEBendRandom( phi_angle_change_range45, psi_angle_change_range45, biol::AASequenceFlexibility::e_NTerminal)
      );
      const util::ShPtr< MutateSSEBendRandom> sp_bend_phi_nterm45
      (
        new MutateSSEBendRandom( phi_angle_change_range45, empty_change_range, biol::AASequenceFlexibility::e_NTerminal)
      );
      const util::ShPtr< MutateSSEBendRandom> sp_bend_psi_nterm45
      (
        new MutateSSEBendRandom( empty_change_range, psi_angle_change_range45, biol::AASequenceFlexibility::e_NTerminal)
      );
      const util::ShPtr< MutateSSEBendRandom> sp_bend_phi_psi_cterm45
      (
        new MutateSSEBendRandom( phi_angle_change_range45, psi_angle_change_range45, biol::AASequenceFlexibility::e_CTerminal)
      );
      const util::ShPtr< MutateSSEBendRandom> sp_bend_phi_cterm45
      (
        new MutateSSEBendRandom( phi_angle_change_range45, empty_change_range, biol::AASequenceFlexibility::e_CTerminal)
      );
      const util::ShPtr< MutateSSEBendRandom> sp_bend_psi_cterm45
      (
        new MutateSSEBendRandom( empty_change_range, psi_angle_change_range45, biol::AASequenceFlexibility::e_CTerminal)
      );
      const util::ShPtr< MutateSSEBendRandom> sp_bend_phi_psi_nterm5
      (
        new MutateSSEBendRandom( phi_angle_change_range5, psi_angle_change_range5, biol::AASequenceFlexibility::e_NTerminal)
      );
      const util::ShPtr< MutateSSEBendRandom> sp_bend_phi_psi_cterm5
      (
        new MutateSSEBendRandom( phi_angle_change_range5, psi_angle_change_range5, biol::AASequenceFlexibility::e_CTerminal)
      );

      // add bending random n terminal loops
      e_MutateCoilBendNTermPhiPsi45 = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_nterminal_flexible,
          sp_bend_phi_psi_nterm45,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_sse_bend_nterm_phi_psi_45"
        )
      );
      e_MutateCoilBendNTermPhiPsi5 = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_nterminal_flexible,
          sp_bend_phi_psi_nterm5,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_sse_bend_nterm_phi_psi_5"
        )
      );
      e_MutateCoilBendNTermPhi45 = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_nterminal_flexible,
          sp_bend_phi_nterm45,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_sse_bend_nterm_phi_45"
        )
      );
      e_MutateCoilBendNTermPsi45 = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_nterminal_flexible,
          sp_bend_psi_nterm45,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_sse_bend_nterm_psi_45"
        )
      );

      // add bending random nonrigid
      e_MutateCoilBendCTermPhiPsi45 = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_cterminal_flexible,
          sp_bend_phi_psi_cterm45,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_sse_bend_cterm_phi_psi_45"
        )
      );
      e_MutateCoilBendCTermPhiPsi5 = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_cterminal_flexible,
          sp_bend_phi_psi_cterm5,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_sse_bend_cterm_phi_psi_5"
        )
      );
      e_MutateCoilBendCTermPhi45 = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_cterminal_flexible,
          sp_bend_phi_cterm45,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_sse_bend_cterm_phi_45"
        )
      );
      e_MutateCoilBendCTermPsi45 = GetMutates().AddMutate
      (
        MutateProteinModelSSE
        (
          sp_locator_cterminal_flexible,
          sp_bend_psi_cterm45,
          MutateTree::GetMutateTypeName( MutateTree::e_SSE) + "_sse_bend_cterm_psi_45"
        )
      );

      // cut in range
      const math::Range< size_t> no_cut_range( 0, 0);
      const math::Range< size_t> cut_in_range( 1, 2);
      const math::Range< size_t> seed_length_range( 1, 2);
      const math::Range< size_t> seed_length_range_cut( 0, 1);
      e_MutateSSESeedNTerm = GetMutates().AddMutate
      (
        MutateProteinModelSSESeed
        (
          sp_locator_nterminal_helix_strand,
          seed_length_range,
          biol::AASequenceFlexibility::e_NTerminal,
          sp_bend_phi_psi_nterm45,
          no_cut_range,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_seed_coil_nterm"
        )
      );
      e_MutateSSESeedCTerm = GetMutates().AddMutate
      (
        MutateProteinModelSSESeed
        (
          sp_locator_cterminal_helix_strand,
          seed_length_range,
          biol::AASequenceFlexibility::e_CTerminal,
          sp_bend_phi_psi_cterm45,
          no_cut_range,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_seed_coil_cterm"
        )
      );
      e_MutateSSESeedCutNTerm = GetMutates().AddMutate
      (
        MutateProteinModelSSESeed
        (
          sp_locator_nterminal_helix_strand,
          seed_length_range_cut,
          biol::AASequenceFlexibility::e_NTerminal,
          sp_bend_phi_psi_nterm45,
          cut_in_range,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_seedcut_coil_nterm"
        )
      );
      e_MutateSSESeedCutCTerm = GetMutates().AddMutate
      (
        MutateProteinModelSSESeed
        (
          sp_locator_cterminal_helix_strand,
          seed_length_range_cut,
          biol::AASequenceFlexibility::e_CTerminal,
          sp_bend_phi_psi_cterm45,
          cut_in_range,
          MutateTree::GetMutateTypeName( MutateTree::e_Add) + "_seedcut_coil_cterm"
        )
      );

      const util::ShPtr< assemble::CollectorSSE> sp_coil_collector( new assemble::CollectorSSE( biol::GetSSTypes().COIL));
      const util::ShPtr< find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> > > sp_coil_locator
      (
        new find::Locator< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, util::SiPtrList< const assemble::SSE> >
        (
          sp_coil_collector,
          sp_pick_sse_random
        )
      );
      const math::Range< size_t> nr_res_move( 1, 2);
      storage::Map< biol::SSType, size_t> min_sse_sizes_move;
      min_sse_sizes_move[ biol::GetSSTypes().COIL] = 0;
      min_sse_sizes_move[ biol::GetSSTypes().HELIX] = 5;
      min_sse_sizes_move[ biol::GetSSTypes().STRAND] = 3;

      e_MutateMoveAANTerm = GetMutates().AddMutate
      (
        MutateProteinModelMoveAA
        (
          sp_locator_cterminal_flexible,
          nr_res_move,
          biol::AASequenceFlexibility::e_NTerminal,
          min_sse_sizes_move,
          sp_bend_phi_psi_cterm45,
          MutateTree::GetMutateTypeName( MutateTree::e_Model) + "_move_aa_cterm"
        )
      );
      e_MutateMoveAACTerm = GetMutates().AddMutate
      (
        MutateProteinModelMoveAA
        (
          sp_locator_nterminal_flexible,
          nr_res_move,
          biol::AASequenceFlexibility::e_CTerminal,
          min_sse_sizes_move,
          sp_bend_phi_psi_nterm45,
          MutateTree::GetMutateTypeName( MutateTree::e_Model) + "_move_aa_nterm"
        )
      );
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolLoopCoordinateAdd::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      // reset all the probabilities
      MUTATE_TREE.Reset();
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSE     , 3.00);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilBendNTermPhiPsi45, 0.33);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilBendNTermPhi45   , 0.33);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilBendNTermPsi45   , 0.33);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilBendCTermPhiPsi45, 0.33);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilBendCTermPhi45   , 0.33);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilBendCTermPsi45   , 0.33);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilBendNTermPhiPsi5 , 0.66);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilBendCTermPhiPsi5 , 0.66);

      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Add         , 1.00);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilResizeNTerm       , 1.00);
      MUTATE_TREE.SetMutateProbability( e_MutateCoilResizeCTerm       , 1.00);
      MUTATE_TREE.SetMutateProbability( e_MutateSSESeedCTerm          , 0.40);
      MUTATE_TREE.SetMutateProbability( e_MutateSSESeedNTerm          , 0.40);
      MUTATE_TREE.SetMutateProbability( e_MutateSSESeedCutCTerm       , 0.20);
      MUTATE_TREE.SetMutateProbability( e_MutateSSESeedCutNTerm       , 0.20);
//      MUTATE_TREE.SetMutateProbability( e_MutateHelixStrandResizeNTerm, 0.20);
//      MUTATE_TREE.SetMutateProbability( e_MutateHelixStrandResizeCTerm, 0.20);

      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Model   , 0.25);
      MUTATE_TREE.SetMutateProbability( e_MutateMoveAACTerm       , 0.125);
      MUTATE_TREE.SetMutateProbability( e_MutateMoveAANTerm       , 0.125);
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolLoopCoordinateAdd::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolLoopCoordinateAdd::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolLoopCoordinateAdd::GetDescription() const
    {
      static const std::string s_description( "Protocol Loop Coordinate Add");
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolLoopCoordinateAdd::GetReadMe() const
    {
      static const std::string s_readme
      (
        "The loop coordinate add protocol adds in coordinates for missing residues in a protein sequence. These"
        " residues can be specified or, if not specified, all missing residues will be added. For each stretch of"
        " missing residues, the coordinates are dynamically added and conformations of the sequence are sampled as"
        " additional residues are added to complete each stretch."
      );

      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolLoopCoordinateAdd::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolLoopCoordinateAdd::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_membrane.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_domain_sse_pool_overlapping.h"
#include "assemble/bcl_assemble_pick_sse_short_loops.h"
#include "biol/bcl_biol_exposure_prediction.h"
#include "biol/bcl_biol_membrane.h"
#include "coord/bcl_coord_move_rotate_random_external_reference.h"
#include "coord/bcl_coord_move_translate_random.h"
#include "fold/bcl_fold_default_flags.h"
#include "fold/bcl_fold_default_mutates.h"
#include "fold/bcl_fold_default_scores.h"
#include "fold/bcl_fold_mutate_protein_model.h"
#include "fold/bcl_fold_mutate_protein_model_sse_add.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_placement_sse_short_loop.h"
#include "fold/bcl_fold_score_weight_set.h"
#include "fold/bcl_fold_setup.h"
#include "io/bcl_io_file.h"
#include "pdb/bcl_pdb_factory.h"
#include "pdb/bcl_pdb_printer_membrane.h"
#include "pdb/bcl_pdb_printer_quality_membrane.h"
#include "score/bcl_score_aa_neighborhood_exposure_prediction.h"
#include "score/bcl_score_environment_predictions.h"
#include "score/bcl_score_protein_model_aa_neighborhood.h"
#include "score/bcl_score_protein_model_membrane_topology.h"
#include "score/bcl_score_protein_model_sse.h"
#include "score/bcl_score_sse_membrane_alignment.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolMembrane::ProtocolMembrane() :
      m_EnvironmentScores()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolMembrane
    ProtocolMembrane *ProtocolMembrane::Clone() const
    {
      return new ProtocolMembrane( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolMembrane &ProtocolMembrane::GetInstance()
    {
      static ProtocolMembrane s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolMembrane::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

     //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolMembrane::GetAlias() const
    {
      static const std::string s_name( "ProtocolMembrane");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolMembrane::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol for folding membrane proteins");
      serializer.AddInitializer
        (
         "mutate add mem SSE short loop",
         "add membrane",
         io::Serialization::GetAgent( &e_MutateAddMemSSEShortLoop)
         );
      serializer.AddInitializer
        (
         "mutate model global z translate",
         "translate the model along its z axis",
         io::Serialization::GetAgent( &e_MutateModelGlobalZTranslate)
         );
      serializer.AddInitializer
        (
         "mutate model global z rotate",
         "rotate the model",
         io::Serialization::GetAgent( &e_MutateModelGlobalRotate)
         );
      serializer.AddInitializer
      (
        "score SSE membrane alignment",
        "scores alignment of SSEs with the membrane",
        io::Serialization::GetAgent( &e_ScoreSSEMembraneAlignment)
       );
      serializer.AddInitializer
      (
        "score helix topology",
        "scores liekliness of helix topology",
        io::Serialization::GetAgent( &e_ScoreHelixTopology)
       );
      serializer.AddInitializer
      (
        "score exposure",
        "scores model exposure outside of the membrane",
        io::Serialization::GetAgent( &e_ScoreExposure)
       );
      serializer.AddInitializer
      (
        "environment scores",
        "sspred environment score",
        io::Serialization::GetAgent( &m_EnvironmentScores)
       );

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolMembrane::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // insert all the flags in the vector
        s_all_flags_vector.PushBack( biol::Membrane::GetFlagMembrane());
        s_all_flags_vector.PushBack
        (
          score::ProteinModelMembraneTopology::GetFlagExpectedTransmembraneHelicesPoolFile()
        );
      }

      // end
      return s_all_flags_vector;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolMembrane::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      // add the membrane to the protein model data
      util::ShPtr< assemble::ProteinModelData> sp_data( START_MODEL.GetProteinModelData());
      sp_data->Insert( assemble::ProteinModelData::e_Membrane, util::CloneToShPtr( biol::Membrane::GetCommandLineMembrane()));
      START_MODEL.SetProteinModelData( sp_data);

      // read environment predictions
      if( score::AANeighborhoodExposurePrediction::GetFlagScoreExposure()->GetFlag())
      {
        biol::ExposurePrediction::ReadPredictions
        (
          START_MODEL,
          DefaultFlags::GetFlagReadSequenceDataPath()->GetParameterList()( 1)->GetValue(),
          DefaultFlags::GetFlagReadSequenceDataPath()->GetFirstParameter()->GetValue()
        );
        util::ShPtr< assemble::ProteinModel> sp_native_model
        (
          START_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_NativeModel).HardCopy()
        );
        if( sp_native_model.IsDefined())
        {
          biol::ExposurePrediction::ReadPredictions
          (
            *sp_native_model,
            DefaultFlags::GetFlagReadSequenceDataPath()->GetParameterList()( 1)->GetValue(),
            DefaultFlags::GetFlagReadSequenceDataPath()->GetFirstParameter()->GetValue()
          );
        }
        util::ShPtr< assemble::ProteinModel> sp_native_filtered_model
        (
          START_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_NativeFilteredModel).HardCopy()
        );
        if( sp_native_filtered_model.IsDefined())
        {
          biol::ExposurePrediction::ReadPredictions
          (
            *sp_native_filtered_model,
            DefaultFlags::GetFlagReadSequenceDataPath()->GetParameterList()( 1)->GetValue(),
            DefaultFlags::GetFlagReadSequenceDataPath()->GetFirstParameter()->GetValue()
          );
        }
      }
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolMembrane::InitializeScores()
    {
      if( e_ScoreSSEMembraneAlignment.IsDefined())
      {
        return;
      }

      // radius of gyration for membrane
      // membrane alignment
      e_ScoreSSEMembraneAlignment = GetScores().AddScore
      (
        Scores::WrapCacheProteinModelScore
        (
          util::ShPtr< score::ProteinModel>
          (
            new score::ProteinModelSSE
            (
              Scores::WrapCacheSSEScore
              (
                util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >
                (
                  new score::SSEMembraneAlignment()
                )
              ),
              false
            )
          )
        )
      );

      // make sure no loops will need to go through the membrane to connect consecutive sses
      score::ProteinModelMembraneTopology topology;
      if( topology.InitializeFromFlag())
      {
        e_ScoreHelixTopology = GetScores().AddScore
        (
          Scores::WrapCacheProteinModelScore( util::ShPtr< score::ProteinModel>( topology.Clone()))
        );
      }

      // iterate over sse methods
      storage::Set< sspred::Method> ss_pred_methods( sspred::Methods::GetCommandLineMethods());
      for
      (
        storage::Set< sspred::Method>::const_iterator
          sspred_itr( ss_pred_methods.Begin()), sspred_itr_end( ss_pred_methods.End());
        sspred_itr != sspred_itr_end;
        ++sspred_itr
      )
      {
        // add environment score
        m_EnvironmentScores[ *sspred_itr] = GetScores().AddScore
        (
          Scores::WrapCacheProteinModelScore
          (
            util::ShPtr< score::ProteinModel>
            (
              new score::ProteinModelSSE
              (
                Scores::WrapCacheSSEScore
                (
                  util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >
                  (
                    new score::EnvironmentPredictions
                    (
                      *sspred_itr,
                      "ss_" + sspred_itr->GetName() + "_env"
                    )
                  )
                ),
                false
              )
            )
          )
        );
      }

      // if scoring exposure
      if( score::AANeighborhoodExposurePrediction::GetFlagScoreExposure()->GetFlag())
      {
        // construct the score
        e_ScoreExposure = GetScores().AddScore
        (
          Scores::WrapCacheProteinModelScore
          (
            util::ShPtr< score::ProteinModel>
            (
              new score::ProteinModelAANeighborhood
              (
                util::CloneToShPtr
                (
                  score::AANeighborhoodExposurePrediction()
                ),
                score::ProteinModelAANeighborhood::e_RMSD
              )
            )
          )
        );

        // construct the score
        e_ScoreExposureExplained = GetScores().AddScore
        (
          Scores::WrapCacheProteinModelScore
          (
            util::ShPtr< score::ProteinModel>
            (
              new score::ProteinModelAANeighborhood
              (
                util::CloneToShPtr
                (
                  score::AANeighborhoodExposurePrediction()
                ),
                score::ProteinModelAANeighborhood::e_FractionExplained
              )
            )
          )
        );
      }
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolMembrane::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
      // set the weights
      SCORE_WEIGHT_SET.SetWeight( e_ScoreSSEMembraneAlignment, 8.0);
      SCORE_WEIGHT_SET.SetWeight( e_ScoreHelixTopology, 500);

      // iterate over sspred scores
      for
      (
        storage::Map< sspred::Method, storage::VectorND< 2, Score> >::const_iterator
          sspred_itr( DefaultScores::GetInstance().GetSSPredScores().Begin()),
          sspred_itr_end( DefaultScores::GetInstance().GetSSPredScores().End());
        sspred_itr != sspred_itr_end; ++sspred_itr
      )
      {
        // set weight for octopus and jufo9d
        if( sspred_itr->first == sspred::GetMethods().e_OCTOPUS)
        {
          const double weight( 20.0);
          SCORE_WEIGHT_SET.SetWeight( sspred_itr->second.First(), weight);  // normal score
          SCORE_WEIGHT_SET.SetWeight( sspred_itr->second.Second(), weight); // entropy score
          SCORE_WEIGHT_SET.SetWeight( m_EnvironmentScores.Find( sspred_itr->first)->second, weight); // environment score
        }
        else if( sspred_itr->first == sspred::GetMethods().e_JUFO9D)
        {
          const double weight( 5.0);
          SCORE_WEIGHT_SET.SetWeight( sspred_itr->second.First(), weight);  // normal score
          SCORE_WEIGHT_SET.SetWeight( sspred_itr->second.Second(), weight); // entropy score
          SCORE_WEIGHT_SET.SetWeight( m_EnvironmentScores.Find( sspred_itr->first)->second, weight); // environment score
        }
      }
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolMembrane::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolMembrane::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolMembrane::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
      FACTORY->AppendPrinter
      (
        util::ShPtr< util::FunctionInterface< assemble::ProteinModel, util::ShPtrList< pdb::Line> > >
        (
          new pdb::PrinterMembrane()
        )
      );
      FACTORY->AppendPrinter
      (
        util::ShPtr< util::FunctionInterface< assemble::ProteinModel, util::ShPtrList< pdb::Line> > >
        (
          new pdb::PrinterQualityMembrane
          (
            GetSetup().GetQualityMeasures(),
            storage::Set< biol::EnvironmentType>( biol::GetEnvironmentTypes().e_MembraneCore),
            GetSetup().GetNativeModel()
          )
        )
      );
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolMembrane::InitializeMutates()
    {
      if( e_MutateAddMemSSEShortLoop.IsDefined())
      {
        return;
      }

      // add sse short loop using a wider angle than for soluble additions
      const size_t short_loop_length( 7);
      e_MutateAddMemSSEShortLoop = GetMutates().AddMutate
      (
        MutateProteinModelSSEAdd
        (
          assemble::PickSSEShortLoops( short_loop_length),
          PlacementSSEShortLoop( short_loop_length, 0.25, math::g_Pi / 2.0),
          "add_mem_sse_next_to_sse"
        )
      );

      // global z translation
      e_MutateModelGlobalZTranslate = GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModel
          (
            coord::MoveTranslateRandom( linal::Vector3D( 0.0, 0.0, 2.0), linal::Vector3D( 0.0, 0.0, 10.0), false),
            "model_global_z_translate"
          )
        )
      );

      // global rotation
      e_MutateModelGlobalRotate = GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModel
          (
            coord::MoveRotateRandomExternalReference
            (
              linal::Vector3D( 0.0, 0.0, 0.0),
              linal::Vector3D( math::g_Pi, math::g_Pi, math::g_Pi),
              math::TransformationMatrix3D(),
              coord::MoveRotateRandomExternalReference::e_InternalTranslate
            ),
            "model_global_rotate"
          )
        )
      );
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolMembrane::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      DefaultMutates::GetInstance().InitializeMutates();
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_AddSSEShortLoop, 0.0);
      MUTATE_TREE.SetMutateProbability( e_MutateAddMemSSEShortLoop, 0.75);

      // reduce split probability
      // if secondary structure prediction were provided and sse resizing is not disabled
      if
      (
        sspred::Methods::GetFlagReadSSPredictions()->GetFlag() &&
        DefaultFlags::GetFlagEnableSSEResize()->GetFlag()
      )
      {
        // iterate over ss prediction methods
        for
        (
          storage::Map< sspred::Method, Mutate>::const_iterator
            sspred_itr( DefaultMutates::GetInstance().m_SSESplit.Begin()),
            sspred_itr_end( DefaultMutates::GetInstance().m_SSESplit.End());
          sspred_itr != sspred_itr_end;
          ++sspred_itr
        )
        {
          const double probability( 0);
          BCL_MessageStd
          (
            "setting split probability for " + sspred_itr->first->GetName() +
            " to " + util::Format()( probability)
          );
          MUTATE_TREE.SetMutateProbability( sspred_itr->second, probability);
        }
      }

      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Model, 0.05);
      MUTATE_TREE.SetMutateProbability( e_MutateModelGlobalZTranslate, 1.5);
      MUTATE_TREE.SetMutateProbability( e_MutateModelGlobalRotate, 1.5);
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolMembrane::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolMembrane::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolMembrane::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "protocol to be applied to membrane proteins with specialized moves and scores"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolMembrane::GetReadMe() const
    {
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "BCL::MP-Fold adapts the BCL::Fold method to function with membrane proteins. KB scores are adjusted to "
        "account for the membrane environment, which is represented statically. Additional MC moves allow for "
        "efficient sampling of the membrane environment.\n"
        "When using BCL::MP-Fold in a publication, and for more detailed information regarding the method, please "
        "cite the publication describing the application's development which is currently in preparation. Refer "
        "to www.meilerlab.org for future details.\n\n"
        "Speficific flags:\n"
        "-membrane #turns on membrane scoring, allows the thickness to be set\n"
        "-tm_helices [tm_helices.pool] #define TM spanning helices in order to score the MP topology\n"
      );

      // end
      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolMembrane::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolMembrane::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_multimer.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_printer_protein_model_multimer.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "coord/bcl_coord_move_rotate_random.h"
#include "coord/bcl_coord_move_translate_external_axis.h"
#include "coord/bcl_coord_move_translate_random.h"
#include "fold/bcl_fold_default_flags.h"
#include "fold/bcl_fold_mutate_protein_model.h"
#include "fold/bcl_fold_mutate_protein_model_sse_swap_multimer.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_setup.h"
#include "mc/bcl_mc_printer_combined.h"
#include "pdb/bcl_pdb_factory.h"
#include "pdb/bcl_pdb_printer_quality_multimer.h"
#include "sspred/bcl_sspred_method_handler.h"
#include "storage/bcl_storage_triplet.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolMultimer::ProtocolMultimer() :
      m_CyclicSubunits( util::GetUndefined< size_t>()),
      m_IsDihedral( false),
      m_Multiplier()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolMultimer
    ProtocolMultimer *ProtocolMultimer::Clone() const
    {
      return new ProtocolMultimer( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolMultimer &ProtocolMultimer::GetInstance()
    {
      static ProtocolMultimer s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolMultimer::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the native multimer
    //! @return the native multimer
    const util::ShPtr< assemble::ProteinModel> &ProtocolMultimer::GetNativeMultimer() const
    {
      static util::ShPtr< assemble::ProteinModel> s_native;

      // if the native is undefined
      if( !s_native.IsDefined())
      {
        // get the native
        s_native = util::ShPtr< assemble::ProteinModel>
        (
          (
            pdb::Factory().ProteinModelFromPDBFilename( GetFlagNativeMultimer()->GetFirstParameter()->GetValue()).Clone()
          )
        );

        // if the list is not empty
        storage::Set< sspred::Method> ss_pred_methods( sspred::Methods::GetCommandLineMethods());
        if( !ss_pred_methods.IsEmpty())
        {
          //try to add the ss predictions, if it fails, copy them from the parent chains
          if
          (
            !sspred::MethodHandler::ReadPredictionsForProteinModel
            (
              ss_pred_methods,
              *s_native,
              DefaultFlags::GetFlagReadSequenceDataPath()->GetParameterList()( 1)->GetValue(),
              DefaultFlags::GetFlagReadSequenceDataPath()->GetFirstParameter()->GetValue()
            )
          )
          {
            // get the chain mappings from the multiplier
            const storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> > chain_mappings
            (
              m_Multiplier.GetTransformationMatrices()
            );

            // iterate over the mappings
            for
            (
              storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> >::const_iterator
                itr( chain_mappings.Begin()), itr_end( chain_mappings.End());
              itr != itr_end; ++itr
            )
            {
              // set the predictions
              util::ShPtr< assemble::Chain> sp_target_chain( s_native->GetChain( itr->Second()));
              SetSSPrediction
              (
                *( sp_target_chain->GetSequence()),
                *( s_native->GetChain( itr->First())->GetSequence())
              );
            }
          }
        }
      }

      // end
      return s_native;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolMultimer::GetAlias() const
    {
      static const std::string s_name( "ProtocolMultimer");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolMultimer::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol for folding multimeric proteins");
      serializer.AddInitializer
        (
         "cyclic subunits",
         "number of cyclic subunits",
         io::Serialization::GetAgent( &m_CyclicSubunits)
         );
      serializer.AddInitializer
        (
         "is dihedral",
         "true if dihedral symmetry, false if cyclic symmetry",
         io::Serialization::GetAgent( &m_IsDihedral)
         );
      serializer.AddInitializer
        (
         "multiplier",
         "protein model multiplier",
         io::Serialization::GetAgent( &m_Multiplier)
         );
      serializer.AddInitializer
        (
         "mutate model global xy translate",
         "translate the model along its xy axis",
         io::Serialization::GetAgent( &e_MutateModelGlobalXYTranslate)
         );
      serializer.AddInitializer
       (
        "mutate model global xyz translate",
        "translate the model in 3D space",
        io::Serialization::GetAgent( &e_MutateModelGlobalXYZTranslate)
        );
      serializer.AddInitializer
      (
        "mutate model global rotate mult",
        "rotate the entire multimer",
        io::Serialization::GetAgent( &e_MutateModelGlobalRotateMult)
      );
      serializer.AddInitializer
      (
        "mutate swap SSE multimer",
        "swap SSEs",
        io::Serialization::GetAgent( &e_MutateSwapSSEMultimer)
      );
      serializer.AddInitializer
      (
        "mutate model global z translate",
        "translate the model along its z axis",
        io::Serialization::GetAgent( &e_MutateModelGlobalZTranslate)
      );
      serializer.AddInitializer
      (
        "mutate model global z rotation",
        "rotate the model along its z axis",
        io::Serialization::GetAgent( &e_MutateModelGlobalZRotation)
      );

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolMultimer::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // insert all the flags in the vector
        s_all_flags_vector.PushBack( GetFlagMultimer());
        s_all_flags_vector.PushBack( GetFlagNativeMultimer());
        s_all_flags_vector.PushBack( pdb::Factory::GetFlagBiomolecule());
      }

      // end
      return s_all_flags_vector;
    }

    //! @brief return command line flag for generating a multimeric protein model
    //! @return command line flag for generating a multimeric protein model
    util::ShPtr< command::FlagInterface> &ProtocolMultimer::GetFlagMultimer()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "symmetry", "\t\tsymmetry type to use to generate a multimeric protein model",
          command::Parameter
          (
            "symmetry_type",
            "\ttype of symmetry (i.e. C3 for 3-fold cyclic symmetry or D2 for 2-fold dihedral symmetry), "
              "currently only Cn and Dn symmetry is supported",
            "C2"
          )
        )
      );

      // end
      return s_flag;
    }

    //! @brief return command line flag for getting the native multimer model
    //! @return command line flag for getting the native multimer model
    util::ShPtr< command::FlagInterface> &ProtocolMultimer::GetFlagNativeMultimer()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "native_multimer", "\t\tnative multimer model for quality calculations",
          command::Parameter
          (
            "native_multimer_filename",
            "\tpath and filename for native multimer pdb",
            ""
          )
        )
      );

      // end
      return s_flag;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolMultimer::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      // if the biomolecule flag was set
      if( pdb::Factory::GetFlagBiomolecule()->GetFlag() && DefaultFlags::GetFlagStartModel()->GetFlag())
      {
        // recalculate the multiplier
        util::ShPtr< assemble::ProteinModelMultiplier> sp_multiplier
        (
          START_MODEL.GetProteinModelData()->GetData( assemble::ProteinModelData::e_Multiplier)
        );

        // make sure the multiplier is defined
        BCL_Assert( sp_multiplier.IsDefined(), "Multiplier is not defined");

        // make a new multiplier that uses the START_MODEL chains
        util::ShPtr< assemble::ProteinModelMultiplier> new_multiplier
        (
          new assemble::ProteinModelMultiplier
          (
            sp_multiplier->GetTransformationMatrices(),
            START_MODEL,
            true
          )
        );

        // get the protein model data
        util::ShPtr< assemble::ProteinModelData> pmd( START_MODEL.GetProteinModelData());

        // set the multiplier in the protein model data
        pmd->Replace( assemble::ProteinModelData::e_Multiplier, new_multiplier);

        // end
        return;
      }

      // get the protein model data
      util::ShPtr< assemble::ProteinModelData> model_data( START_MODEL.GetProteinModelData());

      // if the start model already has a multiplier
      if( model_data->GetData( assemble::ProteinModelData::e_Multiplier).IsDefined())
      {
        // don't modify further
        return;
      }

      // get the symmetry type
      Initialize();

      // move the model along the X-axis so that other subunits can be placed around the external Z-axis
      START_MODEL.Transform( math::Inverse( START_MODEL.GetOrientation()));
      const double offset( 2 * START_MODEL.GetSSEs().GetSize());
      START_MODEL.Translate( linal::Vector3D( offset, 0.0, 0.0));

      // if using dihedral symmetry
      if( m_IsDihedral)
      {
        // translate along the Z-axis as well
        START_MODEL.Translate( linal::Vector3D( 0.0, 0.0, offset));

        // update the protein model data with the multimer
        m_Multiplier =
          assemble::ProteinModelMultiplier
            (
              coord::GetAxes().e_Z,
              coord::GetAxes().e_X,
              m_CyclicSubunits,
              START_MODEL,
              true
          );
        util::ShPtr< assemble::ProteinModelMultiplier> s_multiplier( new assemble::ProteinModelMultiplier( m_Multiplier));
        model_data->Insert( assemble::ProteinModelData::e_Multiplier, s_multiplier);
      }
      // using cyclic symmetry
      else
      {
        // update the protein model data with the multimer
        m_Multiplier =
          assemble::ProteinModelMultiplier
            (
              coord::GetAxes().e_Z,
              m_CyclicSubunits,
              START_MODEL,
              true
          );
        util::ShPtr< assemble::ProteinModelMultiplier> s_multiplier( new assemble::ProteinModelMultiplier( m_Multiplier));
        model_data->Insert( assemble::ProteinModelData::e_Multiplier, s_multiplier);
      }

      // set the protein model data
      START_MODEL.SetProteinModelData( model_data);
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolMultimer::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolMultimer::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolMultimer::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolMultimer::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
      // if a native multimer pdb file was given
      if( GetFlagNativeMultimer()->GetFlag())
      {
        // add the multimer printer
        PRINTER.Insert
        (
          util::ShPtr< mc::PrintInterface< assemble::ProteinModel, double> >
          (
            new assemble::PrinterProteinModelMultimer
            (
              GetSetup().GetPrefix(),
              GetNativeMultimer(),
              GetSetup().GetStorage(),
              GetSetup().GetSuperimposeMeasure()
            )
          )
        );
      }
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolMultimer::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
      // if a native multimer pdb file was given
      if( GetFlagNativeMultimer()->GetFlag())
      {
        FACTORY->AppendPrinter
        (
          util::ShPtr< util::FunctionInterface< assemble::ProteinModel, util::ShPtrList< pdb::Line> > >
          (
            new pdb::PrinterQualityMultimer( GetSetup().GetQualityMeasures(), GetNativeMultimer())
          )
        );
      }
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolMultimer::InitializeMutates()
    {
      // global xy translation
      e_MutateModelGlobalXYTranslate = GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModel
          (
            coord::MoveTranslateExternalAxis( 0.0, 5.0, coord::GetAxes().e_Z), "model_global_xy_translate"
          )
        )
      );

      // global xyz translation
      e_MutateModelGlobalXYZTranslate = GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModel
          (
            coord::MoveTranslateRandom( 0.0, 5.0), "model_global_xyz_translate"
          )
        )
      );

      // global rotation
      e_MutateModelGlobalRotateMult = GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModel( coord::MoveRotateRandom( math::g_Pi, true), "model_global_rotate_mult")
        )
      );

      // swap SSEs between subunits
      e_MutateSwapSSEMultimer = GetMutates().AddMutate
      (
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
        (
          new MutateProteinModelSSESwapMultimer( DefaultFlags::GetFlagFitSwappedSSEs()->GetFlag(), "swap_sse_multimer")
        )
      );

      // if dihedral
      if( m_IsDihedral)
      {
        // z translation
        e_MutateModelGlobalZTranslate = GetMutates().AddMutate
        (
          util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
          (
            new MutateProteinModel
            (
              coord::MoveTranslateRandom( 5.0, false),
              "model_global_z_translate"
            )
          )
        );

        // rotate around z_axis
        e_MutateModelGlobalZRotation = GetMutates().AddMutate
        (
          util::ShPtr< math::MutateInterface< assemble::ProteinModel> >
          (
            new MutateProteinModel
            (
              coord::MoveRotateRandom( linal::Vector3D(), linal::Vector3D( 0, 0, math::g_Pi / 3.0), false),
              "model_global_z_rotation"
            )
          )
        );
      }
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolMultimer::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Model, 0.05);
      MUTATE_TREE.SetMutateProbability( e_MutateModelGlobalRotateMult, 1.0);

      // cyclic or dihedral symmetry
      if( util::IsDefined( m_CyclicSubunits))
      {
        MUTATE_TREE.SetMutateProbability( e_MutateSwapSSEMultimer, 1.0);
        MUTATE_TREE.SetMutateProbability( e_MutateModelGlobalXYTranslate, 1.0);
      }
      // symmetry read in from start model
      else
      {
        MUTATE_TREE.SetMutateProbability( e_MutateModelGlobalXYZTranslate, 1.0);
      }

      if( m_IsDihedral)
      {
        MUTATE_TREE.SetMutateProbability( e_MutateModelGlobalZTranslate, 1.0);
        MUTATE_TREE.SetMutateProbability( e_MutateModelGlobalZRotation, 1.0);
      }
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolMultimer::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolMultimer::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolMultimer::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "protocol for folding multimeric proteins"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolMultimer::GetReadMe() const
    {
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "Adapts the BCL::Fold method to function with homo-multimeric proteins. The protomer is replicated around the "
        "axis of symmetry prior to scoring. The final PDB contains BIOMATRIX lines required to build the multimer."
        "Speficific flags:\n"
        "-symmetry #type of symmetry to use, i.e. C4 for 4-fold cyclic symmetry"
      );

      // end
      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolMultimer::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_CyclicSubunits, ISTREAM);
      io::Serialize::Read( m_IsDihedral, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolMultimer::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_CyclicSubunits, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_IsDihedral, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief initialize symmetry type
    void ProtocolMultimer::Initialize() const
    {
      // get the symmetry type from the command line
      const std::string symmetry_type( GetFlagMultimer()->GetFirstParameter()->GetValue());

      // assert that the string is long enough
      BCL_Assert
      (
        symmetry_type.length() > 1,
        "Incorrect symmetry type given (" + symmetry_type + "), "
          "must be 'C' or 'D' followed by the number of cyclic subunits"
      );

      // set m_IsDihedral based on the first character
      switch( symmetry_type[ 0])
      {
        case 'C':
          m_IsDihedral = false;
          break;
        case 'D':
          m_IsDihedral = true;
          break;
        default:
          BCL_Exit( "Incorrect symmetry type given, must begin with 'C' or 'D'", -1);
          break;
      }

      // get the rest of the string (i.e. the number of subunits)
      m_CyclicSubunits = util::ConvertStringToNumericalValue< size_t>
      (
        symmetry_type.substr( 1, symmetry_type.length() - 1)
      );
    }

    //! @brief copies the ss predictions from TEMPLATE_SEQUENCE onto TARGET_SEQUENCE
    //! @param TARGET_SEQUENCE sequence that will get ss predictions set
    //! @param TEMPLATE_SEQUENCE sequence containing existing ss predictions
    void ProtocolMultimer::SetSSPrediction
    (
      biol::AASequence &TARGET_SEQUENCE,
      const biol::AASequence &TEMPLATE_SEQUENCE
    )
    {
      // assert the sequences are same size
      BCL_Assert
      (
        TARGET_SEQUENCE.GetSize() == TEMPLATE_SEQUENCE.GetSize(),
        "Size of chain " + util::Format()( TARGET_SEQUENCE.GetChainID()) + " does not match size of chain " +
        util::Format()( TEMPLATE_SEQUENCE.GetChainID()) + ". The ss prediction files must be created for that chain."
      );

      // iterate over the sequences
      biol::AASequence::const_iterator template_itr( TEMPLATE_SEQUENCE.Begin());
      const biol::AASequence::const_iterator template_itr_end( TEMPLATE_SEQUENCE.End());
      for
      (
        biol::AASequence::iterator target_itr( TARGET_SEQUENCE.Begin()), target_itr_end( TARGET_SEQUENCE.End());
        target_itr != target_itr_end && template_itr != template_itr_end; ++target_itr, ++template_itr
      )
      {
        // set the predictions
        ( *target_itr)->SetSSPredictions( ( *template_itr)->GetSSPredictions());
      }
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_refinement.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "fold/bcl_fold_default_flags.h"
#include "fold/bcl_fold_default_mutates.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_setup.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolRefinement::ProtocolRefinement()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolRefinement
    ProtocolRefinement *ProtocolRefinement::Clone() const
    {
      return new ProtocolRefinement( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolRefinement &ProtocolRefinement::GetInstance()
    {
      static ProtocolRefinement s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolRefinement::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

     //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolRefinement::GetAlias() const
    {
      static const std::string s_name( "ProtocolRefinement");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolRefinement::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "refinement protocol that uses only small-scale moves");

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolRefinement::GetAllFlags() const
    {
      // construct static vector to hold the flags
      static const util::ShPtrVector< command::FlagInterface> s_flags;

      // end
      return s_flags;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolRefinement::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolRefinement::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolRefinement::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolRefinement::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolRefinement::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolRefinement::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolRefinement::InitializeMutates()
    {
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolRefinement::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      // reset MutateTree
      MUTATE_TREE.Reset();

      // get the pool using the empty model
      util::ShPtr< assemble::SSEPool> sp_pool
      (
        GetSetup().GetEmptyModel()->GetProteinModelData()->GetData( assemble::ProteinModelData::e_Pool)
      );
      BCL_Assert( sp_pool.IsDefined(), "pool is not initialized!");

      // get the average number of helices and strands, and calculate the ratios
      const storage::Pair< double, double> avg_sse_counts( sp_pool->CalculateAverageHelixStrandCounts());
      const double avg_helix_count( avg_sse_counts.First());
      const double avg_strand_count( avg_sse_counts.Second());
      const double avg_sse_count( avg_helix_count + avg_strand_count);
      const double avg_helix_ratio( avg_helix_count / avg_sse_count);
      const double avg_strand_ratio( avg_strand_count / avg_sse_count);

      BCL_MessageStd
      (
        "average helix/strand/sse counts from pool :" + util::Format()( avg_helix_count) + " / " +
         util::Format()( avg_strand_count) + " / " + util::Format()( avg_sse_count) + " / "
      );

      // initialize variables that are based on the counts
      const bool has_helix( avg_helix_count > 0);
      const bool has_strand( avg_strand_count > 0);
      const bool has_helixdomain( avg_helix_count >= 1.5);
      const bool has_helixpair( avg_helix_count >= 1.5);
      const bool has_sheet( avg_strand_count >= 1.5);

      // first choose probabilities for add, remove, swap, move
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Add,         0.00);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Remove,      0.00);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Swap,        0.00);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSE,         0.10);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Helix,       0.20 * avg_helix_ratio);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Strand,      0.20 * avg_strand_ratio);
      const double ssepair_weight(                                     0.20);
      MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSEPair,     ssepair_weight);
      const double domain_weight(                                      0.30);

      // if has a helix pair
      if( has_helixpair)
      {
        // update helix pair weight
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_HelixPair, ssepair_weight * avg_helix_ratio);
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_SSEPair,   ssepair_weight * avg_strand_ratio);
      }

      // update domain weights
      if( has_helixdomain)
      {
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_HelixDomain, domain_weight * avg_helix_ratio);
      }
      if( has_sheet)
      {
        MUTATE_TREE.SetMutateTypeProbability( MutateTree::e_Sheet,       domain_weight * avg_strand_ratio);
      }

      // single SSE moves
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEBendRamachandran,    1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEBendRandomSmall,    1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEBendRandomLarge,    1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETranslateSmall,      3.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETranslateXSmall,    1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETranslateYSmall,    1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETranslateZSmall,    1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSERotateSmall,         3.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSERotateXSmall,       1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSERotateYSmall,       1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSERotateZSmall,       1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSETransformSmall,      6.0);

      // if secondary structure prediction were provided
      if
      (
        sspred::Methods::GetFlagReadSSPredictions()->GetFlag() &&
        DefaultFlags::GetFlagEnableSSEResize()->GetFlag()
      )
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEResizeCTerm, 1.5);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEResizeNTerm, 1.5);
      }

      // single helix moves
      if( has_helix)
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixTranslateXYSmall,     1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixTranslateZSmall,      1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixRotateXYSmall,        1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixRotateZSmall,         1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixTransformXYSmall,     1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixTransformZSmall,      1.0);
      }

      // single strand moves
      if( has_strand)
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_StrandTranslateZSmall,     1.0);
      }

      // sse pair moves
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEPairTranslateNoHingeSmall,    1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEPairTranslateSmall,             1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEPairRotateSmall,                1.0);
      MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SSEPairTransformSmall,             1.0);

      // helix pair moves
      if( has_helixpair)
      {
        // helix pair moves
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixPairRotateZSmallNoHinge,    1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixPairRotateZSmallHinge,       1.0);
      }

      // helix domain moves
      if( has_helixdomain)
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixDomainTranslateSmall,  1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixDomainRotateSmall,     1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_HelixDomainTransformSmall,  1.0);
      }

      // sheet moves
      if( has_sheet)
      {
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetRotateSmall,           1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetTranslateSmall,        1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_SheetTransformSmall,        1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_twist_small,            1.0);
        MUTATE_TREE.SetMutateProbability( DefaultMutates::GetInstance().e_Sheet_register_fix,           1.0);
      }
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolRefinement::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolRefinement::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns string containing short description of the protocol
    //! @return string containing short description of the protocol
    const std::string &ProtocolRefinement::GetDescription() const
    {
      // initialize static const string variable to hold the description
      static const std::string s_description
      (
        "refinement protocol for de novo folding"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolRefinement::GetReadMe() const
    {
      // initialize static const string variable to hold the readme
      static const std::string s_readme
      (
        "The refinement protocol focuses on small amplitude moves that maintain the current topology but optimize "
        "interactions between SSEs and introduce bends into SSEs."
      );

      // end
      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolRefinement::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolRefinement::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_restraint.h"

// includes from bcl - sorted alphabetically
#include "command/bcl_command_flag_interface.h"
#include "fold/bcl_fold_mutate_tree.h"
#include "fold/bcl_fold_mutates.h"
#include "restraint/bcl_restraint_interface.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolRestraint::ProtocolRestraint()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProtocolRestraint
    ProtocolRestraint *ProtocolRestraint::Clone() const
    {
      return new ProtocolRestraint( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief access to only instance
    //! @return reference to only instance
    ProtocolRestraint &ProtocolRestraint::GetInstance()
    {
      static ProtocolRestraint s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProtocolRestraint::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolRestraint::GetAlias() const
    {
      static const std::string s_name( "ProtocolRestraint");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolRestraint::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol for using restraints in folding run");

      return serializer;
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolRestraint::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector
      (
        util::ShPtrVector< command::FlagInterface>::Create
        (
          restraint::GetFlagRestraintsTypes(),
          restraint::GetFlagRestraintsFilePrefix()
        )
      );

      // end
      return s_all_flags_vector;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolRestraint::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolRestraint::InitializeScores()
    {
      // get the restraint types
      const storage::Set< restraint::Type> restraint_types
      (
        restraint::GetFlagRestraintsTypes()->GetObjectSet< restraint::Type>()
      );

      // iterate through the restraint types and add their scores to scores
      for
      (
        storage::Set< restraint::Type>::const_iterator
          restraint_itr( restraint_types.Begin()), restraint_itr_end( restraint_types.End());
        restraint_itr != restraint_itr_end;
        ++restraint_itr
      )
      {
        // copy the restraint data so that the scores can be set
        restraint::Type sp_restraint_data( *restraint_itr);
        sp_restraint_data->InitializeScores();
      }
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolRestraint::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
      // get the restraint types
      const storage::Set< restraint::Type> restraint_types
      (
        restraint::GetFlagRestraintsTypes()->GetObjectSet< restraint::Type>()
      );

      // iterate through the restraint types to modify their score weights
      for
      (
        storage::Set< restraint::Type>::const_iterator
          restraint_itr( restraint_types.Begin()), restraint_itr_end( restraint_types.End());
        restraint_itr != restraint_itr_end;
        ++restraint_itr
      )
      {
        ( *restraint_itr)->ModifyScoreWeightSet( SCORE_WEIGHT_SET);
      }
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolRestraint::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolRestraint::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolRestraint::ModifyFactory
    (
      util::ShPtr< pdb::Factory> &FACTORY,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolRestraint::InitializeMutates()
    {
      // get the restraint types
      const storage::Set< restraint::Type> restraint_types
      (
        restraint::GetFlagRestraintsTypes()->GetObjectSet< restraint::Type>()
      );

      // iterate through the restraint types and add their mutates to mutates
      for
      (
        storage::Set< restraint::Type>::const_iterator
          restraint_itr( restraint_types.Begin()), restraint_itr_end( restraint_types.End());
        restraint_itr != restraint_itr_end;
        ++restraint_itr
      )
      {
        // copy the restraint data so that the mutates can be set
        restraint::Type sp_restraint_data( *restraint_itr);
        sp_restraint_data->InitializeMutates();
      }
    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolRestraint::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      // get the restraint types
      const storage::Set< restraint::Type> restraint_types
      (
        restraint::GetFlagRestraintsTypes()->GetObjectSet< restraint::Type>()
      );

      // let each restraint modify the mutate tree
      for
      (
        storage::Set< restraint::Type>::const_iterator
          restraint_itr( restraint_types.Begin()), restraint_itr_end( restraint_types.End());
        restraint_itr != restraint_itr_end;
        ++restraint_itr
      )
      {
        ( *restraint_itr)->ModifyMutateTree( MUTATE_TREE);
      }
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolRestraint::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolRestraint::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolRestraint::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "protocol for using restraints such as NOE, distance restraints"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &ProtocolRestraint::GetReadMe() const
    {
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "This protocol adapts the BCL::Fold method to function with experimental restraints. To see what is available "
        "use the -help flag and view the description for restraint_types.\n"
        "When using restraint folding in a publication, and for more detailed information regarding the method, please "
        "cite the publication describing the application's development which is currently in preparation. Refer "
        "to www.meilerlab.org for future details.\n\n"
        "Specific flags:\n"
        "-restraint_types #Types of restraints available to use\n"
        "-restraint_prefix #Prefix for the restraint file(s). BCL will add the \".\" and the appropriate file "
        "extension defined by the type of restraint used (e.g. NMR NOE restraints have the extension, \".noe_star\""
      );

      // end
      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProtocolRestraint::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProtocolRestraint::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocols.h"

// includes from bcl - sorted alphabetically
#include "command/bcl_command_flag_dynamic.h"
#include "command/bcl_command_parameter.h"
#include "command/bcl_command_parameter_check_enumerate.h"
#include "fold/bcl_fold_protocol_assembly.h"
#include "fold/bcl_fold_protocol_create.h"
#include "fold/bcl_fold_protocol_default.h"
#include "fold/bcl_fold_protocol_dock.h"
#include "fold/bcl_fold_protocol_em.h"
#include "fold/bcl_fold_protocol_ensemble.h"
#include "fold/bcl_fold_protocol_ensemble_filter.h"
#include "fold/bcl_fold_protocol_ensemble_replicate_conformation.h"
#include "fold/bcl_fold_protocol_ensemble_switch_conformation.h"
#include "fold/bcl_fold_protocol_loop_close.h"
#include "fold/bcl_fold_protocol_loop_coordinate_add.h"
#include "fold/bcl_fold_protocol_membrane.h"
#include "fold/bcl_fold_protocol_multimer.h"
#include "fold/bcl_fold_protocol_refinement.h"
#include "fold/bcl_fold_protocol_restraint.h"
#include "fold/bcl_fold_protocol_template.h"
#include "util/bcl_util_enumerate.hpp"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    Protocols::Protocols() :
      e_Default(           AddEnum( "Default",           util::SiPtr< ProtocolInterface>( ProtocolDefault::GetInstance()))),
      e_Create(            AddEnum( "Create",            util::SiPtr< ProtocolInterface>( ProtocolCreate::GetInstance()))),
      e_Assembly(          AddEnum( "Assembly",          util::SiPtr< ProtocolInterface>( ProtocolAssembly::GetInstance()))),
      e_Refinement(        AddEnum( "Refinement",        util::SiPtr< ProtocolInterface>( ProtocolRefinement::GetInstance()))),
      e_Membrane(          AddEnum( "Membrane",          util::SiPtr< ProtocolInterface>( ProtocolMembrane::GetInstance()))),
      e_Restraint(         AddEnum( "Restraint",         util::SiPtr< ProtocolInterface>( ProtocolRestraint::GetInstance()))),
      e_EM(                AddEnum( "EM",                util::SiPtr< ProtocolInterface>( ProtocolEM::GetInstance()))),
      e_Multimer(          AddEnum( "Multimer",          util::SiPtr< ProtocolInterface>( ProtocolMultimer::GetInstance()))),
      e_Template(          AddEnum( "Template",          util::SiPtr< ProtocolInterface>( ProtocolTemplate::GetInstance()))),
      e_LoopCoordinateAdd( AddEnum( "LoopCoordinateAdd", util::SiPtr< ProtocolInterface>( ProtocolLoopCoordinateAdd::GetInstance()))),
      e_LoopClose(         AddEnum( "LoopClose",         util::SiPtr< ProtocolInterface>( ProtocolLoopClose::GetInstance()))),
      e_Dock(              AddEnum( "Dock",              util::SiPtr< ProtocolInterface>( ProtocolDock::GetInstance()))),
      e_Ensemble(          AddEnum( "Ensemble",          util::SiPtr< ProtocolInterface>( ProtocolEnsemble::GetInstance()))),
      e_EnsembleSwitchConformation   ( AddEnum( "EnsembleSwitchConformation",    util::SiPtr< ProtocolInterface>( ProtocolEnsembleSwitchConformation::GetInstance()))),
      e_EnsembleReplicateConformation( AddEnum( "EnsembleReplicateConformation", util::SiPtr< ProtocolInterface>( ProtocolEnsembleReplicateConformation::GetInstance()))),
      e_EnsembleFilter               ( AddEnum( "EnsembleFilter",                util::SiPtr< ProtocolInterface>( ProtocolEnsembleFilter::GetInstance())))
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief return command line flag for choosing the protocols to be used to run folding
    //! @return command line flag for choosing the protocols to be used to run folding
    util::ShPtr< command::FlagInterface> &Protocols::GetFlagProtocols()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagDynamic
        (
          "protocols",
          "\tFlag for choosing the protocols to be used to run folding",
          command::Parameter
          (
            "protocol",
            "\tprotocol to use",
            command::ParameterCheckEnumerate< Protocols>(),
            GetProtocols().e_Default.GetName()
          ), 0, GetProtocols().GetEnumCount()
        )
      );

      // end
      return s_flag;
    }

    //! @brief return command line flag for choosing the protocols to be used for mutates
    //! @return command line flag for choosing the protocols to be used for mutates
    util::ShPtr< command::FlagInterface> &Protocols::GetFlagMutateProtocols()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagDynamic
        (
          "mutate_protocols",
          "\tFlag for choosing the protocols to be used to for mutates",
          command::Parameter
          (
            "mutate_protocol",
            "\tmutate protocol to use",
            command::ParameterCheckEnumerate< Protocols>(),
            GetProtocols().e_Default.GetName()
          ), 0, GetProtocols().GetEnumCount()
        )
      );

      // end
      return s_flag;
    }

    //! @brief return command line flag for choosing the protocols to be used for scoring
    //! @return command line flag for choosing the protocols to be used for scoring
    util::ShPtr< command::FlagInterface> &Protocols::GetFlagScoreProtocols()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagDynamic
        (
          "score_protocols",
          "\tFlag for choosing the protocols to be used to for scores",
          command::Parameter
          (
            "score_protocol",
            "\tscore_protocol to use",
            command::ParameterCheckEnumerate< Protocols>(),
            GetProtocols().e_Default.GetName()
          ), 0, GetProtocols().GetEnumCount()
        )
      );

      // end
      return s_flag;
    }

    //! @brief return list of protocols specified to be used specified in command line
    //! @return list of protocols to be used specified in command line
    storage::List< Protocol> Protocols::GetCommandLineProtocolList()
    {
      // initialize list to hold protocols
      storage::List< Protocol> protocols_list( 1, GetProtocols().e_Default);

      // get the vector of protocols from command line flag
      storage::Vector< Protocol> protocols( GetFlagProtocols()->GetObjectList< Protocol>());

      // iterate over these
      for
      (
        storage::Vector< Protocol>::const_iterator
          protocol_itr( protocols.Begin()), protocol_itr_end( protocols.End());
        protocol_itr != protocol_itr_end; ++protocol_itr
      )
      {
        // if it's not already in the list
        if( std::find( protocols_list.Begin(), protocols_list.End(), *protocol_itr) == protocols_list.End())
        {
          // then pushback into the list
          protocols_list.PushBack( *protocol_itr);
        }
      }

      // end
      return protocols_list;
    }

    //! @brief return list of protocols to be used for defining scores specified in command line
    //! @return list of protocols to be used for defining scores specified in command line
    storage::List< Protocol> Protocols::GetCommandLineScoreProtocolList()
    {
      // initialize list to hold protocols
      storage::List< Protocol> protocols_list( GetCommandLineProtocolList());

      // get the vector of protocols from command line flag
      storage::Vector< Protocol> protocols( GetFlagScoreProtocols()->GetObjectList< Protocol>());

      // iterate over these
      for
      (
        storage::Vector< Protocol>::const_iterator
          protocol_itr( protocols.Begin()), protocol_itr_end( protocols.End());
        protocol_itr != protocol_itr_end; ++protocol_itr
      )
      {
        // if it's not already in the list
        if( std::find( protocols_list.Begin(), protocols_list.End(), *protocol_itr) == protocols_list.End())
        {
          // then pushback into the list
          protocols_list.PushBack( *protocol_itr);
        }
      }

      // end
      return protocols_list;
    }

    //! @brief return list of protocols to be used for defining mutates specified in command line
    //! @return list of protocols to be used for defining mutates specified in command line
    storage::List< Protocol> Protocols::GetCommandLineMutateProtocolList()
    {
      // initialize static list to hold protocols
      storage::List< Protocol> protocols_list( GetCommandLineProtocolList());

      // get the vector of protocols from command line flag
      storage::Vector< Protocol> protocols( GetFlagMutateProtocols()->GetObjectList< Protocol>());

      // iterate over these
      for
      (
        storage::Vector< Protocol>::const_iterator
          protocol_itr( protocols.Begin()), protocol_itr_end( protocols.End());
        protocol_itr != protocol_itr_end; ++protocol_itr
      )
      {
        // if it's not already in the list
        if( std::find( protocols_list.Begin(), protocols_list.End(), *protocol_itr) == protocols_list.End())
        {
          // then pushback into the list
          protocols_list.PushBack( *protocol_itr);
        }
      }

      // end
      return protocols_list;
    }

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &Protocols::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief construct on access function for all Protocols
    //! @return reference to only instances of Protocols
    Protocols &GetProtocols()
    {
      return Protocols::GetEnums();
    }

  } // namespace fold

  namespace util
  {

  /////////////////////////////
  // explicit instantiations //
  /////////////////////////////

    template class BCL_API Enumerate< SiPtr< fold::ProtocolInterface>, fold::Protocols>;

  } // namespace util
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_protocol_template.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sheet.h"
#include "fold/bcl_fold_mutate_protein_model_add_sheet_from_template.h"
#include "fold/bcl_fold_mutate_protein_model_domain.h"
#include "fold/bcl_fold_mutate_sheet_fit_to_template.h"
#include "fold/bcl_fold_mutate_tree.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProtocolTemplate::ProtocolTemplate()
    {
    }

    //! @brief returns a pointer to a new ProtocolTemplate
    //! @return pointer to a new ProtocolTemplate
    ProtocolTemplate *ProtocolTemplate::Clone() const
    {
      return new ProtocolTemplate( *this);
    }

  ///////////
  // flags //
  ///////////

    //! @brief returns all flags that are specialized for this protocol
    //! @return all flags that are specialized for this protocol
    const util::ShPtrVector< command::FlagInterface> &ProtocolTemplate::GetAllFlags() const
    {
      // initialize static ShPtrVector of FlagInterfaces to form the comment line
      static util::ShPtrVector< command::FlagInterface> s_all_flags_vector;

      // if the flag vector is initialize for the first time
      if( s_all_flags_vector.IsEmpty())
      {
        // insert all the flags in the vector
//        s_all_flags_vector.PushBack( assemble::FoldTemplateHandler::GetFlagFoldTemplates());
//        s_all_flags_vector.PushBack( assemble::SheetTemplateHandler::GetFlagSheetTemplates());
//        s_all_flags_vector.PushBack( GetFlagFoldSSEPairTemplates());
      }

      // end
      return s_all_flags_vector;
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the only instance of this class
    //! @return the only instance of this class
    ProtocolTemplate &ProtocolTemplate::GetInstance()
    {
      static ProtocolTemplate s_protocol_instance;
      return s_protocol_instance;
    }

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &ProtocolTemplate::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &ProtocolTemplate::GetAlias() const
    {
      static const std::string s_name( "ProtocolTemplate");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProtocolTemplate::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "protocol for de novo folding of proteins using fold templates");
      serializer.AddInitializer
        (
         "mutate sheet fit to template",
         "selects a sheet from the protein model and fits it to a sheet template from the database",
         io::Serialization::GetAgent( &e_MutateSheetFitToTemplate)
         );
      serializer.AddInitializer
        (
         "mutate add sheet from template",
         "selects strands from the SSE pool and fits them into sheet template from the database",
         io::Serialization::GetAgent( &e_MutateSheetFitToTemplate)
         );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief modifies the start model
    //! @param START_MODEL Start model to be modified
    void ProtocolTemplate::ModifyStartModel( assemble::ProteinModel &START_MODEL) const
    {
      // create the mutate that adds a sheet template to the model
      util::ShPtr< math::MutateInterface< assemble::ProteinModel> > sp_mutate
      (
        new MutateProteinModelAddSheetFromTemplate()
      );

      // apply the mutate on the model
      math::MutateResult< assemble::ProteinModel> result( sp_mutate->operator()( START_MODEL));
      if( result.GetArgument().IsDefined())
      {
        START_MODEL = *result.GetArgument();
      }
    }

    //! @brief initialize the scores and add them to Scores enumerator
    void ProtocolTemplate::InitializeScores()
    {
    }

    //! @brief modify the score weight set
    //! @param SCORE_WEIGHT_SET Score weight set
    void ProtocolTemplate::ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
    {
    }

    //! @brief modify the terminate object
    //! @param CRITERION which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolTemplate::ModifyCriterion
    (
      opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the printer object
    //! @param PRINTER which will be modified by protocols
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolTemplate::ModifyPrinter
    (
      mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER,
      const mc::Stage &STAGE
    ) const
    {
    }

    //! @brief modify the pdb factory object
    //! @param FACTORY pdb factory to be modified
    //! @param STAGE Stage in which this terminate will be used
    void ProtocolTemplate::ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE) const
    {
    }

    //! @brief initialize the mutates and add them to Mutates enumerator
    void ProtocolTemplate::InitializeMutates()
    {
//      // mutate that bends a SSE according to a template
//      e_MutateSSEBendTemplate = GetMutates().AddMutate
//      (
//        MutateProteinModelSSE
//        (
//          util::CloneToShPtr( assemble::LocatorSSERandom()),
//          util::CloneToShPtr( MutateSSEBendTemplate( assemble::SSEGeometryWithinSizeTolerance( 0, 0))),
//          "sse_bend_template"
//        )
//      );

      // mutate that fits a sheet to template
      if( !GetMutates().HaveEnumWithName( "sheet_fit_to_template"))
      {
        e_MutateSheetFitToTemplate = GetMutates().AddMutate
        (
          MutateProteinModelDomain( assemble::CollectorSheet(), MutateSheetFitToTemplate(), "sheet_fit_to_template")
        );
      }

      if( !GetMutates().HaveEnumWithName( MutateProteinModelAddSheetFromTemplate().GetScheme()))
      {
        // mutate that forms a sheet from strands in the SSE pool and fits it to a template
        e_MutateAddSheetFromTemplate = GetMutates().AddMutate( MutateProteinModelAddSheetFromTemplate());
      }

    }

    //! @brief modify the mutate tree used
    //! @param MUTATE_TREE MutateTree to be modified
    void ProtocolTemplate::ModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      MUTATE_TREE.SetMutateProbability( e_MutateSheetFitToTemplate, 0.75);
      MUTATE_TREE.SetMutateProbability( e_MutateAddSheetFromTemplate, 0.25);
    }

    //! @brief get the mutate tree associated with this protocol
    //! @return the mutate tree associated with this protocol
    util::ShPtr< MutateTree> ProtocolTemplate::GetMutateTree() const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());
      ModifyMutateTree( *sp_mutate_tree);
      return sp_mutate_tree;
    }

    //! @brief merges this protocol's mutate tree into given mutate tree
    //! @param MUTATE_TREE tree into which to merge this protocol's tree
    void ProtocolTemplate::MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
    {
      util::ShPtr< MutateTree> sp_mutate_tree( GetMutateTree());
      MUTATE_TREE.Merge( *sp_mutate_tree);
    }

  ////////////
  // readme //
  ////////////

    //! @brief returns readme information
    //! @return string containing information about this protocol
    const std::string &ProtocolTemplate::GetDescription() const
    {
      // initialize string to store the description
      static const std::string s_description
      (
        "protocol for using structural fold templates in the structure prediction process"
      );

      // end
      return s_description;
    }

    //! @brief returns readme information
    //! @return string containing information about this protocol
    const std::string &ProtocolTemplate::GetReadMe() const
    {
      // initialize string to store the readme information
      static const std::string s_readme
      (
        "readme for template protocol"
      );

      // end
      return s_readme;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read object from input stream
    //! @param ISTREAM input stream to read object from
    //! @return input stream which was read from
    std::istream &ProtocolTemplate::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write object into  output stream
    //! @param OSTREAM output stream to write object into
    //! @param INDENT number of indentations to separate members
    //! @return output stream object was written into
    std::ostream &ProtocolTemplate::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_scores.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_membrane.h"
#include "fold/bcl_fold_default_flags.h"
#include "math/bcl_math_binary_function_cached.h"
#include "math/bcl_math_function_cached.h"
#include "score/bcl_score_protein_model_wrapper.h"
#include "util/bcl_util_enumerate.hpp"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    Scores::Scores()
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &Scores::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief adds a score to the enumerated scores
    //! @param SCORE Score to add
    Scores::EnumType Scores::AddScore( const util::ShPtr< score::ProteinModel> &SCORE)
    {
      return AddEnum( SCORE->GetScheme(), SCORE);
    }

    //! @brief adds a vector of scores to the enumerated scores
    //! @param SCORES Scores to add
    storage::Vector< Scores::EnumType>
    Scores::AddScoreVector( const util::ShPtrVector< score::ProteinModel> &SCORES)
    {
      storage::Vector< Scores::EnumType> score_enums;

      // iterate through the scores to add them
      for
      (
        util::ShPtrVector< score::ProteinModel>::const_iterator
          score_itr( SCORES.Begin()), score_itr_end( SCORES.End());
        score_itr != score_itr_end;
        ++score_itr
      )
      {
        score_enums.PushBack( AddEnum( ( *score_itr)->GetScheme(), *score_itr));
      }

      return score_enums;
    }

    //! @brief function for adding a new enum
    //! @param NAME name of the current enum
    //! @param OBJECT object to be enumerated
    Scores::EnumType &Scores::AddEnum
    (
      const std::string &NAME,
      const util::ShPtr< score::ProteinModel> &OBJECT
    )
    {
      // make sure an enum with the given name does not exist already
      if( HaveEnumWithName( NAME))
      {
        BCL_MessageTop( "A score enum with the given name already exists: " + NAME);
      }

      // call the add enum
      return util::Enumerate< util::ShPtr< score::ProteinModel>, Scores>::AddEnum( NAME, OBJECT);
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief wrap a given unary function for ProteinModel into a FunctionCached object
    //! @param SP_FUNCTION ShPtr to function be wrapped
    //! @return a FunctionCached object
    util::ShPtr< score::ProteinModel>
    Scores::WrapCacheProteinModelScore
    (
      const util::ShPtr< score::ProteinModel> &SP_FUNCTION
    )
    {
      // wrap function into cache function
      util::ShPtr< math::FunctionCached< assemble::ProteinModel, double> > sp_cache_function
      (
        new math::FunctionCached< assemble::ProteinModel, double>
        (
          SP_FUNCTION,
          &assemble::ProteinModel::GetDestructorSignal,
          &assemble::ProteinModel::GetChangeSignal
        )
      );

      // create score
      util::ShPtr< score::ProteinModel> sp_score
      (
        new score::ProteinModelWrapper( sp_cache_function, SP_FUNCTION->GetType(), SP_FUNCTION->GetReadableScheme())
      );

      // end
      return sp_score;
    }

    //! @brief wrap a given unary function for sse into a FunctionCached object
    //! @param SP_FUNCTION ShPtr to function be wrapped
    //! @return a FunctionCached object
    util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > >
    Scores::WrapCacheSSEScore
    (
      const util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > > &SP_FUNCTION
    )
    {
      // wrap function into cache function
      util::ShPtr< math::BinaryFunctionCached< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > > sp_cache_function
      (
        new math::BinaryFunctionCached< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> >
        (
          SP_FUNCTION,
          &assemble::SSE::GetDestructorSignal,
          &biol::Membrane::GetDestructorSignal
        )
      );

      // add signal handler for coordinate changes
      sp_cache_function->AddSignalHandlerForArgument( &assemble::SSE::GetCoordinateChangeSignal);

      // end
      return sp_cache_function;
    }

    //! @brief wrap a given binary function for two sse into a BinaryFunctionCached object
    //! @param SP_FUNCTION ShPtr to binary function be wrapped
    //! @param SYMMETRIC is function symmetric (a,b is the same as b,a)
    //! @return a FunctionCached object
    util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> >
    Scores::WrapCacheSSEPairScore
    (
      const util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> > &SP_FUNCTION,
      const bool SYMMETRIC
    )
    {
      // wrap function into cache function
      util::ShPtr< math::BinaryFunctionCached< assemble::SSE, assemble::SSE, double> > sp_cache_function
      (
        new math::BinaryFunctionCached< assemble::SSE, assemble::SSE, double>
        (
          SP_FUNCTION,
          &assemble::SSE::GetDestructorSignal,
          SYMMETRIC
        )
      );

      // add signal handler for coordinate changes
      sp_cache_function->AddSignalHandlerForArgument( &assemble::SSE::GetCoordinateChangeSignal);

      // end
      return sp_cache_function;
    }

    //! @brief construct on access function for all Scores
    //! @return reference to only instances of Scores
    Scores &GetScores()
    {
      return Scores::GetEnums();
    }

  } // namespace fold

  namespace util
  {

  /////////////////////////////
  // explicit instantiations //
  /////////////////////////////

    template class BCL_API Enumerate< ShPtr< score::ProteinModel>, fold::Scores>;

  } // namespace util
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_score_weight_set.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_serialization.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ScoreWeightSet::s_Instance
    (
      GetObjectInstances().AddInstance( new ScoreWeightSet())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ScoreWeightSet::ScoreWeightSet() :
        m_WeightMap()
    {
    }

    //! @brief constructor from a table
    //! @param TABLE that contains the weights
    ScoreWeightSet::ScoreWeightSet( const storage::Table< double> &TABLE) :
        m_WeightMap()
    {
      InitializeFromTable( TABLE);
    }

    //! @brief Clone function
    //! @return pointer to new ScoreWeightSet
    ScoreWeightSet *ScoreWeightSet::Clone() const
    {
      return new ScoreWeightSet( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ScoreWeightSet::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &ScoreWeightSet::GetAlias() const
    {
      static const std::string s_name( "ScoreWeights");
      return s_name;
    }

    //! @brief returns the weight map
    //! @return weight map
    const storage::Map< Score, double> &ScoreWeightSet::GetWeightMap() const
    {
      return m_WeightMap;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief get weight for a given score
    //! @param SCORE Score of interest
    //! @return weight for the given score
    double ScoreWeightSet::GetWeight( const Score &SCORE)
    {
      return m_WeightMap[ SCORE];
    }

    //! @brief sets the weight of the given score
    //! @param SCORE enum of the score
    //! @param WEIGHT Weight to be assigned to score
    //! @return true is score is defined and weight was set; false otherwise
    bool ScoreWeightSet::SetWeight
    (
      const Score &SCORE,
      const double WEIGHT
    )
    {
      // make sure the a score is defined
      if( !SCORE.IsDefined())
      {
        BCL_MessageVrb( "undefined score supplied!");
        return false;
      }

      // update the weight
      m_WeightMap[ SCORE] = WEIGHT;

      // end
      return true;
    }

    //! @brief sets the weight of the given score
    //! @param SCORE_NAME name of the score
    //! @param WEIGHT Weight to be assigned to score
    //! @return true is score name is a valid score name and weight was set; false otherwise
    bool ScoreWeightSet::SetWeight
    (
      const std::string &SCORE_NAME,
      const double WEIGHT
    )
    {
      // construct the score enum from the name and try to set the weight
      return SetWeight( Score( SCORE_NAME), WEIGHT);
    }

    //! @brief resets all weights to zero
    void ScoreWeightSet::Reset()
    {
      // iterate over the map
      for
      (
        storage::Map< Score, double>::iterator map_itr( m_WeightMap.Begin()), map_itr_end( m_WeightMap.End());
        map_itr != map_itr_end; ++map_itr
      )
      {
        // set the weight to zero
        map_itr->second = 0.0;
      }
    }

    //! @brief constructs the scores and returns it
    //! @return constructed score
    util::ShPtr< score::ProteinModelScoreSum> ScoreWeightSet::ConstructScoreSum() const
    {
      // construct the score
      util::ShPtr< score::ProteinModelScoreSum> scoresum( new score::ProteinModelScoreSum( m_WeightMap));

//      // true if an ensemble of models is being folded
//      if( fold::ProtocolEnsemble::GetFlagEnsembleSize()->GetFlag())
//      {
//        BCL_MessageCrt( "setting score sum to use ensemble score sum");
//
//        // set scoresum pointer to a protein ensemble score sum
//        scoresum = util::ShPtr< score::ProteinModelScoreSum>( new score::ProteinEnsembleScoreSum( m_WeightMap));
//      }

      // return the scoresum object
      return scoresum;
    }

    //! @brief creates a table from scoring weight set
    //! @return table with the scoring weight set
    storage::Table< double> ScoreWeightSet::CreateTable() const
    {
      // create a vector to hold column names
      storage::Vector< std::string> column_names;
      // create a vector to hold the weightst
      storage::Vector< double> weights;

      // iterate over the map
      for
      (
        storage::Map< Score, double>::const_iterator map_itr( m_WeightMap.Begin()), map_itr_end( m_WeightMap.End());
        map_itr != map_itr_end; ++map_itr
      )
      {
        // insert the name and the weight
        column_names.PushBack( map_itr->first.GetName());
        weights.PushBack( map_itr->second);
      }

      // create a table
      storage::Table< double> table( column_names);
      // insert a row
      table.InsertRow( "weights", weights);

      // end
      return table;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ScoreWeightSet::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_WeightMap, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ScoreWeightSet::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_WeightMap, OSTREAM);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief initialize this ScoreWeightSet from a table
    //! @param TABLE Table that contains the weightset
    void ScoreWeightSet::InitializeFromTable( const storage::Table< double> &TABLE)
    {
      // if the table does not have row weights
      if( !TABLE.HasRow( "weights"))
      {
        BCL_Assert
        (
          TABLE.GetHeader().HasColumn( "weights"),
          "The given score weightset table has no row or column named \"weights\""
        );

        // transpose table
        storage::Table< double> transposed_table( TABLE.GetTransposedTable());

        // initialize with the transposed table
        return InitializeFromTable( transposed_table);
      }

      // get the map from the row
      storage::Map< std::string, double> string_map( TABLE[ "weights"].ConvertToMap());

      // iterate over the map
      for
      (
        storage::Map< std::string, double>::const_iterator map_itr( string_map.Begin()), map_itr_end( string_map.End());
        map_itr != map_itr_end; ++map_itr
      )
      {
        // get the score enum with the corresponding name
        const Score &score( GetScores().GetEnumFromName( map_itr->first));

        // make sure there is a score with the given string
        BCL_Assert
        (
          score != GetScores().e_Undefined,
          "There is no score with the name \"" + map_itr->first + "\" among:\n" +
          util::Format()( storage::Vector< std::string>( GetScores().GetEnumStrings()))
        );

        // set the weight for this score in the weight map
        m_WeightMap[ score] = map_itr->second;
      }
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ScoreWeightSet::GetSerializer() const
    {
      io::Serializer params;
      params.SetClassDescription( "scores and weights for folding");
      params.AddInitializer
      (
        "",
        "the map with scores and weights",
        io::Serialization::GetAgent( &m_WeightMap)
      );
      return params;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_setup.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "assemble/bcl_assemble_protein_storage_file.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "command/bcl_command_flag_separator.h"
#include "fold/bcl_fold_default_flags.h"
#include "fold/bcl_fold_protocol_ensemble.h"
#include "fold/bcl_fold_protocols.h"
#include "io/bcl_io_file.h"
#include "pdb/bcl_pdb_factory.h"
#include "sspred/bcl_sspred_method_handler.h"
#include "util/bcl_util_wrapper.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

    //! @brief flag for returning the fold setup used
    //! @return the fold setup used
    const Setup &GetSetup()
    {
      return Setup::GetStaticInstance();
    }

  //////////
  // data //
  //////////

    //! @brief construct and return a static instance of the class
    //! @return a static instance of the class
    const Setup &Setup::GetStaticInstance()
    {
      return GetStaticInstanceNonConst();
    }

    //! @brief reset the static instance
    void Setup::InitializeStaticInstance()
    {
      GetStaticInstanceNonConst() = Setup();
    }

    //! @brief return vector of all flags applicable
    //! @return vector of all flags applicable
    util::ShPtrVector< command::FlagInterface> Setup::GetAllFlags()
    {
      // initialize static data to store flags
      util::ShPtrVector< command::FlagInterface> flags;

      // iterate over all the protocols possible
      for
      (
        std::vector< Protocol>::const_iterator
          protocol_itr( GetProtocols().Begin()), protocol_itr_end( GetProtocols().End());
        protocol_itr != protocol_itr_end; ++protocol_itr
      )
      {
        // insert all the flags in the vector
        const util::ShPtr< command::FlagInterface> sp_separator
        (
          new command::FlagSeparator
          (
            "\n==============================================================================================\n" +
            protocol_itr->GetName() + ":\t" + ( **protocol_itr)->GetDescription() + "\n\n"
          )
        );
        flags.PushBack( sp_separator);

        // pushback the flags for this protocol
        flags.Append( ( **protocol_itr)->GetAllFlags());
      }

      // end
      return flags;
    }

    //! @brief return string containing readme information
    //! @return string containing readme information
    const std::string &Setup::GetReadme()
    {
      // initialize readme string
      static std::string s_readme;

      // if readme is empty
      if( s_readme.empty())
      {
        // iterate over all the protocols possible
        for
        (
          std::vector< Protocol>::const_iterator
            protocol_itr( GetProtocols().Begin()), protocol_itr_end( GetProtocols().End());
          protocol_itr != protocol_itr_end; ++protocol_itr
        )
        {
          s_readme +=
            "===============================================\n" +
            protocol_itr->GetName() + "\n" +
            "===============================================\n" +
            ( **protocol_itr)->GetReadMe() + "\n\n";
        }
      }

      // end
      return s_readme;
    }

    //! @brief construct and return a non-const static instance of the class
    //! @return a non-const static instance of the class
    Setup &Setup::GetStaticInstanceNonConst()
    {
      // initialize static instance
      static Setup s_static_instance;

      // end
      return s_static_instance;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief private default constructor
    Setup::Setup() :
      m_EmptyModel(),
      m_NativeModel(),
      m_StartModel(),
      m_NumberRounds( DefaultFlags::GetFlagNumberModels()->GetFirstParameter()->GetNumericalValue< size_t>()),
      m_QualityMeasures( quality::Measures::GetCommandLineQualityMeasures()),
      m_SuperimposeMeasure
      (
        quality::SuperimposeMeasure
        (
          quality::SuperimposeMeasures::GetFlagSuperimposeMeasure()->GetFirstParameter()->GetValue()
        )
      ),
      m_Prefix( DefaultFlags::GetFlagPrefix()->GetFirstParameter()->GetValue()),
      m_StepStatuses(),
      m_Storage( assemble::ProteinStorageFile::GetDefaultStorage())
    {
      // if no native was given but quality measures were specified
      if( !DefaultFlags::GetFlagNativeModel()->GetFirstParameter()->GetWasSetInCommandLine())
      {
        // if quality measures were specified
        BCL_Assert
        (
          m_QualityMeasures.IsEmpty(),
          "No native model was given, but quality measures were specified!"
        );

        // if superimpose measure was specified
        BCL_Assert
        (
          m_SuperimposeMeasure == quality::GetSuperimposeMeasures().e_NoSuperimpose,
          "No native model was given, but a superimpose measure was specified!"
        );
      }

      // iterate over given step statuses
      for
      (
        util::ShPtrVector< command::ParameterInterface>::const_iterator
          step_status_itr( DefaultFlags::GetFlagPrintMinimization()->GetParameterList().Begin()),
          step_status_itr_end( DefaultFlags::GetFlagPrintMinimization()->GetParameterList().End());
        step_status_itr != step_status_itr_end;
        ++step_status_itr
      )
      {
        // insert into the set
        m_StepStatuses.Insert( opti::StepStatusEnum( ( *step_status_itr)->GetValue()));
      }
    }

    //! @brief Clone function
    //! @return pointer to new Setup
    Setup *Setup::Clone() const
    {
      return new Setup( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &Setup::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the native/template model if one was provided
    //! @return the native/template model if one was provided
    const util::ShPtr< assemble::ProteinModel> &Setup::GetNativeModel() const
    {
      // if the native model is not initialized and a pdb filename was given at the commandline
      if( !m_NativeModel.IsDefined() && DefaultFlags::GetFlagNativeModel()->GetFlag())
      {
        // read the model
        m_NativeModel =
          util::ShPtr< assemble::ProteinModel>
          (
            pdb::Factory().ProteinModelFromPDBFilename
            (
              DefaultFlags::GetFlagNativeModel()->GetFirstParameter()->GetValue()
            ).Clone()
          );

        BCL_Assert( m_NativeModel.IsDefined(), "native model is not defined");
      }

      // return native model
      return m_NativeModel;
    }

    //! @brief return the protein model constructed from aa sequences (given as fastas) that are supposed to be folded
    //! @return the protein model constructed from aa sequences (given as fastas) that are supposed to be folded
    const util::ShPtr< assemble::ProteinModel> &Setup::GetEmptyModel() const
    {
      // empty model is not initialized
      if( !m_EmptyModel.IsDefined())
      {
        // make sure the flags are correctly set
        BCL_Assert
        (
          DefaultFlags::GetFlagNativeModel()->GetFlag() ||
          DefaultFlags::GetFlagFastaRead()->GetFlag() ||
          DefaultFlags::GetFlagStartModel()->GetFlag(),
          "One of the flags for native, fasta, or start model should be set to construct fold setup!!"
        );

        // if native pool flag was given
        if( DefaultFlags::GetFlagUseNativeSSEsAsPool()->GetFlag())
        {
          BCL_Assert
          (
            DefaultFlags::GetFlagNativeModel()->GetFlag(),
            "A native structure has to be provided for using native pool flag!!"
          );
        }

        // construct the ProteinModelData
        util::ShPtr< assemble::ProteinModelData> sp_model_data( new assemble::ProteinModelData());

        // set the identification
        std::string identification( m_Prefix);

        // if a native was given
        if( DefaultFlags::GetFlagNativeModel()->GetFlag())
        {
          // set the identification to the filename minus path and extension
          identification = io::File::RemoveFullExtension
          (
            io::File::SplitToPathAndFileName
            (
              DefaultFlags::GetFlagNativeModel()->GetFirstParameter()->GetValue()
            ).Second()
          );
        }

        // update the protein model data w/ the identification
        sp_model_data->Insert
        (
          assemble::ProteinModelData::e_Identification,
          util::ShPtr< util::Wrapper< std::string> >( new util::Wrapper< std::string>( identification))
        );

        // initialize map to hold the min pool lengths
        storage::Map< biol::SSType, size_t> min_pool_sse_lengths( assemble::SSEPool::GetCommandLineMinSSELengths());

        // initialize empty pool
        util::ShPtr< assemble::SSEPool> sp_pool( new assemble::SSEPool());

        // if a native pdb was provided
        if( DefaultFlags::GetFlagNativeModel()->GetFirstParameter()->GetWasSetInCommandLine())
        {
          // if fasta flag was given give a warning
          if( DefaultFlags::GetFlagFastaRead()->GetFlag())
          {
            BCL_MessageCrt( "Given fasta flag is skipped since a native structure is provided");
          }

          // update empty model to native model
          m_EmptyModel =
            util::ShPtr< assemble::ProteinModel>( new assemble::ProteinModel( GetNativeModel()->GetEmptyChains()));

          // insert the native model into model data
          sp_model_data->Insert( assemble::ProteinModelData::e_NativeModel, GetNativeModel());

          // make a copy of the native model
          util::ShPtr< assemble::ProteinModel> sp_native_model_copy( GetNativeModel()->Clone());

          // filter the SSEs by given pool min sse sizes
          sp_native_model_copy->FilterByMinSSESizes( min_pool_sse_lengths);

          // insert the filtered native model to the PM data
          sp_model_data->Insert( assemble::ProteinModelData::e_NativeFilteredModel, sp_native_model_copy);

          // if the flag for using native SSE definitions were given
          if( DefaultFlags::GetFlagUseNativeSSEsAsPool()->GetFlag())
          {
            // if fasta flag was given give a warning
            if( assemble::SSEPool::GetFlagPoolRead()->GetFlag())
            {
              BCL_MessageCrt( "Given pool file is skipped because use native pool flag is given!");
            }

            // update the pool to have the corresponding SSE definitions from the native model
            sp_pool = util::ShPtr< assemble::SSEPool>
            (
              new assemble::SSEPool
              (
                sp_native_model_copy->GetSSEs(),
                true,
                DefaultFlags::GetFlagUseNativeSSEsAsPool()->GetFirstParameter()->GetValue() == "ideal"
              )
            );
          }
          else
          {
            // open pool file
            io::IFStream read;
            const std::string pool_file( assemble::SSEPool::GetFlagPoolRead()->GetFirstParameter()->GetValue());
            BCL_MessageCrt( "Reading pool from file " + pool_file);
            io::File::MustOpenIFStream( read, pool_file);

            // set the identification to the filename minus path and extension
            identification = io::File::RemoveFullExtension
            (
              io::File::SplitToPathAndFileName
              (
                DefaultFlags::GetFlagNativeModel()->GetFirstParameter()->GetValue()
              ).Second()
            );

            // read pool
            sp_pool->ReadSSEPool
            (
              read,
              *m_EmptyModel,
              min_pool_sse_lengths[ biol::GetSSTypes().HELIX],
              min_pool_sse_lengths[ biol::GetSSTypes().STRAND]
            );
          }
        }
        // if no native pdb is given, but just fasta files
        else
        {
          // initialize empty model
          m_EmptyModel = util::ShPtr< assemble::ProteinModel>( new assemble::ProteinModel());

          // create set for all chain ids represented in the pool
          const storage::Set< char> pool_chain_ids
          (
            assemble::SSEPool::GetChainsRepresented( assemble::SSEPool::GetFlagPoolRead()->GetFirstParameter()->GetValue())
          );

          // fasta chain ids stored
          storage::Set< char> fasta_chain_ids;

          // create a itr for looping over chain ids
          util::ShPtrVector< command::ParameterInterface>::const_iterator chain_id_itr;

          // if chain id flag was given
          if( DefaultFlags::GetFlagChainIdRead()->GetFlag())
          {
            // make sure the number of fastas and chain ids is the same
            BCL_Assert
            (
              DefaultFlags::GetFlagFastaRead()->GetParameterList().GetSize()
                == DefaultFlags::GetFlagChainIdRead()->GetParameterList().GetSize(),
              "Same number of fasta files and chain ids required!"
            );

            // initialize itr for the following loop
            chain_id_itr = DefaultFlags::GetFlagChainIdRead()->GetParameterList().Begin();
          }

          // iterate through the list of fastas and chain ids
          for
          (
            util::ShPtrVector< command::ParameterInterface>::const_iterator
              fasta_itr( DefaultFlags::GetFlagFastaRead()->GetParameterList().Begin()),
              fasta_itr_end( DefaultFlags::GetFlagFastaRead()->GetParameterList().End());
            fasta_itr != fasta_itr_end;
            ++fasta_itr
          )
          {
            // remove fast extension
            const std::string fasta_id( io::File::RemoveFullExtension( ( *fasta_itr)->GetValue()));

            // get the chain id, either the last char before the ".fasta" extension or in the list of chain ids
            const char chain_id
            (
              DefaultFlags::GetFlagChainIdRead()->GetFlag() ?
                ( *chain_id_itr)->GetValue()[ 0] :
                fasta_id[ fasta_id.length() - 1]
            );

            // make sure this chain is also found in the pool chain ids
            BCL_Assert
            (
              pool_chain_ids.Find( chain_id) != pool_chain_ids.End(),
              "The given chain id \"" + util::Format()( chain_id) + "\" is not found in the pool"
            );

            // check if chain id was already inserted
            BCL_Assert
            (
              fasta_chain_ids.Find( chain_id) == fasta_chain_ids.End(),
              "fasta files with identical chain identifiers have been found"
            );

            // insert chain id
            fasta_chain_ids.Insert( chain_id);

            // open fasta file
            io::IFStream read;

            // set the identification to the filename minus path and extension
            identification = io::File::RemoveFullExtension
            (
              io::File::SplitToPathAndFileName
              (
                DefaultFlags::GetFlagNativeModel()->GetFirstParameter()->GetValue()
              ).Second()
            );
               io::File::MustOpenIFStream( read, ( *fasta_itr)->GetValue());

            // insert chain for fasta file
            m_EmptyModel->Insert
            (
              pdb::Factory( biol::GetAAClasses().e_AABackBone).ChainFromFastaStream( chain_id, read)
            );

            // if chain ids were given on the command line increase the chain id itr
            if( DefaultFlags::GetFlagChainIdRead()->GetFlag())
            {
              ++chain_id_itr;
            }
          }

          // open pool file
          io::IFStream read;
          io::File::MustOpenIFStream( read, assemble::SSEPool::GetFlagPoolRead()->GetFirstParameter()->GetValue());

          // read pool
          sp_pool->ReadSSEPool
          (
            read,
            *m_EmptyModel,
            min_pool_sse_lengths[ biol::GetSSTypes().HELIX],
            min_pool_sse_lengths[ biol::GetSSTypes().STRAND]
          );

          // close stream
          io::File::CloseClearFStream( read);
        }

        // make sure pool has SSEs
        BCL_Assert( !sp_pool->IsEmpty(), "Pool must contain SSEs for assembly!");

        // if separate pool flag was provided and native pool is being used
        if( DefaultFlags::GetFlagPoolSeparate()->GetFlag() && !sp_pool->IsOverlapping())
        {
          // separate pools
          const bool success
          (
            sp_pool->Separate
            (
              assemble::SSEPool::GetCommandLineMinSSELengths(),
              DefaultFlags::GetFlagPoolSeparate()->GetFirstParameter()->GetNumericalValue< size_t>()
            )
          );
          if( !success)
          {
            BCL_MessageCrt( "Separate pools operation unsuccessful")
          }

          // make sure to prune it to remove loops
          sp_pool->Prune( assemble::SSEPool::GetCommandLineMinSSELengths());

        }

        // if the list is not empty
        storage::Set< sspred::Method> ss_pred_methods( sspred::Methods::GetCommandLineMethods());

        if( !ss_pred_methods.IsEmpty())
        {

          std::string prefix( DefaultFlags::GetFlagReadSequenceDataPath()->GetParameterList()( 1)->GetValue());
          std::string path( DefaultFlags::GetFlagReadSequenceDataPath()->GetFirstParameter()->GetValue());

          //add ss predictions to m_StartModel
          sspred::MethodHandler::ReadPredictionsForProteinModel
          (
            ss_pred_methods,
            *m_EmptyModel,
            DefaultFlags::GetFlagReadSequenceDataPath()->GetParameterList()( 1)->GetValue(),
            DefaultFlags::GetFlagReadSequenceDataPath()->GetFirstParameter()->GetValue()
          );
        }

        sp_model_data->Insert( assemble::ProteinModelData::e_Pool, sp_pool);
        // set data on the model
        m_EmptyModel->SetProteinModelData( sp_model_data);

        // true if ensemble of models is going to be folded
        if( ProtocolEnsemble::GetFlagEnsembleSize()->GetFlag())
        {
          BCL_MessageCrt( "setting ensemble");
          util::ShPtr< assemble::ProteinEnsemble> ensemble
          (
            new assemble::ProteinEnsemble( util::ShPtr< assemble::ProteinModel>( m_EmptyModel->HardCopy()))
          );

          m_EmptyModel = ensemble;
        }
      }

      // return
      return m_EmptyModel;
    }

    //! @brief return the starting model after adding sses from -start_model file to it
    //!        (this is used to refine an existing starting model)
    //! @return return the starting model after adding sses from -start_model file to it
    const util::ShPtr< assemble::ProteinModel> Setup::GetStartModel() const
    {
      // start model is not initialized
      if( !m_StartModel.IsDefined())
      {
        // use the empty model to get the sequences
        m_StartModel = util::ShPtr< assemble::ProteinModel>( GetEmptyModel()->Clone());

        // if a pdb was provided
        if( DefaultFlags::GetFlagStartModel()->GetFlag())
        {
          util::ShPtr< assemble::ProteinModel> sp_model_provided
          (
            new assemble::ProteinModel
            (
              pdb::Factory().ProteinModelFromPDBFilename( DefaultFlags::GetFlagStartModel()->GetFirstParameter()->GetValue())
            )
          );

          // iterate over the chains in the start model
          for
          (
            util::ShPtrVector< assemble::Chain>::iterator
              chain_itr( sp_model_provided->GetChains().Begin()),
              chain_itr_end( sp_model_provided->GetChains().End());
            chain_itr != chain_itr_end; ++chain_itr
          )
          {
            // iterate over each SSE in that given chain
            for
            (
              storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap>::const_iterator
                sse_itr( ( *chain_itr)->GetData().Begin()), sse_itr_end( ( *chain_itr)->GetData().End());
              sse_itr != sse_itr_end; ++sse_itr
            )

            // if this SSE has defined coordinates
            if( ( *sse_itr)->HasDefinedCoordinates())
            {
              // insert the SSEs from the chain
              m_StartModel->Insert( *sse_itr);
            }
          }

          // connect the sequences of the SSEs from the start model to the native model
          m_StartModel->ConnectSSEToChainData();

          // update any protein model data
          util::ShPtr< assemble::ProteinModelData> sp_data( m_StartModel->GetProteinModelData());
          sp_data->Insert( *( sp_model_provided->GetProteinModelData()));
          m_StartModel->SetProteinModelData( sp_data);
        }
      }

      // return model
      return m_StartModel;
    }

    //! @brief return quality measures to be calculated
    //! @return quality measures to be calculated
    const storage::Set< quality::Measure> &Setup::GetQualityMeasures() const
    {
      return m_QualityMeasures;
    }

    //! @brief return superimpose measure
    //! @return quality superimpose measure
    const quality::SuperimposeMeasure &Setup::GetSuperimposeMeasure() const
    {
      return m_SuperimposeMeasure;
    }

    //! @brief gives the prefix object
    //! @return the prefix that is prepended to output files
    const std::string &Setup::GetPrefix() const
    {
      return m_Prefix;
    }

    //! @brief gives the set of step statuses that will be printed by printers
    //! @return set of step statuses that will be printed by printers
    const storage::Set< opti::StepStatusEnum> &Setup::GetStepStatuses() const
    {
      return m_StepStatuses;
    }

    //! @brief get the protein storage
    //! @return protein storage
    const util::ShPtr< assemble::ProteinStorageFile> &Setup::GetStorage() const
    {
      return m_Storage;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &Setup::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &Setup::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  } // namespace fold
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "fold/bcl_fold_stage_factory.h"

// includes from bcl - sorted alphabetically
#include "fold/bcl_fold_default_flags.h"
#include "fold/bcl_fold_mutates.h"
#include "io/bcl_io_file.h"
#include "mc/bcl_mc_temperature_accepted.h"
#include "storage/bcl_storage_hash_map.h"
#include "util/bcl_util_logger_interface.h"
#include "util/bcl_util_message.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace fold
  {

  //////////
  // data //
  //////////

    const std::string StageFactory::s_LineTypeNames[ s_NumberLineTypes] =
    {
      "NUMBER_CYCLES",         // Number of cycles
      "STAGE",                 // Start of a stage definition, followed by an optional name
      "TYPE",                  // type of the approximation used for this stage
      "FOLD_PROTOCOLS",        // fold protocols to use
      "SCORE_PROTOCOLS",       // score protocols to use (optional)
      "MUTATE_PROTOCOLS",      // mutate protocols to use (optional)
      "SCORE_WEIGHTSET",       // score weight set table
      "SCORE_WEIGHTSET_FILE",  // file containing score weight set
      "SCORE_DROPOUT_RATE",    // Fraction of scores to drop randomly for each protein model
      "MUTATE_WEIGHTSET",      // mutate weight set table
      "MUTATE_WEIGHTSET_FILE", // file containing mutate weight set
      "NUMBER_ITERATIONS",     // followed by total number iterations and max number unimproved
      "MODIFY_START_MODEL",    // true if the stage should modify the start model, false otherwise
      "PRINT_START_MODEL",     // whether to print the start model for this stage
      "PRINT_ITERATION_MODELS",// whether to print the all models for this stage
      "PRINT_END_MODEL",       // whether to print the end model for this stage
      "PRINT_TRACKER_HISTORY", // whether to print the tracker history for this stage
      "POOL_POSTFIX",          // file postfix containing pool that should be used for this stage
      "STAGE_END"              // end of a stage definition
    };

    //! @brief finds the LineType enum that corresponds to given string
    //! @param LINE_NAME Line name of interest
    //! @return the LineType enum that corresponds to given string
    StageFactory::LineType StageFactory::LineTypeFromString( const std::string &LINE_NAME)
    {
      // iterate over line types
      for( size_t i( 0); i < s_NumberLineTypes; ++i)
      {
        // if strings match then return corresponding enum
        if( LINE_NAME == s_LineTypeNames[ i])
        {
          return LineType( i);
        }
      }
      // otherwise exit
      BCL_Exit( "The provided stage file line name is not valid " + LINE_NAME, -1);
      // this line needs to be added to prevent the compiler warning
      return e_NumberCycles;
    }

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> StageFactory::s_Instance
    (
      GetObjectInstances().AddInstance( new StageFactory())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    StageFactory::StageFactory()
    {
    }

    //! @brief Clone function
    //! @return pointer to new StageFactory
    StageFactory *StageFactory::Clone() const
    {
      return new StageFactory( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &StageFactory::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief construct stages
    //! @return vector of stages
    util::ShPtrVector< StageInterface> StageFactory::CreateStages()
    {
      // initialize stages
      util::ShPtrVector< StageInterface> stages;

      // if StageFile was specified
      if( DefaultFlags::GetFlagStagesFileRead()->GetFlag())
      {
        BCL_MessageStd( "Constructing multi-stage from stages file");
        BCL_MessageStd( "All related flags specified in commandline will be ignored");

        // get the number of cycles from command line
        size_t number_cycles
        (
          DefaultFlags::GetFlagStagesNumberCycles()->GetFirstParameter()->GetNumericalValue< size_t>()
        );

        // construct the stages from the stage file
        stages = CreateStagesFromFile( number_cycles);
      }
      else // construct from command line options
      {
        stages.PushBack( CreateStage());
      }

      return stages;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &StageFactory::Read( std::istream &ISTREAM)
    {
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &StageFactory::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief sets the temperature for the given STAGE
    void StageFactory::SetTemperature( mc::Stage &STAGE)
    {
      // create the temperature control
      util::ShPtr< mc::TemperatureInterface> sp_temperature
      (
        new mc::TemperatureAccepted
        (
          // start fraction
          mc::TemperatureAccepted::GetParameterStartFraction()->GetNumericalValue< double>(),
          // end fraction
          mc::TemperatureAccepted::GetParameterEndFraction()->GetNumericalValue< double>(),
          // total number of steps
          STAGE.GetMaxNumberIterations(),
          // start temperature

          mc::TemperatureAccepted::GetParameterStartTemperature()->GetNumericalValue< double>(),
          // nr steps between each update
          mc::TemperatureAccepted::GetParameterUpdateInterval()->GetNumericalValue< size_t>()
        )
      );

      // set the temperature
      STAGE.SetTemperature( sp_temperature);
    }

    //! @brief construct and return stages from stage file
    //! @param NUMBER_CYCLES number of cycles which can be updated from command line
    //! @return stages constructed from stage file
    util::ShPtrVector< StageInterface> StageFactory::CreateStagesFromFile( size_t &NUMBER_CYCLES)
    {
      // stores the stages
      util::ShPtrVector< StageInterface> stages;

      // open a stream to the specified stage file
      io::IFStream read;
      const std::string stage_file( DefaultFlags::GetFlagStagesFileRead()->GetFirstParameter()->GetValue());
      io::File::MustOpenIFStream( read, stage_file);
      BCL_MessageStd( "Reading stage file " + stage_file)

      // stores the total number of stages defined in the stage file
      size_t number_stages( 0);

      // stores the number of cycles
      size_t number_cycles
      (
        DefaultFlags::GetFlagStagesNumberCycles()->GetFirstParameter()->GetNumericalValue< size_t>()
      );

      // parse the stage file
      std::string line;
      while( !read.eof() && std::getline( read, line))
      {
        // if the line is empty, skip it
        if( util::TrimString( line).empty())
        {
          continue;
        }

        // determine the line type
        storage::Vector< std::string> strings( util::SplitString( line));
        LineType line_type( LineTypeFromString( strings.FirstElement()));

        // if this line sets the number of cycles
        if( line_type == e_NumberCycles)
        {
          number_cycles = util::ConvertStringToNumericalValue< size_t>( strings( 1));
        }
        else if( line_type == e_StageStart) // This line marks the begin of a stage definition
        {
          // determine the name for the stage
          ++number_stages;
          std::string name;
          if( strings.GetSize() > 1)
          {
            name = strings( 1);
          }
          else
          {
            name = "stage_" + util::Format()( number_stages);
          }

          // construct the stage form the stage file
          stages.PushBack( CreateStage( read, name, number_stages));
        }
        else
        {
          BCL_Exit( strings.FirstElement() + " is unknown or cannot be used outside of a stage", -1);
        }
      }

      // repeat the stages based on the number of cycles provided
      util::ShPtrVector< StageInterface> original_stages( stages);
      for( size_t i( 1); i < number_cycles; ++i)
      {
        for
        (
          util::ShPtrVector< StageInterface>::const_iterator it( original_stages.Begin());
          it != original_stages.End();
          ++it
        )
        {
          stages.PushBack( *it);
        }
      }

      return stages;
    }

    //! @brief constructs one stage from an IFStream
    //! @param READ IFStream to create the stage from
    //! @param NAME the name of the stage
    //! @param NUMBER the number of the stage
    //! @return shared pointer to the constructed stage
    util::ShPtr< StageInterface> StageFactory::CreateStage( io::IFStream &READ, const std::string &NAME, const size_t &NUMBER)
    {
      // create a map to store line types and their respective values
      storage::HashMap< size_t, storage::Vector< std::string> > linetypes_values;

      // add the name of the stage
      linetypes_values.Insert
      (
        storage::Pair< size_t, storage::Vector< std::string> >
        (
          e_StageStart,
          storage::Vector< std::string>( 1, NAME)
        )
      );

      // parse the stage section until the end of the stage or the end of the file is reached
      std::string line;
      bool stage_closed( false);
      while( !READ.eof() && std::getline( READ, line))
      {
        // determine the line type
        const storage::Vector< std::string> strings( util::SplitString( line));
        const LineType line_type( LineTypeFromString( strings.FirstElement()));

        // if the end of the stage definition is reached
        if( line_type == e_StageEnd)
        {
          stage_closed = true;
          break;
        }

        // check if the same line type has already been read for this stage
        BCL_Assert( linetypes_values.Count( line_type) == 0, "Redefinition of " + s_LineTypeNames[ line_type]);

        // store the line type and its values for further processing
        storage::Vector< std::string> values;
        if( strings.GetSize() > 1)
        {
          values = storage::Vector< std::string>( strings.Begin() + 1, strings.Last() + 1);
        }
        linetypes_values.Insert( storage::Pair< size_t, storage::Vector< std::string> >( line_type, values));
      }

      // make sure that the definition for this stage was complete
      BCL_Assert( stage_closed, "Stage definition is not complete");

      // make sure that the stage type was given
      BCL_Assert( linetypes_values.Count( e_Type) == 1, "Stage type was not provided");

      // construct the stage according to the given type
      util::ShPtr< StageInterface> sp_stage;
      const std::string &type( linetypes_values[ e_Type].FirstElement());
      if( type.compare( "MCM") == 0)
      {
        sp_stage = util::ShPtr< StageInterface>( CreateMcStage( linetypes_values, NUMBER));
      }
      else if( type.compare( "GRADMIN") == 0)
      {

      }
      else
      {
        BCL_Exit( type + " is an unknown stage type", -1);
      }

      return sp_stage;
    }

    //! @brief constructs a stage from the command line
    //! @return shared pointer to the constructed stage
    util::ShPtr< StageInterface> StageFactory::CreateStage()
    {
      BCL_MessageStd( "Constructing single stage from command line");

      // constructing a single stage from the specified protocols
      util::ShPtr< mc::Stage> sp_stage
      (
        new mc::Stage
        (
          GetProtocols().GetCommandLineProtocolList(),
          GetProtocols().GetCommandLineScoreProtocolList(),
          GetProtocols().GetCommandLineMutateProtocolList()
        )
      );

      // initialize the stage
      sp_stage->InitializeScores();
      sp_stage->InitializeMutates();
      SetSingleStageScoreFunction( *sp_stage);
      SetSingleStageMutate( *sp_stage);

      sp_stage->SetMaxNumberIterations
      (
        DefaultFlags::GetFlagMCNumberIterations()->GetParameterList()( 0)->GetNumericalValue< size_t>()
      );
      sp_stage->SetMaxNumberUnimprovedIterations
      (
        DefaultFlags::GetFlagMCNumberIterations()->GetParameterList()( 1)->GetNumericalValue< size_t>()
      );
      sp_stage->SetName( "Stage_0");
      SetTemperature( *sp_stage);
      sp_stage->SetPrefix( GetSetup().GetPrefix());

      return sp_stage;
    }

    //! @brief creates a monte carlo metropolis stage based on the given parameters
    //! @param SETTINGS contains the parameters to construct the stage from
    //! @return shared pointer to the constructed stage
    util::ShPtr< StageInterface> StageFactory::CreateMcStage
    (
      storage::HashMap< size_t, storage::Vector< std::string> > &SETTINGS,
      const size_t &NUMBER
    )
    {
      // create the fold, score and mutate protocols from the arguments given in the stage file
      storage::List< Protocol> fold_protocols( CreateUniqueProtocolList( ConstructProtocolList( SETTINGS[ e_FoldProtocols])));
      storage::List< Protocol> score_protocols( CreateUniqueProtocolList( ConstructProtocolList( SETTINGS[ e_ScoreProtocols])));
      storage::List< Protocol> mutate_protocols( CreateUniqueProtocolList( ConstructProtocolList( SETTINGS[ e_MutateProtocols])));

      // the final unique protocols
      storage::List< Protocol> fold_protocols_final;
      storage::List< Protocol> score_protocols_final;
      storage::List< Protocol> mutate_protocols_final;

      // if the fold protocols have not been specified, they are constructed from the score and mutate protocols
      if( fold_protocols.IsEmpty())
      {
        BCL_MessageStd( "No fold protocols specified, constructing from score and mutate protocols");
        BCL_Assert
        (
          !score_protocols.IsEmpty() && !mutate_protocols.IsEmpty(),
          "Both score and mutate protocols need to be set if fold protocols are not provided for stage"
        );
        fold_protocols = storage::List< Protocol>( score_protocols);
        fold_protocols.Append( mutate_protocols);
        fold_protocols_final = CreateUniqueProtocolList( fold_protocols);
      }
      else // if the fold protocols have been specified
      {
        // if the score protocols have not been specified, they are constructed from the fold protocols
        if( score_protocols.IsEmpty())
        {
          BCL_MessageStd( "No score protocols specified, constructing from fold protocols");
          score_protocols = fold_protocols;
        }

        // if the mutate protocols have not been specified, they are constructed from the fold protocols
        if( mutate_protocols.IsEmpty())
        {
          BCL_MessageStd( "No mutate protocols specified, constructing from fold protocols");
          mutate_protocols = fold_protocols;
        }

        // use the provided fold protocols as the final fold protocols
        fold_protocols_final = fold_protocols;
      }

      // initialize the score protocols
      for( storage::List< Protocol>::iterator it( score_protocols.Begin()); it != score_protocols.End(); ++it)
      {
        // only initialize if the have not been initialized yet
        if( std::find( score_protocols_final.Begin(), score_protocols_final.End(), *it) == score_protocols_final.End())
        {
          BCL_MessageStd( "\t\tInitializing scores from protocol " + it->GetName());
          ( **it)->InitializeScores();
        }
      }

      // initialize the mutate protocols
      for( storage::List< Protocol>::iterator it( mutate_protocols.Begin()); it != mutate_protocols.End(); ++it)
      {
        // only initialize if the have not been initialized yet
        if( std::find( mutate_protocols_final.Begin(), mutate_protocols_final.End(), *it) == mutate_protocols_final.End())
        {
          BCL_MessageStd( "\t\tInitializing mutates from protocol " + it->GetName());
          // initialize mutate
          ( **it)->InitializeMutates();
          // insert into initialized mutates
          mutate_protocols_final.PushBack( *it);
        }
      }

      // create the score weight set
      util::ShPtr< ScoreWeightSet> sp_score_weight;
      // if a score weight set file was provided create the score weight set from it
      if( SETTINGS.Count( e_ScoreWeightSetFile) == 1)
      {
        const std::string &score_weightset_file( SETTINGS[ e_ScoreWeightSetFile]( 0));

        storage::Table< double> score_weightset = ReadTableFromFile( score_weightset_file);

        sp_score_weight = util::ShPtr< ScoreWeightSet>( new ScoreWeightSet( score_weightset));
      }
      else // otherwise construct the weight set from the score protocols
      {
        BCL_MessageStd( "Score weight set not specified, constructing from score protocols");
        sp_score_weight = util::ShPtr< ScoreWeightSet>( new ScoreWeightSet);
        for( storage::List< Protocol>::const_iterator it( score_protocols.Begin()); it != score_protocols.End(); ++it)
        {
          ( **it)->ModifyScoreWeightSet( *sp_score_weight);
        }
      }

      // create the scoring function
      util::ShPtr< score::ProteinModelScoreSum> sp_scoring_function( sp_score_weight->ConstructScoreSum());

      // create the mutate weight set
      util::ShPtr< MutateTree> sp_mutate_tree;
      // if a mutate weight set file was provided create the score weight set from it
      if( SETTINGS.Count( e_MutateWeightSetFile) == 1)
      {
        const std::string &mutate_weightset_file( SETTINGS[ e_MutateWeightSetFile]( 0));
        storage::Table< double> mutate_weightset = ReadTableFromFile( mutate_weightset_file);
        sp_mutate_tree = util::ShPtr< MutateTree>( new MutateTree( mutate_weightset));
      }
      else // otherwise construct the weight set from the mutate protocols
      {
        BCL_MessageStd( "Mutate weight set not specified, constructing from mutate protocols");
        sp_mutate_tree = util::ShPtr< MutateTree>( new MutateTree());
        for( storage::List< Protocol>::const_iterator it( mutate_protocols_final.Begin()); it != mutate_protocols_final.End(); ++it)
        {
          sp_mutate_tree = ( **it)->GetMutateTree();
          ( **it)->MergeAndModifyMutateTree( *sp_mutate_tree);
        }
      }

      // set the maximum number of steps / of unimproved steps in a row
      const size_t max_num_steps
      (
        util::ConvertStringToNumericalValue< size_t>( SETTINGS[ e_NumberIterations]( 0))
      );
      const size_t max_num_unimproved_steps
      (
        util::ConvertStringToNumericalValue< size_t>( SETTINGS[ e_NumberIterations]( 1))
      );
      const size_t scores_to_drop
      (
        SETTINGS[ e_ScoreDropoutRate].GetSize()
        ? util::ConvertStringToNumericalValue< double>( SETTINGS[ e_ScoreDropoutRate]( 0))
          * sp_score_weight->GetWeightMap().GetSize()
        : 0
      );

      // set the printing options
      const bool print_start_model( SETTINGS.Count( e_PrintStartModel) == 0 ? false : true);
      const bool print_itr_model( SETTINGS.Count( e_PrintIterationModel) == 0 ? false : true);
      const bool print_end_model( SETTINGS.Count( e_PrintEndModel) == 0 ? false : true);
      const bool print_tracker_history( SETTINGS.Count( e_PrintTrackerHistory) == 0 ? false : true);

      // set the pool for this stage if specified
      const std::string &pool_postfix( SETTINGS.Count( e_PoolPostfix) == 1 ? SETTINGS[ e_PoolPostfix]( 0) : "");

      // create the mcm stage
      util::ShPtr< mc::Stage> sp_stage( new mc::Stage( fold_protocols_final, score_protocols_final, mutate_protocols_final));
      sp_stage->SetStageNumber( NUMBER);
      sp_stage->SetScoreWeightSet( sp_score_weight);
      sp_stage->SetScoreFunction( sp_scoring_function);
      sp_stage->SetNumberScoresToDrop( scores_to_drop);
      sp_stage->SetMutateTree( sp_mutate_tree);
      sp_stage->SetMutate( sp_mutate_tree->ConstructMutates());
      sp_stage->SetMaxNumberIterations( max_num_steps);
      sp_stage->SetMaxNumberUnimprovedIterations( max_num_unimproved_steps);
      sp_stage->SetPrintStartModel( print_start_model);
      sp_stage->SetPrintIterationModels( print_itr_model);
      sp_stage->SetPrintEndModel( print_end_model);
      sp_stage->SetPrintTrackerHistory( print_tracker_history);
      sp_stage->SetPoolPostfix( pool_postfix);
      sp_stage->SetPrefix( GetSetup().GetPrefix());

      // set the temperature for this stage
      SetTemperature( *sp_stage);

      if( util::GetMessenger().GetCurrentMessageLevel() >= util::Message::e_Verbose)
      {
        WriteStage( *sp_stage, util::GetLogger());
      }

      return sp_stage;
    }

    //! @brief write stage to stream
    //! @param STAGE Stage to be written
    //! @param OSTREAM ostream to be written to
    //! @return ostream which was written to
    std::ostream &StageFactory::WriteStage( const mc::Stage &STAGE, std::ostream &OSTREAM)
    {
      // initialize indent
      static const std::string s_indent( "  ");

      // write name
      OSTREAM << s_LineTypeNames[ e_StageStart] << ' ' << STAGE.GetName() << '\n';

      // write protocols
      OSTREAM << s_indent << s_LineTypeNames[ e_FoldProtocols];
      WriteProtocolList( STAGE.GetFoldProtocols(), OSTREAM);
      OSTREAM << s_indent << s_LineTypeNames[ e_ScoreProtocols];
      WriteProtocolList( STAGE.GetScoreProtocols(), OSTREAM);
      OSTREAM << s_indent << s_LineTypeNames[ e_MutateProtocols];
      WriteProtocolList( STAGE.GetMutateProtocols(), OSTREAM);

      // write the number of iterations
      OSTREAM << s_indent << s_LineTypeNames[ e_NumberIterations] << ' '
             << STAGE.GetMaxNumberIterations() << ' '
             << STAGE.GetMaxNumberUnimprovedIterations() << '\n';

      // write score weightset
      OSTREAM << s_indent << s_LineTypeNames[ e_ScoreWeightSet] << '\n';
      STAGE.GetScoreWeightSet()->CreateTable().WriteFormatted( OSTREAM) << '\n';

      // write mutate weightset
      OSTREAM << s_indent << s_LineTypeNames[ e_MutateWeightSet] << '\n';
      STAGE.GetMutateTree()->CreateTable().WriteFormatted( OSTREAM) << '\n';

      // write end
      OSTREAM << s_LineTypeNames[ e_StageEnd] << '\n';

      // end
      return OSTREAM;
    }

    //! @brief write given protocol list to stream
    //! @param PROTOCOL_LIST Protocol list of interest
    //! @param OSTREAM ostream to be written to
    //! @return ostream which was written to
    std::ostream &StageFactory::WriteProtocolList
    (
      const storage::List< Protocol> &PROTOCOL_LIST,
      std::ostream &OSTREAM
    )
    {
      // iterate over the list
      for
      (
        storage::List< Protocol>::const_iterator itr( PROTOCOL_LIST.Begin()), itr_end( PROTOCOL_LIST.End());
        itr != itr_end; ++itr
      )
      {
        OSTREAM << ' ' << itr->GetName();
      }
      OSTREAM << '\n';

      // end
      return OSTREAM;
    }

    //! @brief removes duplicates if any from the given protocol list
    //! @param PROTOCOL_LIST Protocol list of interest
    //! @return list of unique protocols
    storage::List< Protocol> StageFactory::CreateUniqueProtocolList( const storage::List< Protocol> &PROTOCOL_LIST)
    {
      // initialize list
      storage::List< Protocol> list;

      // iterate over the given list
      for
      (
        storage::List< Protocol>::const_iterator itr( PROTOCOL_LIST.Begin()), itr_end( PROTOCOL_LIST.End());
        itr != itr_end; ++itr
      )
      {
        // insert into list only if not a duplicate
        if( std::find( list.Begin(), list.End(), *itr) == list.End())
        {
          list.PushBack( *itr);
        }
      }

      // end
      return list;
    }

    //! @brief construct a protocol list from the given vector of strings making sure there are no duplicates
    //! @param STRING_VECTOR Vector of strings
    //! @return list of unique protocols
    storage::List< Protocol> StageFactory::ConstructProtocolList( const storage::Vector< std::string> &STRING_VECTOR)
    {
      // construct list
      storage::List< Protocol> list;

      // iterate over string vector
      for
      (
        storage::Vector< std::string>::const_iterator itr( STRING_VECTOR.Begin()), itr_end( STRING_VECTOR.End());
        itr != itr_end; ++itr
      )
      {
        // get the corresponding protocol
        Protocol this_protocol( GetProtocols().GetEnumFromName( *itr));
        BCL_Assert( this_protocol.IsDefined(), "No protocol found with given name " + *itr);

        // insert into list only if not a duplicate
        if( std::find( list.Begin(), list.End(), this_protocol) == list.End())
        {
          list.PushBack( this_protocol);
        }
      }

      // end
      return list;
    }

    //! @brief read table from file
    //! @param FILENAME name for the file that contains table
    //! @return Table read from the file
    storage::Table< double> StageFactory::ReadTableFromFile( const std::string &FILENAME)
    {
      // initialize stream and tie it to filename
      io::IFStream read;
      io::File::MustOpenIFStream( read, FILENAME);

      // construct table and read from stream
      storage::Table< double> table;
      table.ReadFormatted( read, false);
      io::File::CloseClearFStream( read);

      // end
      return table;
    }

    //! @brief write table to file
    //! @param TABLE Table to write
    //! @param FILENAME name fo the file to which the table will be written to
    void StageFactory::WriteTableToFile( const storage::Table< double> &TABLE, const std::string &FILENAME)
    {
      // initialize stream and tie it to filename
      io::OFStream write;
      io::File::MustOpenOFStream( write, FILENAME);

      // write table
      TABLE.WriteFormatted( write);
      io::File::CloseClearFStream( write);
    }

    //! @brief function to set the scoring function for the given single stage
    //! @param SINGLE_STAGE Stage of interest
    void StageFactory::SetSingleStageScoreFunction( mc::Stage &SINGLE_STAGE)
    {
      // if a score file was given using the corresponding flag
      if( DefaultFlags::GetFlagScoreRead()->GetFlag())
      {
        // open the score file
        BCL_MessageStd
        (
          "reading scoring function from " + DefaultFlags::GetFlagScoreRead()->GetFirstParameter()->GetValue()
        );
        io::IFStream read;
        io::File::MustOpenIFStream( read, DefaultFlags::GetFlagScoreRead()->GetFirstParameter()->GetValue());

        // read the scoring function
        util::ShPtr< score::ProteinModelScoreSum> sp_score_function;
        read >> sp_score_function;
        io::File::CloseClearFStream( read);

        // set it
        SINGLE_STAGE.SetScoreFunction( sp_score_function);
      }
      // otherwise use defined scores
      else
      {
        BCL_MessageStd( "initializing scores from protocols chosen");

        // set the score weightset
        SetSingleStageScoreWeightSet( SINGLE_STAGE);

        // construct the score sum
        util::ShPtr< score::ProteinModelScoreSum> sp_score_function
        (
          SINGLE_STAGE.GetScoreWeightSet()->ConstructScoreSum()
        );
        SINGLE_STAGE.SetScoreFunction( sp_score_function);
      }

      // if score write flag was set
      if( DefaultFlags::GetFlagScoreWrite()->GetFlag())
      {
        BCL_MessageStd
        (
          "writing the scoring function to file " + DefaultFlags::GetFlagScoreWrite()->GetFirstParameter()->GetValue()
        );
        // initialize stream
        io::OFStream write;
        io::File::MustOpenOFStream( write, DefaultFlags::GetFlagScoreWrite()->GetFirstParameter()->GetValue());
        // output the stream
        write << SINGLE_STAGE.GetScoreFunction();
        io::File::CloseClearFStream( write);
      }
    }

    //! @brief function to set the scoring weightset for the given single stage
    //! @param SINGLE_STAGE Stage of interest
    void StageFactory::SetSingleStageScoreWeightSet( mc::Stage &SINGLE_STAGE)
    {
      // initialize scoring weight_set
      if( DefaultFlags::GetFlagScoreWeightSetRead()->GetFlag())
      {
        // store filename
        const std::string filename( DefaultFlags::GetFlagScoreWeightSetRead()->GetFirstParameter()->GetValue());
        // initialize read
        BCL_MessageStd( "reading score weight set from file " + filename);

        // read table from given file and construct weightset from it
        SINGLE_STAGE.SetScoreWeightSet
        (
          util::ShPtr< ScoreWeightSet>( new ScoreWeightSet( ReadTableFromFile( filename)))
        );

      }
      // if the flag was not given use the default scoring function
      else
      {
        // initialize a empty ScoreWeightSet
        util::ShPtr< ScoreWeightSet> sp_weightset( new ScoreWeightSet());

        BCL_MessageStd( "initializing score weights");
        // iterate over the score protocols again
        for
        (
          storage::List< Protocol>::const_iterator
            protocol_itr( SINGLE_STAGE.GetScoreProtocols().Begin()),
            protocol_itr_end( SINGLE_STAGE.GetScoreProtocols().End());
          protocol_itr != protocol_itr_end; ++protocol_itr
        )
        {
          BCL_MessageStd( "\t" + protocol_itr->GetName());
          // this time initialize the score weightsets
          ( **protocol_itr)->ModifyScoreWeightSet( *sp_weightset);
        }

        // set the weight set
        SINGLE_STAGE.SetScoreWeightSet( sp_weightset);
      }
    }

    //! @brief function to set the mutate for the given single stage
    //! @param SINGLE_STAGE Stage of interest
    void StageFactory::SetSingleStageMutate( mc::Stage &SINGLE_STAGE)
    {
      // if read mutate flag was set
      if( DefaultFlags::GetFlagMutateRead()->GetFlag())
      {
        // initialize empty mutate
        util::ShPtr< math::MutateInterface< assemble::ProteinModel> > sp_mutate;

        // initialize read
        BCL_MessageStd
        (
          "Reading mutates from " + DefaultFlags::GetFlagMutateRead()->GetFirstParameter()->GetValue()
        );
        io::IFStream read;
        io::File::MustOpenIFStream( read, DefaultFlags::GetFlagMutateRead()->GetFirstParameter()->GetValue()),
        // read the mutate
        read >> sp_mutate;
        io::File::CloseClearFStream( read);

        // set the mutate
        SINGLE_STAGE.SetMutate( sp_mutate);
      }
      // otherwise use the mutates already defined
      else
      {
        BCL_MessageStd( "initializing mutate tree from protocols chosen");

        // set the mutate tree
        SetSingleStageMutateTree( SINGLE_STAGE);

        // now construct the mutate and set it
        SINGLE_STAGE.SetMutate( SINGLE_STAGE.GetMutateTree()->ConstructMutates());
      }
      // if mutate write flag was provided
      if( DefaultFlags::GetFlagMutateWrite()->GetFlag())
      {
        // initialize write
        BCL_MessageStd
        (
          "writing mutates to file" + DefaultFlags::GetFlagMutateWrite()->GetFirstParameter()->GetValue()
        );
        io::OFStream write;
        io::File::MustOpenOFStream( write, DefaultFlags::GetFlagMutateWrite()->GetFirstParameter()->GetValue());

        // write the mutate
        write << SINGLE_STAGE.GetMutate();
        io::File::CloseClearFStream( write);
      }
    }

    //! @brief function to set the mutate tree for the given single stage
    //! @param SINGLE_STAGE Stage of interest
    void StageFactory::SetSingleStageMutateTree( mc::Stage &SINGLE_STAGE)
    {
      // if a weights file is given
      if( DefaultFlags::GetFlagMutateWeightSetRead()->GetFlag())
      {
        // initialize filename
        const std::string filename( DefaultFlags::GetFlagMutateWeightSetRead()->GetFirstParameter()->GetValue());

        // read table and construct mutate tree with it
        BCL_MessageStd( "reading mutate weight set from file " + filename);
        SINGLE_STAGE.SetMutateTree( util::ShPtr< MutateTree>( new MutateTree( ReadTableFromFile( filename))));
      }

      // if no weights file
      else
      {
        // initialize empty mutate weightset
        util::ShPtr< MutateTree> sp_mutate_tree( new MutateTree());

        BCL_MessageStd( "initializing mutate weightset from protocol chosen");
        // iterate over the mutate protocols again
        for
        (
          storage::List< Protocol>::const_iterator
            protocol_itr( SINGLE_STAGE.GetMutateProtocols().Begin()),
            protocol_itr_end( SINGLE_STAGE.GetMutateProtocols().End());
          protocol_itr != protocol_itr_end; ++protocol_itr
        )
        {
          BCL_MessageStd( "\t" + protocol_itr->GetName());
          // this time initialize the mutate tree
          ( **protocol_itr)->MergeAndModifyMutateTree( *sp_mutate_tree);
        }

        // set the tree
        SINGLE_STAGE.SetMutateTree( sp_mutate_tree);
      }
    }

  } // namespace fold
} // namespace bcl
