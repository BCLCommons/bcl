// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_exposure_interface.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_count.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  /////////////////
  // data access //
  /////////////////

    //! @brief gives the flag allowing user to set the sequence exclusion over the command line
    //! @return the flag allowing user to set the sequence exclusion over the command line
    const util::ShPtr< command::FlagInterface> &AAExposureInterface::GetFlagMinimalSequenceSeparation()
    {
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "minimal_sequence_exclusion",
          "The sequence exclusion to use when calculating exposure from a structure.",
          command::Parameter
          (
            "sequence_exclusion",
            "size_t which is the number of residues to be excluded in sequence when calculating exposures",
            util::Format()( AANeighborCount:: GetDefaultMinimalSequenceSeparation())
          )
        )
      );

      return s_flag;
    }

    //! @brief access to the distance cutoff
    //! @return distance cutoff above which the neighbor does not have influence on the score anymore
    double AAExposureInterface::GetDistanceCutoff() const
    {
      return GetThresholdRange().GetMax();
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_exposures.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_count.h"
#include "assemble/bcl_assemble_aa_neighbor_vector.h"
#include "assemble/bcl_assemble_aa_sasa_ols.h"
#include "util/bcl_util_enumerate.hpp"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

    //! @brief default constructor
    AAExposures::AAExposures() :
      e_NeighborCount ( AddEnum( "NeighborVector" , util::ShPtr< AAExposureInterface>( new AANeighborCount()))),
      e_NeighborVector( AddEnum( "NeighborCount"  , util::ShPtr< AAExposureInterface>( new AANeighborVector()))),
      e_AASasaOls     ( AddEnum( "SasaOls"        , util::ShPtr< AAExposureInterface>( new AASasaOLS())))
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AAExposures::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief construct on access function for all AAExposures
    //! @return reference to only instances of AAExposures
    AAExposures &GetAAExposures()
    {
      return AAExposures::GetEnums();
    }

  } // namespace assemble

  namespace util
  {

  /////////////////////////////
  // explicit instantiations //
  /////////////////////////////

    template class BCL_API Enumerate< ShPtr< assemble::AAExposureInterface>, assemble::AAExposures>;

  } // namespace util
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_neighbor_count.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list.h"
#include "biol/bcl_biol_aa_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! @brief returns the default lower and higher thresholds
    //! @return the default lower and higher thresholds
    const math::Range< double> &AANeighborCount::GetDefaultThresholdLowHigh()
    {
      // static range to hold thresholds
      static const math::Range< double> s_default_threshold_low_high( 4.0, 11.4);

      // end
      return s_default_threshold_low_high;
    }

    //! @brief default minimal sequence separation
    const size_t AANeighborCount::GetDefaultMinimalSequenceSeparation()
    {
      // default minimal sequence separation
      static const size_t s_default_minimal_sequence_separation( 2);

      return s_default_minimal_sequence_separation;
    }

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &AANeighborCount::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "neighbor_count_sasa_all_chains_membrane.histograms");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &AANeighborCount::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "aaneigh");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @param SCHEME scheme to be used
    AANeighborCount::AANeighborCount( const std::string &SCHEME) :
      m_Scheme( SCHEME),
      m_ThresholdLowHigh( GetDefaultThresholdLowHigh()),
      m_MininalSequenceSeparation( GetDefaultMinimalSequenceSeparation())
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AANeighborCount object copied from this one
    AANeighborCount *AANeighborCount::Clone() const
    {
      return new AANeighborCount( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AANeighborCount::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AANeighborCount::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief min and max exposure measure
    //! @return range in which exposure can be
    const math::Range< double> &AANeighborCount::GetRange() const
    {
      static const math::Range< double> s_range( 0, 50);
      return s_range;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate neighbor potential for a given amino acid and its AANeighborList
    //! @return neighbor potential for a given amino acid and its AANeighborList
    double AANeighborCount::operator()( const AANeighborList &AA_NEIGHBOR_LIST) const
    {
      // check that the given neighbor list has the proper parameters
      BCL_Assert
      (
        AA_NEIGHBOR_LIST.GetDistanceCutoff() == m_ThresholdLowHigh.GetMax(),
        "given neighbor list does not have the proper distance cutoff or sequence separation: " +
        util::Format()( AA_NEIGHBOR_LIST.GetDistanceCutoff()) + " == " + util::Format()( m_ThresholdLowHigh.GetMax())
      );

      // start with the assumption that the current AA has no neighbors
      double neighbor_count( 0.0);

      //loop over all AAs to calculate env_radius
      for
      (
        AANeighborList::const_iterator
          aa_itr( AA_NEIGHBOR_LIST.Begin()), aa_itr_end( AA_NEIGHBOR_LIST.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        neighbor_count +=
          coord::NeighborWeight( aa_itr->Second(), m_ThresholdLowHigh.GetMin(), m_ThresholdLowHigh.GetMax());
      }

      // return number of neighbors for that AMINO_ACID
      return neighbor_count;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AANeighborCount::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme          , ISTREAM);
      io::Serialize::Read( m_ThresholdLowHigh, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @return returns the output stream
    std::ostream &AANeighborCount::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ThresholdLowHigh, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_voxel_grid_aa.h"
#include "biol/bcl_biol_aa_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AANeighborListContainer::s_Instance
    (
      GetObjectInstances().AddInstance
      (
        new AANeighborListContainer
        (
          util::SiPtrVector< const biol::AABase>(), util::GetUndefined< double>(), util::GetUndefined< size_t>(), false
        )
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from distance cutoff and minimal sequence separation
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborListContainer::AANeighborListContainer
    (
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
    }

    //! @brief construct from a list of amino acids, distance cutoff and minimal sequence separation
    //! @param AMINO_ACIDS the list of amino acids in question
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborListContainer::AANeighborListContainer
    (
      const util::SiPtrVector< const biol::AABase> &AMINO_ACIDS,
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
      iterator itr_guess( m_NeighborLists.Begin());
      // iterate through the residues
      for
      (
        util::SiPtrVector< const biol::AABase>::const_iterator
          aa_itr( AMINO_ACIDS.Begin()), aa_itr_end( AMINO_ACIDS.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // insert AANeighborList into the set
        itr_guess = m_NeighborLists.InsertElement
        (
          itr_guess,
          std::make_pair
          (
            *aa_itr,
            AANeighborList( **aa_itr, util::SiPtrVector< const biol::AABase>(), m_DistanceCutoff, m_MinimalSequenceSeparation, m_ConsiderDifferentChain)
          )
        );
      }
      if( AMINO_ACIDS.GetSize() > size_t( 1))
      {
        VoxelGridAA voxel_grid( m_DistanceCutoff);
        voxel_grid.SetObjects( AMINO_ACIDS);
        auto neighbors( voxel_grid.GetNeighbors( m_DistanceCutoff));
        auto itr_last_found( m_NeighborLists.Begin()), itr_last_found_b( m_NeighborLists.Begin());
        for( auto itr_neigh( neighbors.Begin()), itr_neigh_end( neighbors.End()); itr_neigh != itr_neigh_end; ++itr_neigh)
        {
          if( !m_ConsiderDifferentChain && itr_neigh->First()->GetChainID() != itr_neigh->Second()->GetChainID())
          {
            continue;
          }
          if( biol::SequenceSeparation( *itr_neigh->First(), *itr_neigh->Second()) < m_MinimalSequenceSeparation)
          {
            continue;
          }
          if( itr_neigh->First() != itr_last_found->first)
          {
            itr_last_found = m_NeighborLists.InternalData().find( *itr_neigh->First());
          }
          itr_last_found->second.m_Neighbors.PushBack( storage::Pair< util::SiPtr< const biol::AABase>, double>( itr_neigh->Second(), itr_neigh->Third()));
          m_NeighborLists[ *itr_neigh->Second()].m_Neighbors.PushBack( storage::Pair< util::SiPtr< const biol::AABase>, double>( itr_neigh->First(), itr_neigh->Third()));
        }
      }
    }

    //! @brief construct from two lists of amino acids, distance cutoff and minimal sequence separation
    //! @details only inter pairwise distances and neighbors are calculated
    //! @param AMINO_ACIDS_A, AMINO_ACIDS_B the list of amino acids in question
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborListContainer::AANeighborListContainer
    (
      const util::SiPtrVector< const biol::AABase> &AMINO_ACIDS_A,
      const util::SiPtrVector< const biol::AABase> &AMINO_ACIDS_B,
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
      iterator itr_guess( m_NeighborLists.Begin());
      // iterate through the residues a
      for
      (
        util::SiPtrVector< const biol::AABase>::const_iterator
          aa_itr( AMINO_ACIDS_A.Begin()), aa_itr_end( AMINO_ACIDS_A.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // insert AANeighborList into the set
        itr_guess = m_NeighborLists.InsertElement
        (
          itr_guess,
          std::make_pair
          (
            *aa_itr,
            AANeighborList
            (
              **aa_itr,
              util::SiPtrVector< const biol::AABase>(),
              m_DistanceCutoff,
              m_MinimalSequenceSeparation,
              m_ConsiderDifferentChain
            )
          )
        );
      }

      // iterate through the residues b
      for
      (
        util::SiPtrVector< const biol::AABase>::const_iterator
          aa_itr( AMINO_ACIDS_B.Begin()), aa_itr_end( AMINO_ACIDS_B.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // insert AANeighborList into the set
        itr_guess = m_NeighborLists.InsertElement
        (
          itr_guess,
          std::make_pair
          (
            *aa_itr,
            AANeighborList
            (
              **aa_itr,
              util::SiPtrVector< const biol::AABase>(),
              m_DistanceCutoff,
              m_MinimalSequenceSeparation,
              m_ConsiderDifferentChain
            )
          )
        );
      }

      VoxelGridAA voxel_grid( m_DistanceCutoff);
      voxel_grid.SetObjects( AMINO_ACIDS_B);
      for( auto itr_a( AMINO_ACIDS_A.Begin()), itr_a_end( AMINO_ACIDS_A.End()); itr_a != itr_a_end; ++itr_a)
      {
        auto neighbors( voxel_grid.GetNeighbors( **itr_a, m_DistanceCutoff));
        AANeighborList &neigh_a( m_NeighborLists[ **itr_a]);
        const char chain_id( ( *itr_a)->GetChainID());
        for( auto itr_neigh( neighbors.Begin()), itr_neigh_end( neighbors.End()); itr_neigh != itr_neigh_end; ++itr_neigh)
        {
          if( !m_ConsiderDifferentChain && chain_id != itr_neigh->First()->GetChainID())
          {
            continue;
          }
          if( biol::SequenceSeparation( **itr_a, *itr_neigh->First()) < m_MinimalSequenceSeparation)
          {
            continue;
          }
          neigh_a.m_Neighbors.PushBack( storage::Pair< util::SiPtr< const biol::AABase>, double>( itr_neigh->First(), itr_neigh->Second()));
          m_NeighborLists[ *itr_neigh->First()].m_Neighbors.PushBack( storage::Pair< util::SiPtr< const biol::AABase>, double>( *itr_a, itr_neigh->Second()));
        }
      }
    }

    //! @brief Copy constructor
    //! @param AMINO_ACIDS the list of amino acids in question
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborListContainer::AANeighborListContainer
    (
      const AANeighborListContainer &AMINO_ACIDS,
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
      for( auto itr( AMINO_ACIDS.Begin()), itr_end( AMINO_ACIDS.End()); itr != itr_end; ++itr)
      {
        m_NeighborLists.InternalData().insert
        (
          m_NeighborLists.End(),
          std::pair< util::SiPtr< const biol::AABase>, AANeighborList>
          (
            itr->first,
            AANeighborList( itr->second, m_DistanceCutoff, m_MinimalSequenceSeparation, m_ConsiderDifferentChain)
          )
        );
      }
    }

    //! @brief construct from already-found amino acids (e.g. using assemble::VoxelGridAA.GetSSEConnections())
    //! @param NEIGHBORS List of neighbors
    AANeighborListContainer::AANeighborListContainer
    (
      const storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> > &NEIGHBORS,
      const util::SiPtrVector< const biol::AABase> &AAS,
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
      for( auto itr( AAS.Begin()), itr_end( AAS.End()); itr != itr_end; ++itr)
      {
        m_NeighborLists.InternalData().insert
        (
          m_NeighborLists.End(),
          std::pair< util::SiPtr< const biol::AABase>, AANeighborList>
          (
            *itr,
            AANeighborList( **itr, AANeighborList::NeighborContainerType(), m_DistanceCutoff, m_MinimalSequenceSeparation, m_ConsiderDifferentChain)
          )
        );
      }
      for( auto itr( NEIGHBORS.Begin()), itr_end( NEIGHBORS.End()); itr != itr_end; ++itr)
      {
        m_NeighborLists[ itr->First()].PushBack( itr->Second(), itr->Third());
        m_NeighborLists[ itr->Second()].PushBack( itr->First(), itr->Third());
      }
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief get the total number of neighbors
    //! @return total number of neighbors
    size_t AANeighborListContainer::GetNumberNeighbors() const
    {
      // initialize count
      size_t count( 0);

      // iterate over all the lists
      for( const_iterator itr( m_NeighborLists.Begin()), itr_end( m_NeighborLists.End()); itr != itr_end; ++itr)
      {
        // sum up the number of members in each list
        count += itr->second.GetSize();
      }

      // end
      return count;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief prune the AANeighborListContainer
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    void AANeighborListContainer::Prune
    (
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    )
    {
      if
      (
        DISTANCE_CUTOFF == m_DistanceCutoff
        && MIN_SEQ_SEPARATION == m_MinimalSequenceSeparation
        && ( CONSIDER_DIFFERENT_CHAIN || !m_ConsiderDifferentChain)
      )
      {
        return;
      }
      BCL_Assert
      (
        m_ConsiderDifferentChain >= CONSIDER_DIFFERENT_CHAIN,
        "cannot consider different chain id, since this list, does not contain this information"
      );
      // optimization : if there is only one chain in the neighborlist, there will be no need for removal
      // of other chains
      if( !CONSIDER_DIFFERENT_CHAIN && m_ConsiderDifferentChain && !m_NeighborLists.IsEmpty())
      {
        const char chain_id_first( m_NeighborLists.Begin()->first->GetChainID());
        bool all_same_chain_id( true);
        for( const_iterator itr( m_NeighborLists.Begin()), itr_end( m_NeighborLists.End()); itr != itr_end; ++itr)
        {
          if( itr->first->GetChainID() != chain_id_first)
          {
            all_same_chain_id = false;
            break;
          }
        }
        if( all_same_chain_id)
        {
          m_ConsiderDifferentChain = CONSIDER_DIFFERENT_CHAIN;
          for( iterator itr( m_NeighborLists.Begin()), itr_end( m_NeighborLists.End()); itr != itr_end; ++itr)
          {
            itr->second.m_ConsiderDifferentChain = false;
          }
        }
      }
      size_t old_size( 0), new_size( 0);
      // iterate over all this neighbor list
      for( iterator itr( m_NeighborLists.Begin()), itr_end( m_NeighborLists.End()); itr != itr_end; ++itr)
      {
        AANeighborList &this_list( itr->second);
        old_size += this_list.GetSize();
        BCL_Assert
        (
          this_list.DecreaseDistanceCutoff( DISTANCE_CUTOFF), "could not reduce distance cutoff"
        );
        BCL_Assert
        (
          this_list.IncreaseMinimalSequenceSeparation( MIN_SEQ_SEPARATION),
          "could not increase minimal sequence separation"
        );
        if( !CONSIDER_DIFFERENT_CHAIN)
        {
          this_list.RemoveNeighborsWithDifferentChainID();
        }
        new_size += this_list.GetSize();
      }
      BCL_MessageDbg
      (
        "$$$: Pruning neighbor list container from " + util::Format()( m_DistanceCutoff)
        + " to " + util::Format()( DISTANCE_CUTOFF) + " A. min seq sep "
        + util::Format()( m_MinimalSequenceSeparation) + " -> " + util::Format()( MIN_SEQ_SEPARATION)
        + " diff chain: " + util::Format()( m_ConsiderDifferentChain) + " -> " + util::Format()( CONSIDER_DIFFERENT_CHAIN)
        + " neighbors decrease: " + util::Format()( old_size) + " -> " + util::Format()( new_size)
      );
      // update parameters
      m_DistanceCutoff = DISTANCE_CUTOFF;
      m_MinimalSequenceSeparation = MIN_SEQ_SEPARATION;
      m_ConsiderDifferentChain = CONSIDER_DIFFERENT_CHAIN;
    }

    //! @brief Remove residues located on the same SSE
    //! @param MODEL the protein model containing the SSEs
    void AANeighborListContainer::PruneResiduesSameSSE( const ProteinModel &MODEL)
    {
      for( iterator itr( m_NeighborLists.Begin()), itr_end( m_NeighborLists.End()); itr != itr_end; ++itr)
      {
        AANeighborList &this_list( itr->second);
        this_list.PruneResiduesSameSSE( MODEL);
      }
    }

    //! @brief return the intersect size with the given AANeighborListContainer
    //! @param CONTAINER The container with which the intersect is going to be calculated
    //! @return number of overlapping edges
    size_t AANeighborListContainer::IntersectionSize( const AANeighborListContainer &CONTAINER) const
    {
      size_t n_overlap( 0);

      // if the parameters are different
      if
      (
        m_DistanceCutoff != CONTAINER.m_DistanceCutoff ||
        m_MinimalSequenceSeparation != CONTAINER.m_MinimalSequenceSeparation ||
        m_ConsiderDifferentChain != CONTAINER.m_ConsiderDifferentChain
      )
      {
        // return an empty container
        BCL_MessageCrt
        (
          "Can not calculate intersection for given containers because they have different parameters"
        );
        return 0;
      }

      // iterate over the list of members in this container
      for( const_iterator itr( m_NeighborLists.Begin()), itr_end( m_NeighborLists.End()); itr != itr_end; ++itr)
      {
        // search for the list with the same center amino acid in the given container
        const const_iterator itr_other( CONTAINER.m_NeighborLists.Find( itr->first));

        // if not found continue
        if( itr_other != CONTAINER.End())
        {
          // calculate the intersection between two neighbor lists
          n_overlap += itr->second.IntersectionSize( itr_other->second);
        }

      }

      // end
      return n_overlap;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AANeighborListContainer::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_DistanceCutoff           , ISTREAM);
      io::Serialize::Read( m_MinimalSequenceSeparation, ISTREAM);
      io::Serialize::Read( m_ConsiderDifferentChain   , ISTREAM);
      io::Serialize::Read( m_NeighborLists            , ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AANeighborListContainer::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_DistanceCutoff           , OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_MinimalSequenceSeparation, OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_ConsiderDifferentChain   , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_NeighborLists            , OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_protein_model.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_sse.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_sse_pair.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_pruner.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "math/bcl_math_function_adapter.h"
#include "math/bcl_math_function_cached.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AANeighborListContainerGeneratorProteinModel::s_Instance
    (
      GetObjectInstances().AddInstance( new AANeighborListContainerGeneratorProteinModel( 0.0, 0, true, false))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from SSE pair neighbor list container generator
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborListContainerGeneratorProteinModel::AANeighborListContainerGeneratorProteinModel
    (
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN,
      const bool CACHED
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN),
      m_Cached( CACHED)
    {
    }

    //! @brief Clone function
    //! @return pointer to new AANeighborListContainerGeneratorProteinModel
    AANeighborListContainerGeneratorProteinModel *AANeighborListContainerGeneratorProteinModel::Clone() const
    {
      return new AANeighborListContainerGeneratorProteinModel( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AANeighborListContainerGeneratorProteinModel::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief generate AANeighborListContainer for protein model
    //! @param PROTEIN_MODEL the protein model
    //! @return AANeighborListContainer for ProteinModel
    AANeighborListContainer AANeighborListContainerGeneratorProteinModel::operator()( const ProteinModel &PROTEIN_MODEL) const
    {
      return
        AANeighborListContainer
        (
          PROTEIN_MODEL.GetAminoAcids(), m_DistanceCutoff, m_MinimalSequenceSeparation, m_ConsiderDifferentChain
        );
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AANeighborListContainerGeneratorProteinModel::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_DistanceCutoff               , ISTREAM);
      io::Serialize::Read( m_MinimalSequenceSeparation    , ISTREAM);
      io::Serialize::Read( m_ConsiderDifferentChain       , ISTREAM);
      io::Serialize::Read( m_Cached,                        ISTREAM);
      io::Serialize::Read( m_AANeigborListGeneratorSSEPair, ISTREAM);
      io::Serialize::Read( m_AANeigborListGeneratorSSE    , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AANeighborListContainerGeneratorProteinModel::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_DistanceCutoff               , OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_MinimalSequenceSeparation    , OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_ConsiderDifferentChain       , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Cached                       , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AANeigborListGeneratorSSEPair, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AANeigborListGeneratorSSE    , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return a shptr to NeighborListGenerator class
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    //! @param CACHED wrap the generator in a cache object
    //! @return ShPtr to generator
    util::ShPtr< math::FunctionInterfaceSerializable< ProteinModel, AANeighborListContainer> >
    AANeighborListContainerGeneratorProteinModel::AANeighborListGenerator
    (
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN,
      const bool CACHED
    )
    {
      static double s_max_distance_cutoff_for_caching( 8);
      static size_t s_min_seq_separation_for_caching( 0);
      // no caching desired or distance is so large as to make caching futile due to the amount of pruning necessary for
      // common applications
      if
      (
        !CACHED
        || DISTANCE_CUTOFF > s_max_distance_cutoff_for_caching
        || MIN_SEQ_SEPARATION < s_min_seq_separation_for_caching
      )
      {
        // just create the generator
        return util::ShPtr< math::FunctionInterfaceSerializable< ProteinModel, AANeighborListContainer> >
        (
          new AANeighborListContainerGeneratorProteinModel
          (
            DISTANCE_CUTOFF, MIN_SEQ_SEPARATION, CONSIDER_DIFFERENT_CHAIN, CACHED
          )
        );
      }

      // caching desired, create a generator that make the maximal possible neighbor list
      typedef storage::Map< std::string, util::ShPtr< math::FunctionCached< ProteinModel, AANeighborListContainer> > > PrunersMapType;

      // initialize static map to store the pruners
      static PrunersMapType s_pruners;

      // construct the identifier for the requested pruner
      const std::string identifier
      (
        util::Format()( DISTANCE_CUTOFF) + '_' +
        util::Format()( MIN_SEQ_SEPARATION) + '_' +
        util::Format()( CONSIDER_DIFFERENT_CHAIN)
      );

      // search for this identifier in the map to see if such a pruner was previously constructed
      const PrunersMapType::const_iterator pruner_itr( s_pruners.Find( identifier));

      // if found, then return this pruner
      if( pruner_itr != s_pruners.End())
      {
        return pruner_itr->second;
      }

      // caching desired, create a static generator that make the maximal possible neighbor list
      static util::ShPtr< math::FunctionCached< ProteinModel, AANeighborListContainer> >
        s_complete_neighbor_list_cached;
      // if not initialize yet, then initialize it
      if( !s_complete_neighbor_list_cached.IsDefined())
      {
        // construct generator
        const util::ShPtr< math::FunctionInterfaceSerializable< ProteinModel, AANeighborListContainer> >
          complete_neighbor_list
          (
            new AANeighborListContainerGeneratorProteinModel
            (
              s_max_distance_cutoff_for_caching,
              s_min_seq_separation_for_caching,
              true,
              true
            )
          );
        // wrap it in cache
        s_complete_neighbor_list_cached = util::ShPtr< math::FunctionCached< ProteinModel, AANeighborListContainer> >
        (
          new math::FunctionCached< ProteinModel, AANeighborListContainer>
          (
            complete_neighbor_list,
            &ProteinModel::GetDestructorSignal,
            &ProteinModel::GetChangeSignal
          )
        );
      }

      if
      (
        DISTANCE_CUTOFF == s_max_distance_cutoff_for_caching
        && MIN_SEQ_SEPARATION == s_min_seq_separation_for_caching
        && CONSIDER_DIFFERENT_CHAIN
      )
      {
        s_pruners[ identifier] = s_complete_neighbor_list_cached;
        return s_complete_neighbor_list_cached;
      }

      // otherwise construct the pruner
      const util::ShPtr< math::FunctionInterfaceSerializable< AANeighborListContainer, AANeighborListContainer> > neighborlist_pruner
      (
        new AANeighborListContainerPruner
        (
          DISTANCE_CUTOFF, MIN_SEQ_SEPARATION, CONSIDER_DIFFERENT_CHAIN
        )
      );
      // wrap cache around it
      util::ShPtr< math::FunctionCached< ProteinModel, AANeighborListContainer> > neighborlist_pruner_cached
      (
        new math::FunctionCached< ProteinModel, AANeighborListContainer>
        (
          util::ShPtr< math::FunctionInterfaceSerializable< ProteinModel, AANeighborListContainer> >
          (
            new math::FunctionAdapter< ProteinModel, AANeighborListContainer, AANeighborListContainer>
            (
              s_complete_neighbor_list_cached, neighborlist_pruner
            )
          ),
          &ProteinModel::GetDestructorSignal,
          &ProteinModel::GetChangeSignal
        )
      );
      // insert it into the map and return it
      s_pruners[ identifier] = neighborlist_pruner_cached;
      return neighborlist_pruner_cached;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_pruner.h"
#include "assemble/bcl_assemble_sse.h"
#include "math/bcl_math_function_adapter.h"
#include "math/bcl_math_function_cached.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AANeighborListContainerGeneratorSSE::s_Instance
    (
      GetObjectInstances().AddInstance( new AANeighborListContainerGeneratorSSE( 0.0, 0, true))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from distance cutoff and minimal sequence separation
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborListContainerGeneratorSSE::AANeighborListContainerGeneratorSSE
    (
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
    }

    //! @brief Clone function
    //! @return pointer to new AANeighborListContainerGeneratorSSE
    AANeighborListContainerGeneratorSSE *AANeighborListContainerGeneratorSSE::Clone() const
    {
      return new AANeighborListContainerGeneratorSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AANeighborListContainerGeneratorSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief AANeighborlist from two secondary structure elements
    //! @param ELEMENT secondary structure element
    //! @return the AANeighborlistContainer constructed from all amino in the SSE
    AANeighborListContainer AANeighborListContainerGeneratorSSE::operator()( const SSE &ELEMENT) const
    {
      // calculate neighbor list container and return
      return
        AANeighborListContainer
        (
          ELEMENT.GetMembers(), m_DistanceCutoff, m_MinimalSequenceSeparation, m_ConsiderDifferentChain
        );
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AANeighborListContainerGeneratorSSE::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_DistanceCutoff           , ISTREAM);
      io::Serialize::Read( m_MinimalSequenceSeparation, ISTREAM);
      io::Serialize::Read( m_ConsiderDifferentChain   , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AANeighborListContainerGeneratorSSE::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_DistanceCutoff           , OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_MinimalSequenceSeparation, OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_ConsiderDifferentChain   , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return a shptr to NeighborListGenerator class
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    //! @param CACHED wrap the generator in a cache object
    //! @return ShPtr to generator
    util::ShPtr< math::FunctionInterfaceSerializable< SSE, AANeighborListContainer> > AANeighborListContainerGeneratorSSE::AANeighborListGenerator
    (
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN,
      const bool CACHED
    )
    {
      static size_t s_max_distance_cutoff_for_caching( 12.0);
      // no caching desired or distance is so large as to make caching futile due to the amount of pruning necessary for
      // common applications
      if( !CACHED || DISTANCE_CUTOFF > s_max_distance_cutoff_for_caching)
      {
        // just create the generator
        return util::ShPtr< math::FunctionInterfaceSerializable< SSE, AANeighborListContainer> >
        (
          new AANeighborListContainerGeneratorSSE( DISTANCE_CUTOFF, MIN_SEQ_SEPARATION, CONSIDER_DIFFERENT_CHAIN)
        );
      }

      // caching desired, create a generator that make the maximal possible neighbor list
      static util::ShPtr< math::FunctionCached< SSE, AANeighborListContainer> > s_complete_neighbor_list_cached;
      if( !s_complete_neighbor_list_cached.IsDefined())
      {
        const util::ShPtr< math::FunctionInterfaceSerializable< SSE, AANeighborListContainer> > complete_neighbor_list
        (
          new AANeighborListContainerGeneratorSSE( s_max_distance_cutoff_for_caching, 0, true)
        );
        s_complete_neighbor_list_cached = util::ShPtr< math::FunctionCached< SSE, AANeighborListContainer> >
        (
          new math::FunctionCached< SSE, AANeighborListContainer>( complete_neighbor_list, &SSE::GetDestructorSignal)
        );
        s_complete_neighbor_list_cached->AddSignalHandlerForArgument( &SSE::GetCoordinateChangeSignal);
      }

      // use a pruner, to narrow the neighbor list
      typedef storage::Map< std::string, util::ShPtr< math::FunctionCached< SSE, AANeighborListContainer> > > PrunersMapType;
      static PrunersMapType s_pruners;
      const std::string identifier
      (
        util::Format()( DISTANCE_CUTOFF) + '_' +
        util::Format()( MIN_SEQ_SEPARATION) + '_' +
        util::Format()( CONSIDER_DIFFERENT_CHAIN)
      );
      const PrunersMapType::const_iterator pruner_itr( s_pruners.Find( identifier));
      if( pruner_itr != s_pruners.End())
      {
        return pruner_itr->second;
      }

      const util::ShPtr< math::FunctionInterfaceSerializable< SSE, AANeighborListContainer> > neighborlist_pruner
      (
        new math::FunctionAdapter< SSE, AANeighborListContainer, AANeighborListContainer>
        (
          s_complete_neighbor_list_cached,
          util::ShPtr< math::FunctionInterfaceSerializable< AANeighborListContainer, AANeighborListContainer> >
          (
            new AANeighborListContainerPruner( DISTANCE_CUTOFF, MIN_SEQ_SEPARATION, CONSIDER_DIFFERENT_CHAIN)
          )
        )
      );

      util::ShPtr< math::FunctionCached< SSE, AANeighborListContainer> > neighborlist_pruner_cached
      (
        new math::FunctionCached< SSE, AANeighborListContainer>( neighborlist_pruner, &SSE::GetDestructorSignal)
      );
      neighborlist_pruner_cached->AddSignalHandlerForArgument( &SSE::GetCoordinateChangeSignal);
      s_pruners[ identifier] = neighborlist_pruner_cached;

      return neighborlist_pruner_cached;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_neighbor_list_container_generator_sse_pair.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container_pruner.h"
#include "assemble/bcl_assemble_sse.h"
#include "math/bcl_math_binary_function_cached.h"
#include "math/bcl_math_binary_unary_function_adapter.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AANeighborListContainerGeneratorSSEPair::s_Instance
    (
      GetObjectInstances().AddInstance( new AANeighborListContainerGeneratorSSEPair( 0.0, 0, true))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from distance cutoff and minimal sequence separation
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborListContainerGeneratorSSEPair::AANeighborListContainerGeneratorSSEPair
    (
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
    }

    //! @brief Clone function
    //! @return pointer to new AANeighborListContainerGeneratorSSEPair
    AANeighborListContainerGeneratorSSEPair *AANeighborListContainerGeneratorSSEPair::Clone() const
    {
      return new AANeighborListContainerGeneratorSSEPair( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AANeighborListContainerGeneratorSSEPair::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief AANeighborlist from two secondary structure elements
    //! @param ELEMENT_A first secondary structure element
    //! @param ELEMENT_B second secondary structure element
    //! @return the AANeighborlistContainer constructed from all amino acids in both SSEs
    AANeighborListContainer AANeighborListContainerGeneratorSSEPair::operator()( const SSE &ELEMENT_A, const SSE &ELEMENT_B) const
    {
      // if different chains won't be considered and SSEs have different chain ids
      if( !m_ConsiderDifferentChain && ELEMENT_A.GetChainID() != ELEMENT_B.GetChainID())
      {
        return AANeighborListContainer( m_DistanceCutoff, m_MinimalSequenceSeparation, m_ConsiderDifferentChain);
      }

      // calculate neighbor list container and return
      return
        AANeighborListContainer
        (
          ELEMENT_A.GetMembers(),
          ELEMENT_B.GetMembers(),
          m_DistanceCutoff,
          m_MinimalSequenceSeparation,
          m_ConsiderDifferentChain
        );
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AANeighborListContainerGeneratorSSEPair::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_DistanceCutoff           , ISTREAM);
      io::Serialize::Read( m_MinimalSequenceSeparation, ISTREAM);
      io::Serialize::Read( m_ConsiderDifferentChain   , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AANeighborListContainerGeneratorSSEPair::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_DistanceCutoff           , OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_MinimalSequenceSeparation, OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_ConsiderDifferentChain   , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return a shptr to NeighborListGenerator class
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    //! @param CACHED wrap the generator in a cache object
    //! @return ShPtr to generator
    util::ShPtr< math::BinaryFunctionInterface< SSE, SSE, AANeighborListContainer> >
    AANeighborListContainerGeneratorSSEPair::AANeighborListGenerator
    (
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN,
      const bool CACHED
    )
    {
      static double s_max_distance_cutoff_for_caching( 11.4);
      static size_t s_min_seq_separation_for_caching( 2);
      // no caching desired or distance is so large as to make caching futile due to the amount of pruning necessary for
      // common applications
      if
      (
        !CACHED
        || DISTANCE_CUTOFF > s_max_distance_cutoff_for_caching
        || MIN_SEQ_SEPARATION < s_min_seq_separation_for_caching
      )
      {
        // just create the generator
        return util::ShPtr< math::BinaryFunctionInterface< SSE, SSE, AANeighborListContainer> >
        (
          new AANeighborListContainerGeneratorSSEPair( DISTANCE_CUTOFF, MIN_SEQ_SEPARATION, CONSIDER_DIFFERENT_CHAIN)
        );
      }

      // caching desired, create a static generator that make the maximal possible neighbor list
      static util::ShPtr< math::BinaryFunctionCached< SSE, SSE, AANeighborListContainer> > s_complete_neighbor_list_cached;
      // if not initialize yet, then initialize it
      if( !s_complete_neighbor_list_cached.IsDefined())
      {
        // construct generator
        const util::ShPtr< math::BinaryFunctionInterface< SSE, SSE, AANeighborListContainer> > complete_neighbor_list
        (
          new AANeighborListContainerGeneratorSSEPair( s_max_distance_cutoff_for_caching, 0, true)
        );
        // wrap it in cache
        s_complete_neighbor_list_cached = util::ShPtr< math::BinaryFunctionCached< SSE, SSE, AANeighborListContainer> >
        (
          new math::BinaryFunctionCached< SSE, SSE, AANeighborListContainer>( complete_neighbor_list, &SSE::GetDestructorSignal, true)
        );
        // add signaling
        s_complete_neighbor_list_cached->AddSignalHandlerForArgument( &SSE::GetCoordinateChangeSignal);
      }

      // use a pruner, to narrow the neighbor list
      typedef storage::Map< std::string, util::ShPtr< math::BinaryFunctionCached< SSE, SSE, AANeighborListContainer> > > PrunersMapType;
      // initialize a map to store the pruners constructed
      static PrunersMapType s_pruners;
      // create identifier with requested parameters
      const std::string identifier
      (
        util::Format()( DISTANCE_CUTOFF) + '_' +
        util::Format()( MIN_SEQ_SEPARATION) + '_' +
        util::Format()( CONSIDER_DIFFERENT_CHAIN)
      );
      // check to see if such a pruner was already constructed
      const PrunersMapType::const_iterator pruner_itr( s_pruners.Find( identifier));
      // if found in the map, then return it
      if( pruner_itr != s_pruners.End())
      {
        return pruner_itr->second;
      }
      // otherwise construct the pruner
      const util::ShPtr< math::BinaryFunctionInterface< SSE, SSE, AANeighborListContainer> > neighborlist_pruner
      (
        new math::BinaryUnaryFunctionAdapter< SSE, SSE, AANeighborListContainer, AANeighborListContainer>
        (
          s_complete_neighbor_list_cached,
          util::ShPtr< math::FunctionInterfaceSerializable< AANeighborListContainer, AANeighborListContainer> >
          (
            new AANeighborListContainerPruner( DISTANCE_CUTOFF, MIN_SEQ_SEPARATION, CONSIDER_DIFFERENT_CHAIN)
          )
        )
      );
      // wrap it in cache
      util::ShPtr< math::BinaryFunctionCached< SSE, SSE, AANeighborListContainer> > neighborlist_pruner_cached
      (
        new math::BinaryFunctionCached< SSE, SSE, AANeighborListContainer>( neighborlist_pruner, &SSE::GetDestructorSignal, true)
      );
      // update signaling
      neighborlist_pruner_cached->AddSignalHandlerForArgument( &SSE::GetCoordinateChangeSignal);
      // add to the map and return it
      s_pruners[ identifier] = neighborlist_pruner_cached;
      return neighborlist_pruner_cached;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_neighbor_list_container_pruner.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "biol/bcl_biol_aa_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AANeighborListContainerPruner::s_Instance
    (
      GetObjectInstances().AddInstance( new AANeighborListContainerPruner( 0.0, 0, true))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from distance cutoff and minimal sequence separation
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborListContainerPruner::AANeighborListContainerPruner
    (
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
    }

    //! @brief Clone function
    //! @return pointer to new AANeighborListContainerPruner
    AANeighborListContainerPruner *AANeighborListContainerPruner::Clone() const
    {
      return new AANeighborListContainerPruner( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AANeighborListContainerPruner::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that prunes a given neighbor list container to a reduced one
    //! @param CONTAINER the container to be pruned
    //! @return pruned AANeighborListContainer
    AANeighborListContainer AANeighborListContainerPruner::operator()( const AANeighborListContainer &CONTAINER) const
    {
      return AANeighborListContainer( CONTAINER, m_DistanceCutoff, m_MinimalSequenceSeparation, m_ConsiderDifferentChain);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AANeighborListContainerPruner::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AANeighborListContainerPruner::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_neighbor_list.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_aa.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AANeighborList::s_Instance
    (
      GetObjectInstances().AddInstance( new AANeighborList())
    );

    //! @brief access to default center aa for undefined list
    const biol::AABase &AANeighborList::GetDefaultCenterAA()
    {
      static const biol::AABase *s_default( new biol::AA());
      return *s_default;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief helper constructor to find a neighbor list in a AANeihborListCotainer from given amino acid
    //! @brief CENTER_AMINO_ACID amino acid for which the neighbor list is generated
    AANeighborList::AANeighborList( const biol::AABase &CENTER_AMINO_ACID) :
      m_CenterAminoAcid( &CENTER_AMINO_ACID),
      m_Neighbors(),
      m_DistanceCutoff( util::GetUndefined< double>()),
      m_MinimalSequenceSeparation( util::GetUndefined< size_t>()),
      m_ConsiderDifferentChain( true)
    {
    }

    //! @brief constructor from central AA, neighboring AAs and their distances
    //! @param CENTER_AMINO_ACID amino acid for which the neighbor list is generated
    //! @param AMINO_ACIDS_DISTANCES the list of amino acids in question along w/ their distances
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborList::AANeighborList
    (
      const biol::AABase &CENTER_AMINO_ACID,
      const NeighborContainerType &AMINO_ACIDS_DISTANCES,
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_CenterAminoAcid( &CENTER_AMINO_ACID),
      m_Neighbors( AMINO_ACIDS_DISTANCES),
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
    }

    //! @brief construct from center amino acids, a list of amino acids, distance cutoff and minimal sequence separation
    //! @param CENTER_AMINO_ACID amino acid for which the neighbor list is generated
    //! @param AMINO_ACIDS the list of amino acids in question
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborList::AANeighborList
    (
      const biol::AABase &CENTER_AMINO_ACID,
      const util::SiPtrVector< const biol::AABase> &AMINO_ACIDS,
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_CenterAminoAcid( &CENTER_AMINO_ACID),
      m_Neighbors(),
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
      // create reference to biol::Atom "atom_a" and initialize with the "ATOM_TYPE" atom of "AMINO_ACID"
      const biol::Atom &atom_a( CENTER_AMINO_ACID.GetFirstSidechainAtom());
      const char center_aa_chain_id( CENTER_AMINO_ACID.GetChainID());

      double square_distance_cutoff( math::Sqr( m_DistanceCutoff));
      // iterate through the residues
      for
      (
        util::SiPtrVector< const biol::AABase>::const_iterator
          aa_itr( AMINO_ACIDS.Begin()), aa_itr_end( AMINO_ACIDS.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        if( !m_ConsiderDifferentChain && ( center_aa_chain_id != ( *aa_itr)->GetChainID()))
        {
          continue;
        }

        // skip identical amino acids
        if( m_CenterAminoAcid == *aa_itr)
        {
          continue;
        }

        // check that amino acids are from the same chain and have a sufficient sequence distance
        const size_t seq_separation( biol::SequenceSeparation( CENTER_AMINO_ACID, **aa_itr));

        // seq separation can only be undefined if aa are from different chain or have the same seqid - which was checked
        if( util::IsDefined( seq_separation) && seq_separation < m_MinimalSequenceSeparation)
        {
          continue;
        }

        // create reference to biol::Atom "atom_b" and initialize with the "ATOM_TYPE" atom of "AA_ITR"
        const biol::Atom &atom_b( ( *aa_itr)->GetFirstSidechainAtom());

        // create double "distance" and initialize with the distance between "atom_a" and "atom_b"
        double sq_distance( biol::SquareDistance( atom_a, atom_b));

        // check that distance is defined and under cutoff
        if( sq_distance > square_distance_cutoff)
        {
          continue;
        }
        else if( sq_distance <= 0.0)
        {
          sq_distance = 0.0;
        }
        else if( !util::IsDefined( sq_distance))
        {
          continue;
        }

        // add the residue behind "AA_ITR" and "distance" to "current_neighbors"
        m_Neighbors.PushBack( storage::Pair< util::SiPtr< const biol::AABase>, double>( *aa_itr, math::Sqrt( sq_distance)));
      }
    }

    //! @brief construct from a neighbor list setup with parameters that'd make it a superset of the desired list
    //! @param PARENT the original neighborlist
    //! @param DISTANCE_CUTOFF above which neighbors are not stored
    //! @param MIN_SEQ_SEPARATION minimal sequence distance (if within same chain) under which neighbors are not stored
    //! @param CONSIDER_DIFFERENT_CHAIN bool indicating whether or not amino acids of different chains are considered neighbors
    AANeighborList::AANeighborList
    (
      const AANeighborList &PARENT,
      const double DISTANCE_CUTOFF,
      const size_t MIN_SEQ_SEPARATION,
      const bool CONSIDER_DIFFERENT_CHAIN
    ) :
      m_CenterAminoAcid( PARENT.m_CenterAminoAcid),
      m_Neighbors(),
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_MinimalSequenceSeparation( MIN_SEQ_SEPARATION),
      m_ConsiderDifferentChain( CONSIDER_DIFFERENT_CHAIN)
    {
      if
      (
        m_DistanceCutoff == PARENT.m_DistanceCutoff
        && m_MinimalSequenceSeparation == PARENT.m_MinimalSequenceSeparation
        && ( m_ConsiderDifferentChain == PARENT.m_ConsiderDifferentChain)
      )
      {
        m_Neighbors = PARENT.m_Neighbors;
        return;
      }

      m_Neighbors.AllocateMemory( size_t( PARENT.m_Neighbors.GetSize() * m_DistanceCutoff / PARENT.m_DistanceCutoff));

      BCL_Assert
      (
        m_MinimalSequenceSeparation >= PARENT.m_MinimalSequenceSeparation
        && ( PARENT.m_ConsiderDifferentChain || !m_ConsiderDifferentChain)
        && m_DistanceCutoff <= PARENT.m_DistanceCutoff,
        "Cannot expand a neighborlist with more broad parameters: " +
        util::Format()( m_MinimalSequenceSeparation) + " min sep from "
        + util::Format()( PARENT.m_MinimalSequenceSeparation)
        + ( m_ConsiderDifferentChain && !PARENT.m_ConsiderDifferentChain
            ? ". Cannot get neighbors from other chain from neighborlist containing only same chain. " : " ")
        + ( m_DistanceCutoff >= PARENT.m_DistanceCutoff ? "Distance cutoff violation: from "
            + util::Format()( PARENT.m_DistanceCutoff) + " to " + util::Format()( m_DistanceCutoff) : ""
          )
      );
      const bool same_seq_sep( m_MinimalSequenceSeparation == PARENT.m_MinimalSequenceSeparation);
      const bool same_alt_chain( m_ConsiderDifferentChain == PARENT.m_ConsiderDifferentChain);
      const char chain_id( m_CenterAminoAcid->GetChainID());
      // iterate over all this neighbor list
      for( const_iterator itr( PARENT.m_Neighbors.Begin()), itr_end( PARENT.m_Neighbors.End()); itr != itr_end; ++itr)
      {
        if
        (
          itr->Second() <= m_DistanceCutoff
          && (
               same_seq_sep
               || biol::SequenceSeparation( *m_CenterAminoAcid, *itr->First()) >= m_MinimalSequenceSeparation
             )
          && ( same_alt_chain || itr->First()->GetChainID() == chain_id)
        )
        {
          m_Neighbors.PushBack( *itr);
        }
      }
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief push back another amino acid into the neighbor. Checks that the added AA/dist are appropriate for this list
    //!        should be done prior to this
    void AANeighborList::PushBack( const util::SiPtr< const biol::AABase> &AA, const double &DIST)
    {
      m_Neighbors.PushBack( storage::Pair< util::SiPtr< const biol::AABase>, double>( AA, DIST));
    }

    //! @brief return the intersect with the given neighbor list, the distances will indicate the differences from
    //! this list to the given list for the common residues
    //! @param AA_NEIGHBOR_LIST the neighbor list to calculate the intersection with
    //! @return Number of elements in the intersection of the lists
    size_t AANeighborList::IntersectionSize( const AANeighborList &AA_NEIGHBOR_LIST) const
    {
      size_t intersection_sz( 0);
      std::set< std::pair< char, int> > aa_pdb_id_set_a;
      // iterate over neighbors in this list
      for( const_iterator itr( m_Neighbors.Begin()), itr_end( m_Neighbors.End()); itr != itr_end; ++itr)
      {
        aa_pdb_id_set_a.insert( aa_pdb_id_set_a.end(), std::make_pair( itr->First()->GetChainID(), itr->First()->GetSeqID()));
      }
      for( const_iterator itr( AA_NEIGHBOR_LIST.m_Neighbors.Begin()), itr_end( AA_NEIGHBOR_LIST.m_Neighbors.End()); itr != itr_end; ++itr)
      {
        if
        (
          aa_pdb_id_set_a.find( std::make_pair( itr->First()->GetChainID(), itr->First()->GetSeqID()))
          != aa_pdb_id_set_a.end()
        )
        {
          ++intersection_sz;
        }
      }

      // end
      return intersection_sz;
    }

    //! @brief Remove neighbors with different chain id
    void AANeighborList::RemoveNeighborsWithDifferentChainID()
    {
      // nothing to do
      if( !m_ConsiderDifferentChain)
      {
        return;
      }

      const char chain_id( m_CenterAminoAcid->GetChainID());

      // iterate over all neighbors
      storage::Vector< storage::Pair< util::SiPtr< const biol::AABase>, double> > new_neigh;
      new_neigh.AllocateMemory( m_Neighbors.GetSize());

      // iterate over all neighbors
      for( auto itr( m_Neighbors.Begin()), itr_end( m_Neighbors.End()); itr != itr_end; ++itr)
      {
        if( itr->First()->GetChainID() == chain_id)
        {
          new_neigh.PushBack( *itr);
        }
      }
      m_Neighbors.InternalData().swap( new_neigh.InternalData());

      // update
      m_ConsiderDifferentChain = false;
    }

    //! @brief decrease the distance cutoff
    //! @param DISTANCE_CUTOFF
    //! @return true, on success, false if DISTANCE_CUTOFF is larger than current distance cutoff
    bool AANeighborList::DecreaseDistanceCutoff( const double DISTANCE_CUTOFF)
    {
      // distance cutoff can only be reduced, if the current one is larger
      if( m_DistanceCutoff < DISTANCE_CUTOFF)
      {
        return false;
      }

      // nothing to do
      if( m_DistanceCutoff == DISTANCE_CUTOFF)
      {
        return true;
      }

      // iterate over all neighbors
      storage::Vector< storage::Pair< util::SiPtr< const biol::AABase>, double> > new_neigh;
      new_neigh.AllocateMemory( m_Neighbors.GetSize());

      // iterate over all neighbors
      for( auto itr( m_Neighbors.Begin()), itr_end( m_Neighbors.End()); itr != itr_end; ++itr)
      {
        if( itr->Second() <= DISTANCE_CUTOFF)
        {
          new_neigh.PushBack( *itr);
        }
      }

      // update
      m_DistanceCutoff = DISTANCE_CUTOFF;
      new_neigh.InternalData().swap( m_Neighbors.InternalData());

      // return success
      return true;
    }

    //! @brief increase minimal sequence separation
    //! @param MIN_SEQ_SEPARATION
    //! @return true, if increment was successful, flase if the new seq separtion is smaller than the current
    bool AANeighborList::IncreaseMinimalSequenceSeparation( const size_t MIN_SEQ_SEPARATION)
    {
      // sequence separation can only be increased, if the current one is smaller
      if( m_MinimalSequenceSeparation > MIN_SEQ_SEPARATION)
      {
        return false;
      }

      // nothing to do
      if( m_MinimalSequenceSeparation == MIN_SEQ_SEPARATION)
      {
        return true;
      }

      storage::Vector< storage::Pair< util::SiPtr< const biol::AABase>, double> > new_neigh;
      new_neigh.AllocateMemory( m_Neighbors.GetSize());

      // iterate over all neighbors
      for( auto itr( m_Neighbors.Begin()), itr_end( m_Neighbors.End()); itr != itr_end; ++itr)
      {
        const size_t seq_separation( biol::SequenceSeparation( *m_CenterAminoAcid, *itr->First()));

        // if chain id does not match, remove it
        if( !util::IsDefined( seq_separation) || seq_separation >= MIN_SEQ_SEPARATION)
        {
          new_neigh.PushBack( *itr);
        }
      }

      // update
      m_MinimalSequenceSeparation = MIN_SEQ_SEPARATION;

      // swap vectors
      new_neigh.InternalData().swap( m_Neighbors.InternalData());

      // return success
      return true;
    }

    //! @brief Remove residues located on the same SSE
    //! @param MODEL the protein model containing the SSEs
    void AANeighborList::PruneResiduesSameSSE( const ProteinModel &MODEL)
    {
      util::SiPtr< const SSE> sse( MODEL.GetSSE( *m_CenterAminoAcid));
      storage::Vector< storage::Pair< util::SiPtr< const biol::AABase>, double> > new_neigh;
      new_neigh.AllocateMemory( m_Neighbors.GetSize());

      // iterate over all neighbors
      for( auto itr( m_Neighbors.Begin()), itr_end( m_Neighbors.End()); itr != itr_end; ++itr)
      {
        // if chain id does not match, remove it
        if( sse != MODEL.GetSSE( *( itr->First())))
        {
          new_neigh.PushBack( *itr);
        }
      }

      // swap vectors
      new_neigh.InternalData().swap( m_Neighbors.InternalData());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AANeighborList::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_DistanceCutoff           , ISTREAM);
      io::Serialize::Read( m_MinimalSequenceSeparation, ISTREAM);
      io::Serialize::Read( m_ConsiderDifferentChain   , ISTREAM);
//      io::Serialize::Read( m_CenterAminoAcid          , ISTREAM);
      io::Serialize::Read( m_Neighbors              , ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AANeighborList::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_DistanceCutoff           , OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_MinimalSequenceSeparation, OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_ConsiderDifferentChain   , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_CenterAminoAcid          , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Neighbors                , OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_neighbor_vector.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list.h"
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"
#include "linal/bcl_linal_vector_3d_operations.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! @brief returns the default lower and higher thresholds
    //! @return the default lower and higher thresholds
    const math::Range< double> &AANeighborVector::GetDefaultThresholdLowHigh()
    {
      // static range to hold values
      static const math::Range< double> s_default_threshold_low_high( 3.3, 11.1);

      // end
      return s_default_threshold_low_high;
    }

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &AANeighborVector::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "neighbor_vector_sasa_all_chains_membrane.histograms");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &AANeighborVector::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "aaneighvector");

      // end
      return s_default_scheme;

    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @param SCHEME scheme to be used
    AANeighborVector::AANeighborVector( const std::string &SCHEME) :
      m_Scheme( SCHEME),
      m_ThresholdLowHigh( GetDefaultThresholdLowHigh()),
      m_MininalSequenceSeparation( s_DefaultMinimalSequenceSeparation)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AANeighborVector object copied from this one
    AANeighborVector *AANeighborVector::Clone() const
    {
      return new AANeighborVector( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AANeighborVector::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AANeighborVector::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief min and max exposure measure
    //! @return range in which exposure can be
    const math::Range< double> &AANeighborVector::GetRange() const
    {
      static const math::Range< double> s_range( 0, 1);
      return s_range;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculates the neighbor vector for a given amino acid within the specified sequence separation and threshold
    //! @param AA_NEIGHBOR_LIST AANeighborList to be used for a single amino acid
    //! @param THRESHOLD_LOW_HIGH lower and higher distance thresholds
    //! @param NORMALIZE_BY_NEIGHBOR_COUNT flag to normalize by neighbor count
    //! @return the neighbor vector for a given amino acid within the specified sequence separation and threshold
    linal::Vector3D
    AANeighborVector::NeighborVector
    (
      const AANeighborList &AA_NEIGHBOR_LIST,
      const math::Range< double> &THRESHOLD_LOW_HIGH,
      const bool NORMALIZE_BY_NEIGHBOR_COUNT
    )
    {
      // check that the given neighbor list has the proper parameters
      const double dist_cutoff( AA_NEIGHBOR_LIST.GetDistanceCutoff());
      const double thresh_high( THRESHOLD_LOW_HIGH.GetMax());
      BCL_Assert
      (
        dist_cutoff == thresh_high, "given neighbor list does not have the proper distance cutoff : " +
        util::Format()( dist_cutoff) + " != " + util::Format()( thresh_high)
      );

      // current first sidechain atom coordinate
      const linal::Vector3D &current_cb_coordinate( AA_NEIGHBOR_LIST.GetCenterAminoAcid()->GetFirstSidechainAtom().GetCoordinates());

      // start with the assumption that the current AA has no neighbors
      double neighbor_count( 0.0);

      // vector variable used to hold the sums of all vectors between the current AA and neighboring AAs
      linal::Vector3D vector_sum;

      //loop over all AAs to calculate env_radius
      for
      (
        AANeighborList::const_iterator
          dist_aa_itr( AA_NEIGHBOR_LIST.Begin()),
          dist_aa_itr_end( AA_NEIGHBOR_LIST.End());
        dist_aa_itr != dist_aa_itr_end;
        ++dist_aa_itr
      )
      {
        // determine the weight assigned to this neighbor
        const double neighbor_weight
        (
          coord::NeighborWeight( dist_aa_itr->Second(), THRESHOLD_LOW_HIGH.GetMin(), THRESHOLD_LOW_HIGH.GetMax())
        );

        neighbor_count += neighbor_weight;

        // normalize each neighbor vector such that each gets an initial weight of 1 (before the neighbor_weight)
        vector_sum += ( ( dist_aa_itr->First()->GetFirstSidechainAtom().GetCoordinates() - current_cb_coordinate).Normalize() * neighbor_weight);

      } // aa loop

      if( NORMALIZE_BY_NEIGHBOR_COUNT && ( neighbor_count > 0.0))
      {
        vector_sum /= neighbor_count;
      }

      // end
      return vector_sum;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate neighbor vector potential for a given amino acid and its AANeighborList
    //! @return neighbor vector potential for a given amino acid and its AANeighborList
    double AANeighborVector::operator()( const AANeighborList &AA_NEIGHBOR_LIST) const
    {
      // calculate RadiusEnvirmonment for current aminoacid
      return NeighborVector( AA_NEIGHBOR_LIST, m_ThresholdLowHigh, true).Norm();
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AANeighborVector::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme          , ISTREAM);
      io::Serialize::Read( m_ThresholdLowHigh, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @return returns the output stream
    std::ostream &AANeighborVector::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme          , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ThresholdLowHigh, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_aa_sasa_ols.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list.h"
#include "biol/bcl_biol_aa_base.h"
#include "biol/bcl_biol_atom.h"
#include "coord/bcl_coord_sphere.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! @brief returns the default sphere radius
    //! @return the default sphere radius
    double AASasaOLS::GetDefaultSphereRadius()
    {
      // static integer to hold value
      static const double s_default_sphere_radius( 4.75);

      // end
      return s_default_sphere_radius;
    }

    //! @brief returns default file where the statistics and in consequence the energy potentials are read from
    //! @return default file where the statistics and in consequence the energy potentials are read from
    const std::string &AASasaOLS::GetDefaultHistogramFilename()
    {
      // static string
      static const std::string s_default_histogram_filename( "ols_sasa_all_chains_membrane.histograms");

      // end
      return s_default_histogram_filename;
    }

    //! @brief returns default scheme
    //! @return default scheme
    const std::string &AASasaOLS::GetDefaultScheme()
    {
      // static string
      static const std::string s_default_scheme( "sasaols");

      // end
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @param SCHEME scheme to be used
    AASasaOLS::AASasaOLS( const std::string &SCHEME) :
      m_Scheme( SCHEME),
      m_SphereRadiusThreshold( 0, 2 * GetDefaultSphereRadius()),
      m_MininalSequenceSeparation( s_DefaultMinimalSequenceSeparation)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new AASasaOLS object copied from this one
    AASasaOLS *AASasaOLS::Clone() const
    {
      return new AASasaOLS( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AASasaOLS::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &AASasaOLS::GetScheme() const
    {
      return m_Scheme;
    }

    //! @brief min and max exposure measure
    //! @return range in which exposure can be
    const math::Range< double> &AASasaOLS::GetRange() const
    {
      static const math::Range< double> s_range( 0, 1);
      return s_range;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate SASA for a given amino acid and its AANeighborList
    //! @return SASA for a given amino acid and its AANeighborList
    double AASasaOLS::operator()( const AANeighborList &AA_NEIGHBOR_LIST) const
    {
      // radius
      const double radius( m_SphereRadiusThreshold.GetMax() / 2);

      // check that the given neighbor list has the proper parameters
      BCL_Assert
      (
        AA_NEIGHBOR_LIST.GetDistanceCutoff() == 2 * radius,
        "given neighbor list does not have the proper distance cutoff: " +
        util::Format()( AA_NEIGHBOR_LIST.GetDistanceCutoff()) + " == " + util::Format()( 2 * radius)
      );

      if( !AA_NEIGHBOR_LIST.GetCenterAminoAcid()->GetFirstSidechainAtom().GetCoordinates().IsDefined())
      {
        return util::GetUndefined< double>();
      }

      // sphere for center aa
      const coord::Sphere center_sphere
      (
        AA_NEIGHBOR_LIST.GetCenterAminoAcid()->GetFirstSidechainAtom().GetCoordinates(), radius
      );

      // create a sphere for all neighbor amino acids
      storage::List< coord::Sphere> spheres;

      // iterate over all neighbors
      for
      (
        AANeighborList::const_iterator itr( AA_NEIGHBOR_LIST.Begin()), itr_end( AA_NEIGHBOR_LIST.End());
        itr != itr_end;
        ++itr
      )
      {
        if( itr->First()->GetFirstSidechainAtom().GetCoordinates().IsDefined())
        {
          spheres.PushBack
          (
            coord::Sphere( itr->First()->GetFirstSidechainAtom().GetCoordinates(), radius)
          );
        }
      }

      // calculate the free surface area fraction
      return center_sphere.FreeSurfaceAreaFraction( util::ConvertToConstSiPtrList< const coord::Sphere>( spheres.Begin(), spheres.End()), 100);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from istream
    //! @param ISTREAM is the input stream
    //! @return returns the input stream
    std::istream &AASasaOLS::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme               , ISTREAM);
      io::Serialize::Read( m_SphereRadiusThreshold, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to ostream
    //! @param OSTREAM is the output stream
    //! @return returns the output stream
    std::ostream &AASasaOLS::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme               , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SphereRadiusThreshold, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_analyze_chi_angle_pair_distribution.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "biol/bcl_biol_rotamer.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_gnuplot_heatmap.h"
#include "math/bcl_math_histogram_2d.h"
#include "util/bcl_util_string_functions.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AnalyzeChiAnglePairDistribution::s_Instance
    (
      util::Enumerated< AnalyzeProteinEnsembleInterface>::AddInstance( new AnalyzeChiAnglePairDistribution())
    );

    //! @brief provides the min and max values contained in the heat map
    //! @return min and max values contained in the heat map
    const storage::VectorND< 2, double> &AnalyzeChiAnglePairDistribution::GetMinMax()
    {
      static const storage::VectorND< 2, double> s_min_max( -180.0, 180.0);
      return s_min_max;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AnalyzeChiAnglePairDistribution::AnalyzeChiAnglePairDistribution() :
      m_OutFilePostFix( ".ChiAnglePairDistribution"),
      m_HistogramBinSize( 60),
      m_LocatorAA( CollectorAAType( storage::Set< biol::AAType>::Create( biol::GetAATypes().ALA, biol::GetAATypes().ARG))),
      m_ChiA( biol::ChiAngle::e_One),
      m_ChiB( biol::ChiAngle::e_Two),
      m_SetTitleAndLabel( true),
      m_Title( "Title"),
      m_ShowColorBox( true),
      m_FontSize( 10),
      m_ResolutionX( 640),
      m_ResolutionY( 640),
      m_ReferenceChiFilename( "native_chi_pairs.ls"),
      m_Font     ( "Arial"),
      m_GreyScale( false),
      m_PlotRatio( util::GetUndefinedDouble()),
      m_BinsPerTic( 1),
      m_CenterTics( false),
      m_MinZ( util::GetUndefinedDouble()),
      m_MaxZ( util::GetUndefinedDouble()),
      m_Normalize( true)
    {
    }

    //! @brief Clone function
    //! @return pointer to new AnalyzeChiAnglePairDistribution
    AnalyzeChiAnglePairDistribution *AnalyzeChiAnglePairDistribution::Clone() const
    {
      return new AnalyzeChiAnglePairDistribution( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AnalyzeChiAnglePairDistribution::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gives the string to append to the the end of a filename to identify this analysis
    //! @return gives the string to append to the the end of a filename to identify this analysis
    const std::string &AnalyzeChiAnglePairDistribution::GetOutFilePostfix() const
    {
      return m_OutFilePostFix;
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &AnalyzeChiAnglePairDistribution::GetAlias() const
    {
      static const std::string s_Name( "ChiAnglePairDistribution");
      return s_Name;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief takes an ensemble and does an analysis resulting in string containing formatted information
    //! @param ENSEMBLE the ensemble that will be analyzed
    //! @return string which has the analyzed information about the ensemble
    std::string AnalyzeChiAnglePairDistribution::operator()( const ProteinEnsemble &ENSEMBLE) const
    {
      // calculate normalized chi angle statistics
      const math::Histogram2D chi_stats
      (
        CalculateChiAngleStatistics( ENSEMBLE, m_HistogramBinSize, m_LocatorAA, m_ChiA, m_ChiB)
      );

      // get the gnuplot script object
      const math::GnuplotHeatmap heatmap
      (
        GetHeatMap
        (
          chi_stats, m_ChiA, m_ChiB, m_SetTitleAndLabel, m_Title, m_ShowColorBox,
          m_FontSize, m_ResolutionX, m_ResolutionY, m_ReferenceChiFilename
        )
      );

      // write heat map to string stream
      std::stringstream stream;
      heatmap.WriteScript( stream);

      // return the string
      return stream.str();
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AnalyzeChiAnglePairDistribution::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_OutFilePostFix, ISTREAM);
      io::Serialize::Read( m_HistogramBinSize, ISTREAM);
      io::Serialize::Read( m_LocatorAA, ISTREAM);
      io::Serialize::Read( m_ChiA, ISTREAM);
      io::Serialize::Read( m_ChiB, ISTREAM);

      io::Serialize::Read( m_SetTitleAndLabel, ISTREAM);
      io::Serialize::Read( m_Title, ISTREAM);
      io::Serialize::Read( m_ShowColorBox, ISTREAM);
      io::Serialize::Read( m_FontSize, ISTREAM);
      io::Serialize::Read( m_ResolutionX, ISTREAM);
      io::Serialize::Read( m_ResolutionY, ISTREAM);
      io::Serialize::Read( m_ReferenceChiFilename, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AnalyzeChiAnglePairDistribution::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_OutFilePostFix, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_HistogramBinSize, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_LocatorAA, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_ChiA, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_ChiB, OSTREAM, INDENT) << "\n";

      io::Serialize::Write( m_SetTitleAndLabel, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_Title, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_ShowColorBox, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_FontSize, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_ResolutionX, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_ResolutionY, OSTREAM, INDENT) << "\n";
      io::Serialize::Write( m_ReferenceChiFilename, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AnalyzeChiAnglePairDistribution::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription
      (
        "Outputs gnuplot script to create 2D heat map showing frequency with which chi angles are observed."
        "Uses a collector interface to find the residues of interest from the protein ensemble. The chi angles"
        "are calculated for two desired chi angles for the residues of interest. The frequency with which"
        "a pair of chi angles is observed is shown in the heat map. The possibility to highlight up to two"
        "different sets of desired chi angle combinations is available (e.g. a) combinations available in a"
        "rotamer library and b) experimentally observed combinations). These are highlighted via boxes of"
        "specified dimensions."
      );

      parameters.AddInitializer
      (
        "filename_postfix",
        "the postfix that will be appended to the output file in order to identify this analysis",
        io::Serialization::GetAgent( &m_OutFilePostFix),
        ".ChiAnglePairDistribution"
      );

      parameters.AddInitializer
      (
        "histogram_binsize",
        "the width of one bin of the score histograms",
        io::Serialization::GetAgent( &m_HistogramBinSize),
        "0.1"
      );

      parameters.AddInitializer
      (
        "collector_type",
        "the type of collector that should be used to get residues of interest",
        io::Serialization::GetAgent( &m_LocatorAA)
      );

      parameters.AddInitializer
      (
        "chi_angle_a",
        "the first of two chi angles that statistics should be done over",
        io::Serialization::GetAgent( &m_ChiA),
        "e_One"
      );

      parameters.AddInitializer
      (
        "chi_angle_b",
        "the second of two chi angles that statistics should be done over",
        io::Serialization::GetAgent( &m_ChiB),
        "e_Two"
      );

      parameters.AddInitializer
      (
        "set_title_and_label",
        "1 if the title and axis labels should be set on the resulting heat map - 0 otherwise",
        io::Serialization::GetAgent( &m_SetTitleAndLabel),
        "1"
      );

      parameters.AddInitializer
      (
        "title",
        "the title that will label the resulting heat map",
        io::Serialization::GetAgent( &m_Title),
        "Title"
      );

      parameters.AddInitializer
      (
        "show_color_box",
        "1 if the color box (i.e. coloring scale) should be shown - 0 otherwise",
        io::Serialization::GetAgent( &m_ShowColorBox),
        "1"
      );

      parameters.AddInitializer
      (
        "font_size",
        "the size text in the heat map should have",
        io::Serialization::GetAgent( &m_FontSize),
        "10"
      );

      parameters.AddInitializer
      (
        "x_pixels",
        "the number of pixels in the x direction",
        io::Serialization::GetAgent( &m_ResolutionX),
        "640"
      );

      parameters.AddInitializer
      (
        "y_pixels",
        "the number of pixels in the y direction",
        io::Serialization::GetAgent( &m_ResolutionY),
        "640"
      );

      parameters.AddInitializer
      (
        "reference_chi_filename",
        "The name of the file that contains reference chi angle pairs and optional gnuplot formatted specifications"
        "for the box that will indicate the location of the chi angle pair. The format of the input file should be"
        "\n<chi_a> <chi_b> <box_side_length> <specifications>\nAn example is\n"
        "-69.01 -56.55 60 fs empty border -1 linewidth 0.5 front\nor\n"
        "-76.44 -55.52 30 fs empty border  0 linewidth 0.5 front\n"
        "this file is always attempted to be read, but if it cannot be opened, the heatmap is made anyways.",
        io::Serialization::GetAgent( &m_ReferenceChiFilename),
        "reference_chi_angle_pairs.ls"
      );

      parameters.AddInitializer
      (
        "font",
        "The font to be used for text in the plot",
        io::Serialization::GetAgent( &m_Font),
        "Arial"
      );

      parameters.AddInitializer
      (
        "grey_scale",
        "boolean true the color palette for the gradient should be grey scale. 1=true;0=false",
        io::Serialization::GetAgent( &m_GreyScale),
        "0"
      );

      parameters.AddInitializer
      (
        "plot_ratio",
        "How much of the png area the plot will cover top to bottom and left to write."
        " (this does not include any labels or tics). So if you say 0.5, plot will go from 0 to 0.5 from bottom"
        " to top and left to right",
        io::Serialization::GetAgent( &m_PlotRatio),
        util::Format()( util::GetUndefinedDouble())
      );

      parameters.AddInitializer
      (
        "bins_per_tic",
        "how many bins per tic in the plot. 1 means every bin is labeled, 2 means every other, etc.",
        io::Serialization::GetAgent( &m_BinsPerTic),
        "1"
      );

      parameters.AddInitializer
      (
        "center_tics",
        "boolean if true, tics will be centered on the bins, if false, will be on edges of bins. 1=true;0=false",
        io::Serialization::GetAgent( &m_CenterTics),
        "0"
      );

      parameters.AddInitializer
      (
        "min_z",
        "the minimum value used in pymol for the z axis (i.e. color). Values below this will just get the minimum value color.",
        io::Serialization::GetAgent( &m_MinZ),
        util::Format()( util::GetUndefinedDouble())
      );
      parameters.AddInitializer
      (
        "max_z",
        "the maximum value used in pymol for the z axis (i.e. color). Values above this will just get the maximum value color.",
        io::Serialization::GetAgent( &m_MaxZ),
        util::Format()( util::GetUndefinedDouble())
      );

      parameters.AddInitializer
      (
        "normalize_histogram",
        "boolean true indicates that the distance distribution histogram will be normalized. 1=true;0=false",
        io::Serialization::GetAgent( &m_Normalize),
        "1"
      );

      return parameters;
    }

    //! @brief gives distribution for observed combinations of two chi angles for a desired residue in an ensemble
    //! @param ENSEMBLE the ensemble the distribution will be calculated over
    //! @param BIN_SIZE the size of bins that should be used for the histogram distribution
    //! @param LOCATOR the method for locating the residue of interest
    //! @param CHI_A the first chi angle of interest
    //! @param CHI_B the second chi angle of interest
    //! @return histogram 2D which has the distribution of chia and chib angles observed in the ensemble
    math::Histogram2D AnalyzeChiAnglePairDistribution::CalculateChiAngleStatistics
    (
      const ProteinEnsemble &ENSEMBLE, const double BIN_SIZE,
      const find::CollectorInterface
      <
        util::SiPtrList< const biol::AABase>, util::SiPtrVector< const biol::AABase>
       > &LOCATOR,
       const biol::ChiAngle::ChiEnum CHI_A, const biol::ChiAngle::ChiEnum CHI_B
    ) const
    {
      // to hold the distribution
      const size_t num_bins( ( GetMinMax().Second() - GetMinMax().First()) / BIN_SIZE);
      math::Histogram2D distribution
      (
        storage::VectorND< 2, double>( GetMinMax().First(), GetMinMax().First()),
        storage::VectorND< 2, double>( BIN_SIZE, BIN_SIZE), storage::VectorND< 2, size_t>( num_bins, num_bins)
      );

      // iterate through the ensemble
      for
      (
        ProteinEnsemble::const_iterator ensemble_itr( ENSEMBLE.Begin()), ensemble_itr_end( ENSEMBLE.End());
        ensemble_itr != ensemble_itr_end;
        ++ensemble_itr
      )
      {
        // locate the residue of interest
        const util::SiPtrList< const biol::AABase> resi( LOCATOR.Collect( ( *ensemble_itr)->GetAminoAcids()));

        // iterate over the located residues
        for
        (
          util::SiPtrList< const biol::AABase>::const_iterator
            resi_itr( resi.Begin()), resi_itr_end( resi.End());
          resi_itr != resi_itr_end;
          ++resi_itr
        )
        {
          // true if the resi could not be located
          if( !resi_itr->IsDefined())
          {
            BCL_MessageDbg( "resi " + util::Format()( LOCATOR) + " could not be located");

            // go to next model in ensemble
            continue;
          }

          // the dihedral angles
          const biol::Rotamer dihedral_angles( ( *resi_itr)->CalculateSideChainDihedralAngles());

          // the chi angles of interest
          const double chi_angle_a( dihedral_angles.GetAngle( CHI_A, math::Angle::e_Degree)),
            chi_angle_b( dihedral_angles.GetAngle( CHI_B, math::Angle::e_Degree));

          // true if the desired chi angles of the residue could not be calculated
          if( !util::IsDefined( chi_angle_a) || !util::IsDefined( chi_angle_b))
          {
            BCL_MessageDbg
            (
              "can not get dihedral angles chi " + CHI_A.GetString()
              + " and chi " + CHI_B.GetString() +
              " of residue " + ( *resi_itr)->GetIdentification() + " because only the \n" +
              util::Format()( dihedral_angles) + "\ndihedral angles could be calculated"
            );

            // go to next in ensemble
            continue;
          }

          distribution.PushBack( storage::VectorND< 2, double>( chi_angle_a, chi_angle_b));
        }

      }

      // true if desired to normalize
      if( m_Normalize)
      {
        // normalize distribution
        distribution.Normalize();
      }

      return distribution;
    }

    //! @brief creats a heat map based on the distribution of chi angles
    //! @param DISTRIBUTION the distribution of chi angles that will be turned into a heat map
    //! @param CHI_A the first chi angle of interest
    //! @param CHI_B the second chi angle of interest
    //! @param SET_TITLE_AND_LABEL true if the title and axis labels should be set on the resulting heat map or not
    //! @param TITLE the title that will label the resulting heat map
    //! @param SHOW_COLOR_BOX bool TRUE if the color box should be displayed or not - box that shows the color scale
    //! @param FONT_SIZE the size text in the heat map should have
    //! @param RESOLUTION_X the pixel height and width of the heat map graphic
    //! @param RESOLUTION_Y the pixel width and width of the heat map graphic
    //! @param CHI_FILENAME the name of the file that contains chi angle pairs of interest
    //! @return GnuplotHeatmap showing the distribution of chi angles
    math::GnuplotHeatmap AnalyzeChiAnglePairDistribution::GetHeatMap
    (
      const math::Histogram2D &DISTRIBUTION, const biol::ChiAngle::ChiEnum CHI_A,
      const biol::ChiAngle::ChiEnum CHI_B, const bool SET_TITLE_AND_LABEL, const std::string &TITLE,
      const bool SHOW_COLOR_BOX, const double FONT_SIZE, const size_t RESOLUTION_X, const size_t RESOLUTION_Y,
      const std::string &CHI_FILENAME
    ) const
    {
      math::GnuplotHeatmap heatmap;
      const bool center_tic_x( m_CenterTics);
      const bool center_tic_y( m_CenterTics);
      BCL_MessageStd( "center tic x is " + util::Format()( center_tic_x));
      BCL_MessageStd( "center tic y is " + util::Format()( center_tic_y));
      heatmap.SetFromHistogram( DISTRIBUTION, center_tic_x, center_tic_y);

      if( SET_TITLE_AND_LABEL)
      {
        heatmap.SetTitleAndLabel
        (
          TITLE,
          "X_" + util::Format()( CHI_A + 1) + " (\\260)",
          "X_" + util::Format()( CHI_B + 1) + " (\\260)",
          "Frequency (fraction of counts)"
        );
      }
      heatmap.SetRotationXTics( 90);
      heatmap.SetFilename( "AnalyzeChiAnglePairDistribution.gnuplot");
      heatmap.SetFont( m_Font, FONT_SIZE);
      heatmap.SetShowColorBox( SHOW_COLOR_BOX);
      heatmap.SetPixelAndRatio( RESOLUTION_X, RESOLUTION_Y, 1.0);
      heatmap.SetPalette( math::GnuplotHeatmap::e_GreyScale);
      heatmap.SetNoMirrorTics( true);

      if( util::IsDefined( m_PlotRatio) && m_PlotRatio != double( 0))
      {
        heatmap.SetMargins( m_PlotRatio, 0, m_PlotRatio, 0);
      }

      // binning tics
      BCL_MessageCrt( "manually setting tics");
      const linal::Vector< double> binning_x
      (
        linal::FillVector< double>
        (
          DISTRIBUTION.GetNumberOfBinsX() + size_t( !center_tic_x),
          DISTRIBUTION.GetBoundariesX().First() + ( center_tic_x ? 0.5 * DISTRIBUTION.GetBinSizeXY().First() : 0.0),
          DISTRIBUTION.GetBinSizeXY().First()
        )
      );
      BCL_Assert
      (
        heatmap.SetTicsX
        (
          math::GnuplotHeatmap::TicsFromBinning( binning_x, m_BinsPerTic, util::Format().W( 4)),
          center_tic_x,
          m_BinsPerTic
        ), "unable to set tics x"
      );
      const linal::Vector< double> binning_y
      (
        linal::FillVector< double>
        (
          DISTRIBUTION.GetNumberOfBinsY() + size_t( !center_tic_y),
          DISTRIBUTION.GetBoundariesY().First() + ( center_tic_y ? 0.5 * DISTRIBUTION.GetBinSizeXY().Second() : 0.0),
          DISTRIBUTION.GetBinSizeXY().Second()
        )
      );
      BCL_Assert
      (
        heatmap.SetTicsY
        (
          math::GnuplotHeatmap::TicsFromBinning( binning_y, m_BinsPerTic, util::Format().W( 4)),
          center_tic_y,
          m_BinsPerTic
        ), "unable to set tics y"
      );

      // set the min max z values
      heatmap.SetMinMaxZ( m_MinZ, m_MaxZ);

      const double x_min  ( DISTRIBUTION.GetBoundariesX().First());
      const double x_range( DISTRIBUTION.GetBoundariesX().Second() - DISTRIBUTION.GetBoundariesX().First());
      const double y_min  ( DISTRIBUTION.GetBoundariesY().First());
      const double y_range( DISTRIBUTION.GetBoundariesY().Second() - DISTRIBUTION.GetBoundariesY().First());
      AddBoxesToHeatMap( heatmap, CHI_FILENAME, x_range, y_range, x_min, y_min);

      return heatmap;
    }

    //! @brief provides the text necessary to add any desired boxes to the heat map
    //! @param HEAT_MAP the heat map the boxes will be added to
    //! @param CHI_FILENAME the name of the file that contains chi angle pairs of interest
    //! @param X_RANGE the range in the x direction of the plot - the total size of the x direction
    //! @param Y_RANGE the range in the y direction of the plot -  the total size of the y direction
    //! @param X_MIN the minimum value in the x direction of the heat map
    //! @param Y_MIN the minimum value in the y direction of the heat map
    void
    AnalyzeChiAnglePairDistribution::AddBoxesToHeatMap
    (
      math::GnuplotHeatmap &HEAT_MAP, const std::string &CHI_FILENAME,
      const double X_RANGE, const double Y_RANGE, const double X_MIN, const double Y_MIN
    )
    {
      // try to open the chi containing file
      io::IFStream read;
      const bool opened( io::File::TryOpenIFStream( read, CHI_FILENAME));
      if( !opened)
      {
        return;
      }

      // read in teh chi info
      storage::Vector< storage::Vector< std::string> > chi_box_info( util::SplittedStringLineListFromIStream( read));

      // to hold the box coordinates and any specifications of boxes
      storage::Vector< storage::VectorND< 2, storage::VectorND< 2, double> > > box_coords;
      storage::Vector< std::string> box_specifications;

      // iterate through the split lines to get the chi angle and box information
      for
      (
        storage::Vector< storage::Vector< std::string> >::const_iterator
          line_itr( chi_box_info.Begin()), line_itr_end( chi_box_info.End());
        line_itr != line_itr_end;
        ++line_itr
      )
      {
        const storage::Vector< std::string> &current_line( *line_itr);

        BCL_Assert
        (
          current_line.GetSize() > 2, "need to have at least three columns in chi file. But current line has " +
          util::Format()( current_line) + " See parameter reference_chi_filename for information."
        );

        const double chi_a    ( util::ConvertStringToNumericalValue< double>( current_line( 0)));
        const double chi_b    ( util::ConvertStringToNumericalValue< double>( current_line( 1)));
        const double side_size( util::ConvertStringToNumericalValue< double>( current_line( 2)));
        const double half_side_size( side_size / 2.0);

        // get box corner coordinates
        const double lower_x( chi_a - half_side_size);
        const double lower_y( chi_b - half_side_size);
        const double upper_x( chi_a + half_side_size);
        const double upper_y( chi_b + half_side_size);

        // get the specifications
        std::string current_specs;
        for
        (
          storage::Vector< std::string>::const_iterator
            line_itr_b( line_itr->Begin() + 3), line_itr_end_b( line_itr->End());
          line_itr_b != line_itr_end_b;
          ++line_itr_b
        )
        {
          current_specs += " " + *line_itr_b;
        }

        // add box
        {
          storage::VectorND< 2, storage::VectorND< 2, double> > box
          (
            storage::VectorND< 2, double>( lower_x, lower_y), storage::VectorND< 2, double>( upper_x, upper_y)
          );
          box_coords.PushBack( box);
          box_specifications.PushBack( current_specs);
        }

        // get parts of box that need to wrap around to other side of plot
        // x direction - wrap from left to right
        if( math::Absolute( lower_x) > math::Absolute( GetMinMax().First()))
        {
          const double remainder( math::Absolute( lower_x) - math::Absolute( GetMinMax().First()));
          const double remainder_lower_x( GetMinMax().Second() - remainder);
          const double remainder_upper_x( GetMinMax().Second());
          storage::VectorND< 2, storage::VectorND< 2, double> > box
          (
            storage::VectorND< 2, double>( remainder_lower_x, lower_y),
            storage::VectorND< 2, double>( remainder_upper_x, upper_y)
          );
          box_coords.PushBack( box);
          box_specifications.PushBack( current_specs);
        }
        // x direction - wrap from right to left
        if( math::Absolute( upper_x) > math::Absolute( GetMinMax().Second()))
        {
          const double remainder( math::Absolute( upper_x) - math::Absolute( GetMinMax().Second()));
          const double remainder_lower_x( GetMinMax().First());
          const double remainder_upper_x( GetMinMax().First() + remainder);
          storage::VectorND< 2, storage::VectorND< 2, double> > box
          (
            storage::VectorND< 2, double>( remainder_lower_x, lower_y),
            storage::VectorND< 2, double>( remainder_upper_x, upper_y)
          );
          box_coords.PushBack( box);
          box_specifications.PushBack( current_specs);
        }
        // y direction - wrap from bottom to top
        if( math::Absolute( lower_y) > math::Absolute( GetMinMax().First()))
        {
          const double remainder( math::Absolute( lower_y) - math::Absolute( GetMinMax().First()));
          const double remainder_lower_y( GetMinMax().Second() - remainder);
          const double remainder_upper_y( GetMinMax().Second());
          storage::VectorND< 2, storage::VectorND< 2, double> > box
          (
            storage::VectorND< 2, double>( lower_x, remainder_lower_y),
            storage::VectorND< 2, double>( upper_x, remainder_upper_y)
          );
          box_coords.PushBack( box);
          box_specifications.PushBack( current_specs);
        }

        // y direction - wrap from top to bottom
        if( math::Absolute( upper_y) > math::Absolute( GetMinMax().Second()))
        {
          const double remainder( math::Absolute( upper_y) - math::Absolute( GetMinMax().Second()));
          const double remainder_lower_y( GetMinMax().First());
          const double remainder_upper_y( GetMinMax().First() + remainder);
          storage::VectorND< 2, storage::VectorND< 2, double> > box
          (
            storage::VectorND< 2, double>( lower_x, remainder_lower_y),
            storage::VectorND< 2, double>( upper_x, remainder_upper_y)
          );
          box_coords.PushBack( box);
          box_specifications.PushBack( current_specs);
        }

        // lower left corner - wrap to upper right corner
        if
        (
          math::Absolute( lower_x) > math::Absolute( GetMinMax().First())
          && math::Absolute( lower_y) > math::Absolute( GetMinMax().First())
        )
        {
          const double remainder_x( math::Absolute( lower_x) - math::Absolute( GetMinMax().First()));
          const double remainder_lower_x( GetMinMax().Second() - remainder_x);
          const double remainder_upper_x( GetMinMax().Second());
          const double remainder_y( math::Absolute( lower_y) - math::Absolute( GetMinMax().First()));
          const double remainder_lower_y( GetMinMax().Second() - remainder_y);
          const double remainder_upper_y( GetMinMax().Second());
          storage::VectorND< 2, storage::VectorND< 2, double> > box
          (
            storage::VectorND< 2, double>( remainder_lower_x, remainder_lower_y),
            storage::VectorND< 2, double>( remainder_upper_x, remainder_upper_y)
          );
          box_coords.PushBack( box);
          box_specifications.PushBack( current_specs);
        }

        // upper left corner - wrap to lower right corner
        if
        (
          math::Absolute( lower_x) > math::Absolute( GetMinMax().First())
          && math::Absolute( upper_y) > math::Absolute( GetMinMax().Second())
        )
        {
          const double remainder_x( math::Absolute( lower_x) - math::Absolute( GetMinMax().First()));
          const double remainder_lower_x( GetMinMax().Second() - remainder_x);
          const double remainder_upper_x( GetMinMax().Second());
          const double remainder_y( math::Absolute( upper_y) - math::Absolute( GetMinMax().Second()));
          const double remainder_lower_y( GetMinMax().First());
          const double remainder_upper_y( GetMinMax().First() + remainder_y);
          storage::VectorND< 2, storage::VectorND< 2, double> > box
          (
            storage::VectorND< 2, double>( remainder_lower_x, remainder_lower_y),
            storage::VectorND< 2, double>( remainder_upper_x, remainder_upper_y)
          );
          box_coords.PushBack( box);
          box_specifications.PushBack( current_specs);
        }

        // upper right corner - wrap to lower left corner
        if
        (
          math::Absolute( upper_x) >  math::Absolute( GetMinMax().Second()) &&
          math::Absolute( upper_y) >  math::Absolute( GetMinMax().Second())
        )
        {
          const double remainder_x( math::Absolute( upper_x) - math::Absolute( GetMinMax().Second()));
          const double remainder_lower_x( GetMinMax().First());
          const double remainder_upper_x( GetMinMax().First() + remainder_x);

          const double remainder_y( math::Absolute( upper_y) - math::Absolute( GetMinMax().Second()));
          const double remainder_lower_y( GetMinMax().First());
          const double remainder_upper_y( GetMinMax().First() + remainder_y);
          storage::VectorND< 2, storage::VectorND< 2, double> > box
          (
            storage::VectorND< 2, double>( remainder_lower_x, remainder_lower_y),
            storage::VectorND< 2, double>( remainder_upper_x, remainder_upper_y)
          );
          box_coords.PushBack( box);
          box_specifications.PushBack( current_specs);
        }

        // lower right corner - wrap to upper left corner
        if
        (
          math::Absolute( upper_x) >  math::Absolute( GetMinMax().Second()) &&
          math::Absolute( lower_y) >  math::Absolute( GetMinMax().First())
        )
        {
          const double remainder_x( math::Absolute( upper_x) - math::Absolute( GetMinMax().Second()));
          const double remainder_lower_x( GetMinMax().First());
          const double remainder_upper_x( GetMinMax().First() + remainder_x);
          const double remainder_y( math::Absolute( lower_y) - math::Absolute( GetMinMax().First()));
          const double remainder_lower_y( GetMinMax().Second() - remainder_y);
          const double remainder_upper_y( GetMinMax().Second());
          storage::VectorND< 2, storage::VectorND< 2, double> > box
          (
            storage::VectorND< 2, double>( remainder_lower_x, remainder_lower_y),
            storage::VectorND< 2, double>( remainder_upper_x, remainder_upper_y)
          );
          box_coords.PushBack( box);
          box_specifications.PushBack( current_specs);
        }
      }

      HEAT_MAP.SetBoxes( box_coords, X_RANGE, Y_RANGE, X_MIN, Y_MIN);
      HEAT_MAP.SetBoxesSpecifications( box_specifications);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_analyze_chi_angle_recovery.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "biol/bcl_biol_rotamer.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "storage/bcl_storage_table.h"
#include "util/bcl_util_wrapper.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AnalyzeChiAngleRecovery::s_Instance
    (
      util::Enumerated< AnalyzeProteinEnsembleInterface>::AddInstance( new AnalyzeChiAngleRecovery())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AnalyzeChiAngleRecovery::AnalyzeChiAngleRecovery() :
      m_OutFilePostFix( ".ChiAngleRecovery"),
      m_CollectorAA( CollectorAAType( storage::Set< biol::AAType>( biol::GetAATypes().ALA))),
      m_NativeChiFilename( "native_chi.txt"),
      m_Tolerance( 60),
      m_AngleUnit( math::Angle::e_Degree)
    {
    }

    //! @brief Clone function
    //! @return pointer to new AnalyzeChiAngleRecovery
    AnalyzeChiAngleRecovery *AnalyzeChiAngleRecovery::Clone() const
    {
      return new AnalyzeChiAngleRecovery( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AnalyzeChiAngleRecovery::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gives the string to append to the the end of a filename to identify this analysis
    //! @return gives the string to append to the the end of a filename to identify this analysis
    const std::string &AnalyzeChiAngleRecovery::GetOutFilePostfix() const
    {
      return m_OutFilePostFix;
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &AnalyzeChiAngleRecovery::GetAlias() const
    {
      static const std::string s_Name( "ChiAngleRecovery");
      return s_Name;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief takes an ensemble and does an analysis resulting in string containing formatted information
    //! @param ENSEMBLE the ensemble that will be analyzed
    //! @return string which has the analyzed information about the ensemble
    std::string AnalyzeChiAngleRecovery::operator()( const ProteinEnsemble &ENSEMBLE) const
    {
      //
      const storage::Vector< biol::Rotamer> native_chis( GetNativeChiAngles());

      // to keep track of how many times the chi angles of models agree with native chi angles
      storage::Map< biol::ChiAngle::ChiEnum, size_t> correct_counts;

      // to keep count of total counts of chi angles
      storage::Map< biol::ChiAngle::ChiEnum, size_t> counts;

      // to hold the pdbs that have the most number of correct chis
      std::multimap< size_t, std::string> num_correct_chi_pdb;

      // to hold the best number of chi that are correct
      size_t most_correc_chi( 0);

      // iterate through the ensemble
      for
      (
        ProteinEnsemble::const_iterator protein_itr( ENSEMBLE.Begin()), protein_itr_end( ENSEMBLE.End());
        protein_itr != protein_itr_end;
        ++protein_itr
      )
      {
        // collect the residues of interest
        const util::SiPtrList< const biol::AABase> collected_aas
        (
          m_CollectorAA.Collect( ( *protein_itr)->GetAminoAcids())
        );

        const size_t current_correct_chi( GetCollectedAACounts( collected_aas, native_chis, correct_counts, counts));

        // true if this pdb has more or as many chis correct as any other pdb
        if( current_correct_chi >= most_correc_chi)
        {
          // get pdb name
          const util::ShPtr< util::Wrapper< std::string> > pdb_name
          (
            ( *protein_itr)->GetProteinModelData()->GetData( ProteinModelData::e_PDBFile)
          );
          BCL_Assert( pdb_name.IsDefined(), "pdb name is not defined");

          // set chi key to the current pdb name
          num_correct_chi_pdb.insert( std::pair< size_t, std::string>( current_correct_chi, std::string( pdb_name->GetData())));

          if( current_correct_chi > most_correc_chi)
          {
            // remove all the previous best number of chis from the map
            num_correct_chi_pdb.erase( most_correc_chi);
            // now set the most correct chis to the current number of correct chis
            most_correc_chi = current_correct_chi;
          }
        }
      } //< iterate through ensemble

      std::string output_string( GetAnalysisString( correct_counts, counts));

      // add the best pdbs to the output string
      for
      (
        auto pdb_itr( num_correct_chi_pdb.begin()), pdb_itr_end( num_correct_chi_pdb.end());
        pdb_itr != pdb_itr_end;
        ++pdb_itr
      )
      {
        output_string += "\n" + pdb_itr->second;
      }

      return output_string;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AnalyzeChiAngleRecovery::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_OutFilePostFix, ISTREAM);
      io::Serialize::Read( m_CollectorAA, ISTREAM);
      io::Serialize::Read( m_NativeChiFilename, ISTREAM);
      io::Serialize::Read( m_Tolerance, ISTREAM);
      io::Serialize::Read( m_AngleUnit, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AnalyzeChiAngleRecovery::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_OutFilePostFix, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_CollectorAA, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_NativeChiFilename, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Tolerance, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AngleUnit, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AnalyzeChiAngleRecovery::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription
      (
        "Analyzes the frequency with which chi angles for desired residues are recovered in a protein ensemble. "
        "Outputs a table that has, for each chi observed in the ensemble (chi are column names), "
        "the number of times it was correct, the number of times it was seen, and the percentage of the time "
        "it was correct. These are the rows of the table. In order for a chi to be considered correct, "
        "all the preceding chi angles must have "
        "also been correct. Correctness is determined via a +-tolerance of the inputted native chi angles. "
        "See the reference_chi_filename parameter for information about file format for inputting native chi angles. "
        "If there are multiple native rotamer conformations, the model side chains will be checked against each of "
        "the native rotamers, and the model side chain will be correct if it is in agreement with any of the native"
        " rotamers."
      );

      parameters.AddInitializer
      (
        "filename_postfix",
        "the postfix that will be appended to the output file in order to identify this analysis",
        io::Serialization::GetAgent( &m_OutFilePostFix),
        ".ChiAngleRecovery"
      );

      parameters.AddInitializer
      (
        "collector_type",
        "the type of collector that should be used to get residues of interest",
        io::Serialization::GetAgent( &m_CollectorAA)
      );

      parameters.AddInitializer
      (
        "reference_chi_filename",
        "The file can have multiple possible correct rotamers that the side chains from the ensemble will be "
        "compared against. The file format is\n"
        "bcl::biol::Rotamer\n"
        "<chi> <angle value> <angle unit>\n"
        "Each additional chi follows on a separate line. If multiple rotamers are given, an additional "
        "bcl::biol::Rotamer needs to separate them."
        "An example input file is\n"
        "bcl::biol::Rotamer\n"
        "e_One  95 degree\n"
        "e_Two 120 degree\n"
        "bcl::biol::Rotamer\n"
        "bcl::biol::Rotamer\n"
        "e_One   0.5236 radian\n"
        "e_Two -45.0000 degree\n",
        io::Serialization::GetAgent( &m_NativeChiFilename),
        "reference_chi_angles.ls"
      );

      parameters.AddInitializer
      (
        "tolerance",
        "the +- error allowed to still consider a chi value correct",
        io::Serialization::GetAgent( &m_Tolerance),
        "30"
      );

      parameters.AddInitializer
      (
        "angle_unit",
        "the unit that the tolerance is given in",
        io::Serialization::GetAgent( &m_AngleUnit),
        "degree"
      );

      return parameters;
    }

    //! @brief reads rotamers from a file
    //! @return vector of rotamers read from a file
    storage::Vector< biol::Rotamer> AnalyzeChiAngleRecovery::GetNativeChiAngles() const
    {
      io::IFStream read;

      io::File::MustOpenIFStream( read, m_NativeChiFilename);

      storage::Vector< biol::Rotamer> rotamers;

      biol::Rotamer current_rotamer;
      current_rotamer.ReadSimple( read);
      rotamers.PushBack( current_rotamer);

      BCL_MessageDbg( "read in rotamer " + util::Format()( current_rotamer));
      while( !read.eof() && read.peek() != std::istream::traits_type::eof())
      {
        BCL_MessageDbg( "reading in rotamer");
        biol::Rotamer next_rotamer;
        next_rotamer.ReadSimple( read);
        BCL_MessageDbg( "read in rotamer " + util::Format()( current_rotamer));
        rotamers.PushBack( next_rotamer);
      }
      BCL_MessageDbg( "all read in rotamers are " + util::Format()( rotamers));
      return rotamers;
    }

    //! @brief gets the counts of how many times a chi is seen and how many times it is correct for collected residues
    //! @param COLLECTED_AAS the collected residues whos chis will be counted and checked for correctness
    //! @param NATIVE_CHI the correct chi angles the collected aas will be compared against
    //! @param CORRECT_CHI_COUNTS the map keeping track of how many times a chi is correct
    //! @param CHI_COUNTS the map keeping track of how many times a chi is seen in the collected aas
    //! @return size_t indicating the maximum number of chis that is correct out of the collected aas
    size_t AnalyzeChiAngleRecovery::GetCollectedAACounts
    (
      const util::SiPtrList< const biol::AABase> &COLLECTED_AAS,
      const storage::Vector< biol::Rotamer> &NATIVE_CHI,
      storage::Map< biol::ChiAngle::ChiEnum, size_t> &CORRECT_CHI_COUNTS,
      storage::Map< biol::ChiAngle::ChiEnum, size_t> &CHI_COUNTS
    ) const
    {
      size_t most_correct_chis( 0);
      // iterate through the collected residues
      for
      (
        util::SiPtrList< const biol::AABase>::const_iterator
          aa_itr( COLLECTED_AAS.Begin()), aa_itr_end( COLLECTED_AAS.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // get the dihedral angles of the residue
        const biol::Rotamer model_rotamer( ( *aa_itr)->CalculateSideChainDihedralAngles());

        AddChiCounts( model_rotamer.GetChis(), CHI_COUNTS);

        // make sure correct number of chi angles were calculated
        BCL_Assert
        (
          model_rotamer.GetSize() ==
            ( *aa_itr)->GetData()->GetType()->GetSideChainDihedralAngleAtomTypes().GetSize(),
            "model residue gives chi angles " + util::Format()( model_rotamer) + " but chis should be " +
            util::Format()( ( *aa_itr)->GetData()->GetType()->GetSideChainDihedralAngleAtomTypes())
        );

        const storage::Set< biol::ChiAngle::ChiEnum> correct_chis( FindBestMatchingChis( NATIVE_CHI, model_rotamer));
        AddChiCounts( correct_chis, CORRECT_CHI_COUNTS);

        if( correct_chis.GetSize() > most_correct_chis)
        {
          most_correct_chis = correct_chis.GetSize();
        }
      }

      return most_correct_chis;
    }

    //! @brief determines the largest number of chis that can match between the model rotamer and any of the natives
    //! @param NATIVE_ROTAMERS the rotamers the model rotamer will be compared against
    //! @param MODEL_ROTAMER the rotamer that is going to be checked against each of the native rotamers
    //! @return set with the chis that match between the model rotamer and the best matching native rotamer
    storage::Set< biol::ChiAngle::ChiEnum> AnalyzeChiAngleRecovery::FindBestMatchingChis
    (
      const storage::Vector< biol::Rotamer> &NATIVE_ROTAMERS,
      const biol::Rotamer &MODEL_ROTAMER
    ) const
    {
      storage::Set< biol::ChiAngle::ChiEnum> matching_chi;

      // go through the native rotamers to find the best possible agreement with the residue dihedral angles
      for
      (
        storage::Vector< biol::Rotamer>::const_iterator
          rotamer_itr( NATIVE_ROTAMERS.Begin()), rotamer_itr_end( NATIVE_ROTAMERS.End());
        rotamer_itr != rotamer_itr_end;
        ++rotamer_itr
      )
      {
        const storage::Set< biol::ChiAngle::ChiEnum> current_matching_chi
        (
          rotamer_itr->ChiMatchDependent( MODEL_ROTAMER, m_AngleUnit, m_Tolerance)
        );

        // true if best match seen so far
        if( current_matching_chi.GetSize() > matching_chi.GetSize())
        {
          matching_chi = current_matching_chi;
        }
      }

      BCL_MessageDbg( "best matching chis are " + util::Format()( matching_chi));

      return matching_chi;
    }

    //! @brief adds chis contained in a set of chis to a map keeping track of how many times that chi has been seen
    //! @param CHIS the chis whose counts will be added
    //! @param CHI_COUNTER the map of chi angles keeping track of how often a chi has been seen
    void AnalyzeChiAngleRecovery::AddChiCounts
    (
      const storage::Set< biol::ChiAngle::ChiEnum> &CHIS, storage::Map< biol::ChiAngle::ChiEnum, size_t> &CHI_COUNTER
    )
    {
      // iterate through the chis
      for
      (
        storage::Set< biol::ChiAngle::ChiEnum>::const_iterator chi_itr( CHIS.Begin()), chi_itr_end( CHIS.End());
        chi_itr != chi_itr_end;
        ++chi_itr
      )
      {
        // try to find the chi in the chi counter map
        storage::Map< biol::ChiAngle::ChiEnum, size_t>::const_iterator found_itr( CHI_COUNTER.Find( *chi_itr));

        // true if the chi was found in the counter map
        if( found_itr != CHI_COUNTER.End())
        {
          // increment the counter
          ++CHI_COUNTER[ *chi_itr];
        }
        else //< chi not yet seen
        {
          // set to one since this is the first time it is seen
          CHI_COUNTER[ *chi_itr] = 1;
        }
      }
    }

    //! @brief gives the string that will be outputted to a file for the analysis
    //! @param CORRECT_COUNTS the map that kept track of the nubmer of times a chi is correct
    //! @param TOTAL_COUNTS the map that kept track of the total number of times a chi was observed
    //! @return string which has the string that will be output as the analysis of chi recovery
    std::string AnalyzeChiAngleRecovery::GetAnalysisString
    (
      const storage::Map< biol::ChiAngle::ChiEnum, size_t> &CORRECT_COUNTS,
      const storage::Map< biol::ChiAngle::ChiEnum, size_t> &TOTAL_COUNTS
    ) const
    {
      storage::Vector< std::string> column_names;

      storage::Vector< double> counts;
      storage::Vector< double> correct;
      storage::Vector< double> percent;

      // iterate over the total counts-any chi in total counts will be in correct counts also, but reverse is not true
      for
      (
        storage::Map< biol::ChiAngle::ChiEnum, size_t>::const_iterator
          chi_itr( TOTAL_COUNTS.Begin()), chi_itr_end( TOTAL_COUNTS.End());
        chi_itr != chi_itr_end;
        ++chi_itr
      )
      {
        // get chi name for column name
        column_names.PushBack( biol::ChiAngle::ChiEnum( chi_itr->first).GetString());

        // get the counts for the current chi
        counts.PushBack( chi_itr->second);

        // try to get the chi from correct counts
        storage::Map< biol::ChiAngle::ChiEnum, size_t>::const_iterator correct_itr( CORRECT_COUNTS.Find( chi_itr->first));

        // true chi exists in correct counts meaning it was correct at least once
        if( correct_itr != CORRECT_COUNTS.End())
        {
          // get the correct counts
          correct.PushBack( correct_itr->second);

          // get the percent correct
          percent.PushBack( double( correct_itr->second) / double( chi_itr->second) * 100.0);
        }
        else //< current chi was never correct
        {
          // correct counts is zero
          correct.PushBack( 0);

          // average is zero
          percent.PushBack( 0);
        }
      }

      // create table header from the chi strings
      storage::TableHeader header( column_names);

      storage::Table< double> table( header);

      table.InsertRow( "total_counts", counts);
      table.InsertRow( "correct_counts", correct);
      table.InsertRow( "percent", percent);

      std::stringstream stream;
      table.WriteFormatted( stream);

      return stream.str();
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_analyze_protein_ensemble_aa_neighborhood.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_count.h"
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_aa_neighbor_vector.h"
#include "assemble/bcl_assemble_aa_sasa_ols.h"
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "biol/bcl_biol_membrane.h"
#include "command/bcl_command_parameter_check_allowed.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_running_min_max.h"
#include "score/bcl_score_aa_neighborhood_distances.h"
#include "score/bcl_score_aa_neighborhood_exposure.h"
#include "score/bcl_score_aa_pair_clash.h"
#include "score/bcl_score_aa_pair_distance.h"
#include "util/bcl_util_wrapper.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! @brief names of allowed scores
    const std::string AnalyzeProteinEnsembleAANeighborhood::s_ScoreNames[ AnalyzeProteinEnsembleAANeighborhood::s_NumberScores] =
    {
      "neighbor_count", "neighbor_vector", "overlapping_spheres", "neighbor_distances", "neighbor_clash"
    };

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> AnalyzeProteinEnsembleAANeighborhood::s_Instance
    (
      util::Enumerated< AnalyzeProteinEnsembleInterface>::AddInstance( new AnalyzeProteinEnsembleAANeighborhood())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    AnalyzeProteinEnsembleAANeighborhood::AnalyzeProteinEnsembleAANeighborhood() :
      m_OutFilePostFix( ".score.pml")
    {
    }

    //! @brief Clone function
    //! @return pointer to new AnalyzeProteinEnsembleAANeighborhood
    AnalyzeProteinEnsembleAANeighborhood *AnalyzeProteinEnsembleAANeighborhood::Clone() const
    {
      return new AnalyzeProteinEnsembleAANeighborhood( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &AnalyzeProteinEnsembleAANeighborhood::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gives the string to append to the the end of a filename to identify this analysis
    //! @return gives the string to append to the the end of a filename to identify this analysis
    const std::string &AnalyzeProteinEnsembleAANeighborhood::GetOutFilePostfix() const
    {
      return m_OutFilePostFix;
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &AnalyzeProteinEnsembleAANeighborhood::GetAlias() const
    {
      static const std::string s_name( "ProteinEnsembleAANeighborhood");
      return s_name;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief takes an ensemble and does an analysis resulting in string containing formatted information
    //! @param ENSEMBLE the ensemble that will be analyzed
    //! @return string which has the analyzed information about the ensemble
    std::string AnalyzeProteinEnsembleAANeighborhood::operator()( const ProteinEnsemble &ENSEMBLE) const
    {
      std::stringstream script;

      const util::Format model_number_format( util::Format().W( size_t( std::ceil( std::log10( ENSEMBLE.GetSize())))).R().Fill( '0'));
      size_t count( 0);

      std::string first_model_name;

      // iterate over all proteins in the ensemble
      for( ProteinEnsemble::const_iterator ens_itr( ENSEMBLE.Begin()), ens_itr_end( ENSEMBLE.End()); ens_itr != ens_itr_end; ++ens_itr, ++count)
      {
        std::string pymol_model_name( "model" + model_number_format( count));
        // reference on protein model
        const ProteinModel &model( **ens_itr);

        // check for model id
        const util::ShPtr< util::Wrapper< std::string> > sp_id( model.GetProteinModelData()->GetData( ProteinModelData::e_Identification));
        if( sp_id.IsDefined())
        {
          pymol_model_name = *sp_id + model_number_format( count);
        }

        // check if protein model has a membrane
        const util::SiPtr< const biol::Membrane> sp_membrane( model.GetProteinModelData()->GetData( ProteinModelData::e_Membrane));

        // get the filename
        const std::string filename( *util::ShPtr< util::Wrapper< std::string> >( model.GetProteinModelData()->GetData( ProteinModelData::e_PDBFile)));

        // add load to the pymol script
        script << "#color protein model "     << pymol_model_name << '\n';
        script << "load " << filename << ", " << pymol_model_name << '\n';
        script << "hide everything, "         << pymol_model_name << '\n';
        script << "show cartoon, "            << pymol_model_name << "\n\n";

        // create a neighbor list container for the ProteinModel
        const AANeighborListContainer neighbor_list_container( model.GetAminoAcids(), m_Score->GetDistanceCutoff(), m_Score->GetMinimalSequenceSeparation(), true);

        // storage map for amino acids and their score
        storage::Map< util::SiPtr< const biol::AABase>, double> aa_scores;

        // store range of scores
        math::RunningMinMax< double> score_min_max;

        // iterate over all amino neighbor list
        for
        (
          AANeighborListContainer::const_iterator
            aa_neigh_itr( neighbor_list_container.Begin()), aa_neigh_itr_end( neighbor_list_container.End());
          aa_neigh_itr != aa_neigh_itr_end;
          ++aa_neigh_itr
        )
        {
          // score this amino acids neighborlist
          const double score( m_Score->operator ()( aa_neigh_itr->second, sp_membrane));

          if( !util::IsDefined( score))
          {
            continue;
          }

          // consider the score
          aa_scores[ aa_neigh_itr->second.GetCenterAminoAcid()] = score;
          score_min_max += score;
        }

        // range to use
        const math::Range< double> range
        (
          m_ScoreRange.IsEmpty()
          ? math::Range< double>( score_min_max.GetMin(), score_min_max.GetMax())
          : m_ScoreRange
        );

        // set all b factors to half of the score range
        script << "alter " << pymol_model_name << ", b=0.0" << "\n\n";

        // iterate over all scores
        for
        (
          storage::Map< util::SiPtr< const biol::AABase>, double>::const_iterator
            itr( aa_scores.Begin()), itr_end( aa_scores.End());
          itr != itr_end;
          ++itr
        )
        {
          script << "alter " << pymol_model_name
                 << " and chain " << itr->first->GetChainID() << " and resi " << itr->first->GetPdbID()
                 << ", b=" << itr->second << '\n';
        }

        // create a color spectrum over the model
        script << "spectrum b, blue_white_red, " << pymol_model_name << ", " << range.GetMin() << ", " << range.GetMax() << '\n';

        // now color the map based on the underlying protein
        const std::string ramp_name( m_Score->GetScheme() + model_number_format( count));
        script << "ramp_new " << ramp_name << ", " << pymol_model_name << ", [" << range.GetMin() << "," << range.GetMiddle() << "," << range.GetMax() << "], [blue,white,red]\n\n";

        // create a selection of all positively and negatively scoring residues
        const std::string select_p_name( "positive" + model_number_format( count));
        const std::string select_n_name( "negative" + model_number_format( count));
        script << "select " << select_p_name << ", " << pymol_model_name << " and not name c+n+o and b >  0.0001\n";
        script << "select " << select_n_name << ", " << pymol_model_name << " and not name c+n+o and b < -0.0001\n\n";
        script << "group sidechains" << model_number_format( count) << ", " << select_p_name << ' ' << select_n_name << '\n';

        if( count == 0)
        {
          first_model_name = pymol_model_name;
        }
        else
        {
          script << "#disable all for any model except the first\n";
          script << "disable " << pymol_model_name << '\n';
          script << "disable " << ramp_name        << '\n';
          script << "disable sidechains" << model_number_format( count) << '\n';
        }

        script << "\n#end " << pymol_model_name << "\n\n";
      }
      script << "zoom " << first_model_name << '\n';

      // end
      return script.str();
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &AnalyzeProteinEnsembleAANeighborhood::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &AnalyzeProteinEnsembleAANeighborhood::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return a score from the score name
    //! @param SCORE_NAME
    //! @return ShPtr to exposure score
    util::ShPtr< score::AANeighborhoodInterface> AnalyzeProteinEnsembleAANeighborhood::ScoreFromScoreName( const std::string &SCORE_NAME)
    {
      if( SCORE_NAME == s_ScoreNames[ 0])
      {
        return util::CloneToShPtr( score::AANeighborhoodExposure( AANeighborCount()));
      }

      if( SCORE_NAME == s_ScoreNames[ 1])
      {
        return util::CloneToShPtr( score::AANeighborhoodExposure( AANeighborVector()));
      }

      if( SCORE_NAME == s_ScoreNames[ 2])
      {
        return util::CloneToShPtr( score::AANeighborhoodExposure( AASasaOLS()));
      }

      if( SCORE_NAME == s_ScoreNames[ 3])
      {
        return util::CloneToShPtr( score::AANeighborhoodDistances( score::AAPairDistance()));
      }

      if( SCORE_NAME == s_ScoreNames[ 4])
      {
        return util::CloneToShPtr( score::AANeighborhoodDistances( score::AAPairClash()));
      }

      // end
      return util::ShPtr< score::AANeighborhoodInterface>();
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer AnalyzeProteinEnsembleAANeighborhood::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription
      (
        ""
      );

      parameters.AddInitializer
      (
        "filename_postfix",
        "the postfix that will be appended to the output file in order to identify this analysis",
        io::Serialization::GetAgent( &m_OutFilePostFix),
        ".score.pml"
      );

      parameters.AddInitializer
      (
        "score",
        "name of the score to be used",
        io::Serialization::GetAgentWithCheck
        (
          &m_ScoreName,
          command::ParameterCheckAllowed( storage::Vector< std::string>( s_NumberScores, s_ScoreNames))
        ),
        s_ScoreNames[ 0]
      );

      parameters.AddInitializer
      (
        "range",
        "the range of over which the residues are colored, if not given, the determined dynamic range over the protein model is used"
        " (must be quoted if range string contains () or ,)",
        io::Serialization::GetAgent( &m_ScoreRange),
        "\"(0.0,0.0)\""
      );

      return parameters;
    }

    //! @brief Set the members of this object from the given LABEL
    //! @param LABEL the label containing members that should be read of this class
    //! @param ERROR_STREAM stream with which to write errors
    bool AnalyzeProteinEnsembleAANeighborhood::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
    {
      m_Score = ScoreFromScoreName( m_ScoreName);
      return true;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_analyze_protein_ensemble_interface.h"

// includes from bcl - sorted alphabetically
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "io/bcl_io_file.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! @brief return command line flag for specifying the prefix prepended to each analysis' postfix
    //! @return command line flag for specifying the prefix prepended to each analysis' postfix
    const util::ShPtr< command::FlagInterface> &AnalyzeProteinEnsembleInterface::GetFlagOutFilePrefix()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "analysis_prefix", "\tthe prefix prepended to each analysis' postfix",
          command::Parameter( "prefix", "\tthe prefix prepended to each analysis' postfix")
        )
      );
      // end
      return s_flag;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

  /////////////////
  // data access //
  /////////////////

  ////////////////
  // operations //
  ////////////////

    //! @brief function to create the file that contains the analysis information
    //! @param OUT_FILE_PREFIX the string that will be prepended to the postfix to create the full filename
    //! @param ENSEMBLE the ensemble that will be analyzed
    void AnalyzeProteinEnsembleInterface::WriteAnalysisFile
    (
      const std::string &OUT_FILE_PREFIX, const ProteinEnsemble &ENSEMBLE
    ) const
    {
      // get the output file name
      const std::string out_filename( OUT_FILE_PREFIX + GetOutFilePostfix());

      // for writing the file
      io::OFStream write;

      // open the stream to the file
      io::File::MustOpenOFStream( write, out_filename);

      // write the analysis from the operator
      write << operator()( ENSEMBLE);

      // close the filestream
      io::File::CloseClearFStream( write);
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_biomolecule.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_protein_model_multiplier.h"
#include "math/bcl_math_mutate_result.h"
#include "storage/bcl_storage_triplet.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> Biomolecule::s_Instance
    (
      GetObjectInstances().AddInstance( new Biomolecule())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    Biomolecule::Biomolecule() :
      m_Threshold( util::GetUndefined< double>())
    {
    }

    //! @brief constructor from required members
    //! @param ATOM_TYPES atoms types to use for superimposition
    //! @param SUPERIMPOSE the superimposition measure to use
    //! @param THRESHOLD the threshold for which two chains are considered the same
    Biomolecule::Biomolecule
    (
      const storage::Set< biol::AtomType> &ATOM_TYPES,
      const util::ShPtr< quality::SuperimposeInterface> &SUPERIMPOSE,
      const double THRESHOLD
    ) :
      m_AtomTypes( ATOM_TYPES),
      m_Superimpose( SUPERIMPOSE),
      m_Threshold( THRESHOLD)
    {
    }

    //! @brief Clone function
    //! @return pointer to new Biomolecule
    Biomolecule *Biomolecule::Clone() const
    {
      return new Biomolecule( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &Biomolecule::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &Biomolecule::GetScheme() const
    {
      static const std::string s_scheme( "biomolecule");
      return s_scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator taking a PROTEIN_MODEL and returning a protein model with a protein model multiplier in the
    //! data, that defines a symmetric subunits
    //! @param PROTEIN_MODEL model with multiple chains
    //! @return MutateResult that results from finding the bio molecules
    math::MutateResult< ProteinModel> Biomolecule::operator()( const ProteinModel &PROTEIN_MODEL) const
    {
      util::ShPtr< ProteinModel> sp_new_model( new ProteinModel());
      util::ShPtr< ProteinModelData> sp_new_model_data( PROTEIN_MODEL.GetProteinModelData().HardCopy());

      // check if there is a multiplier present in the argument
      util::ShPtr< ProteinModelMultiplier> sp_multiplier( sp_new_model_data->GetData( ProteinModelData::e_Multiplier));
      if( sp_multiplier.IsDefined())
      {
        BCL_MessageCrt( "creating biomolecules from protein models with multiplie not implemented yet");
        return math::MutateResult< ProteinModel>( util::ShPtr< ProteinModel>(), *this);
      }
      storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> > chain_transformations;

      storage::Set< char> inserted_chains;
      // iterate through chains of argument
      for
      (
        ProteinModel::const_iterator
          chain_itr_template( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr_template != chain_itr_end;
        ++chain_itr_template
      )
      {
        const char template_chain_id( ( *chain_itr_template)->GetChainID());
        if( inserted_chains.Contains( template_chain_id))
        {
          continue;
        }
        sp_new_model->Insert( *chain_itr_template);
        inserted_chains.Insert( template_chain_id);

        // insert identity transformation for template chain
        chain_transformations.PushBack
        (
          storage::Triplet< char, char, math::TransformationMatrix3D>
          (
            template_chain_id, template_chain_id, math::TransformationMatrix3D()
          )
        );

        const std::string template_sequence_string( ( *chain_itr_template)->GetSequence()->Sequence());
        const util::SiPtrVector< const linal::Vector3D> template_coords( ( *chain_itr_template)->GetAtomCoordinates( m_AtomTypes));

        // iterate through other chains to search for identical sequences that can be superimposed
        for
        (
          ProteinModel::const_iterator chain_itr( chain_itr_template + 1);
          chain_itr != chain_itr_end;
          ++chain_itr
        )
        {
          const std::string current_sequence_string( ( *chain_itr)->GetSequence()->Sequence());

          // skip chains of different sequence
          if( template_sequence_string != current_sequence_string)
          {
            BCL_MessageDbg( "found non-identical sequences:\n" + template_sequence_string + '\n' + current_sequence_string);
            continue;
          }

          const util::SiPtrVector< const linal::Vector3D> current_coords( ( *chain_itr)->GetAtomCoordinates( m_AtomTypes));

          // superimpose coordinates
          const double measure( m_Superimpose->CalculateMeasure( current_coords, template_coords));

          // is this superimposition within the threshold
          if( !m_Superimpose->GetComparisonFunction()( measure, m_Threshold))
          {
            continue;
          }
          const char current_chain_id( ( *chain_itr)->GetChainID());
          BCL_MessageDbg
          (
            "found superimposable chain pair: " + std::string( 1, template_chain_id)
            + '\n' + std::string( 1, current_chain_id)
          );

          // calculate the matrix
          const math::TransformationMatrix3D transformation( m_Superimpose->CalculateSuperimposition( current_coords, template_coords));
          chain_transformations.PushBack
          (
            storage::Triplet< char, char, math::TransformationMatrix3D>
            (
              template_chain_id, current_chain_id, transformation
            )
          );
          inserted_chains.Insert( current_chain_id);
        }
      }

      sp_multiplier = util::ShPtr< ProteinModelMultiplier>( new ProteinModelMultiplier( chain_transformations, *sp_new_model));
      sp_new_model_data->Insert( ProteinModelData::e_Multiplier, sp_multiplier);
      sp_new_model->SetProteinModelData( sp_new_model_data);

      return math::MutateResult< ProteinModel>( sp_new_model, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &Biomolecule::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_AtomTypes  , ISTREAM);
      io::Serialize::Read( m_Superimpose, ISTREAM);
      io::Serialize::Read( m_Threshold  , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &Biomolecule::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_AtomTypes  , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Superimpose, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Threshold  , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_chain.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_factory_conformation.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "fold/bcl_fold_mutate_domain_merge_consecutive_ss_types.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> Chain::s_Instance
    (
      GetObjectInstances().AddInstance( new Chain())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    Chain::Chain() :
      m_Sequence(),
      m_Data()
    {
    }

    //! @brief construct from util::ShPtr to SEQUENCE and ShPtrVector of SSEs
    //! @param SP_SEQUENCE util::ShPtr to sequence
    //! @param SSE_VECTOR ShPtrVector of SSEs
    Chain::Chain( const util::ShPtr< biol::AASequence> &SP_SEQUENCE, const util::ShPtrVector< SSE> &SSE_VECTOR) :
      m_Sequence( SP_SEQUENCE),
      m_Data()
    {
      Insert( SSE_VECTOR);
    }

    //! @brief  construct from util::ShPtr to SEQUENCE and DOMAIN
    //! @param SP_SEQUENCE util::ShPtr to sequence
    //! @param SOURCE_DOMAIN Domain which contains SSEs
    Chain::Chain( const util::ShPtr< biol::AASequence> &SP_SEQUENCE, const Domain &SOURCE_DOMAIN) :
      m_Sequence( SP_SEQUENCE),
      m_Data()
    {
      // insert the SSEs
      Insert( SOURCE_DOMAIN);
    }

    //! @brief construct from util::ShPtr to SEQUENCE with no SSE information
    //! @param SP_SEQUENCE util::ShPtr to sequence
    Chain::Chain( const util::ShPtr< biol::AASequence> &SP_SEQUENCE) :
      m_Sequence( SP_SEQUENCE),
      m_Data()
    {
    }

    //! @brief copy constructor
    //! @param CHAIN_RHS Chain to be copied
    Chain::Chain( const Chain &CHAIN_RHS) :
      m_Sequence( CHAIN_RHS.m_Sequence),
      m_Data( CHAIN_RHS.m_Data)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new copy of this Chain
    Chain *Chain::Clone() const
    {
      return new Chain( *this);
    }

    //! @brief hardcopy
    Chain *Chain::HardCopy() const
    {
      // make a new chain with just the sequence
      Chain *hard_copy( new Chain( m_Sequence.HardCopy()));

      // iterate over all sses
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // insert a hardcopy of the shared pointer to sse into the new domain
        hard_copy->Insert( sse_itr->HardCopy());
      }

      // end
      return hard_copy;
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @brief the class name as const ref std::string
    const std::string &Chain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the identification of the sequence and sses
    //! @return the identification of the sequence and sses
    std::string Chain::GetIdentification() const
    {
      // initialize string to be sequence identification
      std::string identification( m_Sequence->GetSequenceIdentification() + "\n");

      // iterate through the sses
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // add the sse identification to the string
        identification += "\t" + ( *sse_itr)->GetIdentification() + "\n";
      }

      // end
      return identification;
    }

    //! @brief set chainID to CHAINID
    //! @param CHAINID chainID to be set to
    void Chain::SetChainID( const char CHAINID)
    {
      // set chain id for the sequence after hardcopying the AAData
      m_Sequence = util::ShPtr< biol::AASequence>( m_Sequence->HardCopy());
      m_Sequence->SetChainID( CHAINID);

      // initialize set of SSEs
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> new_sses;

      // iterate through the SSE data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator sse_itr;
      while( ( sse_itr = m_Data.Begin()) != m_Data.End())
      {
        // hardcopy the SSE
        util::ShPtr< SSE> current_sse( ( *sse_itr)->HardCopy());

        // remove it from the data
        m_Data.RemoveElement( sse_itr);

        // set the chain id on the hardcopy and insert it into the set
        current_sse->SetChainID( CHAINID);
        new_sses.Insert( current_sse);
      }

      // update the SSE data with the new SSEs
      m_Data = new_sses;
    }

    //! @brief get SiPtrVector of SSEs
    //! @return SiPtrVector of SSEs
    util::SiPtrVector< const SSE> Chain::GetSSEs() const
    {
      // construct a SiPtrVector of const SSEs and return it
      return util::SiPtrVector< const SSE>( m_Data.Begin(), m_Data.End());
    }

    //! @brief returns all SSEs in domain of given SSTYPE in a util::SiPtrVector
    //! @param SS_TYPE specific SSTYPE
    //! @return all SSEs in domain of given SSTYPE in a util::SiPtrVector
    util::SiPtrVector< const SSE> Chain::GetSSEs( const biol::SSType &SS_TYPE) const
    {
      // initialize vector of sses
      util::SiPtrVector< const SSE> sses;

      //loop over all SSElements
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if SSE behind sse_itr is of given SSTYPE
        if( ( *sse_itr)->GetType() == SS_TYPE)
        {
          // insert it into the list of SSEs to be returned
          sses.PushBack( util::SiPtr< const SSE>( *sse_itr));
        }
      }

      return sses;
    }

    //! @brief returns SiPtrVector of all SSEs of given SS_TYPES in the set
    //! @param SS_TYPES set of SSTypes of interest
    //! @brief returns SiPtrVector of all SSEs of given SS_TYPES in the set
    util::SiPtrVector< const SSE> Chain::GetSSEs( const storage::Set< biol::SSType> &SS_TYPES) const
    {
      // initialize vector of sses
      util::SiPtrVector< const SSE> sses;

      //loop over all SSElements
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if SSE behind sse_itr is of any given SSTYPES
        if( SS_TYPES.Find( ( *sse_itr)->GetType()) != SS_TYPES.End())
        {
          // insert it into the list of SSEs to be returned
          sses.PushBack( util::SiPtr< const SSE>( *sse_itr));
        }
      }

      return sses;
    }

    //! @brief find and to return the ShPtr for the given SSE
    //! @param SSE_TO_SEARCH SSE of interest
    //! @return ShPtr to corresponding SSE, otherwise an empty ShPtr
    const util::ShPtr< SSE> &Chain::FindSSE( const SSE &SSE_TO_SEARCH) const
    {
      // static undefined SSE ptr
      static const util::ShPtr< SSE> s_undefined_sse_ptr;

      // search for this sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompare( SSE_TO_SEARCH)
        )
      );

      // if such an sse is found
      if( itr != m_Data.End())
      {
        // return the ShPtr
        return *itr;
      }

      // otherwise return empty ShPtr
      return s_undefined_sse_ptr;
    }

    //! @brief return number of SSE of specified SSTYPE
    //! @param SS_TYPE specific SSTYPE
    //! @return number of SSE of specified SSTYPE
    size_t Chain::GetNumberSSE( const biol::SSType &SS_TYPE) const
    {
      // initialize count
      size_t number_sses( 0);

      //loop over all SSElements
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if of correct type increment
        number_sses += ( ( *sse_itr)->GetType() == SS_TYPE);
      }

      // end
      return number_sses;
    }

    //! @brief returns the geometric center of the object
    //! @return the geometric center of the object
    linal::Vector3D Chain::GetCenter() const
    {
      return coord::CenterOfMass( GetAtomCoordinates());
    }

    //! @brief returns the number of amino acids in the chain
    //! @return the number of amino acids in the chain
    size_t Chain::GetNumberAAs() const
    {
      // initialize size of chain
      size_t size( 0);

      // iterate over SSEs and get their size
      for
      (
         auto sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
         sse_itr != sse_itr_end;
         ++sse_itr
      )
      {
        size += ( *sse_itr)->GetData().GetSize();
      }

      return ( size);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief translates the coordinates of all SSEs by the supplied translation vector
    //! @param TRANSLATION_VECTOR_3D Translation vector to be applied
    void Chain::Translate( const linal::Vector3D &TRANSLATION_VECTOR_3D)
    {
      //loop over all secondary structure elements and transform them
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make a copy of the ShPtr
        util::ShPtr< SSE> this_sse( *sse_itr);

        // translate this_sse
        this_sse->Translate( TRANSLATION_VECTOR_3D);
      }
    }

    //! @brief transforms the coordinates of all SSEs according to given transformation matrix
    //! @param TRANSFORMATION_MATRIX_3D transformation matrix to be applied
    void Chain::Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
    {
      //loop over all secondary structure elements and transform them
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make a copy of the ShPtr
        util::ShPtr< SSE> this_sse( *sse_itr);

        // transform this_sse
        this_sse->Transform( TRANSFORMATION_MATRIX_3D);
      }
    }

    //! @brief rotate the SSE by a given rotation matrix
    //! @param ROTATION_MATRIX_3D rotation matrix to be applied
    void Chain::Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
    {
      //loop over all secondary structure elements and transform them
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make a copy of the ShPtr
        util::ShPtr< SSE> this_sse( *sse_itr);

        // transform this_sse
        this_sse->Rotate( ROTATION_MATRIX_3D);
      }
    }

    //! @brief insert the given NEW_SSE into this chain
    //! @param NEW_SSE SSE to be inserted
    //! @return whether insertion was successful
    bool Chain::Insert( const util::ShPtr< SSE> &NEW_SSE)
    {
      //check that chain ID of SSE fits this chain
      if( NEW_SSE->GetChainID() != m_Sequence->GetChainID())
      {
        BCL_MessageCrt
        (
          std::string( "impossible to insert SSE of different chain: this: ") + m_Sequence->GetChainID() +
          " != SSE: " + NEW_SSE->GetChainID()
        );
        return false;
      }

      // call insert function of the set, it will take care if there are overlap and return false
      return m_Data.Insert( NEW_SSE).second;
    }

    //! @brief insert the SSEs in the given NEW_SSE_VECTOR into this chain
    //! @param NEW_SSE_VECTOR Vector of SSEs to be inserted
    //! @return whether insertion was successful
    bool Chain::Insert( const util::ShPtrVector< SSE> &NEW_SSE_VECTOR)
    {
      // initialize status
      bool success( true);

      // iterate over the given SSEs
      for
      (
        util::ShPtrVector< SSE>::const_iterator sse_itr( NEW_SSE_VECTOR.Begin()), sse_itr_end( NEW_SSE_VECTOR.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        success &= Insert( *sse_itr);
      }

      // end
      return success;
    }

    //! @brief insert the SSEs from the given domain
    //! @param NEW_DOMAIN Domain from which SSEs should be inserted
    //! @return whether insertion was successful
    bool Chain::Insert( const Domain &NEW_DOMAIN)
    {
      // initialize status
      bool success( true);

      // iterate over the given SSEs
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          sse_itr( NEW_DOMAIN.GetData().Begin()), sse_itr_end( NEW_DOMAIN.GetData().End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        success &= Insert( *sse_itr);
      }

      // end
      return success;
    }

    //! @brief replace the given SP_SSE with already existing one
    //! @param SP_SSE ShPtr pointing to the SSE to be replaced
    bool Chain::Replace( const util::ShPtr< SSE> &SP_SSE)
    {
      // search for this sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompare( *SP_SSE)
        )
      );

      // if such an sse is found
      if( itr != m_Data.End())
      {
        // remove this sse
        m_Data.RemoveElement( itr);

        // insert the new sse
        m_Data.Insert( SP_SSE);

        // return
        return true;
      }

      // if not found do nothing and return false
      return false;
    }

    //! @brief replace all SSEs that overlap with SP_SSE with SP_SSE
    //! @param SP_SSE ShPtr to SSE to be inserted
    //! @return whether replacement succeeded
    bool Chain::ReplaceWithOverlapping( const util::ShPtr< SSE> &SP_SSE)
    {
      // search for overlapping sses with SP_SSE using equal_range
      std::pair
      <
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator,
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator
      > itr_pair
      (
        std::equal_range
        (
          m_Data.Begin(),
          m_Data.End(),
          SP_SSE,
          SSELessThanNoOverlap()
        )
      );

      // if such an sse is found
      if( itr_pair.first != m_Data.End())
      {
        // remove the sses in the range
        m_Data.Erase( itr_pair.first, itr_pair.second);

        // insert the new sse
        m_Data.Insert( SP_SSE);

        // return
        return true;
      }

      BCL_MessageCrt
      (
        "ReplaceWithOverlapping has been called with a SSE that is not overlapping!"
      );

      // if not found do nothing and return false
      return false;
    }

    //! @brief remove given SSELEMENT from the domain
    //! @param SSELEMENT SSE to be removed
    bool Chain::Remove( const SSE &SSELEMENT)
    {
      // search for this sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompare( SSELEMENT)
        )
      );

      // if such an sse is found
      if( itr != m_Data.End())
      {
        // remove this sse
        m_Data.RemoveElement( itr);

        // return
        return true;
      }

      // if not found do nothing and return false
      return false;
    }

    //! @brief sets positions of all SSEs to ideal conformation w/wo superimposing with prior coordinates
    //! @param KEEP_POSITION flag to indicate whether to original body information of SSEs should be reserved
    void Chain::SetToIdealConformation( const bool KEEP_POSITION)
    {
      //set each sse to ideal conformation
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make a non-const ShPtr to this SSE since Set does not allow non-const iterators
        util::ShPtr< SSE> this_sse( *sse_itr);

        if( KEEP_POSITION)
        {
          this_sse->SetToIdealConformationInPlace();
        }
        else
        {
          this_sse->SetToIdealConformationAtOrigin();
        }
      }
    }

    //! @brief chop all SSEs of that model in pieces of the sizes defined by MIN_SSE_LENGTHS
    //! @param MIN_SSE_LENGTHS VectorND of sizes that defined min size for each SSType
    void Chain::ChopSSEs( const storage::VectorND< 3, size_t> &MIN_SSE_LENGTHS)
    {
      // instatiate set of chopped_sse
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> chopped_sses;

      //iterate over all sselements
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // chop this sse and insert into new set of sses
        chopped_sses.InsertElements( ( *sse_itr)->Chop( MIN_SSE_LENGTHS( ( *sse_itr)->GetType())));
      }

      //set m_Model to new chopped elements
      m_Data = chopped_sses;
    }

    //! @brief checks if domain already contains THIS_SSE
    //! @param THIS_SSE SSE of interest
    //! @return whether domain already contains THIS_SSE
    bool Chain::DoesContain( const SSE &THIS_SSE) const
    {
      // search for this sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompare( THIS_SSE)
        )
      );

      // return if it's found
      return ( itr != m_Data.End());
    }

    //! @brief checks if domain already contains this THIS_SSE or any overlapping SSE with THIS_SSE
    //! @param THIS_SSE SSE to be searched for
    //! @return if domain already contains this THIS_SSE or any overlapping SSE with THIS_SSE
    bool Chain::DoesContainOverlapping( const SSE &THIS_SSE) const
    {
      // search for this sse or any overlapping sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompareOverlap( THIS_SSE)
        )
      );

      // return if it's found
      return ( itr != m_Data.End());
    }

    //! @brief join following ( progressing sequence id) SSEs of given SS_TYPE into one SSE
    //! @param SS_TYPE SSType of interest
    //! @param TEST_PEPTIDE_BOND join only, if SSEs are connected by peptide bond
    void Chain::Join( const biol::SSType &SS_TYPE, const bool TEST_PEPTIDE_BOND)
    {
      if( GetNumberSSE( SS_TYPE) < 2)
      {
        return;
      }

      // new SSEs after joining
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> joined_sses;

      //set each SSE to ideal conformation
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator
      sse_itr( m_Data.Begin()), sse_itr_next( m_Data.Begin()), sse_itr_end( m_Data.End());
      ++sse_itr_next;

      // store the current SSE
      util::ShPtr< SSE> current_sse( ( *sse_itr));

      // initialize a boolean
      bool last_sse_joinable( false);

      // iterate until anyone of the iterators hit the end
      while( sse_itr_next != sse_itr_end && sse_itr != sse_itr_end)
      {
        // if this SSE is of specified type as well as the next SSE and they have no loop residues in between
        if
        (
              current_sse->GetType() == SS_TYPE
           && current_sse->GetType() == ( *sse_itr_next)->GetType()
           && ( current_sse->GetLastAA()->GetSeqID() + 1) == ( *sse_itr_next)->GetFirstAA()->GetSeqID()
           && ( !TEST_PEPTIDE_BOND || biol::AABase::AreAminoAcidsPeptideBonded( *current_sse->GetLastAA(), *( *sse_itr_next)->GetFirstAA(), true))
        )
        {
          // update the sequence of the current SSE by appending the sequence of the next SSE that is connected
          current_sse->AppendSequence( ( **sse_itr_next), false);

          // set the flag
          last_sse_joinable = true;

          // move to next SSE
          ++sse_itr_next;
        }
        // if next SSE is not connected
        else
        {
          // but the previous pair of SSEs were connected
          if( last_sse_joinable)
          {
            // update the geometry
            current_sse->SetGeometry();
            // set the flag back
            last_sse_joinable = false;
          }

          // insert the SSE joined or not into the new list of SSEs
          joined_sses.Insert( current_sse);

          // update the iterators
          current_sse = *sse_itr_next;
          sse_itr = sse_itr_next;
          ++sse_itr_next;
        }
      }

      // if the last SSE was connected
      if( last_sse_joinable)
      {
        // update geometry
        current_sse->SetGeometry();
      }
      // insert the last SSE into new list of SSEs
      joined_sses.Insert( current_sse);

      // update the data
      m_Data = joined_sses;
    }

    //! @brief filters the current chain by given minimum SSE sizes
    //! @param MIN_SSE_SIZES minimum SSE sizes to filter the chain by
    void Chain::FilterByMinSSESizes( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES)
    {
      // create a new set to store sses
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> filtered_sses;

      // iterate over the SSEs
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator
          sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        storage::Map< biol::SSType, size_t>::const_iterator
          type_itr( MIN_SSE_SIZES.Find( ( *sse_itr)->GetType()));

        // if this SSE is one of the specified types in the given map and
        // if this SSE has a size larger than/equal to the specified size
        if
        (
          type_itr != MIN_SSE_SIZES.End() && ( *sse_itr)->GetSize() >= type_itr->second
        )
        {
          // insert it into filtered SSEs
          filtered_sses.Insert( *sse_itr);
        }
      }

      // update the SSE set with the filtered one
      m_Data = filtered_sses;
    }

    //! @brief AddLoops generates loop SSEs for the Chain and assigns them undefined coordinates
    //! @param UNDEFINED_COORDINATES create loop with undefined coordinates, or with coordinates form the member sequence
    //! @param MERGE_CONSECUTIVE_SSES merge consecutive SSEs of given type
    //! @param SS_TYPE the sstype of the SSEs to be merged
    void Chain::AddLoops
    (
      const bool UNDEFINED_COORDINATES,
      const bool MERGE_CONSECUTIVE_SSES,
      const biol::SSType &SS_TYPE
    )
    {
      // create ShPtrVector iterator "seq_itr" and "seq_itr_end" for iterating over the aa sequence of this chain
      biol::AASequence::const_iterator seq_itr( m_Sequence->Begin()), seq_itr_end( m_Sequence->End());

      // check that there is a least one sse
      if( m_Data.IsEmpty())
      {
        // create ShPtr to SSE "new_sse"
        util::ShPtr< SSE> new_sse;

        if( !UNDEFINED_COORDINATES)
        {
          new_sse = util::ShPtr< SSE>( new SSE( *m_Sequence, biol::GetSSTypes().COIL));
        }
        else
        {
          // create ShPtr to SSE "new_sse" and initialize with a new SSE of type COIL
          new_sse = util::ShPtr< SSE>( new SSE( biol::GetSSTypes().COIL));

          // set the chain ID of "new_sse"
          new_sse->SetChainID( GetChainID());

          // set the fasta header of "new_sse"
          new_sse->SetFastaHeader( m_Sequence->GetFastaHeader());

          // copy all amino acids, without coordinates
          for( ; seq_itr != seq_itr_end; ++seq_itr)
          {
            new_sse->PushBack( util::ShPtr< biol::AABase>( ( *seq_itr)->Empty( ( *seq_itr)->GetData())));
          }
        }

        m_Data.Insert( new_sse);

        return;
      }

      // create Set of SSEs "new_sses" to hold the SSEs which are created
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> new_sses;

      // loop over all SSEs in this chain
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // create size_t "sse_begin_seq_id" initialize with the SeqID of the first aa in the SSE denoted by "sse_itr"
        const int sse_begin_seq_id( ( *sse_itr)->GetFirstAA()->GetSeqID());

        // create ShPtr to SSE "new_sse" and initialize with a new SSE of type COIL
        util::ShPtr< SSE> new_sse( new SSE( biol::GetSSTypes().COIL));

        // set the chain ID of "new_sse"
        new_sse->SetChainID( GetChainID());

        // set the fasta header of "new_sse"
        new_sse->SetFastaHeader( m_Sequence->GetFastaHeader());

        // while seq ID of aa denoted by "seq_itr" has not reached "sse_begin_seq_id" and the end of the aa sequence
        // has not been reached
        while( ( *seq_itr)->GetSeqID() != sse_begin_seq_id && seq_itr != seq_itr_end)
        {
          // create a new amino acid of the corresponding aa class (should set coordinates to undefined)
          util::ShPtr< biol::AABase> new_aa;

          if( UNDEFINED_COORDINATES)
          {
            new_aa = util::ShPtr< biol::AABase>( ( *seq_itr)->Empty( ( *seq_itr)->GetData()));
          }
          else
          {
            new_aa = util::ShPtr< biol::AABase>( ( *seq_itr)->Clone());
          }

          // add the new aa to "new_sse"
          new_sse->PushBack( new_aa);

          // move "seq_itr" to the next aa
          ++seq_itr;
        }

        // true if "new_sse" has some aas in it
        if( new_sse->GetSize())
        {
          // insert "new_sse" into "new_sses"
          new_sses.Insert( new_sse);
        }

        // move "seq_itr" to the place of the next non-sse region
        const size_t sse_size( ( *sse_itr)->GetSize());
        for( size_t sse_index( 0); sse_index != sse_size && seq_itr != seq_itr_end; ++sse_index)
        {
          ++seq_itr;
        }
      }

      // we have to make sure to add the loop after the last SSE
      const size_t last_sse_end_id( ( *m_Data.ReverseBegin())->GetLastAA()->GetSeqID());
      const size_t last_aa_id( m_Sequence->GetLastAA()->GetSeqID());

      // if there are any residues at the end of the sequence that are not in the last SSE
      if( last_sse_end_id < last_aa_id)
      {
        // create ShPtr to SSE "new_sse" and initialize with a new SSE of type COIL
        util::ShPtr< SSE> new_sse( new SSE( biol::GetSSTypes().COIL));

        // set the chain ID of "new_sse"
        new_sse->SetChainID( GetChainID());

        // set the fasta header of "new_sse"
        new_sse->SetFastaHeader( m_Sequence->GetFastaHeader());

        // iterate until you hit the end of amino acids in the sequecne
        while( seq_itr != seq_itr_end)
        {
          // create a new amino acid of the corresponding aa class (should set coordinates to 0.000)
          util::ShPtr< biol::AABase> new_aa;

          if( UNDEFINED_COORDINATES)
          {
            new_aa = util::ShPtr< biol::AABase>( ( *seq_itr)->Empty( ( *seq_itr)->GetData()));
          }
          else
          {
            new_aa = util::ShPtr< biol::AABase>( ( *seq_itr)->Clone());
          }

          // add the new aa to "new_sse"
          new_sse->PushBack( new_aa);

          // move "seq_itr" to the next aa
          ++seq_itr;
        }

        // push the last loop
        new_sses.Insert( new_sse);
      }

      // if consecutive SSEs are to be merged, do it with the mutate
      if( MERGE_CONSECUTIVE_SSES)
      {
        const fold::MutateDomainMergeConsecutiveSSTypes mutate( SS_TYPE);
        Domain new_domain( new_sses);

        new_sses = mutate( new_sses).GetArgument()->GetData();
      }

      // add all the new sses in "new_sses" to this chain
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          sse_itr( new_sses.Begin()), sse_itr_end( new_sses.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        Insert( *sse_itr);
      }
    }

    //! @brief let the aadata of the each sse point to the corresponding data in the chain - determined by pdbID
    void Chain::ConnectSSEToChainData()
    {
      // set which will hold new sses which have been connected to the data in the chain
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> new_sses;

      // iterate through the sses of this chain
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // get a sequence copied from the sse
        biol::AASequence sequence( **sse_itr);

        // connect the sequence from the sse to the data in the chain sequence
        m_Sequence->ConnectAADataByPdbID( sequence);

        // make a new sse out of the connected sequence and the type of sse that sse_itr is
        const util::ShPtr< SSE> new_sse( new SSE( sequence, ( *sse_itr)->GetType()));

        // add the new sse to the set of new sses - don't use replace here or segmentation fault results
        new_sses.Insert( new_sse);
      }

      // set the m_Data to the set of new sses
      m_Data = new_sses;
    }

    //! @brief Get SSE hash string to aid in identifying similar chains
    std::string Chain::GetSSEHashString() const
    {
      std::string hash;
      // iterate through the chains
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
      )
      {
        hash += ( *sse_itr)->GetHashString();
        if( ++sse_itr != sse_itr_end)
        {
          hash += ',';
        }
      }
      return hash;
    }

    //! @brief Replace SSEs with those drawn from the pool
    void Chain::AdoptSSEsMaintainCoordinates( const util::SiPtrVector< const SSE> &SSES)
    {
      m_Data.Reset();

      // create ShPtrVector iterator "seq_itr" and "seq_itr_end" for iterating over the aa sequence of this chain
      biol::AASequence::const_iterator seq_itr( m_Sequence->Begin()), seq_itr_end( m_Sequence->End());

      for( auto itr_sses( SSES.Begin()), itr_sses_end( SSES.End()); itr_sses != itr_sses_end; ++itr_sses)
      {
        const SSE &sse( **itr_sses);
        for( auto first_seq_id( sse.GetFirstMember()->GetSeqID()); ( *seq_itr)->GetSeqID() < first_seq_id; ++seq_itr)
        {
        }
        biol::AASequence sequence;
        for
        (
          auto last_seq_id( sse.GetLastMember()->GetSeqID());
          seq_itr != seq_itr_end && ( *seq_itr)->GetSeqID() <= last_seq_id;
          ++seq_itr
        )
        {
          sequence.PushBack( *seq_itr);
        }
        this->Insert( util::ShPtr< SSE>( new SSE( sequence, sse.GetType())));
      }
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief equal operator
    //! @param CHAIN_RHS Chain to be assigned
    //! @return this chain after being assigned to given CHAIN_RHS
    Chain &Chain::operator =( const Chain &CHAIN_RHS)
    {
      // set members
      m_Sequence = CHAIN_RHS.m_Sequence;
      m_Data = CHAIN_RHS.m_Data;

      // return
      return *this;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read Chain from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &Chain::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Sequence, ISTREAM);
      io::Serialize::Read( m_Data, ISTREAM);

      //end
      return ISTREAM;
      }

    //! @brief write Chain to std::ostream
    //! @param OSTREAM output stream
    //! @param INDENT indentation
    //! @return ostream which was written to
    std::ostream &Chain::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Sequence, OSTREAM, INDENT);
      io::Serialize::Write( m_Data, OSTREAM, INDENT);

      //end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief construct a chain from a sequence with SSEs
    //! the phi and psi angles of the backbone are calculated and depending on the position in the ramachandran plot,
    //! sses are constructed
    //! @author woetzen
    //! @param SP_SEQUENCE ShPtr to sequence- at least the backbone atoms, otherwise they will be indentified as loops
    //! @return Chain with given sequence and identified sses
    Chain ConstructChainWithSSEsFromConformation( const util::ShPtr< biol::AASequence> &SP_SEQUENCE)
    {
      // create an sse pool using SSEFactoryConformation
      const SSEPool sse_pool( SSEFactoryConformation()( *SP_SEQUENCE));

      // collection of identified sses
      const Domain identified_sses
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>( sse_pool.Begin(), sse_pool.End())
      );

      // construct chain from sequence and domain
      return Chain( SP_SEQUENCE, identified_sses);
    }

  ///////////////////
  // ChainLessThan //
  ///////////////////

    //! @brief return whether one chain  is less than another
    //! @param CHAIN_LHS first chain
    //! @param CHAIN_RHS second chain
    //! @return whether one chain is less than another
    bool ChainLessThan::operator()( const Chain &CHAIN_LHS, const Chain &CHAIN_RHS) const
    {
      // compare chain ids
      return CHAIN_LHS.GetChainID() < CHAIN_RHS.GetChainID();
    }

    //! @brief return whether one chain is less than another
    //! @param PTR_CHAIN_LHS first chain
    //! @param PTR_CHAIN_RHS second chain
    //! @return whether one chain is less than another
    bool ChainLessThan::operator()
    (
      const util::PtrInterface< Chain> &PTR_CHAIN_LHS,
      const util::PtrInterface< Chain> &PTR_CHAIN_RHS
    ) const
    {
      return operator ()( *PTR_CHAIN_LHS, *PTR_CHAIN_RHS);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_chain_multiplier.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_chain.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ChainMultiplier::s_Instance
    (
      GetObjectInstances().AddInstance( new ChainMultiplier())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ChainMultiplier::ChainMultiplier() :
      m_Transformer(),
      m_InitialChainID( 'A'),
      m_Transformation(),
      m_Sequence()
    {
    }

    //! @brief construct from an SSE transformer, chain ID, and sequence
    //! @param SSE_TRANSFORMER transformer to apply to each SSE
    //! @param INITIAL_CHAIN_ID initial chain id
    //! @param TRANSFORMATION transformation that is applied to each SSE
    //! @param SEQUENCE sequence used to generate new chain
    ChainMultiplier::ChainMultiplier
    (
      const util::ShPtr< util::FunctionInterface< SSE, util::ShPtr< SSE> > > &SSE_TRANSFORMER,
      const char INITIAL_CHAIN_ID,
      const util::ShPtr< math::TransformationMatrix3D> &TRANSFORMATION,
      const util::ShPtr< biol::AASequence> &SEQUENCE
    ) :
      m_Transformer( SSE_TRANSFORMER),
      m_InitialChainID( INITIAL_CHAIN_ID),
      m_Transformation( TRANSFORMATION),
      m_Sequence( SEQUENCE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new ChainMultiplier
    ChainMultiplier *ChainMultiplier::Clone() const
    {
      return new ChainMultiplier( *this);
    }

    //! @brief hardcopy this multiplier
    //! @return harcopied multiplier
    util::ShPtr< ChainMultiplier> ChainMultiplier::HardCopy() const
    {
      // set members
      util::ShPtr< ChainMultiplier> hard_copy( new ChainMultiplier());
      hard_copy->m_Transformer = m_Transformer.HardCopy();
      hard_copy->m_InitialChainID = m_InitialChainID;
      hard_copy->m_Transformation = m_Transformation.HardCopy();
      hard_copy->m_Sequence = util::ShPtr< biol::AASequence>( m_Sequence->HardCopy());

      // end
      return hard_copy;
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ChainMultiplier::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief returns chain after transforming all SSEs
    //! @param CHAIN chain to be replicated
    //! @return chain after transforming all SSEs
    util::ShPtr< Chain> ChainMultiplier::operator ()( const Chain &CHAIN) const
    {
      // create new chain with the new sequence
      util::ShPtr< Chain> new_chain( new Chain( m_Sequence));

      // iterate through the SSEs on the chain
      util::SiPtrVector< const SSE> sses( CHAIN.GetSSEs());
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sses.Begin()), sse_itr_end( sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // insert the transformed SSE into the chain
        new_chain->Insert( m_Transformer->operator ()( **sse_itr));
      }

      // end
      return new_chain;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ChainMultiplier::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Transformer, ISTREAM);
      io::Serialize::Read( m_InitialChainID, ISTREAM);
      io::Serialize::Read( m_Transformation, ISTREAM);
      io::Serialize::Read( m_Sequence, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ChainMultiplier::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Transformer, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_InitialChainID, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Transformation, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Sequence, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  /////////////////////////////
  // ChainMultiplierLessThan //
  /////////////////////////////

    //! @brief return whether one chain multiplier is less than another
    //! @param CHAIN_MULTIPLIER_LHS first chain multiplier
    //! @param CHAIN_MULTIPLIER_RHS second chain multiplier
    //! @return whether one chain multiplier is less than another
    bool ChainMultiplierLessThan::operator()
    (
      const ChainMultiplier &CHAIN_MULTIPLIER_LHS,
      const ChainMultiplier &CHAIN_MULTIPLIER_RHS
    ) const
    {
      // check if initial chain id of LHS is less than chain id of RHS
      if( CHAIN_MULTIPLIER_LHS.GetInitialChainID() < CHAIN_MULTIPLIER_RHS.GetInitialChainID())
      {
        return true;
      }

      // check if initial chain id of LHS is equal to chain id of RHS and new chain id of LHS is less than chain id
      // of RHS
      if
      (
        CHAIN_MULTIPLIER_LHS.GetInitialChainID() == CHAIN_MULTIPLIER_RHS.GetInitialChainID() &&
        CHAIN_MULTIPLIER_LHS.GetNewChainID() < CHAIN_MULTIPLIER_RHS.GetNewChainID()
      )
      {
        return true;
      }

      // else
      return false;
    }

    //! @brief return whether one chain multiplier is less than another
    //! @param PTR_CHAIN_MULTIPLIER_LHS first chain multiplier
    //! @param PTR_CHAIN_MULTIPLIER_RHS second chain multiplier
    //! @return whether one chain multiplier is less than another
    bool ChainMultiplierLessThan::operator()
    (
      const util::PtrInterface< ChainMultiplier> &PTR_CHAIN_MULTIPLIER_LHS,
      const util::PtrInterface< ChainMultiplier> &PTR_CHAIN_MULTIPLIER_RHS
    ) const
    {
      return operator ()( *PTR_CHAIN_MULTIPLIER_LHS, *PTR_CHAIN_MULTIPLIER_RHS);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_aa_specified.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_aa.h"
#include "biol/bcl_biol_aa_base.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_si_ptr_list.h"
#include "util/bcl_util_string_functions.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorAASpecified::s_Instance
    (
      GetObjectInstances().AddInstance( new CollectorAASpecified())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorAASpecified::CollectorAASpecified() :
      m_ResidueList()
    {
    }

    //! @brief construct from a filename which contains the list of residues to collect
    //! @param RESI_LIST_FILENAME the file which contains the list of residues
    CollectorAASpecified::CollectorAASpecified( const std::string &RESI_LIST_FILENAME) :
      m_ResidueList( ReadAALocators( RESI_LIST_FILENAME))
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorAASpecified
    CollectorAASpecified *CollectorAASpecified::Clone() const
    {
      return new CollectorAASpecified( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorAASpecified::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetResidueList gives the list of residue locators
    //! @return m_ResidueList which is the list of amino acid locators
    const storage::List< LocatorAA> &CollectorAASpecified::GetResidueList() const
    {
      return m_ResidueList;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &CollectorAASpecified::GetAlias() const
    {
      static const std::string s_name( "CollectorAASpecified");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorAASpecified::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects residues specified by sequence and chain id.");
      serializer.AddInitializer
      (
        "residues",
        "list of residues to collect",
        io::Serialization::GetAgent( &m_ResidueList)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Collect the specified residues from a protein model
    //! @param MODEL the protein model from which residues will be collected
    //! @return SiPtrList of residues from "m_ResidueList" which could be collected
    util::SiPtrList< const biol::AABase> CollectorAASpecified::Collect( const ProteinModel &MODEL) const
    {
      // create list that will hold all of the residues collected from "MODEL"
      util::SiPtrList< const biol::AABase> collected_aas;

      // iterate through "m_ResidueList" in order to collect the residues
      for
      (
        storage::List< LocatorAA>::const_iterator
          itr( m_ResidueList.Begin()), itr_end( m_ResidueList.End()); itr != itr_end; ++itr
      )
      {
        // try to locate the residue dentod by "itr" in "MODEL"
        const util::SiPtr< const biol::AABase> located_aa( itr->Locate( MODEL));

        // true if the residue was able to be located
        if( located_aa.IsDefined())
        {
          // add the residue to "collected_aas"
          collected_aas.PushBack( located_aa);
        }
      }

      // return the list of residues collected from "MODEL"
      return collected_aas;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &CollectorAASpecified::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ResidueList, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &CollectorAASpecified::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ResidueList, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief ReadAALocators reads in the information from a file needed to create a list of residue locators
    //! @param FILENAME the file from which the information will be read
    //! @return list of LocatorAAs that have been created from FILENAME
    storage::List< LocatorAA> CollectorAASpecified::ReadAALocators( const std::string &FILENAME)
    {
      // create list which will hold all of the residue locators
      storage::List< LocatorAA> resi_list;

      // create istream to read locators from "FILENAME"
      io::IFStream read;

      // open read and bind it to "FILENAME"
      io::File::MustOpenIFStream( read, FILENAME);

      // read in all the contents of "FILENAME" line by line
      while( read.good())
      {
        std::string current_line;
        std::getline( read, current_line);

        // empty lines indicates end
        if( util::TrimString( current_line).empty())
        {
          break;
        }

        std::stringstream str_stream( current_line);
        char chain_id;
        io::Serialize::Read( chain_id, str_stream);

        // read in the seq id from the current line
        int seq_id;
        io::Serialize::Read( seq_id, str_stream);

        // message the chain and seq ids
        BCL_MessageDbg( "chain " + util::Format()( chain_id) + " seqid " + util::Format()( seq_id));
        BCL_Assert( str_stream.eof(), "The file has wrong format, line does not have chain id and seqid: " + current_line);

        // create a locator out of "chain" and "seq_id" and add it to "resi_list"
        resi_list.PushBack( LocatorAA( chain_id, seq_id));
      }

      // return the list of residue locators
      return resi_list;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_aa_type.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_base.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorAAType::s_Instance
    (
      GetObjectInstances().AddInstance( new CollectorAAType())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorAAType::CollectorAAType() :
      m_AATypes( storage::Set< biol::AAType>::Create( biol::GetAATypes().ALA, biol::GetAATypes().ARG))
    {
    }

    //! @brief constructor taking member variables as paramters
    //! @param AA_TYPES set of aa types that will be collected from the list of residues
    CollectorAAType::CollectorAAType( const storage::Set< biol::AAType> &AA_TYPES) :
      m_AATypes( AA_TYPES)
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorAAType
    CollectorAAType *CollectorAAType::Clone() const
    {
      return new CollectorAAType( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorAAType::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &CollectorAAType::GetAlias() const
    {
      static const std::string s_Name( "CollectorAAType");
      return s_Name;
    }

  ////////////////
  // operations //
  ////////////////

    //! Collect the residues that match the desired aa types from the provided residues
    //! @param RESIDUES entity that contains the residues to be collected from
    //! @return returns list of the collected residues that match the desired aa types
    util::SiPtrList< const biol::AABase>
    CollectorAAType::Collect( const util::SiPtrVector< const biol::AABase> &RESIDUES) const
    {
      // will hold all the collected residues that match the desired aa types
      util::SiPtrList< const biol::AABase> collected_aas;

      // iterate through the residues
      for
      (
        util::SiPtrVector< const biol::AABase>::const_iterator aa_itr( RESIDUES.Begin()), aa_itr_end( RESIDUES.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // try to find the residue type in m_AATypes
        const storage::Set< biol::AAType>::const_iterator find_itr( m_AATypes.Find( ( *aa_itr)->GetType()));

        // true if the residue type was found in m_AATypes
        if( find_itr != m_AATypes.End())
        {
          // add the residue into collected_aas since it is one of the desired types
          collected_aas.PushBack( *aa_itr);
        }
      }

      // return the list of residues that were collected matching the desired types of residues
      return collected_aas;
    }

    //! @brief locate the residue that matches the desired aa type - if more than one just returns first encountered
    //! @param RESIDUES entity that contains the residues to be collected from
    //! @return const siptr to biol::AABase which is the first instance of the aa type found in RESIDUES
    util::SiPtr< const biol::AABase> CollectorAAType::Locate( const util::SiPtrVector< const biol::AABase> &RESIDUES) const
    {
      // get all the possible aas
      const util::SiPtrList< const biol::AABase> collected_aas( Collect( RESIDUES));

      // true if none were found
      if( collected_aas.IsEmpty())
      {
        // return empty siptr
        return util::SiPtr< const biol::AABase>();
      }

      // return first aa found
      return collected_aas.FirstElement();
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &CollectorAAType::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_AATypes, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &CollectorAAType::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_AATypes, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorAAType::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription( "Collects residues which match any of the given aa types.");

      parameters.AddInitializer
      (
        "",
        "",
        io::Serialization::GetAgent( &m_AATypes),
        "(" + biol::GetAATypes().ALA->GetName() + ")"
      );

      return parameters;
    }

  } // namespace assemble

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_all_possible_domains.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_sse_geometry_packing_criteria.h"
#include "assemble/bcl_assemble_sse_geometry_packing_pickers.h"
#include "io/bcl_io_serialization.h"
#include "math/bcl_math_combination.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorAllPossibleDomains::s_Instance
    (
      GetObjectInstances().AddInstance( new CollectorAllPossibleDomains())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from the domain size and a packing criteria
    //! @param DOMAIN_SIZE domain size range
    //! @param CONNECTED_DOMAIN bool whether the SSEs in the domain should remain connected
    //! @param PACKING_CRITERIA packing criteria to be used
    CollectorAllPossibleDomains::CollectorAllPossibleDomains
    (
      const math::Range< size_t> DOMAIN_SIZE,
      const bool CONNECTED_DOMAIN,
      const util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> > &PACKING_CRITERIA
    ) :
      m_DomainSize( DOMAIN_SIZE),
      m_ForceDomainConnectivity( CONNECTED_DOMAIN),
      m_PackingCriteria( *PACKING_CRITERIA)
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorAllPossibleDomains
    CollectorAllPossibleDomains *CollectorAllPossibleDomains::Clone() const
    {
      return new CollectorAllPossibleDomains( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorAllPossibleDomains::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return packing criteria function
    //! @return packing criteria function
    const util::ShPtr
    <
      math::FunctionInterfaceSerializable< SSEGeometryPacking, bool>
    > &CollectorAllPossibleDomains::GetDefaultPackingCriteria()
    {
      // construct the vector of criteria vector
      static const util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> > s_packing_criteria
      (
        new SSEGeometryPackingCriteriaCombine
        (
          util::ShPtrVector< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >::Create
          (
            util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >
            (
              new SSEGeometryPackingCriteriaDistancePerType()
            ),
            util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >
            (
              new SSEGeometryPackingCriteriaInteractionWeight
              (
                0.5, math::Comparisons< double>::GetEnums().e_GreaterEqual
              )
            )
          )
        )
      );

      // end
      return s_packing_criteria;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorAllPossibleDomains::GetAlias() const
    {
      static const std::string s_alias( "CollectorAllPossibleDomains");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorAllPossibleDomains::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects all possible domains.");
      serializer.AddInitializer
      (
        "domain size",
        "size of domains randomly chosen",
        io::Serialization::GetAgent( &m_DomainSize)
      );
      serializer.AddInitializer
      (
        "force domain connectivity",
        "whether remaining SSEs should be considered a domain",
        io::Serialization::GetAgent( &m_ForceDomainConnectivity)
      );
      serializer.AddInitializer
      (
        "packing criterion",
        "criterion when the optimization will be terminated",
        io::Serialization::GetAgent( &m_PackingCriteria)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Collect returns all domains in the domain argument
    //! @param SSE_DOMAIN domain from which Domains will be collected
    //! @return returns ShPtrVector of domains found in the given domain
    util::ShPtrVector< Domain> CollectorAllPossibleDomains::Collect( const DomainInterface &SSE_DOMAIN) const
    {
      // get the SSEs
      const util::SiPtrVector< const SSE> sses( SSE_DOMAIN.GetSSEs());

      // if the domain is empty
      if( sses.IsEmpty())
      {
        // return empty vector
        return util::ShPtrVector< Domain>();
      }

      // adjust the potential domain size based on the size of SSE_DOMAIN
      const math::Range< size_t> adjusted_range
      (
        std::min( m_DomainSize.GetMin(), sses.GetSize()),
        std::min( m_DomainSize.GetMax(), sses.GetSize())
      );

      // get the random domain size
      const size_t domain_size( random::GetGlobalRandom().SizeT( adjusted_range));

      // construct a set from the SSEs
      const storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> sse_set( sses.Begin(), sses.End());

      // construct a combination representing the SSEs that are in the domain but not the domain
      const math::Combination< util::SiPtr< const SSE>, SSELessThanNoOverlap> topology_combination
      (
        sse_set,
        sses.GetSize() - domain_size
      );

      // get all possible combinations
      const storage::List< storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> > combinations
      (
        topology_combination.GetAllCombinations()
      );

      // construct a topology from the SSEs
      const Topology complete_topology
      (
        Topology::BuildTopologyGraphFromGeometries
        (
          sses,
          GetSSEGeometryPackingPickers().e_BestInteractionWeight,
          *m_PackingCriteria
        )
      );

      // initialize domain vectors
      util::ShPtrVector< Domain> subdomains;

      // iterate through the list of combinations
      for
      (
        storage::List< storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> >::const_iterator
          combination_itr( combinations.Begin()), combination_itr_end( combinations.End());
        combination_itr != combination_itr_end; ++combination_itr
      )
      {
        // make a hardcopy of the complete graph
        util::ShPtr< Topology::GraphType> sp_domain_graph( complete_topology.GetGraph().HardCopy());
        storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> domain_set( sse_set);

        // iterate through the SSEs in the set
        for
        (
          storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap>::const_iterator
            set_itr( combination_itr->Begin()), set_itr_end( combination_itr->End());
          set_itr != set_itr_end; ++set_itr
        )
        {
          // remove the corresponding vertex
          sp_domain_graph->DeleteVertex
          (
            sp_domain_graph->FindVertex( util::SiPtr< const SSEGeometryInterface>( *set_itr))
          );
          domain_set.Erase( *set_itr);
        }

        // if the graph has no unconnected vertices
        if( sp_domain_graph->IsConnected() && !sp_domain_graph->GetVertices().IsEmpty())
        {
          // if the domain needs to be connected
          if( m_ForceDomainConnectivity)
          {
            // make a hardcopy of the complete graph
            util::ShPtr< Topology::GraphType> sp_protein_graph( complete_topology.GetGraph().HardCopy());

            // iterate through the SSEs in the set
            for
            (
              storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap>::const_iterator
                set_itr( domain_set.Begin()), set_itr_end( domain_set.End());
              set_itr != set_itr_end; ++set_itr
            )
            {
              // remove the corresponding vertex
              sp_protein_graph->DeleteVertex
              (
                sp_protein_graph->FindVertex( util::SiPtr< const SSEGeometryInterface>( *set_itr))
              );
            }

            // move to the next combination if the model is not complete
            if( !sp_protein_graph->IsConnected())
            {
              continue;
            }
          }

          // convert the SiPtr set to a ShPtr set
          storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> sp_sse_set;
          for
          (
            storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap>::const_iterator
              sse_itr( domain_set.Begin()), sse_itr_end( domain_set.End());
            sse_itr != sse_itr_end; ++sse_itr
          )
          {
            sp_sse_set.Insert( util::ShPtr< SSE>( ( *sse_itr)->Clone()));
          }

          // add the domain to the vector
          subdomains.PushBack( util::ShPtr< Domain>( new Domain( sp_sse_set)));
        }
      }

      // end
      return subdomains;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_common_aa.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> CollectorCommonAA::s_Instance
    (
      util::Enumerated< find::CollectorInterface< storage::VectorND< 2, util::SiPtrList< const biol::AABase> >, storage::VectorND< 2, ProteinModel> > >::AddInstance
      (
        new CollectorCommonAA()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorCommonAA::CollectorCommonAA()
    {
    }

    //! @brief
    //! @param COLLECTOR ???
    CollectorCommonAA::CollectorCommonAA( const CollectorCommonAA &COLLECTOR)
    {
    }

    //! @brief Clone is the virtual Clone constructor
    //! @return a pointer to new LocatorSSEFurthest which is a copy of this
    CollectorCommonAA *CollectorCommonAA::Clone() const
    {
      return new CollectorCommonAA( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorCommonAA::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorCommonAA::GetAlias() const
    {
      static const std::string s_alias( "CollectorCommonAA");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorCommonAA::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects all amino acids that two proteins have in common.");

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief collect defined AAs in chains
    //! @param PROTEIN_MODEL model containing chains
    //! @return list of defined AAs
    util::SiPtrList< const biol::AABase> CollectorCommonAA::CollectDefinedAAsInChains
    (
      const ProteinModel &PROTEIN_MODEL
    )
    {
      // create list to hold the collected amino acids that have defined coordinates within the protein model
      util::SiPtrList< const biol::AABase> amino_acids;

      // loop over the chains of the two protein models
      for
      (
        storage::Vector< util::ShPtr< Chain> >::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()),
          chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // loop over the aa sequences of the chains denoted by "chain_itr_a" and "chain_itr_b"
        for
        (
          storage::Vector< util::ShPtr< biol::AABase> >::const_iterator
            aa_itr( ( *chain_itr)->GetSequence()->Begin()),
            aa_itr_end( ( *chain_itr)->GetSequence()->End());
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          // check if the coordinates are defined
          if
          (
            coord::AreDefinedCoordinates( ( *aa_itr)->GetAtomCoordinates())
          )
          {
            // add the amino acid denoted by "aa_itr" to first group in "amino_acids"
            amino_acids.PushBack( util::SiPtr< const biol::AABase>( **aa_itr));
          }
        }
      }

      // return the amino acids that are common to both proteins of "PROTEIN_MODELS"
      return amino_acids;
    }

    //! @brief collect defined SSEs in chains
    //! @param PROTEIN_MODEL model containing SSEs
    //! @return list of defined SSEs
    util::SiPtrList< const biol::AABase> CollectorCommonAA::CollectDefinedAAsInSSEs
    (
      const ProteinModel &PROTEIN_MODEL
    )
    {
      // create list to hold the collected amino acids that have defined coordinates within the protein model
      const util::SiPtrVector< const biol::AABase> amino_acids_initial( PROTEIN_MODEL.GetAminoAcids());
      util::SiPtrList< const biol::AABase> amino_acids;

      for
      (
        util::SiPtrVector< const biol::AABase>::const_iterator
          aa_itr( amino_acids_initial.Begin()),
          aa_itr_end( amino_acids_initial.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // check if the coordinates are defined
        if
        (
          coord::AreDefinedCoordinates( ( *aa_itr)->GetAtomCoordinates())
        )
        {
          // add the amino acid denoted by "aa_itr" to first group in "amino_acids"
          amino_acids.PushBack( *aa_itr);
        }
      }

      // return the amino acids that are common to both proteins of "PROTEIN_MODELS"
      return amino_acids;
    }

    //! @brief
    //! @param AAS_DEFINED ???
    //! @return
    storage::VectorND< 2, util::SiPtrList< const biol::AABase> >
    CollectorCommonAA::Collect
    (
      const storage::VectorND< 2, util::SiPtr< const util::SiPtrList< const biol::AABase> > > &AAS_DEFINED
    )
    {
      // create VectorND to hold the collected amino acids that are common to both protein models
      storage::VectorND< 2, util::SiPtrList< const biol::AABase> > amino_acids;

      util::SiPtrList< const biol::AABase>::const_iterator
        aa_itr_a( AAS_DEFINED.First()->Begin()),
        aa_itr_a_end( AAS_DEFINED.First()->End()),
        aa_itr_b( AAS_DEFINED.Second()->Begin()),
        aa_itr_b_end( AAS_DEFINED.Second()->End());

      while( aa_itr_a != aa_itr_a_end && aa_itr_b != aa_itr_b_end)
      {
        // match up chain ids
        while( aa_itr_a != aa_itr_a_end && ( *aa_itr_a)->GetChainID() < ( *aa_itr_b)->GetChainID())
        {
          ++aa_itr_a;
        }

        // break if there are no aas left in one of the lists
        if( aa_itr_a == aa_itr_a_end)
        {
          break;
        }

        while( aa_itr_b != aa_itr_b_end && ( *aa_itr_b)->GetChainID() < ( *aa_itr_a)->GetChainID())
        {
          ++aa_itr_b;
        }

        // break if there are no aas left in one of the lists
        if( aa_itr_b == aa_itr_b_end)
        {
          break;
        }

        // continue if they still do not match up
        if( ( *aa_itr_a)->GetChainID() != ( *aa_itr_b)->GetChainID())
        {
          continue;
        }

        // assert that the chain ids do indeed match up
        BCL_Assert
        (
            ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID(),
            "chain id's do not match the first is :" + util::Format()( ( ( *aa_itr_a)->GetChainID()))
            + ": and the second is :"
            + util::Format()( ( ( *aa_itr_b)->GetChainID())) + ":"
        );

        // match up seq ids
        while( aa_itr_a != aa_itr_a_end && ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID() && ( *aa_itr_a)->GetSeqID() < ( *aa_itr_b)->GetSeqID())
        {
          ++aa_itr_a;
        }

        // break if there are no aas left in one of the lists
        if( aa_itr_a == aa_itr_a_end)
        {
          break;
        }

        while( aa_itr_b != aa_itr_b_end && ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID() && ( *aa_itr_b)->GetSeqID() < ( *aa_itr_a)->GetSeqID())
        {
          ++aa_itr_b;
        }

        // break if there are no aas left in one of the lists
        if( aa_itr_b == aa_itr_b_end)
        {
          break;
        }

        // continue if they still do not match up
        if( ( *aa_itr_a)->GetChainID() != ( *aa_itr_b)->GetChainID() || ( *aa_itr_a)->GetSeqID() != ( *aa_itr_b)->GetSeqID())
        {
          continue;
        }

        // assert that the seq ids do indeed match up
        BCL_Assert
        (
               ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID()
            && ( *aa_itr_a)->GetSeqID()   == ( *aa_itr_b)->GetSeqID()
//            && ( *aa_itr_a)->GetPdbID()   == ( *aa_itr_b)->GetPdbID()
            ,
            "chain id's and seq ids should match... the first is chain :"
            + util::Format()( ( ( *aa_itr_a)->GetChainID())) + ": seq id :"
            + util::Format()( ( *aa_itr_a)->GetSeqID()) + ": pdb id :"
            + util::Format()( ( *aa_itr_a)->GetPdbID()) + ": \n"
            + "and the second is chainid :"
            + util::Format()( ( ( *aa_itr_b)->GetChainID())) + ": seq id :"
            + util::Format()( ( *aa_itr_b)->GetSeqID()) + ": pdb id :"
            + util::Format()( ( *aa_itr_b)->GetPdbID()) + ": \n"
        );

        // as long as amino acids do match, store them in amino_acids and got to next pair
        while( aa_itr_a != aa_itr_a_end && aa_itr_b != aa_itr_b_end && ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID() && ( *aa_itr_a)->GetSeqID() == ( *aa_itr_b)->GetSeqID())
        {
          // make sure amino acids are of the same type
          BCL_Assert
          (
            ( **aa_itr_a) == ( **aa_itr_b),
            "amino acids have different type: "
            + util::Format()( ( *aa_itr_a)->GetType()) + " != " + util::Format()( ( *aa_itr_b)->GetType())
            + " first aa is PdbID" + util::Format()( ( *aa_itr_a)->GetPdbID()) + " in chain "
            + ( *aa_itr_a)->GetChainID()
            + " second aa is PdbID" + util::Format()( ( *aa_itr_b)->GetPdbID()) + " in chain "
            + ( *aa_itr_b)->GetChainID()
          );

          // store amino acids
          amino_acids.First().PushBack( *aa_itr_a);
          amino_acids.Second().PushBack( *aa_itr_b);
          ++aa_itr_a;
          ++aa_itr_b;
        }
      }

      return amino_acids;
    }

    //! @brief CollectCommonCoordinates is for aligning residues and giving corresponding aligned lists of atoms
    //! @param AAS_DEFINED the two list of amino acids which will be aligned to get their coordinates
    //! @param ATOM_TYPES the atom types in the residues for which you want the coordinates
    //! @return two lists of coordinates which are the aligned coordinates of the common aas and desired atoms
    storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> >
    CollectorCommonAA::CollectCommonCoordinates
    (
      const storage::VectorND< 2, util::SiPtr< const util::SiPtrList< const biol::AABase> > > &AAS_DEFINED,
      const storage::Set< biol::AtomType> &ATOM_TYPES,
      size_t &NR_COMMON_RESIDUES
    )
    {
      // create VectorND to hold the collected atom_coordinates that are common to both lists of AABases
      storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > all_atom_coordinates;

      size_t nr_common_residues( 0);

      util::SiPtrList< const biol::AABase>::const_iterator
        aa_itr_a( AAS_DEFINED.First()->Begin()),
        aa_itr_a_end( AAS_DEFINED.First()->End()),
        aa_itr_b( AAS_DEFINED.Second()->Begin()),
        aa_itr_b_end( AAS_DEFINED.Second()->End());

      while( aa_itr_a != aa_itr_a_end && aa_itr_b != aa_itr_b_end)
      {
        // try to match up chain ids by  moving "aa_itr_a"
        while( aa_itr_a != aa_itr_a_end && ( *aa_itr_a)->GetChainID() < ( *aa_itr_b)->GetChainID())
        {
          ++aa_itr_a;
        }

        // break if there are no aas left in list a
        if( aa_itr_a == aa_itr_a_end)
        {
          break;
        }

        // try to match up chain ids by  moving "aa_itr_b"
        while( aa_itr_b != aa_itr_b_end && ( *aa_itr_b)->GetChainID() < ( *aa_itr_a)->GetChainID())
        {
          ++aa_itr_b;
        }

        // break if there are no aas left in list b
        if( aa_itr_b == aa_itr_b_end)
        {
          break;
        }

        // continue if they still do not match up i.e. one whole chain is missing in one of the lists of aas
        if( ( *aa_itr_a)->GetChainID() != ( *aa_itr_b)->GetChainID())
        {
          continue;
        }

        // assert that the chain ids do indeed match up
        BCL_Assert
        (
            ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID(),
            "chain id's do not match the first is :" + util::Format()( ( ( *aa_itr_a)->GetChainID()))
            + ": and the second is :"
            + util::Format()( ( ( *aa_itr_b)->GetChainID())) + ":"
        );

        // match up seq ids by trying to move "aa_itr_a"
        while
        (
          aa_itr_a != aa_itr_a_end &&
          ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID() &&
          ( *aa_itr_a)->GetSeqID() < ( *aa_itr_b)->GetSeqID()
        )
        {
          ++aa_itr_a;
        }

        // break if there are no aas left in list a
        if( aa_itr_a == aa_itr_a_end)
        {
          break;
        }

        // match up seq ids by trying to move "aa_itr_b"
        while
        (
          aa_itr_b != aa_itr_b_end &&
          ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID() &&
          ( *aa_itr_b)->GetSeqID() < ( *aa_itr_a)->GetSeqID()
        )
        {
          ++aa_itr_b;
        }

        // break if there are no aas left in list b
        if( aa_itr_b == aa_itr_b_end)
        {
          break;
        }

        // continue if they still do not match up
        if
        (
          ( *aa_itr_a)->GetChainID() != ( *aa_itr_b)->GetChainID() ||
          ( *aa_itr_a)->GetSeqID() != ( *aa_itr_b)->GetSeqID()
        )
        {
          continue;
        }

        // assert that the seq ids do indeed match up
        BCL_Assert
        (
               ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID()
            && ( *aa_itr_a)->GetSeqID()   == ( *aa_itr_b)->GetSeqID()
//            && ( *aa_itr_a)->GetPdbID()   == ( *aa_itr_b)->GetPdbID()
            ,
            "chain id's and seq ids should match... the first is chain :"
            + util::Format()( ( ( *aa_itr_a)->GetChainID())) + ": seq id :"
            + util::Format()( ( *aa_itr_a)->GetSeqID()) + ": pdb id :"
            + util::Format()( ( *aa_itr_a)->GetPdbID()) + ": \n"
            + "and the second is chainid :"
            + util::Format()( ( ( *aa_itr_b)->GetChainID())) + ": seq id :"
            + util::Format()( ( *aa_itr_b)->GetSeqID()) + ": pdb id :"
            + util::Format()( ( *aa_itr_b)->GetPdbID()) + ": \n"
        );

        // as long as amino acids do match, store them in amino_acids and got to next pair
        while
        (
          aa_itr_a != aa_itr_a_end &&
          aa_itr_b != aa_itr_b_end &&
          ( *aa_itr_a)->GetChainID() == ( *aa_itr_b)->GetChainID() &&
          ( *aa_itr_a)->GetSeqID() == ( *aa_itr_b)->GetSeqID()
        )
        {
          // make sure amino acids are of the same type
          BCL_Assert
          (
            ( **aa_itr_a) == ( **aa_itr_b),
            "amino acids have different type: "
            + util::Format()( ( *aa_itr_a)->GetType()) + " != " + util::Format()( ( *aa_itr_b)->GetType())
            + " first aa is PdbID" + util::Format()( ( *aa_itr_a)->GetPdbID()) + " in chain "
            + ( *aa_itr_a)->GetChainID()
            + " second aa is PdbID" + util::Format()( ( *aa_itr_b)->GetPdbID()) + " in chain "
            + ( *aa_itr_b)->GetChainID()
          );

          // store coordinates
          const util::SiPtrVector< const linal::Vector3D> temp_coords_a( ( *aa_itr_a)->GetAtomCoordinates( ATOM_TYPES));
          const util::SiPtrVector< const linal::Vector3D> temp_coords_b( ( *aa_itr_b)->GetAtomCoordinates( ATOM_TYPES));

          // skip undefined coordinates
          if( !coord::AreDefinedCoordinates( temp_coords_a))
          {
            BCL_MessageVrb
            (
              "skipping aa with undefined coordinates: chain" + util::Format()( ( *aa_itr_a)->GetChainID()) + " pdbid: " +
              util::Format()( ( *aa_itr_a)->GetPdbID())
            );
            ++aa_itr_a;
            ++aa_itr_b;
            continue;
          }
          if( !coord::AreDefinedCoordinates( temp_coords_b))
          {
            BCL_MessageVrb
            (
              "skipping aa with undefined coordinates: chain" + util::Format()( ( *aa_itr_b)->GetChainID()) + " pdbid: " +
              util::Format()( ( *aa_itr_b)->GetPdbID())
            );
            ++aa_itr_a;
            ++aa_itr_b;
            continue;
          }

          // add coordinates to the end of appropriate SiPtrVectors of "COMMON_AAS"
          all_atom_coordinates.First().Append( temp_coords_a);
          all_atom_coordinates.Second().Append( temp_coords_b);
          ++nr_common_residues;
          ++aa_itr_a;
          ++aa_itr_b;
        }
      }

      NR_COMMON_RESIDUES = nr_common_residues;
      return all_atom_coordinates;
    }

    //! @brief CollectCommonCoordinates is for aligning residues and giving corresponding aligned lists of atoms
    //! @param AAS_DEFINED_A the list of amino acids which will be aligned to get their coordinates from first model
    //! @param AAS_DEFINED_B the list of amino acids which will be aligned to get their coordinates from second model
    //! @param ATOM_TYPES the atom types in the residues for which you want the coordinates
    //! @param NR_COMMON_RESIDUES number of common residues, this value will be overwritten by the function
    //! @return two lists of coordinates which are the aligned coordinates of the common aas and desired atoms
    storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> >
    CollectorCommonAA::CollectCommonCoordinates
    (
      const util::SiPtrList< const biol::AABase> &AAS_DEFINED_A,
      const util::SiPtrList< const biol::AABase> &AAS_DEFINED_B,
      const storage::Set< biol::AtomType> &ATOM_TYPES,
      size_t &NR_COMMON_RESIDUES
    )
    {
      return CollectCommonCoordinates
      (
        storage::VectorND< 2, util::SiPtr< const util::SiPtrList< const biol::AABase> > >
        (
          util::ToSiPtr( AAS_DEFINED_A),
          util::ToSiPtr( AAS_DEFINED_B)
        ),
        ATOM_TYPES,
        NR_COMMON_RESIDUES
      );

    }

    //! @brief ???
    //! @param PROTEIN_MODELS ???
    //! @return returns
    storage::VectorND< 2, util::SiPtrList< const biol::AABase> >
    CollectorCommonAA::Collect( const storage::VectorND< 2, ProteinModel> &PROTEIN_MODELS) const
    {
      // create VectorND "" to hold the collected amino acids that are common to both protein models
      storage::VectorND< 2, util::SiPtrList< const biol::AABase> > amino_acids;

      // loop over the chains of the two protein models
      for
      (
        storage::Vector< util::ShPtr< Chain> >::const_iterator
          chain_itr_a( PROTEIN_MODELS.First().GetChains().Begin()),
          chain_itr_a_end( PROTEIN_MODELS.First().GetChains().End()),
          chain_itr_b( PROTEIN_MODELS.Second().GetChains().Begin()),
          chain_itr_b_end( PROTEIN_MODELS.Second().GetChains().End());
        chain_itr_a != chain_itr_a_end && chain_itr_b != chain_itr_b_end;
        ++chain_itr_a, ++chain_itr_b
      )
      {
        // make sure chain id's match
        BCL_Assert( ( *chain_itr_a)->GetChainID() == ( *chain_itr_b)->GetChainID(), "chain ids do not match");

        // loop over the aa sequences of the chains denoted by "chain_itr_a" and "chain_itr_b"
        for
        (
          storage::Vector< util::ShPtr< biol::AABase> >::const_iterator
            aa_itr_a( ( *chain_itr_a)->GetSequence()->Begin()),
            aa_itr_a_end( ( *chain_itr_a)->GetSequence()->End()),
            aa_itr_b( ( *chain_itr_b)->GetSequence()->Begin()),
            aa_itr_b_end( ( *chain_itr_b)->GetSequence()->End());
          aa_itr_a != aa_itr_a_end && aa_itr_b != aa_itr_b_end;
          ++aa_itr_a, ++aa_itr_b
        )
        {
          // make sure amino acids are of the same type
          BCL_Assert
          (
            ( **aa_itr_a) == ( **aa_itr_b),
            "amino acids have different type: "
            + util::Format()( ( *aa_itr_a)->GetType()) + " != " + util::Format()( ( *aa_itr_b)->GetType())
          );

          // check if the coordinates are defined
          if
          (
               coord::AreDefinedCoordinates( ( *aa_itr_a)->GetAtomCoordinates())
            && coord::AreDefinedCoordinates( ( *aa_itr_b)->GetAtomCoordinates())
          )
          {
            // add the amino acid denoted by "aa_itr_a" to first group in "amino_acids"
            amino_acids.First().PushBack( util::ToSiPtr( **aa_itr_a));

            // add the amino acid denoted by "aa_itr_b" to first group in "amino_acids"
            amino_acids.Second().PushBack( util::ToSiPtr( **aa_itr_b));
          }
        }
      }

      // return the amino acids that are common to both proteins of "PROTEIN_MODELS"
      return amino_acids;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_protein_model_conformation_by_score.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_binary_function_stl_wrapper.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorProteinModelConformationByScore::s_Instance
    (
      util::Enumerated< find::CollectorInterface< util::SiPtrList< const ProteinModel>, ProteinModel> >::AddInstance
      (
        new CollectorProteinModelConformationByScore()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorProteinModelConformationByScore::CollectorProteinModelConformationByScore() :
      m_ScoreFunction(),
      m_NumberToCollect(),
      m_Sort( util::BinaryFunctionSTLWrapper< std::less< double> >()),
      m_ConsiderCurrentConformation()
    {
    }

    //! @brief constructor taking parameters
    //! @param SCORE the scoring function to be used
    //! @param NUM_TO_COLLECT the number of conformations to collect
    //! @param SORT the method for sorting scores to determine whether the best or worst scored models are collected
    //! @param CONSIDER_CURRENT if true the current conformation will be considered with the other conformations
    CollectorProteinModelConformationByScore::CollectorProteinModelConformationByScore
    (
      const util::ShPtr< math::FunctionInterfaceSerializable< ProteinModel, double> > &SCORE,
      const size_t NUM_TO_COLLECT,
      const util::ShPtr< util::BinaryFunctionInterfaceSerializable< double, double, bool> > &SORT,
      const bool CONSIDER_CURRENT
    ) :
      m_ScoreFunction( *SCORE),
      m_NumberToCollect( NUM_TO_COLLECT),
      m_Sort( *SORT),
      m_ConsiderCurrentConformation( CONSIDER_CURRENT)
    {
    }

    //! @brief constructor taking parameters
    //! @param NUM_TO_COLLECT the number of conformations to collect
    //! @param SORT the method for sorting scores to determine whether the best or worst scored models are collected
    //! @param CONSIDER_CURRENT if true the current conformation will be considered with the other conformations
    CollectorProteinModelConformationByScore::CollectorProteinModelConformationByScore
    (
      const size_t NUM_TO_COLLECT,
      const util::ShPtr< util::BinaryFunctionInterfaceSerializable< double, double, bool> > &SORT,
      const bool CONSIDER_CURRENT
    ) :
      m_ScoreFunction(),
      m_NumberToCollect( NUM_TO_COLLECT),
      m_Sort( *SORT),
      m_ConsiderCurrentConformation( CONSIDER_CURRENT)
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorProteinModelConformationByScore
    CollectorProteinModelConformationByScore *CollectorProteinModelConformationByScore::Clone() const
    {
      return new CollectorProteinModelConformationByScore( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorProteinModelConformationByScore::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorProteinModelConformationByScore::GetAlias() const
    {
      static const std::string s_alias( "CollectorProteinModelConformationByScore");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorProteinModelConformationByScore::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Optimization implementation for Monte Carlo Metropolis algorithms.");
      serializer.AddInitializer
      (
        "score function",
        "score function to evaluate the sampled protein models",
        io::Serialization::GetAgent( &m_ScoreFunction)
      );
      serializer.AddInitializer
      (
        "number",
        "number of conformations to collect",
        io::Serialization::GetAgent( &m_NumberToCollect)
      );
      serializer.AddInitializer
      (
        "sort method",
        "method for sorting scores",
        io::Serialization::GetAgent( &m_Sort)
      );
      serializer.AddInitializer
      (
        "consider current",
        "consider the current conformation",
        io::Serialization::GetAgent( &m_ConsiderCurrentConformation)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! Collect the t_ReturnType objects in t_ArgumentType
    //! @param PROTEIN_MODEL entity that contains a t_ReturnType
    //! @return returns Group of the collected t_ReturnType objects
    util::SiPtrList< const ProteinModel>
    CollectorProteinModelConformationByScore::Collect( const ProteinModel &PROTEIN_MODEL) const
    {
      // get the conformations in the protein model
      const ProteinEnsemble &conformation_ensemble( PROTEIN_MODEL.GetConformationalEnsemble());

      storage::List< storage::Pair< double, util::SiPtr< const ProteinModel> > > score_model;

      // iterate through the conformational ensemble to score the proteins and insert them into score list
      for
      (
        ProteinEnsemble::const_iterator
          model_itr( conformation_ensemble.Begin()), model_itr_end( conformation_ensemble.End());
        model_itr != model_itr_end;
        ++model_itr
      )
      {
        // get siptr to current model
        const util::SiPtr< const ProteinModel> current( **model_itr);

        // score the current model
        const double score( m_ScoreFunction->operator()( *current));

        // add the current model and its score into the score list
        score_model.PushBack( storage::Pair< double, util::SiPtr< const ProteinModel> >( score, current));
      }

      // true if the current conformation of the protein model is also being considered
      if( m_ConsiderCurrentConformation)
      {
        // get siptr to current model
        const util::SiPtr< const ProteinModel> current( PROTEIN_MODEL);

        // score the current model
        const double score( m_ScoreFunction->operator()( *current));

        // add the current model and its score into the score list
        score_model.PushBack( storage::Pair< double, util::SiPtr< const ProteinModel> >( score, current));
      }

      // sort the score list
      score_model.Sort
      (
        storage::PairBinaryPredicateFirst< double, util::SiPtr< const ProteinModel> >( *m_Sort)
      );

      // get the desired number of models starting at the beginning of the sorted list
      storage::List< storage::Pair< double, util::SiPtr< const ProteinModel> > > extracted_scores
      (
        score_model.ExtractElements( 0, m_NumberToCollect)
      );

      // to hold the models
      util::SiPtrList< const ProteinModel> desired_models;

      // iterate over the list of extracted scores to build up the list of desired models
      for
      (
        storage::List< storage::Pair< double, util::SiPtr< const ProteinModel> > >::const_iterator
          itr( extracted_scores.Begin()), itr_end( extracted_scores.End());
        itr != itr_end;
        ++itr
      )
      {
        desired_models.PushBack( itr->Second());
      }

      return desired_models;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_protein_model_conformations.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorProteinModelConformations::s_Instance
    (
      util::Enumerated< find::CollectorInterface< util::SiPtrList< const ProteinModel>, ProteinModel> >::AddInstance
      (
        new CollectorProteinModelConformations()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorProteinModelConformations::CollectorProteinModelConformations() :
      m_ConsiderCurrentConformation( false)
    {
    }

    //! @brief constructor taking parameters
    //! @param CONSIDER_CURRENT if true the current conformation will be considered with the other conformations
    CollectorProteinModelConformations::CollectorProteinModelConformations
    (
      const bool CONSIDER_CURRENT
    ) :
      m_ConsiderCurrentConformation( CONSIDER_CURRENT)
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorProteinModelConformations
    CollectorProteinModelConformations *CollectorProteinModelConformations::Clone() const
    {
      return new CollectorProteinModelConformations( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorProteinModelConformations::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorProteinModelConformations::GetAlias() const
    {
      static const std::string s_alias( "CollectorProteinModelConformations");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorProteinModelConformations::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects all conformations of a protein.");
      serializer.AddInitializer
      (
        "consider current",
        "consider current conformation",
        io::Serialization::GetAgent( &m_ConsiderCurrentConformation)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! Collect the t_ReturnType objects in t_ArgumentType
    //! @param PROTEIN_MODEL entity that contains a t_ReturnType
    //! @return returns Group of the collected t_ReturnType objects
    util::SiPtrList< const ProteinModel>
    CollectorProteinModelConformations::Collect( const ProteinModel &PROTEIN_MODEL) const
    {
      // get the conformations in the protein model
      const ProteinEnsemble &conformation_ensemble( PROTEIN_MODEL.GetConformationalEnsemble());

      // to hold the list of conformations from protein model
      util::SiPtrList< const ProteinModel> ensemble_list;

      // fill up the list of conformations from the protein model
      for
      (
        util::ShPtrVector< ProteinModel>::const_iterator
          model_itr( conformation_ensemble.GetEnsembleData().Begin()),
          model_itr_end( conformation_ensemble.GetEnsembleData().End());
        model_itr != model_itr_end;
        ++model_itr
      )
      {
        ensemble_list.PushBack( util::SiPtr< const ProteinModel>( *model_itr));
      }

      // true if want to add the current conformation of the protein model
      if( m_ConsiderCurrentConformation)
      {
        ensemble_list.PushBack( util::ToSiPtr( PROTEIN_MODEL));
      }

      // return the list of conformations
      return ensemble_list;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_sheet.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_topology_sheet.h"
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> CollectorSheet::s_Instance
    (
      GetObjectInstances().AddInstance( new CollectorSheet())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorSheet::CollectorSheet()
    {
    }

    //! @brief Clone function
    //! @return pointer to new Sheet
    CollectorSheet *CollectorSheet::Clone() const
    {
      return new CollectorSheet( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &CollectorSheet::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &CollectorSheet::GetAlias() const
    {
      static const std::string s_name( "CollectorSheet");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorSheet::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects beta-sheets in a protein model.");

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Collect returns all beta-sheets in the ProteinModel argument
    //! @param PROTEIN_MODEL ProteinModel from which SSEs will be collected
    //! @return returns ShPtrList of beta-sheets found in the given protein model
    util::ShPtrVector< Domain> CollectorSheet::Collect( const ProteinModel &PROTEIN_MODEL) const
    {
      // construct sheet vector
      util::ShPtrVector< Domain> sheet_vector;

      // initialize vector to hold strands
      util::SiPtrVector< const SSE> strand_vector( PROTEIN_MODEL.GetSSEs( biol::GetSSTypes().STRAND));

      // collect the SheetTopologies
      util::ShPtrVector< Topology> topology_vector( CollectorTopologySheet().Collect( strand_vector));

      // if there are no strands or no beta-sheet topologies were found
      if( topology_vector.IsEmpty())
      {
        return sheet_vector;
      }

      // iterate over each found topology
      for
      (
        util::ShPtrVector< Topology>::iterator
          topology_itr( topology_vector.Begin()), topology_itr_end( topology_vector.End());
        topology_itr != topology_itr_end; ++topology_itr
      )
      {
        // cast the order vector into a sse vector
        util::SiPtrVector< const SSE> sse_vector( ( *topology_itr)->GetElements());

        // make sure the cast was possible
        if( !sse_vector.IsDefined())
        {
          BCL_MessageCrt( "The cast of SSEGeometryInterfaces to SSEs failed");
          continue;
        }

        // construct the sse set
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> sse_set;

        // iterate over SSE vector
        for
        (
          util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()), sse_itr_end( sse_vector.End());
          sse_itr != sse_itr_end; ++sse_itr
        )
        {
          // find the corresponding SSE
          util::ShPtr< SSE> sp_this_sse( PROTEIN_MODEL.FindSSE( **sse_itr));

          // make sure the SSE was found
          BCL_Assert( sp_this_sse.IsDefined(), "The SSE from Sheet topology was not found in the Protein Model");

          // insert into the set
          sse_set.Insert( sp_this_sse);
        }

        // construct the sheet and add it to the sheet vector
        util::ShPtr< Domain> sp_new_sheet( new Domain( sse_set, *topology_itr));

        // pushback into the sheet vector
        sheet_vector.PushBack( sp_new_sheet);
      }

      // end
      return sheet_vector;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &CollectorSheet::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &CollectorSheet::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> CollectorSSE::s_Instance
    (
      util::Enumerated< find::CollectorInterface< util::SiPtrList< const SSE>, DomainInterface> >::AddInstance
      (
        new CollectorSSE()
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorSSE::CollectorSSE() :
      m_SSTypes( biol::GetSSTypes().HELIX.GetIterator(), biol::GetSSTypes().COIL.GetIterator() + 1)
    {
    }

    //! @brief constructor from a provided sstype
    //! @param SS_TYPES Set of SSTypes to be collected
    CollectorSSE::CollectorSSE( const storage::Set< biol::SSType> &SS_TYPES) :
      m_SSTypes( SS_TYPES)
    {
    }

    //! @brief constructor from a provided sstype
    //! @param SS_TYPE to be collected
    CollectorSSE::CollectorSSE( const biol::SSType &SS_TYPE) :
      m_SSTypes( SS_TYPE)
    {
    }

    //! @brief Clone is the virtual Clone constructor
    //! @return a pointer to new LocatorSSEFurthest which is a copy of this
    CollectorSSE *CollectorSSE::Clone() const
    {
      return new CollectorSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns SSTypes Set
    //! @return SSTypes Set
    const storage::Set< biol::SSType> &CollectorSSE::GetSSTypes() const
    {
      return m_SSTypes;
    }

    //! @brief set SSTypes Set
    //! @param SS_TYPES set of ss types
    void CollectorSSE::SetSSTypes( const storage::Set< biol::SSType> &SS_TYPES)
    {
      m_SSTypes = SS_TYPES;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &CollectorSSE::GetAlias() const
    {
      static const std::string s_name( "CollectorSSE");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorSSE::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects all SSEs in a domain.");
      serializer.AddInitializer
      (
        "sse types",
        "SSE types to collect",
        io::Serialization::GetAgent( &m_SSTypes)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Collect returns all SSEs in the domain argument
    //! @param SSE_DOMAIN domain from which SSEs will be collected
    //! @return returns SiPtrList of the collected SSEs objects
    util::SiPtrList< const SSE> CollectorSSE::Collect( const DomainInterface &SSE_DOMAIN) const
    {
      // get SSEs from the PROTEIN_MODEL( get all types of SSEs if m_SSTypes is empty)
      util::SiPtrVector< const SSE> sses
      (
        SSE_DOMAIN.GetSSEs( m_SSTypes)
      );

      // construct SiPtrList on the go and return it
      return util::SiPtrList< const SSE>( sses.Begin(), sses.End());
    }

    //! Collect returns all SSEs in the SiPtrVector that match the type
    //! @param SSES all SSEs
    //! @return returns SiPtrList of the collected SSEs objects
    util::SiPtrList< const SSE> CollectorSSE::Collect( const util::SiPtrVector< const SSE> &SSES) const
    {
      // initialize list to return
      util::SiPtrList< const SSE> sse_list;

      // iterate through the SSEs
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( SSES.Begin()), sse_itr_end( SSES.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // if the SSE is the right type
        if( m_SSTypes.Contains( ( *sse_itr)->GetType()))
        {
          // add the sse to the list
          sse_list.PushBack( *sse_itr);
        }
      }

      // end
      return sse_list;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_sse_paired.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "io/bcl_io_serialization.h"
#include "storage/bcl_storage_list.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> CollectorSSEPaired::s_Instance
    (
      util::Enumerated< find::CollectorInterface< storage::List< storage::VectorND< 2, util::SiPtr< const SSE> > >, DomainInterface> >::AddInstance( new CollectorSSEPaired())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorSSEPaired::CollectorSSEPaired() :
      m_PackingPicker( GetSSEGeometryPackingPickers().e_Undefined),
      m_ContactTypes(),
      m_MaxDistance( 0.0),
      m_ConsiderOrthogonalConnection( false)
    {
    }

    //! @brief constructor taking a contact type
    //! @param PACKING_PICKER SSEGeometryPackingPicker to be used
    //! @param CONTACT_TYPES is the set of contact type for which sse pairs will be collected
    //! @param MAX_DISTANCE maximum distance to define to sses as paired
    //! @param ORTHOGONAL_CONNECTION boolean whether to include non-orthogonal contacts
    CollectorSSEPaired::CollectorSSEPaired
    (
      const SSEGeometryPackingPicker &PACKING_PICKER,
      const storage::Set< contact::Type> &CONTACT_TYPES,
      const double MAX_DISTANCE,
      const bool ORTHOGONAL_CONNECTION
    ) :
      m_PackingPicker( PACKING_PICKER),
      m_ContactTypes( CONTACT_TYPES),
      m_MaxDistance( MAX_DISTANCE),
      m_ConsiderOrthogonalConnection( ORTHOGONAL_CONNECTION)
    {
    }

    //! @brief Clone is the virtual Clone constructor
    //! @return a pointer to new CollectorSSEPaired which is a copy of this
    CollectorSSEPaired *CollectorSSEPaired::Clone() const
    {
      return new CollectorSSEPaired( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorSSEPaired::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetContactType gives the types of SSE contact of interest
    //! @return the types of SSE contact of interest
    const storage::Set< contact::Type> &CollectorSSEPaired::GetContactTypes() const
    {
      // return "m_ContactTypes"
      return m_ContactTypes;
    }

    //! @brief SetContactType changes the type of SSE contact of interest
    //! @param CONTACT_TYPES is the new type of contact that will be searched for SSEs not having
    void CollectorSSEPaired::SetContactTypes( const storage::Set< contact::Type> &CONTACT_TYPES)
    {
      // set "m_ContactType" to "CONTACT_TYPE"
      m_ContactTypes = CONTACT_TYPES;
    }

    //! @brief GetMaxDistance gives the maximum distance between SSEs for them to still be considered paired
    //! @return returns "m_MaxDistance" the maximum distance between SSEs for them to still be considered paired
    double CollectorSSEPaired::GetMaxDistance() const
    {
      // return "m_MaxDistance"
      return m_MaxDistance;
    }

    //! @brief SetMaxDistance changes the type of SSE contact of interest
    //! @param MAX_DISTANCE is the new maximum distance between SSEs for them to still be considered paired
    void CollectorSSEPaired::SetMaxDistance( const double MAX_DISTANCE)
    {
      // set "m_MaxDistance" to "MAX_DISTANCE"
      m_MaxDistance = MAX_DISTANCE;
    }

    //! @brief returns boolean to whether include non-orthogonal-contacts
    //! @return boolean to whether include non-orthogonal-contacts
    bool CollectorSSEPaired::GetOrthogonalConnection() const
    {
      return m_ConsiderOrthogonalConnection;
    }

    //! @brief sets boolean to whether include non-orthogonal-contacts
    //! @param ORTHOGONAL_CONNECTION boolean to whether include non-orthogonal-contacts
    void CollectorSSEPaired::SetOrthogonalConnection( const bool ORTHOGONAL_CONNECTION)
    {
      m_ConsiderOrthogonalConnection = ORTHOGONAL_CONNECTION;
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorSSEPaired::GetAlias() const
    {
      static const std::string s_alias( "CollectorSSEPaired");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorSSEPaired::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects all paired SSEs.");
      serializer.AddInitializer
      (
        "packing picker",
        "picker for protein geometries",
        io::Serialization::GetAgent( &m_PackingPicker)
      );
      serializer.AddInitializer
      (
        "contact types",
        "types of contacts to consider",
        io::Serialization::GetAgent( &m_ContactTypes)
      );
      serializer.AddInitializer
      (
        "max distance",
        "maximum distance between SSEs to be considered paired",
        io::Serialization::GetAgent( &m_MaxDistance)
      );
      serializer.AddInitializer
      (
        "orthogonal",
        "include orthogonal connections",
        io::Serialization::GetAgent( &m_ConsiderOrthogonalConnection)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief returns the SSEs which are paired in the domain argument
    //! @param SSE_DOMAIN domain from which paired SSEs will be collected
    //! @return returns List of pair of paired sses
    storage::List< storage::VectorND< 2, util::SiPtr< const SSE> > >
    CollectorSSEPaired::Collect( const DomainInterface &SSE_DOMAIN) const
    {
      // get vector of sses from the protein model
      const util::SiPtrVector< const SSE> sse_vector( SSE_DOMAIN.GetSSEs());

      // initialize paired_sses container
      storage::List< storage::VectorND< 2, util::SiPtr< const SSE> > > paired_sses;

      // iterate through "sse_vector"
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr_a( sse_vector.Begin()), sse_itr_end( sse_vector.End());
        sse_itr_a != sse_itr_end;
        ++sse_itr_a
      )
      {
        // iterate through "sse_vector"
        for
        (
          util::SiPtrVector< const SSE>::const_iterator sse_itr_b( sse_itr_a + 1);
          sse_itr_b != sse_itr_end;
          ++sse_itr_b
        )
        {
          // create SSEGeometryPacking "current_packing" from sse pair
          const SSEGeometryPacking this_pack
          (
            ( *m_PackingPicker)->operator ()( **sse_itr_a, **sse_itr_b)
          );

          // if this packing has the correct type, distance below the threshold and is orthogonal if required
          if
          (
            m_ContactTypes.Find( this_pack.GetContactType()) != m_ContactTypes.End() &&
            this_pack.GetShortestConnection().GetLength() <= m_MaxDistance &&
            ( !m_ConsiderOrthogonalConnection || this_pack.GetOrthogonalConnection())
          )
          {
            // insert into paired_sses
            paired_sses.PushBack( storage::VectorND< 2, util::SiPtr< const SSE> >( **sse_itr_a, **sse_itr_b));
          }
        }
      }

      // return
      return paired_sses;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_sse_size.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain_interface.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorSSESize::s_Instance
    (
      util::Enumerated< find::CollectorInterface< util::SiPtrList< const SSE>, DomainInterface> >::AddInstance
      (
        new CollectorSSESize( math::Range< size_t>( 0, util::GetUndefined< size_t>()))
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from sse size range, applies to all SSTypes
    //! @param SIZE_RANGE size range for sse sequence length
    CollectorSSESize::CollectorSSESize( const math::Range< size_t> &SIZE_RANGE) :
      m_SizeRangeMap()
    {
      m_SizeRangeMap[ biol::GetSSTypes().HELIX]  = SIZE_RANGE;
      m_SizeRangeMap[ biol::GetSSTypes().STRAND] = SIZE_RANGE;
      m_SizeRangeMap[ biol::GetSSTypes().COIL]   = SIZE_RANGE;
    }

    //! @brief map of SSTypes and corresponding size ranges
    //! @param SIZE_RANGE_MAP size range for sse sequence length
    CollectorSSESize::CollectorSSESize( const storage::Map< biol::SSType, math::Range< size_t> > &SIZE_RANGE_MAP) :
      m_SizeRangeMap( SIZE_RANGE_MAP)
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorSSESize
    CollectorSSESize *CollectorSSESize::Clone() const
    {
      return new CollectorSSESize( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorSSESize::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorSSESize::GetAlias() const
    {
      static const std::string s_alias( "CollectorSSESize");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorSSESize::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects SSEs with specified sizes.");
      serializer.AddInitializer
      (
        "size map",
        "size ranges for each SSE type",
        io::Serialization::GetAgent( &m_SizeRangeMap)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief collect all sses from domain that fulfill the desired size range
    //! @param SSE_DOMAIN domain to collect from
    //! @return sses is a SiPtrList that have a sequence length according to range
    util::SiPtrList< const SSE> CollectorSSESize::Collect( const DomainInterface &SSE_DOMAIN) const
    {
      // initialize collected SSEs list
      util::SiPtrList< const SSE> collected_sses;

      // get all SSEs from the domain
      util::SiPtrVector< const SSE> domain_sses( SSE_DOMAIN.GetSSEs());

      // iterate over domain sses
      for
      (
        util::SiPtrVector< const SSE>::const_iterator itr( domain_sses.Begin()), itr_end( domain_sses.End());
        itr != itr_end;
        ++itr
      )
      {
        // check to find if there is range for this SSE
        storage::Map< biol::SSType, math::Range< size_t> >::const_iterator range_itr
        (
          m_SizeRangeMap.Find( ( *itr)->GetType())
        );

        // if range not found continue
        if( range_itr == m_SizeRangeMap.End())
        {
          continue;
        }

        // if sequence length is with range
        if( range_itr->second.IsWithin( ( *itr)->GetSize()))
        {
          collected_sses.PushBack( *itr);
        }
      }

      // end
      return collected_sses;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_sse_unpaired.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "io/bcl_io_serialization.h"
#include "restraint/bcl_restraint_group.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> CollectorSSEUnpaired::s_Instance
    (
      GetObjectInstances().AddInstance( new CollectorSSEUnpaired())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorSSEUnpaired::CollectorSSEUnpaired()
    {
    }

    //! @brief constructor taking a contact type
    //! @param CONTACT_TYPE is the contact type for which an SSE not having it is desired
    CollectorSSEUnpaired::CollectorSSEUnpaired
    (
      const contact::Type &CONTACT_TYPE, const double MAX_DISTANCE
    ) :
      m_ContactType( CONTACT_TYPE),
      m_MaxDistance( MAX_DISTANCE)
    {
    }

    //! @brief Clone is the virtual Clone constructor
    //! @return a pointer to new LocatorSSEFurthest which is a copy of this
    CollectorSSEUnpaired *CollectorSSEUnpaired::Clone() const
    {
      return new CollectorSSEUnpaired( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorSSEUnpaired::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetContactType gives the type of SSE contact of interest
    //! @return returns "m_ContactType" which is the contact type that the locator searches for SSEs not having
    const contact::Type &CollectorSSEUnpaired::GetContactType() const
    {
      // return "m_ContactType"
      return m_ContactType;
    }

    //! @brief SetContactType changes the type of SSE contact of interest
    //! @param CONTACT_TYPE is the new type of contact that will be searched for SSEs not having
    void CollectorSSEUnpaired::SetContactType( const contact::Type &CONTACT_TYPE)
    {
      // set "m_ContactType" to "CONTACT_TYPE"
      m_ContactType = CONTACT_TYPE;
    }

    //! @brief GetMaxDistance gives the maximum distance between SSEs for them to still be considered paired
    //! @return returns "m_MaxDistance" the maximum distance between SSEs for them to still be considered paired
    double CollectorSSEUnpaired::GetMaxDistance() const
    {
      // return "m_MaxDistance"
      return m_MaxDistance;
    }

    //! @brief SetMaxDistance changes the type of SSE contact of interest
    //! @param MAX_DISTANCE is the new maximum distance between SSEs for them to still be considered paired
    void CollectorSSEUnpaired::SetMaxDistance( const double MAX_DISTANCE)
    {
      // set "m_MaxDistance" to "MAX_DISTANCE"
      m_MaxDistance = MAX_DISTANCE;
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &CollectorSSEUnpaired::GetAlias() const
    {
      static const std::string s_name( "CollectorSSEUnpaired");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorSSEUnpaired::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collects all unpaired SSEs in a domain.");
      serializer.AddInitializer
      (
        "contact type",
        "SSEs not having this contact are collected",
        io::Serialization::GetAgent( &m_ContactType)
      );
      serializer.AddInitializer
      (
        "maximum distance",
        "maximum distance between SSEs to still be considered paired",
        io::Serialization::GetAgent( &m_MaxDistance)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Collect returns the SSEs which are unpaired in the domain argument
    //! @param SSE_DOMAIN domain from which unpaired SSEs will be collected
    //! @return returns SiPtrList of the collected unpaired SSE objects
    util::SiPtrList< const SSE> CollectorSSEUnpaired::Collect( const DomainInterface &SSE_DOMAIN) const
    {
      // create Vector3D "protein_center" and initialize with the coordinates of the center of "PROTEIN_MODEL"
      linal::Vector3D protein_center( SSE_DOMAIN.GetCenter());

      // create SiPtrVector "sse_vector" and initialize to all the SSEs that could be involved in "m_ContactType"
      util::SiPtrVector< const SSE> sse_vector( SSE_DOMAIN.GetSSEs( m_ContactType->GetSSTypes()));

      // create SiPtrList "unpaired_sses"
      util::SiPtrList< const SSE> unpaired_sses;

      // iterate through "sse_vector"
      for
      (
        storage::Vector< util::SiPtr< const SSE> >::const_iterator
          sse_itr_a( sse_vector.Begin()), sse_itr_end( sse_vector.End());
        sse_itr_a != sse_itr_end;
        ++sse_itr_a
      )
      {
        // boolean to indicate whether current sse is paired or not
        bool is_paired( false);

        // iterate through "sse_vector"
        for
        (
          storage::Vector< util::SiPtr< const SSE> >::const_iterator sse_itr_b( sse_vector.Begin());
          sse_itr_b != sse_itr_end;
          ++sse_itr_b
        )
        {
          if( sse_itr_a != sse_itr_b)
          {
            // check that the distance between SSEs denoted by "sse_itr_a" and "sse_itr_b" is less than or equal to
            // "m_MaxDistance"
            if( linal::Distance( ( *sse_itr_a)->GetCenter(), ( *sse_itr_b)->GetCenter()) <= m_MaxDistance)
            {
              // create SSEGeometryPacking "current_packing"; initialize with SSEs denoted by  "sse_itr_a" and "sse_itr_b"
              SSEGeometryPacking current_packing( **sse_itr_a, **sse_itr_b);

              // check if the SSEs denoted by "sse_itr" and "sse_itr_b" are paired together with type "m_ContactType"
              if( current_packing.GetContactType() == m_ContactType)
              {
                // SSE of "sse_itr" has correct pairing so set "is_paired" to true
                is_paired = true;
                // SSE of "sse_itr" has correct pairing so no need to check it with other SSEs
                break;
              }
            }
          }
        }
        // check if SSE denoted by "sse_itr_a" was not found to be correctly paired with any other SSE
        if( !is_paired)
        {
          // SSE denoted by "sse_itr" does not have "m_ContactType" pairing with any SSEs so add to "unpaired_sses"
          unpaired_sses.PushBack( **sse_itr_a);
        }
      }

      // return "unpaired_sses"
      return unpaired_sses;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &CollectorSSEUnpaired::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_ContactType, ISTREAM);
      io::Serialize::Read( m_MaxDistance, ISTREAM);

      // return
      return ISTREAM;
    }

    //! @brief read from std::ostream
    //! @param OSTREAM input stream
    //! @param INDENT indentation
    //! @return ostream which was read from
    std::ostream &CollectorSSEUnpaired::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ContactType, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MaxDistance, OSTREAM, INDENT);

      // return
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_topology_combined.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_topology_sheet.h"
#include "assemble/bcl_assemble_sse_geometry_packing_criteria.h"
#include "assemble/bcl_assemble_sse_geometry_packing_pickers.h"
#include "assemble/bcl_assemble_topology.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorTopologyCombined::s_Instance
    (
      util::Enumerated< CollectorTopologyInterface>::AddInstance( new CollectorTopologyCombined())
    );

    //! @brief return packing criteria function
    //! @return packing criteria function
    const util::ShPtr
    <
      math::FunctionInterfaceSerializable< SSEGeometryPacking, bool>
    > &CollectorTopologyCombined::GetPackingCriteria()
    {
      // initialize static criteria function
      static const util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> > s_default_criteria
      (
        new SSEGeometryPackingCriteriaCombine
        (
          util::ShPtrVector< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >::Create
          (
            util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >
            (
              new SSEGeometryPackingCriteriaDistancePerType()
            ),
            util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >
            (
              new SSEGeometryPackingCriteriaInteractionWeight
              (
                0.5, math::Comparisons< double>::GetEnums().e_GreaterEqual
              )
            )
          )
        )
      );

      // end
      return s_default_criteria;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from members
    //! @param INCLUDE_UNPACKED_GEOMETRIES whether to include unpacked geometries in the topologies
    CollectorTopologyCombined::CollectorTopologyCombined( const bool INCLUDE_UNPACKED_GEOMETRIES) :
      m_IncludeUnpackedGeometries( INCLUDE_UNPACKED_GEOMETRIES)
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorCombinedTopology
    CollectorTopologyCombined *CollectorTopologyCombined::Clone() const
    {
      return new CollectorTopologyCombined( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorTopologyCombined::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorTopologyCombined::GetAlias() const
    {
      static const std::string s_alias( "CollectorTopologyCombined");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorTopologyCombined::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Determines complete topology of a protein");
      serializer.AddInitializer
      (
        "include unpacked",
        "include unpacked geometries in the topologies",
        io::Serialization::GetAgent( &m_IncludeUnpackedGeometries),
        "true"
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Collect returns all topologies in the given geometry vector
    //! @param GEOMETRY_VECTOR Vector of geometries of interest
    //! @return returns ShPtrVector of topologies found in the given geometry vector
    util::ShPtrVector< Topology> CollectorTopologyCombined::Collect
    (
      const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR
    ) const
    {
      return CalculateTopology( GEOMETRY_VECTOR).GetSubTopologies();
    }

    //! @calculate the topology, which may contain isolated sub-topologies
    //! @param GEOMETRY_VECTOR Vector of geometries of interest
    //! @return calculated topology
    Topology CollectorTopologyCombined::CalculateTopology
    (
      const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR
    ) const
    {
      // get the helix and strand geometries
      util::SiPtrVector< const SSEGeometryInterface> helices;
      util::SiPtrVector< const SSEGeometryInterface> strands;
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator itr( GEOMETRY_VECTOR.Begin()),
          itr_end( GEOMETRY_VECTOR.End());
        itr != itr_end; ++itr
      )
      {
        if( ( *itr)->GetType() == biol::GetSSTypes().HELIX)
        {
          helices.PushBack( *itr);
        }
        else if( ( *itr)->GetType() == biol::GetSSTypes().STRAND)
        {
          strands.PushBack( *itr);
        }
      }

      // build a graph using sheet packing pickers
      Topology::GraphType graph_sheet
      (
        Topology::BuildTopologyGraphFromGeometries
        (
          strands,
          GetSSEGeometryPackingPickers().e_BestStrandPairing,
          *CollectorTopologySheet::GetPackingCriteria()
        )
      );

      // if removing unpacked geometries
      if( !m_IncludeUnpackedGeometries && strands.GetSize() > 1)
      {
        util::SiPtrVector< const SSEGeometryInterface> filtered_strands;

        // iterate over the strands
        for
        (
          util::SiPtrVector< const SSEGeometryInterface>::const_iterator strand_itr( strands.Begin()),
            strand_itr_end( strands.End());
          strand_itr != strand_itr_end; ++strand_itr
        )
        {
          // find the corresponding vertex
          const util::ShPtr< Topology::GraphType::VertexType> vertex
          (
            graph_sheet.FindVertex( *strand_itr)
          );

          // if the vertex has no edges
          if( vertex->GetDegree() == 0)
          {
            // delete it from the graph
            graph_sheet.DeleteVertex( vertex);
          }
          // if it has edges
          else
          {
            // add to filtered vector
            filtered_strands.PushBack( *strand_itr);
          }
        }

        strands = filtered_strands;
      }

      // combine the geometries
      util::SiPtrVector< const SSEGeometryInterface> combined_geometries( strands);
      combined_geometries.Append( helices);

      // build a graph from Fold template setting
      Topology::GraphType graph_fold
      (
        Topology::BuildTopologyGraphFromGeometries
        (
          combined_geometries,
          GetSSEGeometryPackingPickers().e_BestInteractionWeight,
          *GetPackingCriteria()
        )
      );

      // if there are no edges then return graph_fold
      if( graph_sheet.GetNumberEdges() == 0)
      {
        return Topology( graph_fold);
      }

      // now we need to overwrite the edges in the graph_fold for which there is an edge in the sheet graph
      // for this, we need to iterate over all the edges in the sheet
      for
      (
        Topology::GraphType::VertexContainerType::const_iterator
          vertex_itr( graph_sheet.GetVertices().Begin()), vertex_itr_end( graph_sheet.GetVertices().End());
        vertex_itr != vertex_itr_end; ++vertex_itr
      )
      {
        // create ref on vertex
        const Topology::GraphType::VertexType &vertex_a( **vertex_itr);

        // iterate over the edges for this vertex
        for
        (
          Topology::GraphType::EdgeContainerType::const_iterator
            edge_itr( vertex_a.GetEdges().Begin()), edge_itr_end( vertex_a.GetEdges().End());
          edge_itr != edge_itr_end; ++edge_itr
        )
        {
          // create ref on the vertex_b
          const Topology::GraphType::VertexType &vertex_b( *edge_itr->GetTarget());

          // now delete the edge in the graph_fold, if the edge does not exists it won't do anything
          graph_fold.DeleteEdge( vertex_a.GetData(), vertex_b.GetData());

          // now insert the sheet packing information with a new edge
          graph_fold.AddEdge( vertex_a.GetData(), vertex_b.GetData(), edge_itr->GetData());
        }
      }

      // if removing unpacked geometries
      if( !m_IncludeUnpackedGeometries)
      {
        graph_fold.DeleteUnconnectedVertices();
      }

      // end
      return Topology( graph_fold);
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_collector_topology_sheet.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_geometry_packing_compare.h"
#include "assemble/bcl_assemble_sse_geometry_packing_criteria.h"
#include "assemble/bcl_assemble_sse_geometry_packing_pickers.h"
#include "assemble/bcl_assemble_topology.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! maximum distance to identify as strand strand pairing
    const double CollectorTopologySheet::s_MaximumDistance( 7.0);

    //! minimum relative position weight needed to be identified as strand strand pairing
    const double CollectorTopologySheet::s_MinimumStrandStrandPairingWeight( 0.5);

    //! @brief return packing criteria function
    //! @return packing criteria function
    const util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> > &
    CollectorTopologySheet::GetPackingCriteria()
    {
      // construct the vector of criteria vector
      static const util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> > s_packing_criteria
      (
        new SSEGeometryPackingCriteriaCombine
        (
          util::ShPtrVector< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >::Create
          (
            util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >
            (
              new SSEGeometryPackingCriteriaContactType( contact::GetTypes().STRAND_STRAND)
            ),
            util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >
            (
              new SSEGeometryPackingCriteriaDistance( s_MaximumDistance, math::Comparisons< double>::GetEnums().e_LessEqual)
            ),
            util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >
            (
              new SSEGeometryPackingCriteriaStrandWeight
              (
                s_MinimumStrandStrandPairingWeight, math::Comparisons< double>::GetEnums().e_GreaterEqual
              )
            )
          )
        )
      );

      // end
      return s_packing_criteria;
    }

    //! @brief return packing comparison function
    //! @return packing comparison function
    const util::ShPtr< math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> > &
    CollectorTopologySheet::GetPackingComparison()
    {
      // initialize the static instance of the packer
      static const util::ShPtr< math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> >
      s_packing_comparison
      (
        new SSEGeometryPackingCompareInteractionWeight()
      );

      // end
      return s_packing_comparison;
    }

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> CollectorTopologySheet::s_Instance
    (
      util::Enumerated< CollectorTopologyInterface>::AddInstance( new CollectorTopologySheet())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    CollectorTopologySheet::CollectorTopologySheet()
    {
    }

    //! @brief Clone function
    //! @return pointer to new CollectorSheetTopology
    CollectorTopologySheet *CollectorTopologySheet::Clone() const
    {
      return new CollectorTopologySheet( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &CollectorTopologySheet::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &CollectorTopologySheet::GetAlias() const
    {
      static const std::string s_alias( "CollectorTopologySheet");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer CollectorTopologySheet::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Collect sheet topologies");

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Collect returns all beta-sheet topologies in the given geometry vector
    //! @param GEOMETRY_VECTOR Vector of geometries of interest
    //! @return returns ShPtrVector of beta-sheets found in the given geometry vector
    util::ShPtrVector< Topology> CollectorTopologySheet::Collect
    (
      const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR
    ) const
    {
      // construct sheet vector
      util::ShPtrVector< Topology> topology_vector;

      // get full topology
      const Topology full_topology( CalculateTopology( GEOMETRY_VECTOR));

      // return empty vector if no strands
      if( full_topology.GetElements().IsEmpty())
      {
        return topology_vector;
      }

      // now call the topology function
      topology_vector = full_topology.GetSubTopologies();

      // for each topology
      for
      (
        util::ShPtrVector< Topology>::iterator
          topology_itr( topology_vector.Begin()), topology_itr_end( topology_vector.End());
        topology_itr != topology_itr_end; ++topology_itr
      )
      {
        // create reference on this topology
        Topology &this_topology( **topology_itr);

        // try to order the geometries and store the return
        const bool is_valid_geometry( this_topology.OrderElements());

        // if not successful then skip this topology
        if( !is_valid_geometry)
        {
          continue;
        }

        // set the type
        this_topology.SetType
        (
          this_topology.GetElements().GetSize() > 2 &&
          this_topology.GetGraph().AreVerticesConnected
          (
            this_topology.GetElements().FirstElement(), this_topology.GetElements().LastElement()
          ) ?
            Topology::e_BetaBarrel : Topology::e_Sheet
        );

        // update the geometry
        this_topology.SetOrientationFromType();
      }

      // end
      return topology_vector;
    }

    //! @calculate the topology, which may contain isolated sub-topologies
    //! @param GEOMETRY_VECTOR Vector of geometries of interest
    //! @return calculated topology
    Topology CollectorTopologySheet::CalculateTopology
    (
      const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR
    ) const
    {
      // initialize strand vector
      util::SiPtrVector< const SSEGeometryInterface> strand_vector;

      // iterate over given geometries
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator
          geometry_itr( GEOMETRY_VECTOR.Begin()), geometry_itr_end( GEOMETRY_VECTOR.End());
        geometry_itr != geometry_itr_end; ++geometry_itr
      )
      {
        // if of type strand
        if( ( *geometry_itr)->GetType() == biol::GetSSTypes().STRAND)
        {
          // add it to the strand vector
          strand_vector.PushBack( *geometry_itr);
        }
      }

      // construct the topology and return
      return *Topology::BuildTopologyFromGeometries
      (
        strand_vector, GetSSEGeometryPackingPickers().e_BestStrandPairing, *GetPackingCriteria()
      );
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble.h"

// includes from bcl - sorted alphabetically
#include "util/bcl_util_class_descriptor.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

    //! @brief identifier for the name space
    //! @return the name of the namespace
    const std::string &GetNamespaceIdentifier()
    {
      static const std::string *s_namespace_name( new std::string( util::ExtractNamespaceIdentifier( __PRETTY_FUNCTION__)));
      return *s_namespace_name;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_domain.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> Domain::s_Instance
    (
      GetObjectInstances().AddInstance( new Domain())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    Domain::Domain() :
      m_Data(),
      m_Topology()
    {
    }

    //! @brief construct from a Set of ShPtr to SSEs
    //! @param SSE_SET Set of ShPtr to SSEs
    Domain::Domain( const storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> &SSE_SET) :
      m_Data( SSE_SET),
      m_Topology()
    {
    }

    //! @brief construct from a Set of ShPtr to SSEs and a corresponding topology
    //! @param SSE_SET Set of ShPtr to SSEs
    //! @param SP_TOPOLOGY ShPtr to corresponding Topology
    Domain::Domain
    (
      const storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> &SSE_SET,
      const util::ShPtr< Topology> &SP_TOPOLOGY
    ) :
      m_Data( SSE_SET),
      m_Topology( SP_TOPOLOGY)
    {
    }

    //! @brief construct from util::ShPtrVector of SSE
    //! @param SSE_VECTOR ShPtrVector of SSEs
    Domain::Domain( const util::ShPtrVector< SSE> &SSE_VECTOR) :
      m_Data(),
      m_Topology()
    {
      // iterate over given vector of SSEs and insert them into the set m_Data
      for
      (
        util::ShPtrVector< SSE>::const_iterator sse_itr( SSE_VECTOR.Begin()),
          sse_itr_end( SSE_VECTOR.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        Insert( *sse_itr);
      }
    }

    //! @brief construct from util::ShPtrVector of SSE and a corresponding topology
    //! @param SSE_VECTOR ShPtrVector of SSEs
    //! @param SP_TOPOLOGY ShPtr to corresponding Topology
    Domain::Domain
    (
      const util::ShPtrVector< SSE> &SSE_VECTOR,
      const util::ShPtr< Topology> &SP_TOPOLOGY
    ) :
      m_Data(),
      m_Topology( SP_TOPOLOGY)
    {
      // iterate over given vector of SSEs and insert them into the set m_Data
      for
      (
        util::ShPtrVector< SSE>::const_iterator sse_itr( SSE_VECTOR.Begin()),
          sse_itr_end( SSE_VECTOR.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        Insert( *sse_itr);
      }
    }

    //! @brief copy constructor for domain
    //! @param DOMAIN_RHS Domain to be copied
    Domain::Domain( const Domain &DOMAIN_RHS) :
      m_Data( DOMAIN_RHS.m_Data),
      m_Topology( DOMAIN_RHS.m_Topology)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer to a new Domain instance copied from this one
    Domain *Domain::Clone() const
    {
      return new Domain( *this);
    }

    //! @brief virtual hard copy constructor
    //! @return pointer to a new Domain instance hard-copied from this one
    Domain *Domain::HardCopy() const
    {
      // make hard_ccopies of the SSEs
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> new_sses;

      // iterate over all sses
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // insert a hardcopy of the shared pointer to sse into the new domain
        new_sses.Insert( sse_itr->HardCopy());
      }

      // if a topology was defined
      if( m_Topology.IsDefined())
      {
        // create a new topology
        // this topology will only have the geometry since
        // the graph would need to point to new SSEs
        // and there is no guarantee they won't be changed at this point
        util::ShPtr< Topology> sp_new_topology( new Topology( m_Topology->GetOrientation()));

        // now create a domain topology with the SSEs and the topology
        Domain *hard_copy( new Domain( new_sses, sp_new_topology));
        // and return
        return hard_copy;
      }
      // if no topology
      else
      {
        // create a new domain only from the SSEs
        Domain *hard_copy( new Domain( new_sses));
        // and return
        return hard_copy;
      }
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &Domain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return all chain ids within that domain
    //! @return set of all chain ids
    storage::Set< char> Domain::GetChainIds() const
    {
      storage::Set< char> chain_ids;
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        chain_ids.Insert( ( *sse_itr)->GetChainID());
      }

      return chain_ids;
    }

    //! @brief return number of SSE of specified SSTYPE
    //! @param SS_TYPE specific SSTYPE
    //! @return number of SSE of specified SSTYPE
    size_t Domain::GetNumberSSE( const biol::SSType &SS_TYPE) const
    {
      // initialize count
      size_t number_sses( 0);

      //loop over all SSElements
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if of correct type increment
        number_sses += ( ( *sse_itr)->GetType() == SS_TYPE);
      }

      // end
      return number_sses;
    }

    //! @brief returns all SSEs in domain in a util::SiPtrVector
    //! @return all SSEs in domain in a util::SiPtrVector
    util::SiPtrVector< const SSE> Domain::GetSSEs() const
    {
      // construct a SiPtrVector of const SSEs and return it
      return util::SiPtrVector< const SSE>( m_Data.Begin(), m_Data.End());
    }

    //! @brief returns all SSEs in domain of given SSTYPE in a util::SiPtrVector
    //! @param SS_TYPE specific SSTYPE
    //! @return all SSEs in domain of given SSTYPE in a util::SiPtrVector
    util::SiPtrVector< const SSE> Domain::GetSSEs( const biol::SSType &SS_TYPE) const
    {
      // initialize vector of sses
      util::SiPtrVector< const SSE> sses;

      //loop over all SSElements
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if SSE behind sse_itr is of given SSTYPE
        if( ( *sse_itr)->GetType() == SS_TYPE)
        {
          // insert it into the list of SSEs to be returned
          sses.PushBack( util::SiPtr< const SSE>( *sse_itr));
        }
      }

      return sses;
    }

    //! @brief returns the number of amino acids in the chain
    //! @return the number of amino acids in the chain
    size_t Domain::GetNumberAAs() const
    {
      // initialize size of chain
      size_t size( 0);

      // iterate over SSEs and get their size
      for
      (
        auto sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        size += ( *sse_itr)->GetData().GetSize();
      }

      return size;
    }

    //! @brief concatenates sequences of all sses fills in the gaps with unknown AAs and returns this AASequence
    //! @return AASequence created by concatenating sequences of all sses and filling in the gaps with unknown AAs
    util::ShPtr< biol::AASequence> Domain::CreateSequenceFromSSEs() const
    {
      BCL_Assert( !m_Data.IsEmpty(), "It is not possible to create Sequence from 0 SSEs!!!");

      // initialize this sequence
      util::ShPtr< biol::AASequence> this_sequence( new biol::AASequence());
      const char chain_id( ( *m_Data.Begin())->GetChainID());

      // set the chainid to the chainid of the first sse
      this_sequence->SetChainID( chain_id);
      int last_seqid( 1);

      // iterate over sses
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make sure the chainid of this SSE is same with the previous ones
        BCL_Assert
        (
          ( *sse_itr)->GetChainID() == chain_id,
          "This sse's chainid(" + util::Format()( ( *sse_itr)->GetChainID()) +
          ") does not match the sequence's chainid(" + util::Format()( chain_id) + ")!!"
        );

        // iterate over skipped residues from the end of last sse to the beginning of this sse
        for( int seq_id( last_seqid), begin_sse( ( *sse_itr)->GetFirstAA()->GetSeqID()); seq_id < begin_sse; ++seq_id)
        {
          util::ShPtr< biol::AAData> sp_aa_data
          (
            new biol::AAData
            (
              biol::GetAATypes().e_Undefined,
              seq_id,
              util::GetUndefined< int>(), // pdb id is unknown, since the amino acids added to the loop are not actually read in from a pdb
              biol::AAData::s_DefaultPdbICode,
              chain_id
            )
          );
          util::ShPtr< biol::AABase> new_aa( ( *( *sse_itr)->GetFirstAA()->GetAAClass())->Empty( sp_aa_data));
          // insert unknown residues with the corresponding seqid
          this_sequence->PushBack( new_aa);
        }

        // now append the sequence of this sse
        this_sequence->AppendSequence( **sse_itr);

        // update the last_seqid
        last_seqid = ( *sse_itr)->GetLastAA()->GetSeqID() + 1;
      }

      // return the created sequence
      return this_sequence;
    }

    //! @brief returns the geometric center of the object
    //! @return the geometric center of the object
    linal::Vector3D Domain::GetCenter() const
    {
      // if the topology is defined
      if( m_Topology.IsDefined())
      {
        return m_Topology->GetCenter();
      }

      // otherwise return center
      return coord::CenterOfMass( GetAtomCoordinates());
    }

    //! @brief return the orientation of the object
    //! @return orientation
    linal::Vector3D Domain::GetAxis( const coord::Axis &AXIS) const
    {
      // if the topology is defined
      if( m_Topology.IsDefined())
      {
        return m_Topology->GetAxis( AXIS);
      }

      // otherwise return center
      linal::Vector3D axis;
      axis( AXIS) = 1.0;

      return axis;
    }

    //! @brief return the orientation and Position as TransformationMatrix3D
    //! @return TransformationMatrix3D that defines orientation and position
    const math::TransformationMatrix3D Domain::GetOrientation() const
    {
      // if the topology is defined
      if( m_Topology.IsDefined())
      {
        return m_Topology->GetOrientation();
      }

      // otherwise return center
      return math::TransformationMatrix3D( GetCenter());
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief translates the coordinates of all SSEs by the supplied translation vector
    //! @param TRANSLATION_VECTOR_3D Translation vector to be applied
    void Domain::Translate( const linal::Vector3D &TRANSLATION_VECTOR_3D)
    {
      //loop over all secondary structure elements and transform them
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make a copy of the ShPtr
        util::ShPtr< SSE> this_sse( *sse_itr);

        // translate this_sse
        this_sse->Translate( TRANSLATION_VECTOR_3D);
      }
    }

    //! @brief transforms the coordinates of all SSEs according to given transformation matrix
    //! @param TRANSFORMATION_MATRIX_3D transformation matrix to be applied
    void Domain::Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
    {
      //loop over all secondary structure elements and transform them
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make a copy of the ShPtr
        util::ShPtr< SSE> this_sse( *sse_itr);

        // transform this_sse
        this_sse->Transform( TRANSFORMATION_MATRIX_3D);
      }
    }

    //! @brief rotate the SSE by a given rotation matrix
    //! @param ROTATION_MATRIX_3D rotation matrix to be applied
    void Domain::Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
    {
      //loop over all secondary structure elements and transform them
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make a copy of the ShPtr
        util::ShPtr< SSE> this_sse( *sse_itr);

        // transform this_sse
        this_sse->Rotate( ROTATION_MATRIX_3D);
      }
    }

    //! @brief pushback a util::ShPtr< SSE> to m_Data
    //! @param SSELEMENT ShPtr to SSE to be inserted
    //! @return whether insertion succeeded
    bool Domain::Insert( const util::ShPtr< SSE> &SSELEMENT)
    {
      // call insert function of the set, it will take care if there are overlap and return false
      return m_Data.Insert( SSELEMENT).second;
    }

    //! @brief pushback a vector SSEs
    //! @param SSE_VECTOR Vector of SSEs to be added
    //! @return whether insertion succeeded
    bool Domain::Insert( const util::ShPtrVector< SSE> &SSE_VECTOR)
    {
      // initalize boolean success
      bool success( true);

      // iterate over the  SSEs
      for
      (
        util::ShPtrVector< SSE>::const_iterator sse_itr( SSE_VECTOR.Begin()), sse_itr_end( SSE_VECTOR.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        success &= Insert( *sse_itr);
      }

      // end
      return success;
    }

    //! @brief insert the SSEs from the given domain
    //! @param NEW_DOMAIN Domain from which SSEs should be inserted
    //! @return whether insertion was successful
    bool Domain::Insert( const Domain &NEW_DOMAIN)
    {
      // initalize boolean success
      bool success( true);

      // iterate over the  SSEs
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          sse_itr( NEW_DOMAIN.GetData().Begin()), sse_itr_end( NEW_DOMAIN.GetData().End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        success &= m_Data.Insert( *sse_itr).second;
      }

      // end
      return success;
    }

    //! @brief replace the given SP_SSE with already existing one
    //! @param SP_SSE ShPtr pointing to the SSE to be replaced
    bool Domain::Replace( const util::ShPtr< SSE> &SP_SSE)
    {
      // search for this sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompare( *SP_SSE)
        )
      );

      // if such an sse is found
      if( itr != m_Data.End())
      {
        // remove this sse
        m_Data.RemoveElement( itr);

        // insert the new sse
        m_Data.Insert( SP_SSE);

        // return
        return true;
      }

      // if not found do nothing and return false
      return false;
    }

    //! @brief replace all SSEs that overlap with SP_SSE with SP_SSE
    //! @param SP_SSE ShPtr to SSE to be inserted
    //! @return whether replacement succeeded
    bool Domain::ReplaceWithOverlapping( const util::ShPtr< SSE> &SP_SSE)
    {
      // search for overlapping sses with SP_SSE using equal_range
      std::pair
      <
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator,
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator
      > itr_pair
      (
        std::equal_range
        (
          m_Data.Begin(),
          m_Data.End(),
          SP_SSE,
          SSELessThanNoOverlap()
        )
      );

      // if such an sse is found
      if( itr_pair.first != m_Data.End())
      {
        // remove the sses in the range
        m_Data.Erase( itr_pair.first, itr_pair.second);

        // insert the new sse
        m_Data.Insert( SP_SSE);

        // return
        return true;
      }

      BCL_MessageCrt
      (
        "ReplaceWithOverlapping has been called with a sse that is not overlapping!"
      );

      // if not found do nothing and return false
      return false;
    }

    //! @brief remove given SSELEMENT from the domain
    //! @param SSELEMENT SSE to be removed
    bool Domain::Remove( const SSE &SSELEMENT)
    {
      // search for this sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompare( SSELEMENT)
        )
      );

      // if such an sse is found
      if( itr != m_Data.End())
      {
        // remove this sse
        m_Data.RemoveElement( itr);

        // return
        return true;
      }

      // if not found do nothing and return false
      return false;
    }

    //! @brief sets positions of all SSEs to ideal conformation w/wo superimposing with prior coordinates
    //! @param KEEP_POSITION flag to indicate whether to original body information of SSEs should be reserved
    void Domain::SetToIdealConformation( const bool KEEP_POSITION)
    {
      //set each sse to ideal conformation
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // make a non-const ShPtr to this SSE since Set does not allow non-const iterators
        util::ShPtr< SSE> this_sse( *sse_itr);

        if( KEEP_POSITION)
        {
          this_sse->SetToIdealConformationInPlace();
        }
        else
        {
          this_sse->SetToIdealConformationAtOrigin();
        }
      }
    }

    //! @brief chop all sselements of that model in pieces of the sizes defined by MIN_SSE_LENGTHS
    //! @param MIN_SSE_LENGTHS VectorND of sizes that defined min size for each SSType
    void Domain::ChopSSEs( const storage::VectorND< 3, size_t> &MIN_SSE_LENGTHS)
    {
      // instatiate set of chopped_sse
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> chopped_sses;

      //iterate over all sselements
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // chop this sse and insert into new set of sses
        chopped_sses.InsertElements( ( *sse_itr)->Chop( MIN_SSE_LENGTHS( ( *sse_itr)->GetType())));
      }

      //set m_Model to new chopped elements
      m_Data = chopped_sses;
    }

    //! @brief find and to return the ShPtr for the given SSE
    //! @param SSE_TO_SEARCH SSE of interest
    //! @return ShPtr to corresponding SSE, otherwise an empty ShPtr
    const util::ShPtr< SSE> &Domain::FindSSE( const SSE &SSE_TO_SEARCH) const
    {
      // static undefined SSE ptr
      static const util::ShPtr< SSE> s_undefined_sse_ptr;

      // search for this sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompare( SSE_TO_SEARCH)
        )
      );

      // if such an sse is found
      if( itr != m_Data.End())
      {
        // return the ShPtr
        return *itr;
      }

      // otherwise return empty ShPtr
      return s_undefined_sse_ptr;
    }

    //! @brief checks if domain already contains THIS_SSE
    //! @param THIS_SSE SSE of interest
    //! @return whether domain already contains THIS_SSE
    bool Domain::DoesContain( const SSE &THIS_SSE) const
    {
      // search for this sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompare( THIS_SSE)
        )
      );

      // return if it's found
      return ( itr != m_Data.End());
    }

    //! @brief checks if domain already contains this THIS_SSE or any overlapping SSE with THIS_SSE
    //! @param THIS_SSE SSE to be searched for
    //! @return if domain already contains this THIS_SSE or any overlapping SSE with THIS_SSE
    bool Domain::DoesContainOverlapping( const SSE &THIS_SSE) const
    {
      // search for this sse or any overlapping sse in m_Data
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator itr
      (
        std::find_if
        (
          m_Data.Begin(),
          m_Data.End(),
          SSECompareOverlap( THIS_SSE)
        )
      );

      // return if it's found
      return ( itr != m_Data.End());
    }

    //! @brief join following ( progressing sequence id) SSEs of given SS_TYPE into one SSE
    //! @param SS_TYPE SSType of interest
    void Domain::Join( const biol::SSType &SS_TYPE)
    {
      if( GetNumberSSE( SS_TYPE) < 2)
      {
        return;
      }

      // new sses after joining
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> joined_sses;

      //set each sse to ideal conformation
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator
      sse_itr( m_Data.Begin()), sse_itr_next( m_Data.Begin()), sse_itr_end( m_Data.End());
      ++sse_itr_next;

      // store the current SSE
      util::ShPtr< SSE> current_sse( ( *sse_itr));

      // initialize a boolean
      bool last_sse_joinable( false);

      // iterate until anyone of the iterators hit the end
      while( sse_itr_next != sse_itr_end && sse_itr != sse_itr_end)
      {

        // if this SSE is of specified type as well as the next SSE and they have no loop residues in between
        if
        (
          current_sse->GetType() == SS_TYPE
          && current_sse->GetType() == ( *sse_itr_next)->GetType()
          && ( current_sse->GetLastAA()->GetSeqID() + 1) == ( *sse_itr_next)->GetFirstAA()->GetSeqID())
        {
          // update the sequence of the current SSE by appending the sequence of the next SSE that is connected
          current_sse->AppendSequence( ( **sse_itr_next));

          // set the flag
          last_sse_joinable = true;

          // move to next SSE
          ++sse_itr_next;
        }
        // if next SSE is not connected
        else
        {
          // but the previous pair of SSEs were connected
          if( last_sse_joinable)
          {
            // update the geometry
            current_sse->SetGeometry();
            // set the flag back
            last_sse_joinable = false;
          }

          // insert the SSE joined or not into the new list of SSEs
          joined_sses.Insert( current_sse);

          // update the iterators
          current_sse = *sse_itr_next;
          sse_itr = sse_itr_next;
          ++sse_itr_next;
        }
      }

      // if the last SSE was connected
      if( last_sse_joinable)
      {
        // update geoemtry
        current_sse->SetGeometry();
      }
      // insert the last SSE into new list of SSEs
      joined_sses.Insert( current_sse);

      // update the data
      m_Data = joined_sses;
    }

    //! @brief filters the current chain by given minimum SSE sizes
    //! @param MIN_SSE_SIZES minimum SSE sizes to filter the chain by
    void Domain::FilterByMinSSESizes( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES)
    {
      // create a new set to store sses
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> filtered_sses;

      // iterate over the SSEs
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator
          sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        storage::Map< biol::SSType, size_t>::const_iterator
          type_itr( MIN_SSE_SIZES.Find( ( *sse_itr)->GetType()));

        // if this SSE is one of the specified types in the given map and
        // if this SSE has a size larger than/equal to the specified size
        if
        (
          type_itr != MIN_SSE_SIZES.End() && ( *sse_itr)->GetSize() >= type_itr->second
        )
        {
          // insert it into filtered SSEs
          filtered_sses.Insert( *sse_itr);
        }
      }

      // update the SSE set with the filtered one
      m_Data = filtered_sses;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief equal operator
    //! @param DOMAIN_RHS Domain to be assigned to
    //! @return this domain after being assigned to DOMAIN_RHS
    Domain &Domain::operator =( const Domain &DOMAIN_RHS)
    {
      // set members
      m_Data = DOMAIN_RHS.m_Data;
      m_Topology = DOMAIN_RHS.m_Topology;

      // return
      return *this;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read Domain from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &Domain::Read( std::istream &ISTREAM)
    {
      //read member
      io::Serialize::Read( m_Data, ISTREAM);

      //end
      return ISTREAM;
    }

    //! @brief write Domain to std::ostream
    //! @param OSTREAM output stream
    //! @param INDENT indentation
    //! @return ostream which was written to
    std::ostream &Domain::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      //write Data
      io::Serialize::Write( m_Data, OSTREAM, INDENT);

      //end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_domain_interface.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_compare.h"
#include "assemble/bcl_assemble_sse_geometry.h"
#include "biol/bcl_biol_atom.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  /////////////////
  // data access //
  /////////////////

    //! @brief returns all SSEs in domain of given SSTYPE in a util::SiPtrVector
    //! @param SS_TYPE specific SSTYPE
    //! @return all SSEs in domain of given SSTYPE in a util::SiPtrVector
    util::SiPtrVector< const SSE> DomainInterface::GetSSEs( const biol::SSType &SS_TYPE) const
    {
      // initialize vector of sses
      util::SiPtrVector< const SSE> sses;

      // get and store all the SSEs
      const util::SiPtrVector< const SSE> all_sses_vector( GetSSEs());

      //loop over all SSElements
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( all_sses_vector.Begin()),
          sse_itr_end( all_sses_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if SSE behind sse_itr is of given SSTYPE
        if( ( *sse_itr)->GetType() == SS_TYPE)
        {
          // insert it into the list of SSEs to be returned
          sses.PushBack( util::SiPtr< const SSE>( *sse_itr));
        }
      }

      // end
      return sses;
    }

    //! @brief returns all SSEs in domain of given SSTYPEs in a util::SiPtrVector
    //! @param SS_TYPES set of sstypes
    //! @return all SSEs in domain of given SSTYPEs in a util::SiPtrVector
    util::SiPtrVector< const SSE> DomainInterface::GetSSEs( const storage::Set< biol::SSType> &SS_TYPES) const
    {
      // initialize vector of sses
      util::SiPtrVector< const SSE> sses;

      // get and store all the SSEs
      const util::SiPtrVector< const SSE> all_sses_vector( GetSSEs());

      //loop over all SSElements
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( all_sses_vector.Begin()),
          sse_itr_end( all_sses_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if SSE behind sse_itr is of given SSTYPE
        if( SS_TYPES.Contains( ( *sse_itr)->GetType()))
        {
          // insert it into the list of SSEs to be returned
          sses.PushBack( util::ToSiPtr( **sse_itr));
        }
      }

      // end
      return sses;
    }

    //! @brief return total number of sses
    //! @return total number of sses
    size_t DomainInterface::GetNumberSSEs() const
    {
      return GetSSEs().GetSize();
    }

    //! @brief return number of SSE of specified SSTYPE
    //! @param SS_TYPE specific SSTYPE
    //! @return number of SSE of specified SSTYPE
    size_t DomainInterface::GetNumberSSEs( const biol::SSType &SS_TYPE) const
    {
      // initialize count
      size_t sum( 0);

      // get and store the SSEs
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      //loop over all SSElements
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        sum += ( ( *sse_itr)->GetType() == SS_TYPE);
      }

      // end
      return sum;
    }

    //! @brief returns all atoms in domain as SiPtrVector
    //! @return all atoms in domain as SiPtrVector
    util::SiPtrVector< const biol::Atom> DomainInterface::GetAtoms() const
    {
      // initialize storage for atoms
      util::SiPtrVector< const biol::Atom> atoms;

      // get all SSEs first
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      //loop over all SSElements
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        atoms.Append( ( *sse_itr)->GetAtoms());
      }

      return atoms;
    }

    //! @brief returns all atoms of specified ATOM_TYPES in domain as SiPtrVector
    //! @param ATOM_TYPES Set of AtomTypes of interest
    //! @return all atoms of specified types in domain as SiPtrVector
    util::SiPtrVector< const biol::Atom>
    DomainInterface::GetAtoms
    (
      const storage::Set< biol::AtomType> &ATOM_TYPES
    ) const
    {
      //util::SiPtrVector of atoms
      util::SiPtrVector< const biol::Atom> atoms;

      // get all SSEs first
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      //loop over all SSElements
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // append the atoms of current SSE's atoms
        atoms.Append( ( *sse_itr)->GetAtoms( ATOM_TYPES));
      }

      //return
      return atoms;
    }

    //! @brief returns coordinates for all atoms in domain as SiPtrVector
    //! @return coordinates for all atoms in domain as SiPtrVector
    util::SiPtrVector< const linal::Vector3D> DomainInterface::GetAtomCoordinates() const
    {
      // util::SiPtrVector of positions
      util::SiPtrVector< const linal::Vector3D> positions;

      // get all SSEs first
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      //loop over all SSElements
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        positions.Append( ( *sse_itr)->GetAtomCoordinates());
      }

      //return
      return positions;
    }

    //! @brief returns coordinates for all atoms of specified ATOM_TYPES in domain as SiPtrVector
    //! @param ATOM_TYPES Set of AtomTypes of interest
    //! @return coordinates for all atoms of specified types in domain as SiPtrVector
    util::SiPtrVector< const linal::Vector3D>
    DomainInterface::GetAtomCoordinates
    (
      const storage::Set< biol::AtomType> &ATOM_TYPES
    ) const
    {
      //util::SiPtrVector of positions
      util::SiPtrVector< const linal::Vector3D> positions;

      // get all SSEs first
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      //loop over all SSElements
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // append the positions of current SSE's atoms
        positions.Append( ( *sse_itr)->GetAtomCoordinates( ATOM_TYPES));
      }

      //return
      return positions;
    }

    //! @brief returns the center of the domain
    //! @return the center of the domain
    linal::Vector3D DomainInterface::GetCenter() const
    {
      return coord::CenterOfMass( GetAtomCoordinates());
    }

    //! @brief return all the amino acids in all SSEs
    //! @return all the amino acids in all SSEs
    util::SiPtrVector< const biol::AABase> DomainInterface::GetAminoAcids() const
    {
      util::SiPtrVector< const biol::AABase> aminoacids;

      // get all SSEs first
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      // iterate over all SSEs in this domain
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // add the amino acids for this SSE
        aminoacids.Append( util::SiPtrVector< const biol::AABase>( ( *sse_itr)->GetData()));
      }

      return aminoacids;
    }

    //! @brief create and return SSEGeometries for all SSEs in this Domain
    //! @return ShPtrVector of SSEGeometries corresponding to SSEs in this domain
    util::ShPtrVector< SSEGeometry> DomainInterface::GetSSEGeometries() const
    {
      // initialize storage to return geometries
      util::ShPtrVector< SSEGeometry> geometries;

      // get all SSEs first
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      // iterate over all SSEs
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // construct a geometry from this SSE and add it to the vector
        geometries.PushBack( util::ShPtr< SSEGeometry>( new SSEGeometry( **sse_itr)));
      }

      // end
      return geometries;
    }

    //! @brief create and return SSEGeometries for all SSEs in this Domain
    //! @param SS_TYPE specific SSTYPE
    //! @return ShPtrVector of SSEGeometries corresponding to SSEs in this domain
    util::ShPtrVector< SSEGeometry> DomainInterface::GetSSEGeometries( const biol::SSType &SS_TYPE) const
    {
      // initialize storage to return geometries
      util::ShPtrVector< SSEGeometry> geometries;

      // get all SSEs first
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if this SSE is of the requested SS_TYPE
        if( ( *sse_itr)->GetType() == SS_TYPE)
        {
          // construct and append a new SSEGeometry from this SSE
          geometries.PushBack( util::ShPtr< SSEGeometry>( new SSEGeometry( **sse_itr)));
        }
      }

      // end
      return geometries;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief checks if domain already contains THIS_SSE
    //! @param THIS_SSE SSE of interest
    //! @return whether domain already contains THIS_SSE
    bool DomainInterface::DoesContain( const SSE &THIS_SSE) const
    {
      // get all the SSEs
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      // search for this sse in m_Data
      util::SiPtrVector< const SSE>::const_iterator itr
      (
        std::find_if
        (
          sse_vector.Begin(),
          sse_vector.End(),
          SSECompare( THIS_SSE)
        )
      );

      // return if it's found
      return ( itr != sse_vector.End());
    }

    //! @brief returns true if the domain has no SSEs in it
    //! @return true if the domain has no SSEs in it
    bool DomainInterface::IsEmpty() const
    {
      return GetSSEs().IsEmpty();
    }

    //! @brief checks if domain already contains this THIS_SSE or any overlapping SSE with THIS_SSE
    //! @param THIS_SSE SSE to be searched for
    //! @return if domain already contains this THIS_SSE or any overlapping SSE with THIS_SSE
    bool DomainInterface::DoesContainOverlapping( const SSE &THIS_SSE) const
    {
      // get all the SSEs
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      // search for this sse or any overlapping sse in m_Data
      util::SiPtrVector< const SSE>::const_iterator itr
      (
        std::find_if
        (
          sse_vector.Begin(),
          sse_vector.End(),
          SSECompareOverlap( THIS_SSE)
        )
      );

      // return if it's found
      return ( itr != sse_vector.End());
    }

    //! @brief returns SiPtrList of sses that have short loops ( at most MAX_LOOP_LENGTH) to provided TARGET_SSE
    //! @param TARGET_SSE SSE for which short loop connecting SSEs are being search
    //! @param MAX_LOOP_LENGTH maximum loop length that is defined as short loop
    //! @return SiPtrList of sses that have short loops to provided TARGET_SSE
    util::SiPtrList< const SSE> DomainInterface::GetSSEsWithShortLoops
    (
      const SSE &TARGET_SSE,
      const size_t MAX_LOOP_LENGTH
    ) const
    {
      // initialize the sse_list to be returned
      util::SiPtrList< const SSE> sse_list;

      // get the vector of all SSEs
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      // iterate over sses stored in the domain
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // calculate the loop length of this sse behind sse_itr to TARGET_SSE
        const size_t this_distance( biol::CalculateSequenceDistance( **sse_itr, TARGET_SSE));

        // if the loop length is not undefined or is not larger than the MAX_LOOP_LENGTH
        if( this_distance != util::GetUndefinedSize_t() && this_distance <= MAX_LOOP_LENGTH)
        {
          // insert this sse into the list
          sse_list.PushBack( *sse_itr);
        }
      }

      // end
      return sse_list;
    }

    //! @brief selects from provided SSE_LIST, sses that have short loops ( <=MAX_LOOP_LENGTH) to SSEs in Domain
    //! @param SSE_LIST list of SSEs on which the selection will be done
    //! @param MAX_LOOP_LENGTH maximum loop length that is defined as short loop
    //! @return Subset of SSE_LIST that has short loops to SSEs in this domain
    util::SiPtrList< const SSE> DomainInterface::GetSSEsWithShortLoops
    (
      const util::SiPtrList< const SSE> &SSE_LIST,
      const size_t MAX_LOOP_LENGTH
    ) const
    {
      // initialize the list to be returned
      util::SiPtrList< const SSE> eligible_sses;

      // iterate over every SSE in this list
      for
      (
        util::SiPtrList< const SSE>::const_iterator sse_itr( SSE_LIST.Begin()), sse_itr_end( SSE_LIST.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if this domain has at least one sse with a short loop to the SSE behind sse_itr
        if( !GetSSEsWithShortLoops( **sse_itr, MAX_LOOP_LENGTH).IsEmpty())
        {
          // insert this sse into eligible_sses
          eligible_sses.PushBack( *sse_itr);
        }
      }

      // return
      return eligible_sses;
    }

    //! @brief returns pairs of sses that have short loops (at most MAX_LOOP_LENGTH) between each other
    //! @param MAX_LOOP_LENGTH maximum loop length that is defined as short loop
    //! @return list of pairs of sses that have short loops (at most MAX_LOOP_LENGTH) between
    //! @return each other
    storage::List< storage::VectorND< 2, util::SiPtr< const SSE> > > DomainInterface::GetSSEsWithShortLoops
    (
      const size_t MAX_LOOP_LENGTH
    ) const
    {
      // initialize the sse_list to be returned
      storage::List< storage::VectorND< 2, util::SiPtr< const SSE> > > sse_list;

      // get the vector of all SSEs
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      // iterate over sses stored in the domain
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr_a( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr_a != sse_itr_end;
        ++sse_itr_a
      )
      {
        // iterate over other sses in the sequence
        for
        (
          util::SiPtrVector< const SSE>::const_iterator sse_itr_b( sse_vector.Begin());
          sse_itr_b != sse_itr_end;
          ++sse_itr_b
        )
        {
          // if same SSE skip
          if( sse_itr_a == sse_itr_b)
          {
            continue;
          }

          // calculate the loop length of this sse behind sse_itr to TARGET_SSE
          const size_t this_distance( biol::CalculateSequenceDistance( **sse_itr_a, **sse_itr_b));

          // if the loop length is not undefined or is not larger than the MAX_LOOP_LENGTH
          if( this_distance != util::GetUndefinedSize_t() && this_distance <= MAX_LOOP_LENGTH)
          {
            // insert this sse pair into the list
            sse_list.PushBack( storage::VectorND< 2, util::SiPtr< const SSE> >( *sse_itr_a, *sse_itr_b));
          }
        }
      }

      // end
      return sse_list;
    }

    //! @brief returns the SSE before and SSE after given TARGET_SSE in this Domain
    //! @param TARGET_SSE SSE of interest
    //! @return the SSE before and SSE after given TARGET_SSE in this Domain
    storage::VectorND< 2, util::SiPtr< const SSE> > DomainInterface::GetNeighborSSEs
    (
      const SSE &TARGET_SSE
    ) const
    {
      // initialize the list to be returned
      storage::VectorND< 2, util::SiPtr< const SSE> > neighbor_sses;

      // get the vector of all SSEs
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      storage::Pair< util::SiPtr< const SSE>, int> left_dist( util::SiPtr< const SSE>(), 99999);
      storage::Pair< util::SiPtr< const SSE>, int> right_dist( util::SiPtr< const SSE>(), 99999);

      // iterate over SSEs
      for( util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()), sse_itr_end( sse_vector.End()); sse_itr != sse_itr_end; ++sse_itr)
      {
        // distances
        const int distance_left( TARGET_SSE.GetFirstAA()->GetSeqID() - ( *sse_itr)->GetLastAA()->GetSeqID());

        // if TARGET_SSE comes before SSE pointed by and is closer
        if( distance_left > 0 && distance_left < left_dist.Second())
        {
          left_dist.First()  = *sse_itr;
          left_dist.Second() = distance_left;
          continue;
        }

        const int distance_right( ( *sse_itr)->GetFirstAA()->GetSeqID() - TARGET_SSE.GetLastAA()->GetSeqID());

        // if TARGET_SSE comes after SSE pointed by and is closer
        if( distance_right > 0 && distance_right < right_dist.Second())
        {
          right_dist.First()  = *sse_itr;
          right_dist.Second() = distance_right;
        }
      }

      neighbor_sses.First() = left_dist.First();
      neighbor_sses.Second() = right_dist.First();

      // return
      return neighbor_sses;
    }

    //! @brief get the directly adjacent sses by seqid
    //! @param TARGET_SSE SSE of interest
    //! @return the SSE before and SSE after given TARGET_SSE in this Domain by seqid
    storage::VectorND< 2, util::SiPtr< const SSE> > DomainInterface::GetAdjacentSSEs
    (
      const SSE &TARGET_SSE
    ) const
    {
      // initialize the list to be returned
      storage::VectorND< 2, util::SiPtr< const SSE> > neighbor_sses( GetNeighborSSEs( TARGET_SSE));

      // check if neighbor sses distance is 1
      if
      (
           neighbor_sses.First().IsDefined()
        && ( TARGET_SSE.GetFirstAA()->GetSeqID() - neighbor_sses.First()->GetLastAA()->GetSeqID()) != 1
      )
      {
        neighbor_sses.First() = util::SiPtr< const SSE>();
      }

      if
      (
           neighbor_sses.Second().IsDefined()
        && ( neighbor_sses.Second()->GetFirstAA()->GetSeqID() - TARGET_SSE.GetLastAA()->GetSeqID()) != 1
      )
      {
        neighbor_sses.Second() = util::SiPtr< const SSE>();
      }

      // end
      return neighbor_sses;
    }

    //! @brief returns SiPtrList of SSEs that overlap with the given TARGET_SSE
    //! @param TARGET_SSE SSE for which overlapping SSEs are searched for
    //! @return SiPtrList of SSEs that overlap with the given TARGET_SSE
    util::SiPtrList< const SSE> DomainInterface::GetOverlappingSSEs
    (
      const SSE &TARGET_SSE
    ) const
    {
      // get the vector of all SSEs
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      // search for overlapping sses with SP_SSE using equal_range
      std::pair
      <
        util::SiPtrVector< const SSE>::const_iterator,
        util::SiPtrVector< const SSE>::const_iterator
      > itr_pair
      (
        std::equal_range
        (
          sse_vector.Begin(),
          sse_vector.End(),
          TARGET_SSE,
          SSELessThanNoOverlap()
        )
      );

      // if such an sse is found
      if( itr_pair.first != sse_vector.End())
      {
        // return the overlapping sses
        return util::SiPtrList< const SSE>( itr_pair.first, itr_pair.second);
      }

      // if no match is found return empty
      return util::SiPtrList< const SSE>();
    }

    //! @brief get Identification of this Domain
    //! @return string with identification
    std::string DomainInterface::GetIdentification() const
    {
      // get the vector of all SSEs
      const util::SiPtrVector< const SSE> sse_vector( GetSSEs());

      // initialize string to hold the identification
      std::string identification( "#SSEs: " + util::Format()( sse_vector.GetSize()) + "\n");

      // iterate over SSEs
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sse_vector.Begin()),
          sse_itr_end( sse_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // appned the identification of this SSE to the identification of domain
        identification += ( *sse_itr)->GetIdentification() + " \n";
      }

      // end
      return identification;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_fold_template.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sse.h"
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_aa_sequence_factory.h"
#include "math/bcl_math_combination.h"
#include "util/bcl_util_sh_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> FoldTemplate::s_Instance
    (
      GetObjectInstances().AddInstance( new FoldTemplate())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    FoldTemplate::FoldTemplate() :
      m_Geometries(),
      m_PDBID( GetDefaultPDBID()),
      m_Topology(),
      m_TopologyCollector(),
      m_SortBySize( true)
    {
    }

    //! @brief construct from a vectors geometries
    //! @param GEOMETRIES bodies of SSEs in template
    //! @param TOPOLOGY_COLLECTOR collector to use to calculate the topology
    //! @param PDB_ID PDB ID of passed protein model
    //! @param SORT_BY_SIZE whether to sort the geometries by size
    FoldTemplate::FoldTemplate
    (
      const util::ShPtrVector< SSEGeometryPhiPsi> &GEOMETRIES,
      const util::ShPtr< CollectorTopologyInterface> &TOPOLOGY_COLLECTOR,
      const std::string &PDB_ID,
      const bool SORT_BY_SIZE
    ) :
      m_Geometries( GEOMETRIES),
      m_PDBID( PDB_ID),
      m_Topology(),
      m_TopologyCollector( TOPOLOGY_COLLECTOR),
      m_SortBySize( SORT_BY_SIZE)
    {
      // sort the geometries if requested
      if( m_SortBySize)
      {
        m_Geometries.Sort( SSEGeometryPhiPsiLessThan());
      }
    }

    //! @brief construct from a protein model and PDB ID, sorting the geometries by size
    //! @param PROTEIN_MODEL protein model
    //! @param TOPOLOGY_COLLECTOR collector to use to calculate the topology
    //! @param PDB_ID PDB ID of passed protein model
    //! @param TRIM_GEOMETRIES whether to trim the geometries by 1 residue at each terminus
    FoldTemplate::FoldTemplate
    (
      const ProteinModel &PROTEIN_MODEL,
      const util::ShPtr< CollectorTopologyInterface> &TOPOLOGY_COLLECTOR,
      const std::string &PDB_ID,
      const bool TRIM_GEOMETRIES
    ) :
      m_Geometries(),
      m_PDBID( PDB_ID),
      m_Topology(),
      m_TopologyCollector( TOPOLOGY_COLLECTOR),
      m_SortBySize( true)
    {
      // create the geometries from the protein SSEs
      CreateGeometries( PROTEIN_MODEL, TRIM_GEOMETRIES);
    }

    //! @brief copy constructor
    //! @param FOLD_TEMPLATE FoldTemplate to be copied
    FoldTemplate::FoldTemplate( const FoldTemplate &FOLD_TEMPLATE) :
      m_Geometries( FOLD_TEMPLATE.m_Geometries.HardCopy()),
      m_PDBID( FOLD_TEMPLATE.m_PDBID),
      // m_topology is not copied because it will still have pointers to FOLD_TEMPLATE
      // it will be recalculated the first time it is needed
      m_Topology(),
      m_TopologyCollector( FOLD_TEMPLATE.m_TopologyCollector),
      m_SortBySize( FOLD_TEMPLATE.m_SortBySize)
    {
    }

    //! @brief Clone function
    //! @return pointer to new FoldTemplate
    FoldTemplate *FoldTemplate::Clone() const
    {
      return new FoldTemplate( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &FoldTemplate::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief calls GetIndentification on each geometry
    //! @return std::string of GetIndentification from each geometry, separated by a new line
    std::string FoldTemplate::GetGeometryIndentifications() const
    {
      // initialize return string
      std::string geometry_string;

      // iterate through the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geo_itr( m_Geometries.Begin()),
          geo_itr_end( m_Geometries.End());
        geo_itr != geo_itr_end;
        ++geo_itr
      )
      {
        // add the identification to the string
        geometry_string += ( *geo_itr)->GetIdentification() + "\n";
      }

      // end
      return geometry_string;
    }

    //! @brief get the helical geometries
    //! @return the helical geometries
    util::SiPtrVector< const SSEGeometryPhiPsi> FoldTemplate::GetHelicalGeometries() const
    {
      // initialize geometry vector
      util::SiPtrVector< const SSEGeometryPhiPsi> helical_geometries;

      // iterate through the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geo_itr( m_Geometries.Begin()),
          geo_itr_end( m_Geometries.End());
        geo_itr != geo_itr_end;
        ++geo_itr
      )
      {
        // if the geometry is a helix
        if( ( *geo_itr)->GetType() == biol::GetSSTypes().HELIX)
        {
          // add to the geometry vector
          helical_geometries.PushBack( **geo_itr);
        }
      }

      // end
      return helical_geometries;
    }

    //! @brief get the strand geometries
    //! @return the strand geometries
    util::SiPtrVector< const SSEGeometryPhiPsi> FoldTemplate::GetStrandGeometries() const
    {
      // initialize geometry vector
      util::SiPtrVector< const SSEGeometryPhiPsi> strand_geometries;

      // iterate through the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geo_itr( m_Geometries.Begin()),
          geo_itr_end( m_Geometries.End());
        geo_itr != geo_itr_end;
        ++geo_itr
      )
      {
        // if the geometry is a strand
        if( ( *geo_itr)->GetType() == biol::GetSSTypes().STRAND)
        {
          // add to the geometry vector
          strand_geometries.PushBack( **geo_itr);
        }
      }

      // end
      return strand_geometries;
    }

    //! @brief returns whether the topology is initialized or not
    //! @return whether the topology is initialized or not
    bool FoldTemplate::IsTopologyInitialized() const
    {
      return ( m_Topology.GetGraph().GetNumberVertices() > 0);
    }

    //! @brief creates the topology from the geometry information
    //! @return the topology
    void FoldTemplate::CalculateTopology()
    {
      // calculate the SSE geometries using the phi/psi angles if needed
      if( !HasDefinedGeometries())
      {
        CalculateSSEGeometries();
      }

      // then initialize the topology graph
      m_Topology = m_TopologyCollector->CalculateTopology( m_Geometries);
    }

    //! @brief set the topology
    //! @param TOPOLOGY Topology to be copied
    void FoldTemplate::SetTopology( const Topology &TOPOLOGY)
    {
      m_Topology = TOPOLOGY;
    }

    //! @brief get the center of mass of the fold template
    //! @return the center of mass of the fold template
    linal::Vector3D FoldTemplate::GetCenter() const
    {
      // get the coordinates
      storage::Vector< linal::Vector3D> coords( CollectCoordinates());

      // calculate center of mass and return
      return coord::CenterOfMass( util::ConvertToSiPtrVector( coords));
    }

    //! @brief get the radius of gyration of the fold template
    //! @return the radius of gyration of the fold template
    double FoldTemplate::GetRadiusOfGyration() const
    {
      // get the coordinates
      storage::Vector< linal::Vector3D> coords( CollectCoordinates());

      // calculate the radius of gyration and return
      return coord::RadiusOfGyration( util::ConvertToSiPtrVector( coords));
    }

    //! @brief gets a subdomain of the appropriate size
    //! @param HELICES number of helices in the subdomain
    //! @param STRANDS number of strands in the subdomain
    //! @return a subdomain of the appropriate size
    FoldTemplate FoldTemplate::GetSubDomain( const size_t HELICES, const size_t STRANDS) const
    {
      // get all the possible subdomains
      util::ShPtrList< FoldTemplate> all_subdomains( GetAllSubdomains( HELICES, STRANDS));

      // exit with an empty fold template if no subdomains could be identified
      if( all_subdomains.IsEmpty())
      {
        BCL_MessageStd( "Unable to find a subdomain with the requested SSE composition");
        return FoldTemplate();
      }

      // get a random subdomain
      FoldTemplate random_template
      (
        **random::GetGlobalRandom().Iterator( all_subdomains.Begin(), all_subdomains.End(), all_subdomains.GetSize())
      );

      // calculate the topology
      random_template.CalculateTopology();

      // end
      return random_template;
    }

    //! @brief gets a subdomain that matches the passed SSEs by given comparison
    //! @param SSES sses used to chose subdomains based on length
    //! @param SSE_GEOMETRY_COMPARE comparison method
    //! @return a subdomain that matches the passed SSEs by given comparison
    FoldTemplate FoldTemplate::GetSubDomain
    (
      const util::SiPtrVector< const SSE> &SSES,
      const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE
    ) const
    {
      // get the helical sses
      const CollectorSSE helix_collector( biol::GetSSTypes().HELIX);
      const util::SiPtrList< const SSE> helices( helix_collector.Collect( SSES));

      // get the strand sses
      const CollectorSSE strand_collector( biol::GetSSTypes().STRAND);
      const util::SiPtrList< const SSE> strands( strand_collector.Collect( SSES));

      // get all the subdomains of the right SSE composition
      util::ShPtrList< FoldTemplate> all_subdomains( GetAllSubdomains( helices.GetSize(), strands.GetSize()));

      // exit with an empty fold template if no subdomains could be identified
      if( all_subdomains.IsEmpty())
      {
        BCL_MessageVrb
        (
          "Unable to find a subdomain with the requested SSE composition: H(" + util::Format()( helices.GetSize()) +
          ") S(" + util::Format()( strands.GetSize()) + ")"
        );
        return FoldTemplate();
      }

      // initialize probability distribution to hold templates that satisfy the SSE lengths, they are weighted by the
      // square of the average neighbor count
      util::ShPtrVector< FoldTemplate> suitable_subdomains;

      // iterate through the list of all subdomains
      for
      (
        util::ShPtrList< FoldTemplate>::iterator template_itr( all_subdomains.Begin()),
          template_itr_end( all_subdomains.End());
        template_itr != template_itr_end; ++template_itr
      )
      {
        // if the geometry sizes match the sse sizes
        if( ( *template_itr)->HasSimilarSizeGeometries( SSES, SSE_GEOMETRY_COMPARE))
        {
          // add this subdomain
          suitable_subdomains.PushBack( *template_itr);
        }
      }

      // exit with an empty fold template if no subdomains could be identified
      if( suitable_subdomains.IsEmpty())
      {
        BCL_MessageVrb
        (
          "Unable to find a subdomain with the requested SSE composition and sizes"
        );
        return FoldTemplate();
      }

      // get a random subdomain
      FoldTemplate random_template
      (
        **random::GetGlobalRandom().Iterator
        (
          suitable_subdomains.Begin(), suitable_subdomains.End(), suitable_subdomains.GetSize()
        )
      );

      // calculate the topology
      random_template.CalculateTopology();

      // end
      return random_template;
    }

    //! @brief gets the default PDB ID to be used if none is supplied
    //! @return the default PDB ID to be used if none is supplied
    const std::string &FoldTemplate::GetDefaultPDBID()
    {
      static const std::string s_default_pdb_id( "DFLT");

      return s_default_pdb_id;
    }

    //! @brief returns whether the geometries are close in size to the passed SSEs
    //! @param SSES sses to compare geometries to
    //! @param GEOMETRY_COMPARE function to decide whether an SSE should be fit into a geometry
    //! @return whether the geometries are close in size to the passed SSEs
    bool FoldTemplate::HasSimilarSizeGeometries
    (
      const util::SiPtrVector< const SSE> &SSES,
      const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &GEOMETRY_COMPARE
    ) const
    {
      // get the helical sses
      const CollectorSSE helix_collector( biol::GetSSTypes().HELIX);
      util::SiPtrList< const SSE> helices( helix_collector.Collect( SSES));

      // get the strand sses
      const CollectorSSE strand_collector( biol::GetSSTypes().STRAND);
      util::SiPtrList< const SSE> strands( strand_collector.Collect( SSES));

      // get the geometries from this fold template
      const util::SiPtrVector< const SSEGeometryPhiPsi> helical_geometries( GetHelicalGeometries());
      const util::SiPtrVector< const SSEGeometryPhiPsi> strand_geometries( GetStrandGeometries());

      // if the number of SSEs and geometries don't match
      if( helices.GetSize() != helical_geometries.GetSize() || strands.GetSize() != strand_geometries.GetSize())
      {
        return false;
      }

      helices.Sort( SSELessThanBySize());
      strands.Sort( SSELessThanBySize());

      // get iterators on the helical geometries
      util::SiPtrVector< const SSEGeometryPhiPsi>::const_iterator geometry_itr( helical_geometries.Begin());
      const util::SiPtrVector< const SSEGeometryPhiPsi>::const_iterator geometry_itr_end( helical_geometries.End());

      // initialize bool that wrong size was found
      bool found_wrong_size( false);

      // iterate through the helical SSEs and geometries
      for
      (
        util::SiPtrList< const SSE>::const_iterator sse_itr( helices.Begin()), sse_itr_end( helices.End());
        sse_itr != sse_itr_end && geometry_itr != geometry_itr_end; ++sse_itr, ++geometry_itr
      )
      {
        // if the compare function returns false
        if( !GEOMETRY_COMPARE( **sse_itr, **geometry_itr))
        {
          // set the bool and break
          found_wrong_size = true;
          break;
        }
      }

      // only look at the strand geometries if the helix geometries matched
      if( !found_wrong_size)
      {
        // get iterators on the strand geometries
        util::SiPtrVector< const SSEGeometryPhiPsi>::const_iterator geometry_itr( strand_geometries.Begin());
        const util::SiPtrVector< const SSEGeometryPhiPsi>::const_iterator geometry_itr_end( strand_geometries.End());

        // iterate through the strand SSEs and geometries
        for
        (
          util::SiPtrList< const SSE>::const_iterator sse_itr( strands.Begin()), sse_itr_end( strands.End());
          sse_itr != sse_itr_end && geometry_itr != geometry_itr_end; ++sse_itr, ++geometry_itr
        )
        {
          // if the compare function returns false
          if
          (
            !GEOMETRY_COMPARE( **sse_itr, **geometry_itr)
          )
          {
            // set the bool and break
            found_wrong_size = true;
            break;
          }
        }
      }

      // end
      return !found_wrong_size;
    }

    //! @brief returns whether there is at least one geometry that is similar to the SSE
    //! @param SP_SSE sse to compare geometries to
    //! @param GEOMETRY_COMPARE function to decide whether an SSE should be fit into a geometry
    //! @return whether there is at least one geometry that is similar to the SSE
    bool FoldTemplate::HasSimilarSizeGeometry
    (
      const util::SiPtr< const SSE> &SP_SSE,
      const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &GEOMETRY_COMPARE
    ) const
    {
      // get the SSE type
      const biol::SSType ss_type( SP_SSE->GetType());

      // if it is not helix or strand return fals
      if( !ss_type.IsDefined())
      {
        return false;
      }

      // get the appropriate geometries
      const util::SiPtrVector< const SSEGeometryPhiPsi> template_geometries
      (
        ss_type == biol::GetSSTypes().HELIX ? GetHelicalGeometries() : GetStrandGeometries()
      );

      // iterate over the geometries
      for
      (
          util::SiPtrVector< const SSEGeometryPhiPsi>::const_iterator geometry_itr( template_geometries.Begin()),
          geometry_itr_end( template_geometries.End());
        geometry_itr != geometry_itr_end; ++geometry_itr
      )
      {
        // if the geometry matches
        if( GEOMETRY_COMPARE( *SP_SSE, **geometry_itr))
        {
          return true;
        }
      }

      // if this point is reached no matching geometries were found so return false
      return false;
    }

    //! @brief returns whether all the geometries are defined
    //! @return whether all the geometries are defined
    bool FoldTemplate::HasDefinedGeometries() const
    {
      // iterate over the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geometry_itr( m_Geometries.Begin()),
          geometry_itr_end( m_Geometries.End());
        geometry_itr != geometry_itr_end; ++geometry_itr
      )
      {
        // if the geometry is undefined
        if( !( *geometry_itr)->IsDefined())
        {
          return false;
        }
      }

      // all geometries are defined
      return true;
    }

    //! @brief returns whether all the angles are defined
    //! @return whether all the angles are defined
    bool FoldTemplate::HasDefinedAngles() const
    {
      // iterate over the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geometry_itr( m_Geometries.Begin()),
          geometry_itr_end( m_Geometries.End());
        geometry_itr != geometry_itr_end; ++geometry_itr
      )
      {
        // if the angle is undefined
        if( !( *geometry_itr)->GetPhiPsi()->IsDefined())
        {
          return false;
        }
      }

      // all angles are defined
      return true;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief performs translation given by linal::Vector3D
    //! @param TRANSLATION linal::Vector3D to be used for translation
    void FoldTemplate::Translate( const linal::Vector3D &TRANSLATION)
    {
      // create a transformation matrix from the translation
      math::TransformationMatrix3D transform;
      transform( TRANSLATION);

      // apply translation
      Transform( transform);
    }

    //! @brief performs rotation & translation given by 4D transformation matrix
    //! @param TRANSFORMATION_MATRIX_3D TransformationMatrix3D to be used for transformation
    void FoldTemplate::Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
    {
      // iterate through the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::iterator geo_itr( m_Geometries.Begin()),
          geo_itr_end( m_Geometries.End());
        geo_itr != geo_itr_end;
        ++geo_itr
      )
      {
        // apply transformation
        ( *geo_itr)->Transform( TRANSFORMATION_MATRIX_3D);
      }
    }

    //! @brief performs rotation given by math::RotationMatrix3D
    //! @param ROTATIONMATRIX3D math::RotationMatrix3D to be used for rotation
    void FoldTemplate::Rotate( const math::RotationMatrix3D &ROTATIONMATRIX3D)
    {
      // apply rotation
      Transform( math::TransformationMatrix3D( ROTATIONMATRIX3D));
    }

    //! @brief fits the given SSEs into this fold template and returns a domain
    //! @param SSES_TO_FIT vector of SSEs to place into the fold template
    //! @return a domain with the placed SSES
    Domain FoldTemplate::FitSSEs( const util::SiPtrVector< const SSE> &SSES_TO_FIT) const
    {
      // initialize vectors of helices and strands
      util::ShPtrVector< SSE> helices;
      util::ShPtrVector< SSE> strands;

      // iterate through the SSEs
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( SSES_TO_FIT.Begin()), sse_itr_end( SSES_TO_FIT.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // add to the appropriate vector
        if( ( *sse_itr)->GetType() == biol::GetSSTypes().HELIX)
        {
          helices.PushBack( util::ShPtr< SSE>( ( *sse_itr)->Clone()));
        }
        else if( ( *sse_itr)->GetType() == biol::GetSSTypes().STRAND)
        {
          strands.PushBack( util::ShPtr< SSE>( ( *sse_itr)->Clone()));
        }
      }

      // sort by size
      std::sort( helices.Begin(), helices.End(), SSELessThanBySize());
      std::sort( strands.Begin(), strands.End(), SSELessThanBySize());

      // get the helix and strand geometries
      util::SiPtrVector< const SSEGeometryPhiPsi> helical_geometries( GetHelicalGeometries());
      util::SiPtrVector< const SSEGeometryPhiPsi> strand_geometries( GetStrandGeometries());

      // make sure the vectors are the same size
      MatchSSEsAndGeometries( helices, helical_geometries);
      MatchSSEsAndGeometries( strands, strand_geometries);

      // create iterators on the SSEs
      util::ShPtrVector< SSE>::iterator helix_itr( helices.Begin());
      const util::ShPtrVector< SSE>::iterator helix_itr_end( helices.End());
      util::ShPtrVector< SSE>::iterator strand_itr( strands.Begin());
      const util::ShPtrVector< SSE>::iterator strand_itr_end( strands.End());

      // create new domain sse vector
      util::ShPtrVector< SSE> domain_sses;

      // iterate through the helices
      for
      (
        util::SiPtrVector< const SSEGeometryPhiPsi>::const_iterator geometry_itr( helical_geometries.Begin()),
          geometry_itr_end( helical_geometries.End());
        geometry_itr != geometry_itr_end && helix_itr != helix_itr_end;
        ++geometry_itr, ++helix_itr
      )
      {
        // apply the fit
        biol::AASequenceFactory::FitSequence( **helix_itr, *( ( *geometry_itr)->GetPhiPsi()), biol::GetSSTypes().HELIX);

        // update the SSE geometry since the associated sequence has changed
        ( *helix_itr)->SetGeometry();

        // add the sse to the domain vector
        domain_sses.PushBack( *helix_itr);
      }

      // iterate through the strands
      for
      (
        util::SiPtrVector< const SSEGeometryPhiPsi>::const_iterator geometry_itr( strand_geometries.Begin()),
          geometry_itr_end( strand_geometries.End());
        geometry_itr != geometry_itr_end && strand_itr != strand_itr_end;
        ++geometry_itr, ++strand_itr
      )
      {
        // apply the fit
        biol::AASequenceFactory::FitSequence
        (
          **strand_itr,
          *( ( *geometry_itr)->GetPhiPsi()),
          biol::GetSSTypes().STRAND
        );

        // update the SSE geometry since the associated sequence has changed
        ( *strand_itr)->SetGeometry();

        // add the sse to the domain vector
        domain_sses.PushBack( *strand_itr);
      }

      // end
      return Domain( domain_sses);
    }

    //! @brief calculates the SSEGeometries using the associated phi/psi information
    void FoldTemplate::CalculateSSEGeometries()
    {
      // iterate through the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::iterator geo_itr( m_Geometries.Begin()),
          geo_itr_end( m_Geometries.End());
        geo_itr != geo_itr_end; ++geo_itr
      )
      {
        // set it using the phi/psi angles
        ( *geo_itr)->SetSSEGeometryUsingPhiPsi();
      }
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief assignment operator
    //! @param FOLD_TEMPLATE FoldTemplate to be copied
    //! @return This template after all members are assigned to values from FOLD_TEMPLATE
    FoldTemplate &FoldTemplate::operator =( const FoldTemplate &FOLD_TEMPLATE)
    {
      // m_topology is not copied because it will still have pointers to FOLD_TEMPLATE
      // it will be recalculated the first time it is needed
      m_Geometries = FOLD_TEMPLATE.m_Geometries.HardCopy();
      m_PDBID = FOLD_TEMPLATE.m_PDBID;
      m_TopologyCollector = FOLD_TEMPLATE.m_TopologyCollector;
      m_SortBySize = FOLD_TEMPLATE.m_SortBySize;

      // return updated template
      return *this;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &FoldTemplate::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Geometries, ISTREAM);
      io::Serialize::Read( m_PDBID, ISTREAM);
      io::Serialize::Read( m_TopologyCollector, ISTREAM);
      io::Serialize::Read( m_SortBySize, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &FoldTemplate::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Geometries, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PDBID, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_TopologyCollector, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SortBySize, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

    //! @brief write minimal information needed to construct a FoldTemplate to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @return outputstream which was written to
    std::ostream &FoldTemplate::WriteCompact( std::ostream &OSTREAM) const
    {
      // write out the PDB ID number of geometries
      OSTREAM << m_PDBID << ' ' << util::Format()( m_Geometries.GetSize()) << '\n';

      // write out just the phi/psi information by iterating over the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geo_itr( m_Geometries.Begin()),
          geo_itr_end( m_Geometries.End());
        geo_itr != geo_itr_end; ++geo_itr
      )
      {
        // write out the type, coords, and size
        OSTREAM << ( *geo_itr)->GetType().GetName() << ' '
                << WriteCoordinates( ( *geo_itr)->GetPhiPsi()->GetN())
                << WriteCoordinates( ( *geo_itr)->GetPhiPsi()->GetCA())
                << WriteCoordinates( ( *geo_itr)->GetPhiPsi()->GetC())
                << util::Format()( ( *geo_itr)->GetPhiPsi()->GetAngles().GetSize());

        // get iterators on the phi psi angles
        storage::Vector< storage::VectorND< 2, double> >::const_iterator angle_itr
        (
          ( *geo_itr)->GetPhiPsi()->GetAngles().Begin()
        );
        storage::Vector< storage::VectorND< 2, double> >::const_iterator angle_itr_end
        (
          ( *geo_itr)->GetPhiPsi()->GetAngles().End()
        );

        // write out the first psi (phi is nan)
        OSTREAM << ' ' << util::Format()( angle_itr->Second());
        ++angle_itr;
        --angle_itr_end;

        // iterate over the phi/psi angles
        for( ; angle_itr != angle_itr_end; ++angle_itr)
        {
          // write the phi and psi angles
          OSTREAM << ' ' << util::Format()( angle_itr->First()) << ' ' << util::Format()( angle_itr->Second());
        }

        // write out the last phi (psi is nan)
        OSTREAM << ' ' << util::Format()( ( *geo_itr)->GetPhiPsi()->GetAngles().LastElement().First());

        // move to next line
        OSTREAM << '\n';
      }

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief create geometry member variables
    //! @param PROTEIN_MODEL protein model
    //! @param TRIM_GEOMETRIES whether to trim the geometries
    void FoldTemplate::CreateGeometries( const ProteinModel &PROTEIN_MODEL, const bool TRIM_GEOMETRIES)
    {
      // store SSEs
      util::SiPtrVector< const SSE> sses_vector
      (
        PROTEIN_MODEL.GetSSEs( storage::Set< biol::SSType>( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND))
      );

      // if sorting is selected
      if( m_SortBySize)
      {
        std::sort( sses_vector.Begin(), sses_vector.End(), SSELessThanBySize());
      }

      // initialize a geometries vector
      util::ShPtrVector< SSEGeometryPhiPsi> geometries;

      // iterate through SSEs in PROTEIN_MODEL
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sses_vector.Begin()), sse_itr_end( sses_vector.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if the geometries should be trimmed
        if( TRIM_GEOMETRIES)
        {
          // make a copy of the SSE
          SSE copy_sse( **sse_itr);

          // clip the ends
          copy_sse.ClipEnds( 1);

          // update the geometry since ClipEnds is an AASequence function
          copy_sse.SetGeometry();

          // add to the geometries
          geometries.PushBack( util::ShPtr< SSEGeometryPhiPsi>( new SSEGeometryPhiPsi( copy_sse)));
        }
        else
        {
          // add the original SSE to the geometries
          geometries.PushBack( util::ShPtr< SSEGeometryPhiPsi>( new SSEGeometryPhiPsi( **sse_itr)));
        }
      }

      // initialize the topology
      // then initialize the topology graph
      m_Topology = m_TopologyCollector->CalculateTopology( geometries);

      // iterate over the current geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geo_itr( geometries.Begin()),
          geo_itr_end( geometries.End());
        geo_itr != geo_itr_end; ++geo_itr
      )
      {
        // if this geometry does also exist in the topology as a vertex
        // meaning it has at least one SSEPacking that is valid according to criteria and therefore has an edge
        if( m_Topology.GetGraph().HasVertex( *geo_itr))
        {
          m_Geometries.PushBack( *geo_itr);
        }
        else
        {
          BCL_MessageStd( util::Format()( ( *geo_itr)->GetIdentification()) + " has no neighbors");
        }
      }
    }

    //! @brief calculate coordinates for each body in a fold template
    //! @return coordinates for a fold template
    storage::Vector< linal::Vector3D> FoldTemplate::CollectCoordinates() const
    {
      // initialize vector of coordinates
      storage::Vector< linal::Vector3D> coords;

      // iterate through the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geo_itr( m_Geometries.Begin()),
          geo_itr_end( m_Geometries.End());
        geo_itr != geo_itr_end;
        ++geo_itr
      )
      {
        // get the fragment geometries
        util::SiPtrVector< const coord::GeometryInterface> fragments( ( *geo_itr)->GetGeometries());

        // if the fragment list is empty
        if( fragments.IsEmpty())
        {
          // pushback the main geometry
          fragments.PushBack( **geo_itr);
        }

        // iterate through the fragments
        for
        (
          util::SiPtrVector< const coord::GeometryInterface>::const_iterator fragment_itr( fragments.Begin()),
            fragment_itr_end( fragments.End());
          fragment_itr != fragment_itr_end;
          ++fragment_itr
        )
        {
          // add the begin, center, and end points to the coordinates
          coords.PushBack( ( *fragment_itr)->GetMainAxis().GetStartPoint());
          coords.PushBack( ( *fragment_itr)->GetCenter());
          coords.PushBack( ( *fragment_itr)->GetMainAxis().GetEndPoint());
        }
      }

      // end
      return coords;
    }

    //! @brief writes the given coordinates to one line
    //! @param COORDS Vector3D to be written
    //! @return string containing the coordinates on one line
    std::string FoldTemplate::WriteCoordinates( const linal::Vector3D &COORDS)
    {
      // initialize the string
      std::string coords_string;

      // write the orientation
      for( size_t i( 0); i != 3; ++i)
      {
        coords_string += util::Format()( COORDS( i)) + " ";
      }

      // end
      return coords_string;
    }

    //! @brief trims vectors of SSEs and geometries (whichever is biggest so that they match)
    //! @param SSES vector of SSEs
    //! @param GEOS vector of SSEGeometries
    void FoldTemplate::MatchSSEsAndGeometries
    (
      util::ShPtrVector< SSE> &SSES, util::SiPtrVector< const SSEGeometryPhiPsi> &GEOS
    )
    {
      // get the sizes of the vectors
      const size_t nr_sses( SSES.GetSize());
      const size_t nr_geos( GEOS.GetSize());

      // there are more SSEs than geometries
      if( nr_sses > nr_geos)
      {
        // iterate over the size difference
        for( size_t i( 0), i_end( nr_sses - nr_geos); i != i_end; ++i)
        {
          // remove a random element
          SSES.RemoveRandomElement();
        }
      }
      // there are more geometries than SSEs
      else if( nr_sses < nr_geos)
      {
        // iterate over the size difference
        for( size_t i( 0), i_end( nr_geos - nr_sses); i != i_end; ++i)
        {
          // remove a random element
          GEOS.RemoveRandomElement();
        }
      }
    }

    //! @brief get the average number of close geometries
    //! @return the average number of close geometries
    double FoldTemplate::AverageNumberOfCloseGeometries() const
    {
      // initialize sum
      double neighbor_sum( 0.0);

      // iterate through the geometries
      for
      (
        util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geometry_itr( m_Geometries.Begin()),
          geometry_itr_end( m_Geometries.End());
        geometry_itr != geometry_itr_end; ++geometry_itr
      )
      {
        // add to the number of neighbors
        neighbor_sum += NumberOfCloseGeometries( *geometry_itr);
      }

      // get the number of geometries
      const double nr_geometries( m_Geometries.GetSize());

      // end
      return nr_geometries == 0.0 ? 0.0 : neighbor_sum / nr_geometries;
    }

    //! @brief get the number of geometries within DISTANCE
    //! @param GEOMETRY geometry of interest
    //! @return the number of bodies within DISTANCE
    size_t FoldTemplate::NumberOfCloseGeometries( const util::ShPtr< SSEGeometryPhiPsi> &GEOMETRY) const
    {
      return GetNeighborGeometries( GEOMETRY).GetSize();
    }

    //! @brief get geometries that contact the passed geometry in the fold template
    //! @param GEOMETRY geometry of interest
    //! @return ShPtrVector of geometries that contact the passed geometry in the fold template
    util::ShPtrVector< SSEGeometryPhiPsi> FoldTemplate::GetNeighborGeometries
    (
      const util::ShPtr< SSEGeometryPhiPsi> &GEOMETRY
    ) const
    {
      // initialize geometry vector
      util::ShPtrVector< SSEGeometryPhiPsi> neighbors;

      // get the corresponding vertex from the topology graph
      util::ShPtr< Topology::GraphType::VertexType> vertex
      (
        m_Topology.GetGraph().FindVertex( util::SiPtr< const SSEGeometryInterface>( GEOMETRY))
      );

      // is the ShPtr is undefined
      if( !vertex.IsDefined())
      {
        // return an empty vector
        BCL_MessageStd
        (
          "SSEGeometry " + GEOMETRY->GetIdentification() +
          " was not found in the fold template topology, returning empty neighbor geometry vector"
        );

        return neighbors;
      }

      // iterate through the edges
      for
      (
        Topology::GraphType::EdgeContainerType::const_iterator edge_itr( vertex->GetEdges().Begin()),
          edge_itr_end( vertex->GetEdges().End());
        edge_itr != edge_itr_end; ++edge_itr
      )
      {
        // get a pointer to the target data
        util::SiPtr< const SSEGeometryInterface> target_geometry( edge_itr->GetTarget()->GetData());

        // iterate through the geometries
        for
        (
          util::ShPtrVector< SSEGeometryPhiPsi>::const_iterator geometry_itr( m_Geometries.Begin()),
            geometry_itr_end( m_Geometries.End());
          geometry_itr != geometry_itr_end; ++geometry_itr
        )
        {
          // check if the geometry pointer is also pointing to the target data
          if( geometry_itr->GetPointer() == target_geometry.GetPointer())
          {
            // add to the neighbor vector and continue
            neighbors.PushBack( *geometry_itr);
            continue;
          }
        }
      }

      // end
      return neighbors;
    }

    //! @brief gets all the possible subdomains of the requested size
    //! @param HELICES number of helices in the subdomain
    //! @param STRANDS number of strands in the subdomain
    //! @return all the possible subdomains of the requested size
    util::ShPtrList< FoldTemplate> FoldTemplate::GetAllSubdomains( const size_t HELICES, const size_t STRANDS) const
    {
      // check if the requested subdomain size is larger than the fold template
      if( HELICES > GetHelicalGeometries().GetSize() || STRANDS > GetStrandGeometries().GetSize())
      {
        // warn the user and return an empty template
        BCL_MessageVrb
        (
          "Unable to find a subdomain of size " + util::Format()( HELICES) +
          " and " + util::Format()( STRANDS) + " because the fold template is too small"
        );
        return util::ShPtrList< FoldTemplate>();
      }

      // The next step is to find a subgraph from the graph that has the requested number of helices and strands.
      // The approach here is to first store all possible combinations of helices and strands that can be generated to
      // match the number requested (HELICES & STRANDS).  Then each strand combination is added to each helix
      // combination to get HELICES * STRANDS total collections of SSEs.  Next, a subgraph is generated for each
      // collection.  Only connected subgraphs (meaning each SSE is in contact with at least one other SSE) is retained.
      // A fold template is then generated from one of these subgraphs randomly.

      // get the helix and strand geometries
      util::SiPtrVector< const SSEGeometryPhiPsi> helix_geometries( GetHelicalGeometries());
      util::SiPtrVector< const SSEGeometryPhiPsi> strand_geometries( GetStrandGeometries());

      // construct combinations for the helix and strand geometries
      math::Combination< util::SiPtr< const SSEGeometryPhiPsi> > helix_combination
      (
        storage::Set< util::SiPtr< const SSEGeometryPhiPsi> >( helix_geometries.Begin(), helix_geometries.End()),
        helix_geometries.GetSize() - HELICES
      );
      math::Combination< util::SiPtr< const SSEGeometryPhiPsi> > strand_combination
      (
        storage::Set< util::SiPtr< const SSEGeometryPhiPsi> >( strand_geometries.Begin(), strand_geometries.End()),
        strand_geometries.GetSize() - STRANDS
      );

      // get the possible combinations
      storage::List< storage::Set< util::SiPtr< const SSEGeometryPhiPsi> > > helix_combinations
      (
        helix_combination.GetAllCombinations()
      );
      storage::List< storage::Set< util::SiPtr< const SSEGeometryPhiPsi> > > strand_combinations
      (
        strand_combination.GetAllCombinations()
      );

      // initialize list of potential subdomains
      util::ShPtrList< FoldTemplate> subdomains;

      // iterate through the helix combinations
      for
      (
        storage::List< storage::Set< util::SiPtr< const SSEGeometryPhiPsi> > >::const_iterator
          helix_itr( helix_combinations.Begin()), helix_itr_end( helix_combinations.End());
        helix_itr != helix_itr_end; ++helix_itr
      )
      {
        // iterate through the strand combinations
        for
        (
          storage::List< storage::Set< util::SiPtr< const SSEGeometryPhiPsi> > >::const_iterator
            strand_itr( strand_combinations.Begin()), strand_itr_end( strand_combinations.End());
          strand_itr != strand_itr_end; ++strand_itr
        )
        {
          // copy the helix set
          storage::Set< util::SiPtr< const SSEGeometryPhiPsi> > combined_set( *helix_itr);

          // insert the strand entries
          combined_set.InsertElements( *strand_itr);

          // make a copy of the graph in the topology
          // the topology will have the new vertices but they will still have the old edges
          // this is risky but OK to use here since we remove unused helices and strands to get the sub-topology
          util::ShPtr< Topology::GraphType> sp_graph( m_Topology.GetGraph().HardCopy());

          // initialize geometry vector
          util::ShPtrVector< SSEGeometryPhiPsi> geometry_vector( m_Geometries);

          // iterate over the set
          for
          (
            storage::Set< util::SiPtr< const SSEGeometryPhiPsi> >::const_iterator set_itr( combined_set.Begin()),
              set_itr_end( combined_set.End());
            set_itr != set_itr_end; ++set_itr
          )
          {
            // remove the corresponding vertex
            sp_graph->DeleteVertex( sp_graph->FindVertex( *set_itr));
            geometry_vector.RemoveElements( geometry_vector.Find( *set_itr));
          }

          // initialize bool to check whether any vertices are unconnected
          bool has_unconnected_vertex( false);

          // if the graph has more than one vertex
          if( sp_graph->GetVertices().GetSize() > 1)
          {
            // iterate through the graph vertices
            for
            (
              Topology::GraphType::VertexContainerType::const_iterator vertex_itr( sp_graph->GetVertices().Begin()),
                vertex_itr_end( sp_graph->GetVertices().End());
              vertex_itr != vertex_itr_end; ++vertex_itr
            )
            {
              // if the number of edges is zero, set the bool to true and break
              if( ( *vertex_itr)->GetDegree() == 0)
              {
                has_unconnected_vertex = true;
                break;
              }

              // if the vertex is a strand
              if( STRANDS > 1 && ( *vertex_itr)->GetData()->GetType() == biol::GetSSTypes().STRAND)
              {
                // initialize bool for strand pair
                bool strand_pair( false);

                // iterate over the edges
                for
                (
                  Topology::GraphType::EdgeContainerType::const_iterator edge_itr( ( *vertex_itr)->GetEdges().Begin()),
                    edge_itr_end( ( *vertex_itr)->GetEdges().End());
                  edge_itr != edge_itr_end; ++edge_itr
                )
                {
                  // if the edge is a strand-strand type
                  if( edge_itr->GetData().GetContactType() == contact::GetTypes().STRAND_STRAND)
                  {
                    // found a strand pairing
                    strand_pair = true;
                    break;
                  }
                }

                // if this is a single strand
                if( !strand_pair)
                {
                  // break from iteration
                  has_unconnected_vertex = true;
                  break;
                }
              }
            }
          }

          // if the graph has no unconnected vertices
          if( !has_unconnected_vertex && !sp_graph->GetVertices().IsEmpty())
          {
            subdomains.PushBack
            (
              util::ShPtr< FoldTemplate>( new FoldTemplate( geometry_vector, m_TopologyCollector, m_PDBID))
            );
          }
        }
      }

      BCL_MessageDbg
      (
        "Number of subgraphs: " + util::Format()( subdomains.GetSize()) + " out of " +
        util::Format()( helix_combinations.GetSize() * strand_combinations.GetSize())
      );

      // end
      return subdomains;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_fold_template_handler.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sse.h"
#include "assemble/bcl_assemble_collector_topology_combined.h"
#include "assemble/bcl_assemble_fold_template.h"
#include "assemble/bcl_assemble_sse.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "command/bcl_command_parameter_check_allowed.h"
#include "io/bcl_io_file.h"
#include "score/bcl_score.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // static map to store the templates
    storage::Map< storage::Pair< size_t, size_t>, util::ShPtrVector< FoldTemplate> > FoldTemplateHandler::s_TemplateMap;

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> FoldTemplateHandler::s_Instance
    (
      GetObjectInstances().AddInstance( new FoldTemplateHandler())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    FoldTemplateHandler::FoldTemplateHandler()
    {
    }

    //! @brief Clone function
    //! @return pointer to new FoldTemplateHandler
    FoldTemplateHandler *FoldTemplateHandler::Clone() const
    {
      return new FoldTemplateHandler( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &FoldTemplateHandler::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return command line flag for using fold templates
    //! @return command line flag for using fold templates
    util::ShPtr< command::FlagInterface> &FoldTemplateHandler::GetFlagFoldTemplates()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic( "fold_templates", "\tfit protein models to fold templates")
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_template_type
      (
        new command::Parameter
        (
          "fold_template_type",
          "\ttype of fold templates to use",
          command::ParameterCheckAllowed( storage::Vector< std::string>::Create( "soluble", "membrane", "all")),
          "soluble"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_small_template_probability
      (
        new command::Parameter
        (
          "small_template_probability",
          "\tprobability of using a small template (less bodies than SSEs in the pool) for the initial placement",
          "1"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_standard_template_probability
      (
        new command::Parameter
        (
          "standard_template_probability",
          "\tprobability of using a standard template (same bodies as SSEs in the pool) for the initial placement",
          "1"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_large_template_probability
      (
        new command::Parameter
        (
          "large_template_probability",
          "\tprobability of using a large template (more bodies than SSEs in the pool) for the initial placement",
          "1"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_excluded_fold_templates
      (
        new command::Parameter
        (
          "excluded_pdb_ids_file",
          "\tspecify a file that contains a list of PBD IDs to be excluded from the fold template selection",
          ""
        )
      );

      // if this flag is initialized from the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_template_type);
        flag->PushBack( s_small_template_probability);
        flag->PushBack( s_standard_template_probability);
        flag->PushBack( s_large_template_probability);
        flag->PushBack( s_excluded_fold_templates);
      }

      // end
      return s_flag;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief picks a random template of the appropriate size
    //! @param HELICES number of helices to be in the template
    //! @param STRANDS number of strands to be in the template
    //! @return a random template of the appropriate size
    const FoldTemplate &FoldTemplateHandler::GetRandomTemplate( const size_t HELICES, const size_t STRANDS)
    {
      // create static undefined template
      static const FoldTemplate s_undefined_template;

      // create an iterator to the vector of templates with the correct number of helices and strands
      storage::Map
      <
        storage::Pair< size_t, size_t>, util::ShPtrVector< FoldTemplate>
      >::const_iterator templates_itr
      (
        GetTemplates().Find( storage::Pair< size_t, size_t>( HELICES, STRANDS))
      );

      // if iterator is invalid, return empty fold template
      if( templates_itr == GetTemplates().End())
      {
        BCL_MessageStd
        (
          "Unable to find a fold template with " + util::Format()( HELICES) +
            " helices and " + util::Format()( STRANDS) + " strands"
        );
        return s_undefined_template;
      }

      // return a random template
      util::ShPtrVector< FoldTemplate>::const_iterator random_itr
      (
        random::GetGlobalRandom().Iterator
        (
          templates_itr->second.Begin(), templates_itr->second.End(), templates_itr->second.GetSize()
        )
      );

      // end
      return **random_itr;
    }

    //! @brief picks a random template of the appropriate size and geometry lengths
    //! @param SSES sses used to chose subtemplate based on length
    //! @param SSE_GEOMETRY_COMPARE comparison method
    //! @return a random template
    const FoldTemplate &FoldTemplateHandler::GetRandomTemplate
    (
      const util::SiPtrVector< const SSE> &SSES,
      const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE
    )
    {
      // get the helical sses
      const CollectorSSE helix_collector( biol::GetSSTypes().HELIX);
      util::SiPtrList< const SSE> helices( helix_collector.Collect( SSES));

      // get the strand sses
      const CollectorSSE strand_collector( biol::GetSSTypes().STRAND);
      util::SiPtrList< const SSE> strands( strand_collector.Collect( SSES));

      // create static undefined template
      static const FoldTemplate s_undefined_template;

      // create an iterator to the vector of templates with the correct number of helices and strands
      storage::Map
      <
        storage::Pair< size_t, size_t>, util::ShPtrVector< FoldTemplate>
      >::const_iterator templates_itr
      (
        GetTemplates().Find( storage::Pair< size_t, size_t>( helices.GetSize(), strands.GetSize()))
      );

      // if iterator is invalid, return empty fold template
      if( templates_itr == GetTemplates().End())
      {
        BCL_MessageStd
        (
          "Unable to find a fold template with " + util::Format()( helices.GetSize()) +
            " helices and " + util::Format()( strands.GetSize()) + " strands"
        );
        return s_undefined_template;
      }

      BCL_MessageDbg( "# potential templates: " + util::Format()( templates_itr->second.GetSize()));

      // initialize vector of matching templates
      util::SiPtrVector< const FoldTemplate> matching_templates;

      // iterate through the templates
      for
      (
        util::ShPtrVector< FoldTemplate>::const_iterator template_itr( templates_itr->second.Begin()),
          template_itr_end( templates_itr->second.End());
        template_itr != template_itr_end; ++template_itr
      )
      {
        // if the geometries match the sses
        if( ( *template_itr)->HasSimilarSizeGeometries( SSES, SSE_GEOMETRY_COMPARE))
        {
          // add this template
          matching_templates.PushBack( *template_itr);
        }
      }

      // get a random template
      util::SiPtrVector< const FoldTemplate>::const_iterator random_itr
      (
        random::GetGlobalRandom().Iterator
        (
          matching_templates.Begin(), matching_templates.End(), matching_templates.GetSize()
        )
      );

      // if no template was found
      if( random_itr == matching_templates.End())
      {
        BCL_MessageStd
        (
          "Unable to find a fold template with " + util::Format()( helices.GetSize()) +
            " helices and " + util::Format()( strands.GetSize()) + " strands that had the proper geometry sizes"
        );
        // return an empty template
        return s_undefined_template;
      }

      // return a random template
      return **random_itr;
    }

    //! @brief returns a random fold template (that has geometries close in size to the passed sses)
    //!        generated from a larger template
    //! @param SSES sses used to chose subtemplate based on length
    //! @param SSE_GEOMETRY_COMPARE comparison method
    //! @return a random fold template generated from a larger template
    FoldTemplate FoldTemplateHandler::GetRandomSubTemplate
    (
      const util::SiPtrVector< const SSE> &SSES,
      const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE
    )
    {
      // get the helical sses
      const CollectorSSE helix_collector( biol::GetSSTypes().HELIX);
      util::SiPtrList< const SSE> helices( helix_collector.Collect( SSES));

      // get the strand sses
      const CollectorSSE strand_collector( biol::GetSSTypes().STRAND);
      util::SiPtrList< const SSE> strands( strand_collector.Collect( SSES));

      // get the large templates
      util::ShPtrVector< FoldTemplate> large_templates( GetLargeTemplates( helices, strands, SSE_GEOMETRY_COMPARE));

      // initialize sub-template
      FoldTemplate sub_template;

      // loop until a sub template is found
      while( sub_template.GetGeometries().IsEmpty() && !large_templates.IsEmpty())
      {
        // get a random template iterator
        util::ShPtrVector< FoldTemplate>::iterator large_template_itr
        (
          random::GetGlobalRandom().Iterator( large_templates.Begin(), large_templates.End(), large_templates.GetSize())
        );

        // if the topology has not been initialized
        if( !( *large_template_itr)->IsTopologyInitialized())
        {
          // calculate the topology
          ( *large_template_itr)->CalculateTopology();
        }

        // get a subdomain and set it to the sub_template
        sub_template = ( *large_template_itr)->GetSubDomain( SSES, SSE_GEOMETRY_COMPARE);

        // remove the template from the vector so it is not used again if no subdomains were found
        large_templates.RemoveElement( large_template_itr);
      }

      // the sub-template is still empty
      if( sub_template.GetGeometries().IsEmpty())
      {
        // warn the user
        BCL_MessageStd
        (
          "Unable to find a subtemplate, trying a full template"
        );

        // get a random full template
        GetRandomTemplate( helices.GetSize(), strands.GetSize());
      }

      // end
      return sub_template;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &FoldTemplateHandler::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &FoldTemplateHandler::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief singleton function to return fold templates previously generated and stored in a file
    //! @return fold templates previously generated and stored in a file
    const storage::Map
    <
      storage::Pair< size_t, size_t>, util::ShPtrVector< FoldTemplate>
    > &FoldTemplateHandler::GetTemplates()
    {
      // if the map is not initialized
      if( s_TemplateMap.IsEmpty())
      {
        // get the template type
        const std::string &template_type( GetFlagFoldTemplates()->GetFirstParameter()->GetValue());

        // if both soluble and membrane are to be used
        if( template_type == "all")
        {
          // read in both
          s_TemplateMap = ReadTemplates
          (
            storage::Set< std::string>( GetInputFilename( "soluble"), GetInputFilename( "membrane"))
          );
        }
        // only one type is to be used
        else
        {
          // read in that type
          s_TemplateMap = ReadTemplates( storage::Set< std::string>( GetInputFilename( template_type)));
        }
      }

      //end
      return s_TemplateMap;
    }

    //! @brief singleton function to return fold templates previously generated and stored in a file
    //! @param FILENAMES set of filenames to be read in
    //! @return fold templates previously generated and stored in a file
    storage::Map
    <
      storage::Pair< size_t, size_t>, util::ShPtrVector< FoldTemplate>
    > FoldTemplateHandler::ReadTemplates( const storage::Set< std::string> &FILENAMES)
    {
      // initialize storage map
      storage::Map
      <
        storage::Pair< size_t, size_t>, util::ShPtrVector< FoldTemplate>
      > fold_template_map;

      // initialize collector
      const util::ShPtr< CollectorTopologyInterface> sp_collector
      (
        new CollectorTopologyCombined()
      );

      // iterate through the filenames
      for
      (
        storage::Set< std::string>::const_iterator file_itr( FILENAMES.Begin()), file_itr_end( FILENAMES.End());
        file_itr != file_itr_end; ++file_itr
      )
      {
        // open input file
        io::IFStream read;
        io::File::MustOpenIFStream( read, *file_itr);

        // read in the number of templates
        size_t number_of_templates;
        read >> number_of_templates;

        // iterate through the number of templates
        for( size_t i( 0); i != number_of_templates; ++i)
        {
          // initialize vectors of geometries
          util::ShPtrVector< SSEGeometryPhiPsi> geometry_vector;

          // read the number of geometries and the pdb id
          size_t nr_geometries;
          std::string pdb_id;
          read >> pdb_id >> nr_geometries;

          geometry_vector.AllocateMemory( nr_geometries);

          // initialize helix count
          size_t helix_ctr( 0);
          size_t strand_ctr( 0);

          // iterate over the number of geometries
          for( size_t j( 0); j != nr_geometries; ++j)
          {
            // read in the type
            std::string ss_type_string;
            read >> ss_type_string;
            biol::SSType ss_type( biol::GetSSTypes().GetEnumFromName( ss_type_string));

            // initialize identification
            std::string identification;

            // if this is a helix
            if( ss_type == biol::GetSSTypes().HELIX)
            {
              identification = "H" + util::Format()( helix_ctr);
              ++helix_ctr;
            }
            else
            {
              identification = "S" + util::Format()( strand_ctr);
              ++strand_ctr;
            }

            // read in N coords
            linal::Vector3D n_coords;
            for( size_t k( 0); k != 3; ++k)
            {
              read >> n_coords( k);
            }

            // read in CA coords
            linal::Vector3D ca_coords;
            for( size_t k( 0); k != 3; ++k)
            {
              read >> ca_coords( k);
            }

            // read in C coords
            linal::Vector3D c_coords;
            for( size_t k( 0); k != 3; ++k)
            {
              read >> c_coords( k);
            }

            // read in phi/psi size
            size_t nr_residues;
            read >> nr_residues;

            // read in the first psi
            storage::Vector< storage::VectorND< 2, double> > angles;
            angles.AllocateMemory( nr_residues);
            double first_psi;
            read >> first_psi;
            angles.PushBack( storage::VectorND< 2, double>( util::GetUndefined< double>(), first_psi));

            // iterate over the number of residues ( minus 2 since the first and last angles are nan) to read in phi/psis
            for( size_t l( 0); l != nr_residues - 2; ++l)
            {
              double phi;
              double psi;
              read >> phi >> psi;

              angles.PushBack( storage::VectorND< 2, double>( phi, psi));
            }

            // read in the last phi
            double last_phi;
            read >> last_phi;
            angles.PushBack( storage::VectorND< 2, double>( last_phi, util::GetUndefined< double>()));

            // add the geometry to the vector
            geometry_vector.PushBack
            (
              util::ShPtr< SSEGeometryPhiPsi>
              (
                new SSEGeometryPhiPsi
                (
                  biol::AASequencePhiPsi( n_coords, ca_coords, c_coords, angles),
                  ss_type,
                  identification
                )
              )
            );
          }

          // if the template is not to be excluded
          if( !GetExcludedPdbs().Contains( pdb_id))
          {
            // create the fold template and add it to the map
            fold_template_map[ storage::Pair< size_t, size_t>( helix_ctr, strand_ctr)].PushBack
            (
              util::ShPtr< FoldTemplate>( new FoldTemplate( geometry_vector, sp_collector, pdb_id))
            );
          }
          else
          {
            BCL_MessageStd( "Ignoring fold template " + pdb_id);
          }
        }

        // close the read stream
        io::File::CloseClearFStream( read);
      }

      // end
      return fold_template_map;
    }

    //! @brief gets all fold templates from the requested composition up to a constant size
    //! @param HELICES helical SSEs to be used to find a suitable template
    //! @param STRANDS strand SSEs to be used to find a suitable template
    //! @param SSE_GEOMETRY_COMPARE comparison method
    //! @return all fold templates from the requested composition up to a constant size
    util::ShPtrVector< FoldTemplate> FoldTemplateHandler::GetLargeTemplates
    (
      const util::SiPtrList< const SSE> &HELICES,
      const util::SiPtrList< const SSE> &STRANDS,
      const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE
    )
    {
      // max number of helices or strands possible
      static const size_t s_max_sses( 10);

      // initialize vector of potential templates
      util::ShPtrVector< FoldTemplate> large_templates;

      // if requested size is too big, return an empty vector
      if( HELICES.GetSize() > s_max_sses || STRANDS.GetSize() > s_max_sses)
      {
        return large_templates;
      }

      // create an iterator to the vector of templates with the correct number of helices and strands
      storage::Map
      <
        storage::Pair< size_t, size_t>, util::ShPtrVector< FoldTemplate>
      >::const_iterator map_itr
      (
        GetTemplates().Find( storage::Pair< size_t, size_t>( HELICES.GetSize(), STRANDS.GetSize()))
      );

      // create an iterator to the vector of templates with the correct maximum of helices and strands
      storage::Map
      <
        storage::Pair< size_t, size_t>, util::ShPtrVector< FoldTemplate>
      >::const_iterator map_itr_end
      (
        GetTemplates().Find( storage::Pair< size_t, size_t>( s_max_sses, s_max_sses))
      );

      // if the iterator is invalid
      if( map_itr == GetTemplates().End())
      {
        // set it to the beginning
        map_itr = GetTemplates().Begin();
      }
      ++map_itr_end;

      // combine the SSEs into one list
      util::SiPtrList< const SSE> combined_sses( HELICES);
      combined_sses.Append( STRANDS);

      // iterate through the map
      for( ; map_itr != map_itr_end; ++map_itr)
      {
        // iterate through these templates
        for
        (
          util::ShPtrVector< FoldTemplate>::const_iterator
            template_itr( map_itr->second.Begin()), template_itr_end( map_itr->second.End());
          template_itr != template_itr_end; ++template_itr
        )
        {
          // add the template to the vector if it has enough helices and strands
          if
          (
            map_itr->first.First() >= HELICES.GetSize() &&
            map_itr->first.Second() >= STRANDS.GetSize() &&
            map_itr->first.Second() <= s_max_sses
          )
          {
            // iterate over the SSEs
            for
            (
              util::SiPtrList< const SSE>::const_iterator sse_itr( combined_sses.Begin()),
                sse_itr_end( combined_sses.End());
              sse_itr != sse_itr_end; ++sse_itr
            )
            {
              // make sure the SSE would fit into at least one geometry
              if( !( *template_itr)->HasSimilarSizeGeometry( *sse_itr, SSE_GEOMETRY_COMPARE))
              {
                // skip to next template
                continue;
              }
            }

            // this is a suitable template so push it back
            large_templates.PushBack( *template_itr);
          }
        }
      }

      // end
      return large_templates;
    }

    //! @brief default input filename
    //! @param TEMPLATE_TYPE type of templates to use
    //! @return default input filename
    const std::string &FoldTemplateHandler::GetInputFilename( const std::string &TEMPLATE_TYPE)
    {
      // initialize with default file names
      static const std::string s_soluble_filename( score::Score::AddHistogramPath( "soluble_fold_templates.input"));
      static const std::string s_membrane_filename( score::Score::AddHistogramPath( "membrane_fold_templates.input"));
      static const std::string s_undefined;

      // return filename determined by fold template type
      if( TEMPLATE_TYPE == "soluble")
      {
        return s_soluble_filename;
      }
      else if( TEMPLATE_TYPE == "membrane")
      {
        return s_membrane_filename;
      }

      // type should be soluble or membrane so if this point is reached return default string
      return s_undefined;
    }

    //! @brief return set of excluded pdb ids
    //! @return set of excluded pdb ids
    storage::Set< std::string> &FoldTemplateHandler::GetExcludedPdbs()
    {
      static storage::Set< std::string> s_excluded_pdbs;

      // if a file that contains PDBs to exclude as templates was passed
      if( s_excluded_pdbs.IsEmpty() && GetFlagFoldTemplates()->GetParameterList()( 4)->GetWasSetInCommandLine())
      {
        // open the file
        io::IFStream read;
        io::File::MustOpenIFStream( read, GetFlagFoldTemplates()->GetParameterList()( 4)->GetValue());

        // read in the pdb ids
        while( !read.eof())
        {
          std::string temp_string;
          read >> temp_string;

          // add the string to the set
          if( temp_string != "")
          {
            std::transform( temp_string.begin(), temp_string.end(), temp_string.begin(), toupper);
            s_excluded_pdbs.Insert( temp_string);
          }
        }
        io::File::CloseClearFStream( read);
      }

      // end
      return s_excluded_pdbs;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_aa.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> LocatorAA::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorAA())
    );

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorAA::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gives formatted string description
    //! @return gives formatted string description
    std::string LocatorAA::GetIdentification() const
    {
      std::stringstream write;
      io::Serialize::Write( GetLocatorChain().GetChainID(), write, 1);
      io::Serialize::Write( GetAAID(), write, 1);
      io::Serialize::Write( std::string( "UsePDBID"), write, 1);
      io::Serialize::Write( m_UsePDBID, write, 1);
      return write.str();
    }

    //! @brief reads formatted string describing the locator
    //! @return formatted string describing the locator
    std::istream &LocatorAA::ReadIdentification( std::istream &ISTREAM)
    {
      char chain_id;
      io::Serialize::Read( chain_id, ISTREAM);
      m_LocatorChain.SetChainID( chain_id);
      std::string use_pdb_id;
      io::Serialize::Read( m_AA_ID, ISTREAM);
      io::Serialize::Read( use_pdb_id, ISTREAM);
      io::Serialize::Read( m_UsePDBID, ISTREAM);
      return ISTREAM;
    }

    //! @brief returns a bool indicating if the pdb ids will be used instead of the seq ids
    //! @return boolean true if pdb ids should be used - false otherwise
    bool LocatorAA::GetUsePDBID() const
    {
      return m_UsePDBID;
    }

    //! @brief returns aa type, if known
    //! @return aa type, if known
    const biol::AAType &LocatorAA::GetAAType() const
    {
      return m_AAType;
    }

    //! @brief GetAAID gives the seq id of the amino acid to be located
    //! @return returns "m_AA_ID" int
    int const &LocatorAA::GetAAID() const
    {
      return m_AA_ID;
    }

    //! @brief SetAAID changes the amino acid id
    //! @param AA_ID int which indicates the new amino acid id
    void LocatorAA::SetAAID( const int AA_ID)
    {
      // set "m_AA_ID" to "AA_ID"
      m_AA_ID = AA_ID;
    }

    //! @brief returns the chain locator
    //! @return returns the const reference to the chain locator
    const LocatorChain &LocatorAA::GetLocatorChain() const
    {
      return m_LocatorChain;
    }

    //! @brief SetLocatorChain the chain locator to a new one
    //! @param LOCATOR_CHAIN the new locator chain which "m_LocatorChain" will be set to
    void LocatorAA::SetLocatorChain( const LocatorChain &LOCATOR_CHAIN)
    {
      // set "m_LocatorChain" to "LOCATOR_CHAIN"
      m_LocatorChain = LOCATOR_CHAIN;
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &LocatorAA::GetAlias() const
    {
      static const std::string s_Name( "LocatorAA");
      return s_Name;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief GetAA finds the amino acid denoted by the LocatorAA
    //! @param SSE SSE which the LocatorAA refers to
    //! @return returns SharedPointer to the amino acid denoted by the LocatorAA
    util::SiPtr< const biol::AABase> LocatorAA::Locate( const SSE &SSE) const
    {
      // iterate through the residues of "SSE"
      for
      (
        biol::AASequence::const_iterator
          itr_aa( SSE.Begin()), itr_aa_end( SSE.End());
        itr_aa != itr_aa_end;
        ++itr_aa
      )
      {
        // true if the seq id and the chain ids match
        if
        (
          ( m_UsePDBID ? ( *itr_aa)->GetPdbID() : ( *itr_aa)->GetSeqID()) == m_AA_ID
          && ( *itr_aa)->GetChainID() == m_LocatorChain.GetChainID()
        )
        {
          BCL_MessageDbg( ( *itr_aa)->GetIdentification());

          BCL_Assert
          (
            !m_AAType.IsDefined() || !m_AAType->IsNaturalAminoAcid() || m_AAType == ( *itr_aa)->GetType(),
            "AA types did not match " + m_AAType->GetName() + " != " + ( *itr_aa)->GetType().GetName()
            + " for residue: " + util::Format()( m_AA_ID)
            + " ; check input files and formats "
          );
          // return si ptr to the residue denoted by "itr_aa"
          return util::SiPtr< const biol::AABase>( *itr_aa);
        }
      }

      // return empty siptr since the residue was not found in "SSE"
      return util::SiPtr< const biol::AABase>();
    }

    //! @brief GetAA finds the amino acid denoted by the LocatorAA
    //! @param SSE SSE which the LocatorAA refers to
    //! @return returns SharedPointer to the amino acid denoted by the LocatorAA
    util::SiPtr< biol::AABase> LocatorAA::Locate( SSE &SSE) const
    {
      // iterate through the residues of "SSE"
      for
      (
        biol::AASequence::iterator
          itr_aa( SSE.Begin()), itr_aa_end( SSE.End());
        itr_aa != itr_aa_end;
        ++itr_aa
      )
      {
        // true if the seq id and the chain ids match
        if
        (
          ( m_UsePDBID ? ( *itr_aa)->GetPdbID() : ( *itr_aa)->GetSeqID()) == m_AA_ID
          && ( *itr_aa)->GetChainID() == m_LocatorChain.GetChainID()
        )
        {
          BCL_MessageDbg( ( *itr_aa)->GetIdentification());

          BCL_Assert
          (
            !m_AAType.IsDefined() || !m_AAType->IsNaturalAminoAcid() || m_AAType == ( *itr_aa)->GetType(),
            "AA types did not match " + m_AAType->GetName() + " != " + ( *itr_aa)->GetType().GetName()
            + " for residue: " + util::Format()( m_AA_ID)
            + " ; check input files and formats "
          );
          // return si ptr to the residue denoted by "itr_aa"
          return util::SiPtr< biol::AABase>( *itr_aa);
        }
      }

      // return empty siptr since the residue was not found in "SSE"
      return util::SiPtr< biol::AABase>();
    }

    //! @brief Locate finds the amino acid denoted by the LocatorAA in a list of residues
    //! @param RESIDUE_LIST SSE the list of residues which will be searched for the residue of interest
    //! @return returns SiPtr to the amino acid denoted by the LocatorAA
    util::SiPtr< const biol::AABase> LocatorAA::Locate( const util::SiPtrVector< const biol::AABase> &RESIDUE_LIST) const
    {
      // iterate through the residues in "RESIDUE_LIST"
      for
      (
        util::SiPtrVector< const biol::AABase>::const_iterator
          resi_itr( RESIDUE_LIST.Begin()), resi_itr_end( RESIDUE_LIST.End());
        resi_itr != resi_itr_end;
        ++resi_itr
      )
      {
        // get seq id or pdb id
        int identifier;
        if( m_UsePDBID)
        {
          identifier = ( *resi_itr)->GetPdbID();
        }
        else
        {
          identifier = ( *resi_itr)->GetSeqID();
        }
        // true if the seq id and the chain id of the residue denoted by "resi_itr" matches "CHAIN_ID" and "SEQ_ID"
        if( identifier == m_AA_ID && ( *resi_itr)->GetChainID() == m_LocatorChain.GetChainID())
        {
          BCL_Assert
          (
            !m_AAType.IsDefined() || !m_AAType->IsNaturalAminoAcid() || m_AAType == ( *resi_itr)->GetType(),
            "AA types did not match " + m_AAType->GetName() + " != " + ( *resi_itr)->GetType().GetName()
            + " for residue: " + util::Format()( m_AA_ID)
            + " ; check input files and formats "
          );
          // return "resi_itr" indicating that the residue of interest exists in "RESI_LIST"
          return *resi_itr;
        }
      }

      // residue with chain id "SEQ_ID" and seq id "SEQ_ID" was not found in "RESI_LIST" so return empty SiPtr
      // indicating that it was not found
      return util::SiPtr< const biol::AABase>();
    }

    //! @brief Locate finds the amino acid denoted by the LocatorAA in a list of residues
    //! @param RESIDUE_LIST SSE the list of residues which will be searched for the residue of interest
    //! @return returns SiPtr to the amino acid denoted by the LocatorAA
    util::SiPtr< biol::AABase> LocatorAA::Locate( util::SiPtrVector< biol::AABase> &RESIDUE_LIST) const
    {
      // iterate through the residues in "RESIDUE_LIST"
      for
      (
        util::SiPtrVector< biol::AABase>::iterator
          resi_itr( RESIDUE_LIST.Begin()), resi_itr_end( RESIDUE_LIST.End());
        resi_itr != resi_itr_end;
        ++resi_itr
      )
      {
        // get seq id or pdb id
        int identifier( m_UsePDBID ? ( *resi_itr)->GetPdbID() : ( *resi_itr)->GetSeqID());
        // true if the seq id and the chain id of the residue denoted by "resi_itr" matches "CHAIN_ID" and "SEQ_ID"
        if( identifier == m_AA_ID && ( *resi_itr)->GetChainID() == m_LocatorChain.GetChainID())
        {
          if( m_AAType.IsDefined() && m_AAType->IsNaturalAminoAcid() && m_AAType != ( *resi_itr)->GetType())
          {
            BCL_MessageVrb
            (
              "AA types did not match " + m_AAType->GetName() + " != " + ( *resi_itr)->GetType().GetName()
              + " for residue: " + util::Format()( m_AA_ID)
              + " ; check input files and formats "
            );
            return util::SiPtr< biol::AABase>();
          }
          // return "resi_itr" indicating that the residue of interest exists in "RESI_LIST"
          return *resi_itr;
        }
      }

      // residue with chain id "SEQ_ID" and seq id "SEQ_ID" was not found in "RESI_LIST" so return empty SiPtr
      // indicating that it was not found
      return util::SiPtr< biol::AABase>();
    }

    //! @brief GetSSE finds the SSE which contains the amino acid denoted by the LocatorAA
    //! @param PROTEIN_MODEL ProteinModel which the LocatorAA refers to
    //! @return returns SharedPointer to the SSE containing the amino acid denoted by the LocatorAA
    util::SiPtr< const SSE> LocatorAA::LocateSSE( const ProteinModel &PROTEIN_MODEL) const
    {
      // iterate over the SSEs of the chain to see which SSE contains the amino acid
      auto chain( m_LocatorChain.Locate( PROTEIN_MODEL));
      if( !chain.IsDefined())
      {
        return util::SiPtr< const SSE>();
      }
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          itr_begin( chain->GetData().Begin()),
          itr_end( chain->GetData().End());
        itr_begin != itr_end;
        ++itr_begin
      )
      {
        // get seq id or pdb id of the first and last residues of the sse
        int first_identifier, last_identifier;

        if( m_UsePDBID)
        {
          first_identifier = ( *itr_begin)->GetFirstAA()->GetPdbID();
          last_identifier = ( *itr_begin)->GetLastAA()->GetPdbID();
        }
        else
        {
          first_identifier = ( *itr_begin)->GetFirstAA()->GetSeqID();
          last_identifier = ( *itr_begin)->GetLastAA()->GetSeqID();
        }

        // check to see if the SeqIDs of the first and last amino acids of current SSE contain "m_AA_ID"
        if
        (
          first_identifier <= m_AA_ID &&
          last_identifier >= m_AA_ID
        )
        {
          // if so then return the SSE denoted by "itr_begin"
          return *itr_begin;
        }
      }

      // return empty shared pointer if SSE containing the amino acid is not found
      BCL_MessageDbg
      (
        "sse containing " + util::Format()( m_AA_ID) + " does not exist in protein model"
      );
      return util::SiPtr< const SSE>();
    }

    //! @brief GetAA finds the amino acid denoted by the LocatorAA
    //! @param PROTEIN_MODEL ProteinModel which the LocatorAA refers to
    //! @return returns SharedPointer to the amino acid denoted by the LocatorAA
    util::SiPtr< const biol::AABase> LocatorAA::Locate( const ProteinModel &PROTEIN_MODEL) const
    {
      const auto located_sse( this->LocateSSE( PROTEIN_MODEL));
      if( located_sse.IsDefined())
      {
        return this->Locate( *located_sse);
      }

      // if "sse" is not defined
      // return empty simple pointer
      BCL_MessageDbg
      (
        "amino acid with seqid " + util::Format()( m_AA_ID) + " in chain " + m_LocatorChain.GetChainID()
        + " does not exist in protein model"
      );
      return util::SiPtr< const biol::AABase>();
    }

    //! @brief GetSSE finds the SSE which contains the amino acid denoted by the LocatorAA
    //! @param PROTEIN_MODEL ProteinModel which the LocatorAA refers to
    //! @return returns SharedPointer to the SSE containing the amino acid denoted by the LocatorAA
    util::SiPtr< SSE> LocatorAA::LocateSSE( ProteinModel &PROTEIN_MODEL) const
    {
      // iterate over the SSEs of the chain to see which SSE contains the amino acid
      auto chain( m_LocatorChain.Locate( PROTEIN_MODEL));
      if( !chain.IsDefined())
      {
        return util::SiPtr< SSE>();
      }
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::iterator
          itr_begin( chain->GetData().Begin()),
          itr_end( chain->GetData().End());
        itr_begin != itr_end;
        ++itr_begin
      )
      {
        // get seq id or pdb id of the first and last residues of the sse
        int first_identifier, last_identifier;

        if( m_UsePDBID)
        {
          first_identifier = ( *itr_begin)->GetFirstAA()->GetPdbID();
          last_identifier = ( *itr_begin)->GetLastAA()->GetPdbID();
        }
        else
        {
          first_identifier = ( *itr_begin)->GetFirstAA()->GetSeqID();
          last_identifier = ( *itr_begin)->GetLastAA()->GetSeqID();
        }

        // check to see if the SeqIDs of the first and last amino acids of current SSE contain "m_AA_ID"
        if
        (
          first_identifier <= m_AA_ID &&
          last_identifier >= m_AA_ID
        )
        {
          // if so then return the SSE denoted by "itr_begin"
          util::ShPtr< SSE> sse( *itr_begin);
          return util::SiPtr< SSE>( sse);
        }
      }

      // return empty shared pointer if SSE containing the amino acid is not found
      BCL_MessageDbg
      (
        "sse containing " + util::Format()( m_AA_ID) + " does not exist in protein model"
      );
      return util::SiPtr< SSE>();
    }

    //! @brief GetAA finds the amino acid denoted by the LocatorAA
    //! @param PROTEIN_MODEL ProteinModel which the LocatorAA refers to
    //! @return returns SharedPointer to the amino acid denoted by the LocatorAA
    util::SiPtr< biol::AABase> LocatorAA::Locate( ProteinModel &PROTEIN_MODEL) const
    {
      util::SiPtr< SSE> located_sse( this->LocateSSE( PROTEIN_MODEL));
      if( located_sse.IsDefined())
      {
        return this->Locate( *located_sse);
      }

      // if "sse" is not defined
      // return empty simple pointer
      BCL_MessageDbg
      (
        "amino acid with seqid " + util::Format()( m_AA_ID) + " in chain " + m_LocatorChain.GetChainID()
        + " does not exist in protein model"
      );
      return util::SiPtr< biol::AABase>();
    }

    //! @brief GetAA finds the amino acid denoted by the LocatorAA
    //! @param PROTEIN_MODEL ProteinModel which the LocatorAA refers to
    //! @return returns SharedPointer to the amino acid denoted by the LocatorAA
    util::SiPtr< const biol::AABase> LocatorAA::Locate( const DomainInterface &PROTEIN_MODEL) const
    {
      auto sses( PROTEIN_MODEL.GetSSEs());
      for( auto itr_sse( sses.Begin()), itr_sse_end( sses.End()); itr_sse != itr_sse_end; ++itr_sse)
      {
        if( ( *itr_sse)->GetChainID() != m_LocatorChain.GetChainID())
        {
          continue;
        }
        const auto &last_aa( *( *itr_sse)->GetLastAA());
        const int last_id( m_UsePDBID ? last_aa.GetPdbID() : last_aa.GetSeqID());
        if( last_id >= m_AA_ID)
        {
          const auto &first_aa( *( *itr_sse)->GetFirstAA());
          const int first_id( m_UsePDBID ? first_aa.GetPdbID() : first_aa.GetSeqID());
          if( first_id <= m_AA_ID)
          {
            return this->Locate( **itr_sse);
          }
        }
      }

      // if "sse" is not defined
      // return empty simple pointer
      BCL_MessageDbg
      (
        "amino acid with seqid " + util::Format()( m_AA_ID) + " in chain " + m_LocatorChain.GetChainID()
        + " does not exist in protein model"
      );
      return util::SiPtr< const biol::AABase>();
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LocatorAA::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription
      (
        "Is used for locating a specified amino acid from a protein model. This class is used for locating "
        "a specified amino acid from a given protein model. It uses first the member chain locator to find the "
        "corresponding chain and then iterates over the amino acids of the SSEs to find the amino acid with the"
        "specified amino acid seq id."
      );

      parameters.AddInitializer
      (
        "locator_chain",
        "the chain locator that should be used to get the chain with the desired residue",
        io::Serialization::GetAgentWithRange( &m_LocatorChain.GetChainID(), 'A', 'Z')
      );

      parameters.AddInitializer
      (
        "seq_id",
        "the seq id of the desired residue",
        io::Serialization::GetAgent( &m_AA_ID),
        "1"
      );

      parameters.AddInitializer
      (
        "aa type",
        "the aa type; useful to verify that the same sequences/ids/formats are being used",
        io::Serialization::GetAgent( &m_AAType),
        "Undefined"
      );

      parameters.AddInitializer
      (
        "use_pdb_id",
        "boolean if true, the pdb id will be used for location (as opposed to the seq id). 1=true;0=false",
        io::Serialization::GetAgent( &m_UsePDBID),
        "0"
      );

      return parameters;
    }

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorAA::Read( std::istream &ISTREAM)
    {
      return util::SerializableInterface::Read( ISTREAM);
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorAA::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return util::SerializableInterface::Write( OSTREAM, INDENT);
    }

    //! @brief less than operator for comparing two locator aa objects by seq and chain id
    //! @param LOCATOR_LHS the first locator
    //! @param LOCATOR_RHS the second locator
    //! @return boolean true if LOCATOR_LHS is less than LOCATOR_RHS - false otherwise
    bool operator<( const LocatorAA &LOCATOR_LHS, const LocatorAA &LOCATOR_RHS)
    {
      // compare chain id
      if( LOCATOR_LHS.GetLocatorChain().GetChainID() < LOCATOR_RHS.GetLocatorChain().GetChainID())
      {
        return true;
      }

      if( LOCATOR_LHS.GetLocatorChain().GetChainID() > LOCATOR_RHS.GetLocatorChain().GetChainID())
      {
        return false;
      }

      // chain id match
      // compare seq id
      return LOCATOR_LHS.GetAAID() < LOCATOR_RHS.GetAAID();
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_atom_coordinates_interface.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_atom.h"
#include "assemble/bcl_assemble_sse.h"
#include "util/bcl_util_string_replacement.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  /////////////////
  // data access //
  /////////////////

    //! @brief gives formatted string describing the locator
    //! @return formatted string describing the locator
    std::string LocatorAtomCoordinatesInterface::GetIdentification() const
    {
      return util::Format()( GetChainID()) + " " +
        util::Format()( GetSeqID()) + " " + GetAtomType().GetName() + " " + GetAAType().GetName();
    }

    //! @brief gives identifier that can be used for selections in pymol
    //! @return gives string which is an identifier that can be used for selections in pymol
    const std::string LocatorAtomCoordinatesInterface::GetPymolName() const
    {
      return util::Format()( GetChainID()) + "_" +
        util::Format()( GetSeqID()) + "_" + GetAtomType().GetName();
    }

    //! @brief gives identifier that can be used for selections in pymol
    //! @return gives string which is an identifier that can be used for selections in pymol
    const std::string LocatorAtomCoordinatesInterface::GetPymolAtomSelection() const
    {
      return " chain " + util::Format()( GetChainID()) + " and resi " +
        util::Format()( GetSeqID()) + " and name " + GetAtomType().GetName();
    }

    //! @brief gives identifier that can be used for selections in pymol
    //! @return gives string which is an identifier that can be used for selections in pymol
    const std::string LocatorAtomCoordinatesInterface::GetPymolResidueSelection() const
    {
      return " chain " + util::Format()( GetChainID()) + " and resi " +
        util::Format()( GetSeqID());
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief locates an atom from a protein model
    //! @param PROTEIN_MODEL model from which the atom will be located
    //! @return siptr to atom that has been located from PROTEIN_MODEL
    util::SiPtr< const biol::Atom>
    LocatorAtomCoordinatesInterface::LocateAtom( const ProteinModel &PROTEIN_MODEL) const
    {
        return LocatorAtom::LocateAtomFromModel( PROTEIN_MODEL, GetChainID(), GetSeqID(), GetAtomType());
    }

    //! @brief locates an atom from a protein model
    //! @param PROTEIN_MODEL model from which the atom will be located
    //! @return copy of atom that has been located from PROTEIN_MODEL
    biol::Atom LocatorAtomCoordinatesInterface::LocateAtomCopy( const ProteinModel &PROTEIN_MODEL) const
    {
      // try to locate atom
      const util::SiPtr< const biol::Atom> atom
      (
        LocatorAtom::LocateAtomFromModel( PROTEIN_MODEL, GetChainID(), GetSeqID(), GetAtomType())
      );

      // true if atom could not be found
      if( !atom.IsDefined())
      {
        // return empty atom
        return biol::Atom();
      }

      // atom is defined so return atom behind pointer
      return *atom;
    }

    //! @brief locates an aa from a protein model
    //! @param PROTEIN_MODEL model from which the aa will be located
    //! @return siptr to aabase that has been located from PROTEIN_MODEL
    util::SiPtr< const biol::AABase>
    LocatorAtomCoordinatesInterface::LocateAA( const ProteinModel &PROTEIN_MODEL) const
    {
      return LocatorAA( GetChainID(), GetSeqID()).Locate( PROTEIN_MODEL);
    }

    //! @brief locates an aa from an sse
    //! @param SSE the sse from which the aa will be located
    //! @return siptr to aabase that has been located from SSE
    util::SiPtr< const biol::AABase> LocatorAtomCoordinatesInterface::LocateAA( const SSE &SSE)
    {
      return LocateAA( SSE.GetMembers());
    }

    //! @brief locates an aa from a list of residues
    //! @param RESIDUE_LIST the list of residues which will be searched for the residue of interest
    //! @return siptr to aabase that has been located from RESIDUE_LIST
    util::SiPtr< const biol::AABase>
    LocatorAtomCoordinatesInterface::LocateAA( const util::SiPtrVector< const biol::AABase> &RESIDUE_LIST) const
    {
      return LocatorAA( GetChainID(), GetSeqID()).Locate( RESIDUE_LIST);
    }

    //! @brief locates an sse from a protein model
    //! @param PROTEIN_MODEL model from which the sse will be found
    //! @return siptr to aa base that has been located from PROTEIN_MODEL
    util::SiPtr< const SSE>
    LocatorAtomCoordinatesInterface::LocateSSE( const ProteinModel &PROTEIN_MODEL) const
    {
      return LocatorAA( GetChainID(), GetSeqID()).LocateSSE( PROTEIN_MODEL);
    }

    //! @brief locates the SSE this locator is in from a list of SSEs
    //! @param SSES the list of SSEs from which the sse this locator is within will be found
    //! @return siptr to sse that contains this locator
    util::SiPtr< const SSE> LocatorAtomCoordinatesInterface::LocateSSE
    (
      const util::SiPtrVector< const SSE> &SSES
    ) const
    {
      // iterate through the sses
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( SSES.Begin()), sse_itr_end( SSES.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // true if the locator indicates a part of the current sse
        if( IsWithin( **sse_itr))
        {
          // return siptr to current sse
          return *sse_itr;
        }
      }

      // locator does not refer to any part of the provided sses
      return util::SiPtr< const SSE>();
    }

    //! @brief locates the SSE this locator is in from a set of SSEs
    //! @param SSES the list of SSEs from which the sse this locator is within will be found
    //! @return siptr to sse that contains this locator
    util::SiPtr< const SSE> LocatorAtomCoordinatesInterface::LocateSSE
    (
      const storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> &SSES
    ) const
    {
      // iterate through the sses
      for
      (
        storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap>::const_iterator
          sse_itr( SSES.Begin()), sse_itr_end( SSES.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // true if the locator indicates a part of the current sse
        if( IsWithin( **sse_itr))
        {
          // return siptr to current sse
          return *sse_itr;
        }
      }

      // locator does not refer to any part of the provided sses
      return util::SiPtr< const SSE>();
    }

    //! @brief determines if this locator is within a given SSE
    //! @param SSE the sse which will be checked to see if this lcoator is within it
    //! @return bool true if this locator is within the SSE - false otherwise
    bool LocatorAtomCoordinatesInterface::IsWithin( const SSE &SSE) const
    {
      // get information about this locator and the SSE
      const char chain_id( GetChainID());
      const int seq_id( GetSeqID());
      const int sse_start( SSE.GetFirstAA()->GetSeqID());
      const int sse_end( SSE.GetLastAA()->GetSeqID());
      const char sse_chain_id( SSE.GetChainID());

      return chain_id == sse_chain_id && seq_id >= sse_start && seq_id <= sse_end;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief gives a name from an atom locator with no spaces
    //! @param LOCATOR_A first locator to get name from
    //! @param LOCATOR_B second locator to get name from
    //! @return string that represents the pair of locators
    std::string LocatorAtomCoordinatesInterface::GetNameFromPair
    (
      const LocatorAtomCoordinatesInterface &LOCATOR_A,
      const LocatorAtomCoordinatesInterface &LOCATOR_B
    )
    {
      // string replacer to remove undefined atom names
      static const util::StringReplacement s_undefined_replacer( util::StringReplacement::e_Any, "Undefined", "");

      // first locator name
      const std::string name_a
      (
        util::Format()( LOCATOR_A.GetChainID()) + util::Format()( LOCATOR_A.GetSeqID())
        + LOCATOR_A.GetAtomType().GetName()
      );

      // second locator name
      const std::string name_b
      (
        util::Format()( LOCATOR_B.GetChainID()) + util::Format()( LOCATOR_B.GetSeqID())
        + LOCATOR_B.GetAtomType().GetName()
      );

      // name of pair
      std::string name( name_a + name_b);

      // remove undefined atom names
      s_undefined_replacer.ReplaceEachIn( name);

      // return name
      return name;
    }

    //! @brief less than operator for comparing two LocatorAtomCoordinatesInterface
    //! @param LHS the first LocatorAtomCoordinatesInterface
    //! @param RHS the second LocatorAtomCoordinatesInterface
    //! @return bool true if LHS is less than RHS - false otherwise
    bool operator <( const LocatorAtomCoordinatesInterface &LHS, const LocatorAtomCoordinatesInterface &RHS)
    {
      return
        LocatorAtom( LHS.GetChainID(), LHS.GetSeqID(), LHS.GetAtomType()) <
        LocatorAtom( RHS.GetChainID(), RHS.GetSeqID(), RHS.GetAtomType());
    }

    //! @brief not equal operator for comparing two LocatorAtomCoordinatesInterface
    //! @param LHS the first LocatorAtomCoordinatesInterface
    //! @param RHS the second LocatorAtomCoordinatesInterface
    //! @return bool true if LHS not equal to RHS - false otherwise
    bool operator !=( const LocatorAtomCoordinatesInterface &LHS, const LocatorAtomCoordinatesInterface &RHS)
    {
      return
        LocatorAtom( LHS.GetChainID(), LHS.GetSeqID(), LHS.GetAtomType()) !=
        LocatorAtom( RHS.GetChainID(), RHS.GetSeqID(), RHS.GetAtomType());
    }

    //! @brief helper binary operator struct for comparing objects behind pointers to this interface
    //! @param LHS first  pointer to LocatorAtomCoordinatesInterface
    //! @param RHS second pointer to LocatorAtomCoordinatesInterface
    //! @return bool true if LHS object behind pointer is less than RHS object behind pointer - false otherwise
    bool LocatorAtomCoordinatesInterface::PtrLessThan::operator()
    (
      const util::PtrInterface< LocatorAtomCoordinatesInterface> &LHS,
      const util::PtrInterface< LocatorAtomCoordinatesInterface> &RHS
    ) const
    {
      return *LHS < *RHS;
    }

    //! @brief helper binary operator struct for comparing objects behind pointers to this interface
    //! @param LHS first  pointer to LocatorAtomCoordinatesInterface
    //! @param RHS second pointer to LocatorAtomCoordinatesInterface
    //! @return bool true if LHS object behind pointer is less than RHS object behind pointer - false otherwise
    bool LocatorAtomCoordinatesInterface::PtrResidueLessThan::operator()
    (
      const util::PtrInterface< LocatorAtomCoordinatesInterface> &LHS,
      const util::PtrInterface< LocatorAtomCoordinatesInterface> &RHS
    ) const
    {
      return LocatorAA( LHS->GetChainID(), LHS->GetSeqID()) < LocatorAA( RHS->GetChainID(), RHS->GetSeqID());
    }

  } // namespace assemble
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_atom.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LocatorAtom::s_Instance
    (
      util::Enumerated< find::LocatorCoordinatesInterface< ProteinModel> >::AddInstance
      (
        util::Enumerated< LocatorAtomCoordinatesInterface>::AddInstance
        (
          new LocatorAtom()
        )
      )
    );

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorAtom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gives formatted string describing the locator
    //! @return formatted string describing the locator
    std::string LocatorAtom::GetIdentification() const
    {
      std::stringstream write;
      write << m_LocatorAA.GetIdentification();
      io::Serialize::Write( GetAtomType().GetName(), write, 1);
      return write.str();
    }

    //! @brief reads formatted string describing the locator
    //! @return formatted string describing the locator
    std::istream &LocatorAtom::ReadIdentification( std::istream &ISTREAM)
    {
      m_LocatorAA.ReadIdentification( ISTREAM);
      std::string enum_name;
      io::Serialize::Read( enum_name, ISTREAM);
      m_Atom_Type = biol::GetAtomTypes().GetEnumFromName( enum_name);
      return ISTREAM;
    }

    //! @brief gives the chain id the locator corresponds to
    //! @return the chain id the locator corresponds to
    char LocatorAtom::GetChainID() const
    {
      return m_LocatorAA.GetLocatorChain().GetChainID();
    }

    //! @brief gives the seq id the locator corresponds to
    //! @return the seq id the locator corresponds to
    int LocatorAtom::GetSeqID() const
    {
      return m_LocatorAA.GetAAID();
    }

    //! GetAtom gives the atom name
    //! @return returns "m_Atom_Type"
    const biol::AtomType &LocatorAtom::GetAtomType() const
    {
      return m_Atom_Type;
    }

    //! @brief gives the aa type the locator corresponds to
    //! @return the aa type the locator corresponds to
    const biol::AAType &LocatorAtom::GetAAType() const
    {
      return biol::GetAATypes().e_Undefined;
    }

    //! SetAtomID changes the atom name to be located
    //! @param ATOM_TYPE AtomType which indicates the new atom to be located
    void LocatorAtom::SetAtomType( const biol::AtomType &ATOM_TYPE)
    {
      // set "m_Atom_Type" to "ATOM_TYPE"
      m_Atom_Type = ATOM_TYPE;
    }

    //! returns the AA locator
    //! @return returns the const reference to the AA locator
    const LocatorAA &LocatorAtom::GetLocatorAA() const
    {
      return m_LocatorAA;
    }

    //! @brief returns the AA locator
    //! @return returns the reference to the AA locator
    void LocatorAtom::SetLocatorAA( const LocatorAA &LOCATOR_AA)
    {
      m_LocatorAA = LOCATOR_AA;
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &LocatorAtom::GetAlias() const
    {
      static const std::string s_Name( "LocatorAtom");
      return s_Name;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Locate translates the LocatorAtom denoting an atom into the actual atom
    //! @param PROTEIN_MODEL ProteinModel which the LocatorAtom refers to
    //! @param CHAIN_ID the chain id the atom is in
    //! @param SEQ_ID the seq id of the residue the atom is in
    //! @param ATOM_TYPE the atom type that should be located
    //! @return the atom denoted by the LocatorAtom
    util::SiPtr< const biol::Atom> LocatorAtom::LocateAtomFromModel
    (
      const ProteinModel &PROTEIN_MODEL, const char CHAIN_ID, const int SEQ_ID, const biol::AtomType &ATOM_TYPE
    )
    {
      util::SiPtr< const biol::AABase> amino_acid( LocatorAA( CHAIN_ID, SEQ_ID).Locate( PROTEIN_MODEL));

      if( !amino_acid.IsDefined())
      {
        BCL_MessageDbg
        (
          "Locator atom: Chain " + util::Format()( CHAIN_ID) + " and amino acid with seqid " + util::Format()( SEQ_ID)
          + " does not exist in protein model"
        );

        return util::SiPtr< const biol::Atom>();
      }

      util::SiPtr< const biol::Atom> atom( amino_acid->GetAtom( ATOM_TYPE));
      if( !atom.IsDefined())
      {
        BCL_MessageDbg
        (
          "atom " + util::Format()( ATOM_TYPE) + " in chain " + util::Format()( CHAIN_ID)
          + " and amino acid with seqid " + util::Format()( SEQ_ID)
          + "does not exist in protein model"
        );
      }

      return atom;
    }

    //! @brief locates an atom from a protein model
    //! @param PROTEIN_MODEL model from which the atom will be located
    //! @return siptr to atom that has been located from PROTEIN_MODEL
    util::SiPtr< const biol::Atom>
    LocatorAtom::LocateAtom( const ProteinModel &PROTEIN_MODEL) const
    {
      util::SiPtr< const biol::AABase> amino_acid( m_LocatorAA.Locate( PROTEIN_MODEL));

      if( !amino_acid.IsDefined())
      {
        BCL_MessageDbg
        (
          "Locator atom: Chain " + util::Format()( m_LocatorAA.GetLocatorChain().GetChainID()) +
          " and amino acid with seqid " + util::Format()( m_LocatorAA.GetAAID())
          + " does not exist in protein model"
        );

        return util::SiPtr< const biol::Atom>();
      }

      util::SiPtr< const biol::Atom> atom( amino_acid->GetAtom( m_Atom_Type));
      if( !atom.IsDefined())
      {
        BCL_MessageDbg
        (
          "atom " + util::Format()( m_Atom_Type) + " in chain " +
          util::Format()( m_LocatorAA.GetLocatorChain().GetChainID())
          + " and amino acid with seqid " + util::Format()( m_LocatorAA.GetAAID())
          + "does not exist in protein model"
        );
      }

      return atom;
    }

    //! @brief locates the desired coordinates from a protein model
    //! @param PROTEIN_MODEL ProteinModel which the LocatorAtom refers to
    //! @return the coordinates of the atom denoted by the LocatorAtom
    linal::Vector3D LocatorAtom::Locate( const ProteinModel &PROTEIN_MODEL) const
    {
      // try to locate the atom
      util::SiPtr< const biol::Atom> atom( LocateAtom( PROTEIN_MODEL));

      // true if the ptr to atom is not defined
      if( !atom.IsDefined())
      {
        // return undefined vector3d
        return linal::Vector3D( util::GetUndefinedDouble());
      }

      // return the coordinates of the atom
      return atom->GetCoordinates();
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LocatorAtom::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription
      (
        "This class is used for locating a specified atom from a protein model. This class uses the member "
        "LocatorAA to find the corresponding atom and then finds the corresponding atom from that amino acid with the "
        "specified atom type."
      );

      parameters.AddInitializer
      (
        "locator_aa",
        "the residue locator that should be used to get the residue with the desired atom",
        io::Serialization::GetAgent( &m_LocatorAA)
      );

      parameters.AddInitializer
      (
        "atom_type",
        "the atom type to locate",
        io::Serialization::GetAgent( &m_Atom_Type)
      );

      return parameters;
    }

    //! @brief less than operator for comparing two LocatorAtom
    //! @param LHS the first LocatorAtom which will be compared against the second LocatorAtom
    //! @param RHS the second LocatorAtom which will be compared against the first LocatorAtom
    //! @return boolean true if LHS is less than RHS - false otherwise
    bool operator<( const LocatorAtom &LOCATOR_A, const LocatorAtom &LOCATOR_B)
    {
      // chain inequality
      if( LOCATOR_A.GetLocatorAA().GetLocatorChain().GetChainID() < LOCATOR_B.GetLocatorAA().GetLocatorChain().GetChainID())
      {
        return true;
      }
      if( LOCATOR_A.GetLocatorAA().GetLocatorChain().GetChainID() > LOCATOR_B.GetLocatorAA().GetLocatorChain().GetChainID())
      {
        return false;
      }

      // seq id inequality
      if( LOCATOR_A.GetLocatorAA().GetAAID() < LOCATOR_B.GetLocatorAA().GetAAID())
      {
        return true;
      }
      if( LOCATOR_A.GetLocatorAA().GetAAID() > LOCATOR_B.GetLocatorAA().GetAAID())
      {
        return false;
      }

      return LOCATOR_A.GetAtomType() < LOCATOR_B.GetAtomType();
    }

    //! @brief not equal operator for comparing two LocatorAtom
    //! @param LHS the first LocatorAtom
    //! @param RHS the second LocatorAtom
    //! @return bool true if LHS not equal to RHS - false otherwise
    bool operator!=( const LocatorAtom &LOCATOR_A, const LocatorAtom &LOCATOR_B)
    {
      return LOCATOR_A.GetLocatorAA().GetLocatorChain().GetChainID() != LOCATOR_B.GetLocatorAA().GetLocatorChain().GetChainID() ||
             LOCATOR_A.GetLocatorAA().GetAAID()                      != LOCATOR_B.GetLocatorAA().GetAAID()                      ||
             LOCATOR_A.GetAtomType()                                 != LOCATOR_B.GetAtomType();
    }

    //! @brief equal operator for comparing two LocatorAtom
    //! @param LHS the first LocatorAtom
    //! @param RHS the second LocatorAtom
    //! @return bool true if LHS equal to RHS - false otherwise
    bool operator==( const LocatorAtom &LOCATOR_A, const LocatorAtom &LOCATOR_B)
    {
      return !( LOCATOR_A != LOCATOR_B);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_chain.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> LocatorChain::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorChain())
    );

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorChain::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! GetChainID gives the LocatorChain
    //! @return returns "m_Chain_ID" character
    const char &LocatorChain::GetChainID() const
    {
      return m_Chain_ID;
    }

    //! SetChainID changes the chain id
    //! @param CHAINID char which indicates the new chain id
    void LocatorChain::SetChainID( const char CHAINID)
    {
      // set "m_Chain_ID" to "CHAINID"
      m_Chain_ID = CHAINID;
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &LocatorChain::GetAlias() const
    {
      static const std::string s_Name( "LocatorChain");
      return s_Name;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Locate gets the chain of the ProteinModel symbolized by the LocatorChain
    //! @param MODEL ProteinModel for which the chain is wanted
    //! @return returns
    util::SiPtr< const Chain> LocatorChain::Locate( const ProteinModel &MODEL) const
    {
      util::SiPtr< const Chain> chain( MODEL.GetChain( m_Chain_ID));
      if( !chain.IsDefined())
      {
        BCL_MessageDbg
        (
          "chain " + util::Format()( m_Chain_ID) + " does not exist in protein model"
        );
      }
      return chain;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LocatorChain::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription( "Locates a specified chain in the given protein model");

      parameters.AddInitializer
      (
        "chain_id",
        "the chain id of the desired chain",
        io::Serialization::GetAgent( &m_Chain_ID),
        "A"
      );

      return parameters;
    }

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorChain::Read( std::istream &ISTREAM)
    {
      return util::SerializableInterface::Read( ISTREAM);
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorChain::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return util::SerializableInterface::Write( OSTREAM, INDENT);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_domain_random.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LocatorDomainRandom::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorDomainRandom())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorDomainRandom::LocatorDomainRandom() :
      m_DomainSizeRange( 1, 1),
      m_SSType( biol::GetSSTypes().COIL)
    {
    }

    //! @brief constructor from a domain size range and SSTypes
    //! @param DOMAIN_SIZE_RANGE min and max sizes of the domain to be collected
    //! @param SS_TYPE SSType to be collected
    LocatorDomainRandom::LocatorDomainRandom
    (
      const math::Range< size_t> &DOMAIN_SIZE_RANGE,
      const biol::SSType &SS_TYPE
    ) :
      m_DomainSizeRange( DOMAIN_SIZE_RANGE),
      m_SSType( SS_TYPE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LocatorDomainRandom
    LocatorDomainRandom *LocatorDomainRandom::Clone() const
    {
      return new LocatorDomainRandom( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorDomainRandom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the domain size range
    //! @return the domain size range
    const math::Range< size_t> &LocatorDomainRandom::GetDomainSizeRange() const
    {
      return m_DomainSizeRange;
    }

    //! @brief returns the sstype
    //! @return the sstype
    const biol::SSType &LocatorDomainRandom::GetSSType() const
    {
      return m_SSType;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief locates a random domain and returns it
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return randomly located domain
    util::ShPtr< Domain> LocatorDomainRandom::Locate( const ProteinModel &PROTEIN_MODEL) const
    {
      // collect the SSEs from the given model as a domain
      util::ShPtr< Domain> sp_domain( new Domain( PROTEIN_MODEL.GetSSEsAsDomain( m_SSType)));

      // if there are not enough SSEs
      if( sp_domain->GetNumberSSEs() < m_DomainSizeRange.GetMin())
      {
        // warn user and return
        BCL_MessageVrb
        (
          "The given model does not have enough SSEs " + util::Format()( sp_domain->GetNumberSSEs()) + " vs " +
          util::Format()( m_DomainSizeRange.GetMin())
        )
        return util::ShPtr< Domain>();
      }

      // determine the size of the domain
      const size_t domain_size
      (
        random::GetGlobalRandom().SizeT
        (
          math::Range< size_t>
          (
            m_DomainSizeRange.GetMin(),
            std::min( sp_domain->GetNumberSSEs(), m_DomainSizeRange.GetMax())
          )
        )
      );

      // while not reached
      while( !sp_domain->IsEmpty() && sp_domain->GetNumberSSEs() != size_t( domain_size))
      {
        // get a random iterator
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator random_itr
        (
          random::GetGlobalRandom().Iterator
          (
            sp_domain->GetData().Begin(), sp_domain->GetData().End(), sp_domain->GetNumberSSEs()
          )
        );

        // remove the element from the domain
        sp_domain->Remove( **random_itr);
      }

      // end
      return sp_domain;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorDomainRandom::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_DomainSizeRange, ISTREAM);
      io::Serialize::Read( m_SSType, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorDomainRandom::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_DomainSizeRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SSType, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_domain_specified.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_locator_sse.h"
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LocatorDomainSpecified::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorDomainSpecified())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorDomainSpecified::LocatorDomainSpecified() :
      m_Locators()
    {
    }

    //! @brief constructor taking member variable
    //! @param LOCATORS locators to specify the sses that make up the domain
    LocatorDomainSpecified::LocatorDomainSpecified
    (
      const util::ShPtrList
      <
        find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface>
      > &LOCATORS
    ) :
      m_Locators( LOCATORS)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LocatorDomainSpecified
    LocatorDomainSpecified *LocatorDomainSpecified::Clone() const
    {
      return new LocatorDomainSpecified( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorDomainSpecified::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief writes a pymol formatted script to stream that highlights this domain
    //! @param OSTREAM the stream to which the script will be written to
    //! @param PYMOL_NAME the name of the selection should be in pymol
    //! @return ostream that the script was written to
    std::ostream &LocatorDomainSpecified::WritePymolDomainFile
    (
      std::ostream &OSTREAM, const std::string &PYMOL_NAME
    ) const
    {
      OSTREAM << "select " << PYMOL_NAME << ", ";
      // iterate through the locators
      for
      (
        util::ShPtrList
        <
          find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface>
        >::const_iterator
          itr( m_Locators.Begin()), itr_end( m_Locators.End());
        itr != itr_end;
        ++itr
      )
      {
        // try to cast the pointer to LocatorSSE
        const util::ShPtr< LocatorSSE> sse_locator( *itr);

        // true if the sse pointer is not defined
        if( !sse_locator.IsDefined())
        {
          // skip to next sse
          BCL_MessageDbg( "locator cannot be cast to a LocatorSSE and won't be written");
          continue;
        }

        // true if not at first locator
        if( itr != m_Locators.Begin())
        {
          // print plus
          OSTREAM << " + ";
        }

        // write the information in pymol format for the current sse
        OSTREAM << " chain " << sse_locator->GetChainID() <<
          " and resi " << sse_locator->GetSSEID().First() << "-" << sse_locator->GetSSEID().Second();
      }

      return OSTREAM;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief locate function to locate domain from protein model
    //! @param MODEL the model from which the domain will be located
    //! @return shptr to the located domain
    util::ShPtr< Domain> LocatorDomainSpecified::Locate( const ProteinModel &MODEL) const
    {
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> sses;

      // iterate through the locators
      for
      (
        util::ShPtrList
        <
          find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface>
        >::const_iterator
          locator_itr( m_Locators.Begin()), locator_itr_end( m_Locators.End());
        locator_itr != locator_itr_end;
        ++locator_itr
      )
      {
        // locate the sse
        const util::SiPtr< const SSE> located_sse( ( *locator_itr)->Locate( MODEL));

        // true if the sse could not be located
        if( !located_sse.IsDefined())
        {
          // go to next
          BCL_MessageDbg( "could not locate sse " + util::Format()( **locator_itr));
          continue;
        }

        // clone the located sse
        const util::ShPtr< SSE> new_sse( located_sse->Clone());

        // insert the sse into the set of sses
        BCL_Assert( sses.Insert( new_sse).second, "could not insert sse " + new_sse->GetIdentification());
      }

      // create domain from the sses
      const util::ShPtr< Domain> domain( new Domain( sses));

      return domain;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorDomainSpecified::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Locators, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorDomainSpecified::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Locators, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_domain_sse_pool_overlapping.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LocatorDomainSSEPoolOverlapping::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorDomainSSEPoolOverlapping())
    );
  
  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorDomainSSEPoolOverlapping::LocatorDomainSSEPoolOverlapping() :
      m_Pool()
    {
    }

    //! @brief constructor taking parameters
    //! @param POOL the pool that will be used as the basis to locate the domain
    LocatorDomainSSEPoolOverlapping::LocatorDomainSSEPoolOverlapping( const SSEPool &POOL) :
      m_Pool( POOL)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LocatorDomainSSEPoolOverlapping
    LocatorDomainSSEPoolOverlapping *LocatorDomainSSEPoolOverlapping::Clone() const
    {
      return new LocatorDomainSSEPoolOverlapping( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorDomainSSEPoolOverlapping::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns reference to pool
    //! @return gives const reference to sse pool
    const SSEPool &LocatorDomainSSEPoolOverlapping::GetPool() const
    {
      return m_Pool;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief locate function to locate domain from protein model
    //! @param LOCATE_DOMAIN the model from which the domain will be located
    //! @return shptr to the located domain
    util::ShPtr< Domain> LocatorDomainSSEPoolOverlapping::Locate( const ProteinModel &MODEL) const
    {
      util::ShPtr< Domain> new_domain( new Domain());

      // get non overlapping set of sses from sse pool
      const util::SiPtrVector< const SSE> sses( m_Pool.GetSSEs());

      // get the sses in the protein model that overlap with them
      util::SiPtrList< const SSE> overlapping_sses
      (
        MODEL.GetOverlappingSSEs( util::SiPtrList< const SSE>( sses.Begin(), sses.End()))
      );

      // add the overlapping sses into the domain
      for
      (
        util::SiPtrList< const SSE>::const_iterator
        overlapping_sses_itr( overlapping_sses.Begin()), overlapping_sses_itr_end( overlapping_sses.End());
          overlapping_sses_itr != overlapping_sses_itr_end;
        ++overlapping_sses_itr
      )
      {
        // clone the sse and put it into the domain, any SSE repeats won't insert
        new_domain->Insert( util::ShPtr< SSE>( ( *overlapping_sses_itr)->Clone()));
      }

      // return the domain
      return new_domain;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorDomainSSEPoolOverlapping::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Pool, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorDomainSSEPoolOverlapping::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Pool, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_aa.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> LocatorSSE::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorSSE())
    );

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetIdentification
    //! @return the GetIdentification
    const std::string LocatorSSE::GetIdentification() const
    {
      return util::Format()( m_ChainID) + " " + util::Format()( m_StartAAID) + " " + util::Format()( m_EndAAID);
    }

    //! GetSSEID gives the LocatorSSE
    //! @return returns storage::Pair< size_t, size_t> with the start and end SeqIDs of the amino acids
    storage::VectorND< 2, int> LocatorSSE::GetSSEID() const
    {
      return storage::VectorND< 2, int>( m_StartAAID, m_EndAAID);
    }

    //! @brief gives an identifying string for this locator
    //! @return returns an identifying string for this locator
    std::string LocatorSSE::GetSSEIDString() const
    {
      // construct and return the id string
      std::string id
      (
        util::Format()(           m_ChainID) + " " +
        util::Format().W( 4).R()( m_StartAAID) + " " +
        util::Format().W( 4).R()( m_EndAAID)
      );
      if( m_UsePDBID)
      {
        id += " use_pdb_id";
      }

      return id;
    }

    //! SetSSEID changes the SSE identifiers
    //! @param NEW_SSE_START size_t which indicates the new SSE start
    //! @param NEW_SSE_END size_t which indicates the new SSE end
    void LocatorSSE::SetSSEID( const int NEW_SSE_START, const int NEW_SSE_END)
    {
      // set start and end ids of SSE
      m_StartAAID = NEW_SSE_START;
      m_EndAAID = NEW_SSE_END;
    }

    //! returns the chain locator
    //! @return returns the const reference to the chain locator
    const char &LocatorSSE::GetChainID() const
    {
      return m_ChainID;
    }

    //! @brief get the aa locator for the start residue
    //! @return a locator to locate the start AA in the SSE
    const LocatorAA LocatorSSE::StartAALocator() const
    {
      return LocatorAA( m_ChainID, m_StartAAID, m_UsePDBID);
    }

    //! @brief get the aa locator for the end residue
    //! @return a locator to locate the end AA in the SSE
    const LocatorAA LocatorSSE::EndAALocator() const
    {
      return LocatorAA( m_ChainID, m_EndAAID, m_UsePDBID);
    }

    //! @brief get a short name for this class
    //! @return a short name for this class
    const std::string &LocatorSSE::GetAlias() const
    {
      static const std::string s_name( "LocatorSSE");
      return s_name;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LocatorSSE::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Locates a specified SSE in a protein model.");
      serializer.AddInitializer
      (
        "chain id",
        "chain id of the SSE",
        io::Serialization::GetAgent( &m_ChainID)
      );
      serializer.AddInitializer
      (
        "start id",
        "sequence ID of the first residue in the SSE",
        io::Serialization::GetAgent( &m_StartAAID)
      );
      serializer.AddInitializer
      (
        "end id",
        "sequence ID of the last residue in the SSE",
        io::Serialization::GetAgent( &m_EndAAID)
      );
      serializer.AddInitializer
      (
        "use pdb id",
        "use PDB ID instead of sequence ID to locate the residues",
        io::Serialization::GetAgent( &m_UsePDBID)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Locate a sse in the domain
    //! @param SSE_DOMAIN domain which the LocatorSSE refers to
    //! @return returns SiPtr to the SSE denoted by the LocatorSSE
    util::SiPtr< const SSE> LocatorSSE::Locate( const DomainInterface &SSE_DOMAIN) const
    {
      // get all sses
      const util::SiPtrVector< const SSE> sses( SSE_DOMAIN.GetSSEs());

      // iterate over the SSEs
      for
      (
        util::SiPtrVector< const SSE>::const_iterator itr( sses.Begin()), itr_end( sses.End());
        itr != itr_end;
        ++itr
      )
      {
        // check to see if the SeqIDs of the first and last amino acids of current SSE match m_StartAAID and m_EndAAID
        int aa_id_first( ( *itr)->GetFirstAA()->GetSeqID());
        int aa_id_last( ( *itr)->GetLastAA()->GetSeqID());

        if( m_UsePDBID)
        {
          BCL_MessageDbg( "using pbdb id");
          aa_id_first = ( *itr)->GetFirstAA()->GetPdbID();
          aa_id_last = ( *itr)->GetLastAA()->GetPdbID();
        }
        BCL_MessageDbg
        (
          "trying to find " + GetSSEIDString() + " comparing against " +
          util::Format()( aa_id_first) + " " + util::Format()( aa_id_last) + " "
          + util::Format()( ( *itr)->GetChainID()) + " which is " + ( *itr)->GetIdentification()
        );
        if( ( *itr)->GetChainID() == m_ChainID && aa_id_first == m_StartAAID && aa_id_last == m_EndAAID)
        {
          // if so then return this SSE
          return *itr;
        }
      }

      // if not found, return empty SiPtr< const SSE>
      BCL_MessageDbg
      (
        "sse starting with seqID " + util::Format()( m_StartAAID) + " and ending with "
        + util::Format()( m_EndAAID) + " in chain " + m_ChainID + " does not exist in domain " + SSE_DOMAIN.GetIdentification()
      );

      return util::SiPtr< const SSE>();
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_sse_from_protein_model_data.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "util/bcl_util_sh_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LocatorSSEFromProteinModelData::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorSSEFromProteinModelData())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorSSEFromProteinModelData::LocatorSSEFromProteinModelData() :
      m_Key( ProteinModelData::e_Undefined)
    {
    }

    //! @brief constructor from a key
    //! @param KEY key to retrieve the locators from the protein model data
    LocatorSSEFromProteinModelData::LocatorSSEFromProteinModelData( const ProteinModelData::Type KEY) :
      m_Key( KEY)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LocatorSSEFromProteinModelData
    LocatorSSEFromProteinModelData *LocatorSSEFromProteinModelData::Clone() const
    {
      return new LocatorSSEFromProteinModelData( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorSSEFromProteinModelData::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief locate and return an SSE using the locators retrieved from ProteinModelData
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return returns SiPtr to selected SSE
    util::SiPtr< const SSE> LocatorSSEFromProteinModelData::Locate( const DomainInterface &PROTEIN_MODEL) const
    {
      // try to cast the DomainInterface to ProteinModel
      util::SiPtr< const ProteinModel> sp_model( &PROTEIN_MODEL);
      if( !sp_model.IsDefined())
      {
        BCL_MessageCrt( "The cast from DomainInterface to ProteinModel failed!");
        return util::SiPtr< const SSE>();
      }

      // get pointer to data from protein model
      const util::ShPtr< util::ShPtrList< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > > sp_data
      (
        sp_model->GetProteinModelData()->GetData( m_Key)
      );

      // if not defined then warn user and return empty SiPtr
      if( !sp_data.IsDefined())
      {
        BCL_MessageCrt
        (
          "Could not locate protein model data with key " + ProteinModelData::GetTypeName( m_Key)
        );
        return util::SiPtr< const SSE>();
      }

      // if the size is equal to 0 meaning there are no such locators
      if( sp_data->IsEmpty())
      {
        return util::SiPtr< const SSE>();
      }

      // get a random iterator
      util::ShPtrList< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> >::const_iterator itr
      (
        random::GetGlobalRandom().Iterator( sp_data->Begin(), sp_data->End(), sp_data->GetSize())
      );

      // use the randomly located locator to locate an SSE and return it
      return ( *itr)->Locate( PROTEIN_MODEL);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorSSEFromProteinModelData::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Key, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorSSEFromProteinModelData::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Key, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_sse_random.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sse.h"
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> LocatorSSERandom::s_Instance
    (
      util::Enumerated< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> >::AddInstance( new LocatorSSERandom())
    );

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorSSERandom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &LocatorSSERandom::GetAlias() const
    {
      static const std::string s_alias( "LocatorSSERandom");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer LocatorSSERandom::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Locates a random SSE in a given domain.");

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Locate returns a random SSE from the domain argument
    //! @param SSE_DOMAIN domain which the LocatorSSE refers to
    //! @return returns SiPtr to the SSE denoted by the LocatorSSE
    util::SiPtr< const SSE> LocatorSSERandom::Locate( const DomainInterface &SSE_DOMAIN) const
    {
      // initialize static pick and static collectorsse
      static const PickSSERandom s_picker;
      static const CollectorSSE s_collector;

      // return a random sse from all sses in the protein model
      return s_picker.Pick( s_collector.Collect( SSE_DOMAIN));
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_sses_random.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sse.h"
#include "assemble/bcl_assemble_domain_interface.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> LocatorSSEsRandom::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorSSEsRandom())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorSSEsRandom::LocatorSSEsRandom() :
      m_NumberSSEs( 2),
      m_SSECollector( new CollectorSSE())
    {
    }

    //! @brief constructor from number of SSEs to collect and a ShPtr to SSE Collector
    //! @param NUMBER_SSES Number of SSEs to be located
    //! @param SP_COLLECTOR_SSE SSE ShPtr to SSE Collector to be used
    LocatorSSEsRandom::LocatorSSEsRandom
    (
      const size_t NUMBER_SSES,
      const util::ShPtr< find::CollectorInterface< util::SiPtrList< const SSE>, DomainInterface> > &SP_COLLECTOR_SSE
    ) :
      m_NumberSSEs( NUMBER_SSES),
      m_SSECollector( SP_COLLECTOR_SSE)
    {
    }

    //! @brief clone constructor
    LocatorSSEsRandom *LocatorSSEsRandom::Clone() const
    {
      return new LocatorSSEsRandom( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorSSEsRandom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Locate returns a random SSE from the domain argument
    //! @param SSE_DOMAIN domain which the LocatorSSE refers to
    //! @return returns SiPtrList to the SSEs denoted by the collector
    util::SiPtrList< const SSE> LocatorSSEsRandom::Locate( const DomainInterface &SSE_DOMAIN) const
    {
      // collect the SSEs
      util::SiPtrList< const SSE> collected_sses( m_SSECollector->Collect( SSE_DOMAIN));

      // initialize list to return
      util::SiPtrList< const SSE> sse_list;

      // if there are not enough collected sses
      if( collected_sses.GetSize() < m_NumberSSEs)
      {
        // return empty list
        return sse_list;
      }

      // iterate until the requested number of SSEs is reached
      for( size_t sse_ctr( 0); sse_ctr < m_NumberSSEs; ++sse_ctr)
      {
        // get random iterator on the list
        util::SiPtrList< const SSE>::iterator random_itr
        (
          random::GetGlobalRandom().Iterator( collected_sses.Begin(), collected_sses.End(), collected_sses.GetSize())
        );

        // double check that the random iterator is not equal to end
        BCL_Assert
        (
          random_itr != collected_sses.End(),
          "The random iterator returns the end which probably indicates an error with the list"
        );

        // insert it into sse_list
        sse_list.PushBack( *random_itr);

        // remove from collected_sses list
        collected_sses.Remove( random_itr);
      }

      // return the list
      return sse_list;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorSSEsRandom::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSECollector, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief read from std::ostream
    //! @param OSTREAM input stream
    //! @param INDENT indentation
    //! @return ostream which was read from
    std::ostream &LocatorSSEsRandom::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSECollector, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_sse_terminus_residue.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain_interface.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LocatorSSETerminusResidue::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorSSETerminusResidue())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorSSETerminusResidue::LocatorSSETerminusResidue() :
      m_ChainID(),
      m_StartSSE(),
      m_Terminus()
    {
    }

    //! @brief construct from a ChainID, and the SeqID of the amino acid from which you want to grow
    //! @param CHAINID char which indicates the chain
    //! @param SSE_START residue from which to be grown
    //! @param GROW_C_TO_N if true, grow from C to N terminus
    LocatorSSETerminusResidue::LocatorSSETerminusResidue
    (
      const char CHAINID, const int SSE_START, const biol::AASequenceFlexibility::SequenceDirection &TERMINUS
    ) :
      m_ChainID( CHAINID),
      m_StartSSE( SSE_START),
      m_Terminus( TERMINUS)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LocatorSSETerminusResidue
    LocatorSSETerminusResidue *LocatorSSETerminusResidue::Clone() const
    {
      return new LocatorSSETerminusResidue( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorSSETerminusResidue::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief GetIdentification
    //! @return the GetIdentification
    const std::string LocatorSSETerminusResidue::GetIdentification() const
    {
      return util::Format()( m_ChainID) + " " + util::Format()( m_StartSSE) + " " +
        util::Format()( m_Terminus.GetString());
    }

    //! @brief gives the residue that identifies the sse of interest
    //! @return returns the locator
    int LocatorSSETerminusResidue::GetSSEID() const
    {
      return m_StartSSE;
    }

    //! @brief if the N or the C terminus is to be located
    //! @return true if the cterminus of the sse is to be located, false if n-terminus
    biol::AASequenceFlexibility::SequenceDirection LocatorSSETerminusResidue::GetLocateCTerminus() const
    {
      return m_Terminus;
    }

    //! @brief gives an identifying string for this locator
    //! @return returns an identifying string for this locator
    std::string LocatorSSETerminusResidue::GetSSEIDString() const
    {
      return
          std::string
          (
            util::Format()(             m_ChainID) + " " +
            util::Format().W( 4).R()( m_StartSSE) + " " +
            util::Format()( m_Terminus.GetString())
          );
    }

    //! returns the chain locator
    //! @return returns the const reference to the chain locator
    const char &LocatorSSETerminusResidue::GetChainID() const
    {
      return m_ChainID;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Locate a sse in the domain
    //! @param SSE_DOMAIN domain which the LocatorSSE refers to
    //! @return returns SiPtr to the SSE denoted by the LocatorSSE
    util::SiPtr< const SSE> LocatorSSETerminusResidue::Locate( const DomainInterface &SSE_DOMAIN) const
    {
      // get all sses
      const util::SiPtrVector< const SSE> sses( SSE_DOMAIN.GetSSEs());

      // iterate over the SSEs
      for
      (
        util::SiPtrVector< const SSE>::const_iterator itr( sses.Begin()), itr_end( sses.End());
        itr != itr_end;
        ++itr
      )
      {
        // check to see if the SeqIDs of the first and last amino acids of current SSE match m_Start_SSE and m_End_SSE
        if
        (
          ( *itr)->GetChainID()             == m_ChainID &&
          ( *itr)->GetFirstAA()->GetSeqID() == m_StartSSE &&
          ( m_Terminus == biol::AASequenceFlexibility::e_NTerminal)
        )
        {
          // if so then return this SSE
          return *itr;
        }
        else if
        (
          ( *itr)->GetChainID()             == m_ChainID &&
          ( *itr)->GetLastAA()->GetSeqID() == m_StartSSE &&
          ( m_Terminus == biol::AASequenceFlexibility::e_CTerminal)
        )
        {
          // if so then return this SSE
          return *itr;
        }
      }

      // if not found, return empty SiPtr< const SSE>
      return util::SiPtr< const SSE>();
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorSSETerminusResidue::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ChainID        , ISTREAM);
      io::Serialize::Read( m_StartSSE       , ISTREAM);
      io::Serialize::Read( m_Terminus, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorSSETerminusResidue::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ChainID        , OSTREAM, INDENT) << '\t';
      io::Serialize::Write( m_StartSSE       , OSTREAM)         << '\t';
      io::Serialize::Write( m_Terminus, OSTREAM);
      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_sse_unpaired.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorSSEUnpaired::LocatorSSEUnpaired() :
      m_Collector(),
      m_Pick()
    {
    }

    //! @brief constructor taking a all members
    //! @param PICK is the ShPtr to a PickInterface which will determine which unpaired SSE is given
    //! @param CONTACT_TYPE is the contact type for which an SSE not having it is desired
    //! @param MAX_DISTANCE is the maximum distance between SSEs for them to be considered paired
    LocatorSSEUnpaired::LocatorSSEUnpaired
    (
      const find::PickCriteriaInterface< util::SiPtr< const SSE>, util::SiPtrList< const SSE>, linal::Vector3D> &PICK,
      const contact::Type &CONTACT_TYPE,
      const double MAX_DISTANCE
    ) :
      m_Collector( CONTACT_TYPE, MAX_DISTANCE),
      m_Pick( PICK.Clone())
    {
    }

    //! @brief constructor taking a all members
    //! @param SP_PICK is the ShPtr to a PickInterface which will determine which unpaired SSE is given
    //! @param CONTACT_TYPE is the contact type for which an SSE not having it is desired
    //! @param MAX_DISTANCE is the maximum distance between SSEs for them to be considered paired
    LocatorSSEUnpaired::LocatorSSEUnpaired
    (
      const util::ShPtr< find::PickCriteriaInterface< util::SiPtr< const SSE>, util::SiPtrList< const SSE>, linal::Vector3D> > &SP_PICK,
      const contact::Type &CONTACT_TYPE,
      const double MAX_DISTANCE
    ) :
      m_Collector( CONTACT_TYPE, MAX_DISTANCE),
      m_Pick( SP_PICK)
    {
    }

    //! @brief Clone is the virtual Clone constructor
    //! @return a pointer to new LocatorSSEFurthest which is a copy of this
    LocatorSSEUnpaired *LocatorSSEUnpaired::Clone() const
    {
      return new LocatorSSEUnpaired( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorSSEUnpaired::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief SetPick changes the Pick to a different object
    //! @param PICK ShPtr to PickInterface< SSE> which "m_Pick" will be changed to
    void LocatorSSEUnpaired::SetPick
    (
      const util::ShPtr< find::PickCriteriaInterface< util::SiPtr< const SSE>, util::SiPtrList< const SSE>, linal::Vector3D> > &PICK
    )
    {
      m_Pick = PICK;
    }

    //! @brief GetMaxDistance gives the maximum distance between SSEs for them to still be considered paired
    //! @return returns "m_MaxDistance" the maximum distance between SSEs for them to still be considered paired
    const CollectorSSEUnpaired &LocatorSSEUnpaired::GetCollector() const
    {
      return m_Collector;
    }

    //! @brief SetMaxDistance changes the type of SSE contact of interest
    //! @param COLLECTOR is the new maximum distance between SSEs for them to still be considered paired
    void LocatorSSEUnpaired::SetCollector( const CollectorSSEUnpaired &COLLECTOR)
    {
      m_Collector = COLLECTOR;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Locate returns an SSE which is unpaired
    //! @param SSE_DOMAIN domain which the LocatorSSEUnpaired refers to
    //! @return returns SiPtr to the unpaired SSE furthest from the center of SSE_DOMAIN; empty if no SSEs in domain
    util::SiPtr< const SSE> LocatorSSEUnpaired::Locate( const DomainInterface &SSE_DOMAIN) const
    {
      // return empty SiPtr to SSE if there is no unpaired SSE
      return m_Pick->Pick( m_Collector.Collect( SSE_DOMAIN), SSE_DOMAIN.GetCenter());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorSSEUnpaired::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Collector, ISTREAM);
      io::Serialize::Read( m_Pick, ISTREAM);

      // return
      return ISTREAM;
    }

    //! @brief read from std::ostream
    //! @param OSTREAM input stream
    //! @param INDENT indentation
    //! @return ostream which was read from
    std::ostream &LocatorSSEUnpaired::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Collector, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Pick, OSTREAM, INDENT);

      // return
      return OSTREAM;
    }

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> LocatorSSEUnpaired::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorSSEUnpaired())
    );

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_locator_sub_domain_random.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_domain.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> LocatorSubDomainRandom::s_Instance
    (
      GetObjectInstances().AddInstance( new LocatorSubDomainRandom())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    LocatorSubDomainRandom::LocatorSubDomainRandom() :
      m_SizeRange( 0, 0),
      m_LocateConsecutive( false),
      m_UseTopologyOrder( false)
    {
    }

    //! @brief construct from a range for number of SSEs in sub-domain
    //! @param SIZE_RANGE range for number of SSEs
    LocatorSubDomainRandom::LocatorSubDomainRandom( const math::Range< size_t> SIZE_RANGE) :
      m_SizeRange( SIZE_RANGE),
      m_LocateConsecutive( false),
      m_UseTopologyOrder( false)
    {
    }

    //! @brief construct from a range for number of SSEs in sub-domain and whether they should be located consecutively
    //! @param SIZE_RANGE range for number of SSEs
    //! @param LOCATE_CONSECUTIVE boolean to whether to locate consecutive SSEs
    //! @param USE_TOPOLOGY_ORDER boolean to order SSEs by the topology order
    LocatorSubDomainRandom::LocatorSubDomainRandom
    (
      const math::Range< size_t> &SIZE_RANGE,
      bool LOCATE_CONSECUTIVE,
      bool USE_TOPOLOGY_ORDER
    ) :
      m_SizeRange( SIZE_RANGE),
      m_LocateConsecutive( LOCATE_CONSECUTIVE),
      m_UseTopologyOrder( USE_TOPOLOGY_ORDER)
    {
    }

    //! @brief Clone function
    //! @return pointer to new LocatorSubDomainRandom
    LocatorSubDomainRandom *LocatorSubDomainRandom::Clone() const
    {
      return new LocatorSubDomainRandom( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &LocatorSubDomainRandom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief locate and return a random sub-domain from the given domain
    //! @param SP_DOMAIN ShPtr to the domain of interest
    //! @return ShPtr to a random sub-domain located within the given SP_DOMAIN
    util::ShPtr< Domain> LocatorSubDomainRandom::Locate( const util::ShPtr< Domain> &SP_DOMAIN) const
    {
      // make sure given domain is defined
      BCL_Assert( SP_DOMAIN.IsDefined(), "The given domain is not defined");

      // determine start and end indices for the strands to sort
      const size_t nr_sses( SP_DOMAIN->GetNumberSSEs());

      // determine the subset size
      size_t subset_size( 0);

      // if the max of the range is below the nr_sses
      if( m_SizeRange.GetMax() <= nr_sses)
      {
        subset_size = random::GetGlobalRandom().SizeT( m_SizeRange);
      }
      // if it's smaller
      else
      {
        // determine subset size
        subset_size =
          random::GetGlobalRandom().SizeT
          (
            math::Range< size_t>( ( m_SizeRange.GetMin() <= nr_sses ? m_SizeRange.GetMin() : nr_sses), nr_sses)
          );
      }

      // create a new domain
      util::ShPtr< Domain> sp_domain( new Domain());

      // get all the SSEs in the model
      util::SiPtrVector< const SSE> all_sses( SP_DOMAIN->GetSSEs());

      // initialize vector to hold the selected SSEs
      util::SiPtrVector< const SSE> selected_sses;

      // if consecutive is required
      if( m_LocateConsecutive)
      {
        // if by topology order
        if( m_UseTopologyOrder)
        {
          // make sure topology is defined
          BCL_Assert
          (
            SP_DOMAIN->GetTopology().IsDefined(),
            "given domain has undefined topology, although ordering by topology order is requested"
          );

          // get the elements vector and cast them back to SSEs
          all_sses = util::SiPtrVector< const SSE>( SP_DOMAIN->GetTopology()->GetElements());
          BCL_Assert( all_sses.IsDefined(), "The dynamic cast of topology SSEs failed!");
        }

        // otherwise all_sses is sorted by the sequence order
        // now determine a start index
        const size_t start_index
        (
          random::GetGlobalRandom().SizeT
          (
            math::Range< size_t>( 0, all_sses.GetSize() - subset_size)
          )
        );

        // get the sub-siptrvector and construct the subset
        selected_sses = all_sses.SubSiPtrVector( start_index, subset_size);

      }
      // if no consecutive selection is required
      else
      {
        // while all_sses still has more than subset_size elements
        while( all_sses.GetSize() > subset_size)
        {
          // remove a random element
          all_sses.RemoveRandomElement();
        }

        // update the selected_sses
        selected_sses = all_sses;
      }

      // now that we know which SSEs should be in it and in which order they should be added
      // we can go ahead and construct the domains SSEs
      // first iterate over the selected SSEs
      for
      (
        util::SiPtrVector< const SSE>::const_iterator
          sse_itr( selected_sses.Begin()), sse_itr_end( selected_sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // find SSE
        util::ShPtr< SSE> sp_sse( SP_DOMAIN->FindSSE( **sse_itr));
        BCL_Assert( sp_sse.IsDefined(), "could not find a corresponding SSE from domain!");

        // insert it into the new domain
        sp_domain->Insert( sp_sse);
      }

      // if the topology is not defined
      if( SP_DOMAIN->GetTopology().IsDefined())
      {
        // set topology for the new domain
        sp_domain->SetTopology( SP_DOMAIN->GetTopology()->GetSubTopology( selected_sses));
      }

      // end
      return sp_domain;

    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &LocatorSubDomainRandom::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SizeRange, ISTREAM);
      io::Serialize::Read( m_LocateConsecutive, ISTREAM);
      io::Serialize::Read( m_UseTopologyOrder, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &LocatorSubDomainRandom::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SizeRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_LocateConsecutive, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_UseTopologyOrder, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_pick_protein_model_conformation_random.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PickProteinModelConformationRandom::s_Instance
    (
      util::Enumerated< find::PickInterface< util::SiPtr< const ProteinModel>, util::SiPtrList< const ProteinModel> > >::AddInstance( new PickProteinModelConformationRandom())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PickProteinModelConformationRandom::PickProteinModelConformationRandom()
    {
    }

    //! @brief Clone function
    //! @return pointer to new PickProteinModelConformationRandom
    PickProteinModelConformationRandom *PickProteinModelConformationRandom::Clone() const
    {
      return new PickProteinModelConformationRandom( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PickProteinModelConformationRandom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &PickProteinModelConformationRandom::GetAlias() const
    {
      static const std::string s_alias( "PickProteinModelConformationRandom");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer PickProteinModelConformationRandom::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Picks a random conformation of a protein model.");

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Pick returns a random SSE from the domain argument
    //! @param PROTEIN_MODEL model which the locator will Pick from
    //! @return returns SiPtr to protein model conformation from protein model conformation ensemble
    util::SiPtr< const ProteinModel>
    PickProteinModelConformationRandom::Pick( const util::SiPtrList< const ProteinModel> &ENSEMBLE) const
    {
      // if the ensemble is empty return empty siptr
      if( ENSEMBLE.IsEmpty())
      {
        return util::SiPtr< const ProteinModel>();
      }

      // get random index between 0 and ensemble size
      size_t index( random::GetGlobalRandom().Random( size_t( 0), size_t( ENSEMBLE.GetSize() - 1)));

      // get SiPtr to the index of the ensemble
      util::SiPtrList< const ProteinModel>::const_iterator
        ensemble_itr( ENSEMBLE.Begin()), ensemble_itr_end( ENSEMBLE.End());

      storage::AdvanceIterator( ensemble_itr, ensemble_itr_end, index);
      const util::SiPtr< const ProteinModel> located_model( *ensemble_itr);

      return located_model;
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_pick_sse_furthest_euclidean_center.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_pick_sse_furthest_euclidean.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> PickSSEFurthestEuclidean::s_Instance
    (
      GetObjectInstances().AddInstance( new PickSSEFurthestEuclidean())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Clone is the virtual Clone constructor
    //! @return a pointer to new LocatorSSEFurthest which is a copy of this
    PickSSEFurthestEuclidean *PickSSEFurthestEuclidean::Clone() const
    {
      return new PickSSEFurthestEuclidean( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PickSSEFurthestEuclidean::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Picks the assemble::SSE object which is furthest away from "m_ReferencePoint"
    //! @param SSE_LIST is the SiPtrList which provides the pool of assemble::SSE to pick from
    //! @param REFERENCE_POINT is the point from which the furthest SSE will be determined
    //! @return returns SiPtr to the assemble::SSE object which is furthest away from "m_ReferencePoint"
    util::SiPtr< const SSE>
    PickSSEFurthestEuclidean::Pick
    (
      const util::SiPtrList< const SSE> &SSE_LIST,
      const linal::Vector3D &REFERENCE_POINT
    ) const
    {
      // create double "max_distance" for holding the max distance between "m_ReferencePoint" and a assemble::SSE
      double max_distance( 0); //< initialize to zero

      // create SiPtr< const assemble::SSE> "furthest_moveable"
      util::SiPtr< const SSE> furthest_moveable;

      // iterate through "GROUP"
      for
      (
        util::SiPtrList< const SSE>::const_iterator itr( SSE_LIST.Begin()), itr_end( SSE_LIST.End());
        itr != itr_end;
        ++itr
      )
      {
        // create double "current_distance" initialize to the distance between "m_ReferencePoint" and the center of
        // the assemble::SSE currently denoted by "itr"
        double current_distance = linal::Distance( REFERENCE_POINT, ( *itr)->GetCenter());

        // check if "current_distance" is greater than "max_distance"
        if( current_distance > max_distance)
        {
          // set "furthest_sse" to the assemble::SSE currently denoted by "itr"
          furthest_moveable = ( *itr);

          // set "max_distance" to "current_distance"
          max_distance = current_distance;
        }
      }

      // return "furthest_moveable"
      return furthest_moveable;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PickSSEFurthestEuclidean::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief read from std::ostream
    //! @param OSTREAM input stream
    //! @param INDENT indentation
    //! @return ostream which was read from
    std::ostream &PickSSEFurthestEuclidean::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_pick_sse_random.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> PickSSERandom::s_Instance
    (
      util::Enumerated< find::PickInterface< util::SiPtr< const SSE>, util::SiPtrList< const SSE> > >::AddInstance( new PickSSERandom())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PickSSERandom::PickSSERandom() :
      m_SSTypes()
    {
    }

    //! @brief constructor from a set of SSTypes
    //! @param SS_TYPES Set of SSTypes
    PickSSERandom::PickSSERandom( const storage::Set< biol::SSType> &SS_TYPES) :
      m_SSTypes( SS_TYPES)
    {
    }

    //! @brief Clone is the virtual Clone constructor
    //! @return a pointer to new LocatorSSEFurthest which is a copy of this
    PickSSERandom *PickSSERandom::Clone() const
    {
      return new PickSSERandom( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PickSSERandom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &PickSSERandom::GetAlias() const
    {
      static const std::string s_alias( "PickSSERandom");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer PickSSERandom::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Randomly pick an SSE of a given type.");
      serializer.AddInitializer
      (
        "sse_types",
        "which types of SSEs to pick",
        io::Serialization::GetAgent( &m_SSTypes)
      );

      return serializer;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Picks the SSE object which is furthest away from "m_ReferencePoint"
    //! @param SSE_LIST is the SiPtrList which provides the pool of assemble::SSE to pick from
    //! @return returns SiPtr to the assemble::SSE object which is furthest away from "m_ReferencePoint"
    util::SiPtr< const SSE>
    PickSSERandom::Pick
    (
      const util::SiPtrList< const SSE> &SSE_LIST
    ) const
    {
      // if not found, return empty SiPtr< SSE>
      if( SSE_LIST.IsEmpty())
      {
        return util::SiPtr< const SSE>();
      }

      // make a copy of the list
      util::SiPtrList< const SSE> sse_list;

      // if SSTypes is not empty meaning a specific set of SSTypes was requested
      if( !m_SSTypes.IsEmpty())
      {
        // iterate over the sse_list and collect SSEs of the correct types.
        for
        (
          util::SiPtrList< const SSE>::const_iterator sse_itr( SSE_LIST.Begin()), sse_itr_end( SSE_LIST.End());
          sse_itr != sse_itr_end; ++sse_itr
        )
        {
          // if of correct type
          if( m_SSTypes.Find( ( *sse_itr)->GetType()) != m_SSTypes.End())
          {
            // insert it
            sse_list.PushBack( *sse_itr);
          }
        }
      }
      else
      {
        sse_list = SSE_LIST;
      }

      // if not found, return empty SiPtr< SSE>
      if( sse_list.IsEmpty())
      {
        return util::SiPtr< const SSE>();
      }

      // get random iterator on the list
      util::SiPtrList< const SSE>::const_iterator random_iterator
      (
        random::GetGlobalRandom().Iterator
        (
          sse_list.Begin(),
          sse_list.End(),
          sse_list.GetSize()
        )
      );

      // double check that the random iterator is not equal to end
      BCL_Assert
      (
        random_iterator != sse_list.End(),
        "The random iterator returns the end which probably indicates an error with the list"
      );

      // return
      return *random_iterator;
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_pick_sse_short_loops.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> PickSSEShortLoops::s_Instance
    (
      util::Enumerated< find::PickCriteriaInterface< util::SiPtr< const SSE>, util::SiPtrList< const SSE>, DomainInterface> >::AddInstance( new PickSSEShortLoops)
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @brief MAX_LOOP_LENGTH maximum number of residues between SSEs to be classified as short loop ( 5 by defult)
    PickSSEShortLoops::PickSSEShortLoops( const size_t MAX_LOOP_LENGTH) :
      m_MaxShortLoopLength( MAX_LOOP_LENGTH)
    {
    }

    //! @brief Clone is the virtual Clone constructor
    //! @return a pointer to new PickSSEShortLoops which is a copy of this
    PickSSEShortLoops *PickSSEShortLoops::Clone() const
    {
      return new PickSSEShortLoops( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PickSSEShortLoops::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &PickSSEShortLoops::GetAlias() const
    {
      static const std::string s_alias( "PickSSEShortLoops");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer PickSSEShortLoops::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Optimization implementation for Monte Carlo Metropolis algorithms.");
      serializer.AddInitializer
      (
        "max_short_loop_length",
        "maximum length of a loop to be considered short",
        io::Serialization::GetAgent( &m_MaxShortLoopLength)
      );

      return serializer;
    }
  ////////////////
  // operations //
  ////////////////

    //! @brief Picks one of SSEs with the Short Loops to the given domain
    //! @param SSE_LIST is the SiPtrList which provides the pool of assemble::SSE to pick from
    //! @param SSE_DOMAIN is the domain to which SSEs from the SSE_LIST will be compared for short loops
    //! @return returns SiPtr to the assemble::SSE object which has a short loops to one of the SSEs in SSE_DOMAIN
    util::SiPtr< const SSE>
    PickSSEShortLoops::Pick( const util::SiPtrList< const SSE> &SSE_LIST, const DomainInterface &SSE_DOMAIN) const
    {
      // get eligible list of sses by comparing to the protein model for short loops
      util::SiPtrList< const SSE> eligible_sses
      (
        SSE_DOMAIN.GetSSEsWithShortLoops( SSE_LIST, m_MaxShortLoopLength)
      );

      // none are found, return empty SiPtr
      if( eligible_sses.IsEmpty())
      {
        return util::SiPtr< const SSE>();
      }
      // if only one found return that one
      else if( eligible_sses.GetSize() == 1)
      {
        return eligible_sses.FirstElement();
      }
      // else more than one is found pick randomly
      else
      {
        return PickSSERandom().Pick( eligible_sses);
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_pick_sses_random.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of this class
    const util::SiPtr< const util::ObjectInterface> PickSSEsRandom::s_Instance
    (
      GetObjectInstances().AddInstance( new PickSSEsRandom())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @detail sets the SSE types to be considered to helix and strand and the number of SSE to pick to one
    PickSSEsRandom::PickSSEsRandom() :
      m_SSTypes(),
      m_NumSSEsToPick( 1)
    {
      m_SSTypes.Insert( biol::GetSSTypes().HELIX);
      m_SSTypes.Insert( biol::GetSSTypes().STRAND);
    }

    //! @brief constructor from a set of SSTypes and number of SSEs to pick
    //! @param SS_TYPES types of the SSEs which shall be picked
    //! @param NUM_SSES number of SSEs to pick randomly
    PickSSEsRandom::PickSSEsRandom( const storage::Set< biol::SSType> &SS_TYPES, const size_t NUM_SSES) :
      m_SSTypes( SS_TYPES),
      m_NumSSEsToPick( NUM_SSES)
    {
    }

    //! @brief returns a pointer to a new PickSSEsRandom
    //! @return pointer to a new PickSSEsRandom
    PickSSEsRandom *PickSSEsRandom::Clone() const
    {
      return new PickSSEsRandom( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns the name of this class
    //! @return the name of this class
    const std::string &PickSSEsRandom::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief randomly picks the given number of SSEs of the given type from the list
    //! @param SSE_LIST SSE list to pick the SSEs from
    //! @return list with the picked SSEs
    util::SiPtrList< const SSE> PickSSEsRandom::Pick( const util::SiPtrList< const SSE> &SSE_LIST) const
    {
      // collect the SSEs of the wanted type from the list
      util::SiPtrList< const SSE> sses;
      for
      (
        util::SiPtrList< const SSE>::const_iterator it( SSE_LIST.Begin()), it_end( SSE_LIST.End());
        it != it_end;
        ++it
      )
      {
        if( m_SSTypes.Contains( ( **it).GetType()))
        {
          sses.PushBack( *it);
        }
      }

      // if the resulting list is shorter than the number of SSEs to pick exit
      BCL_Assert
      (
        m_NumSSEsToPick <= sses.GetSize(),
        "tried to pick " + util::Format()( m_NumSSEsToPick) + " SSEs from a list that only contains " +
        util::Format()( sses.GetSize()) + " SSEs"
      );

      // randomly pick the given number SSEs from the list containing the given SSE types
      util::SiPtrList< const SSE> picked_sses;
      for( size_t num_picked_sses( 0); num_picked_sses < m_NumSSEsToPick; ++num_picked_sses)
      {
        util::SiPtrList< const SSE>::iterator random_iterator
        (
          random::GetGlobalRandom().Iterator( sses.Begin(), sses.End(), sses.GetSize())
        );
        picked_sses.PushBack( *random_iterator);
        sses.Remove( random_iterator);
      }

      return picked_sses;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read object from input stream
    //! @param ISTREAM input stream to read object from
    //! @return input stream which was read from
    std::istream &PickSSEsRandom::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSTypes, ISTREAM);
      io::Serialize::Read( m_NumSSEsToPick, ISTREAM);

      return ISTREAM;
    }

    //! @brief write object into  output stream
    //! @param OSTREAM output stream to write object into
    //! @param INDENT number of indentations to separate members
    //! @return output stream object was written into
    std::ostream &PickSSEsRandom::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSTypes, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_NumSSEsToPick, OSTREAM, INDENT);

      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_printer_protein_model.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_protein_model_multiplier.h"
#include "assemble/bcl_assemble_protein_storage_file.h"
#include "assemble/bcl_assemble_quality.h"
#include "biol/bcl_biol_membrane.h"
#include "io/bcl_io_file.h"
#include "pdb/bcl_pdb_factory.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PrinterProteinModel::s_Instance
    (
      GetObjectInstances().AddInstance( new PrinterProteinModel())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PrinterProteinModel::PrinterProteinModel() :
      m_Prefix( ""),
      m_Superimpose( quality::GetSuperimposeMeasures().e_NoSuperimpose),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>()),
      m_Storage( ProteinStorageFile::GetDefaultStorage())
    {
    }

    //! @brief construct with prefix
    //! @param PREFIX prefix string
    PrinterProteinModel::PrinterProteinModel( const std::string &PREFIX) :
      m_Prefix( PREFIX),
      m_Superimpose( quality::GetSuperimposeMeasures().e_NoSuperimpose),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>()),
      m_Storage( ProteinStorageFile::GetDefaultStorage())
    {
    }

    //! @brief construct with all member variables
    //! @param PREFIX prefix string
    //! @param STORAGE protein storage to use
    //! @param SUPERIMPOSE measure to use for superimposition
    PrinterProteinModel::PrinterProteinModel
    (
      const std::string &PREFIX,
      const util::ShPtr< ProteinStorageFile> &STORAGE,
      const quality::SuperimposeMeasure &SUPERIMPOSE
    ) :
      m_Prefix( PREFIX),
      m_Superimpose( SUPERIMPOSE),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>()),
      m_Storage( STORAGE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new PrinterProteinModel
    PrinterProteinModel *PrinterProteinModel::Clone() const
    {
      return new PrinterProteinModel( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &PrinterProteinModel::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief reset and initialize the printer
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @return true if initialization was successful
    void PrinterProteinModel::Initialize( const size_t &ROUND_NUMBER)
    {
      // call initialize with undefined stage number
      Initialize( ROUND_NUMBER, util::GetUndefined< size_t>());
    }

    //! @brief reset and initialize the printer with the given round and stage number
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @param STAGE_NUMBER for multiple optimizations, a different stage number will be passed
    //! @return true if initialization was successful
    void PrinterProteinModel::Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
    {
      // update round number
      m_RoundNumber = ROUND_NUMBER;

      // set the stage number
      m_StageNumber = STAGE_NUMBER;
    }

    //! @brief prints information concerning the approximation process based on the status of the given tracker
    //! @param TRACKER holds the status of the approximation process
    void PrinterProteinModel::Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
    {
      // call WriteToStorage function
      WriteToStorage
      (
        TRACKER.GetPhase() == opti::e_End ? TRACKER.GetBest() : TRACKER.GetCurrent(),
        GetStorageStrings( m_Prefix, TRACKER.GetTag(), m_RoundNumber, m_StageNumber)
      );
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PrinterProteinModel::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &PrinterProteinModel::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief gets the source and key strings from the minimization information
    //! @param PREFIX prefix
    //! @param TAG tag for the step status if applicable
    //! @param ROUND_NUMBER round number
    //! @param STAGE_NUMBER stage number
    //! @return source and key strings, respectively
    storage::VectorND< 2, std::string> PrinterProteinModel::GetStorageStrings
    (
      const std::string &PREFIX,
      const std::string &TAG,
      const size_t ROUND_NUMBER,
      const size_t STAGE_NUMBER
    )
    {
      // initialize strings
      std::string tag( TAG);
      if( tag.compare( "") != 0)
      {
        tag = "_" + tag;
      }
      storage::VectorND< 2, std::string> strings( PREFIX + TAG, "_" + GetRoundNumberFormat()( ROUND_NUMBER));

      // if the stage is defined
      if( util::IsDefined( STAGE_NUMBER))
      {
        strings.Second() += "_" + GetStageNumberFormat()( STAGE_NUMBER);
      }

      // end
      return strings;
    }

    //! @brief function to write given model
    //! @param ARGUMENT_RESULT_PAIR Pair of argument and corresponding result
    //! @param STORAGE_STRINGS source and key strings from the minimization information
    //! @return whether write was successful
    bool PrinterProteinModel::WriteToStorage
    (
      const util::ShPtr< storage::Pair< ProteinModel, double> > &ARGUMENT_RESULT_PAIR,
      const storage::VectorND< 2, std::string> &STORAGE_STRINGS
    ) const
    {
      // copy the model
      util::ShPtr< ProteinModel> copy_ptr( ARGUMENT_RESULT_PAIR->First().HardCopy());
      ProteinModel &copy( *copy_ptr);

      // initialize transformation matrix for returning multiplier to original state
      math::TransformationMatrix3D orig_transform;

      // cast a pointer to the multiplier data if any
      util::ShPtr< ProteinModelMultiplier> sp_multiplier
      (
        copy.GetProteinModelData()->GetData( ProteinModelData::e_Multiplier)
      );

      // cast a pointer to the membrane data if any
      util::ShPtr< biol::Membrane> sp_membrane
      (
        copy.GetProteinModelData()->GetData( ProteinModelData::e_Membrane)
      );

      // superimpose if specified
      if( m_Superimpose.IsDefined() && m_Superimpose != quality::GetSuperimposeMeasures().e_NoSuperimpose)
      {
        // superimpose the model and store the transformation to be used for the multiplier
        const math::TransformationMatrix3D transform
        (
          Quality::SuperimposeModel( m_Superimpose, copy, biol::GetAtomTypes().CA).Second()
        );

        // if the pointer is defined
        if( sp_multiplier.IsDefined())
        {
          // set the transformation
          sp_multiplier->Transform( transform);
          orig_transform = math::Inverse( transform);
        }

        // if the pointer is defined
        if( sp_membrane.IsDefined())
        {
          // set the transformation
          sp_membrane->Transform( transform);
          orig_transform = math::Inverse( transform);
        }
      }

      // store the model
      const std::string filename // can get from storage object
      (
        m_Storage->GetInitializer() + "/" + STORAGE_STRINGS.First() + STORAGE_STRINGS.Second() + ".pdb"
      );

      if( m_Storage->Store( copy, STORAGE_STRINGS.First(), STORAGE_STRINGS.Second()))
      {
        BCL_MessageStd( "pdb written to " + filename);
      }
      else
      {
        BCL_MessageCrt
        (
          "Unable to store file, " + filename + ", file may already exist and overwrite is not set"
        );
      }

      // if the multiplier pointer is defined
      if( sp_multiplier.IsDefined())
      {
        // move it back to where it was originally
        sp_multiplier->Transform( orig_transform);
      }

      // if the membrane pointer is defined
      if( sp_membrane.IsDefined())
      {
        // move it back to where it was originally
        sp_membrane->Transform( orig_transform);
      }

      // end
      return true;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_ensemble.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_printer_protein_model.h"
#include "assemble/bcl_assemble_printer_protein_model_ensemble.h"
#include "assemble/bcl_assemble_protein_model_multiplier.h"
#include "assemble/bcl_assemble_protein_storage_file.h"
#include "assemble/bcl_assemble_quality.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PrinterProteinModelEnsemble::s_Instance
    (
      GetObjectInstances().AddInstance( new PrinterProteinModelEnsemble())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PrinterProteinModelEnsemble::PrinterProteinModelEnsemble() :
      m_Prefix( ""),
      m_Superimpose( quality::GetSuperimposeMeasures().e_NoSuperimpose),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>()),
      m_Storage( ProteinStorageFile::GetDefaultStorage())
    {
    }

    //! @brief construct with prefix
    //! @param PREFIX prefix string
    PrinterProteinModelEnsemble::PrinterProteinModelEnsemble( const std::string &PREFIX) :
      m_Prefix( PREFIX),
      m_Superimpose( quality::GetSuperimposeMeasures().e_NoSuperimpose),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>()),
      m_Storage( ProteinStorageFile::GetDefaultStorage())
    {
    }

    //! @brief construct with all member variables
    //! @param PREFIX prefix string
    //! @param STORAGE protein storage to use
    //! @param SUPERIMPOSE measure to use for superimposition
    PrinterProteinModelEnsemble::PrinterProteinModelEnsemble
    (
      const std::string &PREFIX,
      const util::ShPtr< ProteinStorageFile> &STORAGE,
      const quality::SuperimposeMeasure &SUPERIMPOSE
    ) :
      m_Prefix( PREFIX),
      m_Superimpose( SUPERIMPOSE),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>()),
      m_Storage( STORAGE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new PrinterProteinModelEnsemble
    PrinterProteinModelEnsemble *PrinterProteinModelEnsemble::Clone() const
    {
      return new PrinterProteinModelEnsemble( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PrinterProteinModelEnsemble::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief reset and initialize the printer
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @return true if initialization was successful
    void PrinterProteinModelEnsemble::Initialize( const size_t &ROUND_NUMBER)
    {
      // call initialize with undefined stage number
      Initialize( m_RoundNumber, util::GetUndefined< size_t>());
    }

    //! @brief reset and initialize the printer with the given round and stage number
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @param STAGE_NUMBER for multiple optimizations, a different stage number will be passed
    //! @return true if initialization was successful
    void PrinterProteinModelEnsemble::Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
    {
      // update round number
      m_RoundNumber = ROUND_NUMBER;

      // set the stage number
      m_StageNumber = STAGE_NUMBER;
    }

    //! @brief print function taking a tracker
    //! @param TRACKER the tracker to print
    void PrinterProteinModelEnsemble::Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
    {
      WriteToStorage
      (
        TRACKER.GetCurrent()->First(),
        PrinterProteinModel::GetStorageStrings( m_Prefix, TRACKER.GetTag(), m_RoundNumber, m_StageNumber)
      );
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PrinterProteinModelEnsemble::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &PrinterProteinModelEnsemble::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief function to write given model
    //! @param ARGUMENT protein model to print,
    //! @param STORAGE_STRINGS source and key strings from the minimization information
    //! @return whether write was successful
    bool PrinterProteinModelEnsemble::WriteToStorage
    (
      const ProteinModel &ARGUMENT,
      const storage::VectorND< 2, std::string> &STORAGE_STRINGS
    ) const
    {
      // get the conformational ensemble of the protein
      const ProteinEnsemble &ensemble( ARGUMENT.GetConformationalEnsemble());
      BCL_MessageDbg
      (
        "ensemble size is " + util::Format()( ensemble.GetSize())
      );

      for
      (
        ProteinEnsemble::const_iterator ensemble_itr( ensemble.Begin()), ensemble_itr_end( ensemble.End());
        ensemble_itr != ensemble_itr_end;
        ++ensemble_itr
      )
      {
        // copy the model
        util::ShPtr< ProteinModel> copy( ( *ensemble_itr)->HardCopy());

        // get the number identifier for this model
        const size_t conformation_number( ensemble_itr - ensemble.Begin());

        // model id string based on its number in the ensemble
        const std::string model_num_id( GetRoundNumberFormat()( conformation_number));

        WriteModel( *copy, model_num_id, STORAGE_STRINGS);
      }

      {
        // copy the model
        util::ShPtr< ProteinModel> copy( ARGUMENT.HardCopy());
        WriteModel( *copy, GetRoundNumberFormat()( ensemble.GetSize()), STORAGE_STRINGS);
      }

      // end
      return true;
    }

    //! @brief writes a single model to file
    //! @param MODEL the model to write
    //! @param CONFORMATION_NUMBER the identifying number string
    //! @param STORAGE_STRINGS the other strings for storage
    void PrinterProteinModelEnsemble::WriteModel
    (
      const ProteinModel &MODEL, const std::string &CONFORMATION_NUMBER,
      const storage::VectorND< 2, std::string> &STORAGE_STRINGS
    ) const
    {
      util::ShPtr< ProteinModel> model_copy( MODEL.HardCopy());

      // initialize transformation matrix for returning multiplier to original state
      math::TransformationMatrix3D multiplier_transform;

      // cast a pointer to the multiplier data if any
      util::ShPtr< ProteinModelMultiplier> sp_multiplier
      (
        model_copy->GetProteinModelData()->GetData( ProteinModelData::e_Multiplier)
      );

      // superimpose if specified
      if( m_Superimpose.IsDefined() && m_Superimpose != quality::GetSuperimposeMeasures().e_NoSuperimpose)
      {
        // superimpose the model and store the transformation to be used for the multiplier
        const math::TransformationMatrix3D transform
        (
          Quality::SuperimposeModel( m_Superimpose, *model_copy, biol::GetAtomTypes().CA).Second()
        );

        // if the pointer is defined
        if( sp_multiplier.IsDefined())
        {
          // set the transformation
          sp_multiplier->Transform( transform);
          multiplier_transform = math::Inverse( transform);
        }
      }

      // store the model
      const std::string filename // can get from storage object
      (
        m_Storage->GetInitializer() + "/" + STORAGE_STRINGS.First() + "_" + CONFORMATION_NUMBER + STORAGE_STRINGS.Second()
         + ".pdb"
      );
      if( m_Storage->Store( *model_copy, STORAGE_STRINGS.First() + "_" + CONFORMATION_NUMBER, STORAGE_STRINGS.Second()))
      {
        BCL_MessageStd( "pdb written to " + filename);
      }
      else
      {
        BCL_MessageCrt
        (
          "Unable to store file, " + filename + ", file may already exist and overwrite is not set"
        );
      }

      // if the multiplier pointer is defined
      if( sp_multiplier.IsDefined())
      {
        // move it back to where it was originally
        sp_multiplier->Transform( multiplier_transform);
      }
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_printer_protein_model_movie.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model_multiplier.h"
#include "assemble/bcl_assemble_quality.h"
#include "assemble/bcl_assemble_quality_batch.h"
#include "io/bcl_io_file.h"
#include "pdb/bcl_pdb_factory.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PrinterProteinModelMovie::s_Instance
    (
      GetObjectInstances().AddInstance( new PrinterProteinModelMovie())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PrinterProteinModelMovie::PrinterProteinModelMovie() :
      m_Prefix(),
      m_Tag(),
      m_MoviePrinter(),
      m_ScoringFunction(),
      m_StepStatusSet(),
      m_Superimpose( quality::GetSuperimposeMeasures().e_NoSuperimpose),
      m_Qualities(),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>())
    {
    }

    //! @brief construct from data members and information required to initialize movie printer
    //! @param PREFIX prefix as absolute path
    //! @param MOVIE_PRINTER mc movie printer to use
    //! @param SCORING_FUNCTION scoring function
    //! @param STEP_STATUS_SET step statuses to print
    //! @param SUPERIMPOSE superimpose measure to use
    //! @param QUALITIES quality measures to calculate
    PrinterProteinModelMovie::PrinterProteinModelMovie
    (
      const std::string &PREFIX,
      const util::ShPtr< mc::MoviePrinterInterface> &MOVIE_PRINTER,
      const util::ShPtr< score::ProteinModelScoreSum> &SCORING_FUNCTION,
      const storage::Set< opti::StepStatusEnum> &STEP_STATUS_SET,
      const quality::SuperimposeMeasure &SUPERIMPOSE,
      const storage::Set< quality::Measure> &QUALITIES
    ) :
      m_Prefix( PREFIX),
      m_MoviePrinter( MOVIE_PRINTER),
      m_ScoringFunction( SCORING_FUNCTION),
      m_StepStatusSet( STEP_STATUS_SET),
      m_Superimpose( SUPERIMPOSE),
      m_Qualities( QUALITIES),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>())
    {
    }

    //! @brief Clone function
    //! @return pointer to new PrinterProteinModelMovie
    PrinterProteinModelMovie *PrinterProteinModelMovie::Clone() const
    {
      return new PrinterProteinModelMovie( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PrinterProteinModelMovie::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return const reference to the prefix member variable
    //! @return prefix as string
    const std::string &PrinterProteinModelMovie::GetPrefix() const
    {
      return m_Prefix;
    }

    //! @brief required by interface but not implemented since the movie printer has its own prefix that
    //!        should not change
    //! @param PREFIX new prefix
    void PrinterProteinModelMovie::SetPrefix( const std::string &PREFIX)
    {
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief reset and initialize the printer
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @return true if initialization was successful
    void PrinterProteinModelMovie::Initialize( const size_t &ROUND_NUMBER)
    {
      // call initialize with undefined stage number
      Initialize( m_RoundNumber, util::GetUndefined< size_t>());
    }

    //! @brief reset and initialize the printer with the given round and stage number
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @param STAGE_NUMBER for multiple optimizations, a different stage number will be passed
    //! @return true if initialization was successful
    void PrinterProteinModelMovie::Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
    {
      // update round number
      m_RoundNumber = ROUND_NUMBER;

      // set the stage number
      m_StageNumber = STAGE_NUMBER;
    }

    //! @brief prints information concerning the approximation process based on the status of the given tracker
    //! @param TRACKER holds the status of the approximation process
    void PrinterProteinModelMovie::Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
    {
      // call WriteToFile function
      WriteToFile( TRACKER.GetBest(), CreateFileName( "final"), "final");

      // initialize output for script
      io::OFStream write;

      // construct the script filename
      std::string movie_script_filename( GetPrefix() + GetRoundNumberFormat()( m_RoundNumber));
      if( util::IsDefined( m_StageNumber))
      {
        movie_script_filename += "_" + GetStageNumberFormat()( m_StageNumber);
      }
      movie_script_filename += "_movie." + m_MoviePrinter->GetScriptFileExtension();
      io::File::MustOpenOFStream( write, movie_script_filename);

      // write the script
      m_MoviePrinter->WriteScript( write);
      io::File::CloseClearFStream( write);

      BCL_MessageCrt
      (
        "run the script " + movie_script_filename + " and use the following command line to encode the video: " +
        m_MoviePrinter->FFMpegCommandLine()
      );
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PrinterProteinModelMovie::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &PrinterProteinModelMovie::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief static function to write given model to using the given FILENAME and TAG
    //! @param ARGUMENT_RESULT_PAIR Pair of argument and corresponding result
    //! @param FILENAME filename of the file to be written
    //! @param TAG tag to be used
    //! @return whether writing succeeded
    bool PrinterProteinModelMovie::WriteToFile
    (
      const util::ShPtr< storage::Pair< ProteinModel, double> > &ARGUMENT_RESULT_PAIR,
      const std::string &FILENAME,
      const std::string &TAG
    ) const
    {
      // open stream
      io::OFStream write;
      io::File::MustOpenOFStream( write, FILENAME);

      // copy the model
      util::ShPtr< ProteinModel> copy_ptr( ARGUMENT_RESULT_PAIR->First().HardCopy());
      ProteinModel &copy( *copy_ptr);

      // superimpose if specified
      if( m_Superimpose.IsDefined() && m_Superimpose != quality::GetSuperimposeMeasures().e_NoSuperimpose)
      {
        // superimpose the model and store the transformation to be used for the multiplier
        const math::TransformationMatrix3D transform
        (
          Quality::SuperimposeModel( m_Superimpose, copy, biol::GetAtomTypes().CA).Second()
        );

        // cast a pointer to the multiplier data if any
        util::ShPtr< ProteinModelMultiplier> sp_multiplier
        (
          copy.GetProteinModelData()->GetData( ProteinModelData::e_Multiplier)
        );

        // if the pointer is defined
        if( sp_multiplier.IsDefined())
        {
          // set the transformation
          sp_multiplier->Transform( math::Inverse( transform));

          // update the protein data
          util::ShPtr< ProteinModelData> sp_protein_model_data( copy.GetProteinModelData());
          sp_protein_model_data->Replace( ProteinModelData::e_Multiplier, sp_multiplier);
          copy.SetProteinModelData( sp_protein_model_data);
        }
      }

      // initialize header
      storage::Table< double> table
      (
        math::SumFunctionMixin< score::ProteinModel>::GetValueTableVerticalColumnNames()
      );

      // write score to file
      if( m_ScoringFunction.IsDefined())
      {
        table.Append( m_ScoringFunction->CreateSortedReadableTable( ARGUMENT_RESULT_PAIR->First()));
      }
      else
      {
        write << "score: " << ARGUMENT_RESULT_PAIR->Second() << '\n';
      }

      // if qualities were given
      if( !m_Qualities.IsEmpty())
      {
        // create quality section
        table.InsertRow
        (
          "Quality",
          storage::Vector< double>::Create
          (
            util::GetUndefined< double>(),
            util::GetUndefined< double>(),
            util::GetUndefined< double>()
          )
        );

        table.Append
        (
          QualityBatch( m_Qualities, biol::GetAtomTypes().CA, "", true).ConstructTable( ARGUMENT_RESULT_PAIR->First())
        );
      }

      // write model to file
      pdb::Factory().WriteModelToPDB( copy, write);
      BCL_MessageStd( "pdb written to " + util::Format()( FILENAME));

      // close and clear stream
      io::File::CloseClearFStream( write);

      // add to movie script
      if( TAG == "final")
      {
        // add frame
        m_MoviePrinter->AddFinalFrame( FILENAME, table);
      }
      else
      {
        opti::StepStatusEnum step_status;
        std::stringstream err_stream;
        if( step_status.TryRead( util::ObjectDataLabel( TAG), err_stream))
        {
          // add frame
          m_MoviePrinter->AddFrame( FILENAME, step_status, table);
        }
      }

      // return success
      return true;
    }

    //! @brief creates filename from minimization information
    //! @param TAG tag for the step status if applicable
    //! @param ITERATION number of iteration
    //! @return the full filename of a model pdb
    std::string PrinterProteinModelMovie::CreateFileName( const std::string &TAG, const size_t ITERATION) const
    {
      // initialize string
      std::string filename( m_Prefix + GetRoundNumberFormat()( m_RoundNumber) + "_");

      // if valid stage
      if( util::IsDefined( m_StageNumber))
      {
        // add stage prefix
        filename += GetStageNumberFormat()( m_StageNumber) + "_";
      }

      // if iteration is defined
      if( util::IsDefined( ITERATION))
      {
        filename += GetIterationNumberFormat()( ITERATION) + "_";
      }

      // add the tag
      filename += TAG + ".pdb";

      // end
      return filename;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_printer_protein_model_multimer.h"

// includes from bcl - sorted alphabetically
#include "align/bcl_align_alignment_node.h"
#include "assemble/bcl_assemble_printer_protein_model.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_protein_model_multiplier.h"
#include "assemble/bcl_assemble_protein_storage_file.h"
#include "assemble/bcl_assemble_quality.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "util/bcl_util_wrapper.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PrinterProteinModelMultimer::s_Instance
    (
      GetObjectInstances().AddInstance( new PrinterProteinModelMultimer())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    PrinterProteinModelMultimer::PrinterProteinModelMultimer() :
      m_Prefix( ""),
      m_Superimpose(),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>()),
      m_NativeMultimer(),
      m_Storage( ProteinStorageFile::GetDefaultStorage())
    {
    }

    //! @brief construct with all member variables
    //! @param PREFIX prefix string
    //! @param NATIVE_MULTIMER_MODEL native multimer model
    //! @param STORAGE protein storage to use
    //! @param SUPERIMPOSE measure to use for superimposition
    PrinterProteinModelMultimer::PrinterProteinModelMultimer
    (
      const std::string &PREFIX,
      const util::ShPtr< ProteinModel> &NATIVE_MULTIMER_MODEL,
      const util::ShPtr< ProteinStorageFile> &STORAGE,
      const quality::SuperimposeMeasure &SUPERIMPOSE
    ) :
      m_Prefix( PREFIX),
      m_Superimpose( SUPERIMPOSE),
      m_RoundNumber( 0),
      m_StageNumber( util::GetUndefined< size_t>()),
      m_NativeMultimer( NATIVE_MULTIMER_MODEL),
      m_Storage( STORAGE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new PrinterProteinModelMultimer
    PrinterProteinModelMultimer *PrinterProteinModelMultimer::Clone() const
    {
      return new PrinterProteinModelMultimer( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &PrinterProteinModelMultimer::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return prefix
    //! @return prefix
    const std::string &PrinterProteinModelMultimer::GetPrefix() const
    {
      return m_Prefix;
    }

    //! @brief set prefix to given PREFIX
    //! @param PREFIX new prefix
    void PrinterProteinModelMultimer::SetPrefix( const std::string &PREFIX)
    {
      m_Prefix = PREFIX;
    }

    //! @brief reset and initialize the printer
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @return true if initialization was successful
    void PrinterProteinModelMultimer::Initialize( const size_t &ROUND_NUMBER)
    {
      // update round number
      m_RoundNumber = ROUND_NUMBER;

      // set the stage number to undefined
      m_StageNumber = util::GetUndefined< size_t>();
    }

    //! @brief reset and initialize the printer with the given round and stage number
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @param STAGE_NUMBER for multiple optimizations, a different stage number will be passed
    //! @return true if initialization was successful
    void PrinterProteinModelMultimer::Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
    {
      // initialize according to round number
      Initialize( ROUND_NUMBER);

      // update stage number
      m_StageNumber = STAGE_NUMBER;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief prints information concerning the approximation process based on the status of the given tracker
    //! @param TRACKER holds the status of the approximation process
    void PrinterProteinModelMultimer::Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
    {
      // call WriteToStorage function
      WriteToStorage
      (
        TRACKER.GetBest(),
        PrinterProteinModel::GetStorageStrings( m_Prefix, TRACKER.GetTag() + "_mult", m_RoundNumber, m_StageNumber)
      );
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PrinterProteinModelMultimer::Read( std::istream &ISTREAM)
    {
      // read members

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &PrinterProteinModelMultimer::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief function to write given model
    //! @param ARGUMENT_RESULT_PAIR Pair of argument and corresponding result
    //! @param STORAGE_STRINGS source and key strings from the minimization information
    //! @return whether write was successful
    bool PrinterProteinModelMultimer::WriteToStorage
    (
      const util::ShPtr< storage::Pair< ProteinModel, double> > &ARGUMENT_RESULT_PAIR,
      const storage::VectorND< 2, std::string> &STORAGE_STRINGS
    ) const
    {
      // copy the protein model data
      util::ShPtr< ProteinModelData> mult_pmd( ARGUMENT_RESULT_PAIR->First().GetProteinModelData()->HardCopy());

      // cast a pointer to the multiplier data if any
      util::ShPtr< ProteinModelMultiplier> sp_multiplier( mult_pmd->GetData( ProteinModelData::e_Multiplier));

      // model to hold the model multimer
      ProteinModel model_multimer;

      // if the pointer is defined
      if( sp_multiplier.IsDefined())
      {
        // apply the multiplier
        model_multimer = sp_multiplier->operator()( ARGUMENT_RESULT_PAIR->First());

        // set the pointer to null
        mult_pmd->Replace( ProteinModelData::e_Multiplier, util::ShPtr< ProteinModelMultiplier>());
      }

      // set the protein identification
      const util::ShPtr< util::Wrapper< std::string> > &sp_id
      (
        mult_pmd->GetData( ProteinModelData::e_Identification)
      );
      BCL_Assert( sp_id.IsDefined(), "No identification stored for protein model");
      mult_pmd->Replace
      (
        ProteinModelData::e_Identification,
        util::ShPtr< util::Wrapper< std::string> >( new util::Wrapper< std::string>( std::string( *sp_id) + "_mult"))
      );

      // if a native multimer model was supplied
      if( m_NativeMultimer.IsDefined())
      {
        // determine the best multimer
        model_multimer = CalculateBestMultimer( model_multimer, *m_NativeMultimer, quality::GetMeasures().e_RMSD, sp_multiplier);

        // create a new model using the chains from the native
        ProteinModel new_model( m_NativeMultimer->GetEmptyChains());

        // iterate over the SSEs in the multimer
        const util::SiPtrVector< const SSE> multimer_sses( model_multimer.GetSSEs());
        for
        (
          util::SiPtrVector< const SSE>::const_iterator sse_itr( multimer_sses.Begin()),
            sse_itr_end( multimer_sses.End());
          sse_itr != sse_itr_end; ++sse_itr
        )
        {
          // insert the sse
          new_model.Insert( util::ShPtr< SSE>( ( *sse_itr)->Clone()));
        }
        model_multimer = new_model;

        if( !mult_pmd->Insert( ProteinModelData::e_NativeModel, m_NativeMultimer))
        {
          mult_pmd->Replace( ProteinModelData::e_NativeModel, m_NativeMultimer);
        }

        // make a copy of the native model
        util::ShPtr< ProteinModel> sp_native_model_copy( m_NativeMultimer->Clone());

        // filter the SSEs by given pool min sse sizes
        sp_native_model_copy->FilterByMinSSESizes( SSEPool::GetCommandLineMinSSELengths());

        // add filtered model
        if( !mult_pmd->Insert( ProteinModelData::e_NativeFilteredModel, sp_native_model_copy))
        {
          mult_pmd->Replace( ProteinModelData::e_NativeFilteredModel, sp_native_model_copy);
        }
      }

      model_multimer.ConnectSSEToChainData();

      // if there is a native and the model should be superimposed
      if( m_Superimpose.IsDefined() && m_NativeMultimer.IsDefined())
      {
        // get the alignment between the current model and the native
        const storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > alignments
        (
          Quality::CreateAlignmentProteinModels( model_multimer, *m_NativeMultimer)
        );

        const storage::Set< biol::AtomType> &atom_type( biol::GetAtomTypes().CA);

        // initialize coordinates vector
        const storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > coords
        (
          Quality::CoordinatesFromAlignments( alignments, atom_type)
        );

        // transform the model to superimpose it to the native
        const math::TransformationMatrix3D transformation( ( *m_Superimpose)->CalculateSuperimposition( coords.Second(), coords.First()));
        model_multimer.Transform( transformation);
      }

      // set the protein model data
      model_multimer.SetProteinModelData( mult_pmd);

      // store the model
      const std::string filename( STORAGE_STRINGS.First() + STORAGE_STRINGS.Second() + ".pdb");
      if( m_Storage->Store( model_multimer, STORAGE_STRINGS.First(), STORAGE_STRINGS.Second()))
      {
        BCL_MessageStd( "pdb written to " + filename);
      }
      else
      {
        BCL_MessageCrt
        (
          "Unable to store file, " + filename + ", file may already exist and overwrite is not set"
        );
      }

      // end
      return true;
    }

    //! @brief determines the best combination of chain ids to match the native model
    //! @param MODEL model whose chains will be changed in order to find the best combination for superimposing
    //! @param NATIVE the model that will be used to calculate quality against
    //! @param QUALITY the quality that will be used to calculate the best model
    //! @param MULTIPLIER multiplier used to create the model
    //! @return protein model which can be best superimposed onto NATIVE
    ProteinModel PrinterProteinModelMultimer::CalculateBestMultimer
    (
      const ProteinModel &MODEL,
      const ProteinModel &NATIVE,
      const quality::Measure &QUALITY,
      const util::ShPtr< ProteinModelMultiplier> &MULTIPLIER
    )
    {
      // quality calculated on CAs
      const storage::Set< biol::AtomType> atom_type( biol::GetAtomTypes().CA);

      // get the alignment between the model and the native
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > alignments
      (
        Quality::CreateAlignmentProteinModels( MODEL, NATIVE)
      );

      // initialize coordinates vector
      storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > coords
      (
        Quality::CoordinatesFromAlignments( alignments, atom_type)
      );

      // calculate the quality measure for the model
      const double quality( ( *QUALITY)->CalculateMeasure( coords.First(), coords.Second()));

      // now reverse the chain ordering (i.e. counter-clockwise to clockwise) and see if the quality improves

      // initialize chains
      util::ShPtrVector< Chain> chains;

      // iterate over the chain mappings
      const storage::Map< char, std::string> chain_id_mappings( MULTIPLIER->GetTargetChains());
      for
      (
        storage::Map< char, std::string>::const_iterator map_itr( chain_id_mappings.Begin()),
          map_itr_end( chain_id_mappings.End());
        map_itr != map_itr_end; ++map_itr
      )
      {
        // iterate forwards and backwards through the target chains
        std::string::const_reverse_iterator rev_itr( map_itr->second.rbegin());
        const std::string::const_reverse_iterator rev_itr_end( map_itr->second.rend());
        for
        (
          std::string::const_iterator forward_itr( map_itr->second.begin()), forward_itr_end( map_itr->second.end());
          forward_itr != forward_itr_end && rev_itr != rev_itr_end; ++forward_itr, ++rev_itr
        )
        {
          // get the chain
          util::ShPtr< Chain> sp_chain( MODEL.GetChain( *forward_itr)->HardCopy());

          // set the chain id
          sp_chain->SetChainID( *rev_itr);

          // add to chains vector
          chains.PushBack( sp_chain);
        }
      }

      // sort
      chains.Sort( ChainLessThan());

      // create a new model
      ProteinModel model_copy( chains);

      // get the alignment between the current model and the native
      alignments = Quality::CreateAlignmentProteinModels( model_copy, NATIVE);

      // get coordinates vector
      coords = Quality::CoordinatesFromAlignments( alignments, atom_type);

      // return whichever model has the best quality
      return ( *QUALITY)->CalculateMeasure( coords.First(), coords.Second()) < quality ? model_copy : MODEL;
    }

  } // namespace assemble

} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_printer_tracker_history.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_quality_batch.h"
#include "io/bcl_io_file.h"
#include "mc/bcl_mc_temperature_interface.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> PrinterTrackerHistory::s_Instance
    (
      GetObjectInstances().AddInstance( new PrinterTrackerHistory())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default construactor
    PrinterTrackerHistory::PrinterTrackerHistory() :
      m_Path(),
      m_Prefix(),
      m_ScoringFunction(),
      m_Temperature(),
      m_ColumnNames()
    {
    }

    //! @brief constructor from a prefix, ShPtrs to scoring function, tracker, temperature and a native model
    //! @param PATH path to be used for writing output files
    //! @param PREFIX Prefix to be added to output filename
    //! @param SP_SCORING_FUNCTION ShPtr to scoring function to be used
    //! @param SP_TRACKER ShPtr to tracker that is used
    //! @param SP_TEMPERATURE ShPtr to temperature used
    //! @param QUALITIES set of quality measures to calculate
    PrinterTrackerHistory::PrinterTrackerHistory
    (
      const std::string &PATH,
      const std::string &PREFIX,
      const util::ShPtr< score::ProteinModelScoreSum> &SP_SCORING_FUNCTION,
      const util::ShPtr< mc::TemperatureInterface> &SP_TEMPERATURE,
      const storage::Set< quality::Measure> &QUALITIES
    ) :
      m_Path( PATH),
      m_Prefix( PREFIX),
      m_ScoringFunction( SP_SCORING_FUNCTION),
      m_Temperature( SP_TEMPERATURE),
      m_Qualities( QUALITIES),
      m_ColumnNames( CollectColumnNames())
    {
    }

    //! @brief Clone function
    //! @return pointer to new PrinterTrackerHistory
    PrinterTrackerHistory *PrinterTrackerHistory::Clone() const
    {
      return new PrinterTrackerHistory( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &PrinterTrackerHistory::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return prefix
    //! @return prefix
    const std::string &PrinterTrackerHistory::GetPrefix() const
    {
      return m_Prefix;
    }

    //! @brief set prefix to given PREFIX
    //! @param PREFIX new prefix
    void PrinterTrackerHistory::SetPrefix( const std::string &PREFIX)
    {
      m_Prefix = PREFIX;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief the filename the history is written to
    //! @return the filename the history is written to
    std::string PrinterTrackerHistory::Filename() const
    {
      const std::string filename( m_Path + util::GetRuntimeEnvironment().GetPathSeperator() + m_Prefix
        + GetRoundNumberFormat()( m_RoundNumber) + "_" + GetStageNumberFormat()( m_StageNumber) + ".tracker_history");

      return filename;
    }

    //! @brief reset and initialize the printer
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @return true if initialization was successful
    void PrinterTrackerHistory::Initialize( const size_t &ROUND_NUMBER)
    {
      // set the round number
      m_RoundNumber = ROUND_NUMBER;
    }

    //! @brief reset and initialize the printer with the given round and stage number
    //! @param ROUND_NUMBER for multiple optimizations, a different round number will be passed
    //! @param STAGE_NUMBER for multiple optimizations, a different stage number will be passed
    //! @return true if initialization was successful
    void PrinterTrackerHistory::Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
    {
      // set the round number and stage number
      m_RoundNumber = ROUND_NUMBER;
      m_StageNumber = STAGE_NUMBER;
    }

    //! @brief prints information concerning the approximation process based on the status of the given tracker
    //! @param TRACKER holds the status of the approximation process
    void PrinterTrackerHistory::Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
    {
      // Write history to file
      WriteToFile( TRACKER);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &PrinterTrackerHistory::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &PrinterTrackerHistory::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief collects column names in a vector of strings and returns it
    //! @return vector of string that holds the column names
    storage::Vector< std::string> PrinterTrackerHistory::CollectColumnNames() const
    {
      // initialize column names
      storage::Vector< std::string> column_names
      (
        storage::Vector< std::string>::Create
        (
          "iter_no", "step_status", "nr_aas", "nr_sses", "nr_helix", "nr_strand", "temperature", "mutate"
        )
      );

      // now get the scheme names from the scoring function and append them to this vector
      column_names.Append( m_ScoringFunction->GetFunctionSchemes());

      // if the native model is defined with coordinates
      if( !m_Qualities.IsEmpty())
      {
        column_names.Append( QualityBatch::ColumnNamesFromQualities( m_Qualities));
      }
      // end
      return column_names;
    }

    //! @brief function to write to stream
    //! @param TRACKER holds the status of the approximation process
    //! @return whether writing succeeded
    void PrinterTrackerHistory::WriteToFile( const opti::Tracker< ProteinModel, double> &TRACKER) const
    {
      // static column seperator
      static const std::string col_sep( " ");

      // initialize formats
      static const util::Format column_format( util::Format().W( 12).R());
      static const util::Format number_format( util::Format().W( 12).FFP( 3).R());
      static const util::Format mutate_format( util::Format().W( 40).R());

      // initialize filename
      const std::string filename( Filename());

      // get the scheme for the last step
      const std::string &mutate_scheme( TRACKER.GetStepScheme());

      // get a reference on the last argument
      const ProteinModel &this_model( TRACKER.GetCurrent()->First());

      // initialize write
      io::OFStream write;

      // if this is the first iteration
      if( TRACKER.GetIteration() == 1)
      {
        // open with write mode
        io::File::MustOpenOFStream( write, filename);

        // write out the header for the table
        // iterate over the column names
        for
        (
          storage::Vector< std::string>::const_iterator
            name_itr( m_ColumnNames.Begin()), name_itr_end( m_ColumnNames.End());
          name_itr != name_itr_end; ++name_itr
        )
        {
          // if this is mutate column
          if( *name_itr == "mutate")
          {
            write << mutate_format( *name_itr) << col_sep;
          }
          else
          {
            write << column_format( *name_itr) << col_sep;
          }
        }
        write << '\n';
      }
      else
      {
        // otherwise open with append mode
        io::File::MustOpenOFStream( write, filename, std::ios::app);
      }

      // get the step status name
      const std::string step_status_name( TRACKER.GetStatusOfLastStep().GetString());

      // now start printing the values
      // iteration number
      write << column_format( TRACKER.GetIteration()) << col_sep;
      // step status
      write << column_format( step_status_name) << col_sep;
      // number amino acids
      write << column_format( this_model.GetNumberAAs()) << col_sep;
      // number SSEs
      write << column_format( this_model.GetNumberSSEs()) << col_sep;
      // number helices
      write << column_format( this_model.GetNumberSSE( biol::GetSSTypes().HELIX)) << col_sep;
      // number strands
      write << column_format( this_model.GetNumberSSE( biol::GetSSTypes().STRAND)) << col_sep;
      // temperature
      write << number_format( m_Temperature->GetLastCalculatedTemperature()) << col_sep;
      // write the mutate name
      write << mutate_format( mutate_scheme) << col_sep;

      // now get the scores
      storage::Table< double> scores( m_ScoringFunction->CreateValueTableHorizontal( this_model));
      // get the row with weighted values and write with the same format
      storage::Vector< double> score_vector( scores[ "weighted_value"].GetData());

      // iterate over columns
      for
      (
        storage::Vector< double>::const_iterator score_itr( score_vector.Begin()), score_itr_end( score_vector.End());
        score_itr != score_itr_end; ++score_itr
      )
      {
        write << number_format( *score_itr) << col_sep;
      }

      // if any quality measures are given
      if( !m_Qualities.IsEmpty())
      {
        // now calculate the measures
        const storage::List< storage::Pair< std::string, double> > measures_list
        (
          QualityBatch( m_Qualities, biol::GetAtomTypes().CA)( this_model)
        );

        // iterate over the measures vector
        for
        (
          storage::List< storage::Pair< std::string, double> >::const_iterator
            measure_itr( measures_list.Begin()), measure_itr_end( measures_list.End());
          measure_itr != measure_itr_end; ++measure_itr
        )
        {
          // print the value
          write << number_format( measure_itr->Second()) << col_sep;
        }
      }

      // add the newline character and return true
      write << '\n';
      io::File::CloseClearFStream( write);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_ensemble.h"

// includes from bcl - sorted alphabetically
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "fold/bcl_fold_default_flags.h"
#include "io/bcl_io_file.h"
#include "pdb/bcl_pdb_factory.h"
#include "restraint/bcl_restraint_data_set_pairwise.h"
#include "sspred/bcl_sspred_method_handler.h"
#include "sspred/bcl_sspred_pdb.h"
#include "util/bcl_util_logger_interface.h"
#include "util/bcl_util_wrapper.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinEnsemble::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinEnsemble())
    );

    //! command line flag for reading list of protein models
    util::ShPtr< command::FlagInterface> &ProteinEnsemble::GetFlagPDBList()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "pdb_list", "\tlist of pdbs to do statistics over"
        )
      );

      // initialize filename parameter
      static util::ShPtr< command::ParameterInterface> s_filename
      (
        new command::Parameter
        (
          "filename", "\tfull path and name of pdb list file", "pdbs.ls"
        )
      );

      // initialize pdb column parameter
      static util::ShPtr< command::ParameterInterface> s_column
      (
        new command::Parameter
        (
          "column", "\tthe column in the file where the pdb name is. First column is number 0.", "0"
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_filename);
        flag->PushBack( s_column);
      }

      // end
      return s_flag;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinEnsemble::ProteinEnsemble() :
      m_Ensemble()
    {
    }

    //! @brief constructor
    //! @param MODEL model the ensemble will be created from
    ProteinEnsemble::ProteinEnsemble( const util::ShPtr< ProteinModel> &MODEL) :
      ProteinModel( *util::ShPtr< ProteinModel>( MODEL->HardCopy())),
      m_Ensemble()
    {
    }

    //! @brief constructor
    //! @param MODEL model the ensemble will be created from
    ProteinEnsemble::ProteinEnsemble( const ProteinModel &MODEL) :
      ProteinModel( *util::ShPtr< ProteinModel>( MODEL.HardCopy())),
      m_Ensemble()
    {
    }

    //! @brief constructor taking filename with list of pdbs in it
    //! @param FILENAME file with the list of pdbs in it
    //! @param COLUMN the column in the file that has the pdbs in it
    //! @param AA_CLASS aa class used for protein models
    //! @param PREFIX prefix to add to all filenames in the file
    ProteinEnsemble::ProteinEnsemble
    (
      const std::string &FILENAME,
      const size_t COLUMN,
      const biol::AAClass &AA_CLASS,
      const std::string &PREFIX,
      const bool &STATUS_MESSAGES,
      const size_t &INPUT_START,
      const size_t &INPUT_MAX
    ) :
      m_Ensemble()
    {
      *this = GetEnsembleFromFile( FILENAME, COLUMN, AA_CLASS, PREFIX, STATUS_MESSAGES, INPUT_START, INPUT_MAX);
    }

    //! @brief Clone function
    //! @return pointer to new ProteinEnsemble
    ProteinEnsemble *ProteinEnsemble::Clone() const
    {
      return new ProteinEnsemble( *this);
    }

    //! @brief hard copy constructor
    //! @return a ProteinModel with chains hard copied from that model
    ProteinEnsemble *ProteinEnsemble::HardCopy() const
    {
      ProteinEnsemble *new_models( new ProteinEnsemble());
      for( const_iterator itr( Begin()), itr_end( End()); itr != itr_end; ++itr)
      {
        util::ShPtr< ProteinModel> new_model( ( *itr)->HardCopy());
        new_models->InsertElement( new_model);
        new_model->SetProteinModelData( ( *itr)->GetProteinModelData()->HardCopy());
      }

      // iterate over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator
          chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // push back a shptr to a hardcopied chain
        new_models->m_Chains.PushBack( util::ShPtr< Chain>( ( *chain_itr)->HardCopy()));
      }

      new_models->SetProteinModelData( m_ProteinModelData->HardCopy());

      return new_models;
    }

    //! @brief empty copy constructor
    //! @return a ProteinModel that is empty
    ProteinEnsemble *ProteinEnsemble::Empty() const
    {
      return new ProteinEnsemble();
    }

    //! @brief destructor
    ProteinEnsemble::~ProteinEnsemble()
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinEnsemble::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns size of the container
    //! @return size, i.e. number of elements stored
    size_t ProteinEnsemble::GetSize() const
    {
      return m_Ensemble.GetSize();
    }

    //! @brief return iterator on begin
    //! @return iterator pointing to the beginning of the container, i.e. the first element
    ProteinEnsemble::iterator ProteinEnsemble::Begin()
    {
      return m_Ensemble.Begin();
    }

    //! @brief return const_iterator on begin
    //! @return const_iterator pointing to the beginning of the container, i.e. the first element
    ProteinEnsemble::const_iterator ProteinEnsemble::Begin() const
    {
      return m_Ensemble.Begin();
    }

    //! @brief return iterator on end
    //! @return iterator pointing to the end of the container, i.e. behind the last element
    ProteinEnsemble::iterator ProteinEnsemble::End()
    {
      return m_Ensemble.End();
    }

    //! @brief return const_iterator on end
    //! @return const_iterator pointing to the end of the container, i.e. behind the last element
    ProteinEnsemble::const_iterator ProteinEnsemble::End() const
    {
      return m_Ensemble.End();
    }

    //! @brief sets the sse pool within the protein model data
    //! @param SSE_POOL the sse pool that will be set in the protein model data
    void ProteinEnsemble::SetSSEPoolData( const util::ShPtr< SSEPool> &SSE_POOL)
    {
      // set the pool for the protein model
      ProteinModel::SetSSEPoolData( SSE_POOL);

      // iterate through the ensemble to set the pool
      for( iterator itr( Begin()), itr_end( End()); itr != itr_end; ++itr)
      {
        ( *itr)->SetSSEPoolData( SSE_POOL);
      }
    }

    //! @brief set identifiers of each model in the ensemble
    //! @param IDENTIFIERS the identifiers in the order of the models that they are assigned
    //! @return true if setting was successful
    bool ProteinEnsemble::SetIdentifiers( const storage::Vector< std::string> &IDENTIFIERS)
    {
      if( IDENTIFIERS.GetSize() != m_Ensemble.GetSize())
      {
        return false;
      }

      // iterate through the ensemble to set the pool
      storage::Vector< std::string>::const_iterator ident_itr( IDENTIFIERS.Begin());
      for( iterator itr( Begin()), itr_end( End()); itr != itr_end; ++itr, ++ident_itr)
      {
        util::ShPtr< ProteinModelData> sp_data( ( *itr)->GetProteinModelData());
        util::ShPtr< util::Wrapper< std::string> > sp_id( new util::Wrapper< std::string>( *ident_itr));
        if( !sp_data->Insert( ProteinModelData::e_Identification, sp_id))
        {
          return false;
        }
      }

      return true;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief checks whether container is empty
    //! @return if the container is empty or not
    bool ProteinEnsemble::IsEmpty() const
    {
      return m_Ensemble.IsEmpty();
    }

    //! @brief insert ELEMENT into the container
    //! @param ELEMENT an object of t_DataType that is inserted
    void ProteinEnsemble::InsertElement( const util::ShPtr< ProteinModel> &ELEMENT)
    {
      m_Ensemble.PushBack( ELEMENT);
    }

    //! @brief insert ELEMENT into the container
    //! @param POS the position where the element should be inserted
    //! @param ELEMENT an object of t_DataType that is inserted
    void ProteinEnsemble::InsertElement( const size_t POS, const util::ShPtr< ProteinModel> &ELEMENT)
    {
      m_Ensemble.InsertElement( POS, ELEMENT);
    }

    //! @brief delete single element at ITR
    //! @param ITR iterator pointing to the element that will be destroyed
    void ProteinEnsemble::RemoveElement( iterator ITR)
    {
      m_Ensemble.RemoveElement( ITR);
    }

    //! @brief gives the mean and std dev of distances for a data pair for this ensemble
    //! @param DATA_PAIR the data pair that indicates the distance that should be calculated
    //! @return the mean and std dev of all pairwise distances
    math::RunningAverageSD< double> ProteinEnsemble::GetDistanceStatistics
    (
      const restraint::DataPairwise &DATA_PAIR
    ) const
    {
      // get the distances
      const storage::Vector< double> distances( GetDistances( DATA_PAIR));

      // will hold the statistics
      math::RunningAverageSD< double> mean_sd;

      // iterate through distances to calculate statistics
      for
      (
        storage::Vector< double>::const_iterator
          distances_itr( distances.Begin()), distances_itr_end( distances.End());
        distances_itr != distances_itr_end;
        ++distances_itr
      )
      {
        if( util::IsDefined( *distances_itr))
        {
          mean_sd += *distances_itr;
        }
      }

      // return statistics object
      return mean_sd;
    }

    //! @brief gives vector of coordinates located from each of the models in the ensemble
    //! @param COORD_LOCATOR method for locating coordinates in each model
    //! @return vector of coordinates located from each of the models in the ensemble
    storage::Vector< linal::Vector3D> ProteinEnsemble::GetCoordinates
    (
      const find::LocatorInterface< linal::Vector3D, ProteinModel> &COORD_LOCATOR
    ) const
    {
      // will hold coordinates
      storage::Vector< linal::Vector3D> coordinates;

      // iterate through the ensemble
      for
      (
        const_iterator model_itr( Begin()), model_itr_end( End()); model_itr != model_itr_end; ++model_itr
      )
      {
        // locate the coordinates
        const linal::Vector3D coord( COORD_LOCATOR.Locate( **model_itr));

        // true if the coordinates are not defined
        if( !coord.IsDefined())
        {
          // go to next iteration
          continue;
        }

        // add the coordinates to the vector of coordinates
        coordinates.PushBack( coord);
      }

      return coordinates;
    }

    //! @brief gives a vector of distances calculated within each of the models for a given data pair
    //! @param DATA_PAIR the data pair that indicates the distance that should be calculated
    //! @return vector of doubles which are the distances calculated in each of the models of the ensemble
    storage::Vector< double> ProteinEnsemble::GetDistances( const restraint::DataPairwise &DATA_PAIR) const
    {
      // will hold the distances
      storage::Vector< double> distances;

      // iterate over the models of the ensemble
      for
      (
        const_iterator model_itr( Begin()), model_itr_end( End()); model_itr != model_itr_end; ++model_itr
      )
      {
        // get the coordinates for the first atom
        const linal::Vector3D coord_a( DATA_PAIR.First()->Locate( **model_itr));

        // get the coordinates for the second atom
        const linal::Vector3D coord_b( DATA_PAIR.Second()->Locate( **model_itr));

        // true if either of the coordinates are not defined
        if( !coord_a.IsDefined() || !coord_b.IsDefined())
        {
          // add undefined double and continue
          distances.PushBack( util::GetUndefinedDouble());

          continue;
        }

        // calculate the distance between the atoms
        const double distance( linal::Distance( coord_a, coord_b));

        // add the distance into distances
        distances.PushBack( distance);
      }

      return distances;
    }

    //! @brief gives a vector of distance changes for a data pair for this ensemble versus a given ensemble.
    //!        all pairwise distance changes are calculated and provided
    //! @param DATA_PAIR the data pair that indicates the distance that should be calculated
    //! @param OTHER_ENSEMBLE the ensemble which provides the second state to get distance changes from
    //! @return vector of doubles which are all pairwise distance changes going from this ensemble to OTHER_ENSEMBLE
    //!         for the given data pair
    storage::Vector< double> ProteinEnsemble::GetDistanceChanges
    (
      const restraint::DataPairwise &DATA_PAIR,
      const ProteinEnsemble &OTHER_ENSEMBLE
    ) const
    {
      // get the distances from this ensemble
      const storage::Vector< double> this_distances( GetDistances( DATA_PAIR));

      // get the distances from OTHER_ENSEMBLE
      const storage::Vector< double> other_distances( OTHER_ENSEMBLE.GetDistances( DATA_PAIR));

      // vector will hold the pairwise distance changes between this and the other ensemble
      storage::Vector< double> distance_changes;

      // iterate through this distances to calculate the difference to the other distances
      for
      (
        storage::Vector< double>::const_iterator
          this_distances_itr( this_distances.Begin()), this_distances_itr_end( this_distances.End());
        this_distances_itr != this_distances_itr_end;
        ++this_distances_itr
      )
      {
        // iterate through the other distances
        for
        (
          storage::Vector< double>::const_iterator
            other_distances_itr( other_distances.Begin()), other_distances_itr_end( other_distances.End());
          other_distances_itr != other_distances_itr_end;
          ++other_distances_itr
        )
        {
          // calculate the distance difference
          const double distance_difference( ( *this_distances_itr) - ( *other_distances_itr));

          // add the distance difference to distance changes
          distance_changes.PushBack( distance_difference);
        }
      }

      return distance_changes;
    }

    //! @brief gives the mean and std dev of distance changes for a data pair for this ensemble versus a given
    //!        ensemble. all pairwise distance changes are calculated and provided
    //! @param DATA_PAIR the data pair that indicates the distance that should be calculated
    //! @param OTHER_ENSEMBLE the ensemble which provides the second state to get distance changes from
    //! @return the mean and std dev of all pairwise distance changes going from this ensemble to OTHER_ENSEMBLE
    math::RunningAverageSD< double> ProteinEnsemble::GetDistanceChangesMeanSD
    (
      const restraint::DataPairwise &DATA_PAIR,
      const ProteinEnsemble &OTHER_ENSEMBLE
    ) const
    {
      // get the distance changes
      const storage::Vector< double> distance_changes( GetDistanceChanges( DATA_PAIR, OTHER_ENSEMBLE));

      // will hold the statistics
      math::RunningAverageSD< double> mean_sd;

      // iterate through distance changes to build up the mean and stdev statistics
      for
      (
        storage::Vector< double>::const_iterator
          distance_change_itr( distance_changes.Begin()), distance_change_itr_end( distance_changes.End());
        distance_change_itr != distance_change_itr_end;
        ++distance_change_itr
      )
      {
        // if the current distance change is not defined, continue
        if( !util::IsDefined( *distance_change_itr))
        {
          continue;
        }

        // add current value to statistics
        mean_sd += *distance_change_itr;
      }

      return mean_sd;
    }

    //! @brief gives all mean and std dev of distance changes for a data set for this ensemble versus a given
    //!        ensemble. all pairwise distance changes are calculated and provided
    //! @param DATA_SET the data set that indicates the distance that should be calculated
    //! @param OTHER_ENSEMBLE the ensemble which provides the second state to get distance changes from
    //! @return the mean and std dev of all pairwise distance changes going from this ensemble to OTHER_ENSEMBLE
    std::multimap< math::RunningAverageSD< double>, restraint::DataPairwise, math::LessThanAbsoluteMean>
    ProteinEnsemble::GetDistanceChangesMeanSD
    (
      const restraint::DataSetPairwise &DATA_SET, const ProteinEnsemble &OTHER_ENSEMBLE
    ) const
    {
      // will hold the statistics for the whole data set
      std::multimap< math::RunningAverageSD< double>, restraint::DataPairwise, math::LessThanAbsoluteMean> stats;

      // iterate over the data set
      for
      (
        restraint::DataSetPairwise::const_iterator
          itr( DATA_SET.Begin()), itr_end( DATA_SET.End());
        itr != itr_end;
        ++itr
      )
      {
        // get and insert the current mean sd
        const math::RunningAverageSD< double> mean_sd( GetDistanceChangesMeanSD( *itr, OTHER_ENSEMBLE));
        stats.insert( std::make_pair( mean_sd, *itr));
      }

      return stats;
    }

    //! @brief removes all models from the ensemble
    void ProteinEnsemble::Reset()
    {
      m_Ensemble.Reset();
    }

    //! @brief read given ssmethods predictions
    //! @param SS_METHODS the methods to read for each protein in the ensemble
    //! @return true if reading was successful
    bool ProteinEnsemble::ReadSSPredictions( const storage::Set< sspred::Method> &SS_METHODS)
    {
      bool success( true);

      // iterate trough the ensemble
      for( iterator itr( Begin()), itr_end( End()); itr != itr_end; ++itr)
      {
        // get the filename
        util::ShPtr< util::Wrapper< std::string> > sp_filename( ( *itr)->GetProteinModelData()->GetData( ProteinModelData::e_PDBFile));

        if( !sp_filename.IsDefined())
        {
          success = false;
          continue;
        }

        // remove extension and split into path and prefix
        const std::string filename( io::File::RemoveFullExtension( *sp_filename));
        const storage::VectorND< 2, std::string> path_prefix( io::File::SplitToPathAndFileName( filename));

        // read predictions for that protein model
        success &=
          sspred::MethodHandler::ReadPredictionsForProteinModel
          (
            SS_METHODS,
            **itr,
            fold::DefaultFlags::GetFlagReadSequenceDataPath()->GetParameterList()( 1)->GetValue(),
            fold::DefaultFlags::GetFlagReadSequenceDataPath()->GetFirstParameter()->GetValue()
          )
          || sspred::MethodHandler::ReadPredictionsForProteinModel( SS_METHODS, **itr, path_prefix.Second(), path_prefix.First());
      }

      // end
      return success;
    }

    //! @brief gives all of the pdb file names of the proteins in the ensemble
    //! @return vector of strings which are the pdb names of the proteins in the ensemble
    storage::Vector< std::string> ProteinEnsemble::GetPDBNames() const
    {
      storage::Vector< std::string> names;

      // iterate through the ensemble
      for( const_iterator itr( Begin()), itr_end( End()); itr != itr_end; ++itr)
      {
        // get the name of the first model in order to determine its length
        util::ShPtr< util::Wrapper< std::string> > pdb_name
        (
          ( *itr)->GetProteinModelData()->GetData( ProteinModelData::e_PDBFile)
        );
        if( pdb_name.IsDefined())
        {
          names.PushBack( std::string( *pdb_name));
        }
      }

      return names;
    }

    //! @brief gives a format object which can be used to format strings based on the longest pdb name
    //! @return format object which can be used to format strings to the same length as the longest pdb name
    util::Format ProteinEnsemble::GetNameFormatter() const
    {
      int longest_name( 0);
      // iterate through the ensemble
      for( const_iterator itr( Begin()), itr_end( End()); itr != itr_end; ++itr)
      {
        // get the name of the first model in order to determine its length
        util::ShPtr< util::Wrapper< std::string> > pdb_name
        (
          ( *itr)->GetProteinModelData()->GetData( ProteinModelData::e_PDBFile)
        );
        if( pdb_name.IsDefined())
        {
          int current_name_length( pdb_name->length());
          if( longest_name < current_name_length)
          {
            longest_name = current_name_length;
          }
        }
      }

      return util::Format().W( longest_name);
    }

    //! @brief gives the conformations that are in this protein
    //! @return protein ensemble which is the conformations making up this protein
    const ProteinEnsemble &ProteinEnsemble::GetConformationalEnsemble() const
    {
      return *this;
    }

    //! @brief sets the conformations that are in this protein
    //! @param ENSEMBLE protein ensemble which is the conformations making up this protein
    void ProteinEnsemble::SetConformationalEnsemble( const ProteinEnsemble &ENSEMBLE)
    {
      m_Ensemble = ENSEMBLE.m_Ensemble;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinEnsemble::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Ensemble, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinEnsemble::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Ensemble, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief opens a file and reads a list of pdbs and creates an ensemble out of them
    //! @param FILENAME file with the list of pdbs in it
    //! @param COLUMN the column in the file that has the pdbs in it - start at 0
    //! @param PREFIX prefix to add to all filenames in the file
    ProteinEnsemble ProteinEnsemble::GetEnsembleFromFile
    (
      const std::string &FILENAME,
      const size_t COLUMN,
      const biol::AAClass &AA_CLASS,
      const std::string &PREFIX,
      const bool &STATUS_MESSAGE,
      const size_t &INPUT_START,
      const size_t &INPUT_MAX
    )
    {
      // open file
      io::IFStream read;
      io::File::MustOpenIFStream( read, FILENAME);

      // read in and split the lines
      const storage::Vector< storage::Vector< std::string> > lines( util::SplittedStringLineListFromIStream( read));
      io::File::CloseClearFStream( read);
      ProteinEnsemble ensemble;

      const pdb::Factory factory( AA_CLASS);

      const size_t n_to_read( std::min( INPUT_MAX, lines.GetSize() - std::min( lines.GetSize(), INPUT_START)));

      const std::string n_pdbs( util::Format()( n_to_read));
      size_t pdb_num( 0);

      // iterate through the split lines to create protein models and add them to the ensemble
      for
      (
        storage::Vector< storage::Vector< std::string> >::const_iterator
          line_itr( lines.Begin() + INPUT_START), line_itr_end( lines.Begin() + n_to_read + INPUT_START);
        line_itr != line_itr_end;
        ++line_itr, ++pdb_num
      )
      {
        if( STATUS_MESSAGE)
        {
          util::GetLogger().LogStatus( "Reading Protein model : " + util::Format()( pdb_num) + " / " + n_pdbs);
        }
        // get pdb filename
        const std::string pdb_file( PREFIX + line_itr->operator()( COLUMN));

        // create protein model
        util::ShPtr< ProteinModel> model
        (
          factory.ProteinModelFromPDBFilename( pdb_file).Clone()
        );
        sspred::PDB::SetEnvironmentTypes( *model, true);

        // insert the pdb name as protein model data
        util::ShPtr< ProteinModelData> model_data( new ProteinModelData());
        model_data->Insert
        (
          ProteinModelData::e_PDBFile,
          util::ShPtr< util::Wrapper< std::string> >( new util::Wrapper< std::string>( pdb_file))
        );
        model->SetProteinModelData( model_data);

        // add the model to the ensemble
        ensemble.InsertElement( model);
        BCL_MessageDbg( "inserted model " + pdb_file + " into ensemble");
      }

      return ensemble;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_model.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_topology_combined.h"
#include "assemble/bcl_assemble_protein_ensemble.h"
#include "assemble/bcl_assemble_sse_geometry_packing_pickers.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "storage/bcl_storage_row.h"
#include "storage/bcl_storage_triplet.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

    //! @class TransformationsCompare
    //! @brief compares transformations
    struct BCL_API TransformationsCompare
    {
      //! @brief compares transformations
      //! @param TRIPLET_A first transformation
      //! @param TRIPLET_B second transformation
      //! @return comparison
      bool operator()
      (
        const storage::Triplet< char, char, math::TransformationMatrix3D> &TRIPLET_A,
        const storage::Triplet< char, char, math::TransformationMatrix3D> &TRIPLET_B
      )
      {
        return TRIPLET_A.Second() < TRIPLET_B.Second();
      }
    };

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> ProteinModel::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModel())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModel::ProteinModel() :
      m_Chains(),
      m_ProteinModelData( new ProteinModelData())
    {
    }

    //! @brief construct from ShPtrVector of Chains CHAINS
    //! @param CHAINS ShPtrVector of Chains
    ProteinModel::ProteinModel( const util::ShPtrVector< Chain> &CHAINS) :
      m_Chains( CHAINS),
      m_ProteinModelData( new ProteinModelData())
    {
    }

    //! @brief construct from util::ShPtr< Chain> CHAIN
    //! @param CHAIN ShPtr to Chain
    ProteinModel::ProteinModel( const util::ShPtr< Chain> &CHAIN) :
      m_Chains( 1, CHAIN),
      m_ProteinModelData( new ProteinModelData())
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer a new ProteinModel copied from this model
    ProteinModel *ProteinModel::Clone() const
    {
      return new ProteinModel( *this);
    }

    //! @brief hard copy constructor
    //! @return a ProteinModel with chains hard copied from that model
    ProteinModel *ProteinModel::HardCopy() const
    {
      return new ProteinModel( HardCopy( *this));
    }

    //! @brief hard copy a protein model by hard copying its chains
    ProteinModel ProteinModel::HardCopy( const ProteinModel &PROTEIN_MODEL)
    {
      // new protein model
      ProteinModel hard_copy;
      hard_copy.SetProteinModelData( PROTEIN_MODEL.m_ProteinModelData->HardCopy());

      // iterate over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.m_Chains.Begin()), chain_itr_end( PROTEIN_MODEL.m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // push back a shptr to a hardcopied chain
        hard_copy.m_Chains.PushBack( util::ShPtr< Chain>( ( *chain_itr)->HardCopy()));
      }

      // end
      return hard_copy;
    }

    //! @brief empty copy constructor
    //! @return a ProteinModel that is empty
    ProteinModel *ProteinModel::Empty() const
    {
      return new ProteinModel();
    }

    //! @brief destructor
    ProteinModel::~ProteinModel()
    {
      m_DestructorSignal.Emit( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModel::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the identification of the chains
    //! @return the identification of the chains
    std::string ProteinModel::GetIdentification() const
    {
      // initialize string
      std::string identification;

      // iterate through the chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // add the chain identification to the string
        identification += ( *chain_itr)->GetIdentification();
      }

      // end
      return identification;
    }

    //! @brief access the protein model data object which contains miscellaneous data for that protein model
    //! @return SHPtr to the protein model data object
    const util::ShPtr< ProteinModelData> &ProteinModel::GetProteinModelData() const
    {
      return m_ProteinModelData;
    }

    //! @brief set a new protein model data object
    //! @param SP_PROTEIN_MODEL_DATA ShPtr to a new protein model data object
    void ProteinModel::SetProteinModelData( const util::ShPtr< ProteinModelData> &SP_PROTEIN_MODEL_DATA)
    {
      m_ProteinModelData = SP_PROTEIN_MODEL_DATA;
      m_ChangeSignal.Emit( *this);
    }

    //! @brief sets the sse pool within the protein model data
    //! @param SSE_POOL the sse pool that will be set in the protein model data
    void ProteinModel::SetSSEPoolData( const util::ShPtr< SSEPool> &SSE_POOL)
    {
      // copy the ProteinModelData
      util::ShPtr< ProteinModelData> sp_model_data( GetProteinModelData()->HardCopy());
      if( !sp_model_data->Insert( ProteinModelData::e_Pool, SSE_POOL))
      {
        BCL_Assert
        (
          sp_model_data->Replace( ProteinModelData::e_Pool, SSE_POOL),
          "could not replace protein model data " + util::Format()( assemble::ProteinModelData::e_Pool)
        );
      }

      SetProteinModelData( sp_model_data);

      m_ChangeSignal.Emit( *this);
    }

    //! @brief returns total Number of SSEs
    //! @return total Number of SSEs
    size_t ProteinModel::GetNumberSSEs() const
    {
      // initialize counter
      size_t number_sses( 0);

      // loop over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // sum up the number of such SSEs from this chain
        number_sses += ( *chain_itr)->GetNumberSSEs();
      }
      // end
      return number_sses;
    }

    //! @brief return number of SSE of specified SSTYPE
    //! @param SS_TYPE specific SSTYPE
    //! @return number of SSE of specified SSTYPE
    size_t ProteinModel::GetNumberSSE( const biol::SSType &SS_TYPE) const
    {
      // initialize counter
      size_t number_sses( 0);

      // loop over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // sum up the number of such SSEs from this chain
        number_sses += ( *chain_itr)->GetNumberSSE( SS_TYPE);
      }
      // end
      return number_sses;
    }

    //! @brief get specific chains
    //! @param CHAIN_IDS specific chain IDs as a string
    //! @return specific chains requested
    util::ShPtrVector< Chain> ProteinModel::GetChains( const std::string &CHAIN_IDS) const
    {
      util::ShPtrVector< Chain> chains;
      for( std::string::const_iterator itr( CHAIN_IDS.begin()); itr != CHAIN_IDS.end(); ++itr)
      {
        chains.PushBack( GetChain( *itr));
      }
      return chains;
    }

    //! @brief returns chains without SSE information
    //! @return chains without SSE information
    util::ShPtrVector< Chain> ProteinModel::GetEmptyChains() const
    {
      // initialize vector of chains
      util::ShPtrVector< Chain> chains;

      // iterate over the chains in the protein model
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // pushback the chain lacking SSE information into the chains vector
        chains.PushBack( util::ShPtr< Chain>( new Chain( ( *chain_itr)->GetSequence())));
      }

      //end
      return chains;
    }

    //! @brief get all chain ids
    //! @return vector with all chain ids in protein model
    std::string ProteinModel::GetChainIDs() const
    {
      std::string chain_ids;

      //loop over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        chain_ids.push_back( ( *chain_itr)->GetChainID());
      }

      // end
      return chain_ids;
    }

    //! @brief returns const ShPtr to Chain with the supplied chain id
    //! @param CHAIN_ID Chain ID of the chain that is being searched
    //! @return const ShPtr to Chain with the supplied chain id
    const util::ShPtr< Chain> &ProteinModel::GetChain( const char CHAIN_ID) const
    {
      //loop over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // if this chain has the supplied CHAIN_ID, return it
        if( ( *chain_itr)->GetChainID() == CHAIN_ID)
        {
          return *chain_itr;
        }
      }

      // if no such chain was found message and return empty shared pointer
      BCL_MessageDbg
      (
        "No chain with the supplied chain_id '" + util::Format()( CHAIN_ID) +
        "' was found in this protein model with the chains\n" + util::Format()( GetChainIDs())
      );
      static const util::ShPtr< Chain> s_undefined_chain;
      return s_undefined_chain;
    }

    //! @brief returns const ShPtr to Chain with the supplied chain id
    //! @param CHAIN_ID Chain ID of the chain that is being searched
    //! @return const ShPtr to Chain with the supplied chain id
    util::ShPtr< Chain> &ProteinModel::GetChain( const char CHAIN_ID)
    {
      //loop over all chains
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // if this chain has the supplied CHAIN_ID, return it
        if( ( *chain_itr)->GetChainID() == CHAIN_ID)
        {
          return *chain_itr;
        }
      }

      // if no such chain was found message and return empty shared pointer
      BCL_MessageDbg
      (
        "No chain with the supplied chain_id '" + util::Format()( CHAIN_ID) +
        "' was found in this protein model with the chains\n" + util::Format()( GetChainIDs())
      );
      static util::ShPtr< Chain> s_undefined_chain;
      return s_undefined_chain;
    }

    //! @brief returns SiPtrVector of AASequences of all chains
    //! @return SiPtrVector of AASequences of all chains
    util::SiPtrVector< const biol::AASequence> ProteinModel::GetSequences() const
    {
      // initialize sequences vector
      util::SiPtrVector< const biol::AASequence> sequences;

      //loop over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        sequences.PushBack( ( *chain_itr)->GetSequence());
      }

      // end
      return sequences;
    }

    //! @brief returns SiPtrVector of all SSEs of given SS_TYPE
    //! @param SS_TYPE SSType of interest
    //! @return SiPtrVector of all SSEs of given SS_TYPE
    util::SiPtrVector< const SSE> ProteinModel::GetSSEs( const biol::SSType &SS_TYPE) const
    {
      util::SiPtrVector< const SSE> sses;

      //loop over all SSElements
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        sses.Append( ( *chain_itr)->GetSSEs( SS_TYPE));
      }

      return sses;
    }

    //! @brief returns SiPtrVector of all SSEs of given SS_TYPES in the set
    //! @param SS_TYPES set of SSTypes of interest
    //! @brief returns SiPtrVector of all SSEs of given SS_TYPES in the set
    util::SiPtrVector< const SSE> ProteinModel::GetSSEs( const storage::Set< biol::SSType> &SS_TYPES) const
    {
      util::SiPtrVector< const SSE> sses;

      //loop over all SSElements
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        sses.Append( ( *chain_itr)->GetSSEs( SS_TYPES));
      }

      return sses;
    }

    //! @brief returns SiPtrVector of all SSEs in all chains
    //! @return SiPtrVector of all SSEs in all chains
    util::SiPtrVector< const SSE> ProteinModel::GetSSEs() const
    {
      util::SiPtrVector< const SSE> sses;

      //loop over all SSElements
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        sses.Append( ( *chain_itr)->GetSSEs());
      }

      return sses;
    }

    //! @brief returns the SSE containing the given residue
    //! @param RESIDUE residue for which to return the SSE
    //! @return SSE containing the given residue
    util::SiPtr< const SSE> ProteinModel::GetSSE( const biol::AABase &RESIDUE) const
    {
      // get the chain and sequence ids
      const char chain_id( RESIDUE.GetChainID());
      const int seq_id( RESIDUE.GetSeqID());

      // find the SSE containing the given residue
      const Chain &chain( *GetChain( chain_id));
      for
      (
        auto sse_it( chain.GetData().Begin()), sse_it_end( chain.GetData().End());
        sse_it != sse_it_end;
        ++sse_it
      )
      {
        const SSE &sse( **sse_it);
        if( sse.GetFirstAA()->GetSeqID() <= seq_id && sse.GetLastAA()->GetSeqID() >= seq_id)
        {
          return *sse_it;
        }
      }

      return util::SiPtr< const SSE>();
    }

    //! @brief returns ShPtrVector of all SSE geometries in all chains
    //! @return ShPtrVector of all SSE geometries in all chains
    util::ShPtrVector< SSEGeometry> ProteinModel::GetSSEGeometries() const
    {
      // initialize vector of geometries
      util::ShPtrVector< SSEGeometry> geometry_vector;

      // iterate over the chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator itr( m_Chains.Begin()), itr_end( m_Chains.End());
        itr != itr_end; ++itr
      )
      {
        // pushback the geometries from this chain
        geometry_vector.Append( ( *itr)->GetSSEGeometries());
      }
      // end
      return geometry_vector;
    }

    //! @brief returns ShPtrVector of all SSE fragments in all chains
    //! @return ShPtrVector of all SSE fragments in all chains
    util::ShPtrVector< SSEGeometryInterface> ProteinModel::GetFragments() const
     {
       // initialize vector of geometries
       util::ShPtrVector< SSEGeometryInterface> geometry_vector;

       // iterate over SSEs and add fragments to geometry vector
       for
       (
         util::ShPtrVector< Chain>::const_iterator itr( m_Chains.Begin()), itr_end( m_Chains.End());
         itr != itr_end; ++itr
       )
       {
         util::SiPtrVector< const SSE> sses( ( *itr)->GetSSEs());
         for
         (
             util::SiPtrVector< const SSE>::const_iterator sse_itr( sses.Begin()), sse_itr_end( sses.End());
             sse_itr != sse_itr_end; sse_itr++
         )
         {
           geometry_vector.Append( ( *sse_itr)->GetFragments());
         }
       }
       // end
       return geometry_vector;
     }

    //! @brief returns all SSEs in Chains in a single Domain
    //! @return all SSEs in Chains in a single Domain
    Domain ProteinModel::GetSSEsAsDomain() const
    {
      // initialize domain to return
      Domain this_domain;

      //loop over all Chaiins
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // insert the domain
        this_domain.Insert( ( *chain_itr)->GetData());
      }

      // end
      return this_domain;
    }

    //! @brief returns all SSEs of SS_TYPE in Chains in a single Domain
    //! @param SS_TYPE SSType of interest
    //! @return all SSEs of specified SS_TYPE in Chains in a single Domain
    Domain ProteinModel::GetSSEsAsDomain( const biol::SSType &SS_TYPE) const
    {
      // initialize domain to return
      Domain this_domain;

      //loop over all Chaiins
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // iterate over all the SSEs in this chain
        for
        (
          storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
            sse_itr( ( *chain_itr)->GetData().Begin()), sse_itr_end( ( *chain_itr)->GetData().End());
          sse_itr != sse_itr_end;
          ++sse_itr
        )
        {
          // if the type is correct
          if( ( *sse_itr)->GetType() == SS_TYPE)
          {
            // insert into domain
            this_domain.Insert( *sse_itr);
          }
        }
      }

      // end
      return this_domain;
    }

    //! @brief find and to return the ShPtr for the given SSE
    //! @param SSE_TO_SEARCH SSE of interest
    //! @return ShPtr to corresponding SSE, otherwise an empty ShPtr
    const util::ShPtr< SSE> &ProteinModel::FindSSE( const SSE &SSE_TO_SEARCH) const
    {
      // static undefined SSE ptr
      static const util::ShPtr< SSE> s_undefined_sse_ptr;

      //iterate over all chains, and find the right Chain matching sse's chain id
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()),
          chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        //if matching chain id
        if( ( *chain_itr)->GetChainID() == SSE_TO_SEARCH.GetChainID())
        {
          // find the SSE in the chain and return it
          return ( *chain_itr)->FindSSE( SSE_TO_SEARCH);
        }
      }

      // if this point is reached then no chain with matching chain id is found
      return s_undefined_sse_ptr;
    }

    //! @brief returns concatenated vector of all amino acids in all sses in all chains(excludes amino acids in loops)
    //! @return concatenated vector of all amino acids in all sses in all chains(excludes amino acids in loops)
    util::SiPtrVector< const biol::AABase> ProteinModel::GetAminoAcids() const
    {
      util::SiPtrVector< const biol::AABase> amino_acids;
      amino_acids.AllocateMemory( GetNumberAAs());

      //loop over all SSElements
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        amino_acids.Append( ( *chain_itr)->GetAminoAcids());
      }

      return amino_acids;
    }

    //! @brief returns all atoms in a SiPtrVector
    //! @return all atoms in a SiPtrVector
    util::SiPtrVector< const biol::Atom> ProteinModel::GetAtoms() const
    {
      util::SiPtrVector< const biol::Atom> atoms;

      //loop over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        atoms.Append( ( *chain_itr)->GetAtoms());
      }

      return atoms;
    }

    //! @brief returns all atoms of specified types in a SiPtrVector
    //! @param ATOM_TYPES Set of AtomTypes of interest
    //! @return all atoms of specified types in a SiPtrVector
    util::SiPtrVector< const biol::Atom> ProteinModel::GetAtoms
    (
      const storage::Set< biol::AtomType> &ATOM_TYPES
    ) const
    {
      // util::SiPtrVector of atoms
      util::SiPtrVector< const biol::Atom> atoms;

      // loop over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        atoms.Append( ( *chain_itr)->GetAtoms( ATOM_TYPES));
      }

      //return
      return atoms;
    }

    //! @brief returns coordinates for all atoms in a SiPtrVector
    //! @return coordinates for all atoms in a SiPtrVector
    util::SiPtrVector< const linal::Vector3D> ProteinModel::GetAtomCoordinates() const
    {
      //util::SiPtrVector of positions
      util::SiPtrVector< const linal::Vector3D> positions;

      //loop over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        positions.Append( ( *chain_itr)->GetAtomCoordinates());
      }

      //return
      return positions;
    }

    //! @brief returns coordinates for all atoms of specified types in a SiPtrVector
    //! @param ATOM_TYPES Set of AtomTypes of interest
    //! @return coordinates for all atoms of specified types in a SiPtrVector
    util::SiPtrVector< const linal::Vector3D> ProteinModel::GetAtomCoordinates
    (
      const storage::Set< biol::AtomType> &ATOM_TYPES
    ) const
    {
      //util::SiPtrVector of positions
      util::SiPtrVector< const linal::Vector3D> positions;

      //loop over all chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        positions.Append( ( *chain_itr)->GetAtomCoordinates( ATOM_TYPES));
      }

      //return
      return positions;
    }

    //! @brief returns defined coordinates for all atoms of specified types in a SiPtrVector
    //! @param ATOM_TYPES Set of AtomTypes of interest
    //! @return defined coordinates for all atoms of specified types in a SiPtrVector
    util::SiPtrVector< const linal::Vector3D> ProteinModel::GetDefinedAtomCoordinates
    (
      const storage::Set< biol::AtomType> &ATOM_TYPES
    ) const
    {
      // SiPtrVector that holds defined coordinates of all atoms
      util::SiPtrVector< const linal::Vector3D> defined_coordinates;

      // loop over all chains
      for
      (
        auto chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // get all atoms of ATOM_TYPE on the current chain
        util::SiPtrVector< const biol::Atom> atoms( ( *chain_itr)->GetAtoms( ATOM_TYPES));

        // loop over all atoms
        for
        (
          auto atom_itr( atoms.Begin()), atom_itr_end( atoms.End());
          atom_itr != atom_itr_end;
          ++atom_itr
        )
        {
          // only push back defined coordinates
          if( ( *atom_itr)->GetCoordinates().IsDefined())
          {
            defined_coordinates.PushBack( ( *atom_itr)->GetCoordinates());
          }
        }
      }

      // return all defined atom coordinates
      return defined_coordinates;
    }

    //! @brief returns the center of the protein model
    //! @return the center of the protein model
    linal::Vector3D ProteinModel::GetCenter() const
    {
      return coord::CenterOfMass( GetAtomCoordinates( storage::Set< biol::AtomType>( biol::GetAtomTypes().CA)), true);
    }

    //! @brief returns the center of the centers of the sses
    //! @return center of mass of centers of sses
    linal::Vector3D ProteinModel::GetCenterOfSSEs() const
    {
      // collect center of all SSEs
      const util::SiPtrVector< const SSE> all_sses( GetSSEs());

      // initialize center
      linal::Vector3D center( 0.0);

      size_t count_sse( 0);
      // iterate over all sses
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( all_sses.Begin()), sse_itr_end( all_sses.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // skip if body is undefined
        if( !( *sse_itr)->IsDefined())
        {
          continue;
        }

        center += ( *sse_itr)->GetCenter();
        ++count_sse;
      }

      //normalize
      center /= double( count_sse);

      return center;
    }

    //! @brief gives the conformations that are in this protein
    //! @return protein ensemble which is the conformations making up this protein
    const ProteinEnsemble &ProteinModel::GetConformationalEnsemble() const
    {
      static ProteinEnsemble ensemble;

      return ensemble;
    }

    //! @brief sets the conformations that are in this protein
    //! @param ENSEMBLE protein ensemble which is the conformations making up this protein
    void ProteinModel::SetConformationalEnsemble( const ProteinEnsemble &ENSEMBLE)
    {
    }

    //! @brief gives the number of amino acids in the protein
    //! @return the number of amino acids in the protein
    size_t ProteinModel::GetNumberAAs() const
    {
      // initialize size
      size_t size( 0);
      // loop over sequence to get size of protein model
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        size += ( *chain_itr)->GetNumberAAs();
      }
      return ( size);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief transforms the coordinates of the entire model with given TransformationMatrix3D
    //! @param TRANSFORMATION_MATRIX_3D TransformationMatrix3D to be applied
    void ProteinModel::Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
    {
      //loop over all chains and transform them
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        ( *chain_itr)->Transform( TRANSFORMATION_MATRIX_3D);
      }

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief translate the object along a given TRANSLATION vector
    //! @param TRANSLATION vector to be used in translation
    void ProteinModel::Translate( const linal::Vector3D &TRANSLATION)
    {
      //loop over all chains and transform them
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        ( *chain_itr)->Translate( TRANSLATION);
      }

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief rotate the object by a given RotationMatrix3D
    //! @param ROTATION_MATRIX_3D RotationMatrix3D to be used in rotation
    void ProteinModel::Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
    {
      //loop over all chains and transform them
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        ( *chain_itr)->Rotate( ROTATION_MATRIX_3D);
      }

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief adds a chain to the model
    //! @param SP_CHAIN ShPtr to Chain to be inserted
    void ProteinModel::Insert( const util::ShPtr< Chain> &SP_CHAIN)
    {
      for
      (
        util::ShPtrVector< Chain>::iterator
          chain_itr( m_Chains.Begin()),
          chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        if( ( *chain_itr)->GetChainID() == SP_CHAIN->GetChainID())
        {
          for
          (
            storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( SP_CHAIN->GetData().Begin()),
              sse_itr_end( SP_CHAIN->GetData().End());
            sse_itr != sse_itr_end;
            ++sse_itr
          )
          {
            ( *chain_itr)->Insert( *sse_itr);
          }

          // emit change signal
          m_ChangeSignal.Emit( *this);
          return;
        }
        if( ( *chain_itr)->GetChainID() > SP_CHAIN->GetChainID())
        {
          m_Chains.InsertElement( chain_itr, SP_CHAIN);

          // emit change signal
          m_ChangeSignal.Emit( *this);
          return;
        }
      }

      m_Chains.PushBack( SP_CHAIN);

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief adds a structure element to the model
    //! @brief SP_SSE ShPtr to the SSE to be inserted
    //! @return whether insertion succeeded
    bool ProteinModel::Insert( const util::ShPtr< SSE> &SP_SSE)
    {
      // iterate over all chains, and find the right Chain mathich sse's chain id
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()),
          chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // if matching chain id and sse is not already contained, insert
        if( ( *chain_itr)->GetChainID() == SP_SSE->GetChainID() && !( *chain_itr)->DoesContain( *SP_SSE))
        {
          util::ShPtr< Chain> new_chain( chain_itr->HardCopy());

          if( new_chain->Insert( SP_SSE))
          {
            ( *chain_itr) = new_chain;

            // emit change signal
            m_ChangeSignal.Emit( *this);

            return true;
          }
          else
          {
            return false;
          }
        }
      }

      // end
      BCL_MessageVrb
      (
        "could not insert SSE " + SP_SSE->GetIdentification() + ", since no matching Chain was found or overlapping sse exists"
      );
      return false;
    }

    //! @brief replaces given SSE if it was in one of the chains
    //! @param SP_SSE SSE of interest
    //! @return whether replacement succeeded
    bool ProteinModel::Replace( const util::ShPtr< SSE> &SP_SSE)
    {
      //iterate over all chains, and find the right Chain matching sse's chain id
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()),
          chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // if matching chain id and if similar sse is within chain
        if( ( *chain_itr)->GetChainID() == SP_SSE->GetChainID() && ( *chain_itr)->DoesContain( *SP_SSE))
        {
          // replace chain and sse in chain
          util::ShPtr< Chain> sp_chain_new( chain_itr->HardCopy());

          if( sp_chain_new->Replace( SP_SSE))
          {
            ( *chain_itr) = sp_chain_new;

            // emit change signal
            m_ChangeSignal.Emit( *this);

            return true;
          }
        }
      }

      //end
      BCL_MessageCrt
      (
        "fail to replace SSELEMENT, " + SP_SSE->GetIdentification() +
        " since no matching Chain found in protein model with chains " + util::Format()( GetChainIDs())
      );
      return false;
    }

    //! @brief replaces given chain if it was in the protein model
    //! @param SP_CHAIN ShPtr to the chain of interest
    //! @return whether replacement succeeded
    bool ProteinModel::Replace( const util::ShPtr< Chain> &SP_CHAIN)
    {
      // iterate over all chains to find the right chain
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin());
          chain_itr != m_Chains.End();
        ++chain_itr
      )
      {
        // find the matching chain
        if( ( *chain_itr)->GetChainID() == SP_CHAIN->GetChainID())
        {
          // replace the chain
          ( *chain_itr) = SP_CHAIN;

          // emit change signal
          m_ChangeSignal.Emit( *this);

          // return true that the replacement was successful
          return true;
        }
      }

      // return false if replacement failed
      BCL_MessageCrt
      (
        "fail to replace CHAIN, " + SP_CHAIN->GetClassIdentifier() +
        " since no matching Chain found in protein model with chains " + util::Format()( GetChainIDs())
      );
      return false;
    }

    //! @brief replaces SSEs in the protein model with the given SSE
    //! @detail SSEs in the protein model that are overlapping with the given SSE are either completely
    //! replaced or resized in order to not overlap with the given SSE
    //! @param SP_SSE SSE that is to be inserted into the protein model
    void ProteinModel::ReplaceResize( const util::ShPtr< SSE> &SP_SSE)
    {
      // determine SSEs that are overlapping with the given SSE
      const util::SiPtrList< const SSE> overlap_sses( GetOverlappingSSEs( *SP_SSE));

      // determine the neighbor SSEs of the given SSE
      storage::VectorND< 2, util::SiPtr< const SSE> > neighbors( GetNeighborSSEs( *SP_SSE));
      if( !neighbors.First().IsDefined() || !neighbors.Second().IsDefined())
      {
        return;
      }

      const SSE neighbor_n( *neighbors.First());
      const SSE neighbor_c( *neighbors.Second());

      // determine if the neighbor SSEs have to be resized
      const int seq_n_n( neighbor_n.GetFirstAA()->GetSeqID());
      const int seq_c_n( neighbor_n.GetLastAA()->GetSeqID());
      const int seq_n_new( SP_SSE->GetFirstAA()->GetSeqID());
      const int seq_c_new( SP_SSE->GetLastAA()->GetSeqID());
      const int seq_n_c( neighbor_c.GetFirstAA()->GetSeqID());
      const size_t distance_n( seq_n_new - seq_c_n);
      const size_t distance_c( seq_n_c - seq_c_new);

      ReplaceWithOverlapping( SP_SSE);

      // resize n-terminal neighbor SSE if needed
      if( distance_n > 1)
      {
        const size_t length_n( neighbor_n.GetSize() + distance_n - 1);
        const biol::AASequence &sequence( *GetChain( neighbor_n.GetChainID())->GetSequence());
        const util::ShPtr< SSE> sp_new_n
        (
          new SSE( sequence.SubSequence( seq_n_n - 1, length_n), neighbor_c.GetType())
        );
        ReplaceWithOverlapping( sp_new_n);
      }
      else if( distance_n < 1)
      {
        BCL_MessageTop( "Shrinking n-terminal SSE.");
      }

      // resize c-terminal neighbor SSE if needed
      if( distance_c > 1)
      {
        const size_t length_c( neighbor_c.GetSize() + distance_c - 1);
        BCL_MessageTop
        (
          "Extending c-terminal SSE to " + util::Format()( seq_c_new + 1) + "-" +
          util::Format()( seq_c_new + length_c)
        );
        const biol::AASequence &sequence( *GetChain( neighbor_c.GetChainID())->GetSequence());
        const util::ShPtr< SSE> sp_new_c
        (
          new SSE( sequence.SubSequence( seq_c_new, length_c), neighbor_c.GetType())
        );
        ReplaceWithOverlapping( sp_new_c);
      }
      else if( distance_c < 1)
      {
        BCL_MessageTop( "Shrinking c-terminal SSE.");
      }
    }

    //! @brief replaces vector of SSEs in the chains
    //! @brief SSELEMENTS ShPtrVector of SSEs to be replaced
    //! @return whether replacement succeeded
    bool ProteinModel::Replace( const util::ShPtrVector< SSE> &SSELEMENTS)
    {
      //iterate over all given sses and replace them individually
      for
      (
        util::ShPtrVector< SSE>::const_iterator sse_itr( SSELEMENTS.Begin()),
          sse_itr_end( SSELEMENTS.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // try to replace single given sse
        if( !Replace( *sse_itr))
        {
          BCL_Exit( "unable to replace sselement", -1);
          return false;
        }
      }

      // no onchange signal emission necessary, since the Replace already emits

      //end
      return true;
    }

    //! @brief replace all SSEs that overlap with SP_SSE with SP_SSE
    //! @param SP_SSE ShPtr to SSE to be inserted
    //! @return whether replacement succeeded
    bool ProteinModel::ReplaceWithOverlapping( const util::ShPtr< SSE> &SP_SSE)
    {
      //iterate over all chains, and find the right Chain matching sse's chain id
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()),
          chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // if chain ids match and chain contains overlapping sses to SP_SSE, replace chain and sse in chain
        if
        (
          ( *chain_itr)->GetChainID() == SP_SSE->GetChainID() &&
          ( *chain_itr)->DoesContainOverlapping( *SP_SSE)
        )
        {
          util::ShPtr< Chain> sp_chain_new( ( *chain_itr)->Clone());
          ( *chain_itr) = sp_chain_new;

          // emit change signal
          m_ChangeSignal.Emit( *this);

          return sp_chain_new->ReplaceWithOverlapping( SP_SSE);
        }
      }

      // end
      BCL_MessageCrt
      (
        "fail to replace SSELEMENT " + SP_SSE->GetIdentification() +
        ", since no matching Chain or overlapping sse was found"
      );

      return false;
    }

    //! @brief replaces given set of SSEs in the chains
    //! @param SSELEMENTS set of SSEs to be replaced
    //! @return whether replacement succeeded
    bool ProteinModel::Replace( const storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> &SSELEMENTS)
    {
      //iterate over all given sses and replace them individually
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( SSELEMENTS.Begin()),
          sse_itr_end( SSELEMENTS.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        //try to replace single given sse
        if( !Replace( *sse_itr))
        {
          BCL_Exit( "unable to replace sselement", -1);
          return false;
        }
      }

      // no onchange signal emission necessary, since the Replace already emits

      //end
      return true;
    }

    //! @brief remove given SSE
    //! @brief THIS_SSE SSE of interest
    //! @return whether removal succeeded
    bool ProteinModel::Remove( const SSE &THIS_SSE)
    {
      //iterate over all chains, and find the right Chain matching sse's chain id
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // if matching chain id and if similar sse is within chain
        if( ( *chain_itr)->GetChainID() == THIS_SSE.GetChainID() && ( *chain_itr)->DoesContain( THIS_SSE))
        {
          util::ShPtr< Chain> new_chain( chain_itr->HardCopy());

          if( new_chain->Remove( THIS_SSE))
          {
            // replace chain
            ( *chain_itr) = new_chain;

            // emit change signal
            m_ChangeSignal.Emit( *this);

            return true;
          }
          else
          {
            return false;
          }
        }
      }

      //end
      BCL_MessageCrt
      (
        "fail to remove SSELEMENT: " + THIS_SSE.GetIdentification() + ", since no matching SSE found in protein model"
      );
      return false;
    }

    //! @brief sets all positions of all SSEs to ideal conformation and superimpose them with prior coordinates
    //! depending on flag KEEP_POSITION
    //! @param KEEP_POSITION flag to determine superimposition with prior coordinates
    void ProteinModel::SetToIdealConformation( const bool KEEP_POSITION)
    {
      //iterate over all chains
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        //set each chain to ideal conformation
        ( *chain_itr)->SetToIdealConformation( KEEP_POSITION);
      }

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief chop all sselements of that model in pieces of the given size vector MIN_SSE_LENGTHS
    //! @param MIN_SSE_LENGTHS minimal sizes for chopping for each SSType
    void ProteinModel::ChopSSEs( const storage::VectorND< 3, size_t> &MIN_SSE_LENGTHS)
    {
      //instantiate new vector to chopped elements
      util::ShPtrVector< SSE> new_model;

      //iterate over all sselements
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // chop sses for this chain
        ( *chain_itr)->ChopSSEs( MIN_SSE_LENGTHS);
      }

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief checks whether the given SSE is already in the model or is overlapping with one
    //! @param THIS_SSE SSE of interest
    //! @return whether the given SSE is already in the model or is overlapping with one
    bool ProteinModel::DoesContain( const SSE &THIS_SSE) const
    {
      //iterate over all sselements
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        if( ( *chain_itr)->GetChainID() == THIS_SSE.GetChainID() && ( *chain_itr)->DoesContain( THIS_SSE))
        {
          return true;
        };
      }

      return false;
    }

    //! @brief returns pairs of sses that have short loops (at most MAX_LOOP_LENGTH) between each other
    //! @param MAX_LOOP_LENGTH maximum loop length that is defined as short loop
    //! @return list of pairs of sses that have short loops (at most MAX_LOOP_LENGTH) between
    //! @return each other
    storage::List< storage::VectorND< 2, util::SiPtr< const SSE> > > ProteinModel::GetSSEsWithShortLoops
    (
      const size_t MAX_LOOP_LENGTH
    ) const
    {
      // initialize list of pair of sses to be returned
      storage::List< storage::VectorND< 2, util::SiPtr< const SSE> > > sse_list;

      // iterate over chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // append the list of sses with short loops for this chain
        sse_list.Append( ( *chain_itr)->GetSSEsWithShortLoops( MAX_LOOP_LENGTH));
      }
      // end
      return sse_list;
    }

    //! @brief returns SiPtrList of sses that have short loops ( at most MAX_LOOP_LENGTH) to provided TARGET_SSE
    //! @param TARGET_SSE SSE for which short loop connecting SSEs are being search
    //! @param MAX_LOOP_LENGTH maximum loop length that is defined as short loop
    //! @return SiPtrList of sses that have short loops to provided TARGET_SSE
    util::SiPtrList< const SSE> ProteinModel::GetSSEsWithShortLoops
    (
      const SSE &TARGET_SSE,
      const size_t MAX_LOOP_LENGTH
    ) const
    {
      // get the chain with the same chain ID as TARGET_SSE
      util::ShPtr< Chain> chain_ptr( GetChain( TARGET_SSE.GetChainID()));

      // if chain was not found
      if( chain_ptr.IsDefined())
      {
        // return this chain overlapping sses
        return chain_ptr->GetSSEsWithShortLoops( TARGET_SSE, MAX_LOOP_LENGTH);
      }

      // otherwise if chain was not found warn user
      BCL_MessageStd
      (
        "No sses with short loops to given list of sses are found in the protein model!"
      );

      // return empty list
      return util::SiPtrList< const SSE>();
    }

    //! @brief selects from provided SSE_LIST, sses that have short loops ( <=MAX_LOOP_LENGTH) to SSEs in ProteinModel
    //! @param SSE_LIST list of SSEs on which the selection will be done
    //! @param MAX_LOOP_LENGTH maximum loop length that is defined as short loop
    //! @return Subset of SSE_LIST that has short loops to SSEs in this ProteinModel
    util::SiPtrList< const SSE> ProteinModel::GetSSEsWithShortLoops
    (
      const util::SiPtrList< const SSE> &SSE_LIST,
      const size_t MAX_LOOP_LENGTH
    ) const
    {
      // initialize the list to be returned
      util::SiPtrList< const SSE> eligible_sses;

      // iterate over every SSE in this list
      for
      (
        util::SiPtrList< const SSE>::const_iterator sse_itr( SSE_LIST.Begin()), sse_itr_end( SSE_LIST.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if the associated chain has at least 1 sses with a short loop to SSE behind sse_itr
        if( !( GetChain( ( *sse_itr)->GetChainID())->GetSSEsWithShortLoops( **sse_itr, MAX_LOOP_LENGTH)).IsEmpty())
        {
          // insert this sse into eligible_sses
          eligible_sses.PushBack( *sse_itr);
        }
      }

      // return
      return eligible_sses;
    };

    //! @brief returns the SSE before and SSE after given TARGET_SSE in this ProteinModel
    //! @param TARGET_SSE SSE of interest
    //! @return the SSE before and SSE after given TARGET_SSE in this ProteinModel
    storage::VectorND< 2, util::SiPtr< const SSE> > ProteinModel::GetNeighborSSEs
    (
      const SSE &TARGET_SSE
    ) const
    {
      // initialize the list to be returned
      storage::VectorND< 2, util::SiPtr< const SSE> > neighbor_sses;

      // get the chain with the same chain ID as TARGET_SSE
      util::ShPtr< Chain> chain_ptr( GetChain( TARGET_SSE.GetChainID()));

      // if chain is found
      if( chain_ptr.IsDefined())
      {
        // return the neighbor sses from this chain
        return chain_ptr->GetNeighborSSEs( TARGET_SSE);
      }

      // otherwise if chain was not found warn user
      BCL_MessageStd
      (
        "No neighbor SSEs are found for the given SSE, since ProteinModel does not have the specified chain!"
        + std::string( 1, TARGET_SSE.GetChainID())
      );

      // return
      return neighbor_sses;
    }

    //! @brief returns SSEs in this ProteinModel which overlap with given TARGET_SSE
    //! @brief TARGET_SSE SSE for which overlaps are going to be searched
    //! @return SSEs in this ProteinModel which overlap with given TARGET_SSE
    util::SiPtrList< const SSE> ProteinModel::GetOverlappingSSEs
    (
      const SSE &TARGET_SSE
    ) const
    {
      // return the associated chains overlapping sses with this one
      return GetChain( TARGET_SSE.GetChainID())->GetOverlappingSSEs( TARGET_SSE);
    }

    //! @brief returns SSEs in this ProteinModel which overlap with one or more SSEs in the given SSE_LIST
    //! @brief SSE_LIST SiPtrList of SSEs for which overlaps are going to be searched
    //! @return SSEs in this ProteinModel which overlap with one or more SSEs in the given SSE_LIST
    util::SiPtrList< const SSE> ProteinModel::GetOverlappingSSEs
    (
      const util::SiPtrList< const SSE> &SSE_LIST
    ) const
    {
      // initialize the list to be returned
      util::SiPtrList< const SSE> eligible_sses;

      // iterate over every SSE in this list
      for
      (
        util::SiPtrList< const SSE>::const_iterator sse_itr( SSE_LIST.Begin()), sse_itr_end( SSE_LIST.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // get overlapping sses for this sse
        util::SiPtrList< const SSE> overlapping_sses( GetOverlappingSSEs( **sse_itr));

        // if any were found
        if( !overlapping_sses.IsEmpty())
        {
          // pushback overlapping sses in the model for this sse into the list
          eligible_sses.Append( GetOverlappingSSEs( **sse_itr));
        }
      }

      // return
      return eligible_sses;
    }

    //! @brief AddLoops generates loop SSEs for the protein model and assigns them zero coordinates
    //! @param UNDEFINED_COORDINATES create loop with undefined coordinates, or with coordinates form the member sequence
    //! @param MERGE_CONSECUTIVE_SSES merge consecutive sses of given type
    //! @param SS_TYPE hte sstype of the sses to be merged
    void ProteinModel::AddLoops
    (
      const bool UNDEFINED_COORDINATES,
      const bool MERGE_CONSECUTIVE_SSES,
      const biol::SSType &SS_TYPE
    )
    {
      // iterate through all chains
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        ( *chain_itr)->AddLoops( UNDEFINED_COORDINATES, MERGE_CONSECUTIVE_SSES, SS_TYPE);
      }
    }

    //! @brief filters the current protein model by given minimum SSE sizes
    //! @param MIN_SSE_SIZES minimum SSE sizes to filter the model by
    void ProteinModel::FilterByMinSSESizes
    (
      const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES
    )
    {
      // iterate through all chains
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // make a clone of the chain and call the function
        ( *chain_itr) = util::ShPtr< Chain>( ( *chain_itr)->Clone());
        ( *chain_itr)->FilterByMinSSESizes( MIN_SSE_SIZES);
      }

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief join following ( progressing sequence id) SSEs of given SS_TYPE into one SSE
    //! @param SS_TYPE SSType of interest
    //! @param TEST_PEPTIDE_BOND join only, if SSEs are connected by peptide bond
    void ProteinModel::Join( const biol::SSType &SS_TYPE, const bool TEST_PEPTIDE_BOND)
    {
      // iterate through all chains
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // make a copy of the chain and call the function
        ( *chain_itr) = util::ShPtr< Chain>( ( *chain_itr)->HardCopy());
        ( *chain_itr)->Join( SS_TYPE, TEST_PEPTIDE_BOND);
      }

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief let the aadata of the each sse point to the corresponding data in the chain - determined by pdbID
    void ProteinModel::ConnectSSEToChainData()
    {
      // iterate through the chains
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        ( *chain_itr)->ConnectSSEToChainData();
      }

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief Replace SSEs with those drawn from the pool
    void ProteinModel::AdoptSSEsMaintainCoordinates( const util::SiPtrVector< const SSE> &SSES)
    {
      storage::Map< char, util::SiPtrVector< const SSE> > chain_to_sses;
      for( auto itr_sses( SSES.Begin()), itr_sses_end( SSES.End()); itr_sses != itr_sses_end; ++itr_sses)
      {
        chain_to_sses[ ( *itr_sses)->GetChainID()].PushBack( *itr_sses);
      }

      // iterate through the chains
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        ( *chain_itr)->AdoptSSEsMaintainCoordinates( chain_to_sses[ ( *chain_itr)->GetChainID()]);
      }

      // emit change signal
      m_ChangeSignal.Emit( *this);
    }

    //! @brief Get SSE hash string to aid in identifying similar proteins
    std::string ProteinModel::GetSSEHashString() const
    {
      std::string hash;
      // iterate through the chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator chain_itr( m_Chains.Begin()), chain_itr_end( m_Chains.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        hash += ( *chain_itr)->GetChainID();
        hash += '{';
        hash += ( *chain_itr)->GetSSEHashString();
        hash += '}';
      }
      return hash;
    }

    //! @brief calculates all pairwise interactions of amino acids within SSE fragments
    //! @param SIZE number of amino acids in the chain
    //! @return matrix of pairwise interactions of amino acids within SSE fragments
    const linal::Matrix< double> ProteinModel::CalculateFragmentInteractions() const
    {
      // get size of matrix
      const size_t size( GetNumberAAs());

      // initialize matrix
      linal::Matrix< double> matrix( size, size);

      // get fragments
      util::ShPtrVector< SSEGeometryInterface> fragments( GetFragments());

      // criteria to determine whether or not two fragments are in contact
      const math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> &PACKING_CRITERIA( *CollectorTopologyCombined::GetPackingCriteria());

      //get ids of fragments
      storage::Vector< storage::Pair< int, int> > fragment_ids( GetFragmentIDs());

      // get sses
      const util::SiPtrVector< const SSE> sses( GetSSEs());

      // initialize weight of fragment interaction
      double interaction_weight( 0);

      //iterate over ids to fill in row of table

      // initialize fragment vector for each sse
      util::ShPtrVector< SSEGeometryInterface> sse_fragments;

      for
      (
        util::ShPtrVector< SSEGeometryInterface>::const_iterator frag_itr( fragments.Begin()),
        frag_itr_end( fragments.End()); frag_itr != frag_itr_end; ++frag_itr
      )
      {
        for
        (
          util::ShPtrVector< SSEGeometryInterface>::const_iterator frag_itr_2( fragments.Begin() + 1),
          frag_itr_2_end( fragments.End()); frag_itr_2 != frag_itr_2_end; ++frag_itr_2
        )
        {
          //get packing between the two fagments
          SSEGeometryPacking this_packing( ( *GetSSEGeometryPackingPickers().e_BestInteractionWeight)->operator()( **frag_itr, **frag_itr_2));
          if( PACKING_CRITERIA( this_packing))
          {
            //fill in matrix with interaction weight as metric of packing score
            interaction_weight = this_packing.GetInteractionWeight();
            matrix( ( *frag_itr_2)->GetCentralAA(), ( *frag_itr)->GetCentralAA()) = interaction_weight;
          }
        }
      }

      return matrix;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief assignment operator
    //! @param PROTEIN_MODEL ProteinModel to be copied
    //! @return This model after all members are assigned to values from PROTEIN_MODEL
    ProteinModel &ProteinModel::operator =( const ProteinModel &PROTEIN_MODEL)
    {
      // update members
      m_Chains = PROTEIN_MODEL.m_Chains;
      m_ProteinModelData = PROTEIN_MODEL.m_ProteinModelData;

      // emit change signal
      m_ChangeSignal.Emit( *this);

      // end
      return *this;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read ProteinModel from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModel::Read( std::istream &ISTREAM)
    {
      //read data
      io::Serialize::Read( m_Chains, ISTREAM);
      io::Serialize::Read( m_ProteinModelData, ISTREAM);

      // emit change signal
      m_ChangeSignal.Emit( *this);

      //return
      return ISTREAM;
    }

    //! @brief write ProteinModel to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &ProteinModel::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      //write data
      io::Serialize::Write( m_Chains, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ProteinModelData, OSTREAM, INDENT);

      //return
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_model_data.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  ///////////
  // enums //
  ///////////

    //! @brief conversion to a string from a Type
    //! @param TYPE the type to get a string for
    //! @return a string representing that type
    const std::string &ProteinModelData::GetTypeName( const Type &TYPE)
    {
      static const std::string s_descriptors[ s_NumberTypes + 1] =
      {
        "pool",
        "native_model",
        "native_filtered_model",
        "sasa",
        "multiplier",
        "loop_domain_locators",
        "pdb_file",
        "identification",
        "membrane",
        "slicelist_manager",
        "undefined",
        GetStaticClassName< ProteinModelData>()
      };
      return s_descriptors[ size_t( TYPE)];
    }

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelData::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelData())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelData::ProteinModelData() :
      m_DataMap()
    {
      m_DataMap[ e_Undefined] = util::ShPtr< util::ObjectInterface>();
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelData
    ProteinModelData *ProteinModelData::Clone() const
    {
      return new ProteinModelData( *this);
    }

    //! @brief hardcopy all member shared pointers
    //! @return pointer to hardcopied data
    util::ShPtr< ProteinModelData> ProteinModelData::HardCopy() const
    {
      // initialize new pmd
      util::ShPtr< ProteinModelData> new_pmd( new ProteinModelData());

      // iterate over the map
      for
      (
        storage::Map< TypeEnum, util::ShPtr< util::ObjectInterface> >::const_iterator itr( m_DataMap.Begin()),
          itr_end( m_DataMap.End());
        itr != itr_end; ++itr
      )
      {
        // add the hardcopied data
        if( itr->second.IsDefined())
        {
          new_pmd->Insert( itr->first, itr->second.HardCopy());
        }
      }

      // end
      return new_pmd;
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelData::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief insert data to the map
    //! @param KEY the identifier for the data
    //! @param SP_DATA ShPtr to the ObjectInterface derived data
    //! @return true, if data with that key did not exist and was inserted, false otherwise
    bool ProteinModelData::Insert( const Type &KEY, const util::ShPtr< util::ObjectInterface> &SP_DATA)
    {
      // check if key exists
      if( m_DataMap.Find( KEY) != m_DataMap.End())
      {
        return false;
      }

      // set the data
      m_DataMap[ KEY] = SP_DATA;

      // success
      return true;
    }

    //! @brief insert data from another object into the map
    //! @param PROTEIN_MODEL_DATA object containing data to be added
    //! @param REPLACE if true, data of the same key is replaced
    void ProteinModelData::Insert( const ProteinModelData &PROTEIN_MODEL_DATA, const bool REPLACE)
    {
      // iterate over the map
      for
      (
        storage::Map< TypeEnum, util::ShPtr< util::ObjectInterface> >::const_iterator
          itr( PROTEIN_MODEL_DATA.m_DataMap.Begin()),
          itr_end( PROTEIN_MODEL_DATA.m_DataMap.End());
        itr != itr_end; ++itr
      )
      {
        // if the insert fails and it should be replaced
        if( !Insert( itr->first, itr->second) && REPLACE)
        {
          Replace( itr->first, itr->second);
        }
      }
    }

    //! @brief replace data in the map
    //! @param KEY the identifier for the data
    //! @param SP_DATA ShPtr to the ObjectInterface derived data
    //! @return true if data with that key existed and was replaced, false otherwise
    bool ProteinModelData::Replace( const Type &KEY, const util::ShPtr< util::ObjectInterface> &SP_DATA)
    {
      // check if key exists
      if( m_DataMap.Find( KEY) == m_DataMap.End())
      {
        return false;
      }

      // set the data
      m_DataMap[ KEY] = SP_DATA;

      // success
      return true;
    }

    //! @brief access the data with a key
    //! @param KEY the key for the data
    //! @return ShPtr to the data, undefined ShPtr returned if there is no data stored with the given key
    const util::ShPtr< util::ObjectInterface> &ProteinModelData::GetData( const Type &KEY) const
    {
      // find entry for KEY
      const storage::Map< TypeEnum, util::ShPtr< util::ObjectInterface> >::const_iterator itr( m_DataMap.Find( KEY));

      // check if key exists
      if( itr == m_DataMap.End())
      {
        return m_DataMap.Find( e_Undefined)->second;
      }

      // return the data
      return itr->second;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelData::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_DataMap, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelData::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_DataMap, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_model_inverter.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_aa_sequence_factory.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelInverter::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelInverter())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from whether to use cache and a cache size
    //! @param USE_CACHE whether to use cache, by default it is set to false
    //! @param MODEL_CACHE_SIZE Maximum number of models to keep in cache, default is 2
    //! @param COIL_CACHE_SIZE Maximum number of coils to keep in cache, default is 30
    ProteinModelInverter::ProteinModelInverter
    (
      const bool USE_CACHE,
      const size_t MODEL_CACHE_SIZE,
      const size_t COIL_CACHE_SIZE
    ) :
      m_UseCache( USE_CACHE),
      m_ModelCacheSize( MODEL_CACHE_SIZE),
      m_CoilCacheSize( COIL_CACHE_SIZE),
      m_ExtendedSequences(),
      m_Coils(),
      m_InvertedModels()
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelInverter
    ProteinModelInverter *ProteinModelInverter::Clone() const
    {
      return new ProteinModelInverter( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelInverter::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief generates the description string for a given chain
    //! @param CHAIN Chain of interest
    //! @return description string
    std::string ProteinModelInverter::GenerateDescription( const Chain &CHAIN)
    {
      // initialize string with the address of the sequence
      std::string description( util::Format()( CHAIN.GetSequence().GetPointer()));

      // static variable to hold valid SSTypes set
      static const storage::Set< biol::SSType> valid_types( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND);

      // get SSEs
      const util::SiPtrVector< const SSE> sses( CHAIN.GetSSEs( valid_types));

      // iterate over chains
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( sses.Begin()), sse_itr_end( sses.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // generate description for chain
        description += "_" + util::Format()( ( *sse_itr)->GetFirstAA()->GetSeqID()) +
                       "_" + util::Format()( ( *sse_itr)->GetLastAA()->GetSeqID());
      }

      // end
      return description;
    }

    //! @brief generates the description string for a given model
    //! @param MODEL Model of interest
    //! @return description string
    std::string ProteinModelInverter::GenerateDescription( const ProteinModel &MODEL)
    {
      // initialize string
      std::string description;

      // iterate over chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator
          chain_itr( MODEL.GetChains().Begin()), chain_itr_end( MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // generate description for chain
        description += GenerateDescription( **chain_itr);
      }

      // end
      return description;
    }

    //! @brief returns whether any extended loop with the given begin and end SeqIDs exist for the given AASequence
    //! @param SP_SEQUENCE ShPtr to AASequence of interest
    //! @param BEGIN_SEQ_ID seqid for the first amino acid
    //! @param END_SEQ_ID seqid for the last amino acid
    //! @return whether any extended loop with the given begin and end SeqIDs exist for the given AASequence
    bool ProteinModelInverter::DoesContainCoil
    (
      const util::ShPtr< biol::AASequence> &SP_SEQUENCE,
      const size_t BEGIN_SEQ_ID,
      const size_t END_SEQ_ID
    ) const
    {
      // search for the sequence
      storage::Map< util::ShPtr< biol::AASequence>, util::ShPtrList< SSE> >::const_iterator seq_itr
      (
        m_Coils.Find( SP_SEQUENCE)
      );

      // if not found
      if( seq_itr == m_Coils.End())
      {
        return false;
      }

      // if sequence is found, then search and return if the SSE is found
      return
        std::find_if
        (
          seq_itr->second.Begin(),
          seq_itr->second.End(),
          SSECompareByIdentity( BEGIN_SEQ_ID, END_SEQ_ID, SP_SEQUENCE->GetChainID(), biol::GetSSTypes().COIL)
        ) != seq_itr->second.End();
    }

    //! @brief reset the cached storage
    void ProteinModelInverter::Reset()
    {
      // reset the members
      m_ExtendedSequences.Reset();
      m_Coils.Reset();
      m_InvertedModels.Reset();
    }

  ////////////////
  // operations //
  ///////////////

    //! @brief return inverted model for a given ProteinModel
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return inverted ProteinModel
    util::ShPtr< ProteinModel> ProteinModelInverter::GetInvertedModel( const ProteinModel &PROTEIN_MODEL) const
    {
      // if cache is not used
      if( !m_UseCache)
      {
        return ConstructInvertedModel( PROTEIN_MODEL);
      }
      // otherwise generate model with cache
      else
      {
        return GetInvertedModelFromCache( PROTEIN_MODEL);
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelInverter::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_UseCache, ISTREAM);
      io::Serialize::Read( m_ModelCacheSize, ISTREAM);
      io::Serialize::Read( m_CoilCacheSize, ISTREAM);
      // do not read other data members since they should be regenerated
      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelInverter::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_UseCache, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ModelCacheSize, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_CoilCacheSize, OSTREAM, INDENT);
      // do not write other data members since they can be regenerated
      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief get a cached coil using begin seqid and end seqid
    //! @param SP_SEQUENCE ShPtr to AASequence of the chain inverted
    //! @param BEGIN_SEQ_ID seqid for the first amino acid
    //! @param END_SEQ_ID seqid for the last amino acid
    //! @return coil with specified begin and end seqids
    util::ShPtr< SSE> ProteinModelInverter::GetCoilFromCache
    (
      const util::ShPtr< biol::AASequence> &SP_SEQUENCE,
      const size_t BEGIN_SEQ_ID,
      const size_t END_SEQ_ID
    ) const
    {
      // create reference on the cached coils
      util::ShPtrList< SSE> &coils( m_Coils[ SP_SEQUENCE]);

      // search for this SSE
      storage::List< util::ShPtr< SSE> >::const_iterator coil_itr
      (
        std::find_if
        (
          coils.Begin(),
          coils.End(),
          SSECompareByIdentity( BEGIN_SEQ_ID, END_SEQ_ID, SP_SEQUENCE->GetChainID(), biol::GetSSTypes().COIL)
        )
      );

      // if found
      if( coil_itr != coils.End())
      {
        // then return it
        return *coil_itr;
      }

      // otherwise create the coil
      util::ShPtr< SSE> sp_new_coil
      (
        new SSE
        (
          m_ExtendedSequences[ SP_SEQUENCE]->SubSequence( BEGIN_SEQ_ID - 1, END_SEQ_ID - BEGIN_SEQ_ID + 1),
          biol::GetSSTypes().COIL
        )
      );

      // insert this SSE and return it
      coils.PushBack( sp_new_coil);
      return sp_new_coil;
    }

    //! @brief returns a chain that contains extended loops containing all amino acids that are not in the given chain
    //! @param CHAIN Chain to be inverted
    //! @return inverted chain
    util::ShPtr< Chain> ProteinModelInverter::GetInvertedChainFromCache( const Chain &CHAIN) const
    {
      // create reference on the sequence of the Chain
      const util::ShPtr< biol::AASequence> &sp_sequence( CHAIN.GetSequence());

      // check to see if an extended sequence exists for this chain
      storage::Map< util::ShPtr< biol::AASequence>, util::ShPtr< biol::AASequence> >::const_iterator extended_itr
      (
        m_ExtendedSequences.Find( CHAIN.GetSequence())
      );

      // if it does not exists
      if( extended_itr == m_ExtendedSequences.End())
      {
        // construct the extended sequence and store it
        extended_itr =
          m_ExtendedSequences.Insert( std::make_pair( sp_sequence, ConstructExtendedSequence( *sp_sequence))).first;
      }

      // create a reference on the extended sequence
      const util::ShPtr< biol::AASequence> &sp_extended_sequence( extended_itr->second);

      // get SSEs
      util::SiPtrVector< const SSE> sses( CHAIN.GetSSEs());

      // initialize a vector to store the inverted SSEs
      util::ShPtrVector< SSE> coils;

      // if no SSEs meaning an empty chain
      if( sses.IsEmpty())
      {
        // insert only the sequence that covers the full sequence
        coils.PushBack( util::ShPtr< SSE>( new SSE( *sp_extended_sequence, biol::GetSSTypes().COIL)));

        // construct a chain and return it
        return util::ShPtr< Chain>( new Chain( sp_sequence, coils));
      }

      // initialize iterators
      util::SiPtrVector< const SSE>::const_iterator sse_itr( sses.Begin());
      const util::SiPtrVector< const SSE>::const_iterator sse_itr_end( sses.End());

      // initialize previous seqid
      int prev_seqid( 0);

      // iterate over the SSEs
      for( ; sse_itr != sse_itr_end; ++sse_itr)
      {
        // store the begin and end id
        const int begin_seqid( ( *sse_itr)->GetFirstAA()->GetSeqID());

        // if there is any region between this and the previous sse
        if( begin_seqid > prev_seqid + 1)
        {
          // get the inverted SSE and insert it
          coils.PushBack( GetCoilFromCache( sp_sequence, prev_seqid + 1, begin_seqid - 1));
        }
        // update prev_seqid with the seqid of the last amino acid in this SSE
        prev_seqid = ( *sse_itr)->GetLastAA()->GetSeqID();

      }

      // if theres is any loop left after the last SSE
      if( prev_seqid < sp_sequence->GetLastAA()->GetSeqID())
      {
        // insert one more SSE that covers the last prev_seqid to the end of the sequence
        coils.PushBack( GetCoilFromCache( sp_sequence, prev_seqid + 1, sp_sequence->GetSize()));
      }

      // initialize a new chain and return it
      return util::ShPtr< Chain>( new Chain( sp_sequence, coils));
    }

    //! @brief returns an inverted model
    //! @param MODEL ProteinModel to be inverted
    //! @return ShPtr to inverted model
    util::ShPtr< ProteinModel> ProteinModelInverter::GetInvertedModelFromCache( const ProteinModel &MODEL) const
    {
      // generate the string description to be used as key
      const std::string key( GenerateDescription( MODEL));

      // construct a predicate that matches the key
      storage::PairEqualFirst< std::string> predicate( key);

      // search for this predicate to see if there is already a model cached with that description
      storage::List< storage::Pair< std::string, util::ShPtr< ProteinModel> > >::const_iterator
        model_itr( std::find_if( m_InvertedModels.Begin(), m_InvertedModels.End(), predicate));

      // if found
      if( model_itr != m_InvertedModels.End())
      {
        // then return it directly
        return model_itr->Second();
      }

      // otherwise construct a new model and description pair
      storage::Pair< std::string, util::ShPtr< ProteinModel> > sp_new_key_model
      (
        key, util::ShPtr< ProteinModel>( new ProteinModel())
      );

      // iterate over chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator
          chain_itr( MODEL.GetChains().Begin()), chain_itr_end( MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // construct and insert a new chain
        sp_new_key_model.Second()->Insert( GetInvertedChainFromCache( **chain_itr));

        // create non-const reference on the coils list for this sequence
        util::ShPtrList< SSE> &coils( m_Coils[ ( *chain_itr)->GetSequence()]);

        // while the size of the coils is larger than the coil cache size
        while( coils.GetSize() > m_CoilCacheSize)
        {
          // remove the first element
          coils.PopFront();
        }
      }

      // set the protein model data
      sp_new_key_model.Second()->SetProteinModelData( MODEL.GetProteinModelData());

      // insert the new model into cache
      m_InvertedModels.PushBack( sp_new_key_model);

      // if model cache size is reached
      if( m_InvertedModels.GetSize() > m_ModelCacheSize)
      {
        // remove first element
        m_InvertedModels.PopFront();
      }

      // return new model
      return sp_new_key_model.Second();
    }

    //! @brief static function to generate an extended chain from a given AASequence
    //! @param AA_SEQUENCE AASequence of interest
    //! @return ShPtr to AASequence in the extended chain conformation
    util::ShPtr< biol::AASequence> ProteinModelInverter::ConstructExtendedSequence( const biol::AASequence &AA_SEQUENCE)
    {
      // construct transformation matrix that will move the sequence to be parallel to xy plane and at z coordinate 500
      // this is required in order to make sure for membrane protein, the inverted model is not in the membrane
      math::TransformationMatrix3D transform( coord::GetAxes().e_X, math::g_Pi / 2.0);
      transform( linal::Vector3D( 0.0, 0.0, 500.0));

      // calculate from the chain id the z transform
      linal::Vector3D z_translation( 0.0, 0.0, ( AA_SEQUENCE.GetChainID() - 'A') * 25);
      transform( z_translation);

      // hardcopy the sequence
      util::ShPtr< biol::AASequence> sp_new_sequence( AA_SEQUENCE.HardCopy());

      // idealize the sequence
      biol::AASequenceFactory::IdealizeSequence( *sp_new_sequence, biol::GetSSTypes().STRAND);

      // transform sequence
      sp_new_sequence->Transform( transform);

      // return the sequence
      return sp_new_sequence;
    }

    //! @brief static function to generate an inverted chain for a given Chain
    //! @param CHAIN Chain of interest
    //! @return ShPtr to inverted Chain
    util::ShPtr< Chain> ProteinModelInverter::ConstructInvertedChain( const Chain &CHAIN)
    {
      // create reference on the sequence
      const util::ShPtr< biol::AASequence> &sp_sequence( CHAIN.GetSequence());

      // construct extended sequence
      util::ShPtr< biol::AASequence> sp_extended_sequence( ConstructExtendedSequence( *sp_sequence));

      // get SSEs from the Chain
      util::SiPtrVector< const SSE> sses( CHAIN.GetSSEs());

      // initialize a vector to store the inverted SSEs
      util::ShPtrVector< SSE> inverted_sses;

      // if no SSEs meaning an empty chain
      if( sses.IsEmpty())
      {
        // insert only the sequence that covers the full sequence
        inverted_sses.PushBack( util::ShPtr< SSE>( new SSE( *sp_extended_sequence, biol::GetSSTypes().COIL)));

        // construct a chain and return it
        return util::ShPtr< Chain>( new Chain( sp_sequence, inverted_sses));
      }

      // initialize iterators
      util::SiPtrVector< const SSE>::const_iterator sse_itr( sses.Begin());
      const util::SiPtrVector< const SSE>::const_iterator sse_itr_end( sses.End());

      // initialize previous seqid
      int prev_seqid( 0);

      // iterate over the SSEs
      for( ; sse_itr != sse_itr_end; ++sse_itr)
      {
        // store the begin and end id
        const int begin_seqid( ( *sse_itr)->GetFirstAA()->GetSeqID());

        // if there is any region between this and the previous sse
        if( begin_seqid > prev_seqid + 1)
        {
          // construct the SSE
          util::ShPtr< SSE> sp_new_sse
          (
            new SSE
            (
              sp_extended_sequence->SubSequence( prev_seqid, begin_seqid - prev_seqid - 1), biol::GetSSTypes().COIL
            )
          );

          // insert it into the model
          inverted_sses.PushBack( sp_new_sse);
        }
        // update prev_seqid with the seqid of the last amino acid in this SSE
        prev_seqid = ( *sse_itr)->GetLastAA()->GetSeqID();
      }

      // if there is any loop left after the last SSE
      if( prev_seqid < sp_sequence->GetLastAA()->GetSeqID())
      {
        // construct the SSE
        util::ShPtr< SSE> sp_new_sse
        (
          new SSE
          (
            sp_extended_sequence->SubSequence( prev_seqid, CHAIN.GetSequence()->GetSize() - prev_seqid),
            biol::GetSSTypes().COIL
          )
        );

        // insert it into the model
        inverted_sses.PushBack( sp_new_sse);
      }

      // initialize new chain
      util::ShPtr< Chain> sp_new_chain( new Chain( sp_sequence, inverted_sses));

      // return new chain
      return sp_new_chain;
    }

    //! @brief static function to generate an inverted model for a given ProteinModel
    //! @param MODEL ProteinMOdel of interest
    //! @return ShPtr to inverted ProteinMOdel
    util::ShPtr< ProteinModel> ProteinModelInverter::ConstructInvertedModel( const ProteinModel &MODEL)
    {
      // otherwise construct a new model and description pair
      util::ShPtr< ProteinModel> sp_new_model( new ProteinModel());

      // iterate over chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator
          chain_itr( MODEL.GetChains().Begin()), chain_itr_end( MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // construct inverted chain and insert it into the model
        sp_new_model->Insert( ConstructInvertedChain( **chain_itr));
      }

      // set the protein model data
      sp_new_model->SetProteinModelData( MODEL.GetProteinModelData());

      // end
      return sp_new_model;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_model_moment_of_inertia.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_aa_neighbor_list_container.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_atom.h"
#include "coord/bcl_coord_moment_of_inertia.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelMomentOfInertia::s_Instance
    (
      GetObjectInstances().AddInstance
      (
        new ProteinModelMomentOfInertia
        (
          biol::AATypeData::e_TransferFreeEnergyEisenberg,
          util::ShPtr< AAExposureInterface>(),
          false
        )
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @param PROPERTY the property to use as weight
    //! @param EXPOSURE_WEIGHT_FUNCTION multiply each property with aa exposure
    //! @param CONSIDER_ONLY_NEGATIVE_PROPERTY consider only negative energies in calculations
    ProteinModelMomentOfInertia::ProteinModelMomentOfInertia
    (
      const biol::AATypeData::PropertyType &PROPERTY,
      const util::ShPtr< AAExposureInterface> &EXPOSURE_WEIGHT_FUNCTION,
      const bool CONSIDER_ONLY_NEGATIVE_PROPERTY
    ) :
      m_PropertyType( PROPERTY),
      m_ExposureWeight( EXPOSURE_WEIGHT_FUNCTION),
      m_ConsiderOnlyNegativeEnergies( CONSIDER_ONLY_NEGATIVE_PROPERTY)
    {
    }

    //! @brief Clone function
    //! @return pointer to new MomentOfInertia
    ProteinModelMomentOfInertia *ProteinModelMomentOfInertia::Clone() const
    {
      return new ProteinModelMomentOfInertia( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelMomentOfInertia::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief return a 4*n matrix with 3 coordinates and exposure * weight in each row (4 columns) and number amino acid rows
    //! @param PROTEIN_MODEL protein model
    //! @return 4 * n matrix
    linal::Matrix< double>
    ProteinModelMomentOfInertia::ProteinModelAAExposureToCoordinateWeightMatrix( const ProteinModel &PROTEIN_MODEL) const
    {
      // collect AANeighborLists for all amino acids in the given protein model
      const AANeighborListContainer all_aa_neighbor_list
      (
        PROTEIN_MODEL.GetAminoAcids(),
        m_ExposureWeight->GetDistanceCutoff(),
        0,
        true
      );

      // create matrix
      linal::Matrix< double> coordinate_weight_matrix( all_aa_neighbor_list.GetSize(), 4, 0.0);

      // pointer to first row
      double *row( coordinate_weight_matrix.Begin());

      // iterate over all lists in the all_aa_neighbor_list
      for
      (
        AANeighborListContainer::const_iterator
          aa_itr( all_aa_neighbor_list.Begin()), aa_itr_end( all_aa_neighbor_list.End());
        aa_itr != aa_itr_end;
        ++aa_itr, row += 4
      )
      {
        const linal::Vector3D &current_coord( aa_itr->second.GetCenterAminoAcid()->GetFirstSidechainAtom().GetCoordinates());
        if( !current_coord.IsDefined())
        {
          continue;
        }

        // coordinate
        std::copy( current_coord.Begin(), current_coord.End(), row);

        // weight
        double exposure( m_ExposureWeight->operator ()( aa_itr->second));
        if( !m_ExposureWeight->IsDirect())
        {
          exposure = 1.0 / exposure;
        }
        const double current_weight( aa_itr->second.GetCenterAminoAcid()->GetType()->GetAAProperty( m_PropertyType) * exposure);
        if( !m_ConsiderOnlyNegativeEnergies || current_weight < 0.0)
        {
          row[ 3] = current_weight;
        }
      }

      // end
      return coordinate_weight_matrix;
    }

    //! @brief return a 4*n matrix with 3 coordinates and weight in each row (4 columns) and number amino acid rows
    //! @param PROTEIN_MODEL protein model
    //! @return 4 * n matrix
    linal::Matrix< double>
    ProteinModelMomentOfInertia::ProteinModelToCoordinateWeightMatrix( const ProteinModel &PROTEIN_MODEL) const
    {
      // get all amino acids of the protein model
      const util::SiPtrVector< const biol::AABase> amino_acids( PROTEIN_MODEL.GetAminoAcids());

      // create matrix
      linal::Matrix< double> coordinate_weight_matrix( amino_acids.GetSize(), 4, 0.0);

      // pointer to first row
      double *row( coordinate_weight_matrix.Begin());

      // iterate over all amino acids
      for
      (
        util::SiPtrVector< const biol::AABase>::const_iterator itr( amino_acids.Begin()), itr_end( amino_acids.End());
        itr != itr_end;
        ++itr, row += 4
      )
      {
        const linal::Vector3D &current_coord( ( *itr)->GetFirstSidechainAtom().GetCoordinates());
        if( !current_coord.IsDefined())
        {
          continue;
        }

        // coordinate
        std::copy( current_coord.Begin(), current_coord.End(), row);

        // weight
        const double current_weight( ( *itr)->GetType()->GetAAProperty( m_PropertyType));
        if( !m_ConsiderOnlyNegativeEnergies || current_weight < 0.0)
        {
          row[ 3] = current_weight;
        }
      }

      // end
      return coordinate_weight_matrix;
    }

    //! @brief calculate transformation that translates into the center of weights and that sorts principal axes of inertia according to principal moments of inertia x - smallest, z - largest
    //! @param PROTEIN_MODEL protein model
    //! @return transformation matrix and principal moments of inertias
    storage::Pair< math::TransformationMatrix3D, linal::Vector3D>
    ProteinModelMomentOfInertia::TransformationAndMoments( const ProteinModel &PROTEIN_MODEL) const
    {
      if( m_ExposureWeight.IsDefined())
      {
        return coord::MomentOfInertia().TransformationAndMoments( ProteinModelAAExposureToCoordinateWeightMatrix( PROTEIN_MODEL));
      }
      else
      {
        return coord::MomentOfInertia().TransformationAndMoments( ProteinModelToCoordinateWeightMatrix( PROTEIN_MODEL));
      }
    }

  ///////////////
  // operators //
  ///////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelMomentOfInertia::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_PropertyType, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelMomentOfInertia::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_PropertyType, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_model_multiplier.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_transformer.h"
#include "math/bcl_math_function_cached.h"
#include "storage/bcl_storage_table.h"
#include "storage/bcl_storage_triplet.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinModelMultiplier::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelMultiplier())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelMultiplier::ProteinModelMultiplier() :
      m_ChainMultipliers(),
      m_NumberMultimers( util::GetUndefinedSize_t()),
      m_Orientation()
    {
    }

    //! @brief construct from triplets of chain ids and transformations
    //! @param TRANSFORMATIONS vector of current chain id, new chain id and transformation
    //! @param PROTEIN_MODEL original protein model
    //! @param CACHE bool whether to cache the SSE transformer
    ProteinModelMultiplier::ProteinModelMultiplier
    (
      const storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> > &TRANSFORMATIONS,
      const ProteinModel &PROTEIN_MODEL,
      const bool CACHE
    ) :
      m_ChainMultipliers(),
      m_NumberMultimers( util::GetUndefinedSize_t()),
      m_Orientation()
    {
      BuildChainMultipliers( TRANSFORMATIONS, PROTEIN_MODEL, CACHE);
    }

    //! @brief construct from an axis of symmetry and number of subunits
    //! @param SYMMETRY_AXIS axis of symmetry
    //! @param SUBUNITS number of subunits
    //! @param PROTEIN_MODEL original protein model
    //! @param CACHE bool whether to cache the SSE transformer
    ProteinModelMultiplier::ProteinModelMultiplier
    (
      const linal::Vector3D &SYMMETRY_AXIS,
      const size_t SUBUNITS,
      const ProteinModel &PROTEIN_MODEL,
      const bool CACHE
    ) :
      m_ChainMultipliers(),
      m_NumberMultimers( SUBUNITS),
      m_Orientation()
    {
      BuildChainMultipliers( GetChainData( SYMMETRY_AXIS, SUBUNITS, PROTEIN_MODEL.GetChainIDs()), PROTEIN_MODEL, CACHE);
    }

    //! @brief construct from an axis of symmetry and number of subunits
    //! @param SYMMETRY_AXIS axis of symmetry
    //! @param SUBUNITS number of subunits
    //! @param PROTEIN_MODEL original protein model
    //! @param DIHEDRAL_AXIS optional secondary rotation axis for dihedral symmetry
    //! @param CACHE bool whether to cache the SSE transformer
    ProteinModelMultiplier::ProteinModelMultiplier
    (
      const linal::Vector3D &SYMMETRY_AXIS,
      const linal::Vector3D &DIHEDRAL_AXIS,
      const size_t SUBUNITS,
      const ProteinModel &PROTEIN_MODEL,
      const bool CACHE
    ) :
      m_ChainMultipliers(),
      m_NumberMultimers( SUBUNITS),
      m_Orientation()
    {
      BuildChainMultipliers
      (
        GetChainData( SYMMETRY_AXIS, SUBUNITS, PROTEIN_MODEL.GetChainIDs(), DIHEDRAL_AXIS),
        PROTEIN_MODEL,
        CACHE
      );
    }

    //! @brief Clone function
    //! @return pointer to new ProteinModelMultiplier
    ProteinModelMultiplier *ProteinModelMultiplier::Clone() const
    {
      return new ProteinModelMultiplier( *this);
    }

    //! @brief make a copy of this multiplier that also copies the ShPtrs in the set of chain multipliers
    //! @return new copy of this
    util::ShPtr< ProteinModelMultiplier> ProteinModelMultiplier::HardCopy() const
    {
      storage::Set< util::ShPtr< ChainMultiplier>, ChainMultiplierLessThan> data_copy;
      // iterate through the set to make copies
      for
      (
        storage::Set< util::ShPtr< ChainMultiplier>, ChainMultiplierLessThan>::const_iterator
          itr( m_ChainMultipliers.Begin()), itr_end( m_ChainMultipliers.End());
        itr != itr_end;
        ++itr
      )
      {
        data_copy.Insert( ( *itr)->HardCopy());
      }
      util::ShPtr< ProteinModelMultiplier> copy( new ProteinModelMultiplier());
      copy->m_ChainMultipliers = data_copy;
      copy->m_NumberMultimers = m_NumberMultimers;
      copy->m_Orientation = m_Orientation;

      return copy;
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelMultiplier::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return the orientation of the object
    //! @return orientation
    linal::Vector3D ProteinModelMultiplier::GetAxis( const coord::Axis &AXIS) const
    {
      return m_Orientation.GetAxis( AXIS);
    }

    //! @brief gets the transformation matrices for this multiplier
    //! @return the transformation matrices for this multiplier
    storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> >
    ProteinModelMultiplier::GetTransformationMatrices() const
    {
      // initialize matrices
      storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> > matrices;

      // iterate through the chain multipliers
      for
      (
        storage::Set< util::ShPtr< ChainMultiplier>, ChainMultiplierLessThan>::const_iterator
          multiplier_itr( m_ChainMultipliers.Begin()),
          multiplier_itr_end( m_ChainMultipliers.End());
        multiplier_itr != multiplier_itr_end; ++multiplier_itr
      )
      {
        matrices.PushBack
        (
          storage::Triplet< char, char, math::TransformationMatrix3D>
          (
            ( *multiplier_itr)->GetInitialChainID(),
            ( *multiplier_itr)->GetNewChainID(),
            *( ( *multiplier_itr)->GetTransformationMatrix())
          )
        );
      }

      // end
      return matrices;
    }

    //! @brief returns the geometric center of the object
    //! @return the geometric center of the object
    linal::Vector3D ProteinModelMultiplier::GetCenter() const
    {
      return m_Orientation.GetOrigin();
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief transform the multimer
    //! @param TRANSFORMATION transformation to be applied
    void ProteinModelMultiplier::Transform( const math::TransformationMatrix3D &TRANSFORMATION)
    {
      // iterate through the chain multipliers
      for
      (
        storage::Set< util::ShPtr< ChainMultiplier>, ChainMultiplierLessThan>::const_iterator
          multiplier_itr( m_ChainMultipliers.Begin()),
          multiplier_itr_end( m_ChainMultipliers.End());
        multiplier_itr != multiplier_itr_end; ++multiplier_itr
      )
      {
        // get the current transformation
        util::ShPtr< math::TransformationMatrix3D> sp_chain_transformation
        (
          ( *multiplier_itr)->GetTransformationMatrix()
        );

        // move back to the original location, apply the chain transformation, then apply the passed transformation
        math::TransformationMatrix3D transform( math::Inverse( TRANSFORMATION));
        transform( *sp_chain_transformation);
        transform( TRANSFORMATION);
        *sp_chain_transformation = transform;
      }

      m_Orientation( TRANSFORMATION);
    }

    //! @brief translate the object along a given TRANSLATION vector
    //! @param TRANSLATION Translation to be applied
    void ProteinModelMultiplier::Translate( const linal::Vector3D &TRANSLATION)
    {
      Transform( math::TransformationMatrix3D( TRANSLATION));
    }

    //! @brief rotate the object by a given RotationMatrix3D
    //! @param ROTATION_MATRIX_3D RotationMatrix3D to be applied
    void ProteinModelMultiplier::Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
    {
      Transform( math::TransformationMatrix3D( ROTATION_MATRIX_3D));
    }

    //! @brief mapping of chain id mapping from origianl to the new chain id
    //! @return table containing the matrix number, the original chainid, the chainid it will have in the model
    storage::Table< char> ProteinModelMultiplier::ChainIDMapping() const
    {
      storage::Table< char> mapping( storage::Vector< std::string>::Create( "orig", "new"));
      size_t count( 0);

      for
      (
        storage::Set< util::ShPtr< ChainMultiplier>, ChainMultiplierLessThan>::const_iterator
          itr( m_ChainMultipliers.Begin()), itr_end( m_ChainMultipliers.End());
        itr != itr_end;
        ++itr, ++count
      )
      {
        mapping.InsertRow
        (
          util::Format()( count),
          storage::Vector< char>::Create( ( *itr)->GetInitialChainID(), ( *itr)->GetNewChainID())
        );
      }

      return mapping;
    }

    //! @brief gets a map of original chain id to target chain ids (as a string)
    //! @return map of original chain id to target chain ids (as a string)
    storage::Map< char, std::string> ProteinModelMultiplier::GetTargetChains() const
    {
      // initialize map
      storage::Map< char, std::string> chains;

      // iterate over chain multipliers
      for
      (
        storage::Set< util::ShPtr< ChainMultiplier>, ChainMultiplierLessThan>::const_iterator
          itr( m_ChainMultipliers.Begin()), itr_end( m_ChainMultipliers.End());
        itr != itr_end; ++itr
      )
      {
        // add chain id char to string
        chains[ ( *itr)->GetInitialChainID()].push_back( ( *itr)->GetNewChainID());
      }

      // end
      return chains;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief returns protein model after transforming all chains
    //! @param PROTEIN_MODEL protein model to be replicated
    //! @return protein model after transforming all chains
    ProteinModel ProteinModelMultiplier::operator ()( const ProteinModel &PROTEIN_MODEL) const
    {
      // initialize vector of chains
      util::ShPtrVector< Chain> chains;

      // iterate through the chain multipliers
      for
      (
        storage::Set< util::ShPtr< ChainMultiplier>, ChainMultiplierLessThan>::const_iterator
          multiplier_itr( m_ChainMultipliers.Begin()), multiplier_itr_end( m_ChainMultipliers.End());
        multiplier_itr != multiplier_itr_end; ++multiplier_itr
      )
      {
        // get the new chain
        util::ShPtr< Chain> new_chain
        (
          ( *multiplier_itr)->operator ()( *( PROTEIN_MODEL.GetChain( ( *multiplier_itr)->GetInitialChainID())))
        );

        // push back into the vector
        chains.PushBack( new_chain);
      }

      // sort the chains by chain id
      chains.Sort( ChainLessThan());
      ProteinModel new_model( chains);

      // set the protein model data
      util::ShPtr< ProteinModelData> pmd( PROTEIN_MODEL.GetProteinModelData()->HardCopy());
      pmd->Replace( ProteinModelData::e_Multiplier, util::ShPtr< ProteinModelMultiplier>());
      new_model.SetProteinModelData( pmd);

      // end
      return new_model;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelMultiplier::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ChainMultipliers, ISTREAM);
      io::Serialize::Read( m_NumberMultimers, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinModelMultiplier::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ChainMultipliers, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_NumberMultimers, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief wrap an SSE transformer into a FunctionCached object
    //! @param SSE_TRANSFORMER SSE transformer to be wrapped
    //! @param CACHE bool whether to cache the SSE transformer
    //! @return FunctionCached object
    util::ShPtr< util::FunctionInterface< SSE, util::ShPtr< SSE> > > ProteinModelMultiplier::WrapCacheSSETransformer
    (
      const util::ShPtr< util::FunctionInterface< SSE, util::ShPtr< SSE> > > &SSE_TRANSFORMER,
      const bool CACHE
    )
    {
      // does function need to be wrapped
      if( !CACHE)
      {
        // return the function
        return SSE_TRANSFORMER;
      }
      else
      {
        // wrap function into cache function
        util::ShPtr< math::FunctionCached< SSE, util::ShPtr< SSE> > > sp_cache_function
        (
          new math::FunctionCached< SSE, util::ShPtr< SSE> >
          (
            SSE_TRANSFORMER,
            &SSE::GetDestructorSignal
          )
        );

        // add signal handler for coordinate changes
        sp_cache_function->AddSignalHandlerForArgument( &SSE::GetCoordinateChangeSignal);

        // end
        return sp_cache_function;
      }
    }

    //! @brief converts axis, subunit, and chain id information into triplets used by the constructor
    //! @param SYMMETRY_AXIS axis of symmetry
    //! @param SUBUNITS number of subunits
    //! @param CHAIN_IDS chain ids present in original model
    //! @param DIHEDRAL_AXIS secondary rotation axis for dihedral symmetry
    //! @return transformation information for each chain multiplier
    storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> > ProteinModelMultiplier::GetChainData
    (
      const linal::Vector3D &SYMMETRY_AXIS,
      const size_t SUBUNITS,
      const std::string &CHAIN_IDS,
      const linal::Vector3D &DIHEDRAL_AXIS
    )
    {
      // make sure the number of subunits is positive
      BCL_Assert
      (
        SUBUNITS != 0 && SUBUNITS != util::GetUndefined< size_t>(),
        "Invalid number of symmetric subunits for protein model multiplier"
      );

      // initialize chain data
      storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> > chain_data;

      // make sure at least one chain id is given
      if( CHAIN_IDS.empty())
      {
        return chain_data;
      }

      // identity transformation
      const math::TransformationMatrix3D transform_identity;

      // iterate through the chains in the original protein model
      for
      (
        std::string::const_iterator chain_itr( CHAIN_IDS.begin()), chain_itr_end( CHAIN_IDS.end());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // pushback the identity transformation
        chain_data.PushBack
        (
          storage::Triplet< char, char, math::TransformationMatrix3D>( *chain_itr, *chain_itr, transform_identity)
        );
      }

      // get the new chain id
      char new_chain_id( CHAIN_IDS[ CHAIN_IDS.length() - 1]);

      // increment through the number of subunits
      for( size_t i( 1); i != SUBUNITS; ++i)
      {
        // calculate the transformation
        const math::TransformationMatrix3D transform
        (
          math::RotationMatrix3D( SYMMETRY_AXIS, double( i) * 2.0 * math::g_Pi / double( SUBUNITS))
        );

        // iterate through the original chains
        for
        (
          std::string::const_iterator chain_itr( CHAIN_IDS.begin()), chain_itr_end( CHAIN_IDS.end());
          chain_itr != chain_itr_end; ++chain_itr
        )
        {
          // increment to next available chain id
          ++new_chain_id;

          // pushback the transformation
          chain_data.PushBack
          (
            storage::Triplet< char, char, math::TransformationMatrix3D>( *chain_itr, new_chain_id, transform)
          );
        }
      }

      // if this is dihedral symmetry
      if( DIHEDRAL_AXIS != linal::Vector3D())
      {
        // copy the chain data
        storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> > orig_chain_data( chain_data);

        // initialize subunit counter
        size_t subunit( 0);

        // iterate through the transformations
        for
        (
          storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> >::const_iterator
            itr( orig_chain_data.Begin()), itr_end( orig_chain_data.End());
          itr != itr_end; ++itr, ++subunit
        )
        {
          // calculate the transformation
          math::TransformationMatrix3D transform( itr->Third());
          transform( math::RotationMatrix3D( DIHEDRAL_AXIS, math::g_Pi));

          // iterate through the original chains
          for
          (
            std::string::const_iterator chain_itr( CHAIN_IDS.begin()), chain_itr_end( CHAIN_IDS.end());
            chain_itr != chain_itr_end; ++chain_itr
          )
          {
            // increment to next available chain id
            ++new_chain_id;

            // pushback the transformation
            chain_data.PushBack
            (
              storage::Triplet< char, char, math::TransformationMatrix3D>( *chain_itr, new_chain_id, transform)
            );
          }
        }
      }

      // end
      return chain_data;
    }

    //! @brief builds the member data from the transformations and protein model
    //! @param TRANSFORMATIONS vector of current chain id, new chain id and transformation
    //! @param PROTEIN_MODEL original protein model
    //! @param CACHE bool whether to cache the SSE transformer
    void ProteinModelMultiplier::BuildChainMultipliers
    (
      const storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> > &TRANSFORMATIONS,
      const ProteinModel &PROTEIN_MODEL,
      const bool CACHE
    )
    {
      // initialize coords
      storage::Vector< linal::Vector3D> coords;

      // iterate through the vector
      for
      (
        storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> >::const_iterator
          transformation_itr( TRANSFORMATIONS.Begin()), transformation_itr_end( TRANSFORMATIONS.End());
        transformation_itr != transformation_itr_end; ++transformation_itr
      )
      {
        // get the chain
        const util::ShPtr< Chain> &sp_chain( PROTEIN_MODEL.GetChain( transformation_itr->First()));
        if( !sp_chain.IsDefined())
        {
          BCL_MessageCrt
          (
            "no such chain in model: " + std::string( 1, transformation_itr->First())
          );
          continue;
        }
        // construct the new sequence for the chain at the position of the chain
        util::ShPtr< biol::AASequence> sp_sequence
        (
          sp_chain->GetSequence()->HardCopy()
        );
        sp_sequence->SetChainID( transformation_itr->Second());
        sp_sequence->Transform( transformation_itr->Third());

        // get the transformation matrix
        const util::ShPtr< math::TransformationMatrix3D> sp_transformation_matrix( transformation_itr->Third().Clone());

        // add to coords
        coords.PushBack( transformation_itr->Third().GetOrigin());

        // create a chain multiplier and add it to the set
        m_ChainMultipliers.Insert
        (
          util::ShPtr< ChainMultiplier>
          (
            new ChainMultiplier
            (
              WrapCacheSSETransformer
              (
                util::ShPtr< util::FunctionInterface< SSE, util::ShPtr< SSE> > >
                (
                  new SSETransformer( sp_sequence, sp_transformation_matrix)
                ),
                CACHE
              ),
              transformation_itr->First(),
              sp_transformation_matrix,
              sp_sequence
            )
          )
        );
      }

      // set the orientation
      m_Orientation = math::TransformationMatrix3D( coord::CenterOfMass( util::SiPtrVector< const linal::Vector3D>( coords.Begin(), coords.End())));
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_model_with_cache.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_atom.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> ProteinModelWithCache::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelWithCache())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelWithCache::ProteinModelWithCache() :
      ProteinModel(),
      descriptor::SequenceInterface< biol::AABase>(),
      m_RequireCoordinates( false)
    {
      GetChangeSignal().Connect( this, &ProteinModelWithCache::UpdateAAPtrs);
    }

    //! @brief construct from a protein model
    //! @param MODEL protein model of interest
    //! @param REQUIRE_COORDINATES whether to exclude sspred analysis methods from AAs that lac defined coordinates
    ProteinModelWithCache::ProteinModelWithCache( const ProteinModel &MODEL, const bool &REQUIRE_COORDINATES) :
      ProteinModel( MODEL),
      descriptor::SequenceInterface< biol::AABase>(),
      m_RequireCoordinates( REQUIRE_COORDINATES)
    {
      UpdateAAPtrs( *this);
      GetChangeSignal().Connect( this, &ProteinModelWithCache::UpdateAAPtrs);
    }

    //! @brief copy constructor
    //! @param ORIGINAL model with cache to copy
    ProteinModelWithCache::ProteinModelWithCache( const ProteinModelWithCache &ORIGINAL) :
      ProteinModel( ORIGINAL),
      descriptor::SequenceInterface< biol::AABase>(),
      m_RequireCoordinates( ORIGINAL.m_RequireCoordinates)
    {
      UpdateAAPtrs( *this);
      GetChangeSignal().Connect( this, &ProteinModelWithCache::UpdateAAPtrs);
    }

    //! @brief virtual copy constructor
    //! @return pointer a new ProteinModelWithCache copied from this model
    ProteinModelWithCache *ProteinModelWithCache::Clone() const
    {
      return new ProteinModelWithCache( *this);
    }

    //! @brief hard copy constructor
    //! @return a ProteinModelWithCache with chains hard copied from that model
    ProteinModelWithCache *ProteinModelWithCache::HardCopy() const
    {
      return new ProteinModelWithCache( ProteinModel::HardCopy( *this), m_RequireCoordinates);
    }

    //! @brief empty copy constructor
    //! @return a ProteinModelWithCache that is empty
    ProteinModelWithCache *ProteinModelWithCache::Empty() const
    {
      return new ProteinModelWithCache();
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelWithCache::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return the length of the sequence in question
    //! @return the length of the sequence in question
    size_t ProteinModelWithCache::GetSize() const
    {
      return m_AAs.GetSize();
    }

    //! @brief get the iterator for the sequence
    //! @return the iterator for the sequence
    iterate::Generic< const biol::AABase> ProteinModelWithCache::GetIterator() const
    {
      return iterate::Generic< const biol::AABase>( m_AAs.Begin(), m_AAs.End());
    }

    //! @brief get a non-constant iterator for the sequence
    //! @return the non-constant iterator for the sequence
    iterate::Generic< biol::AABase> ProteinModelWithCache::GetIteratorNonConst()
    {
      return iterate::Generic< biol::AABase>( m_AAs.Begin(), m_AAs.End());
    }

    //! @brief get the protein model, represented as a molecule
    //! @note this will only be constructed if when this function is called
    const chemistry::AAFragmentComplete &ProteinModelWithCache::GetChemicalRepresentation() const
    {
      if( !m_FragmentComplete.IsDefined())
      {
        m_FragmentComplete = util::ShPtr< chemistry::AAFragmentComplete>( new chemistry::AAFragmentComplete( m_AAs, true));
      }
      return *m_FragmentComplete;
    }

    //! @brief Reset the cache
    void ProteinModelWithCache::ResetCache() const
    {
      descriptor::SequenceInterface< biol::AABase>::ResetCache();
      m_FragmentComplete = util::ShPtr< chemistry::AAFragmentComplete>();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief assignment operator
    //! @param PROTEIN_MODEL ProteinModelWithCache to be copied
    //! @return This model after all members are assigned to values from PROTEIN_MODEL
    ProteinModelWithCache &ProteinModelWithCache::operator =( const ProteinModelWithCache &PROTEIN_MODEL)
    {
      // update members
      m_RequireCoordinates = PROTEIN_MODEL.m_RequireCoordinates;
      ProteinModel::operator =( PROTEIN_MODEL);

      // end
      return *this;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read ProteinModelWithCache from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelWithCache::Read( std::istream &ISTREAM)
    {
      //read data
      ProteinModel::Read( ISTREAM);

      //return
      return ISTREAM;
    }

    //! @brief write ProteinModelWithCache to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &ProteinModelWithCache::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write protein model
      return ProteinModel::Write( OSTREAM, INDENT);
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief update amino acid pointers based on the new model
    void ProteinModelWithCache::UpdateAAPtrs( const ProteinModel &MODEL)
    {
      util::SiPtrVector< biol::AABase> new_aas;
      new_aas.AllocateMemory( m_AAs.GetSize());

      m_AAs.Reset();
      //loop over all SSElements
      for
      (
        util::ShPtrVector< Chain>::iterator chain_itr( GetChains().Begin()), chain_itr_end( GetChains().End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        new_aas.Append( ( *chain_itr)->GetSequence()->GetMembers());
      }

      // loop over AAs, remove secondary structure predictions that are invalid if the AA does not have defined coords
      if( m_RequireCoordinates)
      {
         // SS/TM analytic methods should require defined coordinates, so remove the method should have required them
         // This is kind of a work-around for the fact that 3D structural analysis methods can sometimes report values
         // even when the coordinates are missing; and even if they don't, the BCL may have inserted some default
         // prediction value for the method
        for
        (
          util::SiPtrVector< biol::AABase>::iterator itr( new_aas.Begin()), itr_end( new_aas.End());
          itr != itr_end;
          ++itr
        )
        {
          if( !( *itr)->HasDefinedCoordinates())
          {
            ( *itr)->RemoveStructureBasedSSTMInfo();
          }
        }
      }
      // Skip residues with undefined type at the beginning
      util::SiPtrVector< biol::AABase>::const_iterator itr( new_aas.Begin()), itr_end( new_aas.End());
      for( ; itr != itr_end && ( !( *itr)->GetType().IsDefined() || !( *itr)->GetType()->IsNaturalAminoAcid()); ++itr)
      {
      }
      for( ; itr != itr_end; ++itr)
      {
        if( ( *itr)->GetType().IsDefined())
        {
          m_AAs.PushBack( *itr);
        }
      }
      // prune residues at the end of the sequence with undefined residue types. These are typically expression tags
      // or, in the case of membrane proteins, dummy residues inserted by OPM
      while( !m_AAs.IsEmpty() && !m_AAs.LastElement()->GetType()->IsNaturalAminoAcid())
      {
        m_AAs.PopBack();
      }

      ResetCache();
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_model_with_mutations.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_locator_aa.h"
#include "biol/bcl_biol_atom.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> ProteinModelWithMutations::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinModelWithMutations())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    ProteinModelWithMutations::ProteinModelWithMutations()
    {
    }

    //! @brief construct from a protein model with cache
    //! @param MODEL protein model of interest
    //! @param REQUIRE_COORDINATES whether to exclude sspred analysis methods from AAs that lac defined coordinates
    //! @param MUTATIONS mutations already made to the protein
    ProteinModelWithMutations::ProteinModelWithMutations
    (
      const ProteinModel &MODEL,
      const bool &REQUIRE_COORDINATES,
      const storage::Vector< biol::Mutation> &MUTATIONS
    ) :
      ProteinModelWithCache( MODEL, REQUIRE_COORDINATES),
      m_CurrentMutations( MUTATIONS)
    {
    }

    //! @brief copy constructor
    //! @return pointer a new ProteinModelWithMutations copied from this model
    ProteinModelWithMutations *ProteinModelWithMutations::Clone() const
    {
      return new ProteinModelWithMutations( *this);
    }

    //! @brief hard copy constructor
    //! @return a ProteinModelWithMutations with chains hard copied from that model
    ProteinModelWithMutations *ProteinModelWithMutations::HardCopy() const
    {
      return new ProteinModelWithMutations( ProteinModel::HardCopy( *this), m_RequireCoordinates, m_CurrentMutations);
    }

    //! @brief empty copy constructor
    //! @return a ProteinModelWithMutations that is empty
    ProteinModelWithMutations *ProteinModelWithMutations::Empty() const
    {
      return new ProteinModelWithMutations;
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinModelWithMutations::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief test whether we have the wild type protein
    //! @return true if we have the wild type protein
    bool ProteinModelWithMutations::IsWildType() const
    {
      return m_CurrentMutations.IsEmpty();
    }

    //! @brief test whether this protein only has the given mutation
    //! @return true if this protein only has the given mutation
    bool ProteinModelWithMutations::OnlyHasMutation( const biol::Mutation &MUTATION) const
    {
      return m_CurrentMutations.GetSize() == size_t( 1) && m_CurrentMutations( 0) == MUTATION;
    }

    //! @brief get the mutations already applied to this protein
    const storage::Vector< biol::Mutation> &ProteinModelWithMutations::GetMutations() const
    {
      return m_CurrentMutations;
    }

    //! @brief Apply a mutation to the given protein
    void ProteinModelWithMutations::Mutate( const biol::Mutation &MUTATION)
    {
      ApplyMutation( MUTATION, false);
      m_CurrentMutations.PushBack( MUTATION);
      ResetCache();
    }

    //! @brief revert all mutations to wild-type
    void ProteinModelWithMutations::RevertToWildType()
    {
      for( auto itr( m_CurrentMutations.Begin()), itr_end( m_CurrentMutations.End()); itr != itr_end; ++itr)
      {
        ApplyMutation( *itr, true);
      }
      m_CurrentMutations.Reset();
      ResetCache();
    }

    //! @brief Apply a mutation to the given protein
    //! @param REVERSE whether to reverse the given mutation
    //! @note unlike Mutate, this function doesn't change m_CurrentMutations or the cache
    bool ProteinModelWithMutations::ApplyMutation( const biol::Mutation &MUTATION, const bool &REVERSE)
    {
      size_t n_applied( 0);
      const biol::AAType from_type( REVERSE ? MUTATION.GetMutantType() : MUTATION.GetNativeType());
      const biol::AAType to_type( REVERSE ? MUTATION.GetNativeType() : MUTATION.GetMutantType());

      for( auto itr( GetChains().Begin()), itr_end( GetChains().End()); itr != itr_end; ++itr)
      {
        LocatorAA locator( ( *itr)->GetChainID(), MUTATION.GetResidueNumber(), from_type, false);
        util::SiPtr< biol::AABase> base( locator.Locate( *this));
        if( base.IsDefined())
        {
          base->SetType( to_type);
          MUTATION.SetAA( *base);
        }
        base = locator.Locate( this->m_AAs);
        if( base.IsDefined())
        {
          base->SetType( to_type);
          MUTATION.SetAA( *base);
          ++n_applied;
        }
      }
      if( !n_applied)
      {
        BCL_MessageStd( "Mutation " + MUTATION.ToString() + " Could not be applied to protein");
      }
      else
      {
        this->GetChangeSignal().Emit( *this);
      }
      return n_applied;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief read ProteinModelWithCache from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinModelWithMutations::Read( std::istream &ISTREAM)
    {
      ProteinModelWithCache::Read( ISTREAM);
      io::Serialize::Read( m_CurrentMutations, ISTREAM);
      return ISTREAM;
    }

    //! @brief write ProteinModelWithCache to std::ostream
    //! @param OSTREAM output stream to write to
    //! @return output stream which was written to
    std::ostream &ProteinModelWithMutations::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      ProteinModelWithCache::Write( OSTREAM, INDENT) << '\n';
      return io::Serialize::Write( m_CurrentMutations, OSTREAM, INDENT);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_storage_file.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "command/bcl_command_command_state.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "command/bcl_command_parameter_check_enumerate.h"
#include "command/bcl_command_parameter_check_serializable.h"
#include "io/bcl_io_directory_entry.h"
#include "io/bcl_io_file.h"
#include "opti/bcl_opti_tracker.h"
#include "pdb/bcl_pdb_handler.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> ProteinStorageFile::s_Instance
    (
      GetObjectInstances().AddInstance( new ProteinStorageFile())
    );

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief InitializerType as string
    //! @param INIT_TYPE the InitializerType
    //! @return the string for the INIT_TYPE
    const std::string &ProteinStorageFile::GetInitializerTypeDescriptor( const InitializerType &INIT_TYPE)
    {
      static const std::string s_descriptors[] =
      {
        "Attach",
        "Overwrite",
        GetStaticClassName< InitializerType>()
      };
      return s_descriptors[ size_t( INIT_TYPE)];
    }

    //! @brief default storage as given in the storage flag used in the command line
    util::ShPtr< ProteinStorageFile> ProteinStorageFile::GetDefaultStorage()
    {
      return util::ShPtr< ProteinStorageFile>
             (
               new ProteinStorageFile
               (
                 GetDefaultStorageFlag()->GetParameterList()( 0)->GetValue(),
                 ProteinStorageFile::TypeEnum( GetDefaultStorageFlag()->GetParameterList()( 1)->GetValue()),
                 io::StreamBufferClass( GetDefaultStorageFlag()->GetParameterList()( 2)->GetValue())
               )
             );
    }

    //! @brief flag for default ProteinStorage
    //! @return ShPtr to flag that is used for default protein storage
    const util::ShPtr< command::FlagInterface> &ProteinStorageFile::GetDefaultStorageFlag()
    {
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "protein_storage",
          "choice of protein storage",
          util::ShPtrVector< command::ParameterInterface>::Create
          (
            util::ShPtr< command::ParameterInterface>
            (
              new command::Parameter
              (
                "storage_initializer",
                "initializer that is passed to the storage",
                ""
              )
            ),
            util::ShPtr< command::ParameterInterface>
            (
              new command::Parameter
              (
                "init_type",
                "type of initialization - attach to existing storage (no overwrite) or overwrite a storage (will overwrite existing files)",
                command::ParameterCheckSerializable( TypeEnum()),
                GetInitializerTypeDescriptor( e_Attach)
              )
            ),
            util::ShPtr< command::ParameterInterface>
            (
              new command::Parameter
              (
                "compression", "choice of compression",
                command::ParameterCheckEnumerate< io::StreamBufferClasses>(),
                io::GetStreamBufferClasses().e_Uncompressed.GetName()
              )
            )
          )
        )
      );

      // end
      return s_flag;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief initialize with stream buffer class type
    ProteinStorageFile::ProteinStorageFile
    (
      const std::string &INITIALIZER,
      const InitializerType &INIT_TYPE,
      const io::StreamBufferClass &COMPRESSION
    ) :
      m_InitializerType( INIT_TYPE),
      m_CompressionType( COMPRESSION)
    {
      if( !m_CompressionType.IsDefined() && !command::CommandState::IsInStaticInitialization())
      {
        m_CompressionType = io::GetStreamBufferClasses().e_Uncompressed;
      }
      if( !INITIALIZER.empty())
      {
        SetDirectory( INITIALIZER);
      }
    }

    //! @brief Clone function
    //! @return pointer to new ProteinStorageFile
    ProteinStorageFile *ProteinStorageFile::Clone() const
    {
      return new ProteinStorageFile( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinStorageFile::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief sets the pdb factory
    //! @param FACTORY PDB factory to use
    void ProteinStorageFile::SetFactory( const util::ShPtr< pdb::Factory> &FACTORY)
    {
      m_Factory = FACTORY;
    }

    //! @brief initialize the molecule storage
    //! @param INITIALIZER path (including prefix) in which proteins are stored
    //! @param INIT_FLAG flag for type of initialization
    //! @return true if initialize was successful
    bool ProteinStorageFile::SetDirectory( const std::string &INITIALIZER)
    {
      if( !m_CompressionType.IsDefined())
      {
        m_CompressionType = io::GetStreamBufferClasses().e_Uncompressed;
      }

      // set factory
      m_Factory = util::ShPtr< pdb::Factory>( new pdb::Factory());

      m_Directory = util::ShPtr< io::Directory>( new io::Directory( INITIALIZER));

      // check if directory exists
      const bool dir_exists( m_Directory->DoesExist());
      bool make_success( dir_exists);
      if( !dir_exists)
      {
        make_success = m_Directory->Make();
      }

      // end
      return make_success;
    }

    //! @brief get the initializer
    //! @return string used to initialize molecule storage
    const std::string &ProteinStorageFile::GetInitializer() const
    {
      if( m_Directory.IsDefined())
      {
        return m_Directory->GetPath();
      }
      // uninitialized path is the current directory
      static const std::string s_uninitialized;
      return s_uninitialized;
    }

    //! @brief get the initialization type
    //! @return true if existing files in the storage will be overwritten
    bool ProteinStorageFile::WillOverwrite() const
    {
      return m_InitializerType == e_Overwrite;
    }

    //! @brief number of molecules in source
    //! @param SOURCE source of molecule eg. given smallmolecule source like mGluR5 potentiators,
    //!        protein xray structures
    //! @return number of molecules
    size_t ProteinStorageFile::GetSize( const std::string &SOURCE) const
    {
      return GetAllKeys( SOURCE).GetSize();
    }

    //! @brief gets all sources in this storage
    //! @return all sources in this storage
    storage::Set< std::string> ProteinStorageFile::GetAllSources() const
    {
      // directory content
      const storage::List< io::DirectoryEntry> dir_entries
      (
        m_Directory->ListEntries( io::Directory::e_File, "", ( *m_CompressionType)->AddExtension( "." + pdb::GetDefaultFileExtension()))
      );

      // found sources
      storage::Set< std::string> sources;

      // iterate over all entries
      for
      (
        storage::List< io::DirectoryEntry>::const_iterator itr( dir_entries.Begin()), itr_end( dir_entries.End());
        itr != itr_end; ++itr
      )
      {
        // store the name
        const std::string name( io::File::RemoveLastExtension( io::File::RemoveCompressionExtension( itr->GetName())));

        // check for key sizes = s_SmallKeySize (final models)
        if( name.size() > s_SmallKeySize)
        {
          // get the substring
          const std::string key_short( name.substr( name.length() - s_SmallKeySize, s_SmallKeySize));

          // if this key is valid
          if( IsValidKey( key_short))
          {
            // add the rest of the name as the source
            sources.Insert( name.substr( 0, name.length() - s_SmallKeySize));
          }

          // check for key sizes = s_LargeKeySize
          if( name.size() > s_LargeKeySize)
          {
            // get the substring
            const std::string key_long( name.substr( name.length() - s_LargeKeySize, s_LargeKeySize));

            // if this key is valid
            if( IsValidKey( key_long))
            {
              // add the rest of the name as the source
              sources.Insert( name.substr( 0, name.length() - s_LargeKeySize));
            }
          }
        }
      }

      return sources;
    }

    //! @brief get all keys for given source and sort them
    //! @param SOURCE source of molecule eg. given smallmolecule source like mGluR5 potentiators,
    //!        protein xray structures
    //! @return all keys of given source
    storage::Vector< std::string> ProteinStorageFile::GetAllKeys( const std::string &SOURCE) const
    {
      // directory content
      const storage::List< io::DirectoryEntry> dir_entries( GetAllEntries( SOURCE));

      // keys
      storage::Vector< std::string> keys;

      // iterate over all entries
      for
      (
        storage::List< io::DirectoryEntry>::const_iterator itr( dir_entries.Begin()), itr_end( dir_entries.End());
        itr != itr_end; ++itr
      )
      {
        // filename without extension
        const std::string::size_type source_pos( itr->GetName().find( SOURCE));
        std::string key;
        if( m_CompressionType != io::GetStreamBufferClasses().e_Uncompressed)
        {
          key = io::File::RemoveLastExtension( io::File::RemoveCompressionExtension( itr->GetName()));
        }
        else
        {
          key = io::File::RemoveLastExtension( itr->GetName());
        }
        // extract the key
        key.erase( source_pos, SOURCE.length());

        key = opti::Tracker< ProteinModel, double>::RemoveTrackerTag( key);

        // key needs to be valid
        if( !IsValidKey( key))
        {
          continue;
        }

        keys.PushBack( key);
      }

      return keys;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief get protein
    //! @param SOURCE prefix of protein eg. "run1"
    //! @param KEY key identifier for specific protein in given source like "00001"
    //! @return shptr to protein of interest, undefined if there is no such protein
    util::ShPtr< ProteinModel> ProteinStorageFile::Retrieve( const std::string &SOURCE, const std::string &KEY) const
    {
      // model
      util::ShPtr< ProteinModel> ptr_model;

      // check the key
      if( !IsValidKey( KEY))
      {
        return ptr_model;
      }

      // filename and check if exists
      const io::DirectoryEntry filename( Filename( SOURCE, KEY));

      // check if file with that name exists
      if( !filename.DoesExist())
      {
        return util::ShPtr< ProteinModel>();
      }

      // retrieve protein model
      ptr_model = util::ShPtr< ProteinModel>( m_Factory->ProteinModelFromPDBFilename( filename.GetFullName()).Clone());
      return ptr_model;
    }

    //! @brief get ensemble of proteins
    //! @param SOURCE corresponds to the prefix for the files e.g "run1"
    //! @return shptr list of proteins from given source
    util::ShPtrList< ProteinModel> ProteinStorageFile::RetrieveEnsemble( const std::string &SOURCE) const
    {
      // acquire all keys for that source and return ensemble
      return RetrieveEnsemble( SOURCE, GetAllKeys( SOURCE));
    }

    //! @brief get ensemble of proteins for given keys
    //! @param SOURCE corresponds to the prefix for the files e.g "run1"
    //! @param KEYS vector of identifiers for specific proteins in given source like "00001", "00002"
    //! @return shptr list of proteins from given source
    util::ShPtrList< ProteinModel> ProteinStorageFile::RetrieveEnsemble
    (
      const std::string &SOURCE,
      const storage::Vector< std::string> &KEYS
    ) const
    {
      util::ShPtrList< ProteinModel> ensemble;

      // iterate over all keys
      for( storage::Vector< std::string>::const_iterator itr( KEYS.Begin()), itr_end( KEYS.End()); itr != itr_end; ++itr)
      {
        util::ShPtr< ProteinModel> current( Retrieve( SOURCE, *itr));
        if( current.IsDefined())
        {
          ensemble.PushBack( current);
        }
        else
        {
          BCL_MessageCrt( "could not find protein " + Filename( SOURCE, *itr));
        }
      }

      // end
      return ensemble;
    }

    //! @brief get ensemble of proteins for given keys which does not map to keys, following plain numbering
    //! @param SOURCE corresponds to the prefix for the files e.g "run1"
    //! @param RANGE range of proteins
    //! @return shptr list of proteins from given source
    util::ShPtrList< ProteinModel> ProteinStorageFile::RetrieveEnsemble
    (
      const std::string &SOURCE,
      const math::Range< size_t> &RANGE
    ) const
    {
      // get all keys
      const storage::Vector< std::string> keys( GetAllKeys( SOURCE));

      // start position
      const size_t start_pos( RANGE.GetMin() + RANGE.GetLeftCondition());

      // width
      const size_t width( RANGE.GetWidth() + 1 - RANGE.GetLeftCondition() - RANGE.GetRightCondition());

      // subvector for the range
      storage::Vector< std::string> subkeys( keys, start_pos, width);

      // return sub keys ensemble
      return RetrieveEnsemble( SOURCE, subkeys);
    }

    //! @brief get any PDB remark lines
    //! @param SOURCE prefix of protein eg. "run1"
    //! @param KEY key identifier for specific protein in given source like "00001"
    //! @return PDB remark lines
    util::ShPtrList< pdb::Line> ProteinStorageFile::RetrieveRemarkLines
    (
      const std::string &SOURCE,
      const std::string &KEY
    ) const
    {
      // filename and check if exists
      const io::DirectoryEntry filename( Filename( SOURCE, KEY));

      // check if file with that name exists
      if( !filename.DoesExist())
      {
        return util::ShPtrList< pdb::Line>();
      }

      // read in pdb to handler
      io::IFStream read;
      io::File::MustOpenIFStream( read, filename.GetFullName());
      pdb::Handler handler( read);
      io::File::CloseClearFStream( read);

      // locate remark lines
      return handler.GetLines( pdb::GetLineTypes().REMARK);
    }

    //! @brief store protein
    //! @param MOLECULE protein to store
    //! @param SOURCE corresponds to the prefix for the files e.g "run1"
    //! @return key associated with protein
    std::string ProteinStorageFile::Store( const ProteinModel &MOLECULE, const std::string &SOURCE)
    {
      // if overwriting files and this source has not been written to yet
      if( m_InitializerType == e_Overwrite && !m_Sources.Contains( SOURCE))
      {
        // remove all entries w/ same source
        RemoveEntries( SOURCE);
        m_Sources.Insert( SOURCE);
      }

      // initialize current keys
      size_t current_key( 0);

      std::string key;
      while( true)
      {
        key = KeyToString( current_key);
        const io::DirectoryEntry filename( Filename( SOURCE, key));

        // check if a file with the name exists
        const bool file_exists( filename.DoesExist());

        // in the mean time, somebody might have written to the directory
        if( file_exists)
        {
          // advance to next key
          ++current_key;
          continue;
        }

        io::OFStream write;
        io::File::MustOpenOFStream( write, filename.GetFullName());
        m_Factory->WriteModelToPDB( MOLECULE, write);
        io::File::CloseClearFStream( write);
        break;
      }

      // increment key
      return key;
    }

    //! @brief store protein
    //! @param MOLECULE protein to store
    //! @param SOURCE corresponds to the prefix for the files e.g "run1"
    //! @param KEY key under which protein was stored
    //! @return true if store was successful
    bool ProteinStorageFile::Store( const ProteinModel &MOLECULE, const std::string &SOURCE, const std::string &KEY)
    {
      // check that key is valid
      if( !IsValidKey( KEY))
      {
        BCL_MessageStd( "KEY " + util::Format()( KEY) + " is not valid");
        return false;
      }

      // filename and check if exists
      io::DirectoryEntry filename( Filename( SOURCE, KEY));

      // if the file exists and should not be overwritten
      if( filename.DoesExist() && m_InitializerType != e_Overwrite)
      {
        std::string new_key( KEY);
        size_t i( s_SmallKeySize);
        do
        {
          i = s_SmallKeySize;
          while( --i)
          {
            if( new_key[ i] == '9')
            {
              new_key[ i] = '0';
            }
            else
            {
              new_key[ i] += 1;
              break;
            }
          }
          filename = Filename( SOURCE, new_key);
        } while( filename.DoesExist() && i);
        if( filename.DoesExist())
        {
          // only return false if the storage is full
          return false;
        }
      }

      // write
      io::OFStream write;
      io::File::MustOpenOFStream( write, filename.GetFullName());
      BCL_MessageDbg( "writing model to pdb file " + filename.GetFullName());
      m_Factory->WriteModelToPDB( MOLECULE, write);
      io::File::CloseClearFStream( write);

      // end
      return true;
    }

    //! @brief store ensemble of proteins
    //! @param ENSEMBLE shptr list of proteins
    //! @param SOURCE corresponds to the prefix for the files e.g "run1"
    //! @return vector of keys
    storage::Vector< std::string> ProteinStorageFile::Store
    (
      const util::ShPtrList< ProteinModel> &ENSEMBLE,
      const std::string &SOURCE
    )
    {
      // keys
      storage::Vector< std::string> keys;
      keys.AllocateMemory( ENSEMBLE.GetSize());

      // iterate over ensemble
      for
      (
        util::ShPtrList< ProteinModel>::const_iterator itr( ENSEMBLE.Begin()), itr_end( ENSEMBLE.End());
        itr != itr_end;
        ++itr
      )
      {
        // store molecule and insert key into keys
        keys.PushBack( Store( **itr, SOURCE));
      }

      return keys;
    }

    //! @brief deletes all entries in this storage
    void ProteinStorageFile::Delete()
    {
      // delete the storage
      if( m_Directory.IsDefined())
      {
        m_Directory->Remove( true);
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinStorageFile::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Directory, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinStorageFile::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Directory, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief construct complete filename from source and key
    //! @brief SOURCE the source for the model
    //! @brief KEY the key for that protein
    //! @brief filename of form {initializer}/{SOURCE}{KEY}.pdb
    std::string ProteinStorageFile::Filename( const std::string &SOURCE, const std::string &KEY) const
    {
      return m_Directory->AppendFilename
             (
               ( *m_CompressionType)->AddExtension
               (
                 SOURCE + KEY + io::File::GetExtensionDelimiter()
                 + pdb::GetDefaultFileExtension()
               )
             );
    }

    //! @brief converts a key into a string
    //! @param KEY key to be converted
    //! @return converted string
    std::string ProteinStorageFile::KeyToString( const size_t &KEY)
    {
      static const util::Format s_KeyToString
      (
        util::Format().W( 4).R().Fill( '0')
      );

      return "_" + s_KeyToString( KEY);
    }

    //! @brief check if key is valid string
    //! @param KEY the key to be checked
    //! @return true if the key is valid
    bool ProteinStorageFile::IsValidKey( const std::string &KEY)
    {
      // check that key is not empty
      if( KEY.empty())
      {
        return false;
      }

      // if this is a small string size
      if( KEY.size() == s_SmallKeySize)
      {
        // create iterators on the string
        std::string::const_iterator itr( KEY.begin()), itr_end( KEY.end());

        // first char should be "_"
        if( *itr != '_')
        {
          return false;
        }

        // other chars should be digits
        ++itr;
        for( ; itr != itr_end; ++itr)
        {
          if( !isdigit( *itr))
          {
            return false;
          }
        }
      }
      // if this is a large string size
      else if( KEY.size() == s_LargeKeySize)
      {
        // iterate over the string
        for
        (
          std::string::const_iterator itr( KEY.begin()), itr_end( KEY.end());
          itr != itr_end; ++itr
        )
        {
          // if the char is not a number
          if( !isdigit( *itr))
          {
            // check for '_' at the right positions
            if( *itr == '_' && ( itr == KEY.begin() || itr == KEY.end() - 6))
            {
              continue;
            }

            BCL_MessageStd
            (
              "non numeric \"" + util::Format()( *itr) + "\" in key \"" + KEY +
              "\" should be a \"_\" and either at the beginning or at end - 6"
            );

            return false;
          }
        }
      }
      // wrong size
      else
      {
        BCL_MessageStd
        (
          "key size does not match " + util::Format()( 11) + " or "
          + util::Format()( 5) + " as it has size " + util::Format()( KEY.size())
          + " candidate key was: " + KEY
        );
        return false;
      }

      // passed all checks
      return true;
    }

    //! @brief gets all entries that have the given source
    //! @param SOURCE source of entries
    //! @return list of found entries
    storage::List< io::DirectoryEntry> ProteinStorageFile::GetAllEntries( const std::string &SOURCE) const
    {
      // directory content
      return m_Directory->ListEntries
             (
               io::Directory::e_File,
               SOURCE,
               ( *m_CompressionType)->AddExtension( "." + pdb::GetDefaultFileExtension())
             );
    }

    //! @brief removes all entries that have the given source
    //! @param SOURCE source of entries to be removed
    void ProteinStorageFile::RemoveEntries( const std::string &SOURCE) const
    {
      // get the matching entries
      storage::List< io::DirectoryEntry> entries( GetAllEntries( SOURCE));

      // iterate over the list
      for
      (
        storage::List< io::DirectoryEntry>::iterator itr( entries.Begin()), itr_end( entries.End());
        itr != itr_end; ++itr
      )
      {
        // remove the entry
        if( !itr->Remove())
        {
          BCL_MessageStd( "Unable to remove file, " + itr->GetName());
        }
      }
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_with_cache_dataset_from_file.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_aa_classes.h"
#include "descriptor/bcl_descriptor_dataset_builder.h"
#include "io/bcl_io_serialization.h"
#include "pdb/bcl_pdb_factory.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    const util::SiPtr< const util::ObjectInterface> ProteinWithCacheDatasetFromFile::s_SequenceInstance
    (
      util::Enumerated< model::RetrieveDataSetBase>::AddInstance( new ProteinWithCacheDatasetFromFile( false))
    );
    const util::SiPtr< const util::ObjectInterface> ProteinWithCacheDatasetFromFile::s_ProteinInstance
    (
      util::Enumerated< model::RetrieveDataSetBase>::AddInstance( new ProteinWithCacheDatasetFromFile( true))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor, takes the desired AA class and whether or not to require coordinates
    ProteinWithCacheDatasetFromFile::ProteinWithCacheDatasetFromFile( const bool &REQUIRE_COORDINATES) :
      ProteinWithCacheStorageFile( REQUIRE_COORDINATES),
      m_Builder( new descriptor::DatasetBuilder< biol::AABase>())
    {
    }

    //! @brief copy constructor, clones builder
    ProteinWithCacheDatasetFromFile::ProteinWithCacheDatasetFromFile( const ProteinWithCacheDatasetFromFile &PARENT) :
      ProteinWithCacheStorageFile( PARENT),
      model::RetrieveDataSetBase( PARENT),
      m_FeatureStartIdToKey( PARENT.m_FeatureStartIdToKey),
      m_Builder
      (
        new descriptor::DatasetBuilder< biol::AABase>
        (
          PARENT.GetFeatureCode(),
          PARENT.GetResultCode(),
          PARENT.GetIdCode()
        )
      )
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProteinWithCacheDatasetFromFile
    ProteinWithCacheDatasetFromFile *ProteinWithCacheDatasetFromFile::Clone() const
    {
      return new ProteinWithCacheDatasetFromFile( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinWithCacheDatasetFromFile::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &ProteinWithCacheDatasetFromFile::GetAlias() const
    {
      return ProteinWithCacheStorageFile::GetAlias();
    }

    //! @brief Set the code / label for the feature (1st part) of the data set
    //! @param CODE the new code
    void ProteinWithCacheDatasetFromFile::SelectFeatures( const util::ObjectDataLabel &CODE)
    {
      model::RetrieveDataSetBase::SelectFeatures( CODE);
      // this is not strictly necessary, but it allows a user to ask for help over the command line for this retriever
      util::Implementation< descriptor::Base< biol::AABase, float> > property( GetFeatureCode());
      m_Builder->SetFeatureCode( GetFeatureCode());
    }

    //! @brief Set the code / label for the result (2nd part) of the data set
    //! @param CODE the new code
    void ProteinWithCacheDatasetFromFile::SelectResults( const util::ObjectDataLabel &CODE)
    {
      model::RetrieveDataSetBase::SelectResults( CODE);
      m_FeatureStartIdToKey.Reset();
      m_Builder->SetResultsCode( GetResultCode());
      const descriptor::Type type( m_Builder->GetType());
      if( type.GetDimension() == size_t( 0))
      {
        // add up the size of each, convoluted by the type
        size_t key_number( 0);
        for( const size_t n_proteins( ProteinWithCacheStorageFile::GetSize()); key_number < n_proteins; ++key_number)
        {
          m_FeatureStartIdToKey[ key_number] = key_number;
        }
        m_FeatureStartIdToKey[ key_number] = key_number;
      }
      else
      {
        // retrieve the size of each key
        storage::Vector< std::string> all_keys( ProteinWithCacheStorageFile::GetAllKeys());
        // add up the size of each, convoluted by the type
        size_t total_features( 0), key_number( 0);
        util::GetLogger() << "Computing total # of features\n";
        for
        (
          storage::Vector< std::string>::const_iterator itr( all_keys.Begin()), itr_end( all_keys.End());
          itr != itr_end;
          ++itr, ++key_number
        )
        {
          const size_t n_new_features( type.GetNumberFeatures( ProteinWithCacheStorageFile::GetKeySize( *itr)));
          if( n_new_features)
          {
            m_FeatureStartIdToKey[ total_features] = key_number;
            total_features += n_new_features;
            util::GetLogger().LogStatus
            (
              "File #" + util::Format()( key_number) + " / " + util::Format()( all_keys.GetSize())
              + " (" + *itr + "), # features: " + util::Format()( n_new_features)
              + "; total features so far: " + util::Format()( total_features)
            );
          }
        }
        m_FeatureStartIdToKey[ total_features] = key_number;
      }
    }

    //! @brief Set the code / label for the ids (3rd part) of the data set
    //! @param CODE the new code
    void ProteinWithCacheDatasetFromFile::SelectIds( const util::ObjectDataLabel &CODE)
    {
      model::RetrieveDataSetBase::SelectIds( CODE);
      // this is not strictly necessary, but it allows a user to ask for help over the command line for this retriever
      util::Implementation< descriptor::Base< biol::AABase, char> > property( GetIdCode());
      m_Builder->SetIdCode( CODE);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Get the code / label set for the feature (1st part) of the data set with sizes of each property
    //! @return the code / label for the feature (1st part) of the data set with sizes of each property
    //! the feature code set
    model::FeatureLabelSet ProteinWithCacheDatasetFromFile::GetFeatureLabelsWithSizes() const
    {
      return m_Builder.IsDefined() ? m_Builder->GetFeatureCode().GetLabelsWithSizes() : model::FeatureLabelSet();
    }

    //! @brief Get the code / label for the result (2nd part) of the data set with sizes of each property
    //! @return the code / label for the result (2nd part) of the data set with sizes of each property
    //! the feature code set
    model::FeatureLabelSet ProteinWithCacheDatasetFromFile::GetResultCodeWithSizes() const
    {
      return m_Builder.IsDefined() ? m_Builder->GetResultCode().GetLabelsWithSizes() : model::FeatureLabelSet();
    }

    //! @brief Get the code / label for the ids of the data set with sizes of each property
    //! @return the code / label for the ids of the data set with sizes of each property
    //! the feature code set
    model::FeatureLabelSet ProteinWithCacheDatasetFromFile::GetIdCodeWithSizes() const
    {
      return m_Builder.IsDefined() ? m_Builder->GetIdCode().GetLabelsWithSizes() : model::FeatureLabelSet();
    }

    //! @brief generate dataset from a set of ranges
    //! @return generated dataset
    util::ShPtr< descriptor::Dataset> ProteinWithCacheDatasetFromFile::GenerateDataSet()
    {
      pdb::Factory::GetFlagConvertToNaturalAAType()->SetFlag();

      // determine the total size of the data set
      const size_t total_dataset_size( m_FeatureStartIdToKey.ReverseBegin()->first);

      if( !m_Builder.IsDefined())
      {
        m_Builder =
          util::ShPtr< descriptor::DatasetBuilder< biol::AABase> >
          (
            new descriptor::DatasetBuilder< biol::AABase>( GetFeatureCode(), GetResultCode(), GetIdCode())
          );
      }

      // dataset to hold all results
      const size_t nominal_size( GetNominalSize());
      util::ShPtr< descriptor::Dataset> dataset_sp
      (
        new descriptor::Dataset
        (
          nominal_size,
          GetFeatureLabelsWithSizes(),
          GetResultCodeWithSizes(),
          GetIdCodeWithSizes()
        )
      );
      linal::MatrixReference< float> features( dataset_sp->GetFeaturesReference());
      linal::MatrixReference< float> results( dataset_sp->GetResultsReference());
      linal::MatrixReference< char> ids( dataset_sp->GetIdsReference());

      const size_t nr_features
      (
        GenerateDataSubsetGivenBuilder
        (
          math::Range< size_t>( 0, total_dataset_size),
          features,
          results,
          ids,
          0,
          *m_Builder
        )
      );

      // remove unused rows
      dataset_sp->ShrinkRows( nr_features);

      // return the generated dataset
      return dataset_sp;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &ProteinWithCacheDatasetFromFile::Read( std::istream &ISTREAM)
    {
      // read member
      ProteinWithCacheStorageFile::Read( ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &ProteinWithCacheDatasetFromFile::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      ProteinWithCacheStorageFile::Write( OSTREAM, INDENT) << '\n';

      // end
      return OSTREAM;
    }

    //! @brief get the number of partitions requested by the user, along with the partition ids
    //! @return the number of partitions requested by the user, along with the partition ids
    storage::Pair< size_t, math::RangeSet< size_t> > ProteinWithCacheDatasetFromFile::GetNumberPartitionsAndIds() const
    {
      return storage::Pair< size_t, math::RangeSet< size_t> >( 1, math::RangeSet< size_t>( math::Range< size_t>( 0, 0)));
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinWithCacheDatasetFromFile::GetSerializer() const
    {
      io::Serializer member_data( ProteinWithCacheStorageFile::GetSerializer());
      member_data.SetClassDescription
      (
        (
          ProteinWithCacheStorageFile::m_RequireCoordinates
          ? "Calculates descriptors from PDB entries (as sequences of " + ProteinWithCacheStorageFile::m_Class.GetName() + ")"
          : "Retrieves sequences of " + ProteinWithCacheStorageFile::m_Class.GetName() + " from PDBs or FASTAs"
        ) +
        " from a directory or subdirectory"
      );

      return member_data;
    } // GetParameters

    //! @brief get the nominal (e.g. best estimate without generating the entire dataset) size of the dataset
    //! @return the nominal (e.g. best estimate without generating the entire dataset) size of the dataset
    size_t ProteinWithCacheDatasetFromFile::GetNominalSize() const
    {
      // get the last value out of the map, if there are any values
      if( m_FeatureStartIdToKey.IsEmpty())
      {
        BCL_MessageCrt( "Warning, called GetNominalSize before calling SelectResults");
        return 0;
      }

      return m_FeatureStartIdToKey.ReverseBegin()->first;
    }

    //! @brief load a range of data from the dataset
    //! @param SUBSET the range of data to load
    //! @param FEATURES_STORAGE where to store features that are loaded, must be large enough to hold the subset without resizing
    //! @param RESULTS_STORAGE where to store the corresponding results, must be large enough to hold the subset without resizing
    //! @param START_FEATURE_NUMBER position to store the first feature in FEATURES_STORAGE
    //! @return # of features actually loaded
    //! Note: Implementations should overload this and SupportsEfficientSubsetLoading together
    size_t ProteinWithCacheDatasetFromFile::GenerateDataSubset
    (
      const math::Range< size_t> &SUBSET,
      linal::MatrixInterface< float> &FEATURES_STORAGE,
      linal::MatrixInterface< float> &RESULTS_STORAGE,
      linal::MatrixInterface< char> &IDS_STORAGE,
      const size_t &START_FEATURE_NUMBER
    )
    {
      pdb::Factory::GetFlagConvertToNaturalAAType()->SetFlag();

      if( !m_Builder.IsDefined())
      {
        m_Builder =
          util::ShPtr< descriptor::DatasetBuilder< biol::AABase> >
          (
            new descriptor::DatasetBuilder< biol::AABase>( GetFeatureCode(), GetResultCode(), GetIdCode())
          );
      }

      // generate a dataset of protein codes from the ranges given in the range set
      return
        GenerateDataSubsetGivenBuilder
        (
          SUBSET,
          FEATURES_STORAGE,
          RESULTS_STORAGE,
          IDS_STORAGE,
          START_FEATURE_NUMBER,
          *m_Builder
        );
    }

    //! @brief load a range of data from the dataset, given a particular dataset builder
    //! @param SUBSET the range of data to load
    //! @param FEATURES_STORAGE where to store features that are loaded, must be large enough to hold the subset without resizing
    //! @param RESULTS_STORAGE where to store the corresponding results, must be large enough to hold the subset without resizing
    //! @param START_FEATURE_NUMBER position to store the first feature in FEATURES_STORAGE
    //! @param BUILDER the dataset builder to use
    //! @return # of features actually loaded
    size_t ProteinWithCacheDatasetFromFile::GenerateDataSubsetGivenBuilder
    (
      const math::Range< size_t> &SUBSET,
      linal::MatrixInterface< float> &FEATURES_STORAGE,
      linal::MatrixInterface< float> &RESULTS_STORAGE,
      linal::MatrixInterface< char> &IDS_STORAGE,
      const size_t &START_FEATURE_NUMBER,
      descriptor::DatasetBuilder< biol::AABase> &BUILDER
    )
    {
      pdb::Factory::GetFlagConvertToNaturalAAType()->SetFlag();

      // retrieve the protein ensemble
      util::ShPtrVector< ProteinModelWithCache> models;
      size_t start_feature( 0), total_size( 0);

      BCL_Assert
      (
        BUILDER.GetFeatureSize() == FEATURES_STORAGE.GetNumberCols(),
        "Wrong column size for features " + util::Format()( BUILDER.GetFeatureSize())
        + " storage: " + util::Format()( FEATURES_STORAGE.GetNumberCols())
      );
      BCL_Assert( BUILDER.GetResultSize() == RESULTS_STORAGE.GetNumberCols(), "Wrong column size for results");
      BCL_Assert( BUILDER.GetIdSize() == IDS_STORAGE.GetNumberCols(), "Wrong column size for ids");

      if( BUILDER.GetType().GetDimension() == size_t( 0))
      {
        const math::Range< size_t> closed_range( SUBSET.CloseBorders());
        models = RetrieveEnsemble( closed_range);
        total_size = models.GetSize();
      }
      else
      {
        math::Range< size_t> closed_range( SUBSET.CloseBorders());
        storage::Map< size_t, size_t>::const_iterator itr_lower( m_FeatureStartIdToKey.LowerBound( closed_range.GetMin()));
        storage::Map< size_t, size_t>::const_iterator itr_upper( m_FeatureStartIdToKey.LowerBound( closed_range.GetMax()));
        if( itr_lower == m_FeatureStartIdToKey.End())
        {
          return 0;
        }
        else if( itr_lower->first > closed_range.GetMin())
        {
          --itr_lower;
        }
        if( itr_upper == m_FeatureStartIdToKey.End())
        {
          --itr_upper;
          closed_range = math::Range< size_t>( closed_range.GetMin(), itr_upper->first - 1);
        }
        total_size = closed_range.GetWidth() + 1;
        const math::Range< size_t> model_range
        (
          math::RangeBorders::e_LeftClosed,
          itr_lower->second,
          itr_upper->second,
          math::RangeBorders::e_RightOpen
        );
        models = RetrieveEnsemble( model_range);
        start_feature = closed_range.GetMin() - itr_lower->first;
      }
      iterate::Generic< const descriptor::SequenceInterface< biol::AABase> >
        model_iterator( models.Begin(), models.End());
      descriptor::Dataset dataset( BUILDER( model_iterator, start_feature, total_size));
      // copy the code vectors into the matrices
      size_t data_counter( START_FEATURE_NUMBER);
      std::copy
      (
        dataset.GetFeaturesReference().Begin(),
        dataset.GetFeaturesReference().End(),
        FEATURES_STORAGE[ data_counter]
      );
      // copy the result
      std::copy
      (
        dataset.GetResultsReference().Begin(),
        dataset.GetResultsReference().End(),
        RESULTS_STORAGE[ data_counter]
      );
      // copy the ids
      std::copy
      (
        dataset.GetIdsReference().Begin(),
        dataset.GetIdsReference().End(),
        IDS_STORAGE[ data_counter]
      );

      // return the # of features that were actually loaded
      return dataset.GetSize();
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_with_cache_storage_file.h"

// includes from bcl - sorted alphabetically
#include "biol/bcl_biol_blast_profile_handler.h"
#include "biol/bcl_biol_dssp.h"
#include "biol/bcl_biol_membrane.h"
#include "io/bcl_io_directory_entry.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "pdb/bcl_pdb_factory.h"
#include "pdb/bcl_pdb_head.h"
#include "sspred/bcl_sspred_mahssmi.h"
#include "sspred/bcl_sspred_method_handler.h"
#include "sspred/bcl_sspred_pdb.h"
#include "util/bcl_util_wrapper.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    const util::SiPtr< const util::ObjectInterface> ProteinWithCacheStorageFile::s_SequenceInstance
    (
      util::Enumerated< RetrieveProteinModelWithCache>::AddInstance( new ProteinWithCacheStorageFile( false))
    );
    const util::SiPtr< const util::ObjectInterface> ProteinWithCacheStorageFile::s_ProteinInstance
    (
      util::Enumerated< RetrieveProteinModelWithCache>::AddInstance( new ProteinWithCacheStorageFile( true))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor, takes whether or not to require coordinates
    //! @param REQUIRE_COORDINATES if true, only load PDB files, and only consider AAs with coordinates
    //! @param AUTOLOAD if true, automatically load any blast and secondary structure prediction files
    ProteinWithCacheStorageFile::ProteinWithCacheStorageFile
    (
      const bool &REQUIRE_COORDINATES,
      const bool &AUTOLOAD
    ) :
      m_Class( REQUIRE_COORDINATES ? biol::GetAAClasses().e_AABackBone : biol::GetAAClasses().e_AA),
      m_RequireCoordinates( REQUIRE_COORDINATES),
      m_Autoload( AUTOLOAD),
      m_DoDSSP( false),
      m_Alias( std::string( m_RequireCoordinates ? "Protein" : "Sequence") + "Directory"),
      m_TransitionRegionThickness( 5.0),
      m_GapThickness( 0.0),
      m_BlastExtension(),
      m_RecursiveFind( false),
      m_HaveLoadedIndexFile( false),
      m_CanWriteIndexFile( true)
    {
    }

    //! @brief copy constructor; ignores all cached values
    ProteinWithCacheStorageFile::ProteinWithCacheStorageFile( const ProteinWithCacheStorageFile &PARENT) :
      m_Directory( PARENT.m_Directory),
      m_Suffix( PARENT.m_Suffix),
      m_PdbIdListFile( PARENT.m_PdbIdListFile),
      m_PdbPathFile( PARENT.m_PdbPathFile),
      m_ProteinFiles( PARENT.m_ProteinFiles),
      m_ProteinFileSizes( PARENT.m_ProteinFileSizes),
      m_KeyToPathId( PARENT.m_KeyToPathId),
      m_Class( PARENT.m_Class),
      m_RequireCoordinates( PARENT.m_RequireCoordinates),
      m_Autoload( PARENT.m_Autoload),
      m_DoDSSP( PARENT.m_DoDSSP),
      m_Alias( PARENT.m_Alias),
      m_TransitionRegionThickness( PARENT.m_TransitionRegionThickness),
      m_GapThickness( PARENT.m_GapThickness),
      m_BlastExtension( PARENT.m_BlastExtension),
      m_RecursiveFind( PARENT.m_RecursiveFind),
      m_HaveLoadedIndexFile( PARENT.m_HaveLoadedIndexFile),
      m_CanWriteIndexFile( PARENT.m_CanWriteIndexFile)
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProteinWithCacheStorageFile
    ProteinWithCacheStorageFile *ProteinWithCacheStorageFile::Clone() const
    {
      return new ProteinWithCacheStorageFile( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinWithCacheStorageFile::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return the name of the property without any parameters
    //! @return name of the property as string
    const std::string &ProteinWithCacheStorageFile::GetAlias() const
    {
      return m_Alias;
    }

    //! @brief number of proteins in storage
    //! @return number of proteins in this storage
    size_t ProteinWithCacheStorageFile::GetSize() const
    {
      return m_ProteinFiles.GetSize();
    }

    //! @brief get all keys for given source
    //! @return all keys of given prefix
    storage::Vector< std::string> ProteinWithCacheStorageFile::GetAllKeys() const
    {
      // make a vector of strings big enough to hold the keys
      storage::Vector< std::string> keys( GetSize());

      for( size_t key( 0), max_key( keys.GetSize()); key < max_key; ++key)
      {
        keys( key) = GetKey( m_ProteinFiles( key), m_Suffix);
      }

      // return all created keys
      return keys;
    }

    //! @brief count the number of AAs in a given key, without actually creating a complete model
    //! @param KEY the identifier for the protein of interest
    //! @return the number of AAs (or AAs with coordinates if m_RequireCoordinates is set) for the given key
    size_t ProteinWithCacheStorageFile::GetKeySize( const std::string &KEY) const
    {
      // find the filename id for the given key
      const std::string cleaned_key( GetKey( KEY, m_Suffix));
      storage::Map< std::string, size_t>::const_iterator itr( m_KeyToPathId.Find( cleaned_key));

      // if no id was found
      if( itr == m_KeyToPathId.End())
      {
        // return an empty model
        return util::GetUndefined< size_t>();
      }

      // find the size in the vector
      size_t &number_aas( m_ProteinFileSizes( itr->second));

      // if the value is known, it will be defined
      if( util::IsDefined( number_aas))
      {
        // so just return it
        return number_aas;
      }

      // try to read the index file, if it has not been read already
      if( !m_HaveLoadedIndexFile)
      {
        m_HaveLoadedIndexFile = true;
        std::string index_filename( GetIndexFileName());
        if( io::DirectoryEntry( index_filename).DoesExist())
        {
          io::IFStream index_read;
          if( io::File::TryOpenIFStream( index_read, index_filename))
          {
            util::ChopHeader( index_read);
            storage::Vector< storage::Vector< std::string> > path_to_counts
            (
              util::SplittedStringLineListFromIStream( index_read)
            );
            io::File::CloseClearFStream( index_read);
            for
            (
              storage::Vector< storage::Vector< std::string> >::const_iterator
                itr_index( path_to_counts.Begin()), itr_index_end( path_to_counts.End());
              itr_index != itr_index_end;
              ++itr_index
            )
            {
              if( itr_index->GetSize() != size_t( 2))
              {
                continue;
              }
              size_t key_index( m_ProteinFiles.Find( itr_index->FirstElement()));
              if( key_index < m_ProteinFiles.GetSize())
              {
                m_ProteinFileSizes( key_index) = util::ConvertStringToNumericalValue< size_t>( ( *itr_index)( 1));
              }
            }
          }
        }
      }

      // if the value is known, it will be defined
      if( util::IsDefined( number_aas))
      {
        // so just return it
        return number_aas;
      }

      // otherwise, the key will have to be read
      number_aas = Retrieve( KEY)->GetSize();

      if( m_CanWriteIndexFile)
      {
        std::string index_filename( GetIndexFileName());
        if( !index_filename.empty())
        {
          io::OFStream index_out;
          if( !io::DirectoryEntry( index_filename).DoesExist())
          {
            if( io::File::TryOpenOFStream( index_out, index_filename))
            {
              index_out << "# BCL Index file\n# Filename\tNumber Residues\n";
              index_out << "#This file is used to cache the number of residues in input files for BCL descriptor\n";
              index_out << "#generation and PDB file access.  It can be deleted at any time to force recalculation of sizes\n";
            }
            else
            {
              m_CanWriteIndexFile = false;
            }
          }
          else if( !io::File::TryOpenOFStream( index_out, index_filename, std::ios::app))
          {
            m_CanWriteIndexFile = false;
          }
          if( m_CanWriteIndexFile)
          {
            index_out << m_ProteinFiles( itr->second) << '\t' << number_aas << '\n';
            io::File::CloseClearFStream( index_out);
          }
        }
        else
        {
          m_CanWriteIndexFile = false;
        }
      }
      return number_aas;
    }

    //! @brief get the type of AA class that will be produced
    //! @return the type of AA class that will be produced
    const biol::AAClass &ProteinWithCacheStorageFile::GetAAClass() const
    {
      return m_Class;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief get the filename for a given key
    //! @param KEY key identifier for specific object
    //! @return the filename for the given key (empty if the key is invalid for this storage)
    const std::string &ProteinWithCacheStorageFile::GetFilename( const std::string &KEY) const
    {
      static std::string s_empty;
      // look for the key
      storage::Map< std::string, size_t>::const_iterator itr( m_KeyToPathId.Find( GetKey( KEY, m_Suffix)));

      // get the complete filename, or empty if no filename was found
      return itr == m_KeyToPathId.End() ? s_empty : m_ProteinFiles( itr->second);
    }

    //! @brief get stored MoleculeComplete from key
    //! @param KEY key identifier for specific object
    //! @return Molecule of interest
    util::ShPtr< ProteinModelWithCache> ProteinWithCacheStorageFile::Retrieve( const std::string &KEY) const
    {
      // get the complete filename
      const std::string cleaned_key( GetKey( KEY, m_Suffix));

      // look for the model in the cache
      if( cleaned_key == m_LastModelKey)
      {
        return m_LastModel;
      }

      // look for the key
      storage::Map< std::string, size_t>::const_iterator itr( m_KeyToPathId.Find( cleaned_key));

      // handle unavailable keys
      if( itr == m_KeyToPathId.End())
      {
        BCL_MessageCrt( "Warning: Could not retrieve requested protein key: " + KEY);
        return util::ShPtr< ProteinModelWithCache>();
      }

      const std::string &filename( m_ProteinFiles( itr->second));

      BCL_MessageVrb( "Reading key: " + cleaned_key + " from " + filename);

      // create the model
      ProteinModel model( GenerateProteinModelFromFile( filename, m_RequireCoordinates, m_Class));

      // handle autoload and dssp parameters
      if( m_Autoload)
      {
        if( m_DoDSSP)
        {
          biol::DSSP().SetPDBSSPred( model);
        }
        if( m_Suffix.empty() || !util::EndsWith( m_Suffix, filename))
        {
          const std::string fname( io::File::RemoveLastExtension( filename));
          LoadBlastSspred( model, fname);
          if( cleaned_key.size() >= size_t( 5))
          {
            LoadBlastSspred( model, fname.substr( 0, fname.size() - 1));
          }
        }
        else
        {
          if( cleaned_key.size() >= size_t( 5))
          {
            LoadBlastSspred( model, filename.substr( 0, filename.size() - m_Suffix.size() - 1));
          }
          LoadBlastSspred( model, filename.substr( 0, filename.size() - m_Suffix.size()));
        }
      }
      m_LastModel = util::ShPtr< ProteinModelWithCache>( new ProteinModelWithCache( model, m_RequireCoordinates));
      if( m_Autoload && !m_BlastExtension.empty())
      {
        // check that the blast profile was read
        BCL_Assert
        (
          m_LastModel->IsEmpty() || m_LastModel->GetIterator()->GetBlastProfilePtr().IsDefined(),
          "Could not read blast profile for " + model.GetIdentification() + " @ " + filename
          + " with extension " + m_BlastExtension
        );
      }
      m_LastModelKey = cleaned_key;
      return m_LastModel;
    }

    //! @brief get molecule ensemble for given keys
    //! @param KEYS vector of keys
    //! @return list of MoleculeComplete objects corresponding to KEYS
    util::ShPtrVector< ProteinModelWithCache> ProteinWithCacheStorageFile::RetrieveEnsemble( const storage::Vector< std::string> &KEYS) const
    {
      // create ensemble with final proteins
      util::ShPtrVector< ProteinModelWithCache> list_proteins;
      list_proteins.AllocateMemory( KEYS.GetSize());
      for
      (
        storage::Vector< std::string>::const_iterator itr( KEYS.Begin()), itr_end( KEYS.End());
        itr != itr_end;
        ++itr
      )
      {
        list_proteins.PushBack( Retrieve( *itr));
      }

      // end
      return list_proteins;
    }

    //! @brief get ensemble of stored proteins objects for a range of keys, specified by plain numbers
    //! @param RANGE range of keys
    //! @return list of MoleculeComplete objects corresponding to keys in RANGE
    util::ShPtrVector< ProteinModelWithCache> ProteinWithCacheStorageFile::RetrieveEnsemble( const math::Range< size_t> &RANGE) const
    {
      // create a normal range
      if( !util::IsDefined( RANGE.GetMax()))
      {
        return this->RetrieveEnsemble( m_ProteinFiles);
      }

      math::Range< size_t> std_range( RANGE.StandardizeRange());

      // create ensemble with final proteins
      util::ShPtrVector< ProteinModelWithCache> list_proteins;
      list_proteins.AllocateMemory( std_range.GetWidth());
      for( size_t i( std_range.GetMin()), mx( std::min( m_ProteinFiles.GetSize(), std_range.GetMax())); i < mx; ++i)
      {
        list_proteins.PushBack( Retrieve( m_ProteinFiles( i)));
      }

      // end
      return list_proteins;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief Set the members of this property from the given LABEL
    //! @param LABEL the label to parse
    //! @param ERR_STREAM stream to write out errors to
    bool ProteinWithCacheStorageFile::ReadInitializerSuccessHook
    (
      const util::ObjectDataLabel &LABEL,
      std::ostream &ERR_STREAM
    )
    {
      if( !m_PdbPathFile.empty())
      {
        m_Directory = io::File::MakeAbsolutePath( m_Directory);
        if( m_Directory.size() && m_Directory[ m_Directory.size() - 1] != '/')
        {
          m_Directory += '/';
        }
        if( !m_PdbIdListFile.empty())
        {
          BCL_MessageCrt( "key file parameter ignored because pdb paths were given");
        }
        io::IFStream input;
        io::File::MustOpenIFStream( input, m_PdbPathFile);
        storage::Vector< std::string> paths_of_interest( util::StringListFromIStream( input));
        io::File::CloseClearFStream( input);
        // remove any empty lines
        m_ProteinFiles.Reset();
        m_ProteinFiles.AllocateMemory( paths_of_interest.GetSize());
        for
        (
          storage::Vector< std::string>::const_iterator itr( paths_of_interest.Begin()), itr_end( paths_of_interest.End());
          itr != itr_end;
          ++itr
        )
        {
          const std::string trimmed_path( m_Directory + util::TrimString( *itr));
          const std::string trimmed_key( GetKey( trimmed_path, m_Suffix));
          if( !trimmed_key.empty())
          {
            if( !io::DirectoryEntry( trimmed_path).DoesExist())
            {
              ERR_STREAM << "Path from file does not exist: " << trimmed_path;
              return false;
            }
            if( m_KeyToPathId.Has( trimmed_key))
            {
              ERR_STREAM << "Unique key violation: " << trimmed_key << " encountered at "
                         << trimmed_path << " and " << m_ProteinFiles( m_KeyToPathId[ trimmed_key]);
              return false;
            }
            m_KeyToPathId[ trimmed_key] = m_ProteinFiles.GetSize();
            m_ProteinFiles.PushBack( trimmed_path);
          }
        }
      }
      // if the list file was set, filter the keys with the list
      else if( !m_PdbIdListFile.empty())
      {
        io::IFStream input;
        io::File::MustOpenIFStream( input, m_PdbIdListFile);
        storage::Vector< std::string> keys_of_interest( util::StringListFromIStream( input));
        io::File::CloseClearFStream( input);
        // remove any empty lines
        storage::Vector< std::string> valid_keys;
        valid_keys.AllocateMemory( keys_of_interest.GetSize());
        for
        (
          storage::Vector< std::string>::const_iterator itr( keys_of_interest.Begin()), itr_end( keys_of_interest.End());
          itr != itr_end;
          ++itr
        )
        {
          const std::string trimmed( GetKey( util::TrimString( *itr), m_Suffix));
          if( !trimmed.empty())
          {
            m_KeyToPathId[ trimmed] = valid_keys.GetSize();
            valid_keys.PushBack( trimmed);
          }
        }
        m_ProteinFiles.Resize( valid_keys.GetSize());

        storage::Set< std::string> desired_key_set( valid_keys.Begin(), valid_keys.End());

        // try finding all the desired keys
        if( !AddKeys( io::Directory( m_Directory), desired_key_set, ERR_STREAM))
        {
          return false;
        }

        // check that all desired keys were found
        if( !desired_key_set.IsEmpty())
        {
          ERR_STREAM << "Could not find the following keys: " << desired_key_set << '\n';
          return false;
        }
      }
      else if( !m_Directory.empty())
      {
        io::DirectoryEntry entry( m_Directory);
        if( entry.DoesExist() && entry.IsType( io::Directory::e_Dir))
        {
          // get all the keys
          if( !AddKeys( io::Directory( m_Directory), ERR_STREAM))
          {
            return false;
          }
        }
        else if( entry.IsType( io::Directory::e_File))
        {
          const std::string trimmed_key( GetKey( entry.GetName(), m_Suffix));
          m_KeyToPathId[ trimmed_key] = 0;
          m_ProteinFiles.PushBack( entry.GetFullName());
        }
      }

      // create the sizes vector, which will only be updated whenever AA count is requested for the given protein
      m_ProteinFileSizes.Resize( m_ProteinFiles.GetSize());
      m_ProteinFileSizes.SetAllElements( util::GetUndefined< size_t>());

      if( m_RequireCoordinates)
      {
        biol::Membrane::GetParameterTransitionThickness()->SetParameter( util::Format()( m_TransitionRegionThickness), ERR_STREAM);
        biol::Membrane::GetParameterGapThickness()->SetParameter( util::Format()( m_GapThickness), ERR_STREAM);
      }
      return true;
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinWithCacheStorageFile::GetSerializer() const
    {
      io::Serializer parameters;
      parameters.SetClassDescription
      (
        m_RequireCoordinates
        ? "Retrieves PDB amino acids that have coordinates from a directory or subdirectory"
        : "Retrieves amino acid sequences from PDBs or FASTAs from a directory or subdirectory"
      );

      // set the parameter check accordingly
      parameters.AddOptionalInitializer
      (
        "",
        "Protein file or directory which contains proteins or folders containing proteins",
        io::Serialization::GetAgentInputFilename( &m_Directory)
      );

      parameters.AddOptionalInitializer
      (
        "suffix",
        "Protein file suffix; if not given, use .pdb if it is available, .fasta otherwise",
        io::Serialization::GetAgent( &m_Suffix)
      );

      parameters.AddOptionalInitializer
      (
        "key file",
        "File containing pdb ids, one per line, to look for in dir (by default, all files with the correct suffix are used)",
        io::Serialization::GetAgentInputFilename( &m_PdbIdListFile)
      );

      parameters.AddOptionalInitializer
      (
        "path file",
        "File containing absolute or relative paths to files that are to be loaded. "
        "If not given, the directory will be searched recursively for the keys in the key file, if it was given, or "
        "all files with the given suffix will be taken from the directory. "
        "This option is useful on files systems (e.g. NFS) where scanning directories is slow, also when there may be  "
        "multiple files in the directories that would yield the same key",
        io::Serialization::GetAgentInputFilename( &m_PdbPathFile)
      );

      if( m_RequireCoordinates)
      {
        parameters.AddInitializer
        (
          "aa class",
          "Level of detail at which to load amino acids",
          io::Serialization::GetAgent( &m_Class),
          m_RequireCoordinates ? biol::GetAAClasses().e_AABackBone.GetName() : biol::GetAAClasses().e_AA.GetName()
        );
        parameters.AddInitializer
        (
          "dssp",
          "Flag to enable re-determining Helix Strand and Coil regions via the DSSP algorithm",
          io::Serialization::GetAgent( &m_DoDSSP),
          "No"
        );
        parameters.AddInitializer
        (
          "membrane gap thickness",
          "Thickness (in angstrom) of gap between membrane and transition region",
          io::Serialization::GetAgentWithMin( &m_GapThickness, 0.0),
          "0"
        );
        parameters.AddInitializer
        (
          "membrane transition thickness",
          "Thickness of transition region; 5 A is thicness of typical phosholipid head group",
          io::Serialization::GetAgentWithMin( &m_TransitionRegionThickness, 0.0),
          "5"
        );
      }
      parameters.AddInitializer
      (
        "blast extension",
        "Extension for blast pssm files; if empty, choose .ascii6 if available, .ascii otherwise",
        io::Serialization::GetAgent( &m_BlastExtension),
        ""
      );
      parameters.AddInitializer
      (
        "recursive",
        "Recursively search all directories and subdirectory for the given keys. "
        "If this flag is not set, and no paths are given, only the given directory (or explicit file) will be searched for keys",
        io::Serialization::GetAgent( &m_RecursiveFind),
        "False"
      );
      parameters.AddDataMember( "key map", io::Serialization::GetAgent( &m_KeyToPathId));
      parameters.AddDataMember( "file list", io::Serialization::GetAgent( &m_ProteinFiles));
      return parameters;
    }

    //! @brief add protein keys and paths from the given directory
    //! @param DIRECTORY the directory of interest
    //! @param ERR_STREAM output stream for errors
    //! @return true if no duplicate keys were found
    bool ProteinWithCacheStorageFile::AddKeys( const io::Directory &DIRECTORY, std::ostream &ERR_STREAM)
    {
      static const std::string pdb_extension( "." + pdb::GetDefaultFileExtension());

      // determine the default extension
      const std::string def_extension( m_Suffix.empty() ? m_RequireCoordinates ? pdb_extension : ".fasta" : m_Suffix);
      {
        // get all files with the desired extension in the directory
        storage::List< io::DirectoryEntry> entries( DIRECTORY.ListFiles( "", def_extension, m_RecursiveFind));

        // add all the entries
        for
        (
          storage::List< io::DirectoryEntry>::const_iterator itr( entries.Begin()), itr_end( entries.End());
          itr != itr_end;
          ++itr
        )
        {
          // add the new file
          m_ProteinFiles.PushBack( itr->GetFullName());

          // get the key for this protein
          const std::string key( GetKey( itr->GetName(), m_Suffix));

          // ensure that the key is not already present could be added
          if( !m_KeyToPathId.Insert( std::make_pair( key, m_ProteinFiles.GetSize() - 1)).second)
          {
            ERR_STREAM << "Found " << key << " at " << m_ProteinFiles.LastElement()
                       << " and " << m_ProteinFiles( m_KeyToPathId[ key]);
            return false;
          }
        }
      }

      // if looking for sequences, also consider any pdb files
      if( m_Suffix.empty() && !m_RequireCoordinates)
      {
        // get all pdb files in the directory
        storage::List< io::DirectoryEntry> entries( DIRECTORY.ListFiles( "", pdb_extension, m_RecursiveFind));
        // add all the pdb entries, if a fasta has not already been found
        for
        (
          storage::List< io::DirectoryEntry>::const_iterator itr( entries.Begin()), itr_end( entries.End());
          itr != itr_end;
          ++itr
        )
        {
          // get the key for this pdb
          const std::string key( GetKey( itr->GetName(), m_Suffix));

          // ensure that the key is not already present and could be added
          if( m_KeyToPathId.Insert( std::make_pair( key, m_ProteinFiles.GetSize())).second)
          {
            // insert succeeded, so add the pdb key to the protein file
            m_ProteinFiles.PushBack( itr->GetFullName());
          }
        }
      }
      return true;
    }

    //! @brief add protein keys and paths from the given directory if they are in the given set, remove them from the set as each is added
    //! @param DIRECTORY the directory of interest
    //! @param DESIRED_KEYS set of keys of interest
    //! @param ERR_STREAM output stream for errors
    //! @return false if any duplicates are found
    bool ProteinWithCacheStorageFile::AddKeys
    (
      const io::Directory &DIRECTORY,
      storage::Set< std::string> &DESIRED_KEYS,
      std::ostream &ERR_STREAM
    )
    {
      static const std::string pdb_extension( "." + pdb::GetDefaultFileExtension());

      // determine the default extension
      const std::string def_extension( m_Suffix.empty() ? m_RequireCoordinates ? pdb_extension : ".fasta" : m_Suffix);
      {
        // get all files with the desired extension in the directory
        storage::List< io::DirectoryEntry> entries( DIRECTORY.ListFiles( "", def_extension, m_RecursiveFind));

        // add all the entries that are also in the desired keys
        for
        (
          storage::List< io::DirectoryEntry>::const_iterator itr( entries.Begin()), itr_end( entries.End());
          itr != itr_end;
          ++itr
        )
        {
          // get the key for this pdb
          const std::string key( GetKey( itr->GetName(), m_Suffix));

          // look for the key in the set
          storage::Set< std::string>::iterator itr_set( DESIRED_KEYS.Find( key));

          if( itr_set != DESIRED_KEYS.End())
          {
            m_ProteinFiles( m_KeyToPathId[ key]) = itr->GetFullName();
            DESIRED_KEYS.RemoveElement( itr_set);
          }
          else if( m_KeyToPathId.Has( key))
          {
            ERR_STREAM << "Found " << key << " at " << itr->GetFullName()
                       << " and " << m_ProteinFiles( m_KeyToPathId[ key]);
            return false;
          }
        }
      }

      // if looking for sequences, also consider any pdb files
      if( m_Suffix.empty() && !m_RequireCoordinates && !DESIRED_KEYS.IsEmpty())
      {
        // get all pdb files in the directory
        storage::List< io::DirectoryEntry> entries( DIRECTORY.ListFiles( "", pdb_extension, m_RecursiveFind));
        // add all the fasta entries, if a pdb has not already been found
        for
        (
          storage::List< io::DirectoryEntry>::const_iterator itr( entries.Begin()), itr_end( entries.End());
          itr != itr_end;
          ++itr
        )
        {
          // get the key for this fasta
          const std::string key( GetKey( itr->GetName(), m_Suffix));

          // look for the key in the set
          storage::Set< std::string>::iterator itr_set( DESIRED_KEYS.Find( key));

          if( itr_set != DESIRED_KEYS.End())
          {
            m_ProteinFiles( m_KeyToPathId[ key]) = itr->GetFullName();
            DESIRED_KEYS.RemoveElement( itr_set);
          }
        }
      }
      return true;
    }

    //! @brief given a fasta or pdb filename, generate a protein model
    //! @param FILENAME filename of interest
    //! @param REQUIRE_COORDINATES true if coordinates are required
    //! @param CLASS AA class to use
    ProteinModel ProteinWithCacheStorageFile::GenerateProteinModelFromFile
    (
      const std::string &FILENAME,
      const bool &REQUIRE_COORDINATES,
      const biol::AAClass &CLASS
    )
    {
      // get the complete filename
      const std::string cleaned_key( GetKey( FILENAME, "." + pdb::GetDefaultFileExtension()));

      BCL_MessageVrb( "Reading key: " + cleaned_key + " from " + FILENAME);

      // create a pdb factory
      pdb::Factory factory( CLASS);

      // Minimum SSE sizes (no filter)
      static storage::Map< biol::SSType, size_t> sse_sizes
      (
        storage::Map< biol::SSType, size_t>::Create
        (
          std::make_pair( biol::GetSSTypes().HELIX, 0),
          std::make_pair( biol::GetSSTypes().STRAND, 0),
          std::make_pair( biol::GetSSTypes().COIL, 0)
        )
      );

      // handle loading of pdbs
      if( REQUIRE_COORDINATES || io::File::GetLastExtension( FILENAME) == pdb::GetDefaultFileExtension())
      {
        // normal pdb file; read it in as usual, and add the identification from the key
        ProteinModel model( factory.ProteinModelFromPDBFilename( FILENAME, sse_sizes, true));
        util::ShPtr< ProteinModelData> sp_data( model.GetProteinModelData().HardCopy());
        sp_data->Insert
        (
          ProteinModelData::e_Identification,
          util::ShPtr< util::Wrapper< std::string> >( new util::Wrapper< std::string>( cleaned_key.substr( 0, 5)))
        );
        model.SetProteinModelData( sp_data);
        return model;
      }

      // fasta file, need to create a sequence and insert it into the protein model

      io::IFStream read;
      io::File::MustOpenIFStream( read, FILENAME);

      // protein model
      ProteinModel model;

      // chain id for sequence from last char of fasta filename without extension
      const char chain_id( cleaned_key.size() <= 4 || cleaned_key[ 4] == '_' || cleaned_key.size() > 5 ? ' ' : cleaned_key[ 4]);

      model.Insert( factory.ChainFromFastaStream( chain_id, read));
      io::File::CloseClearFStream( read);

      util::ShPtr< ProteinModelData> sp_data( model.GetProteinModelData().HardCopy());
      sp_data->Insert
      (
        ProteinModelData::e_PDBFile,
        util::ShPtr< util::Wrapper< std::string> >( new util::Wrapper< std::string>( FILENAME))
      );
      sp_data->Insert
      (
        ProteinModelData::e_Identification,
        util::ShPtr< util::Wrapper< std::string> >
        (
          new util::Wrapper< std::string>( cleaned_key.substr( 0, std::min( cleaned_key.size(), size_t( 6))))
        )
      );
      model.SetProteinModelData( sp_data);
      return model;
    }

    //! @brief load all extra data available for the model
    //! @param MODEL protein model of interest
    //! @param PREFIX filename of the model, without the pdb/fasta extension
    void ProteinWithCacheStorageFile::LoadBlastSspred( ProteinModel &MODEL, const std::string &PREFIX) const
    {
      biol::BlastProfileHandler::TryReadProfileForProteinModel( MODEL, PREFIX, m_BlastExtension);
      sspred::MethodHandler::ReadAllPredictionsForProteinModel( MODEL, PREFIX, "");
      sspred::PDB::SetEnvironmentTypes( MODEL, true);
      if( MODEL.GetChains().IsEmpty() || MODEL.GetChains().FirstElement()->GetSequence()->GetSize() == size_t( 0))
      {
        return;
      }
      const biol::AABase &first_aa( **( *MODEL.GetChains().FirstElement()->GetSequence()).Begin());
      if
      (
        first_aa.GetSSPrediction( sspred::GetMethods().e_StrideDSSP).IsDefined()
        && first_aa.GetSSPrediction( sspred::GetMethods().e_PALSSE).IsDefined()
        && !first_aa.GetSSPrediction( sspred::GetMethods().e_MAHSSMI).IsDefined()
        &&
        (
          first_aa.GetAAClass() == biol::GetAAClasses().e_AACaCb
          || first_aa.GetAAClass() == biol::GetAAClasses().e_AAComplete
          || first_aa.GetAAClass() == biol::GetAAClasses().e_AABackBone
        )
      )
      {
        sspred::Mahssmi::Calculate( MODEL, true);
      }
    }

    //! @brief helper function to get the key from a filename
    //! @param FILENAME filename of interest
    //! @param SUFFIX suffix that can be removed from the filename
    //! @return key
    std::string ProteinWithCacheStorageFile::GetKey( const std::string &FILENAME, const std::string &SUFFIX)
    {
      // create the basic key by removing the final extension, the full path
      std::string key( FILENAME);
      if( key.find( PATH_SEPARATOR) < std::string::npos)
      {
        key = io::File::RemovePath( key);
      }
      if( util::EndsWith( key, ".gz") || util::EndsWith( key, ".bz2"))
      {
        key = io::File::RemoveLastExtension( key);
      }
      if( !SUFFIX.empty() && util::EndsWith( key, SUFFIX))
      {
        key.erase( key.size() - SUFFIX.size());
      }
      if( util::EndsWith( key, ".fasta") || util::EndsWith( key, ".pdb"))
      {
        key = io::File::RemoveLastExtension( key);
      }
      // remove any trailing '_'
      size_t last_char( key.size() - 1);
      while( last_char > size_t( 3) && key[ last_char] == '_')
      {
        --last_char;
      }
      if( ++last_char != key.size())
      {
        key.erase( last_char);
      }
      if( key.size() < size_t( 5)) // no chain id
      {
        return util::ToLower( key);
      }

      // if a chain id is present, preserve its case for size 5 keys (presumably pdb id)
      return key.size() == size_t( 5) ? util::ToLower( key.substr( 0, 4)) + key.substr( 4) : key;
    }

    //! @brief helper function to determine the total number of residues in a map returned from pdb::Head
    //! @param MAP map, usually obtained from pdb::Head::GetSEQRESProteinChains or pdb::Head::GetMissingResidues
    //! @return the total number of residues in the map
    size_t ProteinWithCacheStorageFile::GetMapSize( const storage::Map< char, storage::List< pdb::ResidueSimple> > &MAP)
    {
      size_t total_size( 0);
      for
      (
        storage::Map< char, storage::List< pdb::ResidueSimple> >::const_iterator itr( MAP.Begin()), itr_end( MAP.End());
        itr != itr_end;
        ++itr
      )
      {
        total_size += itr->second.GetSize();
      }
      return total_size;
    }

    //! @brief helper function to determine the # of residues in a given PDB file from the atom lines
    //! @param ISTREAM input file
    size_t ProteinWithCacheStorageFile::CountResiduesInAtomLines( std::istream &INPUT)
    {
      // keep track of the total # of residues found
      size_t number_aas( 0);

      // create a vector (indexed by chain id) of valid seq ids for that chain
      storage::Vector< storage::Set< int> > valid_pdb_ids( 128);

      // skip everything up until the atom lines
      std::string line;
      while( INPUT.good() && !util::StartsWith( line, pdb::GetLineTypes().ATOM.GetName()))
      {
        std::getline( INPUT, line);
      }

      // get the end column of the occupancy column for the pdb
      const size_t chain_pos( pdb::GetEntryTypes().ATOMChainID->GetStart());
      const size_t seq_id_start( pdb::GetEntryTypes().ATOMResidueSequenceID->GetStart());
      const size_t seq_id_size( pdb::GetEntryTypes().ATOMResidueSequenceID->GetLength());
      const size_t het_three_letter_code_start( pdb::GetEntryTypes().HETATMResidueName->GetStart());
      const size_t seq_id_end( seq_id_start + seq_id_size);

      // temporary string for sequence id
      std::string seq_id_str( seq_id_size, ' ');

      // temporary error stream
      std::ostringstream err_stream;

      // scan each atom line
      while
      (
        util::StartsWith( line, pdb::GetLineTypes().ATOM.GetName())
        ||
        (
          // also allow HETATM entries that correspond to valid amino acid types, including UND
          // sometimes unnatural AAs like MSE are labeled with HETATM label rather than ATOM
          util::StartsWith( line, pdb::GetLineTypes().HETATM.GetName())
          &&
          (
            biol::GetAATypes().AATypeFromThreeLetterCode( line.substr( het_three_letter_code_start, 3)).IsDefined()
            || line.substr( het_three_letter_code_start, 3) == "UND"
          )
        )
      )
      {
        // if the line has all the necessary, members, extract the chain id and sequence id
        if( line.size() > seq_id_end)
        {
          // get the chain id
          const char chain_id( line[ chain_pos]);
          std::copy( line.begin() + seq_id_start, line.begin() + seq_id_end, seq_id_str.begin());
          int seq_id;
          if( util::TryConvertFromString( seq_id, seq_id_str, err_stream))
          {
            // sequence id was converted successfully
            // increment the # of AAs seen so far
            if( valid_pdb_ids( int( chain_id)).Insert( seq_id).second)
            {
              ++number_aas;
            }
          }
        }

        std::getline( INPUT, line);

        // skip empty lines and ANISOU lines
        while( INPUT.good() && ( line.empty() || util::StartsWith( line, pdb::GetLineTypes().ANISOU.GetName())))
        {
          std::getline( INPUT, line);
        }

        // catch the end of the file; in case this is a bad PDB file that does not have a proper END or TER or MASTER line
        if( !INPUT.good())
        {
          break;
        }
      }
      return number_aas;
    }

    //! @brief get the name of the index file for this protein cache storage file
    std::string ProteinWithCacheStorageFile::GetIndexFileName() const
    {
      if( io::DirectoryEntry( m_Directory).IsType( io::Directory::e_File))
      {
        return std::string();
      }
      std::string index_file_name( m_Directory + "bcl");

      // handle PDBs
      if( io::File::GetLastExtension( m_Suffix) == pdb::GetDefaultFileExtension())
      {
        index_file_name += ".seqres.counts";
      }
      else
      {
        // fastas are fast to load, so just read the file into an AASequence
        index_file_name += ".fasta.aa.counts";
      }
      return index_file_name;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_protein_with_mutations_dataset_from_file.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model_with_mutations.h"
#include "biol/bcl_biol_aa_classes.h"
#include "biol/bcl_biol_protein_mutation_set.h"
#include "descriptor/bcl_descriptor_dataset_builder.h"
#include "io/bcl_io_directory_entry.h"
#include "io/bcl_io_file.h"
#include "io/bcl_io_serialization.h"
#include "pdb/bcl_pdb_factory.h"
#include "util/bcl_util_wrapper.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    const util::SiPtr< const util::ObjectInterface> ProteinWithMutationsDatasetFromFile::s_SequenceInstance
    (
      util::Enumerated< model::RetrieveDataSetBase>::AddInstance( new ProteinWithMutationsDatasetFromFile( false))
    );
    const util::SiPtr< const util::ObjectInterface> ProteinWithMutationsDatasetFromFile::s_ProteinInstance
    (
      util::Enumerated< model::RetrieveDataSetBase>::AddInstance( new ProteinWithMutationsDatasetFromFile( true))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor, takes the desired AA class and whether or not to require coordinates
    ProteinWithMutationsDatasetFromFile::ProteinWithMutationsDatasetFromFile( const bool &REQUIRE_COORDINATES) :
      m_ProteinStorage( REQUIRE_COORDINATES),
      m_InvertFilter( false),
      m_FractSelfMutations( 0.0),
      m_Builder( new descriptor::DatasetBuilder< biol::Mutation>())
    {
    }

    //! @brief copy constructor, clones builder
    ProteinWithMutationsDatasetFromFile::ProteinWithMutationsDatasetFromFile( const ProteinWithMutationsDatasetFromFile &PARENT) :
      model::RetrieveDataSetBase( PARENT),
      m_ProteinStorage( PARENT.m_ProteinStorage),
      m_FeatureStartIdToKey( PARENT.m_FeatureStartIdToKey),
      m_FilteredMutations( PARENT.m_FilteredMutations),
      m_InvertFilter( PARENT.m_InvertFilter),
      m_FractSelfMutations( PARENT.m_FractSelfMutations),
      m_Builder
      (
        new descriptor::DatasetBuilder< biol::Mutation>
        (
          PARENT.GetFeatureCode(),
          PARENT.GetResultCode(),
          PARENT.GetIdCode()
        )
      )
    {
    }

    //! @brief Clone function
    //! @return pointer to new ProteinWithMutationsDatasetFromFile
    ProteinWithMutationsDatasetFromFile *ProteinWithMutationsDatasetFromFile::Clone() const
    {
      return new ProteinWithMutationsDatasetFromFile( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &ProteinWithMutationsDatasetFromFile::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns the name used for this class in an object data label
    //! @return the name used for this class in an object data label
    const std::string &ProteinWithMutationsDatasetFromFile::GetAlias() const
    {
      static const std::string s_seqname( "SequenceMutationsDirectory"), s_protname( "ProteinMutationsDirectory");
      return m_ProteinStorage.GetRequireCoordinates() ? s_protname : s_seqname;
    }

    //! @brief Set the code / label for the feature (1st part) of the data set
    //! @param CODE the new code
    void ProteinWithMutationsDatasetFromFile::SelectFeatures( const util::ObjectDataLabel &CODE)
    {
      model::RetrieveDataSetBase::SelectFeatures( CODE);
      // this is not strictly necessary, but it allows a user to ask for help over the command line for this retriever
      util::Implementation< descriptor::Base< biol::Mutation, float> > property( GetFeatureCode());
      m_Builder->SetFeatureCode( GetFeatureCode());
    }

    //! @brief Set the code / label for the result (2nd part) of the data set
    //! @param CODE the new code
    void ProteinWithMutationsDatasetFromFile::SelectResults( const util::ObjectDataLabel &CODE)
    {
      model::RetrieveDataSetBase::SelectResults( CODE);
      m_FeatureStartIdToKey.Reset();
      m_Builder->SetResultsCode( GetResultCode());
      const descriptor::Type type( m_Builder->GetType());
      if( type.GetDimension() == size_t( 0))
      {
        // add up the size of each, convoluted by the type
        size_t key_number( 0);
        for( const size_t n_proteins( m_ProteinStorage.GetSize()); key_number < n_proteins; ++key_number)
        {
          m_FeatureStartIdToKey[ key_number] = key_number;
        }
        m_FeatureStartIdToKey[ key_number] = key_number;
      }
      else
      {
        // retrieve the size of each key
        storage::Vector< std::string> all_keys( m_ProteinStorage.GetAllKeys());
        // add up the size of each, convoluted by the type
        size_t total_features( 0), key_number( 0);
        util::GetLogger() << "Computing total # of features\n";
        io::IFStream input;
        for
        (
          storage::Vector< std::string>::const_iterator itr( all_keys.Begin()), itr_end( all_keys.End());
          itr != itr_end;
          ++itr, ++key_number
        )
        {
          io::File::MustOpenIFStream( input, io::File::RemoveLastExtension( *itr) + m_Suffix);
          const size_t n_new_features
          (
            type.GetNumberFeatures( util::StringLineListFromIStream( input).GetSize() * ( m_FractSelfMutations ? 2 : 1))
          );
          if( n_new_features)
          {
            m_FeatureStartIdToKey[ total_features] = key_number;
            total_features += n_new_features;
            util::GetLogger().LogStatus
            (
              "File #" + util::Format()( key_number) + " / " + util::Format()( all_keys.GetSize())
              + " (" + *itr + "), # features: " + util::Format()( n_new_features)
              + "; total features so far: " + util::Format()( total_features)
            );
          }
          io::File::CloseClearFStream( input);
        }
        m_FeatureStartIdToKey[ total_features] = key_number;
      }
    }

    //! @brief Set the code / label for the ids (3rd part) of the data set
    //! @param CODE the new code
    void ProteinWithMutationsDatasetFromFile::SelectIds( const util::ObjectDataLabel &CODE)
    {
      model::RetrieveDataSetBase::SelectIds( CODE);
      // this is not strictly necessary, but it allows a user to ask for help over the command line for this retriever
      util::Implementation< descriptor::Base< biol::Mutation, char> > property( GetIdCode());
      m_Builder->SetIdCode( CODE);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Get the code / label set for the feature (1st part) of the data set with sizes of each property
    //! @return the code / label for the feature (1st part) of the data set with sizes of each property
    //! the feature code set
    model::FeatureLabelSet ProteinWithMutationsDatasetFromFile::GetFeatureLabelsWithSizes() const
    {
      return m_Builder.IsDefined() ? m_Builder->GetFeatureCode().GetLabelsWithSizes() : model::FeatureLabelSet();
    }

    //! @brief Get the code / label for the result (2nd part) of the data set with sizes of each property
    //! @return the code / label for the result (2nd part) of the data set with sizes of each property
    //! the feature code set
    model::FeatureLabelSet ProteinWithMutationsDatasetFromFile::GetResultCodeWithSizes() const
    {
      return m_Builder.IsDefined() ? m_Builder->GetResultCode().GetLabelsWithSizes() : model::FeatureLabelSet();
    }

    //! @brief Get the code / label for the ids of the data set with sizes of each property
    //! @return the code / label for the ids of the data set with sizes of each property
    //! the feature code set
    model::FeatureLabelSet ProteinWithMutationsDatasetFromFile::GetIdCodeWithSizes() const
    {
      return m_Builder.IsDefined() ? m_Builder->GetIdCode().GetLabelsWithSizes() : model::FeatureLabelSet();
    }

    //! @brief generate dataset from a set of ranges
    //! @return generated dataset
    util::ShPtr< descriptor::Dataset> ProteinWithMutationsDatasetFromFile::GenerateDataSet()
    {
      pdb::Factory::GetFlagConvertToNaturalAAType()->SetFlag();

      // determine the total size of the data set
      const size_t total_dataset_size( m_FeatureStartIdToKey.ReverseBegin()->first);

      if( !m_Builder.IsDefined())
      {
        m_Builder =
          util::ShPtr< descriptor::DatasetBuilder< biol::Mutation> >
          (
            new descriptor::DatasetBuilder< biol::Mutation>( GetFeatureCode(), GetResultCode(), GetIdCode())
          );
      }

      // dataset to hold all results
      const size_t nominal_size( GetNominalSize());
      util::ShPtr< descriptor::Dataset> dataset_sp
      (
        new descriptor::Dataset
        (
          nominal_size,
          GetFeatureLabelsWithSizes(),
          GetResultCodeWithSizes(),
          GetIdCodeWithSizes()
        )
      );
      linal::MatrixReference< float> features( dataset_sp->GetFeaturesReference());
      linal::MatrixReference< float> results( dataset_sp->GetResultsReference());
      linal::MatrixReference< char> ids( dataset_sp->GetIdsReference());

      const size_t nr_features
      (
        GenerateDataSubsetGivenBuilder
        (
          math::Range< size_t>( 0, total_dataset_size),
          features,
          results,
          ids,
          0,
          *m_Builder
        )
      );

      // remove unused rows
      dataset_sp->ShrinkRows( nr_features);

      // return the generated dataset
      return dataset_sp;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief get the number of partitions requested by the user, along with the partition ids
    //! @return the number of partitions requested by the user, along with the partition ids
    storage::Pair< size_t, math::RangeSet< size_t> > ProteinWithMutationsDatasetFromFile::GetNumberPartitionsAndIds() const
    {
      return storage::Pair< size_t, math::RangeSet< size_t> >( 1, math::RangeSet< size_t>( math::Range< size_t>( 0, 0)));
    }

    //! @brief return parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer ProteinWithMutationsDatasetFromFile::GetSerializer() const
    {
      io::Serializer member_data( m_ProteinStorage.GetSerializer());
      member_data.SetClassDescription
      (
        std::string
        (
          m_ProteinStorage.GetRequireCoordinates()
          ? "Calculates descriptors related to mutations of proteins"
          : "Calculates descriptors related to mutations of protein sequences"
        ) +
        " from a directory or subdirectory"
      );
      member_data.AddInitializer
      (
        "mutation extension",
        "file extension for mutation file. Replacing .pdb/.fasta with this value should give us the mutation file",
        io::Serialization::GetAgent( &m_Suffix),
        ".mutants.txt"
      );
      member_data.AddOptionalInitializer
      (
        "filter",
        "mutations to filter, formatted as protein key to set of mutations to filter, e.g. : (a1q1=(H176G))",
        io::Serialization::GetAgent( &m_FilteredMutations)
      );
      member_data.AddInitializer
      (
        "invert filter",
        "Whether to invert the sense of the filter. If true, only the mutations given in the filter will be returned",
        io::Serialization::GetAgent( &m_InvertFilter),
        "False"
      );

      member_data.AddInitializer
      (
        "add self mutation fraction",
        "Fraction of mutations for which the synonymous mutations should be added to help the model learn that native is native",
        io::Serialization::GetAgentWithRange( &m_FractSelfMutations, 0.0, 1.0),
        "0.0"
      );
      return member_data;
    } // GetParameters

    //! @brief get the nominal (e.g. best estimate without generating the entire dataset) size of the dataset
    //! @return the nominal (e.g. best estimate without generating the entire dataset) size of the dataset
    size_t ProteinWithMutationsDatasetFromFile::GetNominalSize() const
    {
      // get the last value out of the map, if there are any values
      if( m_FeatureStartIdToKey.IsEmpty())
      {
        BCL_MessageCrt( "Warning, called GetNominalSize before calling SelectResults");
        return 0;
      }

      return m_FeatureStartIdToKey.ReverseBegin()->first;
    }

    //! @brief load a range of data from the dataset
    //! @param SUBSET the range of data to load
    //! @param FEATURES_STORAGE where to store features that are loaded, must be large enough to hold the subset without resizing
    //! @param RESULTS_STORAGE where to store the corresponding results, must be large enough to hold the subset without resizing
    //! @param START_FEATURE_NUMBER position to store the first feature in FEATURES_STORAGE
    //! @return # of features actually loaded
    //! Note: Implementations should overload this and SupportsEfficientSubsetLoading together
    size_t ProteinWithMutationsDatasetFromFile::GenerateDataSubset
    (
      const math::Range< size_t> &SUBSET,
      linal::MatrixInterface< float> &FEATURES_STORAGE,
      linal::MatrixInterface< float> &RESULTS_STORAGE,
      linal::MatrixInterface< char> &IDS_STORAGE,
      const size_t &START_FEATURE_NUMBER
    )
    {
      if( !m_Builder.IsDefined())
      {
        m_Builder =
          util::ShPtr< descriptor::DatasetBuilder< biol::Mutation> >
          (
            new descriptor::DatasetBuilder< biol::Mutation>( GetFeatureCode(), GetResultCode(), GetIdCode())
          );
      }

      // generate a dataset of protein codes from the ranges given in the range set
      return
        GenerateDataSubsetGivenBuilder
        (
          SUBSET,
          FEATURES_STORAGE,
          RESULTS_STORAGE,
          IDS_STORAGE,
          START_FEATURE_NUMBER,
          *m_Builder
        );
    }

    //! @brief load a range of data from the dataset, given a particular dataset builder
    //! @param SUBSET the range of data to load
    //! @param FEATURES_STORAGE where to store features that are loaded, must be large enough to hold the subset without resizing
    //! @param RESULTS_STORAGE where to store the corresponding results, must be large enough to hold the subset without resizing
    //! @param START_FEATURE_NUMBER position to store the first feature in FEATURES_STORAGE
    //! @param BUILDER the dataset builder to use
    //! @return # of features actually loaded
    size_t ProteinWithMutationsDatasetFromFile::GenerateDataSubsetGivenBuilder
    (
      const math::Range< size_t> &SUBSET,
      linal::MatrixInterface< float> &FEATURES_STORAGE,
      linal::MatrixInterface< float> &RESULTS_STORAGE,
      linal::MatrixInterface< char> &IDS_STORAGE,
      const size_t &START_FEATURE_NUMBER,
      descriptor::DatasetBuilder< biol::Mutation> &BUILDER
    )
    {
      // retrieve the protein ensemble
      util::ShPtrVector< biol::ProteinMutationSet> models;
      size_t start_feature( 0), total_size( 0);

      BCL_Assert
      (
        BUILDER.GetFeatureSize() == FEATURES_STORAGE.GetNumberCols(),
        "Wrong column size for features " + util::Format()( BUILDER.GetFeatureSize())
        + " storage: " + util::Format()( FEATURES_STORAGE.GetNumberCols())
      );
      BCL_Assert( BUILDER.GetResultSize() == RESULTS_STORAGE.GetNumberCols(), "Wrong column size for results");
      BCL_Assert( BUILDER.GetIdSize() == IDS_STORAGE.GetNumberCols(), "Wrong column size for ids");

      if( BUILDER.GetType().GetDimension() == size_t( 0))
      {
        const math::Range< size_t> closed_range( SUBSET.CloseBorders());
        auto temp_models( m_ProteinStorage.RetrieveEnsemble( closed_range));
        models.AllocateMemory( temp_models.GetSize());
        for
        (
          auto itr_tmp_models( temp_models.Begin()), itr_tmp_models_end( temp_models.End());
          itr_tmp_models != itr_tmp_models_end;
          ++itr_tmp_models
        )
        {
          models.PushBack
          (
            util::ShPtr< biol::ProteinMutationSet>
            (
              new biol::ProteinMutationSet
              (
                **itr_tmp_models,
                m_ProteinStorage.GetRequireCoordinates(),
                GetMutationsFromProteinModel( **itr_tmp_models)
              )
            )
          );
        }
        total_size = models.GetSize();
      }
      else
      {
        math::Range< size_t> closed_range( SUBSET.CloseBorders());
        storage::Map< size_t, size_t>::const_iterator itr_lower( m_FeatureStartIdToKey.LowerBound( closed_range.GetMin()));
        storage::Map< size_t, size_t>::const_iterator itr_upper( m_FeatureStartIdToKey.LowerBound( closed_range.GetMax()));
        if( itr_lower == m_FeatureStartIdToKey.End())
        {
          return 0;
        }
        else if( itr_lower->first > closed_range.GetMin())
        {
          --itr_lower;
        }
        if( itr_upper == m_FeatureStartIdToKey.End())
        {
          --itr_upper;
          closed_range = math::Range< size_t>( closed_range.GetMin(), itr_upper->first - 1);
        }
        total_size = closed_range.GetWidth() + 1;
        const math::Range< size_t> model_range
        (
          math::RangeBorders::e_LeftClosed,
          itr_lower->second,
          itr_upper->second,
          math::RangeBorders::e_RightOpen
        );
        auto temp_models( m_ProteinStorage.RetrieveEnsemble( model_range));
        models.AllocateMemory( temp_models.GetSize());
        for
        (
          auto itr_tmp_models( temp_models.Begin()), itr_tmp_models_end( temp_models.End());
          itr_tmp_models != itr_tmp_models_end;
          ++itr_tmp_models
        )
        {
          models.PushBack
          (
            util::ShPtr< biol::ProteinMutationSet>
            (
              new biol::ProteinMutationSet
              (
                **itr_tmp_models,
                m_ProteinStorage.GetRequireCoordinates(),
                GetMutationsFromProteinModel( **itr_tmp_models)
              )
            )
          );
        }

        start_feature = closed_range.GetMin() - itr_lower->first;
      }
      iterate::Generic< const descriptor::SequenceInterface< biol::Mutation> >
        model_iterator( models.Begin(), models.End());
      descriptor::Dataset dataset( BUILDER( model_iterator, start_feature, total_size));
      // copy the code vectors into the matrices
      size_t data_counter( START_FEATURE_NUMBER);
      std::copy
      (
        dataset.GetFeaturesReference().Begin(),
        dataset.GetFeaturesReference().End(),
        FEATURES_STORAGE[ data_counter]
      );
      // copy the result
      std::copy
      (
        dataset.GetResultsReference().Begin(),
        dataset.GetResultsReference().End(),
        RESULTS_STORAGE[ data_counter]
      );
      // copy the ids
      std::copy
      (
        dataset.GetIdsReference().Begin(),
        dataset.GetIdsReference().End(),
        IDS_STORAGE[ data_counter]
      );

      // return the # of features that were actually loaded
      return dataset.GetSize();
    }

    storage::Vector< biol::Mutation> ProteinWithMutationsDatasetFromFile::GetMutationsFromProteinModel
    (
      const ProteinModel &MODEL
    ) const
    {
      // Get the filename
      util::ShPtr< util::Wrapper< std::string> > sp_filename_wrapper
      (
        MODEL.GetProteinModelData()->GetData( ProteinModelData::e_PDBFile)
      );

      // Remove the last extension
      std::string basename
      (
        io::File::RemoveLastExtension( io::File::RemoveCompressionExtension( sp_filename_wrapper->GetData()))
      );
      io::DirectoryEntry entry( basename + m_Suffix);
      storage::Vector< biol::Mutation> mutations;
      io::IFStream input;
      io::File::MustOpenIFStream( input, basename + m_Suffix);
      if( entry.DoesExist())
      {
        storage::Set< biol::Mutation> empty_set;
        auto itr_filter_map( m_FilteredMutations.Find( io::File::RemovePath( basename)));
        const storage::Set< biol::Mutation> &filtered_mutations
        (
          itr_filter_map == m_FilteredMutations.End()
          ? empty_set
          : itr_filter_map->second
        );
        storage::Vector< std::string> mutation_strs( util::StringListFromIStream( input));
        for( auto itr( mutation_strs.Begin()), itr_end( mutation_strs.End()); itr != itr_end; ++itr)
        {
          biol::Mutation candidate_mutation( biol::Mutation::FromString( util::SplitString( util::TrimString( *itr))( 0)));
          if( filtered_mutations.Contains( candidate_mutation) == m_InvertFilter)
          {
            mutations.PushBack( candidate_mutation);
            if( m_FractSelfMutations && random::GetGlobalRandom().Double() < m_FractSelfMutations)
            {
              biol::Mutation self_mut
              (
                candidate_mutation.GetResidueNumber(),
                candidate_mutation.GetNativeType(),
                candidate_mutation.GetNativeType()
              );
              if( mutations.Find( self_mut) >= mutations.GetSize())
              {
                mutations.PushBack( self_mut);
              }
            }
          }
        }
      }
      else
      {
        BCL_MessageCrt( "Mutations file: " + basename + m_Suffix + " not found, skipping!");
      }
      io::File::CloseClearFStream( input);
      return mutations;
    }

    //! @brief Set the members of this property from the given LABEL
    //! @param LABEL the label to parse
    //! @param ERR_STREAM stream to write out errors to
    bool ProteinWithMutationsDatasetFromFile::ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
    {
      return m_ProteinStorage.ReadInitializerSuccessHook( LABEL, ERR_STREAM);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_quality_batch.h"

// includes from bcl - sorted alphabetically
#include "align/bcl_align_alignment_node.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_quality.h"
#include "contact/bcl_contact_order.h"
#include "contact/bcl_contact_recovery.h"
#include "fold/bcl_fold_default_flags.h"
#include "math/bcl_math_sum_function.h"
#include "score/bcl_score_protein_model_topology.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> QualityBatch::s_Instance
    (
      GetObjectInstances().AddInstance( new QualityBatch())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    QualityBatch::QualityBatch() :
      m_Qualities(),
      m_AtomTypes(),
      m_QualitySuffix( ""),
      m_UseReadableNames( false)
    {
    }

    //! @brief constructor from set of qualities and set of atom types
    //! @param QUALITIES set of qualities to calculate
    //! @param ATOM_TYPES set of atom types to be used
    //! @param QUALITY_SUFFIX suffix to add to end of quality names
    //! @param USE_READABLE_NAMES use readable names (for nice table output)
    QualityBatch::QualityBatch
    (
      const storage::Set< quality::Measure> &QUALITIES,
      const storage::Set< biol::AtomType> &ATOM_TYPES,
      const std::string &QUALITY_SUFFIX,
      const bool USE_READABLE_NAMES
    ) :
      m_Qualities( QUALITIES),
      m_AtomTypes( ATOM_TYPES),
      m_QualitySuffix( QUALITY_SUFFIX),
      m_UseReadableNames( USE_READABLE_NAMES)
    {
      // if the given quality has GDT_TS, add 1A,2A,4A,8A automatically
      if( m_Qualities.Contains( quality::GetMeasures().e_GDT_TS))
      {
        m_Qualities.InsertElement( quality::GetMeasures().e_GDT_1A);
        m_Qualities.InsertElement( quality::GetMeasures().e_GDT_2A);
        m_Qualities.InsertElement( quality::GetMeasures().e_GDT_4A);
        m_Qualities.InsertElement( quality::GetMeasures().e_GDT_8A);
      }
    }

    //! @brief Clone function
    //! @return pointer to new QualityBatch
    QualityBatch *QualityBatch::Clone() const
    {
      return new QualityBatch( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &QualityBatch::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief static function to create the names of columns to be generated from the qualities
    //! @param QUALITIES Set of qualities of interest
    //! @return vector of string that correspond to column names
    storage::Vector< std::string> QualityBatch::ColumnNamesFromQualities
    (
      const storage::Set< quality::Measure> &QUALITIES
    )
    {
      // initialize column names
      storage::Vector< std::string> column_names
      (
        storage::Vector< std::string>::Create( "co", "rco_seq", "rco_aas", "cr6", "cr12", "cr24").Append
        (
          storage::Vector< std::string>::Create( "cr6_mcc", "cr12_mcc", "cr24_mcc", "topology_f").Append
          (
            storage::Vector< std::string>::Create( "topology_tpr", "topology_ppv", "completeness")
          )
        )
      );

      // make a copy of the qualities
      storage::Set< quality::Measure> qualities( QUALITIES);

      // if it has GDT_TS
      if( qualities.Contains( quality::GetMeasures().e_GDT_TS))
      {
        // insert 1A, 2A, 4A and 8A
        qualities.InsertElement( quality::GetMeasures().e_GDT_1A);
        qualities.InsertElement( quality::GetMeasures().e_GDT_2A);
        qualities.InsertElement( quality::GetMeasures().e_GDT_4A);
        qualities.InsertElement( quality::GetMeasures().e_GDT_8A);
      }

      // iterate over measures
      for
      (
        storage::Set< quality::Measure>::const_iterator itr( qualities.Begin()), itr_end( qualities.End());
        itr != itr_end; ++itr
      )
      {
        // insert into column names
        column_names.PushBack( itr->GetName());

        // if this is a RMSD measure
        if
        (
          *itr == quality::GetMeasures().e_RMSD ||
          *itr == quality::GetMeasures().e_RMSD_NoSuperimposition ||
          *itr == quality::GetMeasures().e_RMSD_XYSuperimposition
        )
        {
          // insert also this normalized column name
          column_names.PushBack( itr->GetName() + "100");
        }
        if
        (
          *itr >= quality::GetMeasures().e_GDT_TS && *itr <= quality::GetMeasures().e_GDT_8A
        )
        {
          // also insert the the normalized names for these measures
          column_names.PushBack( itr->GetName() + '_' + "norm");
          column_names.PushBack( itr->GetName() + "_sse_norm");
        }
      }

      // end
      return column_names;
    }

    //! @brief operator calculating the batch of qualities for the given model
    //! @param PROTEIN_MODEL protein model for which the qualities will be calculated
    //! @return list of pairs of quality names and values for the given model
    storage::List< storage::Pair< std::string, double> > QualityBatch::operator()
    (
      const ProteinModel &PROTEIN_MODEL
    ) const
    {
      // initialize boolean to hold whether cache should be used depending on the corresponding command line flag
      static const bool cache( true);

      // construct static object for calculating contact orders
      static const contact::Order co( contact::Order::e_Absolute, "co", cache);
      static const contact::Order rco_seq( contact::Order::e_RelativeSequenceLength, "rco_seq", cache);
      static const contact::Order rco_aas( contact::Order::e_RelativeAAsUsed, "rco_aas", cache);

      // construct static objects for calculating contact recovery
      static const contact::Recovery cr6( 6);
      static const contact::Recovery cr12( 12);
      static const contact::Recovery cr24( 24);
      static const contact::Recovery cr6_mcc( 6, math::ContingencyMatrixMeasures::e_MatthewsCorrelationCoefficient);
      static const contact::Recovery cr12_mcc( 12, math::ContingencyMatrixMeasures::e_MatthewsCorrelationCoefficient);
      static const contact::Recovery cr24_mcc( 24, math::ContingencyMatrixMeasures::e_MatthewsCorrelationCoefficient);

      // construct static object for topology score
      static const score::ProteinModelTopology topology_f( score::ProteinModelTopology::score_f);
      static const score::ProteinModelTopology topology_tpr( score::ProteinModelTopology::score_tpr);
      static const score::ProteinModelTopology topology_ppv( score::ProteinModelTopology::score_ppv);

      // initialize the storage list of pairs
      storage::List< storage::Pair< std::string, double> > results_list;

      // insert the contact order values
      results_list.PushBack( storage::Pair< std::string, double>( "co" + m_QualitySuffix, co( PROTEIN_MODEL)));
      results_list.PushBack( storage::Pair< std::string, double>( "rco_seq" + m_QualitySuffix, rco_seq( PROTEIN_MODEL)));
      results_list.PushBack( storage::Pair< std::string, double>( "rco_aas" + m_QualitySuffix, rco_aas( PROTEIN_MODEL)));

      // get the native model data
      util::ShPtr< ProteinModel> sp_native_model
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( ProteinModelData::e_NativeFilteredModel)
      );

      // calculate and insert contact recoveries and topology scores, if there is not native model then insert nans
      results_list.PushBack
      (
        storage::Pair< std::string, double>
        (
          "cr6" + m_QualitySuffix,
          sp_native_model.IsDefined() ? cr6( *sp_native_model, PROTEIN_MODEL) : util::GetUndefinedDouble()
        )
      );
      results_list.PushBack
      (
        storage::Pair< std::string, double>
        (
          "cr12" + m_QualitySuffix,
          sp_native_model.IsDefined() ? cr12( *sp_native_model, PROTEIN_MODEL) : util::GetUndefinedDouble()
        )
      );
      results_list.PushBack
      (
        storage::Pair< std::string, double>
        (
          "cr24" + m_QualitySuffix,
          sp_native_model.IsDefined() ? cr24( *sp_native_model, PROTEIN_MODEL) : util::GetUndefinedDouble()
        )
      );
      results_list.PushBack
      (
        storage::Pair< std::string, double>
        (
          "cr6_mcc" + m_QualitySuffix,
          sp_native_model.IsDefined() ? cr6_mcc( *sp_native_model, PROTEIN_MODEL) : util::GetUndefinedDouble()
        )
      );
      results_list.PushBack
      (
        storage::Pair< std::string, double>
        (
          "cr12_mcc" + m_QualitySuffix,
          sp_native_model.IsDefined() ? cr12_mcc( *sp_native_model, PROTEIN_MODEL) : util::GetUndefinedDouble()
        )
      );
      results_list.PushBack
      (
        storage::Pair< std::string, double>
        (
          "cr24_mcc" + m_QualitySuffix,
          sp_native_model.IsDefined() ? cr24_mcc( *sp_native_model, PROTEIN_MODEL) : util::GetUndefinedDouble()
        )
      );
      results_list.PushBack
      (
        storage::Pair< std::string, double>
        (
          "topology_f",
          sp_native_model.IsDefined() ? topology_f( *sp_native_model, PROTEIN_MODEL) : util::GetUndefinedDouble()
        )
      );
      results_list.PushBack
      (
        storage::Pair< std::string, double>
        (
          "topology_tpr",
          sp_native_model.IsDefined() ? topology_tpr( *sp_native_model, PROTEIN_MODEL) : util::GetUndefinedDouble()
        )
      );
      results_list.PushBack
      (
        storage::Pair< std::string, double>
        (
          "topology_ppv",
          sp_native_model.IsDefined() ? topology_ppv( *sp_native_model, PROTEIN_MODEL) : util::GetUndefinedDouble()
        )
      );

      // construct alignments for computing RMSDs
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > initial_alignments;
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > filtered_alignments;

      // get native model and "SSE-only" model
      util::SiPtr< const ProteinModel> native_model
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( ProteinModelData::e_NativeModel)
      );
      util::SiPtr< const ProteinModel> filtered_model
      (
        PROTEIN_MODEL.GetProteinModelData()->GetData( ProteinModelData::e_NativeFilteredModel)
      );

      // compute alignments
      if( native_model.IsDefined())
      {
        initial_alignments =
          Quality::CreateAlignmentProteinModels( *native_model, PROTEIN_MODEL);
        filtered_alignments =
          Quality::CreateAlignmentProteinModels( *filtered_model, PROTEIN_MODEL);
      }
      else
      {
        initial_alignments = Quality::CreateAlignmentProteinModelSequencesToSSEs( PROTEIN_MODEL);
        filtered_alignments = Quality::CreateAlignmentFromProteinModelSSEs( PROTEIN_MODEL);
      }

      // remove any assignments in the alignment where the template residues are undefined
      // this can happen if PDB has undefined coordinates. These residues have to be removed because
      // if the evaluated model is a Rosetta model, or a BCL::Fold model generated using predicted pool, the model
      // can actually have coordinates for these residues which are undefined in the template model, which in turn
      // can cause the completeness value to be wrong.
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > alignments, sse_alignments;

      // iterate over the initial_alignments
      for
      (
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::const_iterator
          align_itr( initial_alignments.Begin()), align_itr_end( initial_alignments.End());
        align_itr != align_itr_end; ++align_itr
      )
      {
        alignments[ align_itr->first] =
          util::ShPtr< align::AlignmentNode< biol::AABase> >
          (
            new align::AlignmentNode< biol::AABase>
            (
              Quality::RemoveUndefinedTemplateAminoAcidsFromAlignment( *align_itr->second, m_AtomTypes)
            )
          );
      }
      // iterate over the initial_alignments
      for
      (
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::const_iterator
          align_itr( filtered_alignments.Begin()), align_itr_end( filtered_alignments.End());
        align_itr != align_itr_end; ++align_itr
      )
      {
        sse_alignments[ align_itr->first] =
          util::ShPtr< align::AlignmentNode< biol::AABase> >
          (
            new align::AlignmentNode< biol::AABase>
            (
              Quality::RemoveUndefinedTemplateAminoAcidsFromAlignment( *align_itr->second, m_AtomTypes)
            )
          );
      }

      // append the qualities to the list
      results_list.Append( QualitiesFromAlignment( alignments, filtered_alignments));

      // end
      return results_list;
    }

    //! @brief operator calculating the batch of qualities for the two models
    //! @param PROTEIN_MODEL_A protein model for which the qualities will be calculated
    //! @param PROTEIN_MODEL_B protein model for which the qualities will be calculated
    //! @return list of pairs of quality names and values for the given models
    storage::List< storage::Pair< std::string, double> > QualityBatch::operator()
    (
      const ProteinModel &PROTEIN_MODEL_A,
      const ProteinModel &PROTEIN_MODEL_B
    ) const
    {
      // get the alignment for the SSE residues
      const storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > initial_alignments
      (
        Quality::CreateAlignmentProteinModels( PROTEIN_MODEL_A, PROTEIN_MODEL_B)
      );

      // remove any assignments in the alignment where the template residues are undefined
      // this can happen if PDB has undefined coordinates. These residues have to be removed because
      // if the evaluated model is a Rosetta model, or a BCL::Fold model generated using predicted pool, the model
      // can actually have coordinates for these residues which are undefined in the template model, which in turn
      // can cause the completeness value to be wrong.
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > alignments;

      // iterate over the initial_alignments
      for
      (
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::const_iterator
          align_itr( initial_alignments.Begin()), align_itr_end( initial_alignments.End());
        align_itr != align_itr_end; ++align_itr
      )
      {
        alignments[ align_itr->first] =
          util::ShPtr< align::AlignmentNode< biol::AABase> >
          (
            new align::AlignmentNode< biol::AABase>
            (
              Quality::RemoveUndefinedTemplateAminoAcidsFromAlignment( *align_itr->second, m_AtomTypes)
            )
          );
      }

      return QualitiesFromAlignment( alignments, alignments);
    }

    //! @brief construct a table that has protein distance measures to be append to a score table
    //! @param PROTEIN_MODEL to be used for measure calculations
    //! @return storage table of measures
    storage::Table< double> QualityBatch::ConstructTable
    (
      const ProteinModel &PROTEIN_MODEL
    ) const
    {
      return ConstructTable( operator()( PROTEIN_MODEL));
    }

    //! @brief construct a table that has protein distance measures to be append to a score table
    //! @param PROTEIN_MODEL_A protein model for which the qualities will be calculated
    //! @param PROTEIN_MODEL_B protein model for which the qualities will be calculated
    //! @return storage table of measures
    storage::Table< double> QualityBatch::ConstructTable
    (
      const ProteinModel &PROTEIN_MODEL_A,
      const ProteinModel &PROTEIN_MODEL_B
    ) const
    {
      return ConstructTable( operator()( PROTEIN_MODEL_A, PROTEIN_MODEL_B));
    }

    //! @brief construct a table that has only the completeness estimate without checking for coordinates
    //! @param PROTEIN_MODEL to be used
    //! @return storage table with completeness estimate
    storage::Table< double> QualityBatch::ContructTableWithCompletenessOnly( const ProteinModel &PROTEIN_MODEL) const
    {
      // get the alignments of sequences
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >
        align_seq( Quality::CreateAlignmentFromProteinModelSequences( PROTEIN_MODEL));

      // get the alignments of SSEs
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >
        align_sses( Quality::CreateAlignmentFromProteinModelSSEs( PROTEIN_MODEL));

      // calculate AA count in sequences and SSEs
      size_t total_count( 0), sse_count( 0); // needed values to calculate the completeness
      for
      (
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::const_iterator
          align_seq_itr( align_seq.Begin()), align_seq_itr_end( align_seq.End()),
          align_sses_itr( align_sses.Begin()), align_sses_itr_end( align_seq.End());
        align_seq_itr != align_seq_itr_end && align_sses_itr != align_sses_itr_end;
        ++align_seq_itr, ++align_sses_itr
      )
      {
        total_count += align_seq_itr->second->GetSize();
        sse_count += align_sses_itr->second->GetSize();
      }

      const double completeness( ( double)( sse_count) / total_count); // calculate completeness

      // initialize the storage list of pairs and insert the completeness value
      storage::List< storage::Pair< std::string, double> > results;
      results.PushBack( storage::Pair< std::string, double>( "completeness_estimate" + m_QualitySuffix, completeness));

      return ConstructTable( results);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &QualityBatch::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Qualities, ISTREAM);
      io::Serialize::Read( m_AtomTypes, ISTREAM);
      io::Serialize::Read( m_QualitySuffix, ISTREAM);
      io::Serialize::Read( m_UseReadableNames, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &QualityBatch::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Qualities, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AtomTypes, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_QualitySuffix, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_UseReadableNames, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculates a qualities from an alignment
    //! @param ALIGNMENTS the alignments from which the qualities will be calculated
    //! @return list of pairs of string indicating the quality and double indicating the quality value
    storage::List< storage::Pair< std::string, double> > QualityBatch::QualitiesFromAlignment
    (
      const storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > &ALIGNMENTS,
      const storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > &SSE_ALIGNMENTS
    ) const
    {
      // initialize coordinates vector
      storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > coordinates_pair;

      // initialize counters
      size_t total_ctr( 0);
      size_t pruned_ctr( 0);
      size_t filtered_ctr( 0);

      // iterate through the map
      for
      (
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::const_iterator
          align_itr( ALIGNMENTS.Begin()), sse_alignments( SSE_ALIGNMENTS.Begin()), align_itr_end( ALIGNMENTS.End());
        align_itr != align_itr_end; ++align_itr
      )
      {
        // get the pruned alignment where gaps and amino acids with undefined coordinates are removed
        const align::AlignmentNode< biol::AABase> pruned_alignment
        (
          Quality::RemoveUndefinedAminoAcidsFromAlignment( *( align_itr->second), m_AtomTypes)
        );

        // update counters
        total_ctr += align_itr->second->GetSize();
        pruned_ctr += pruned_alignment.GetSize();
        filtered_ctr += sse_alignments->second->GetSize();

        // get the common coordinates
        const storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > this_coordinates_pair
        (
          Quality::CoordinatesFromAlignment( pruned_alignment, m_AtomTypes)
        );

        // update the total coordinates
        coordinates_pair.First().Append( this_coordinates_pair.First());
        coordinates_pair.Second().Append( this_coordinates_pair.Second());
      }

      // initialize the storage list of pairs
      storage::List< storage::Pair< std::string, double> > results_list;

      // get the ratio of completeness
      const double completeness( double( pruned_ctr) / double( total_ctr));
      const double sse_completeness( double( filtered_ctr) / double( total_ctr));
      const double sse_ratio( filtered_ctr ? completeness / sse_completeness : 0.0);

      // insert the completeness
      results_list.PushBack( storage::Pair< std::string, double>( "completeness" + m_QualitySuffix, completeness));

      // remember whether it has GDT_TS
      const bool has_gdt_ts( m_Qualities.Contains( quality::GetMeasures().e_GDT_TS));

      // iterate over measures
      for
      (
        storage::Set< quality::Measure>::const_iterator
          measure_itr( m_Qualities.Begin()), measure_itr_end( m_Qualities.End());
        measure_itr != measure_itr_end; ++measure_itr
      )
      {
        // if a GDT measure
        if
        (
          *measure_itr >= quality::GetMeasures().e_GDT_TS && *measure_itr <= quality::GetMeasures().e_GDT_8A
        )
        {
          // if it has GDT_TS
          if( has_gdt_ts)
          {
            // if gdt_ts do calculation for all sub GDT measures, otherwise nothing needs to be done
            if( *measure_itr == quality::GetMeasures().e_GDT_TS)
            {
              // calculate individual values and then calculate GDT_TS by averaging to avoid redundant calculations
              // since GDT calculation can be relatively expensive
              const double gdt_1A( ( *quality::GetMeasures().e_GDT_1A)->CalculateMeasure( coordinates_pair.First(), coordinates_pair.Second()));
              const double gdt_2A( ( *quality::GetMeasures().e_GDT_2A)->CalculateMeasure( coordinates_pair.First(), coordinates_pair.Second()));
              const double gdt_4A( ( *quality::GetMeasures().e_GDT_4A)->CalculateMeasure( coordinates_pair.First(), coordinates_pair.Second()));
              const double gdt_8A( ( *quality::GetMeasures().e_GDT_8A)->CalculateMeasure( coordinates_pair.First(), coordinates_pair.Second()));
              const double gdt_ts( ( gdt_1A + gdt_2A + gdt_4A + gdt_8A) / 4.0);

              // insert into the results_vector with the name and the value
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_TS->GetName() + m_QualitySuffix, gdt_ts)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_TS->GetName() + '_' + "norm" + m_QualitySuffix, gdt_ts * completeness)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_TS->GetName() + '_' + "sse_norm" + m_QualitySuffix, gdt_ts * sse_ratio)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_1A->GetName() + m_QualitySuffix, gdt_1A)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_1A->GetName() + '_' + "norm" + m_QualitySuffix, gdt_1A * completeness)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_1A->GetName() + '_' + "sse_norm" + m_QualitySuffix, gdt_1A * sse_ratio)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_2A->GetName() + m_QualitySuffix, gdt_2A)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_2A->GetName() + '_' + "norm" + m_QualitySuffix, gdt_2A * completeness)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_2A->GetName() + '_' + "sse_norm" + m_QualitySuffix, gdt_2A * sse_ratio)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_4A->GetName() + m_QualitySuffix, gdt_4A)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_4A->GetName() + '_' + "norm" + m_QualitySuffix, gdt_4A * completeness)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_4A->GetName() + '_' + "sse_norm" + m_QualitySuffix, gdt_4A * sse_ratio)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_8A->GetName() + m_QualitySuffix, gdt_8A)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_8A->GetName() + '_' + "norm" + m_QualitySuffix, gdt_8A * completeness)
              );
              results_list.PushBack
              (
                storage::Pair< std::string, double>( quality::GetMeasures().e_GDT_8A->GetName() + '_' + "sse_norm" + m_QualitySuffix, gdt_8A * sse_ratio)
              );
            }
          }
          // if no GDT_TS
          else
          {
            // calculate the value and store
            const double value( ( **measure_itr)->CalculateMeasure( coordinates_pair.First(), coordinates_pair.Second()));

            // insert into the results_vector with the name and the value
            results_list.PushBack( storage::Pair< std::string, double>( measure_itr->GetName() + m_QualitySuffix, value));

            // also insert the the normalized version of this measure
            results_list.PushBack
            (
              storage::Pair< std::string, double>
              (
                measure_itr->GetName() + '_' + "norm" + m_QualitySuffix,
                value * completeness
              )
            ); // also insert the the normalized version of this measure
            results_list.PushBack
            (
              storage::Pair< std::string, double>
              (
                measure_itr->GetName() + '_' + "sse_norm" + m_QualitySuffix,
                value * sse_ratio
              )
            );
          }
        }
        // any other measure
        else
        {
          // calculate the value and store
          const double value( ( **measure_itr)->CalculateMeasure( coordinates_pair.First(), coordinates_pair.Second()));

          // insert into the results_vector with the name and the value
          results_list.PushBack( storage::Pair< std::string, double>( measure_itr->GetName() + m_QualitySuffix, value));

          // if this is a RMSD measure
          if
          (
            *measure_itr == quality::GetMeasures().e_RMSD ||
            *measure_itr == quality::GetMeasures().e_RMSD_NoSuperimposition ||
            *measure_itr == quality::GetMeasures().e_RMSD_XYSuperimposition
          )
          {
            // calculate rmsd_100 value
            const double rmsd_100( Quality::RMSD100( value, pruned_ctr));
            BCL_MessageStd
            (
              "Calculating RMSD100=" + util::Format()( rmsd_100)
              + " from RMSD=" + util::Format()( value) + " and amino_acid_count=" + util::Format()( pruned_ctr)
            );

            // insert also this normalized value into the table
            results_list.PushBack
            (
              storage::Pair< std::string, double>( measure_itr->GetName() + "100" + m_QualitySuffix, rmsd_100)
            );
          }
        }
      }

      return results_list;
    }

    //! @brief construct a table that has protein distance measures to be append to a score table
    //! @param QUALITY_LIST list of calculated quality measures and their values
    //! @return storage table of measures
    storage::Table< double> QualityBatch::ConstructTable
    (
      const storage::List< storage::Pair< std::string, double> > &QUALITY_LIST
    ) const
    {
      // construct storage table from HEADER
      storage::Table< double> measures_table
      (
        math::SumFunctionMixin< score::ProteinModel>::GetValueTableVerticalColumnNames()
      );

      // iterate over the measures vector
      for
      (
        storage::List< storage::Pair< std::string, double> >::const_iterator
          measure_itr( QUALITY_LIST.Begin()), measure_itr_end( QUALITY_LIST.End());
        measure_itr != measure_itr_end; ++measure_itr
      )
      {
        // insert the row for this measure
        measures_table.InsertRow
        (
          m_UseReadableNames ? GetFormattedName( measure_itr->First()) : measure_itr->First(),
          storage::Vector< double>::Create( 1.0, measure_itr->Second(), measure_itr->Second())
        );
      }

      // end
      return measures_table;
    }

    //! @brief get formatted name for better readability
    //! @param ROW_NAME original row name
    //! @return formatted name for better readability
     std::string QualityBatch::GetFormattedName( const std::string &ROW_NAME)
    {
      // initialize static map
      static storage::Map< std::string, std::string> s_name_map;

      if( s_name_map.IsEmpty())
      {
        s_name_map[ "RMSD100"] = storage::Table< double>::s_Indentation + "RMSD100";
        s_name_map[ "cr12"] = storage::Table< double>::s_Indentation + "Contact recovery";
      }

      // check the map and return new string if found
      storage::Map< std::string, std::string>::const_iterator find_itr( s_name_map.Find( ROW_NAME));
      if( find_itr != s_name_map.End())
      {
        return find_itr->second;
      }

      // not in map so return original
      return ROW_NAME;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_quality.h"

// includes from bcl - sorted alphabetically
#include "align/bcl_align_aligner_dp.h"
#include "align/bcl_align_handler_interface.h"
#include "align/bcl_align_sequence.h"
#include "assemble/bcl_assemble_collector_aa_specified.h"
#include "assemble/bcl_assemble_collector_common_aa.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "biol/bcl_biol_align_by_aa_data.h"
#include "biol/bcl_biol_align_by_pdb_id.h"
#include "command/bcl_command_flag_dynamic.h"
#include "command/bcl_command_parameter.h"
#include "function/bcl_function_binary_sum.h"
#include "io/bcl_io_directory_entry.h"
#include "io/bcl_io_file.h"
#include "score/bcl_score_aa_assignments.h"
#include "score/bcl_score_assignment_with_gap.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> Quality::s_Instance
    (
      GetObjectInstances().AddInstance( new Quality())
    );

    //! @brief gives the flag which allows specifying multiple alignment files corresponding to multiple chains
    //! @return flag which allows specifying multiple alignment files corresponding to multiple chains
    const util::ShPtr< command::FlagInterface> &Quality::GetFlagAlignments()
    {
      static const util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagDynamic
        (
          "alignment",
          "use an alignment for comparing PDB(s) with reference structure",
          command::Parameter
          (
            "alignment_files",
            "list of PIR alignment files, one for each chain, test/template sequence MUST be first - "
            "name must be of format, *<chain_id>.*, "
            "where the chain_id is the char representing which chains are aligned "
            "(i.e. alignA.pir would have the alignment of the A chains)", ""
          )
        )
      );

      return s_flag;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @details construct with rmsd and backbone atom types
    Quality::Quality() :
      m_Measure( quality::GetMeasures().e_RMSD),
      m_AtomTypes( biol::GetAtomTypes().GetBackBoneAtomTypes())
    {
    }

    //! @brief construct from a quality measure and the atom types to be considered
    //! @param QUALITY_MEASURE quality measure to be calculated
    //! @param ATOM_TYPES Set of atom types to be superimposed
    Quality::Quality
    (
      const quality::Measure &QUALITY_MEASURE,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    ) :
      m_Measure( QUALITY_MEASURE),
      m_AtomTypes( ATOM_TYPES)
    {
    }

    //! @brief virtual copy constructor
    //! @return pointer a new Quality copied from this quality
    Quality *Quality::Clone() const
    {
      return new Quality( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &Quality::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &Quality::GetScheme() const
    {
      return m_Measure.GetName();
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief calculate the given QUALITY_MEASURE between the coordinates in the SSEs of the Protein model and the original coordinates given from the pdbfile, that are stored in the original sequence
    //! @param QUALITY_MEASURE quality measure to be calculated
    //! @param PROTEIN_MODEL the protein model for which the QUALITY_MEASURE of the coordinates in the SSEs is calculated against the coordinates in the sequence in the chains
    //! @param ATOM_TYPES Set of atom types to be superimposed
    //! @return QUALITY_MEASURE between the coordinates in the SSEs of the Protein model and the original coordinates given from the pdbfile, that are stored in the original sequence
    double Quality::Calculate
    (
      const quality::Measure &QUALITY_MEASURE,
      const ProteinModel &PROTEIN_MODEL,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      // assert that measure is defined
      BCL_Assert( QUALITY_MEASURE.IsDefined(), "Undefined quality measure provided for calculating quality");

      // check that atom types are given
      if( ATOM_TYPES.IsEmpty())
      {
        BCL_MessageCrt( "no atom types given for quality calculation");
        return util::GetUndefined< double>();
      }

      // get the pair of coordinate vectors for each chain that has the current and original coordinates
      storage::Pair< util::SiPtrVector< const linal::Vector3D>, util::SiPtrVector< const linal::Vector3D> >
        model_sequence_coordinates( GetChainAndSequenceCoordinates( PROTEIN_MODEL, ATOM_TYPES));

      // superimposition with less than three coordinates is ambiguous
      if( model_sequence_coordinates.First().GetSize() < 3)
      {
        BCL_MessageCrt( "3 coordinates are needed at least for quality calculation")
        return util::GetUndefined< double>();
      }

      // calculate the quality measure for common coordinates and return it
      return
        ( *QUALITY_MEASURE)->CalculateMeasure
        (
          model_sequence_coordinates.First(), model_sequence_coordinates.Second()
        );
    }

    //! @brief calculate the given QUALITY_MEASURE between the coordinates in the SSEs of the Protein model and the original coordinates given from the pdbfile, that are stored in the original sequence
    //! @param QUALITY_MEASURE quality measure to be calculated
    //! @param PROTEIN_MODEL the protein model for which the QUALITY_MEASURE of the coordinates in the SSEs is calculated against the coordinates in the sequence in the chains
    //! @param NATIVE_MODEL native structure
    //! @param ATOM_TYPES Set of atom types to be superimposed
    //! @return QUALITY_MEASURE between the coordinates in the SSEs of the Protein model and the original coordinates given from the pdbfile, that are stored in the original sequence
    double Quality::Calculate
    (
      const quality::Measure &QUALITY_MEASURE,
      const ProteinModel &PROTEIN_MODEL,
      const ProteinModel &NATIVE_MODEL,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      // assert that measure is defined
      BCL_Assert( QUALITY_MEASURE.IsDefined(), "Undefined quality measure provided for calculating quality");

      // check that atom types are given
      if( ATOM_TYPES.IsEmpty())
      {
        BCL_MessageCrt( "no atom types given for rmsd calculation");
        return util::GetUndefined< double>();
      }

      // collect aas with defined coordinates from protein model
      const util::SiPtrList< const biol::AABase>
        aas_defined_model( CollectorCommonAA::CollectDefinedAAsInSSEs( PROTEIN_MODEL));

      // collect aas with defined coordinates from native model
      const util::SiPtrList< const biol::AABase>
        aas_defined_native( CollectorCommonAA::CollectDefinedAAsInSSEs( NATIVE_MODEL));

      // create VectorND "common_amino_acids"
      storage::VectorND< 2, util::SiPtrList< const biol::AABase> > common_amino_acids
      (
        // initialize with all the amino acids that are common to both "protein_model_a" and "protein_model_b"
        CollectorCommonAA().Collect
        (
          storage::VectorND< 2, util::SiPtr< const util::SiPtrList< const biol::AABase> > >
          (
            util::ToSiPtr( aas_defined_model),
            util::ToSiPtr( aas_defined_native)
          )
        )
      );

      // create VectorND "all_atom_coordinates" to hold the desired atom coordinates of both proteins
      storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > all_atom_coordinates
      (
        // initialize with all the atom coordinates
        GetAllDesiredAtomCoordinates( common_amino_acids, ATOM_TYPES)
      );

      // calculate the quality measure for common coordinates and return it
      return ( *QUALITY_MEASURE)->CalculateMeasure( all_atom_coordinates.First(), all_atom_coordinates.Second());
    }

    //! @brief superimpose the coordinates in the SSEs of the Protein model and the original coordinates given from the pdbfile, that are stored in the original sequence
    //! @param SUPERIMPOSE_MEASURE superimpose measure to be used for superimposition
    //! @param PROTEIN_MODEL protein model that will be superimpose to its native coordinates
    //! @param ATOM_TYPES Set of atom types to be superimposed
    //! @return whether superimposition succeeded and the transformation used
    storage::Pair< bool, math::TransformationMatrix3D> Quality::SuperimposeModel
    (
      const quality::SuperimposeMeasure &SUPERIMPOSE_MEASURE,
      ProteinModel &PROTEIN_MODEL,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      // initialize static default transformation
      static const math::TransformationMatrix3D s_default_transformation;

      // assert that measure is defined
      BCL_Assert( SUPERIMPOSE_MEASURE.IsDefined(), "Undefined quality measure provided for calculating superimposition");

      // check that atom types are given
      if( ATOM_TYPES.IsEmpty())
      {
        BCL_MessageCrt( "no atom types given for quality calculation");
        return storage::Pair< bool, math::TransformationMatrix3D>( false, s_default_transformation);
      }

      // get the pair of coordinate vectors for each chain that has the current and original coordinates
      storage::Pair< util::SiPtrVector< const linal::Vector3D>, util::SiPtrVector< const linal::Vector3D> >
        model_sequence_coordinates( GetChainAndSequenceCoordinates( PROTEIN_MODEL, ATOM_TYPES));

      // superimposition with less than three coordinates is ambiguous
      if( model_sequence_coordinates.First().GetSize() < 3)
      {
        BCL_MessageCrt( "3 coordinates are needed at least for quality calculation")
        return storage::Pair< bool, math::TransformationMatrix3D>( false, s_default_transformation);
      }

      // calculate the superimposition transformation matrix
      const math::TransformationMatrix3D transformation
      (
        ( *SUPERIMPOSE_MEASURE)->CalculateSuperimposition
        (
          model_sequence_coordinates.First(), model_sequence_coordinates.Second()
        )
      );

      // if the transformation is not defined
      if( !transformation.IsDefined())
      {
        BCL_MessageCrt( "the superimposition failed");
        return storage::Pair< bool, math::TransformationMatrix3D>( false, s_default_transformation);
      }

      // transform the protein model
      PROTEIN_MODEL.Transform( transformation);

      // return
      return storage::Pair< bool, math::TransformationMatrix3D>( true, transformation);
    }

    //! @brief superimpose given model to another model
    //! @param SUPERIMPOSE_MEASURE superimpose measure to be used for superimposition
    //! @param PROTEIN_MODEL the protein model to be superimposed
    //! @param REFERENCE_MODEL reference structure
    //! @param ATOM_TYPES Set of atom types to be superimposed
    //! @return whether superimposition succeeded and the transformation used
    storage::Pair< bool, math::TransformationMatrix3D> Quality::SuperimposeModel
    (
      const quality::SuperimposeMeasure &SUPERIMPOSE_MEASURE,
      ProteinModel &PROTEIN_MODEL,
      const ProteinModel &REFERENCE_MODEL,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      // initialize static default transformation
      static const math::TransformationMatrix3D s_default_transformation;

      // assert that measure is defined
      BCL_Assert( SUPERIMPOSE_MEASURE.IsDefined(), "Undefined quality measure provided for calculating superimposition");

      // check that atom types are given
      if( ATOM_TYPES.IsEmpty())
      {
        BCL_MessageCrt( "no atom types given for superimposition");
        return storage::Pair< bool, math::TransformationMatrix3D>( false, s_default_transformation);
      }

      // collect aas with defined coordinates from protein models
      const util::SiPtrList< const biol::AABase>
        aas_defined_model( CollectorCommonAA::CollectDefinedAAsInSSEs( PROTEIN_MODEL));
      const util::SiPtrList< const biol::AABase>
        aas_defined_reference( CollectorCommonAA::CollectDefinedAAsInSSEs( REFERENCE_MODEL));

      // create VectorND "common_amino_acids"
      storage::VectorND< 2, util::SiPtrList< const biol::AABase> > common_amino_acids
      (
        // initialize with all the amino acids that are common to both "protein_model" and "reference_model"
        CollectorCommonAA().Collect
        (
          storage::VectorND< 2, util::SiPtr< const util::SiPtrList< const biol::AABase> > >
          (
            util::ToSiPtr( aas_defined_model),
            util::ToSiPtr( aas_defined_reference)
          )
        )
      );

      // create VectorND "all_atom_coordinates" to hold the desired atom coordinates of both proteins
      storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > all_atom_coordinates
      (
        // initialize with all the atom coordinates
        GetAllDesiredAtomCoordinates( common_amino_acids, ATOM_TYPES)
      );

      // calculate the superimposition transformation matrix
      const math::TransformationMatrix3D transformation
      (
        ( *SUPERIMPOSE_MEASURE)->CalculateSuperimposition( all_atom_coordinates.First(), all_atom_coordinates.Second())
      );

      // if the transformation is not defined
      if( !transformation.IsDefined())
      {
        BCL_MessageCrt( "the superimposition failed");
        return storage::Pair< bool, math::TransformationMatrix3D>( false, s_default_transformation);
      }

      // transform the protein model
      PROTEIN_MODEL.Transform( transformation);

      // return
      return storage::Pair< bool, math::TransformationMatrix3D>( true, transformation);
    }

    //! @brief superimpose given model to another model
    //! @param SUPERIMPOSE_MEASURE superimpose measure to be used for superimposition
    //! @param PROTEIN_MODEL the protein model to be superimposed
    //! @param REFERENCE_MODEL reference structure
    //! @param ATOM_TYPES Set of atom types to be superimposed
    //! @return whether superimposition succeeded and the transformation used
    storage::Pair< bool, math::TransformationMatrix3D> Quality::SuperimposeModelWithAlignment
    (
      const quality::SuperimposeMeasure &SUPERIMPOSE_MEASURE,
      ProteinModel &PROTEIN_MODEL,
      const ProteinModel &REFERENCE_MODEL,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      // initialize static default transformation
      static const math::TransformationMatrix3D s_default_transformation;

      // assert that measure is defined
      BCL_Assert( SUPERIMPOSE_MEASURE.IsDefined(), "Undefined quality measure provided for calculating superimposition");

      // check that atom types are given
      if( ATOM_TYPES.IsEmpty())
      {
        BCL_MessageCrt( "no atom types given for superimposition");
        return storage::Pair< bool, math::TransformationMatrix3D>( false, s_default_transformation);
      }

      // construct alignments for computing RMSDs
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >
        initial_alignments_a, initial_alignments_b, initial_alignments;

      // compute alignments
      initial_alignments_a = Quality::CreateAlignmentFromProteinModelSequences( PROTEIN_MODEL);

      // compute alignments
      initial_alignments_b = Quality::CreateAlignmentFromProteinModelSequences( REFERENCE_MODEL);

      initial_alignments = Quality::AlignSingleAlignments( initial_alignments_a, initial_alignments_b);

      // initialize coordinates vector
      storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > coordinates_pair;

      // iterate through the map
      for
      (
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::const_iterator
          align_itr( initial_alignments.Begin()), align_itr_end( initial_alignments.End());
        align_itr != align_itr_end;
        ++align_itr
      )
      {
        // get the pruned alignment where gaps and amino acids with undefined coordinates are removed
        const align::AlignmentNode< biol::AABase> pruned_alignment
        (
          Quality::RemoveUndefinedAminoAcidsFromAlignment( *( align_itr->second), ATOM_TYPES)
        );

        // get the common coordinates
        const storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > this_coordinates_pair
        (
          Quality::CoordinatesFromAlignment( pruned_alignment, ATOM_TYPES)
        );

        // update the total coordinates
        coordinates_pair.First().Append( this_coordinates_pair.First());
        coordinates_pair.Second().Append( this_coordinates_pair.Second());
      }

      // calculate the superimposition transformation matrix
      const math::TransformationMatrix3D transformation
      (
        ( *SUPERIMPOSE_MEASURE)->CalculateSuperimposition( coordinates_pair.First(), coordinates_pair.Second())
      );

      // if the transformation is not defined
      if( !transformation.IsDefined())
      {
        BCL_MessageCrt( "the superimposition failed");
        return storage::Pair< bool, math::TransformationMatrix3D>( false, s_default_transformation);
      }

      // transform the protein model
      PROTEIN_MODEL.Transform( transformation);

      // return
      return storage::Pair< bool, math::TransformationMatrix3D>( true, transformation);
    }

    //! @brief calculates RMSD100 by normalizing RMSD by the number of residues
    //! @param RMSD RMSD to be converted to RMSD100
    //! @param NUMBER_RESIDUES number of residues aligned in RMSD calculation
    //! @return RMSD100 calculated from the given RMSD
    double
    Quality::RMSD100
    (
      const double RMSD,
      const size_t NUMBER_RESIDUES
    )
    {
      // if there is less 14 residues (it leads to a negative value)
      if( NUMBER_RESIDUES <= 14)
      {
        BCL_MessageCrt( "There needs to be at least 14 residues for RMSD100 calculation");
        // return undefined
        return util::GetUndefinedDouble();
      }

      // otherwise go ahead with the calculation
      return RMSD / ( 1.0 + std::log( math::Sqrt( double( NUMBER_RESIDUES) / 100.0)));
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that calculates quality measure of protein model to to coordinates stored in the aa sequences
    //! @param PROTEIN_MODEL the model to be considered
    //! @return the result of the quality measure this object was constructed with
    double Quality::operator()( const ProteinModel &PROTEIN_MODEL) const
    {
      return Calculate( m_Measure, PROTEIN_MODEL, m_AtomTypes);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read ProteinModel from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &Quality::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Measure, ISTREAM);
      io::Serialize::Read( m_AtomTypes, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write ProteinModel to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT nr of indentations
    //! @return output stream which was written to
    std::ostream &Quality::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Measure, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AtomTypes, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief returns the pair of current and original coordinates for specified atomtypes for each amino acid that are in SSEs for the given chain
    //! @param CHAIN chain of interest
    //! @param NATIVE the native chain
    //! @param ATOM_TYPES Set of atom types to be returned
    //! @return the pair of current and original coordinates for specified atomtypes for each amino acid that are in SSEs for the given chain
    storage::Pair< util::SiPtrVector< const linal::Vector3D>, util::SiPtrVector< const linal::Vector3D> >
    Quality::GetSSEAndSequenceCoordinates
    (
      const Chain &CHAIN,
      const Chain &NATIVE,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      //instantiate Pair of util::SiPtrVector of coordinates to model and according sequence coordinates
      storage::Pair< util::SiPtrVector< const linal::Vector3D>, util::SiPtrVector< const linal::Vector3D> >
        model_sequence_coordinates;

      //instantiate an iterator to sequence of amino acids
      biol::AASequence::const_iterator sequence_itr( NATIVE.GetSequence()->Begin());
      const biol::AASequence::const_iterator sequence_itr_end( NATIVE.GetSequence()->End());

      // instantiate secondary structure element iterator to the elements of the protein model
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          sse_itr( CHAIN.GetData().Begin()), sse_itr_end( CHAIN.GetData().End());
        sse_itr != sse_itr_end && sequence_itr != sequence_itr_end;
        ++sse_itr
      )
      {
        //iterator to the first amino acids of current sselement
        biol::AASequence::const_iterator aa_itr( ( *sse_itr)->Begin());
        const biol::AASequence::const_iterator aa_itr_end( ( *sse_itr)->End());

        // increase sequence_itr till it matches the first aminoacid of the current SSE
        while
        (
          sequence_itr != sequence_itr_end &&
          aa_itr != aa_itr_end &&
          (
            ( *sequence_itr)->GetSeqID() < ( *aa_itr)->GetSeqID() ||
            (
              ( *sequence_itr)->GetSeqID() == ( *aa_itr)->GetSeqID() &&
              ( *sequence_itr)->GetPdbICode() < ( *aa_itr)->GetPdbICode()
            )
          )
        )
        {
          sequence_itr++;
        }

        // collect coordinates of common amino acids
        while
        (
          sequence_itr != sequence_itr_end &&
          aa_itr != aa_itr_end &&
          ( *sequence_itr)->GetSeqID() == ( *aa_itr)->GetSeqID() &&
          ( *sequence_itr)->GetPdbICode() == ( *aa_itr)->GetPdbICode()
        )
        {
          // initialize vectors to store coordinates for given atom types for original and current coordinates
          const util::SiPtrVector< const linal::Vector3D>
            model_coordinates( ( *aa_itr)->GetAtomCoordinates( ATOM_TYPES));
          const util::SiPtrVector< const linal::Vector3D> seq_coordinates
            ( ( *sequence_itr)->GetAtomCoordinates( ATOM_TYPES));

          //only if coordinates of current AA is defined
          if( coord::AreDefinedCoordinates( model_coordinates) && coord::AreDefinedCoordinates( seq_coordinates))
          {
            //store model coordinates
            model_sequence_coordinates.First().Append( model_coordinates);
            model_sequence_coordinates.Second().Append( seq_coordinates);
          }

          //goto next amino acid in sselement and sequence
          aa_itr++;
          sequence_itr++;
        }
      }

      // end
      return model_sequence_coordinates;
    }

    //! @brief returns the pair of current and original coordinates for specified atomtypes for each amino acid that are in SSEs for all the given chains
    //! @param MODEL Protein model of interest
    //! @param ATOM_TYPES Set of atom types to be returned
    //! @return the pair of current and original coordinates for specified atomtypes for each amino acid that are in SSEs for all the given chains
    storage::Pair< util::SiPtrVector< const linal::Vector3D>, util::SiPtrVector< const linal::Vector3D> >
    Quality::GetChainAndSequenceCoordinates
    (
      const ProteinModel &MODEL,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      //instantiate Pair of util::SiPtrVector of coordinates to model and according sequence coordinates
      storage::Pair< util::SiPtrVector< const linal::Vector3D>, util::SiPtrVector< const linal::Vector3D> >
        model_sequence_coordinates;
      const util::SiPtr< const ProteinModel> template_model
      (
        MODEL.GetProteinModelData()->GetData( ProteinModelData::e_NativeModel)
      );

      // check that atom types are given
      if( ATOM_TYPES.IsEmpty())
      {
        BCL_MessageCrt( "no atom types given for rmsd calcualtion");
        return model_sequence_coordinates;
      }

      if( !template_model.IsDefined())
      {
        BCL_MessageCrt( "No native model given!");
        return model_sequence_coordinates;
      }

      // iterate over each chain
      for
      (
        util::ShPtrVector< Chain>::const_iterator
          chain_itr( MODEL.GetChains().Begin()), chain_itr_end( MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        util::ShPtr< Chain> sp_templ_chain( template_model->GetChain( ( *chain_itr)->GetChainID()));
        if( !sp_templ_chain.IsDefined())
        {
          BCL_MessageCrt( "Template model lacked chain " + std::string( size_t( 1), ( *chain_itr)->GetChainID()));
          return model_sequence_coordinates;
        }

        // get the current and original coordinates for the common amino acids
        storage::Pair< util::SiPtrVector< const linal::Vector3D>, util::SiPtrVector< const linal::Vector3D> >
          tmp_model_sequence_coordinates( GetSSEAndSequenceCoordinates( **chain_itr, *sp_templ_chain, ATOM_TYPES));

        // append to already stored coordinates
        model_sequence_coordinates.First().Append( tmp_model_sequence_coordinates.First());
        model_sequence_coordinates.Second().Append( tmp_model_sequence_coordinates.Second());
      }

      // end
      return model_sequence_coordinates;
    }

    //! @brief GetAllDesiredAtomCoordinates puts all the desired atoms for both proteins into a StorageVectorND
    //! @param COMMON_AAS VectorND which holds the amino acids which are common to both proteins
    //! @param DESIRED_ATOMS Set which holds the atoms which are desired to be included in the calculation
    //! @return VectorND< 2, util::SiPtrVector< const linal::Vector3D> > which has desired atom coordinates
    storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > Quality::GetAllDesiredAtomCoordinates
    (
      const storage::VectorND< 2, util::SiPtrList< const biol::AABase> > &COMMON_AAS,
      const storage::Set< biol::AtomType> &DESIRED_ATOMS
    )
    {
      // initialize atom coordinates to return
      storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > all_atom_coordinates;

      // get the coordinates of the atoms that are of interest
      for
      (
        util::SiPtrList< const biol::AABase>::const_iterator
          itr_a( COMMON_AAS.First().Begin()), itr_a_end( COMMON_AAS.First().End()),
          itr_b( COMMON_AAS.Second().Begin()), itr_b_end( COMMON_AAS.Second().End());
        itr_a != itr_a_end && itr_b != itr_b_end;
        ++itr_a, ++itr_b
      )
      {
        // add coordinates to the end of appropriate SiPtrVectors of "COMMON_AAS"
        all_atom_coordinates.First().Append( ( *itr_a)->GetAtomCoordinates( DESIRED_ATOMS));
        all_atom_coordinates.Second().Append( ( *itr_b)->GetAtomCoordinates( DESIRED_ATOMS));
      }

      // end
      return all_atom_coordinates;
    }

    //! @brief creates alignments from a single ProteinModel using the SSE residues
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return alignments created from the ProteinModel using the SSE residues
    storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >
    Quality::CreateAlignmentFromProteinModelSSEs( const ProteinModel &PROTEIN_MODEL)
    {
      // initialize map
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > alignments_from_sses;

      // iterate over chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // initialize AA vector
        util::ShPtrVector< biol::AABase> residues;

        // iterate over the SSEs
        for
        (
          storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
            sse_itr( ( *chain_itr)->GetData().Begin()), sse_itr_end( ( *chain_itr)->GetData().End());
          sse_itr != sse_itr_end; ++sse_itr
        )
        {
          // add the residues to the vector
          residues.Append( ( *sse_itr)->GetData());
        }

        // create a new sequence
        const util::ShPtr< align::Sequence< biol::AABase> > sp_sequence( new align::Sequence< biol::AABase>( residues, ( *chain_itr)->GetSequence()->GetSequenceId()));

        // add to the map
        alignments_from_sses[ ( *chain_itr)->GetChainID()] =
          util::ShPtr< align::AlignmentInterface< biol::AABase> >( new align::AlignmentLeaf< biol::AABase>( sp_sequence));
      }

      // create and return the alignment
      return alignments_from_sses;
    }

    //! @brief creates alignments from a single ProteinModel using specific residues identified by collector
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @param COLLECTOR the collector that has the specific residues that will be used
    //! @return alignments created from the ProteinModel using the specified residues
    storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >
    Quality::CreateAlignmentFromCollectorAASpecified
    (
      const ProteinModel &PROTEIN_MODEL, const CollectorAASpecified &COLLECTOR
    )
    {
      // get the residues of interest
      const util::SiPtrList< const biol::AABase> collected_aas( COLLECTOR.Collect( PROTEIN_MODEL));

      // will hold the residues for each chain
      storage::Map< char, util::ShPtrVector< biol::AABase> > chain_sequence;

      // iterate through the residues to build up the list per chain
      for
      (
        util::SiPtrList< const biol::AABase>::const_iterator
          aa_itr( collected_aas.Begin()), aa_itr_end( collected_aas.End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // get reference to current aa list corresponding to the chain of the current residue
        util::ShPtrVector< biol::AABase> &residue_vector( chain_sequence[ ( *aa_itr)->GetChainID()]);

        // make shptr to cloned residue
        const util::ShPtr< biol::AABase> new_aa_ptr( ( *aa_itr)->Clone());

        residue_vector.PushBack( new_aa_ptr);

        if( residue_vector.GetSize() > 1)
        {
          BCL_Assert
          (
            new_aa_ptr->GetSeqID() > residue_vector( residue_vector.GetSize() - 2)->GetSeqID(),
            "the residues are being collected in non numerically increasing order. please make sure your desired "
            "residues to collect are listed in increasing numerical order."
          );
        }
      }

      // initialize map to hold chain and alignment
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > alignments_from_sses;

      // iterate through the chain and sequence map
      for
      (
        storage::Map< char, util::ShPtrVector< biol::AABase> >::const_iterator
          chain_itr( chain_sequence.Begin()), chain_itr_end( chain_sequence.End());
        chain_itr != chain_itr_end;
        ++chain_itr
      )
      {
        // create a new sequence
        const util::ShPtr< align::Sequence< biol::AABase> > sp_sequence
        (
          new align::Sequence< biol::AABase>( chain_itr->second, std::string( &chain_itr->first, 1))
        );

        // add to the map
        alignments_from_sses[ chain_itr->first] =
          util::ShPtr< align::AlignmentInterface< biol::AABase> >( new align::AlignmentLeaf< biol::AABase>( sp_sequence));
      }

      return alignments_from_sses;
    }

    //! @brief creates alignments from a single ProteinModel using the chain sequence residues
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return alignments created from the ProteinModel using the chain sequence residues
    storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >
    Quality::CreateAlignmentFromProteinModelSequences( const ProteinModel &PROTEIN_MODEL)
    {
      // initialize map
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > alignments_from_sequences;

      // iterate over chains
      for
      (
        util::ShPtrVector< Chain>::const_iterator
          chain_itr( PROTEIN_MODEL.GetChains().Begin()), chain_itr_end( PROTEIN_MODEL.GetChains().End());
        chain_itr != chain_itr_end; ++chain_itr
      )
      {
        // create an alignment from the chain sequence
        const util::ShPtr< biol::AASequence> &sp_sequence( ( *chain_itr)->GetSequence());
        util::ShPtr< align::AlignmentLeaf< biol::AABase> > sp_leaf
        (
          new align::AlignmentLeaf< biol::AABase>( sp_sequence)
        );

        // add the alignment to the map
        alignments_from_sequences[ ( *chain_itr)->GetChainID()] = sp_leaf;
      }

      // end
      return alignments_from_sequences;
    }

    //! @brief creates alignments of chain sequences to SSE residues for a given ProteinModel
    //! @param PROTEIN_MODEL ProteinModel of interest
    //! @return alignments of chain sequences to SSE residues for a given ProteinModel
    storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >
    Quality::CreateAlignmentProteinModelSequencesToSSEs( const ProteinModel &PROTEIN_MODEL)
    {
      // get the alignments of sequences
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > align_seq
      (
        Quality::CreateAlignmentFromProteinModelSequences( PROTEIN_MODEL)
      );

      // get the alignments of SSEs
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > align_sses
      (
        Quality::CreateAlignmentFromProteinModelSSEs( PROTEIN_MODEL)
      );

      // return the combined alignment
      return AlignSingleAlignments( align_seq, align_sses);
    }

    //! @brief creates alignments of sequences in SSEs of two protein models
    //! @param PROTEIN_MODEL_A first ProteinModel of interest
    //! @param PROTEIN_MODEL_B second ProteinModel of interest
    //! @return alignments of sequences in SSEs of two protein models
    storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >
    Quality::CreateAlignmentProteinModels
    (
      const ProteinModel &PROTEIN_MODEL_A,
      const ProteinModel &PROTEIN_MODEL_B
    )
    {
      // get the alignment of model a
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > align_a
      (
        Quality::CreateAlignmentFromProteinModelSSEs( PROTEIN_MODEL_A)
      );

      // get the alignments of model b
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > align_b
      (
        Quality::CreateAlignmentFromProteinModelSSEs( PROTEIN_MODEL_B)
      );

      // return the combined alignment
      return AlignSingleAlignments( align_a, align_b, biol::AACompareData());
    }

    //! @brief aligns two single alignments (each containing 1 sequence) using the given comparison
    //! @param ALIGNMENT_A first alignment
    //! @param ALIGNMENT_B second alignment
    //! @param COMPARISON comparison object for two AABase
    //! @return combined alignments
    storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >
    Quality::AlignSingleAlignments
    (
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > &ALIGNMENT_A,
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > &ALIGNMENT_B,
      const util::BinaryFunctionInterface< biol::AABase, biol::AABase, bool> &COMPARISON
    )
    {
      function::BinarySum< const biol::AABase, const biol::AABase, double> assign_score;
      assign_score += **score::GetAAAssignments().e_IDENTITY;

      // Based on Elizabeth Dong's Weight tables -0.672 -0.907 -0.635  0.00
      // fold recognition scores ENCLOSED_SINGLE_GAP, ENCLOSED_MULTIPLE_GAP, BOUNDARY_SINGLE_GAP, BOUNDARY_MULTIPLE_GAP
      score::AssignmentWithGap< biol::AABase> assign_gap_score
      (
        util::CloneToShPtr( assign_score),
        -0.672, // ENCLOSED_SINGLE_GAP
        -0.907, // ENCLOSED_MULTIPLE_GAP
        -0.635, // BOUNDARY_SINGLE_GAP
        0.0 // BOUNDARY_MULTIPLE_GAP
      );
      // just identity score
      score::AssignmentWithGap< biol::AABase> identity_score
      (
        util::CloneToShPtr( assign_score),
        0.0, // ENCLOSED_SINGLE_GAP
        0.0, // ENCLOSED_MULTIPLE_GAP
        0.0, // BOUNDARY_SINGLE_GAP
        0.0 // BOUNDARY_MULTIPLE_GAP
      );

      // initialize map
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > sequences;

      // iterate over the model a map
      for
      (
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::iterator
          seq_itr( ALIGNMENT_A.Begin()), seq_itr_end( ALIGNMENT_A.End());
        seq_itr != seq_itr_end; ++seq_itr
      )
      {
        // try to find the corresponding sequence from the sse map
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::iterator find_itr
        (
          ALIGNMENT_B.Find( seq_itr->first)
        );

        // if the sequence was found
        if( find_itr != ALIGNMENT_B.End())
        {
          // add the alignment to the map
          sequences[ seq_itr->first] =
            util::ShPtr< align::AlignmentInterface< biol::AABase> >
            (
              biol::AlignByPdbID().AlignPair( seq_itr->second, find_itr->second).First().Clone()
            );
          if( sequences[ seq_itr->first]->Score( identity_score) < std::min( find_itr->second->GetSize(), seq_itr->second->GetSize()))
          {
            BCL_MessageVrb( "Recomputing alignments because PDB IDs of the native and the model did not match!")
            align::AlignerDP< biol::AABase> aligner;
            aligner.SetScoringFunction( assign_gap_score);
            sequences[ seq_itr->first] =
                        util::ShPtr< align::AlignmentInterface< biol::AABase> >
                        (
                          aligner.AlignPair( seq_itr->second, find_itr->second).First().Clone()
                        );
          }
        }
      }

      // end
      return sequences;
    }

    //! @brief prunes the given alignment by removing all assignments with gaps
    //! @param ALIGNMENT Alignment of two protein sequences
    //! @return pruned alignment where the gaps were removed
    align::AlignmentNode< biol::AABase> Quality::RemoveAssignmentsWithGapsFromAlignment
    (
      const align::AlignmentInterface< biol::AABase> &ALIGNMENT
    )
    {
      // initialize alignment
      align::AlignmentNode< biol::AABase> pruned_alignment( ALIGNMENT.GetChildAlignments());

      // iterate over the given alignment
      for
      (
        align::AlignmentLeaf< biol::AABase>::const_iterator
          itr( ALIGNMENT.GetAssignments().Begin()), itr_end( ALIGNMENT.GetAssignments().End());
        itr != itr_end; ++itr
      )
      {
        // if all the members of the assignment are defined
        if( ( *itr)->GetMembers().IsDefined())
        {
          pruned_alignment.Append( *itr);
        }
      }

      // end
      return pruned_alignment;
    }

    //! @brief prunes the given alignment making sure each template amino acid has defined coordinates for given atom types
    //! @param ALIGNMENT Alignment of two protein sequences
    //! @param ATOM_TYPES Set of atom types for which the coordinates need to be defined
    //! @return pruned alignment where the residues where the template sequence has undefined coordinates were removed
    align::AlignmentNode< biol::AABase> Quality::RemoveUndefinedTemplateAminoAcidsFromAlignment
    (
      const align::AlignmentInterface< biol::AABase> &ALIGNMENT,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      // initialize alignment
      align::AlignmentNode< biol::AABase> pruned_alignment( ALIGNMENT.GetChildAlignments());

      // iterate over the given alignment
      for
      (
        align::AlignmentLeaf< biol::AABase>::const_iterator
          itr( ALIGNMENT.GetAssignments().Begin()), itr_end( ALIGNMENT.GetAssignments().End());
        itr != itr_end; ++itr
      )
      {
        // create a pointer on the template (first sequence) amino acid for this position
        const util::SiPtr< const biol::AABase> aa_ptr( ( *itr)->GetMembers().FirstElement());

        // if the amino acid is not defined, skip to next assignment
        if( !aa_ptr.IsDefined())
        {
          continue;
        }

        // get the coordinates for this amino acid
        const util::SiPtrVector< const linal::Vector3D> coords( aa_ptr->GetAtomCoordinates( ATOM_TYPES));

        // if coordinates are defined
        if( !coords.IsEmpty() && coord::AreDefinedCoordinates( coords))
        {
          // add this assignment to the pruned alignment created
          pruned_alignment.Append( *itr);
        }
      }

      if( ALIGNMENT.GetSize() != pruned_alignment.GetSize())
      {
        BCL_MessageStd
        (
          "Pruned alignment from " + util::Format()( ALIGNMENT.GetSize()) + " to "
          + util::Format()( pruned_alignment.GetSize()) + " assignments by removing undefined coordinates."
        );
      }
      // end
      return pruned_alignment;
    }

    //! @brief prunes the given alignment making sure each amino acid has defined coordinates for given atom types
    //! @param ALIGNMENT Alignment of two protein sequences
    //! @param ATOM_TYPES Set of atom types for which the coordinates need to be defined
    //! @return pruned alignment where the residues with undefined coordinates were removed
    align::AlignmentNode< biol::AABase> Quality::RemoveUndefinedAminoAcidsFromAlignment
    (
      const align::AlignmentInterface< biol::AABase> &ALIGNMENT,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      // initialize alignment
      align::AlignmentNode< biol::AABase> pruned_alignment( ALIGNMENT.GetChildAlignments());

      // iterate over the given alignment
      for
      (
        align::AlignmentLeaf< biol::AABase>::const_iterator
          itr( ALIGNMENT.GetAssignments().Begin()), itr_end( ALIGNMENT.GetAssignments().End());
        itr != itr_end; ++itr
      )
      {
        // if all the members of the assignment are defined
        bool coordinates_defined( true);

        // iterate over all amino acids to check if the atom coordinates of interest are defined
        for
        (
          util::SiPtrList< const biol::AABase>::const_iterator
            itr_mem( ( *itr)->GetMembers().Begin()), itr_mem_end( ( *itr)->GetMembers().End());
          itr_mem != itr_mem_end && coordinates_defined;
          ++itr_mem
        )
        {
          // if amino acid is not defined
          if( !itr_mem->IsDefined())
          {
            // set corodinates_defined to false and break
            coordinates_defined = false;
            break;
          }

          // get the coordinates
          const util::SiPtrVector< const linal::Vector3D> coords( ( *itr_mem)->GetAtomCoordinates( ATOM_TYPES));

          coordinates_defined &= ( !coords.IsEmpty() && coord::AreDefinedCoordinates( coords));
        }

        // insert if coordinates are defined
        if( coordinates_defined)
        {
          pruned_alignment.Append( *itr);
        }
      }

      // end
      return pruned_alignment;
    }

    //! @brief given an amino acid alignment and atom types generate two siptr vector of corresponding coordinates
    //!        for quality calculations, and the number of residues involved (e.g. skipping undefined residues
    //! @param ALIGNMENT Alignment of two protein sequences
    //! @param ATOM_TYPES Set of atom types of interest
    //! @return two siptr vector of corresponding coordinates, and the number of residues in the alignment
    storage::Pair< storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> >, size_t>
    Quality::CoordinatesAndResidueCountFromAlignment
    (
      const align::AlignmentInterface< biol::AABase> &ALIGNMENT,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      storage::Pair< storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> >, size_t>
      coordinates_pair_and_nres
      (
        storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> >(),
        size_t( 0)
      );
      size_t n_residues( 0);
      storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > &coordinates_pair
      (
        coordinates_pair_and_nres.First()
      );

      if( ALIGNMENT.GetDepth() < 2)
      {
        return coordinates_pair_and_nres;
      }

      // allocate enough space
      coordinates_pair.First().AllocateMemory( ATOM_TYPES.GetSize() * ALIGNMENT.GetSize());
      coordinates_pair.Second().AllocateMemory( ATOM_TYPES.GetSize() * ALIGNMENT.GetSize());

      // iterate over the given alignment
      for
      (
        align::AlignmentLeaf< biol::AABase>::const_iterator
          itr( ALIGNMENT.GetAssignments().Begin()), itr_end( ALIGNMENT.GetAssignments().End());
        itr != itr_end; ++itr
      )
      {
        const util::SiPtrList< const biol::AABase> &members( ( *itr)->GetMembers());
        const util::SiPtr< const biol::AABase> &member_a( *members.Begin()); // first member
        const util::SiPtr< const biol::AABase> &member_b( *++members.Begin()); // second member

        // check that amino acids is not aligned against a gap
        if( !member_a.IsDefined() || !member_b.IsDefined())
        {
          continue;
        }

        // get the coordinates for the given atom types from the amino acids
        const util::SiPtrVector< const linal::Vector3D> coords_a( member_a->GetAtomCoordinates( ATOM_TYPES));
        const util::SiPtrVector< const linal::Vector3D> coords_b( member_b->GetAtomCoordinates( ATOM_TYPES));

        // check that the number of coordinates agrees and both are defined
        if
        (
             coords_a.GetSize() != coords_b.GetSize()
          || !coord::AreDefinedCoordinates( coords_a)
          || !coord::AreDefinedCoordinates( coords_b)
        )
        {
          continue;
        }

        // insert the coordinates
        ++n_residues;
        coordinates_pair.First().Append( coords_a);
        coordinates_pair.Second().Append( coords_b);
      }

      coordinates_pair_and_nres.Second() = n_residues;

      // end
      return coordinates_pair_and_nres;
    }

    //! @brief given an amino acid alignment and atom types generate two siptr vector of corresponding coordinates
    //!        for quality calculations
    //! @param ALIGNMENT Alignment of two protein sequences
    //! @param ATOM_TYPES Set of atom types of interest
    //! @return two siptr vector of corresponding coordinates
    storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > Quality::CoordinatesFromAlignment
    (
      const align::AlignmentInterface< biol::AABase> &ALIGNMENT,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      return CoordinatesAndResidueCountFromAlignment( ALIGNMENT, ATOM_TYPES).First();
    }

    //! @brief given an amino acid alignments and atom types generate two siptr vector of corresponding coordinates
    //!        for quality calculations
    //! @param ALIGNMENTS Alignments of two protein sequences
    //! @param ATOM_TYPES Set of atom types of interest
    //! @return two siptr vector of corresponding coordinates
    storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > Quality::CoordinatesFromAlignments
    (
      const storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > &ALIGNMENTS,
      const storage::Set< biol::AtomType> &ATOM_TYPES
    )
    {
      // initialize coordinates vector
      storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > coords;

      // iterate through the alignment map
      for
      (
        storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > >::const_iterator
          align_itr( ALIGNMENTS.Begin()), align_itr_end( ALIGNMENTS.End());
        align_itr != align_itr_end; ++align_itr
      )
      {
        // get the common coordinates
        const storage::VectorND< 2, util::SiPtrVector< const linal::Vector3D> > this_coordinates_pair
        (
          CoordinatesFromAlignment( *( align_itr->second), ATOM_TYPES)
        );

        // update the total coordinates
        coords.First().Append( this_coordinates_pair.First());
        coords.Second().Append( this_coordinates_pair.Second());
      }

      // end
      return coords;
    }

    //! @brief uses a vector of filenames to read in alignments for chains - chain is last character before extension
    //! @param HANDLER the type of handler to read in the alignments
    //! @param ALIGN_FILES the files containing the alignments for each chain
    //! @return map with a character for the chain and a corresponding alignment for that chain
    storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > Quality::GetChainAlignments
    (
      const align::HandlerInterface< biol::AABase> &HANDLER, const storage::Vector< io::DirectoryEntry> &ALIGN_FILES
    )
    {
      // to hold for each chain an alignment
      storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > chain_align;

      // iterate over the alignment files
      for
      (
        storage::Vector< io::DirectoryEntry>::const_iterator align_itr( ALIGN_FILES.Begin()),
          align_itr_end( ALIGN_FILES.End());
        align_itr != align_itr_end; ++align_itr
      )
      {
        // get the filename without extensions
        const std::string extensionless_file( io::File::RemoveFullExtension( align_itr->GetName()));

        // get the chain id - last character of extension-less filename
        const char chain_id( extensionless_file[ extensionless_file.length() - 1]);

        // read in the alignment
        io::IFStream read;
        io::File::MustOpenIFStream( read, align_itr->GetFullName());
        chain_align[ chain_id] = HANDLER.ReadAlignment( read, biol::AASequence(), chain_id);
        io::File::CloseClearFStream( read);
      }

      return chain_align;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sheet_template_handler.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_topology_sheet.h"
#include "assemble/bcl_assemble_fold_template.h"
#include "assemble/bcl_assemble_sse.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "command/bcl_command_parameter_check_allowed.h"
#include "io/bcl_io_file.h"
#include "score/bcl_score.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // static map to store the templates
    storage::Map< size_t, util::ShPtrVector< FoldTemplate> > SheetTemplateHandler::s_TemplateMap;

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SheetTemplateHandler::s_Instance
    (
      GetObjectInstances().AddInstance( new SheetTemplateHandler())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief Clone function
    //! @return pointer to new SheetTemplateHandler
    SheetTemplateHandler *SheetTemplateHandler::Clone() const
    {
      return new SheetTemplateHandler( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SheetTemplateHandler::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return command line flag for using sheet templates
    //! @return command line flag for using sheet templates
    util::ShPtr< command::FlagInterface> &SheetTemplateHandler::GetFlagSheetTemplates()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic( "sheet_templates", "\tuse sheet templates")
      );

      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_template_type
      (
        new command::Parameter
        (
          "sheet_template_type",
          "\ttype of sheet templates to use",
          command::ParameterCheckAllowed( storage::Vector< std::string>::Create( "soluble", "membrane", "all")),
          "soluble"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_excluded_sheet_templates
      (
        new command::Parameter
        (
          "excluded_pdb_ids_file",
          "\tspecify a file that contains a list of PBD IDs to be excluded from the sheet template selection",
          ""
        )
      );

      // if this flag is initialized from the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters
        flag->PushBack( s_template_type);
        flag->PushBack( s_excluded_sheet_templates);
      }

      // end
      return s_flag;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief picks a random template of the appropriate size
    //! @param NR_STRANDS number of strands to be in the template
    //! @return a random template of the appropriate size
    const FoldTemplate &SheetTemplateHandler::GetRandomTemplate( const size_t NR_STRANDS)
    {
      // create static undefined template
      static const FoldTemplate s_undefined_template;

      // create an iterator to the vector of templates with the correct number of helices and strands
      storage::Map< size_t, util::ShPtrVector< FoldTemplate> >::iterator templates_itr
      (
        GetTemplates().Find( NR_STRANDS)
      );

      // if iterator is invalid, return empty fold template
      if( templates_itr == GetTemplates().End())
      {
        BCL_MessageStd
        (
          "Unable to find a sheet template with " + util::Format()( NR_STRANDS) + " strands"
        );
        return s_undefined_template;
      }

      // return a random template
      util::ShPtrVector< FoldTemplate>::iterator random_itr
      (
        random::GetGlobalRandom().Iterator
        (
          templates_itr->second.Begin(), templates_itr->second.End(), templates_itr->second.GetSize()
        )
      );

      BCL_MessageStd
      (
        "The sheet template is picked from " + ( *random_itr)->GetPDBID()
      )

      // if this is the first time this template is being picked
      // then the topology won't be initialized yet
      // therefore we need to collect the sheet topology and update the topology with this information
      if( !( *random_itr)->IsTopologyInitialized())
      {
        InitializeTopology( **random_itr);
      }

      // end
      return **random_itr;
    }

    //! @brief picks a random template of the appropriate size and geometry lengths
    //! @param SSES sses used to chose subtemplate based on length
    //! @param SSE_GEOMETRY_COMPARE comparison method
    //! @return a random template
    const FoldTemplate &SheetTemplateHandler::GetRandomTemplate
    (
      const util::SiPtrVector< const SSE> &SSES,
      const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE
    )
    {
      // create static undefined template
      static const FoldTemplate s_undefined_template;

      // create an iterator to the vector of templates with the correct number of helices and strands
      storage::Map< size_t, util::ShPtrVector< FoldTemplate> >::iterator templates_itr( GetTemplates().Find( SSES.GetSize()));

      // if iterator is invalid, return empty fold template
      if( templates_itr == GetTemplates().End())
      {
        BCL_MessageStd
        (
          "Unable to find a sheet template with " + util::Format()( SSES.GetSize()) + " strands"
        );
        return s_undefined_template;
      }

      // initialize vector of matching templates
      util::ShPtrVector< FoldTemplate> matching_templates;

      // iterate through the templates
      for
      (
        util::ShPtrVector< FoldTemplate>::const_iterator template_itr( templates_itr->second.Begin()),
          template_itr_end( templates_itr->second.End());
        template_itr != template_itr_end; ++template_itr
      )
      {
        // if the geometries match the sses
        if( ( *template_itr)->HasSimilarSizeGeometries( SSES, SSE_GEOMETRY_COMPARE))
        {
          // add this template
          matching_templates.PushBack( *template_itr);
        }
      }

      // get a random template
      util::ShPtrVector< FoldTemplate>::iterator random_itr
      (
        random::GetGlobalRandom().Iterator
        (
          matching_templates.Begin(), matching_templates.End(), matching_templates.GetSize()
        )
      );

      // if no template was found
      if( random_itr == matching_templates.End())
      {
        BCL_MessageStd
        (
          "Unable to find a sheet template with " +
          util::Format()( SSES.GetSize()) + " strands that had the proper geometry sizes"
        );
        // return an empty template
        return s_undefined_template;
      }

      // if this is the first time this template is being picked
      // then the topology won't be initialized yet
      // therefore we need to collect the sheet topology and update the topology with this information
      if( !( *random_itr)->IsTopologyInitialized())
      {
        InitializeTopology( **random_itr);
      }

      // return a random template
      return **random_itr;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SheetTemplateHandler::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SheetTemplateHandler::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief singleton function to return sheet templates previously generated and stored in a file
    //! @return sheet templates previously generated and stored in a file
    storage::Map< size_t, util::ShPtrVector< FoldTemplate> > &SheetTemplateHandler::GetTemplates()
    {
      // if the map is not initialized
      if( s_TemplateMap.IsEmpty())
      {
        // get the template type
        const std::string &template_type( GetFlagSheetTemplates()->GetFirstParameter()->GetValue());

        // if both soluble and membrane are to be used
        if( template_type == "all")
        {
          // read in both
          s_TemplateMap = ReadTemplates
          (
            storage::Set< std::string>( GetInputFilename( "soluble"), GetInputFilename( "membrane"))
          );
        }
        // only one type is to be used
        else
        {
          // read in that type
          s_TemplateMap = ReadTemplates( storage::Set< std::string>( GetInputFilename( template_type)));
        }
      }

      //end
      return s_TemplateMap;
    }

    //! @brief singleton function to return sheet templates previously generated and stored in a file
    //! @param FILENAMES set of filenames to be read in
    //! @return sheet templates previously generated and stored in a file
    storage::Map< size_t, util::ShPtrVector< FoldTemplate> > SheetTemplateHandler::ReadTemplates
    (
      const storage::Set< std::string> &FILENAMES
    )
    {
      // initialize storage map
      storage::Map< size_t, util::ShPtrVector< FoldTemplate> > sheet_template_map;

      // initialize collector
      const util::ShPtr< CollectorTopologyInterface> sp_collector
      (
        new CollectorTopologySheet()
      );

      // iterate through the filenames
      for
      (
        storage::Set< std::string>::const_iterator file_itr( FILENAMES.Begin()), file_itr_end( FILENAMES.End());
        file_itr != file_itr_end; ++file_itr
      )
      {
        // open input file
        io::IFStream read;
        io::File::MustOpenIFStream( read, *file_itr);

        // read in the number of templates
        size_t number_of_templates;
        read >> number_of_templates;

        // iterate through the number of templates
        for( size_t i( 0); i != number_of_templates; ++i)
        {
          // initialize vectors of geometries
          util::ShPtrVector< SSEGeometryPhiPsi> geometry_vector;

          // read the number of geometries and the pdb id
          size_t nr_strands;
          std::string pdb_id;
          read >> pdb_id >> nr_strands;

          // iterate over the number of geometries
          for( size_t j( 0); j != nr_strands; ++j)
          {
            // read in the type
            std::string ss_type_string;
            read >> ss_type_string;
            biol::SSType ss_type( biol::GetSSTypes().GetEnumFromName( ss_type_string));

            // read in N coords
            linal::Vector3D n_coords;
            for( size_t k( 0); k != 3; ++k)
            {
              read >> n_coords( k);
            }

            // read in CA coords
            linal::Vector3D ca_coords;
            for( size_t k( 0); k != 3; ++k)
            {
              read >> ca_coords( k);
            }

            // read in C coords
            linal::Vector3D c_coords;
            for( size_t k( 0); k != 3; ++k)
            {
              read >> c_coords( k);
            }

            // read in phi/psi size
            size_t nr_residues;
            read >> nr_residues;

            // read in the first psi
            storage::Vector< storage::VectorND< 2, double> > angles;
            double first_psi;
            read >> first_psi;
            angles.PushBack( storage::VectorND< 2, double>( util::GetUndefined< double>(), first_psi));

            // iterate over the number of residues ( minus 2 since the first and last angles are nan) to read in phi/psis
            for( size_t l( 0); l != nr_residues - 2; ++l)
            {
              double phi;
              double psi;
              read >> phi >> psi;

              angles.PushBack( storage::VectorND< 2, double>( phi, psi));
            }

            // read in the last phi
            double last_phi;
            read >> last_phi;
            angles.PushBack( storage::VectorND< 2, double>( last_phi, util::GetUndefined< double>()));

            // add the geometry to the vector
            geometry_vector.PushBack
            (
              util::ShPtr< SSEGeometryPhiPsi>
              (
                new SSEGeometryPhiPsi
                (
                  biol::AASequencePhiPsi( n_coords, ca_coords, c_coords, angles),
                  ss_type,
                  "S" + util::Format()( nr_strands)
                )
              )
            );
          }

          // if the template is not to be excluded
          if( !GetExcludedPdbs().Contains( pdb_id))
          {
            // create the fold template and add it to the map
            sheet_template_map[ nr_strands].PushBack
            (
              util::ShPtr< FoldTemplate>( new FoldTemplate( geometry_vector, sp_collector, pdb_id, false))
            );
          }
        }

        // close the read stream
        io::File::CloseClearFStream( read);
      }

      // end
      return sheet_template_map;
    }

    //! @brief default input filename
    //! @param TEMPLATE_TYPE type of templates to use
    //! @return default input filename
    const std::string &SheetTemplateHandler::GetInputFilename( const std::string &TEMPLATE_TYPE)
    {
      // initialize with default file names
      static const std::string s_soluble_filename( score::Score::AddHistogramPath( "soluble_sheet_templates.input"));
      static const std::string s_membrane_filename( score::Score::AddHistogramPath( "membrane_sheet_templates.input"));
      static const std::string s_undefined;

      // return filename determined by fold template type
      if( TEMPLATE_TYPE == "soluble")
      {
        return s_soluble_filename;
      }
      else if( TEMPLATE_TYPE == "membrane")
      {
        return s_membrane_filename;
      }

      // type should be soluble or membrane so if this point is reached return default string
      return s_undefined;
    }

    //! @brief return set of excluded pdb ids
    //! @return set of excluded pdb ids
    storage::Set< std::string> &SheetTemplateHandler::GetExcludedPdbs()
    {
      static storage::Set< std::string> s_excluded_pdbs;

      // if a file that contains PDBs to exclude as templates was passed
      if( s_excluded_pdbs.IsEmpty() && GetFlagSheetTemplates()->GetParameterList()( 1)->GetWasSetInCommandLine())
      {
        // open the file
        io::IFStream read;
        io::File::MustOpenIFStream( read, GetFlagSheetTemplates()->GetParameterList()( 1)->GetValue());

        // read in the pdb ids
        while( !read.eof())
        {
          std::string temp_string;
          read >> temp_string;

          // add the string to the set
          if( temp_string != "")
          {
            std::transform( temp_string.begin(), temp_string.end(), temp_string.begin(), toupper);
            s_excluded_pdbs.Insert( temp_string);
          }
        }
        io::File::CloseClearFStream( read);
      }

      // end
      return s_excluded_pdbs;
    }

    //! @brief initialize the sheet template topology
    //! @param SHEET_TEMPLATE sheet template for which topology will be initialized
    void SheetTemplateHandler::InitializeTopology( FoldTemplate &SHEET_TEMPLATE)
    {
      // calculate the geometries
      SHEET_TEMPLATE.CalculateSSEGeometries();

      // collect the sheet topology from the given vector of geometries
      util::ShPtrVector< Topology> sheet_vector( CollectorTopologySheet().Collect( SHEET_TEMPLATE.GetGeometries()));

      BCL_MessageStd
      (
        "The picked template, has " + util::Format()( sheet_vector.GetSize()) +
        " sheet/s and #strands for first one: " + util::Format()( sheet_vector.FirstElement()->GetElements().GetSize())
      );

      // make sure there is only one sheet and is of correct size
      if
      (
        sheet_vector.GetSize() != 1 ||
        sheet_vector.FirstElement()->GetElements().GetSize() != SHEET_TEMPLATE.GetGeometries().GetSize()
      )
      {
        BCL_MessageCrt( "There was a problem with sheet topology building from sheet template selected");
      }
      else
      {
        // update the sheet topology
        SHEET_TEMPLATE.SetTopology( *sheet_vector.FirstElement());
      }
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_compare.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  ///////////////
  // operators //
  ///////////////

    //! @brief return true if SSE_A comes before SSE_B in sequence
    //! @param SSE_A first SSE
    //! @param SSE_B second SSE
    //! @return true if SSE_A comes before SSE_B in sequence
    bool SSELessThan::operator()( const SSE &SSE_A, const SSE &SSE_B) const
    {
      // if in a previous chain
      if( SSE_A.GetChainID() < SSE_B.GetChainID())
      {
        return true;
      }

      // if in the same chain
      if( SSE_A.GetChainID() == SSE_B.GetChainID())
      {
        // check that there are amino acids available - if they are nt, compare size
        if( SSE_A.GetData().IsEmpty() || SSE_B.GetData().IsEmpty())
        {
          return SSE_A.GetSize() < SSE_B.GetSize();
        }

        // if sse_a starts first return true
        if( SSE_A.GetFirstAA()->GetSeqID() < SSE_B.GetFirstAA()->GetSeqID())
        {
          return true;
        }
        // if sse_a starts at the same position
        if( SSE_A.GetFirstAA()->GetSeqID() == SSE_B.GetFirstAA()->GetSeqID())
        {
          // if sse_a ends earlier
          if( SSE_A.GetLastAA()->GetSeqID() < SSE_B.GetLastAA()->GetSeqID())
          {
            return true;
          }
          // if they end at the same seq id
          if( SSE_A.GetLastAA()->GetSeqID() == SSE_B.GetLastAA()->GetSeqID())
          {
            // check if ss_type is smaller
            if( SSE_A.GetType() < SSE_B.GetType())
            {
              return true;
            }
          }
        }
      }

      // for all other cases return false
      return false;
    }

    //! @brief returns true if PTR_SSE_A comes before PTR_SSE_B in sequence
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A comes before PTR_SSE_B in sequence
    bool SSELessThan::operator()
    (
      const util::PtrInterface< SSE> &PTR_SSE_A,
      const util::PtrInterface< SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if PTR_SSE_A comes before PTR_SSE_B in sequence
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A comes before PTR_SSE_B in sequence
    bool SSELessThan::operator()
    (
      const util::PtrInterface< const SSE> &PTR_SSE_A,
      const util::PtrInterface< const SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if PTR_SSE_A comes before PTR_SSE_B in sequence
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A comes before PTR_SSE_B in sequence
    bool SSELessThan::operator()
    (
      const util::PtrInterface< const SSE> &PTR_SSE_A,
      const util::PtrInterface< SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if PTR_SSE_A comes before PTR_SSE_B in sequence
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A comes before PTR_SSE_B in sequence
    bool SSELessThan::operator()
    (
      const util::PtrInterface< SSE> &PTR_SSE_A,
      const util::PtrInterface< const SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief return true if SSE_A comes before SSE_B in sequence, false if overlap
    //! @param SSE_A first SSE
    //! @param SSE_B second SSE
    //! @return true if SSE_A comes before SSE_B in sequence, false if overlap
    bool SSELessThanNoOverlap::operator()( const SSE &SSE_A, const SSE &SSE_B) const
    {
      if( SSE_A.GetChainID() < SSE_B.GetChainID())
      {
        return true;
      }
      else if( SSE_A.GetChainID() > SSE_B.GetChainID())
      {
        return false;
      }

      // an empty sse is smaller
      if( SSE_A.GetData().IsEmpty())
      {
        return true;
      }

      // an empty is smaller
      if( SSE_B.GetData().IsEmpty())
      {
        return false;
      }

      if
      (
        ( SSE_A.GetFirstAA()->GetSeqID() < SSE_B.GetFirstAA()->GetSeqID())
        &&
        ( SSE_A.GetLastAA()->GetSeqID() < SSE_B.GetFirstAA()->GetSeqID()))
      {
        return true;
      }

      // else return larger
      return false;
    }

    //! @brief returns true if PTR_SSE_A comes before PTR_SSE_B in sequence, false if overlap
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A comes before PTR_SSE_B in sequence, false if overlap
    bool SSELessThanNoOverlap::operator()
    (
      const util::PtrInterface< SSE> &PTR_SSE_A,
      const util::PtrInterface< SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if PTR_SSE_A comes before PTR_SSE_B in sequence, false if overlap
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A comes before PTR_SSE_B in sequence, false if overlap
    bool SSELessThanNoOverlap::operator()
    (
      const util::PtrInterface< const SSE> &PTR_SSE_A,
      const util::PtrInterface< const SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if SSE_A comes before SSE_B in sequence, false if overlap
    //! @param SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if SSE_A comes before PTR_SSE_B in sequence, false if overlap
    bool SSELessThanNoOverlap::operator()( const SSE &SSE_A, const util::PtrInterface< SSE> &PTR_SSE_B) const
    {
      return operator()( SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if SSE_A comes before SSE_B in sequence, false if overlap
    //! @param SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if SSE_A comes before PTR_SSE_B in sequence, false if overlap
    bool SSELessThanNoOverlap::operator()( const SSE &SSE_A, const util::PtrInterface< const SSE> &PTR_SSE_B) const
    {
      return operator()( SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if SSE_A comes before SSE_B in sequence, false if overlap
    //! @param PTR_SSE_A first SSE
    //! @param SSE_B second SSE
    //! @return true if PTR_SSE_A comes before SSE_B in sequence, false if overlap
    bool SSELessThanNoOverlap::operator()( const util::PtrInterface< SSE> &PTR_SSE_A, const SSE &SSE_B) const
    {
      return operator()( *PTR_SSE_A, SSE_B);
    }

    //! @brief returns true if SSE_A comes before SSE_B in sequence, false if overlap
    //! @param PTR_SSE_A first SSE
    //! @param SSE_B second SSE
    //! @return true if PTR_SSE_A comes before SSE_B in sequence, false if overlap
    bool SSELessThanNoOverlap::operator()( const util::PtrInterface< const SSE> &PTR_SSE_A, const SSE &SSE_B) const
    {
      return operator()( *PTR_SSE_A, SSE_B);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief return true if SSE_A is smaller than SSE_B in size
    //! @param SSE_A first SSE
    //! @param SSE_B second SSE
    //! @return true if SSE_A is smaller than SSE_B in size
    bool SSELessThanBySize::operator()( const SSE &SSE_A, const SSE &SSE_B) const
    {
      // if has a smaller size
      if( SSE_A.GetSize() < SSE_B.GetSize())
      {
        return true;
      }
      // if the sizes of both SSEs are same
      if( SSE_A.GetSize() == SSE_B.GetSize())
      {
        // if in a previous chain
        if( SSE_A.GetChainID() < SSE_B.GetChainID())
        {
          return true;
        }
        // if in the same chain
        if( SSE_A.GetChainID() == SSE_B.GetChainID())
        {
          // if sse_a starts first return true
          if( SSE_A.GetFirstAA()->GetSeqID() < SSE_B.GetFirstAA()->GetSeqID())
          {
            return true;
          }
          // if sse_a starts at the same position
          if( SSE_A.GetFirstAA()->GetSeqID() == SSE_B.GetFirstAA()->GetSeqID())
          {
            // if sse_a ends earlier
            if( SSE_A.GetLastAA()->GetSeqID() < SSE_B.GetLastAA()->GetSeqID())
            {
              return true;
            }
            // if they end at the same seq id
            if( SSE_A.GetLastAA()->GetSeqID() == SSE_B.GetLastAA()->GetSeqID())
            {
              // check if ss_type is smaller
              if( SSE_A.GetType() < SSE_B.GetType())
              {
                return true;
              }
            }
          }
        }
      }

      // for all other cases return false
      return false;
    }

    //! @brief returns true if PTR_SSE_A is smaller than PTR_SSE_B in size
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A is smaller than PTR_SSE_B in size
    bool SSELessThanBySize::operator()
    (
      const util::PtrInterface< SSE> &PTR_SSE_A,
      const util::PtrInterface< SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if PTR_SSE_A is smaller than PTR_SSE_B in size
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A is smaller than PTR_SSE_B in size
    bool SSELessThanBySize::operator()
    (
      const util::PtrInterface< const SSE> &PTR_SSE_A,
      const util::PtrInterface< const SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if PTR_SSE_A is smaller than PTR_SSE_B in size
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A is smaller than PTR_SSE_B in size
    bool SSELessThanBySize::operator()
    (
      const util::PtrInterface< const SSE> &PTR_SSE_A,
      const util::PtrInterface< SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

    //! @brief returns true if PTR_SSE_A is smaller than PTR_SSE_B in size
    //! @param PTR_SSE_A first SSE
    //! @param PTR_SSE_B second SSE
    //! @return true if PTR_SSE_A is smaller than PTR_SSE_B in size
    bool SSELessThanBySize::operator()
    (
      const util::PtrInterface< SSE> &PTR_SSE_A,
      const util::PtrInterface< const SSE> &PTR_SSE_B
    ) const
    {
      return operator()( *PTR_SSE_A, *PTR_SSE_B);
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a SSE reference
    //! @param THIS_SSE reference to SSE to be compared against
    SSECompare::SSECompare( const SSE &THIS_SSE) :
      m_SSE( THIS_SSE)
    {
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief compares the provided THIS_SSE with m_SSE to check it is the same sse
    //! @param THIS_SSE SSE to be compared
    //! @return true if THIS_SSE is equal to m_SSE
    bool SSECompare::operator()( const SSE &THIS_SSE) const
    {
      return THIS_SSE == m_SSE;
    }

    //! @brief compares the provided PTR_SSE with m_SSE to check it is the same sse
    //! @param PTR_SSE SSE to be compared
    //! @return true if PTR_SSE is equal to m_SSE
    bool SSECompare::operator()( const util::PtrInterface< SSE> &PTR_SSE) const
    {
      return *PTR_SSE == m_SSE;
    }

    //! @brief compares the provided PTR_SSE with m_SSE to check it is the same sse
    //! @param PTR_SSE SSE to be compared
    //! @return true if PTR_SSE is equal to m_SSE
    bool SSECompare::operator()( const util::PtrInterface< const SSE> &PTR_SSE) const
    {
      return *PTR_SSE == m_SSE;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a begin seq id, end seq id, chain id and SSType
    //! @param BEGIN_SEQ_ID seq id of the first amino acid  of the SSE searched
    //! @param END_SEQ_ID seq id of the last amino acid of the SSE searched
    //! @param CHAIN_ID chain id of the SSE searched
    //! @param SS_TYPE type of the SSE searched
    SSECompareByIdentity::SSECompareByIdentity
    (
      const size_t        BEGIN_SEQ_ID,
      const size_t        END_SEQ_ID,
      const char          CHAIN_ID,
      const biol::SSType &SS_TYPE
    ) :
      m_BeginSeqID( BEGIN_SEQ_ID),
      m_EndSeqID( END_SEQ_ID),
      m_ChainID( CHAIN_ID),
      m_Type( SS_TYPE)
    {
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief compares the provided THIS_SSE with m_SSE to check it is the same sse
    //! @param THIS_SSE SSE to be compared
    //! @return true if THIS_SSE is equal to m_SSE
    bool SSECompareByIdentity::operator()( const SSE &THIS_SSE) const
    {
      return
        size_t( THIS_SSE.GetFirstAA()->GetSeqID()) == m_BeginSeqID &&
        size_t( THIS_SSE.GetLastAA()->GetSeqID()) == m_EndSeqID &&
        THIS_SSE.GetChainID() == m_ChainID &&
        THIS_SSE.GetType() == m_Type;
    }

    //! @brief compares the provided PTR_SSE with m_SSE to check it is the same sse
    //! @param PTR_SSE SSE to be compared
    //! @return true if PTR_SSE is equal to m_SSE
    bool SSECompareByIdentity::operator()( const util::PtrInterface< SSE> &PTR_SSE) const
    {
      return operator()( *PTR_SSE);
    }

    //! @brief compares the provided PTR_SSE with m_SSE to check it is the same sse
    //! @param PTR_SSE SSE to be compared
    //! @return true if PTR_SSE is equal to m_SSE
    bool SSECompareByIdentity::operator()( const util::PtrInterface< const SSE> &PTR_SSE) const
    {
      return operator()( *PTR_SSE);
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a SSE reference
    //! @param THIS_SSE reference to SSE to be compared against
    SSECompareOverlap::SSECompareOverlap( const SSE &THIS_SSE) :
      m_SSE( THIS_SSE)
    {
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief compares the provided THIS_SSE with m_SSE to check for overlap
    //! @param THIS_SSE SSE to be checked for overlap
    //! @return true if THIS_SSE overlaps with m_SSE
    bool SSECompareOverlap::operator()( const SSE &THIS_SSE) const
    {
      // return overlap
      return biol::DoOverlap( THIS_SSE, m_SSE);
    }

    //! @brief compares the provided PTR_SSE with m_SSE to check for overlap
    //! @param PTR_SSE SSE to be checked for overlap
    //! @return true if PTR_SSE overlaps with m_SSE
    bool SSECompareOverlap::operator()( const util::PtrInterface< SSE> &PTR_SSE) const
    {
      // return overlap
      return biol::DoOverlap( *PTR_SSE, m_SSE);
    }

    //! @brief compares the provided PTR_SSE with m_SSE to check for overlap
    //! @param PTR_SSE SSE to be checked for overlap
    //! @return true if PTR_SSE overlaps with m_SSE
    bool SSECompareOverlap::operator()( const util::PtrInterface< const SSE> &PTR_SSE) const
    {
      // return overlap
      return biol::DoOverlap( *PTR_SSE, m_SSE);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_compare_extent.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSECompareExtent::s_Instance
    (
      GetObjectInstances().AddInstance( new SSECompareExtent())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSECompareExtent::SSECompareExtent() :
      m_ExtentTolerance(),
      m_Axis()
    {
    }

    //! @brief constructor from tolerance and axis
    //! @param TOLERANCE extent tolerance to be used
    //! @param AXIS axis to be used (e.g. z axis)
    SSECompareExtent::SSECompareExtent( const double TOLERANCE, const coord::Axis &AXIS) :
      m_ExtentTolerance( TOLERANCE),
      m_Axis( AXIS)
    {
    }

    //! @brief virtual copy constructor
    SSECompareExtent *SSECompareExtent::Clone() const
    {
      return new SSECompareExtent( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that tests whether the two sses have the same extent within some tolerance
    //! @param SSE_A first sse to be tested
    //! @param SSE_B second sse to be tested
    //! @return bool whether the two sses agree in their extent within some tolerance (m_ExtentTolerance)
    bool SSECompareExtent::operator()( const SSE &SSE_A, const SSE &SSE_B) const
    {
      // if the the difference of the extent of the two sses along the specified axis is not greater than the tolerance
      // return true, otherwise false
      return ( math::Absolute( SSE_A.GetExtent( m_Axis) - SSE_B.GetExtent( m_Axis)) < m_ExtentTolerance);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSECompareExtent::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSECompareExtent::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_compare_type.h"

// includes from bcl - sorted alphabetically
#include "io/bcl_io_serialization.h"
#include "util/bcl_util_enumerated.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSECompareType::s_Instance
    (
      util::Enumerated< util::BinaryFunctionInterfaceSerializable< SSE, SSE, bool> >::AddInstance( new SSECompareType())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief virtual copy constructor
    SSECompareType *SSECompareType::Clone() const
    {
      return new SSECompareType( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief get the name of the object when used in a dynamic context
    //! @return the name of the object when used in a dynamic context
    const std::string &SSECompareType::GetAlias() const
    {
      static const std::string s_alias( "SSECompareType");
      return s_alias;
    }

    //! @brief returns parameters for member data that are set up from the labels
    //! @return parameters for member data that are set up from the labels
    io::Serializer SSECompareType::GetSerializer() const
    {
      io::Serializer serializer;
      serializer.SetClassDescription( "Compares the type of SSEs");

      return serializer;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that tests whether the ss type of two sses is the same
    //! @param SSE_A first sse to be tested
    //! @param SSE_B second sse to be tested
    //! @return bool whether the ss type is the same
    bool SSECompareType::operator()( const SSE &SSE_A, const SSE &SSE_B) const
    {
      // return whether the ss type of the two sses is the same
      return SSE_A.GetType() == SSE_B.GetType();
    }

  //////////////////////
  // input and output //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_compare.h"
#include "assemble/bcl_assemble_sse_geometry.h"
#include "biol/bcl_biol_aa_sequence_factory.h"
#include "biol/bcl_biol_aa_sequence_phi_psi.h"
#include "quality/bcl_quality_rmsd.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSE::s_Instance
    (
      GetObjectInstances().AddInstance( new SSE())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from SSType
    //! @param SS_TYPE specific SSType
    SSE::SSE( const biol::SSType &SS_TYPE) :
      biol::AASequence(),
      m_SSType( SS_TYPE),
      m_Orientation(),
      m_XExtent( m_SSType->GetRadialExtent()),
      m_YExtent( m_SSType->GetRadialExtent()),
      m_Fragments()
    {
    }

    //! @brief construct by AASequence and SSType
    //! @param SEQUENCE amino acid sequence
    //! @param SS_TYPE specific SSType
    SSE::SSE( const biol::AASequence &SEQUENCE, const biol::SSType &SS_TYPE) :
      biol::AASequence( SEQUENCE),
      m_SSType( SS_TYPE),
      m_Orientation(),
      m_XExtent( m_SSType->GetRadialExtent()),
      m_YExtent( m_SSType->GetRadialExtent()),
      m_Fragments()
    {
      // only set the geometry if the sequence has proper coordinates
      if( SEQUENCE.HasDefinedCoordinates())
      {
        SetGeometry();
      }
    }

    //! @brief copy constructor
    //! @param SSE_TO_COPY
    SSE::SSE( const SSE &SSE_TO_COPY) :
      biol::AASequence( SSE_TO_COPY),
      m_SSType( SSE_TO_COPY.m_SSType),
      m_Orientation( SSE_TO_COPY.m_Orientation),
      m_XExtent( SSE_TO_COPY.m_XExtent),
      m_YExtent( SSE_TO_COPY.m_YExtent),
      m_Fragments( SSE_TO_COPY.m_Fragments.HardCopy())
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSE
    SSE *SSE::Clone() const
    {
      return new SSE( *this);
    }

    //! @brief virtual hard copy all amino acids and their data
    //! @return SSE with independent hard copied AADatas
    SSE *SSE::HardCopy() const
    {
      // copy for this sequence
      SSE *new_sse( Clone());

      // iterate over all amino acids to make hard copy of the Data
      for
      (
        biol::AASequence::iterator aa_itr( new_sse->Begin()), aa_itr_end( new_sse->End());
        aa_itr != aa_itr_end;
        ++aa_itr
      )
      {
        // hard copy the data for that aa
        ( *aa_itr)->SetData( ( *aa_itr)->GetData().HardCopy());
      }

      // end
      return new_sse;
    }

    //! @brief destructor
    SSE::~SSE()
    {
      m_GeometryDestructorSignal.Emit( *this);
      m_DestructorSignal.Emit( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get identification of this SSE
    //! @return string with identification for this SSE
    std::string SSE::GetIdentification() const
    {
      // initialize identification with SSType, seqid and 3 letter code for beginning and ending amino acid
      std::string identification
      (
        m_SSType.GetName() + ' ' + util::Format()( GetChainID())
      );

      // add identifiers for the first and last residues this sse is spanning
      if( GetSize() > 0)
      {
        identification += ' ' +
          util::Format().W( 4)( GetFirstAA()->GetSeqID()) + ' ' + GetFirstAA()->GetType()->GetThreeLetterCode() +
          " <==> " +
          util::Format().W( 4)( GetLastAA()->GetSeqID()) + ' ' + GetLastAA()->GetType()->GetThreeLetterCode();
      }

      // end
      return identification;
    }

    //! @brief returns the requested extent
    //! @param AXIS axis of interest
    //! @return the requested extent
    double SSE::GetExtent( const coord::Axis &AXIS) const
    {
      // return the appropriate extent
      if( AXIS == coord::GetAxes().e_X)
      {
        return m_XExtent;
      }
      if( AXIS == coord::GetAxes().e_Y)
      {
        return m_YExtent;
      }
      if( AXIS == coord::GetAxes().e_Z)
      {
        return GetLength() / 2.0;
      }

      // else return undefined
      return util::GetUndefinedDouble();
    }

    //! @brief sets the extents
    //! @param EXTENT vector containing the extents in x, y, z
    void SSE::SetExtents( const linal::Vector3D &EXTENT)
    {
      m_XExtent = EXTENT.X();
      m_YExtent = EXTENT.Y();
    }

    //! @brief sets the SSType
    //! @param SS_TYPE SSType to be set
    void SSE::SetType( const biol::SSType &SS_TYPE)
    {
      m_SSType = SS_TYPE;
      SetExtents();
    }

    //! @brief Get SSE hash string to aid in identifying similar chains
    std::string SSE::GetHashString() const
    {
      return util::Format()( m_SSType->GetOneLetterCode())
             + ':' + util::Format()( this->GetFirstAA()->GetSeqID())
             + '-' + util::Format()( this->GetLastAA()->GetSeqID());
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief translate the object along a given TRANSLATION vector
    //! @param TRANSLATION Translation to be applied
    void SSE::Translate( const linal::Vector3D &TRANSLATION)
    {
      // translate sequence
      AASequence::Translate( TRANSLATION);

      // create a transformation matrix from the translation
      math::TransformationMatrix3D transform;
      transform( TRANSLATION);

      // translate the geometries
      TransformGeometries( transform);
    }

    //! @brief transform the object by a given TransformationMatrix3D
    //! @param TRANSFORMATION_MATRIX_3D TransformationMatrix3D to be applied
    void SSE::Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
    {
      // transform sequence
      AASequence::Transform( TRANSFORMATION_MATRIX_3D);

      // transform geometries
      TransformGeometries( TRANSFORMATION_MATRIX_3D);
    }

    //! @brief rotate the object by a given RotationMatrix3D
    //! @param ROTATION_MATRIX_3D RotationMatrix3D to be applied
    void SSE::Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
    {
      // rotate sequence
      AASequence::Rotate( ROTATION_MATRIX_3D);

      // rotate geometries
      TransformGeometries( math::TransformationMatrix3D( ROTATION_MATRIX_3D));
    }

    //! @brief rotation around ROTATION_AXIS that goes through ROTATION_POINT and given ANGLE
    //! @param ROTATION_POINT point which rotation should pass through
    //! @param ROTATION_AXIS RotationAxis around which SSE will be rotated
    //! @param ANGLE angle for the rotation
    void SSE::Rotate( const linal::Vector3D &ROTATION_POINT, const linal::Vector3D &ROTATION_AXIS, const double &ANGLE)
    {
      if( ANGLE == 0 || ( ROTATION_AXIS.X() == 0.0 && ROTATION_AXIS.Y() == 0.0 && ROTATION_AXIS.Z() == 0.0))
      {
        BCL_MessageCrt( "no rotation");

        return;
      }

      // translate all coordinates to origin
      math::TransformationMatrix3D matrix( -ROTATION_POINT);

      //build TransformationMatrix3D
      matrix( math::RotationMatrix3D( ROTATION_AXIS, ANGLE));

      // translate all coordinates to former position
      matrix( ROTATION_POINT);

      // transform with TransformationMatrix
      Transform( matrix);
    }

    //! @brief sets the conformation to idealized at origin
    void SSE::SetToIdealConformationAtOrigin()
    {
      if( !m_SSType->IsStructured())
      {
        return;
      }

      // idealize this sequence
      biol::AASequenceFactory::IdealizeSequence( *this, m_SSType);

      // reset the orientation
      m_Orientation = math::TransformationMatrix3D();

      // iterate over the geometries
      m_Fragments.Reset();
      SetFragmentGeometries();
    }

    //! @brief sets the conformation to idealized in place
    void SSE::SetToIdealConformationInPlace()
    {
      if( !m_SSType->IsStructured())
      {
        return;
      }

      // make a copy of the sequence
      biol::AASequence template_copy( *this);

      // reset the fragments
      m_Fragments.Reset();

      // set sequence to ideal conformation
      SetToIdealConformationAtOrigin();

      // superimpose with template
      Transform( biol::AASequenceFactory::CalculateSuperimposition( *this, template_copy));

      // set the geometries
      SetFragmentGeometries();
    }

    //! @brief sets all geometries; main geometry and fragment geometries
    void SSE::SetGeometry()
    {
      // set the main geometry
      SetMainGeometry();

      // set fragment geometries
      SetFragmentGeometries();
    }

    //! @brief sets the main geometry to the geometry of an copy SSE that is idealized, does not set fragment geometries
    void SSE::SetMainGeometry()
    {
      // set the extents
      SetExtents();

      // if this is a coil
      if( !m_SSType->IsStructured())
      {
        // initialize a transformation matrix
        // calculate the center of mass
        m_Orientation =
        math::TransformationMatrix3D
        (
          *coord::GetAxes().e_X,
          *coord::GetAxes().e_Y,
          *coord::GetAxes().e_Z,
          coord::CenterOfMass( GetAtomCoordinates( biol::GetAtomTypes().GetBackBoneAtomTypes()), true)
        );
      }

      // else if it's a helix or a strand
      else
      {
        // make a copy of the sequence
        biol::AASequence sequence_copy( *this);

        // idealize the copy
        biol::AASequenceFactory::IdealizeSequence( sequence_copy, m_SSType);

        // calculate the transformation that will superimpose the idealized sequence onto this sequence
        math::TransformationMatrix3D transformation
        (
          biol::AASequenceFactory::CalculateSuperimposition( sequence_copy, *this)
        );

        // update the main geometry to this transformation
        m_Orientation = transformation;
      }
    }

    //! @brief returns a storage::Set of SSEs chopped to pieces of minimal size with spacing of one aa
    //! @param SIZE minimal size
    //! @return a storage::Set of SSEs chopped to pieces of minimal size with spacing of one aa
    storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> SSE::Chop( const size_t &SIZE) const
    {
      BCL_Assert( SIZE != 0, "cannot chop into sequences of size 0");

      //chop the sequence
      util::ShPtrVector< biol::AASequence> chopped_sequence( biol::AASequence::ChopSequence( SIZE));

      //build new sses from chopped sequence
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> chopped_sses;

      //iterate over chopped sequence and pushback new sses
      for
      (
        util::ShPtrVector< biol::AASequence>::const_iterator seq_itr( chopped_sequence.Begin()),
          seq_itr_end( chopped_sequence.End());
        seq_itr != seq_itr_end;
        ++seq_itr
      )
      {
        chopped_sses.Insert( util::ShPtr< SSE>( new SSE( **seq_itr, GetType())));
      }

      //return chopped sequence
      return chopped_sses;
    }

    //! @brief finds the coordinates for the given amino acid and prepends it to the sequence
    //! @param AMINO_ACID amino acid to be prepended
    //! @param IDEALIZE bool whether to idealize the SSE prior to prepending
    void SSE::Prepend( const biol::AABase &AMINO_ACID, const bool IDEALIZE)
    {
      // check the chain id and the sequence id of the given amino acid for compatibility
      BCL_Assert
      (
        AMINO_ACID.GetChainID() == GetChainID() && AMINO_ACID.GetSeqID() == GetFirstAA()->GetSeqID() - 1,
        "The given amino acid: " + AMINO_ACID.GetIdentification() + " cannot be added to this SSE " +
        GetIdentification()
      );

      // initialize transformation matrix
      math::TransformationMatrix3D transform;

      // if the SSE should be idealized
      if( IDEALIZE)
      {
        // idealize this SSE
        SetToIdealConformationInPlace();

        // initialize the transformation matrix to the body of the fragment
        transform = this->GetOrientation();

        // find the translation
        transform( -1.0 * GetLength() / 2.0 * GetAxis( coord::GetAxes().e_Z));
      }
      // do not idealize SSE and determine transformation from last residue
      else
      {
        // get the first AA
        util::ShPtr< biol::AABase> first_aa( GetData().FirstElement());

        // make a hardcopy and set to ideal at origin
        util::ShPtr< biol::AABase> copy_aa( first_aa.HardCopy());
        copy_aa->SetToIdealConformation( m_SSType, math::TransformationMatrix3D());

        // get the transformation matrix to superimpose the aa's
        transform = quality::RMSD::SuperimposeCoordinates( first_aa->GetAtomCoordinates(), copy_aa->GetAtomCoordinates());
      }

      // make a copy for the transformation for going from one residue to the next and invert it
      math::TransformationMatrix3D transform_for_residue( m_SSType->GetTransformationMatrixForResidues());
      transform_for_residue.Invert();

      // make a copy of this amino acid
      util::ShPtr< biol::AABase> new_aa( AMINO_ACID.Clone());

      // now set to ideal coordinates for the calculated transformation at the origin
      new_aa->SetToIdealConformation( m_SSType, transform_for_residue);

      // now to transform to the original coordinate
      new_aa->Transform( transform);

      // prepend the amino acid into the sequence
      biol::AASequence::PushFront( *new_aa);

      // set geometry
      SetGeometry();
    }

    //! @brief calculates ideal coordinates for the given amino acid and appends it to the sequence
    //! @param AMINO_ACID amino acid to be appended
    //! @param IDEALIZE bool whether to idealize the SSE prior to appending
    void SSE::Append( const biol::AABase &AMINO_ACID, const bool IDEALIZE)
    {
      // check the chain id and the sequence id of the given amino acid for compatibility
      BCL_Assert
      (
        AMINO_ACID.GetChainID() == GetChainID() && AMINO_ACID.GetSeqID() == GetLastAA()->GetSeqID() + 1,
        "The given amino acid: " + AMINO_ACID.GetIdentification() + " cannot be added to this SSE " +
        GetIdentification()
      );

      // make a copy of this amino acid
      util::ShPtr< biol::AABase> new_aa( AMINO_ACID.Clone());

      // initialize transformations
      math::TransformationMatrix3D transform;
      math::TransformationMatrix3D relative_residue_transform;

      // if the SSE should be idealized
      if( IDEALIZE)
      {
        // idealize this SSE
        SetToIdealConformationInPlace();

        // create a transformation to store the relative residue transformation
        relative_residue_transform
        (
          ( GetSize() * m_SSType->GetRiseInZPerResidue() / 2.0) * ( *coord::GetAxes().e_Z)
        );

        // apply the correct rotation
        relative_residue_transform( coord::GetAxes().e_Z, GetSize() * m_SSType->GetAnglePerTurn());

        // now to transform to the original coordinate
        transform = this->GetOrientation();
      }
      // do not idealize SSE and determine transformation from last residue
      else
      {
        // get the last aa
        util::ShPtr< biol::AABase> last_aa( GetData().LastElement());

        // make a hardcopy and set to ideal at origin
        util::ShPtr< biol::AABase> copy_aa( last_aa.HardCopy());
        copy_aa->SetToIdealConformation( m_SSType, math::TransformationMatrix3D());

        // get the transformation matrix to superimpose the aa's
        transform = quality::RMSD::SuperimposeCoordinates( last_aa->GetAtomCoordinates(), copy_aa->GetAtomCoordinates());

        // apply the incremental residue transformation
        relative_residue_transform( m_SSType->GetTransformationMatrixForResidues());
      }

      // now set to ideal coordinates for the calculated transformation
      new_aa->SetToIdealConformation( m_SSType, relative_residue_transform);

      // now to transform to the original coordinate
      new_aa->Transform( transform);

      // prepend the amino acid into the sequence
      biol::AASequence::PushBack( *new_aa);

      // set geometry
      SetGeometry();
    }

    //! @brief calculates ideal coordinates for the amino acids in the given sequence and prepends them to the sequence
    //! @param AA_SEQUENCE sequence to be prepended
    //! @param IDEALIZE bool whether to idealize the SSE prior to prepending
    void SSE::PrependSequence( const AASequence &AA_SEQUENCE, const bool IDEALIZE)
    {
      // if empty sequence is passed then do nothing
      if( AA_SEQUENCE.GetSize() == 0)
      {
        return;
      }

      // check the chain ids match, as well as seq id ares in correct order and the given sequence is continous
      BCL_Assert
      (
        AA_SEQUENCE.DoesPrecede( *this),
        "The given sequence: " + AA_SEQUENCE.GetSequenceIdentification() + " cannot be prepended to this SSE " +
        GetIdentification()
      );

      // initialize the transformation matrix
      math::TransformationMatrix3D transform;

      // if the SSE should be idealized
      if( IDEALIZE)
      {
        // idealize this SSE
        SetToIdealConformationInPlace();

        // initialize the transformation matrix to the body of the fragment
        transform = this->GetOrientation();

        // find the translation
        transform( -1.0 * GetLength() / 2.0 * GetAxis( coord::GetAxes().e_Z));
      }
      // do not idealize SSE and determine transformation from last residue
      else
      {
        // get the last aa
        util::ShPtr< biol::AABase> first_aa( GetData().FirstElement());

        // make a hardcopy and set to ideal at origin
        util::ShPtr< biol::AABase> copy_aa( first_aa.HardCopy());
        copy_aa->SetToIdealConformation( m_SSType, math::TransformationMatrix3D());

        // get the transformation matrix to superimpose the aa's
        transform = quality::RMSD::SuperimposeCoordinates( first_aa->GetAtomCoordinates(), copy_aa->GetAtomCoordinates());
      }

      // make a copy for the transformation for going from one residue to the next and invert it
      math::TransformationMatrix3D transform_for_prev_residue( m_SSType->GetTransformationMatrixForResidues());
      transform_for_prev_residue.Invert();

      // initialize a transformation for the residue to build up the cumulative transformation
      math::TransformationMatrix3D cumulative_transform_for_residue;

      // iterate over residues to add in reverse order
      for
      (
        biol::AASequence::const_reverse_iterator aa_itr( AA_SEQUENCE.ReverseBegin()),
          aa_itr_end( AA_SEQUENCE.ReverseEnd());
        aa_itr != aa_itr_end; ++aa_itr
      )
      {
        // make a copy of this amino acid
        util::ShPtr< biol::AABase> new_aa( ( *aa_itr)->Clone());

        // update the cumulative residue transformation
        cumulative_transform_for_residue( transform_for_prev_residue);

        // now set to ideal coordinates for the calculated transformation at the origin
        new_aa->SetToIdealConformation( m_SSType, cumulative_transform_for_residue);

        // now to transform to the original coordinate
        new_aa->Transform( transform);

        // prepend the amino acid into the sequence
        biol::AASequence::PushFront( *new_aa);
      }

      // set geometry
      SetGeometry();
    }

    //! @brief calculates ideal coordinates for the amino acids in the given sequence and appends them to the sequence
    //! @param AA_SEQUENCE sequence acid to be appended
    //! @param IDEALIZE bool whether to idealize the SSE prior to appending
    void SSE::AppendSequence( const AASequence &AA_SEQUENCE, const bool IDEALIZE)
    {
      // if empty sequence is passed then do nothing
      if( AA_SEQUENCE.GetSize() == 0)
      {
        return;
      }

      // if already peptide bonded, don't fix position of AA_SEQUENCE
      if( !IDEALIZE && biol::AABase::AreAminoAcidsPeptideBonded( *GetLastAA(), *AA_SEQUENCE.GetFirstAA(), true))
      {
        biol::AASequence::AppendSequence( AA_SEQUENCE);
      }
      else
      {
        // check the chain ids match, as well as seq id ares in correct order and the given sequence is continous
        BCL_Assert
        (
          DoesPrecede( AA_SEQUENCE),
          "The given sequence: " + AA_SEQUENCE.GetSequenceIdentification() + " cannot be appended to this SSE " +
          GetIdentification()
        );

        // create a transformation to store the relative residue transformation
        math::TransformationMatrix3D relative_residue_transform;
        math::TransformationMatrix3D transform;

        // if the SSE should be idealized
        if( IDEALIZE)
        {
          // idealize this SSE
          SetToIdealConformationInPlace();

          relative_residue_transform
          (
            ( ( GetSize() - 1) * m_SSType->GetRiseInZPerResidue() - GetLength() / 2.0) * ( *coord::GetAxes().e_Z)
          );

          // apply the correct rotation and overall transformation
          relative_residue_transform( coord::GetAxes().e_Z, ( GetSize() - 1) * m_SSType->GetAnglePerTurn());
          transform = this->GetOrientation();
        }
        // do not idealize SSE and determine transformation from last residue
        else
        {
          // get the last aa
          const biol::AABase &last_aa( *GetData().LastElement());

          // make a hardcopy and set to ideal at origin
          util::ShPtr< biol::AABase> copy_aa( last_aa.Clone());
          copy_aa->SetToIdealConformation( m_SSType, math::TransformationMatrix3D());

          // get the transformation matrix to superimpose the aa's
          transform = quality::RMSD::SuperimposeCoordinates
              (
                last_aa.GetAtomCoordinates( biol::GetAtomTypes().GetBackBoneAtomTypes()),
                copy_aa->GetAtomCoordinates( biol::GetAtomTypes().GetBackBoneAtomTypes())
              );
        }

        // iterate over residues to add
        for
        (
          biol::AASequence::const_iterator aa_itr( AA_SEQUENCE.Begin()), aa_itr_end( AA_SEQUENCE.End());
          aa_itr != aa_itr_end; ++aa_itr
        )
        {
          // make a copy of this amino acid
          util::ShPtr< biol::AABase> new_aa( ( *aa_itr)->Clone());

          // apply the incremental residue transformation
          relative_residue_transform( m_SSType->GetTransformationMatrixForResidues());

          // now set to ideal coordinates for the calculated transformation
          new_aa->SetToIdealConformation( m_SSType, relative_residue_transform);

          // now to transform to the original coordinate
          new_aa->Transform( transform);

          // prepend the amino acid into the sequence
          biol::AASequence::PushBack( *new_aa);
        }
      }

      // set geometry
      SetGeometry();
    }

    //! @brief fits SSE using this sequence and the passed SSE as a template
    //! @param SSE_TEMPLATE SSE to be used as a template
    //! @return fit SSE
    void SSE::FitToSSE( const SSE &SSE_TEMPLATE)
    {
      // if the SSE's are different types
      if( m_SSType != SSE_TEMPLATE.GetType())
      {
        // warn the user and switch this type
        BCL_MessageCrt( "Fitting SSE to another type!");
        m_SSType = SSE_TEMPLATE.GetType();
      }

      // fit the sequence
      biol::AASequenceFactory::FitSequence
      (
        *this,
        biol::AASequencePhiPsi( SSE_TEMPLATE),
        m_SSType
      );

      // update the geometry
      SetGeometry();
    }

    //! @brief get the longest contiguous predicted TM-segment
    bool SSE::IsPredictedTransmembrane() const
    {
      size_t length_current_seg( 0);
      auto method( sspred::GetMethods().GetCommandLineMethods());
      for( auto itr( this->GetData().Begin()), itr_end( this->GetData().End()); itr != itr_end; ++itr)
      {
        bool was_in_mem( false);
        for( auto itr_method( method.Begin()), itr_method_end( method.End()); itr_method != itr_method_end; ++itr_method)
        {
          auto method_pred( ( *itr)->GetSSPrediction( *itr_method));
          if( method_pred.IsDefined() && method_pred->GetOneStateTMPrediction() == biol::GetEnvironmentTypes().e_MembraneCore)
          {
            was_in_mem = true;
            break;
          }
        }
        if( !was_in_mem)
        {
          length_current_seg = 0;
        }
        else
        {
          ++length_current_seg;
          if
          (
            ( length_current_seg > size_t( 16) && m_SSType == biol::GetSSTypes().HELIX)
            || ( length_current_seg > size_t( 5) && m_SSType == biol::GetSSTypes().STRAND)
          )
          {
            return true;
          }
        }
      }
      return false;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator = SSE : makes HardCopy of the m_Data through the BaseClass operator =
    //! @param SSE_RHS SSE to be assigned to
    //! @return this SSE after assignment
    SSE &SSE::operator =( const SSE &SSE_RHS)
    {
      biol::AASequence::operator =( SSE_RHS);
      m_SSType = SSE_RHS.m_SSType;
      m_Orientation = SSE_RHS.m_Orientation;
      m_XExtent = SSE_RHS.m_XExtent;
      m_YExtent = SSE_RHS.m_YExtent;
      m_Fragments = SSE_RHS.m_Fragments;

      // emit coordinate change signal
      m_GeometryCoordinateChangeSignal.Emit( *this);
      m_CoordinateChangeSignal.Emit( *this);

      // retrun this
      return *this;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSE::Read( std::istream &ISTREAM)
    {
      // read base class
      biol::AASequence::Read( ISTREAM);

      // read the members
      io::Serialize::Read( m_SSType, ISTREAM);
      io::Serialize::Read( m_Orientation, ISTREAM);
      io::Serialize::Read( m_XExtent, ISTREAM);
      io::Serialize::Read( m_YExtent, ISTREAM);
      io::Serialize::Read( m_Fragments, ISTREAM);

      // emit coordinate change signal
      m_GeometryCoordinateChangeSignal.Emit( *this);
      m_CoordinateChangeSignal.Emit( *this);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSE::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write base class
      biol::AASequence::Write( OSTREAM, INDENT) << '\n';

      // write the members
      io::Serialize::Write( m_SSType, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Orientation, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_XExtent, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_YExtent, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Fragments, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief sets the fragment geometries
    //! @param FRAGMENT_LENGTH fragment length to use
    void SSE::SetFragmentGeometries( size_t FRAGMENT_LENGTH)
    {
      // set the default fragment length (if no FRAGMENT_LENGTH was given)
      if( FRAGMENT_LENGTH == 0)
      {
        FRAGMENT_LENGTH = m_SSType->GetFragmentLength();
      }

      // if the sse is not the right type or the sse is the minimal size or smaller, return
      if( !m_SSType->IsStructured() || GetSize() <= FRAGMENT_LENGTH)
      {
        return;
      }

      // clear the fragment list
      m_Fragments.Reset();

      // calculate the number of geometries
      const size_t number_geometries( GetSize() - FRAGMENT_LENGTH + 1);

      // iterate over the number of geometries
      for( size_t geometry_ctr( 0); geometry_ctr < number_geometries; ++geometry_ctr)
      {
        // get the subsequence that corresponds to this fragment
        biol::AASequence sub_sequence
        (
          SubSequence
          (
            geometry_ctr, // starting position
            FRAGMENT_LENGTH // ending position
          )
        );

        // get central amino acid
        const int center( sub_sequence.GetFirstMember()->GetSeqID() + ( FRAGMENT_LENGTH - 1) / 2);

        // pushback the sse fragment into the fragments vector
        m_Fragments.PushBack
        (
          util::ShPtr< SSEGeometryInterface>
          (
            new SSEGeometry( SSE( sub_sequence, m_SSType), center)
          )
        );
      }

      // emit coordinate change signal
      m_GeometryCoordinateChangeSignal.Emit( *this);
      m_CoordinateChangeSignal.Emit( *this);
    }

    //! @brief sets the extents for the geometry
    void SSE::SetExtents()
    {
      // set the extents
      m_XExtent = m_SSType->GetRadialExtent();
      m_YExtent = m_SSType->GetRadialExtent();
    }

    //! @brief transforms only the geometries while leaving the AASequence coords in place
    //! @param TRANSFORMATION_MATRIX_3D transformation to apply to each geometry
    void SSE::TransformGeometries( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
    {
      // transform orientation
      m_Orientation( TRANSFORMATION_MATRIX_3D);

      // transform fragment geometries
      for
      (
        util::ShPtrVector< SSEGeometryInterface>::iterator fragment_itr( m_Fragments.Begin()),
          fragment_itr_end( m_Fragments.End());
        fragment_itr != fragment_itr_end;
        ++fragment_itr
      )
      {
        ( *fragment_itr)->Transform( TRANSFORMATION_MATRIX_3D);
      }

      // emit coordinate change signal
      m_GeometryCoordinateChangeSignal.Emit( *this);
      m_CoordinateChangeSignal.Emit( *this);
    }

    //! @brief boolean operator SSE_LHS == SSE_RHS
    //! @param SSE_LHS first SSE
    //! @param SSE_RHS second SSE
    //! @return whether SSE_LHS is equal to SSE_RHS
    bool operator ==( const SSE &SSE_LHS, const SSE &SSE_RHS)
    {
      return
      (
        SSE_LHS.GetChainID() == SSE_RHS.GetChainID() &&
        SSE_LHS.GetType()    == SSE_RHS.GetType()    &&
        SSE_LHS.Sequence()   == SSE_RHS.Sequence()   &&
        SSE_LHS.GetFirstAA()->GetSeqID() == SSE_RHS.GetFirstAA()->GetSeqID() &&
        SSE_LHS.GetLastAA()->GetSeqID() == SSE_RHS.GetLastAA()->GetSeqID()
      );
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_factories.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_factory_conformation.h"
#include "assemble/bcl_assemble_sse_factory_mc.h"
#include "sspred/bcl_sspred_sse_factory_highest.h"
#include "sspred/bcl_sspred_sse_factory_threshold.h"
#include "util/bcl_util_enumerate.hpp"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEFactories::SSEFactories() :
      e_Conformation(        AddEnum( "Conformation"   , util::ShPtr< assemble::SSEFactoryInterface>( new         SSEFactoryConformation()))),
      e_PredictionMC(        AddEnum( "SSPredMC"       , util::ShPtr< assemble::SSEFactoryInterface>( new         SSEFactoryMC( sspred::GetMethods().e_Undefined, 0.0)))),
      e_PredictionThreshold( AddEnum( "SSPredThreshold", util::ShPtr< assemble::SSEFactoryInterface>( new sspred::SSEFactoryThreshold( sspred::GetMethods().e_Undefined)))),
      e_PredictionHighest(   AddEnum( "SSPredHighest"  , util::ShPtr< assemble::SSEFactoryInterface>( new sspred::SSEFactoryHighest( sspred::GetMethods().e_Undefined))))
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEFactories::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief create SSEFactoryInterface from enum, threshold and method
    //! @param FACTORY enum of the factory to be used
    //! @param SS_METHOD ss_pred to be used
    //! @param SSTYPE_THRESHOLDS sstype thresholds
    //! @return ShPtr to assemble::SSEFactoryInterface
    util::ShPtr< SSEFactoryInterface> SSEFactories::Create
    (
      const SSEFactory &FACTORY,
      const sspred::Method &SS_METHOD,
      const storage::Map< biol::SSType, double> &SSTYPE_THRESHOLDS
    ) const
    {
      // create factory
      util::ShPtr< SSEFactoryInterface> sp_factory( ( *FACTORY)->Clone());

      // set the member
      sp_factory->SetMethod( SS_METHOD);
      sp_factory->SetThresholds( SSTYPE_THRESHOLDS);

      // end
      return sp_factory;
    }

    //! @brief construct on access function for all SSEFactories
    //! @return reference to only instances of SSEFactories
    const SSEFactories &GetSSEFactories()
    {
      return SSEFactories::GetEnums();
    }

  } // namespace assemble

  namespace util
  {

  /////////////////////////////
  // explicit instantiations //
  /////////////////////////////

    template class BCL_API Enumerate< ShPtr< assemble::SSEFactoryInterface>, assemble::SSEFactories>;

  } // namespace util
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_factory_conformation.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_chain.h"
#include "assemble/bcl_assemble_domain.h"
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "biol/bcl_biol_dssp.h"
#include "biol/bcl_biol_membrane.h"
#include "math/bcl_math_mutate_result.h"
#include "sspred/bcl_sspred_ci_phi_psi.h"
#include "storage/bcl_storage_object_nd_hash_map.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEFactoryConformation::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEFactoryConformation())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEFactoryConformation::SSEFactoryConformation() :
      m_MinSSELengths( 5, 3, 0)
    {
    }

    //! @brief constructor from provided minimal sse lengths
    //! @param MIN_SSE_LENGTHS minimum size of SSEs to be considered
    SSEFactoryConformation::SSEFactoryConformation( const storage::VectorND< 3, size_t> &MIN_SSE_LENGTHS) :
      m_MinSSELengths( MIN_SSE_LENGTHS)
    {
    }

    //! @brief virtual copy constructor
    SSEFactoryConformation *SSEFactoryConformation::Clone() const
    {
      return new SSEFactoryConformation( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEFactoryConformation::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that returns a set of SSEs for the given AASequence
    //! @brief SEQUENCE AASequence from which the SSEPool is going to be built
    //! @return SSEPool built from provided SEQUENCE
    SSEPool
    SSEFactoryConformation::operator()( const biol::AASequence &SEQUENCE) const
    {
      // initialize sse_pool
      SSEPool sse_pool;

      // collection of identified sses
      Domain identified_sses;

      // sequence needs to have at least s_MinimalSequenceLength amino acids
      if( SEQUENCE.GetSize() < s_MinimalSequenceLength)
      {
        return sse_pool;
      }

      ProteinModel model;
      util::ShPtr< Chain> tmp_chain( new Chain( util::CloneToShPtr( SEQUENCE)));
      tmp_chain->Insert( util::ShPtr< SSE>( new SSE( SEQUENCE, biol::GetSSTypes().COIL)));
      model.Insert( tmp_chain);

      const biol::DSSP dssp;
      math::MutateResult< ProteinModel> result( dssp( model));
      storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> dssp_sses
      (
        result.GetArgument().IsDefined()
        ? result.GetArgument()->GetChains().FirstElement()->GetData()
        : storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>()
      );

      // copy the sequence
      biol::AASequence seq_copy( SEQUENCE);

      sspred::CIPhiPsi().Calculate( seq_copy, util::SiPtr< const biol::Membrane>());

      util::ShPtr< SSE> current_sse;

      // find sstype for each amino acid and generate long sequences of a certain sstype
      for
      (
        biol::AASequence::const_iterator
          current_itr( SEQUENCE.Begin()),
          end_itr( SEQUENCE.End()), copy_itr( seq_copy.Begin());
        current_itr != end_itr;
        ++current_itr, ++copy_itr
      )
      {
        // calculate phi and psi and store it in map
        util::SiPtr< const sspred::MethodInterface> ciphipsi_pred
        (
          ( *copy_itr)->GetSSPrediction( sspred::GetMethods().e_CIPhiPsi)
        );
        const biol::SSType current_sstype( ciphipsi_pred.IsDefined() ? ciphipsi_pred->GetOneStateSSPrediction() : biol::GetSSTypes().COIL);

        // there was no sses started yet
        if( !current_sse.IsDefined())
        {
          current_sse =
            util::ShPtr< SSE>
            (
              new SSE( biol::AASequence( ( *current_itr)->GetAAClass(), 0, SEQUENCE.GetChainID()), current_sstype)
            );
        }

        // elongate existing sse of identical sstype
        if( current_sse->GetType() == current_sstype)
        {
          current_sse->PushBack( current_itr->HardCopy());
        }

        // different sstypes - insert sse into domain and create new sse with that aminoacid
        else
        {
          // if sse is not long enough, set it to type coil, otherwise calculate body
          if
          (
            (
              ( current_sse->GetType() == biol::GetSSTypes().HELIX) &&
              ( current_sse->GetSize() < m_MinSSELengths( biol::GetSSTypes().HELIX))
            )
            ||
            (
              ( current_sse->GetType() == biol::GetSSTypes().STRAND) &&
              ( current_sse->GetSize() < m_MinSSELengths( biol::GetSSTypes().STRAND))
            )
          )
          {
            current_sse->SetType( biol::GetSSTypes().COIL);
          }
          // else if sse is long enough
          else
          {
            current_sse->SetGeometry();
          }

          if( current_sse->GetType()->IsStructured())
          {
            // insert current sse
            current_sse->SetChainID( SEQUENCE.GetChainID());
            auto itr_dssp( dssp_sses.Find( current_sse));
            while( itr_dssp != dssp_sses.End())
            {
              dssp_sses.RemoveElement( itr_dssp);
              itr_dssp = dssp_sses.Find( current_sse);
            }
            identified_sses.Insert( current_sse);
          }

          // create new current sse for current aa
          current_sse = util::ShPtr< SSE>
          (
            new SSE( biol::AASequence( ( *current_itr)->GetAAClass(), 0, SEQUENCE.GetChainID()), current_sstype)
          );
          current_sse->PushBack( current_itr->HardCopy());
        }
      }

      // this is the same routine, when all aas were processed since the last sse is still not inserted in the sse list
      // if sse is not long enough, set it to type coil, otherwise calculate body
      if
      (
        (
          ( current_sse->GetType() == biol::GetSSTypes().HELIX) &&
          ( current_sse->GetSize() < m_MinSSELengths( biol::GetSSTypes().HELIX))
        )
        ||
        (
          ( current_sse->GetType() == biol::GetSSTypes().STRAND) &&
          ( current_sse->GetSize() < m_MinSSELengths( biol::GetSSTypes().STRAND))
        )
      )
      {
        current_sse->SetType( biol::GetSSTypes().COIL);
      }
      else
      {
        current_sse->SetGeometry();
      }

      if( current_sse->GetType()->IsStructured())
      {
        // insert current sse
        current_sse->SetChainID( SEQUENCE.GetChainID());
        auto itr_dssp( dssp_sses.Find( current_sse));
        while( itr_dssp != dssp_sses.End())
        {
          dssp_sses.RemoveElement( itr_dssp);
          itr_dssp = dssp_sses.Find( current_sse);
        }
        identified_sses.Insert( current_sse);
      }

      if( !dssp_sses.IsEmpty())
      {
        for( auto itr_dssp( dssp_sses.Begin()), itr_dssp_end( dssp_sses.End()); itr_dssp != itr_dssp_end; ++itr_dssp)
        {
          if
          (
            (
              ( ( *itr_dssp)->GetType() == biol::GetSSTypes().HELIX) &&
              ( ( *itr_dssp)->GetSize() >= m_MinSSELengths( biol::GetSSTypes().HELIX))
            )
            ||
            (
              ( ( *itr_dssp)->GetType() == biol::GetSSTypes().STRAND) &&
              ( ( *itr_dssp)->GetSize() >= m_MinSSELengths( biol::GetSSTypes().STRAND))
            )
          )
          {
            util::ShPtr< SSE> current_sse
            (
              new SSE
              (
                biol::AASequence( SEQUENCE.GetFirstAA()->GetAAClass(), 0, SEQUENCE.GetChainID()),
                ( *itr_dssp)->GetType()
              )
            );
            for
            (
              auto itr_sse( ( *itr_dssp)->GetData().Begin()), itr_sse_end( ( *itr_dssp)->GetData().End());
              itr_sse != itr_sse_end;
              ++itr_sse
            )
            {
              current_sse->PushBack( *itr_sse);
            }
            current_sse->SetGeometry();
            identified_sses.Insert( current_sse);
          }
        }
      }

      // insert the sses in the domain to the pool
      sse_pool.InsertElements( identified_sses.GetData().Begin(), identified_sses.GetData().End());

      // return set of sses
      return sse_pool;
    }

  ////////////////
  // operations //
  ////////////////

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEFactoryConformation::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_MinSSELengths, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &SSEFactoryConformation::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_MinSSELengths, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_factory_interface.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that returns a set of SSEs for the given vector of AASequences
    //! @brief SEQUENCES Vector of AASequences from which the SSEPool is going to be built
    //! @return SSEPool built from provided SEQUENCES
    SSEPool
    SSEFactoryInterface::operator()( const util::SiPtrVector< biol::AASequence> &SEQUENCES) const
    {
      // initialize SSEPool to be returned
      SSEPool sse_pool;

      // iterate over the provided sequences
      for
      (
        util::SiPtrVector< biol::AASequence>::const_iterator seq_itr( SEQUENCES.Begin()),
          seq_itr_end( SEQUENCES.End());
        seq_itr != seq_itr_end;
        ++seq_itr
      )
      {
        // create an ssepool from the sequence behind seq_itr
        const SSEPool this_sse_pool( operator()( **seq_itr));

        // append the pool for this sequence to sse_pool
        sse_pool.InsertElements( this_sse_pool.Begin(), this_sse_pool.End());
      }

      // end
      return sse_pool;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_factory_mc.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_sse_size.h"
#include "assemble/bcl_assemble_pick_sse_random.h"
#include "assemble/bcl_assemble_sse_pool.h"
#include "assemble/bcl_assemble_sse_pool_insert_coil_into_sse.h"
#include "assemble/bcl_assemble_sse_pool_join_sses.h"
#include "assemble/bcl_assemble_sse_pool_move_aa.h"
#include "assemble/bcl_assemble_sse_pool_mutate_sse.h"
#include "assemble/bcl_assemble_sse_pool_split_sse.h"
#include "biol/bcl_biol_membrane.h"
#include "find/bcl_find_locator.h"
#include "fold/bcl_fold_mutate_sse_type.h"
#include "math/bcl_math_binary_function_bind_second.h"
#include "math/bcl_math_binary_sum_function.h"
#include "math/bcl_math_mutate_decision_node.h"
#include "mc/bcl_mc_approximator.h"
#include "mc/bcl_mc_temperature_accepted.h"
#include "opti/bcl_opti_criterion_combine.h"
#include "opti/bcl_opti_criterion_number_iterations.h"
#include "opti/bcl_opti_criterion_unimproved.h"
#include "score/bcl_score_sse_pool_sses.h"
#include "score/bcl_score_sse_predictions.h"
#include "sspred/bcl_sspred_sse_factory_highest.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEFactoryMC::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEFactoryMC( sspred::GetMethods().e_Undefined, 0.0))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from sspred method
    //! @param SSMETHOD sspred method to use to generate pool of sses
    //! @param CONFIDENCE_THRESHOLD the threshold in units of z-score, above which the confidence score becomes negative
    SSEFactoryMC::SSEFactoryMC
    (
      const sspred::Method &SSMETHOD,
      const double CONFIDENCE_THRESHOLD
    ) :
      m_Method( SSMETHOD),
      m_ConfidenceThreshold( CONFIDENCE_THRESHOLD),
      m_MaxNumberIterations( s_MaxNumberIterations),
      m_NumberOptimizations( s_NumberOptimizations)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEFactoryMC
    SSEFactoryMC *SSEFactoryMC::Clone() const
    {
      return new SSEFactoryMC( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEFactoryMC::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief set the thresholds to use
    //! @brief SSTYPE_THRESHOLDS the thresholds to use for the sstypes desired
    void SSEFactoryMC::SetThresholds( const storage::Map< biol::SSType, double> &SSTYPE_THRESHOLDS)
    {
      if( SSTYPE_THRESHOLDS.IsEmpty())
      {
        return;
      }

      // take first value
      m_ConfidenceThreshold = SSTYPE_THRESHOLDS.Begin()->second;
    }

    //! @brief set the scoring function
    //! @param SP_SCORING ShPtr to scoring function
    void SSEFactoryMC::SetScoringFunction( const util::ShPtr< math::BinaryFunctionInterface< SSEPool, biol::Membrane, double> > &SP_SCORING)
    {
      m_ScoringFunction = SP_SCORING;
    }

    //! @brief set the mutate object
    //! @param SP_MUTATE ShPtr to mutate
    void SSEFactoryMC::SetMutate( const util::ShPtr< math::MutateInterface< SSEPool> > &SP_MUTATE)
    {
      m_Mutate = SP_MUTATE;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief generate the default scoring function
    //! @return function to score the sse pool as objective function
    util::ShPtr< math::BinaryFunctionInterface< SSEPool, biol::Membrane, double> > SSEFactoryMC::DefaultScoringFunction() const
    {
      // objective function
      util::ShPtr< score::SSEPredictions> sp_sse_preds( new score::SSEPredictions( m_Method, 0.0));
      util::ShPtr< math::BinarySumFunction< SSEPool, biol::Membrane, double, double> > sp_objective
      (
        new math::BinarySumFunction< SSEPool, biol::Membrane, double, double>()
      );
      sp_objective->NewOperand
      (
        util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_preds, false, false)), 1.0
      );

//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_avg2, false, false)), 1.0);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_avg5, false, false)), 1.0);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_dev, false, false)), 1.0);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_slope, false, false)), 1.0);
//      util::ShPtr< score::SSEPredictions> sp_sse_preds( new score::SSEPredictions( m_Method, -0.0));
//      util::ShPtr< math::SumFunctionMixin< SSEPool, double> > sp_objective( new math::SumFunctionMixin< SSEPool, double>());
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_avg2, false, false)), 0.25);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_avg3, false, false)), 0.25);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_avg4, false, false)), 0.25);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_avg5, false, false)), 0.25);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_dev0, false, false)), 0.33);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_dev1, false, false)), 0.33);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_dev2, false, false)), 0.33);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_slope2, false, false)), 0.5);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_pred_slope3, false, false)), 0.5);
//      sp_objective->NewOperand( util::ShPtr< score::SSEPoolSSEs>( new score::SSEPoolSSEs( sp_sse_preds, false, false)), 1.0);

      return sp_objective;
    }

    //! @brief generate the default set of mutates
    //! @return mutate to change the compositon of the sse pool
    util::ShPtr< math::MutateInterface< SSEPool> > SSEFactoryMC::DefaultMutate() const
    {
      // collector for sses size < 8
      util::ShPtr< CollectorSSESize> sp_collector_sse_size_tiny
      (
        new CollectorSSESize( math::Range< size_t>( 1, 8))
      );

      // collector for sses size >= 4
      util::ShPtr< CollectorSSESize> sp_collector_sse_size_small
      (
        new CollectorSSESize( math::Range< size_t>( 4, util::GetUndefined< size_t>()))
      );

      util::ShPtr< CollectorSSESize> sp_collector_sse_size_large
      (
        new CollectorSSESize( math::Range< size_t>( 10, util::GetUndefined< size_t>()))
      );

      // pick sse random
      util::ShPtr< PickSSERandom> sp_pick_sse_random( new PickSSERandom());

      // locate random sse below size
      util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > sp_locate_sse_tiny_random
      (
        new find::Locator< util::SiPtr< const SSE>, DomainInterface, util::SiPtrList< const SSE> >
        (
          sp_collector_sse_size_tiny,
          sp_pick_sse_random
        )
      );

      // locate random sse above size
      util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > sp_locate_sse_small_random
      (
        new find::Locator< util::SiPtr< const SSE>, DomainInterface, util::SiPtrList< const SSE> >
        (
          sp_collector_sse_size_small,
          sp_pick_sse_random
        )
      );

      util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > sp_locate_sse_large_random
      (
        new find::Locator< util::SiPtr< const SSE>, DomainInterface, util::SiPtrList< const SSE> >
        (
          sp_collector_sse_size_large,
          sp_pick_sse_random
        )
      );

      // change sse type
      util::ShPtr< fold::MutateSSEType> sp_mutate_sse_type
      (
        new fold::MutateSSEType
        (
          storage::Set< biol::SSType>( biol::GetSSTypes().HELIX, biol::GetSSTypes().STRAND, biol::GetSSTypes().COIL)
        )
      );

      util::ShPtr< math::MutateDecisionNode< SSEPool> > sp_mutate_node( new math::MutateDecisionNode< SSEPool>());
      util::ShPtr< SSEPoolMoveAA> sp_mutate_move_aa( new SSEPoolMoveAA( math::Range< size_t>( 1, 3)));

      // split an sse and mutate the one with the lower probability
      util::ShPtr< SSEPoolSplitSSE> sp_mutate_split_change_sse
      (
        new SSEPoolSplitSSE
        (
          m_Method,
          sp_locate_sse_small_random,
          sp_mutate_sse_type
        )
      );

      // devide an sse without mutating either resulting sses
      util::ShPtr< SSEPoolSplitSSE> sp_mutate_devide_sse
      (
        new SSEPoolSplitSSE
        (
          m_Method,
          sp_locate_sse_small_random,
          util::ShPtr< math::MutateInterface< SSE> >()
        )
      );
      util::ShPtr< SSEPoolMutateSSE> sp_mutate_pool_sse_type
      (
        new SSEPoolMutateSSE
        (
          sp_locate_sse_large_random,
          sp_mutate_sse_type
        )
      );
      util::ShPtr< SSEPoolJoinSSEs> sp_mutate_pool_join
      (
        new SSEPoolJoinSSEs( sp_locate_sse_tiny_random)
      );

      util::ShPtr< SSEPoolInsertCoilIntoSSE> sp_mutate_pool_insert_coil_1
      (
        new SSEPoolInsertCoilIntoSSE
        (
          m_Method,
          sp_locate_sse_large_random,
          1
        )
      );
      util::ShPtr< SSEPoolInsertCoilIntoSSE> sp_mutate_pool_insert_coil_3
      (
        new SSEPoolInsertCoilIntoSSE
        (
          m_Method,
          sp_locate_sse_large_random,
          3
        )
      );

      // add all mutates with a probability of 1.0 to the node
      sp_mutate_node->AddMutate( *sp_mutate_move_aa, 1.0);
      sp_mutate_node->AddMutate( *sp_mutate_split_change_sse, 1.0);
      sp_mutate_node->AddMutate( *sp_mutate_devide_sse, 1.0);
      sp_mutate_node->AddMutate( *sp_mutate_pool_sse_type, 1.0);
      sp_mutate_node->AddMutate( *sp_mutate_pool_join, 1.0);
      sp_mutate_node->AddMutate( *sp_mutate_pool_insert_coil_1, 0.6);
      sp_mutate_node->AddMutate( *sp_mutate_pool_insert_coil_3, 0.4);

      // end
      return sp_mutate_node;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that returns a set of SSEs for the given AASequence
    //! @brief SEQUENCE AASequence from which the SSEPool is going to be built
    //! @return SSEPool built from provided SEQUENCE
    SSEPool
    SSEFactoryMC::operator()( const biol::AASequence &SEQUENCE) const
    {
      // check that sequence has one aa
      if( SEQUENCE.GetSize() < 1)
      {
        return SSEPool();
      }

      // check that sequence has defined prediction method
      if( !SEQUENCE.GetFirstAA()->GetSSPrediction( m_Method).IsDefined())
      {
        BCL_MessageCrt
        (
          "cannot derive pool, since sequence does not have defined sspred method: " + m_Method.GetName()
        );
        return SSEPool();
      }

      // start pool
      SSEPool start_pool( sspred::SSEFactoryHighest( m_Method)( SEQUENCE));

      // objective function
      util::ShPtr< math::BinaryFunctionInterface< SSEPool, biol::Membrane, double> > sp_binary_objective;
      if( m_ScoringFunction.IsDefined())
      {
        sp_binary_objective = m_ScoringFunction;
      }
      else
      {
        sp_binary_objective = DefaultScoringFunction();
      }

      // bind the second argument (membrane) so that the function only takes one argument,
      // this assumes the scoring function does not care about the membrane
      util::ShPtr< math::FunctionInterfaceSerializable< SSEPool, double> > sp_objective
      (
        new math::BinaryFunctionBindSecond< SSEPool, biol::Membrane, double>
        (
          sp_binary_objective,
          biol::Membrane()
        )
      );

      // mutate
      util::ShPtr< math::MutateInterface< SSEPool> > sp_mutate_node;
      if( m_Mutate.IsDefined())
      {
        sp_mutate_node = m_Mutate;
      }
      else
      {
        sp_mutate_node = DefaultMutate();
      }

      util::ShPtr< storage::Pair< SSEPool, double> > sp_final_result
      (
        new storage::Pair< SSEPool, double>
        (
          SSEPool(), std::numeric_limits< double>::max()
        )
      );

      for( size_t pool_nr( 0); pool_nr < m_NumberOptimizations; ++pool_nr)
      {
        // metropolis
        util::ShPtr< mc::Metropolis< double> > sp_metropolis
        (
          new mc::Metropolis< double>
          (
            util::ShPtr< mc::TemperatureInterface>
            (
              new mc::TemperatureAccepted( m_MaxNumberIterations)
            )
          )
        );

        // create termination criterion
        opti::CriterionCombine< SSEPool, double> termination_criterion;
        termination_criterion.InsertCriteria( opti::CriterionUnimproved< SSEPool, double>( s_MaxNumberUnimproved));
        termination_criterion.InsertCriteria( opti::CriterionNumberIterations< SSEPool, double>( m_MaxNumberIterations));

        // create the approximator
        mc::Approximator< SSEPool, double> approximator
        (
          *sp_objective,
          *sp_mutate_node,
          *sp_metropolis,
          termination_criterion,
          start_pool
        );

        // approximate
        approximator.Approximate();
        const util::ShPtr< storage::Pair< SSEPool, double> > sp_result( approximator.GetTracker().GetBest());
        if( sp_final_result->Second() > sp_result->Second())
        {
          sp_final_result = sp_result;
        }
      }

      return sp_final_result->First();
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEFactoryMC::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Method             , ISTREAM);
      io::Serialize::Read( m_ConfidenceThreshold, ISTREAM);
      io::Serialize::Read( m_ScoringFunction    , ISTREAM);
      io::Serialize::Read( m_Mutate             , ISTREAM);
      io::Serialize::Read( m_MaxNumberIterations, ISTREAM);
      io::Serialize::Read( m_NumberOptimizations, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEFactoryMC::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Method             , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ConfidenceThreshold, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ScoringFunction    , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Mutate             , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MaxNumberIterations, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_NumberOptimizations, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_compare.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry_phi_psi.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEGeometryWithinSizeTolerance::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryWithinSizeTolerance())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from helix and strand length tolerances
    //! @param HELIX_TOLERANCE helix tolerance
    //! @param STRAND_TOLERANCE strand tolerance
    SSEGeometryWithinSizeTolerance::SSEGeometryWithinSizeTolerance
    (
      const size_t HELIX_TOLERANCE,
      const size_t STRAND_TOLERANCE
    ) :
      m_SizeTolerances()
    {
      m_SizeTolerances[ biol::GetSSTypes().HELIX] = HELIX_TOLERANCE;
      m_SizeTolerances[ biol::GetSSTypes().STRAND] = STRAND_TOLERANCE;
    }

    //! @brief Clone function
    //! @return pointer to new SSEGeometryWithinSizeTolerance
    SSEGeometryWithinSizeTolerance *SSEGeometryWithinSizeTolerance::Clone() const
    {
      return new SSEGeometryWithinSizeTolerance( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEGeometryWithinSizeTolerance::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief returns whether two SSE geometry interface objects are within a fragment length of each other
    //! @param SSE_TO_COMPARE SSE to be compared
    //! @param GEOMTRY_PHI_PSI SSEGeometryPhiPsi to be compared
    //! @return bool whether two SSE geometry interface objects are within a fragment length of each other
    bool SSEGeometryWithinSizeTolerance::operator()
    (
      const SSE &SSE_TO_COMPARE,
      const SSEGeometryPhiPsi &GEOMTRY_PHI_PSI
    ) const
    {
      // if the types don't match or are not helix or strand
      if( SSE_TO_COMPARE.GetType() != GEOMTRY_PHI_PSI.GetType() || !SSE_TO_COMPARE.GetType()->IsStructured())
      {
        return false;
      }

      // return whether the difference it is less than or equal to the tolerance
      return math::Absolute( int( SSE_TO_COMPARE.GetSize()) - int( GEOMTRY_PHI_PSI.GetPhiPsi()->GetAngles().GetSize()))
        <= int( m_SizeTolerances.GetValue( SSE_TO_COMPARE.GetType()));
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryWithinSizeTolerance::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SizeTolerances, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryWithinSizeTolerance::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SizeTolerances, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEGeometry::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometry())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from SSType
    //! @param SSTYPE SSType of geometry
    //! @param IDENTIFICATION identification of this geometry
    //! @param LENGTH length of the geometry
    SSEGeometry::SSEGeometry
    (
      const biol::SSType &SSTYPE,
      const std::string &IDENTIFICATION,
      const double &LENGTH
    ) :
      m_SSType( SSTYPE),
      m_Length( LENGTH),
      m_Identification( IDENTIFICATION),
      m_Orientation( math::TransformationMatrix3D()),
      m_MainAxis(),
      m_MainAxisUpToDate( false),
      m_Fragments()
    {
    }

    //! @brief construct from a geometry interface
    //! @param GEOMETRY Geometry to be stored
    SSEGeometry::SSEGeometry( const SSEGeometryInterface &GEOMETRY) :
      m_SSType( GEOMETRY.GetType()),
      m_Length( GEOMETRY.GetLength()),
      m_Identification( GEOMETRY.GetIdentification()),
      m_Orientation( GEOMETRY.GetOrientation()),
      m_MainAxis(),
      m_MainAxisUpToDate( false),
      m_Fragments( GEOMETRY.GetFragments().HardCopy())
    {
    }

    //! @brief construct from a geometry interface and its central amino acid
    //! @param GEOMETRY Geometry to be stored
    //! @param CENTRAL_AA central amino acid
    SSEGeometry::SSEGeometry( const SSEGeometryInterface &GEOMETRY, const int &CENTRAL_AA) :
      m_SSType( GEOMETRY.GetType()),
      m_Length( GEOMETRY.GetLength()),
      m_Identification( GEOMETRY.GetIdentification()),
      m_Orientation( GEOMETRY.GetOrientation()),
      m_MainAxis(),
      m_MainAxisUpToDate( false),
      m_Fragments( GEOMETRY.GetFragments().HardCopy()),
      m_CentralAA( CENTRAL_AA)
    {
    }

    //! @brief copy constructor
    //! @param GEOMETRY SSEGeometry to be copied
    SSEGeometry::SSEGeometry( const SSEGeometry &GEOMETRY) :
      m_SSType( GEOMETRY.m_SSType),
      m_Length( GEOMETRY.m_Length),
      m_Identification( GEOMETRY.m_Identification),
      m_Orientation( GEOMETRY.m_Orientation),
      m_MainAxis( GEOMETRY.m_MainAxis),
      m_MainAxisUpToDate( GEOMETRY.m_MainAxisUpToDate),
      m_Fragments( GEOMETRY.m_Fragments.HardCopy())
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEGeometry
    SSEGeometry *SSEGeometry::Clone() const
    {
      return new SSEGeometry( *this);
    }

    //! @brief destructor
    //! emits destructor signal
    SSEGeometry::~SSEGeometry()
    {
      m_GeometryDestructorSignal.Emit( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEGeometry::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return SiPtrVector of SSEGeometries
    //! @return SiPtrVector of SSEGeometries
    util::SiPtrVector< const SSEGeometryInterface> SSEGeometry::GetSSEGeometries() const
    {
      // if the fragments is empty
      if( m_Fragments.IsEmpty())
      {
        return util::SiPtrVector< const SSEGeometryInterface>( 1, this);
      }

      // otherwise return the fragments
      return m_Fragments;
    }

    //! @brief returns SiPtrVector of GeometryInterface that make up this GeometryInterface
    //! @return SiPtrVector of GeometryInterface that make up this GeometryInterface
    util::SiPtrVector< const coord::GeometryInterface> SSEGeometry::GetGeometries() const
    {
      return m_Fragments;
    }

    //! @brief returns the main axis as a LineSegment3D
    //! @return the main axis as a LineSegment3D
    coord::LineSegment3D SSEGeometry::GetMainAxis() const
    {
      if( !m_MainAxisUpToDate)
      {
        m_MainAxisUpToDate = true;
        m_MainAxis = coord::LineSegment3D( BeginOfZ(), EndOfZ());
      }
      return m_MainAxis;
    }

    //! @brief returns the requested extent
    //! @param AXIS axis of interest
    //! @return the requested extent
    double SSEGeometry::GetExtent( const coord::Axis &AXIS) const
    {
      // return the appropriate extent
      if( AXIS == coord::GetAxes().e_X)
      {
        return m_SSType->GetRadialExtent();
      }
      if( AXIS == coord::GetAxes().e_Y)
      {
        return m_SSType->GetRadialExtent();
      }
      if( AXIS == coord::GetAxes().e_Z)
      {
        return m_Length / 2.0;
      }

      // else return undefined
      return util::GetUndefinedDouble();
    }

    //! @brief returns the radial extent
    //! @return the radial extent
    double SSEGeometry::GetRadialExtent() const
    {
      return m_SSType->GetRadialExtent();
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief translate the object along a given TRANSLATION vector
    //! @param TRANSLATION Translation to be applied
    void SSEGeometry::Translate( const linal::Vector3D &TRANSLATION)
    {
      m_MainAxisUpToDate = false;
      // translate orientation
      m_Orientation( TRANSLATION);

      // iterate over fragments
      for
      (
        util::ShPtrVector< SSEGeometryInterface>::iterator itr( m_Fragments.Begin()), itr_end( m_Fragments.End());
        itr != itr_end; ++itr
      )
      {
        // translate fragment
        ( *itr)->Translate( TRANSLATION);
      }

      // emit geometry coordinate change signal
      m_GeometryCoordinateChangeSignal.Emit( *this);
    }

    //! @brief transform the object by a given TransformationMatrix3D
    //! @param TRANSFORMATION_MATRIX_3D TransformationMatrix3D to be applied
    void SSEGeometry::Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
    {
      m_MainAxisUpToDate = false;
      // transform orientation
      m_Orientation( TRANSFORMATION_MATRIX_3D);

      // iterate over fragments
      for
      (
        util::ShPtrVector< SSEGeometryInterface>::iterator itr( m_Fragments.Begin()), itr_end( m_Fragments.End());
        itr != itr_end; ++itr
      )
      {
        // transform fragment
        ( *itr)->Transform( TRANSFORMATION_MATRIX_3D);
      }

      // emit geometry coordinate change signal
      m_GeometryCoordinateChangeSignal.Emit( *this);
    }

    //! @brief rotate the object by a given RotationMatrix3D
    //! @param ROTATION_MATRIX_3D RotationMatrix3D to be applied
    void SSEGeometry::Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
    {
      m_MainAxisUpToDate = false;
      //transform orientation
      m_Orientation( ROTATION_MATRIX_3D);

      // iterate over fragments
      for
      (
        util::ShPtrVector< SSEGeometryInterface>::iterator itr( m_Fragments.Begin()), itr_end( m_Fragments.End());
        itr != itr_end; ++itr
      )
      {
        // rotate fragment
        ( *itr)->Rotate( ROTATION_MATRIX_3D);
      }

      // emit geometry coordinate change signal
      m_GeometryCoordinateChangeSignal.Emit( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator = SSEGeometry assign operator
    //! @param SSE_GEOMETRY_RHS SSEGeometry to be assigned to
    //! @return this SSEGeometry after assignment
    SSEGeometry &SSEGeometry::operator =( const SSEGeometry &SSE_GEOMETRY_RHS)
    {
      m_SSType = SSE_GEOMETRY_RHS.m_SSType;
      m_Length = SSE_GEOMETRY_RHS.m_Length;
      m_Identification = SSE_GEOMETRY_RHS.m_Identification;
      m_Orientation = SSE_GEOMETRY_RHS.m_Orientation;
      m_Fragments = SSE_GEOMETRY_RHS.m_Fragments.HardCopy();
      m_MainAxisUpToDate = false;

      // emit geometry coordinate change signal
      m_GeometryCoordinateChangeSignal.Emit( *this);

      // return this
      return *this;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometry::Read( std::istream &ISTREAM)
    {
      // read the members
      io::Serialize::Read( m_SSType, ISTREAM);
      io::Serialize::Read( m_Length, ISTREAM);
      io::Serialize::Read( m_Identification, ISTREAM);
      io::Serialize::Read( m_Orientation, ISTREAM);
      io::Serialize::Read( m_Fragments, ISTREAM);

      m_MainAxisUpToDate = false;

      // emit geometry coordinate change signal
      m_GeometryCoordinateChangeSignal.Emit( *this);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometry::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write the members
      io::Serialize::Write( m_SSType, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Length, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Identification, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Orientation, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Fragments, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_packer_all_fragment_pairs.h"

// includes from bcl - sorted alphabetically
#include "storage/bcl_storage_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPackerAllFragmentPairs::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPackerAllFragmentPairs())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPackerAllFragmentPairs::SSEGeometryPackerAllFragmentPairs() :
      m_MinimalInterfaceLength( SSEGeometryPacking::GetDefaultFragmentMinimalInterfaceLength()),
      m_UseDistanceCutoffs( false),
      m_DistanceCutoffs()
    {
    }

    //! @brief constructor from a minimal interface length
    //! @param MINIMAL_INTERFACE_LENGTH minimal interface length
    SSEGeometryPackerAllFragmentPairs::SSEGeometryPackerAllFragmentPairs
    (
      const double MINIMAL_INTERFACE_LENGTH
    ) :
      m_MinimalInterfaceLength( MINIMAL_INTERFACE_LENGTH),
      m_UseDistanceCutoffs( false),
      m_DistanceCutoffs()
    {
    }

    //! @brief constructor from a minimal interface length
    //! @param MINIMAL_INTERFACE_LENGTH minimal interface length
    //! @param DISTANCE_CUTOFFS map of distance cutoffs for each contact type
    SSEGeometryPackerAllFragmentPairs::SSEGeometryPackerAllFragmentPairs
    (
      const double MINIMAL_INTERFACE_LENGTH,
      const storage::Map< biol::SSType, storage::Map< biol::SSType, double> > &DISTANCE_CUTOFFS
    ) :
      m_MinimalInterfaceLength( MINIMAL_INTERFACE_LENGTH),
      m_UseDistanceCutoffs( true),
      m_DistanceCutoffs( DISTANCE_CUTOFFS)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEGeometryPackerAllFragmentPairs
    SSEGeometryPackerAllFragmentPairs *SSEGeometryPackerAllFragmentPairs::Clone() const
    {
      return new SSEGeometryPackerAllFragmentPairs( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEGeometryPackerAllFragmentPairs::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the packing between all fragments of the given geometries and return it in a list of lists
    //! @param SSE_GEOMETRY_A first SSEGeometryInterface derived class of interest
    //! @param SSE_GEOMETRY_B second SSEGeometryInterface derived class of interest
    //! @return list of lists containing packing between all fragment pairings between given geometry pair
    storage::Vector< storage::List< SSEGeometryPacking> > SSEGeometryPackerAllFragmentPairs::operator()
    (
      const SSEGeometryInterface &SSE_GEOMETRY_A,
      const SSEGeometryInterface &SSE_GEOMETRY_B
    ) const
    {
      // initialize a static undefined sse geometry packing
      static const SSEGeometryPacking s_undefined_packing;

      // if both SSEs are not helix or strand or they are the same geometry
      if
      (
        !SSE_GEOMETRY_A.GetType()->IsStructured() ||
        !SSE_GEOMETRY_B.GetType()->IsStructured() ||
        &SSE_GEOMETRY_A == &SSE_GEOMETRY_B
      )
      {
        // return empty list
        return storage::Vector< storage::List< SSEGeometryPacking> >();
      }

      // get the sub-geometries for both SSEGeometries and store them
      const util::SiPtrVector< const SSEGeometryInterface> geometries_a( SSE_GEOMETRY_A.GetSSEGeometries());
      const util::SiPtrVector< const SSEGeometryInterface> geometries_b( SSE_GEOMETRY_B.GetSSEGeometries());

      // declare the list of lists SSEPackings to be returned and initialize them
      storage::Vector< storage::List< SSEGeometryPacking> > packing_list( geometries_a.GetSize());

      // initialize iterators for the packing list
      storage::Vector< storage::List< SSEGeometryPacking> >::iterator pack_itr( packing_list.Begin());
      const storage::Vector< storage::List< SSEGeometryPacking> >::const_iterator pack_itr_end( packing_list.End());

      // determine the max cutoff for this type
      const double cutoff_distance
      (
        m_UseDistanceCutoffs ?
          m_DistanceCutoffs.Find( SSE_GEOMETRY_A.GetType())->second.Find( SSE_GEOMETRY_B.GetType())->second :
          0.0
      );

      // iterate over the first fragments list while also iterating over the packing list
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator
          fragment_itr_a( geometries_a.Begin()), fragment_itr_a_end( geometries_a.End());
        fragment_itr_a != fragment_itr_a_end && pack_itr != pack_itr_end;
        ++fragment_itr_a, ++pack_itr
      )
      {
        // iterate over second list
        for
        (
          util::SiPtrVector< const SSEGeometryInterface>::const_iterator
            fragment_itr_b( geometries_b.Begin()), fragment_itr_b_end( geometries_b.End());
          fragment_itr_b != fragment_itr_b_end;
          ++fragment_itr_b
        )
        {
          // list the fragments
          BCL_MessageDbg
          (
            "\t\tLooking at " + ( *fragment_itr_a)->GetIdentification() + " vs " +
            ( *fragment_itr_b)->GetIdentification()
          )

          // if using distance cutoffs
          if( m_UseDistanceCutoffs)
          {
            // calculate the distance between centers of geometries
            const double center_distance
            (
              linal::Distance( ( *fragment_itr_a)->GetCenter(), ( *fragment_itr_b)->GetCenter())
            );

            // if the distance is greater than the cutoff for that contact type
            if( center_distance > cutoff_distance)
            {
              // insert undefined SSEPacking
              pack_itr->PushBack( s_undefined_packing);

              // move to next fragment pair
              continue;
            }
          }

          SSEGeometryPacking pack( **fragment_itr_a, **fragment_itr_b, m_MinimalInterfaceLength);
//          if( pack.GetDistance() > pack.GetContactType()->GetDistanceRange().GetMax())
//          {
//            BCL_MessageStd
//            (
//              "Pack Dist: " + util::Format()( pack.GetDistance())
//              + " contact type: " + pack.GetContactType().GetName()
//              + " max dist: " + util::Format()( pack.GetContactType()->GetDistanceRange().GetMax())
//            );
//          }
          // insert a packing for these two fragments into the list
          pack_itr->PushBack( pack);
//          BCL_MessageDbg( "\t\t\twith packing:" + pack_itr->LastElement().GetIdentification());

          // if the packing is defined and the distance is less than the critical distance give a warning
          if
          (
            pack_itr->LastElement().GetContactType().IsDefined() &&
            pack_itr->LastElement().GetDistance() <= SSEGeometryPacking::s_CriticalDistance
          )
          {
            BCL_MessageVrb
            (
              "distance_check_frag " + pack_itr->LastElement().GetIdentification()
            );
          }
        }
      }

      // return list of packings
      return packing_list;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackerAllFragmentPairs::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_MinimalInterfaceLength, ISTREAM);
      io::Serialize::Read( m_UseDistanceCutoffs, ISTREAM);
      io::Serialize::Read( m_DistanceCutoffs, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackerAllFragmentPairs::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_MinimalInterfaceLength, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_UseDistanceCutoffs, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_DistanceCutoffs, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief return map of maps for upper distance ranges for sstype pairs
    //! @return map of maps for upper distance ranges for sstype pairs
    const storage::Map< biol::SSType, storage::Map< biol::SSType, double> > &
    SSEGeometryPackerAllFragmentPairs::GetDistanceCutoffMap()
    {
      // initialize map
      static storage::Map< biol::SSType, storage::Map< biol::SSType, double> > s_cutoff_map;

      // if map is not initialized yet then initialize it
      if( s_cutoff_map.IsEmpty())
      {
        // initialize static overheads for helix and strand fragments
        const double helix_overhead
        (
          biol::GetSSTypes().HELIX->GetFragmentLength() * biol::GetSSTypes().HELIX->GetRiseInZPerResidue() / 2.0
        );
        const double strand_overhead
        (
          biol::GetSSTypes().STRAND->GetFragmentLength() * biol::GetSSTypes().STRAND->GetRiseInZPerResidue() / 2.0
        );

        // store the minimal fragment interface length
        const double interface_length( SSEGeometryPacking::GetDefaultFragmentMinimalInterfaceLength());

        // insert values
        s_cutoff_map[ biol::GetSSTypes().HELIX][ biol::GetSSTypes().HELIX] =
          contact::GetTypes().HELIX_HELIX->GetDistanceRange().GetMax() + 2 * helix_overhead - interface_length;
        s_cutoff_map[ biol::GetSSTypes().HELIX][ biol::GetSSTypes().STRAND] =
          contact::GetTypes().HELIX_STRAND->GetDistanceRange().GetMax() + helix_overhead + strand_overhead - interface_length;
        s_cutoff_map[ biol::GetSSTypes().STRAND][ biol::GetSSTypes().HELIX] =
          contact::GetTypes().HELIX_STRAND->GetDistanceRange().GetMax() + helix_overhead + strand_overhead - interface_length;
        s_cutoff_map[ biol::GetSSTypes().STRAND][ biol::GetSSTypes().STRAND] =
          contact::GetTypes().SHEET_SHEET->GetDistanceRange().GetMax() + 2 * strand_overhead - interface_length;
      }

      // end
      return s_cutoff_map;
    }

    //! @brief return map of maps for upper clash distance ranges for sstype pairs
    //! @return map of maps for upper clash distance ranges for sstype pairs
    const storage::Map< biol::SSType, storage::Map< biol::SSType, double> > &
    SSEGeometryPackerAllFragmentPairs::GetClashDistanceCutoffMap()
    {
      // initialize map
      static storage::Map< biol::SSType, storage::Map< biol::SSType, double> > s_cutoff_map;

      // if map is not initialized yet then initialize it
      if( s_cutoff_map.IsEmpty())
      {
        // initialize overheads for helix and strand fragments
        const double helix_overhead
        (
          biol::GetSSTypes().HELIX->GetFragmentLength() * biol::GetSSTypes().HELIX->GetRiseInZPerResidue() / 2.0
        );
        const double strand_overhead
        (
          biol::GetSSTypes().STRAND->GetFragmentLength() * biol::GetSSTypes().STRAND->GetRiseInZPerResidue() / 2.0
        );

        // insert values
        s_cutoff_map[ biol::GetSSTypes().HELIX][ biol::GetSSTypes().HELIX] =
          contact::GetTypes().HELIX_HELIX->GetMinimalSSEDistance() + 2 * helix_overhead;
        s_cutoff_map[ biol::GetSSTypes().HELIX][ biol::GetSSTypes().STRAND] =
          contact::GetTypes().HELIX_SHEET->GetMinimalSSEDistance() + helix_overhead + strand_overhead;
        s_cutoff_map[ biol::GetSSTypes().STRAND][ biol::GetSSTypes().HELIX] =
          contact::GetTypes().HELIX_SHEET->GetMinimalSSEDistance() + helix_overhead + strand_overhead;
        s_cutoff_map[ biol::GetSSTypes().STRAND][ biol::GetSSTypes().STRAND] =
          contact::GetTypes().SHEET_SHEET->GetMinimalSSEDistance() + 2 * strand_overhead;
      }

      // end
      return s_cutoff_map;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_packer_best_fragment_pair.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPackerBestFragmentPair::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPackerBestFragmentPair())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPackerBestFragmentPair::SSEGeometryPackerBestFragmentPair() :
      m_Packer(),
      m_PackingCriteria(),
      m_PackingComparison()
    {
    }

    //! @brief constructor from a packer and a comparison function
    //! @param PACKER SSEGeometryPacker to be used
    //! @param COMPARISION_FUNCTION function for comparing two SSE geometry packing objects
    SSEGeometryPackerBestFragmentPair::SSEGeometryPackerBestFragmentPair
    (
      const SSEGeometryPacker &PACKER,
      const math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> &COMPARISION_FUNCTION
    ) :
      m_Packer( PACKER),
      m_PackingCriteria(),
      m_PackingComparison( COMPARISION_FUNCTION.Clone())
    {
    }

    //! @brief constructor from a packer, a criteria function and a comparison function
    //! @param PACKER SSEGeometryPacker to be used
    //! @param CRITERIA criteria to decide on which packings are to considered
    //! @param COMPARISION_FUNCTION function for comparing two SSE geometry packing objects
    SSEGeometryPackerBestFragmentPair::SSEGeometryPackerBestFragmentPair
    (
      const SSEGeometryPacker &PACKER,
      const math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> &CRITERIA,
      const math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> &COMPARISION_FUNCTION
    ) :
      m_Packer( PACKER),
      m_PackingCriteria( CRITERIA.Clone()),
      m_PackingComparison( COMPARISION_FUNCTION.Clone())
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEGeometryPackerBestFragmentPair
    SSEGeometryPackerBestFragmentPair *SSEGeometryPackerBestFragmentPair::Clone() const
    {
      return new SSEGeometryPackerBestFragmentPair( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEGeometryPackerBestFragmentPair::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief return the minimal interface length used
    //! @return minimal interface length used
    double SSEGeometryPackerBestFragmentPair::GetMinimalInterfaceLength() const
    {
      return ( *m_Packer)->GetMinimalInterfaceLength();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the packing between all fragments of the given geometries and return the best one
    //! @param SSE_GEOMETRY_A first SSEGeometryInterface derived class of interest
    //! @param SSE_GEOMETRY_B second SSEGeometryInterface derived class of interest
    //! @return the best packign between fragments of given geometry pair according to comparison function
    SSEGeometryPacking SSEGeometryPackerBestFragmentPair::operator()
    (
      const SSEGeometryInterface &SSE_GEOMETRY_A,
      const SSEGeometryInterface &SSE_GEOMETRY_B
    ) const
    {
      // initialize static undefined packing
      static const SSEGeometryPacking s_undefined_packing;

      BCL_MessageDbg
      (
        "Calculating Best fragment pair for geometries " +
        SSE_GEOMETRY_A.GetIdentification() + " and " + SSE_GEOMETRY_B.GetIdentification()
      );

      // use the packer to get the list of packings
      storage::Vector< storage::List< SSEGeometryPacking> > packing_list
      (
        ( *m_Packer)->operator ()( SSE_GEOMETRY_A, SSE_GEOMETRY_B)
      );

      // if the list is empty return undefined packing
      if( packing_list.IsEmpty())
      {
        return SSEGeometryPacking();
      }

      // initialize the best packing
      util::SiPtr< const SSEGeometryPacking> sp_best_packing( &s_undefined_packing);

      // iterate over the packings in the list
      for
      (
        storage::Vector< storage::List< SSEGeometryPacking> >::const_iterator
          list_itr( packing_list.Begin()), list_itr_end( packing_list.End());
        list_itr != list_itr_end; ++list_itr
      )
      {
        for
        (
          storage::List< SSEGeometryPacking>::const_iterator
            pack_itr( list_itr->Begin()), pack_itr_end( list_itr->End());
          pack_itr != pack_itr_end; ++pack_itr
        )
        {
          // boolean to see if the packing matches the criteria
          const bool match_criteria
          (
            m_PackingCriteria.IsDefined() ?
              m_PackingCriteria->operator()( *pack_itr) :
              true
          );

//          BCL_MessageDbg( "\t" + pack_itr->GetIdentification());

          // if this packing matches the criteria (if any) and
          // it is better than the best packing seen so far or this is the first one to be compared
          if
          (
            match_criteria &&
            ( !sp_best_packing->IsDefined() || m_PackingComparison->operator ()( *pack_itr, *sp_best_packing))
          )
          {
//            BCL_MessageDbg( "new best!");
            // then update the best packing to this
            sp_best_packing = &( *pack_itr);
          }
        }
      }

      BCL_MessageDbg( "BEST_PACKING_PAIR: " + sp_best_packing->GetIdentification());

      // return the best packing found
      return *sp_best_packing;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackerBestFragmentPair::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Packer, ISTREAM);
      io::Serialize::Read( m_PackingCriteria, ISTREAM);
      io::Serialize::Read( m_PackingComparison, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackerBestFragmentPair::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Packer, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PackingCriteria, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PackingComparison, OSTREAM, INDENT) << '\n';

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_packer_best_fragment_pairs.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPackerBestFragmentPairs::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPackerBestFragmentPairs())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPackerBestFragmentPairs::SSEGeometryPackerBestFragmentPairs() :
      m_Packer(),
      m_PackingCriteria(),
      m_PackingComparison()
    {
    }

    //! @brief constructor from a packer and a comparison function
    //! @param PACKER Packer to be used
    //! @param COMPARISION_FUNCTION function for comparing two SSE geometry packing objects
    SSEGeometryPackerBestFragmentPairs::SSEGeometryPackerBestFragmentPairs
    (
      const SSEGeometryPacker &PACKER,
      const math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> &COMPARISION_FUNCTION
    ) :
      m_Packer( PACKER),
      m_PackingCriteria(),
      m_PackingComparison( COMPARISION_FUNCTION.Clone())
    {
    }

    //! @brief constructor from a packer, a criteria function and a comparison function
    //! @param PACKER Packer to be used
    //! @param CRITERIA criteria to decide on which packings are to considered
    //! @param COMPARISION_FUNCTION function for comparing two SSE geometry packing objects
    SSEGeometryPackerBestFragmentPairs::SSEGeometryPackerBestFragmentPairs
    (
      const SSEGeometryPacker &PACKER,
      const math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> &CRITERIA,
      const math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> &COMPARISION_FUNCTION
    ) :
      m_Packer( PACKER),
      m_PackingCriteria( CRITERIA.Clone()),
      m_PackingComparison( COMPARISION_FUNCTION.Clone())
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEGeometryPackerBestFragmentPairs
    SSEGeometryPackerBestFragmentPairs *SSEGeometryPackerBestFragmentPairs::Clone() const
    {
      return new SSEGeometryPackerBestFragmentPairs( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEGeometryPackerBestFragmentPairs::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief calculate the packing between all fragments of the given geometries and return it in a list
    //! @param SSE_GEOMETRY_A first SSEGeometryInterface derived class of interest
    //! @param SSE_GEOMETRY_B second SSEGeometryInterface derived class of interest
    //! @return list containing packing between all fragment pairings between given geometry pair
    storage::List< SSEGeometryPacking> SSEGeometryPackerBestFragmentPairs::operator()
    (
      const SSEGeometryInterface &SSE_GEOMETRY_A,
      const SSEGeometryInterface &SSE_GEOMETRY_B
    ) const
    {
      // static undefined packing
      static const SSEGeometryPacking s_undefined_packing;

      // if both SSEs are not helix or strand or they are the same geometry
      if
      (
        !SSE_GEOMETRY_A.GetType()->IsStructured() ||
        !SSE_GEOMETRY_B.GetType()->IsStructured() ||
        &SSE_GEOMETRY_A == &SSE_GEOMETRY_B
      )
      {
        // return empty list
        return storage::List< SSEGeometryPacking>();
      }

      // get the list of list of packings for the given two SSE Geometries
      storage::Vector< storage::List< SSEGeometryPacking> > all_packings_list
      (
        ( *m_Packer)->operator ()( SSE_GEOMETRY_A, SSE_GEOMETRY_B)
      );

      // initialize list to store the best fragments
      storage::List< SSEGeometryPacking> packing_list;

      // iterate over the first layers of lists
      for
      (
        storage::Vector< storage::List< SSEGeometryPacking> >::const_iterator list_itr( all_packings_list.Begin()),
          list_itr_end( all_packings_list.End());
        list_itr != list_itr_end; ++list_itr
      )
      {
        // create a pointer to store the best packing
        util::SiPtr< const SSEGeometryPacking> sp_best_packing( &s_undefined_packing);

        // iterate over the second layer of lists
        for
        (
          storage::List< SSEGeometryPacking>::const_iterator pack_itr( list_itr->Begin()),
          pack_itr_end( list_itr->End());
          pack_itr != pack_itr_end;
          ++pack_itr
        )
        {
          // boolean to see if the packing matches the criteria
          bool match_criteria( true);

          // if the criteria is set
          if( m_PackingCriteria.IsDefined())
          {
            match_criteria = m_PackingCriteria->operator()( *pack_itr);
          }

          // if this packing matches the criteria (if any) and
          // it is better than the best packing seen so far or this is the first one to be compared
          if
          (
            match_criteria &&
            ( !sp_best_packing->IsDefined() || m_PackingComparison->operator ()( *pack_itr, *sp_best_packing))
          )
          {
            // then update the best packing to this
            sp_best_packing = &( *pack_itr);
          }

        } // pack_itr
        // if the best packing is defined and has a valid interaction weight
        if( sp_best_packing->IsDefined())
        {
          // insert this list into the main list
          packing_list.PushBack( *sp_best_packing);
        }
      } // list_itr

      // end
      return packing_list;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackerBestFragmentPairs::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Packer, ISTREAM);
      io::Serialize::Read( m_PackingCriteria, ISTREAM);
      io::Serialize::Read( m_PackingComparison, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackerBestFragmentPairs::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Packer, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PackingCriteria, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PackingComparison, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_packers.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_geometry_packer_all_fragment_pairs.h"
#include "util/bcl_util_enumerate.hpp"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief private constructor for constructing all SSEGeometryPackers
    SSEGeometryPackers::SSEGeometryPackers() :
      e_Default
      (
        AddEnum
        (
          "Default",
          SSEGeometryPackerInterface< storage::Vector< storage::List< SSEGeometryPacking> > >::WrapPacker
          (
            util::ShPtr< SSEGeometryPackerInterface< storage::Vector< storage::List< SSEGeometryPacking> > > >
            (
              new SSEGeometryPackerAllFragmentPairs
              (
                SSEGeometryPacking::GetDefaultFragmentMinimalInterfaceLength(), SSEGeometryPackerAllFragmentPairs::GetDistanceCutoffMap()

              )
            ), true, false
          )
        )
      ),
      e_Default_NoCache
      (
        AddEnum
        (
          "Default_NoCache",
          SSEGeometryPackerInterface< storage::Vector< storage::List< SSEGeometryPacking> > >::WrapPacker
          (
            util::ShPtr< SSEGeometryPackerInterface< storage::Vector< storage::List< SSEGeometryPacking> > > >
            (
              new SSEGeometryPackerAllFragmentPairs
              (
                SSEGeometryPacking::GetDefaultFragmentMinimalInterfaceLength(), SSEGeometryPackerAllFragmentPairs::GetDistanceCutoffMap()
              )
            ), false, false
          )
        )
      ),
      e_SSEClash
      (
        AddEnum
        (
          "SSEClash",
          SSEGeometryPackerInterface< storage::Vector< storage::List< SSEGeometryPacking> > >::WrapPacker
          (
            util::ShPtr< SSEGeometryPackerInterface< storage::Vector< storage::List< SSEGeometryPacking> > > >
            (
              new SSEGeometryPackerAllFragmentPairs
              (
                0.0, SSEGeometryPackerAllFragmentPairs::GetClashDistanceCutoffMap()
              )
            ), true, false
          )
        )
      ),
      e_SSEClash_NoCache
      (
        AddEnum
        (
          "SSEClash_NoCache",
          SSEGeometryPackerInterface< storage::Vector< storage::List< SSEGeometryPacking> > >::WrapPacker
          (
            util::ShPtr< SSEGeometryPackerInterface< storage::Vector< storage::List< SSEGeometryPacking> > > >
            (
              new SSEGeometryPackerAllFragmentPairs
              (
                0.0, SSEGeometryPackerAllFragmentPairs::GetClashDistanceCutoffMap()
              )
            ), false, false
          )
        )
      )
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEGeometryPackers::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief access static instance of SSEGeometryPackers enums
    //! @return static instance of SSEGeometryPackers enums
    const SSEGeometryPackers &GetSSEGeometryPackers()
    {
      return SSEGeometryPackers::GetEnums();
    }

  } // namespace assemble

  namespace util
  {

  /////////////////////////////
  // explicit instantiations //
  /////////////////////////////

    template class BCL_API Enumerate< ShPtr< assemble::SSEGeometryPackerInterface< storage::Vector< storage::List< assemble::SSEGeometryPacking> > > >, assemble::SSEGeometryPackers>;

  } // namespace util
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_packing_compare.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_geometry_packing.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief virtual copy constructor
    SSEGeometryPackingCompareInteractionWeight *SSEGeometryPackingCompareInteractionWeight::Clone() const
    {
      return new SSEGeometryPackingCompareInteractionWeight( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEGeometryPackingCompareInteractionWeight::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief return true if SSE_GEOMETRY_PACKING_A has better interaction weight than SSE_GEOMETRY_PACKING_B, or is closer by distance
    //! @param SSE_GEOMETRY_PACKING_A first SSEGeometryPacking
    //! @param SSE_GEOMETRY_PACKING_B second SSEGeometryPacking
    //! @return true if SSE_GEOMETRY_PACKING_A has better interaction weight than SSE_GEOMETRY_PACKING_B, or smaller distance
    bool SSEGeometryPackingCompareInteractionWeight::operator()
    (
      const SSEGeometryPacking &SSE_GEOMETRY_PACKING_A,
      const SSEGeometryPacking &SSE_GEOMETRY_PACKING_B
    ) const
    {
      // compare the interaction weights
      if( SSE_GEOMETRY_PACKING_A.GetInteractionWeight() > SSE_GEOMETRY_PACKING_B.GetInteractionWeight())
      {
        return true;
      }
      // for equal interaction weight, consider the closest by distance
      else if( SSE_GEOMETRY_PACKING_A.GetInteractionWeight() == SSE_GEOMETRY_PACKING_B.GetInteractionWeight())
      {
        return SSE_GEOMETRY_PACKING_A.GetDistance() < SSE_GEOMETRY_PACKING_B.GetDistance();
      }

      // end
      return false;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackingCompareInteractionWeight::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackingCompareInteractionWeight::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief virtual copy constructor
    SSEGeometryPackingCompareDistance *SSEGeometryPackingCompareDistance::Clone() const
    {
      return new SSEGeometryPackingCompareDistance( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEGeometryPackingCompareDistance::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief return true if SSE_GEOMETRY_PACKING_A has a shorter distance than SSE_GEOMETRY_PACKING_B
    //! @param SSE_GEOMETRY_PACKING_A first SSEGeometryPacking
    //! @param SSE_GEOMETRY_PACKING_B second SSEGeometryPacking
    //! @return true if SSE_GEOMETRY_PACKING_A has a shorter distance than SSE_GEOMETRY_PACKING_B
    bool SSEGeometryPackingCompareDistance::operator()
    (
      const SSEGeometryPacking &SSE_GEOMETRY_PACKING_A,
      const SSEGeometryPacking &SSE_GEOMETRY_PACKING_B
    ) const
    {
      // compare the interaction weights
      return SSE_GEOMETRY_PACKING_A.GetDistance() > SSE_GEOMETRY_PACKING_B.GetDistance()
             ? false
             : SSE_GEOMETRY_PACKING_A.GetDistance() < SSE_GEOMETRY_PACKING_B.GetDistance()
               ? true
               : SSE_GEOMETRY_PACKING_A.GetInteractionWeight() > SSE_GEOMETRY_PACKING_B.GetInteractionWeight();
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackingCompareDistance::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackingCompareDistance::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_packing.h"

// includes from bcl - sorted alphabetically
#include "util/bcl_util_sh_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
    //! @brief conversion to a string from a Orientation
    //! @param ORIENTATION the type to get a string for
    //! @return a string representing that orientation
    const std::string &SSEGeometryPacking::GetOrientationName( const Orientation &ORIENTATION)
    {
      static const std::string s_descriptors[] =
      {
        "PARALLEL",
        "ANTIPARALLEL",
        "UNDEFINED_ORIENTATION",
        GetStaticClassName< Orientation>()
      };

      return s_descriptors[ size_t( ORIENTATION)];
    }

  //////////
  // data //
  //////////

    //! Critical distance between two SSEs
    const double SSEGeometryPacking::s_CriticalDistance( 3.0);

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPacking::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPacking())
    );

    //! @brief static function that returns minimal length of fragment interface to get an interaction weight of 1.0
    double SSEGeometryPacking::GetDefaultFragmentMinimalInterfaceLength()
    {
      // initialize static minimal interface length
      static const double s_default_fragment_minimal_interface_length( 4.0);

      // return
      return s_default_fragment_minimal_interface_length;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPacking::SSEGeometryPacking() :
      m_FirstSSEGeometry(),
      m_SecondSSEGeometry(),
      m_ContactType( contact::GetTypes().e_Undefined),
      m_ShortestConnection(),
      m_Distance( util::GetUndefined< double>()),
      m_OrthogonalConnection( false),
      m_InteractionWeight( util::GetUndefined< double>()),
      m_TwistAngle( util::GetUndefined< double>()),
      m_Orientation( e_UndefinedOrientation),
      m_RelativePosition( util::GetUndefined< double>()),
      m_RelativePositionWeight( util::GetUndefined< double>()),
      m_StrandStrandPairingWeight( util::GetUndefined< double>()),
      m_MinimalInterfaceLength( util::GetUndefined< double>())
    {
    }

    //! @brief construct from pair of SSE geometries
    //! @param SSE_GEOMETRY_A first SSE geometry of interest
    //! @param SSE_GEOMETRY_A second SSE geometry of interest
    //! @param MINIMAL_INTERFACE_LENGTH minimal interface length, set to GetDefaultMinimalInterfaceLength by default
    SSEGeometryPacking::SSEGeometryPacking
    (
      const SSEGeometryInterface &SSE_GEOMETRY_A,
      const SSEGeometryInterface &SSE_GEOMETRY_B,
      const double MINIMAL_INTERFACE_LENGTH,
      const bool &ALLOW_UNDEFINED_TYPES
    ) :
      m_FirstSSEGeometry( SSE_GEOMETRY_A),
      m_SecondSSEGeometry( SSE_GEOMETRY_B),
      m_ShortestConnection(),
      m_OrthogonalConnection( false),
      m_InteractionWeight( util::GetUndefined< double>()),
      m_TwistAngle( util::GetUndefined< double>()),
      m_RelativePosition( util::GetUndefined< double>()),
      m_RelativePositionWeight( util::GetUndefined< double>()),
      m_StrandStrandPairingWeight( util::GetUndefined< double>()),
      m_MinimalInterfaceLength( MINIMAL_INTERFACE_LENGTH)
    {
      Initialize( SSE_GEOMETRY_A, SSE_GEOMETRY_B, ALLOW_UNDEFINED_TYPES);
    }

    //! @brief virtual copy constructor
    //! @return a new copy of this SSEGeometryPacking
    SSEGeometryPacking *SSEGeometryPacking::Clone() const
    {
      return new SSEGeometryPacking( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEGeometryPacking::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief function to reverse the order of the geometries stored
    void SSEGeometryPacking::Reverse()
    {
      // swap the geometries
      std::swap( m_FirstSSEGeometry, m_SecondSSEGeometry);

      // reverse the contact type
      m_ContactType = contact::GetTypes().Reverse( m_ContactType);

      // reverse the shortest connection
      m_ShortestConnection = m_ShortestConnection.GetReverse();
    }

    //! @brief returns identification string
    //! @return identification string
    std::string SSEGeometryPacking::GetIdentification() const
    {
      // initialize identification string
      const std::string identification
      (
        " GEO_1: " + ( m_FirstSSEGeometry.IsDefined() ? m_FirstSSEGeometry->GetIdentification() : "NULL") +
        "\tGEO_2: " + ( m_SecondSSEGeometry.IsDefined() ? m_SecondSSEGeometry->GetIdentification() : "NULL") +
        "\tco: " + m_ContactType.GetName() +
        "\tdist: " + util::Format()( GetDistance()) +
        "\tortho: " + util::Format()( m_OrthogonalConnection) +
        "\tint_weight: " + util::Format()( m_InteractionWeight) +
        "\tstr_weight: " + util::Format()( m_StrandStrandPairingWeight) +
        "\ttwist:" + util::Format()( m_TwistAngle) +
        "\torient:" + GetOrientationName( m_Orientation) +
        "\trel_pos:" + util::Format()( m_RelativePosition) +
        "\trel_weight:" + util::Format()( m_RelativePositionWeight) +
        "\tint_length:" + util::Format()( m_MinimalInterfaceLength)
      );

      // end
      return identification;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief Calculate all SSEGeometryPacking member information for given SSE geometry pair
    //! @param SSE_GEOMETRY_A first SSE of interest
    //! @param SSE_GEOMETRY_B second SSE of interest
    //! @param ALLOW_UNDEFINED_TYPES ALLOW_UNDEFINED_TYPES if true, allow UNDEFINED_HELIX_STRAND and similar as contact types, otherwise,
    //!        choose the closest type to remove ambiguity
    void SSEGeometryPacking::Initialize
    (
      const SSEGeometryInterface &SSE_GEOMETRY_A,
      const SSEGeometryInterface &SSE_GEOMETRY_B,
      const bool &ALLOW_UNDEFINED_TYPES
    )
    {
      // first get the basic contact type
      const contact::Type contact_type( contact::GetTypes().TypeFromSSTypes( SSE_GEOMETRY_A, SSE_GEOMETRY_B));

      // check that the SSEs have defined transformation matrices (bodies)
      if
      (
        SSE_GEOMETRY_A.GetType()->IsStructured() &&
        SSE_GEOMETRY_B.GetType()->IsStructured() &&
        ( !SSE_GEOMETRY_A.IsDefined() || !SSE_GEOMETRY_B.IsDefined())
      )
      {
        // if that's the case set the contact type to undefined
        m_ContactType = contact::GetTypes().e_Undefined;

        // warn user and break
        BCL_MessageCrt
        (
          "The provided sse pair has at least one SSE with invalid body " +
          SSE_GEOMETRY_A.GetIdentification() + " vs " + SSE_GEOMETRY_B.GetIdentification()
        )
        return;
      }

      //determine the shortest connection
      const storage::Pair< coord::LineSegment3D, bool>
        shortest_connection_orthogonal
        (
          coord::ShortestConnectionBetweenGeometries
          (
            SSE_GEOMETRY_A,
            SSE_GEOMETRY_B,
            m_MinimalInterfaceLength
          )
        );
      //set member shortest connection
      m_ShortestConnection = shortest_connection_orthogonal.First();

      // initialize distance
      m_Distance = m_ShortestConnection.GetLength();

      //set member orthogonal connection
      m_OrthogonalConnection = shortest_connection_orthogonal.Second();

      //angle between main axis (z-Axis) - twist angle
      m_TwistAngle = CalulateTwistAngle( SSE_GEOMETRY_A, SSE_GEOMETRY_B, shortest_connection_orthogonal.First());

      // set the orientation
      m_Orientation = OrientationFromSSEs( SSE_GEOMETRY_A, SSE_GEOMETRY_B);

      //weight of interaction
      m_InteractionWeight =
        m_OrthogonalConnection ?
          double( 1.0) :
          InteractionWeight( SSE_GEOMETRY_A, SSE_GEOMETRY_B, shortest_connection_orthogonal.First());

      // switch over contact type
      // if UNKNOWN
      if( contact_type == contact::GetTypes().e_Undefined)
      {
        m_ContactType = contact::GetTypes().e_Undefined;
      }

      // if HELIX_HELIX
      else if( contact_type == contact::GetTypes().HELIX_HELIX)
      {
        m_RelativePosition = 0;
        m_RelativePositionWeight = double( 1.0);
        m_ContactType = contact::GetTypes().HELIX_HELIX;
      }

      // if HELIX_SHEET
      else if( contact_type == contact::GetTypes().HELIX_SHEET)
      {
        m_RelativePosition =
          math::Absolute
          (
            math::g_Pi * 0.5 -
            math::Absolute
            (
              math::g_Pi * 0.5 -
              linal::ProjAngle
              (
                m_ShortestConnection.GetEndPoint(),
                m_ShortestConnection.GetStartPoint(),
                m_ShortestConnection.GetEndPoint() + SSE_GEOMETRY_B.GetAxis( coord::GetAxes().e_X)
              )
            )
          );

        m_RelativePositionWeight = math::WeightBetweenZeroAndPi( 2.0 * m_RelativePosition);

        //determine contact type according to relative position
        //HELIX_SHEET if angle < 30
        if( m_RelativePosition < math::g_Pi / ( ALLOW_UNDEFINED_TYPES ? 6 : 4))
        {
          m_ContactType = contact::GetTypes().HELIX_SHEET;
        }
        //HELIX_STRAND if angle > 60
        else if( !ALLOW_UNDEFINED_TYPES || m_RelativePosition > math::g_Pi / 3)
        {
          m_ContactType = contact::GetTypes().HELIX_STRAND;
        }
        //TWILIGHT_ZONE if 30 < angle < 60
        else
        {
          m_ContactType = contact::GetTypes().UNDEFINED_HELIX_STRAND;
        }
      }

      // if SHEET_HELIX
      else if( contact_type == contact::GetTypes().SHEET_HELIX)
      {
        m_RelativePosition =
          math::Absolute
          (
            math::g_Pi * 0.5 -
            math::Absolute
            (
              math::g_Pi * 0.5 -
              linal::ProjAngle
              (
                m_ShortestConnection.GetStartPoint(),
                m_ShortestConnection.GetEndPoint(),
                m_ShortestConnection.GetStartPoint() + SSE_GEOMETRY_A.GetAxis( coord::GetAxes().e_X)
              )
            )
          );
        m_RelativePositionWeight = math::WeightBetweenZeroAndPi( 2.0 * m_RelativePosition);

        //determine contact type according to relative position
        //SHEET_HELIX if angle < 30
        if( m_RelativePosition < math::g_Pi / ( ALLOW_UNDEFINED_TYPES ? 6 : 4))
        {
          m_ContactType = contact::GetTypes().SHEET_HELIX;
        }
        //STRAND_HELIX if angle > 60
        else if( !ALLOW_UNDEFINED_TYPES || m_RelativePosition > math::g_Pi / 3)
        {
          m_ContactType = contact::GetTypes().STRAND_HELIX;
        }
        //TWILIGHT_ZONE if 30 < angle < 60
        else
        {
          m_ContactType = contact::GetTypes().UNDEFINED_STRAND_HELIX;
        }
      }

      // if STRAND_STRAND
      else if( contact_type == contact::GetTypes().STRAND_STRAND)
      {
        // initialize variables
        const double a
        (
          math::Absolute
          (
            math::g_Pi * 0.5 -
            math::Absolute
            (
              math::g_Pi * 0.5 -
              linal::ProjAngle
              (
                m_ShortestConnection.GetEndPoint(),
                m_ShortestConnection.GetStartPoint(),
                m_ShortestConnection.GetEndPoint() + SSE_GEOMETRY_B.GetAxis( coord::GetAxes().e_X)
              )
            )
          )
        );
        const double b
        (
          math::Absolute
          (
            math::g_Pi * 0.5 -
            math::Absolute
            (
              math::g_Pi * 0.5 -
              linal::ProjAngle
              (
                m_ShortestConnection.GetStartPoint(),
                m_ShortestConnection.GetEndPoint(),
                m_ShortestConnection.GetStartPoint() + SSE_GEOMETRY_A.GetAxis( coord::GetAxes().e_X)
              )
            )
          )
        );

        m_RelativePosition = a + b;

        const double w1( math::WeightBetweenZeroAndPi( 2.0 * a));
        const double w2( math::WeightBetweenZeroAndPi( 2.0 * b));

        m_RelativePositionWeight = w1 * w2;
        m_StrandStrandPairingWeight = ( 1.0 - w1) * ( 1.0 - w2);

        // STRAND_STRAND if angle > 120
        if( m_RelativePosition > 2 * math::g_Pi / ( ALLOW_UNDEFINED_TYPES ? 3 : 4))
        {
          m_ContactType = contact::GetTypes().STRAND_STRAND;
        }
        //SHEET_SHEET if angle < 60
        else if( !ALLOW_UNDEFINED_TYPES || m_RelativePosition < math::g_Pi / 3)
        {
          m_ContactType = contact::GetTypes().SHEET_SHEET;
        }
        //TWILIGHT_ZONE if 60 < angle < 120
        else
        {
          m_ContactType = contact::GetTypes().UNDEFINED_STRAND_STRAND;
        }

      }
      // if the contact type was not matched
      else
      {
        BCL_Exit( "impossible contact type supplied, since TypeFromSSTypes only returns 4 different ones", -1);
      }
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read SSEGeometryPacking from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPacking::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ContactType, ISTREAM);
      io::Serialize::Read( m_ShortestConnection, ISTREAM);
      io::Serialize::Read( m_Distance, ISTREAM);
      io::Serialize::Read( m_OrthogonalConnection, ISTREAM);
      io::Serialize::Read( m_InteractionWeight, ISTREAM);
      io::Serialize::Read( m_TwistAngle, ISTREAM);
      io::Serialize::Read( m_Orientation, ISTREAM);
      io::Serialize::Read( m_RelativePosition, ISTREAM);
      io::Serialize::Read( m_RelativePositionWeight, ISTREAM);
      io::Serialize::Read( m_StrandStrandPairingWeight, ISTREAM);
      io::Serialize::Read( m_MinimalInterfaceLength, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write SSEGeometryPacking to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &SSEGeometryPacking::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ContactType, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_ShortestConnection, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Distance, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_OrthogonalConnection, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_InteractionWeight, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_TwistAngle, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Orientation, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_RelativePosition, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_RelativePositionWeight, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_StrandStrandPairingWeight, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MinimalInterfaceLength, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief Calculate twist angle between sse pair
    //! @param SSE_GEOMETRY_A first SSE of interest
    //! @param SSE_GEOMETRY_B second SSE of interest
    //! @param SHORTEST_CONNECTION shortest connection to be used
    //! @return twist angle between sse pair
    double
    SSEGeometryPacking::CalulateTwistAngle
    (
      const SSEGeometryInterface &SSE_GEOMETRY_A,
      const SSEGeometryInterface &SSE_GEOMETRY_B,
      const coord::LineSegment3D &SHORTEST_CONNECTION
    )
    {
      return linal::Dihedral
             (
               SHORTEST_CONNECTION.GetStartPoint() + SSE_GEOMETRY_A.GetAxis( coord::GetAxes().e_Z),
               SHORTEST_CONNECTION.GetStartPoint(),
               SHORTEST_CONNECTION.GetEndPoint(),
               SHORTEST_CONNECTION.GetEndPoint()   + SSE_GEOMETRY_B.GetAxis( coord::GetAxes().e_Z)
             );
    }

    //! @brief calculate the the alpha1 (angle between THIS_SSE and shortest connection)
    //! @param SSE_GEOMETRY SSE geometry of interest
    //! @param SHORTEST_CONNECTION shortest connection to be used in angle calculation
    //! @return the the alpha1 (angle between THIS_SSE and shortest connection)
    double SSEGeometryPacking::AngleSSEConnection
    (
      const SSEGeometryInterface &SSE_GEOMETRY,
      const coord::LineSegment3D &SHORTEST_CONNECTION
    )
    {
      return
        math::Absolute
        (
          math::g_Pi * 0.5 - linal::ProjAngle( SSE_GEOMETRY.GetAxis( coord::GetAxes().e_Z), SHORTEST_CONNECTION.GetDirection())
        );
    }

    //! @brief Calculate weight of interaction between sse pair
    //! @param SSE_GEOMETRY_A first SSE of interest
    //! @param SSE_GEOMETRY_B second SSE of interest
    //! @param SHORTEST_CONNECTION shortest connection to be used in weight calculation
    //! @return weight of interaction between sse pair
    double
    SSEGeometryPacking::InteractionWeight
    (
      const SSEGeometryInterface &SSE_GEOMETRY_A,
      const SSEGeometryInterface &SSE_GEOMETRY_B,
      const coord::LineSegment3D &SHORTEST_CONNECTION
    )
    {
      //calculate the deviation of an orthogonal angle between the main axis of each SSE and the shortest connection
      // for a nice pairing where the foot-points are not on the borders of the main axis, they should be 0
      //for a bad pairing (orthogonal) one should be 90 degree
      const double alpha1( AngleSSEConnection( SSE_GEOMETRY_A, SHORTEST_CONNECTION));
      const double alpha2( AngleSSEConnection( SSE_GEOMETRY_B, SHORTEST_CONNECTION));

      //product from two weights, will be maximal if alpha is 0 degree and zero if either is 90 degree
      return math::WeightBetweenZeroAndPi( alpha1 * 2) * math::WeightBetweenZeroAndPi( alpha2 * 2);
    }

    //! @brief static function to calculate the orientation of two SSEs
    //! @param SSE_GEOMETRY_A first SSE of interest
    //! @param SSE_GEOMETRY_B second SSE of interest
    //! @return the orientation of two SSEs
    SSEGeometryPacking::OrientationEnum SSEGeometryPacking::OrientationFromSSEs
    (
      const SSEGeometryInterface &SSE_GEOMETRY_A,
      const SSEGeometryInterface &SSE_GEOMETRY_B
    )
    {
      // check that the SSEs have defined transformation matrices (bodies)
      if
      (
        SSE_GEOMETRY_A.GetType()->IsStructured() &&
        SSE_GEOMETRY_B.GetType()->IsStructured() &&
        ( !SSE_GEOMETRY_A.IsDefined() || !SSE_GEOMETRY_B.IsDefined())
      )
      {
        return OrientationEnum( e_UndefinedOrientation);
      }

      const double angle_start_to_finish
      (
        SSE_GEOMETRY_A.GetCentralAA() < SSE_GEOMETRY_B.GetCentralAA()
        ? linal::ProjAngle( SSE_GEOMETRY_A.BeginOfZ(), SSE_GEOMETRY_A.EndOfZ(), SSE_GEOMETRY_B.BeginOfZ(), SSE_GEOMETRY_B.EndOfZ())
        : linal::ProjAngle( SSE_GEOMETRY_B.BeginOfZ(), SSE_GEOMETRY_B.EndOfZ(), SSE_GEOMETRY_A.BeginOfZ(), SSE_GEOMETRY_A.EndOfZ())
      );

      // set the orientation
      return Orientation( angle_start_to_finish >= math::g_Pi * 0.5);
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_packing_criteria.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_geometry_packing.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPackingCriteriaCombine::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPackingCriteriaCombine())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPackingCriteriaCombine::SSEGeometryPackingCriteriaCombine() :
      m_CriteriaVector()
    {
    }

    //! @brief constructor from a criteria vector
    //! @param CRITERIA_VECTOR vector of criteria
    SSEGeometryPackingCriteriaCombine::SSEGeometryPackingCriteriaCombine
    (
      const util::ShPtrVector< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> > &CRITERIA_VECTOR
    ) :
      m_CriteriaVector( CRITERIA_VECTOR)
    {
    }

    //! @brief virtual copy constructor
    SSEGeometryPackingCriteriaCombine *SSEGeometryPackingCriteriaCombine::Clone() const
    {
      return new SSEGeometryPackingCriteriaCombine( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEGeometryPackingCriteriaCombine::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief evaluate the given SSEGeometryPacking according to the group of criteria
    //! @param SSE_GEOMETRY_PACKING SSEGeometryPacking to be evaluated
    //! @return true if given SSEGeometryPacking follows all criteria
    bool SSEGeometryPackingCriteriaCombine::operator()
    (
      const SSEGeometryPacking &SSE_GEOMETRY_PACKING
    ) const
    {
      // iterate over criteria
      for
      (
        util::ShPtrVector< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> >::const_iterator
          criteria_itr( m_CriteriaVector.Begin()), criteria_itr_end( m_CriteriaVector.End());
        criteria_itr != criteria_itr_end; ++criteria_itr
      )
      {
        // return false if the criteria is not correct
        if( !( *criteria_itr)->operator ()( SSE_GEOMETRY_PACKING))
        {
          return false;
        }
      }

      // return true if this point is reached, meaning all the criteria were followed
      return true;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackingCriteriaCombine::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_CriteriaVector, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackingCriteriaCombine::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_CriteriaVector, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPackingCriteriaDistance::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPackingCriteriaDistance())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPackingCriteriaDistance::SSEGeometryPackingCriteriaDistance() :
      m_DistanceCutoff(),
      m_Comparison()
    {
    }

    //! @brief constructor from a distance cutoff and a comparison
    //! @param DISTANCE_CUTOFF distance cutoff
    //! @param COMPARISON Comparison operator
    SSEGeometryPackingCriteriaDistance::SSEGeometryPackingCriteriaDistance
    (
      const double DISTANCE_CUTOFF,
      const math::Comparisons< double>::Comparison &COMPARISON
    ) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_Comparison( COMPARISON)
    {
    }

    //! @brief virtual copy constructor
    SSEGeometryPackingCriteriaDistance *SSEGeometryPackingCriteriaDistance::Clone() const
    {
      return new SSEGeometryPackingCriteriaDistance( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEGeometryPackingCriteriaDistance::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief evaluate the given SSEGeometryPacking according to distance cutoff criteria
    //! @param SSE_GEOMETRY_PACKING SSEGeometryPacking to be evaluated
    //! @return true if SSEGeometryPacking follows distance cutoff criteria
    bool SSEGeometryPackingCriteriaDistance::operator()( const SSEGeometryPacking &SSE_GEOMETRY_PACKING) const
    {
      // evaluate the distance cutoff using the comparison operator
      return ( *m_Comparison)->operator ()( SSE_GEOMETRY_PACKING.GetDistance(), m_DistanceCutoff);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackingCriteriaDistance::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_DistanceCutoff, ISTREAM);
      io::Serialize::Read( m_Comparison, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackingCriteriaDistance::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_DistanceCutoff, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Comparison, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPackingCriteriaContactType::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPackingCriteriaContactType())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPackingCriteriaContactType::SSEGeometryPackingCriteriaContactType() :
      m_ContactTypes()
    {
    }

    //! @brief constructor from a contact type
    //! @param CONTACT_TYPE requested contact type
    SSEGeometryPackingCriteriaContactType::SSEGeometryPackingCriteriaContactType
    (
      const contact::Type &CONTACT_TYPE
    ) :
      m_ContactTypes( CONTACT_TYPE)
    {
    }

    //! @brief constructor from a set of contact types
    //! @param CONTACT_TYPES set of requested contact types
    SSEGeometryPackingCriteriaContactType::SSEGeometryPackingCriteriaContactType
    (
      const storage::Set< contact::Type> &CONTACT_TYPES
    ) :
      m_ContactTypes( CONTACT_TYPES)
    {
    }

    //! @brief virtual copy constructor
    SSEGeometryPackingCriteriaContactType *SSEGeometryPackingCriteriaContactType::Clone() const
    {
      return new SSEGeometryPackingCriteriaContactType( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEGeometryPackingCriteriaContactType::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief evaluate the given SSEGeometryPacking according to contact type criteria
    //! @param SSE_GEOMETRY_PACKING SSEGeometryPacking to be evaluated
    //! @return true if SSEGeometryPacking follows contact type criteria
    bool SSEGeometryPackingCriteriaContactType::operator()
    (
      const SSEGeometryPacking &SSE_GEOMETRY_PACKING
    ) const
    {
      // search for the corresponding contact type
      return m_ContactTypes.Contains( SSE_GEOMETRY_PACKING.GetContactType());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackingCriteriaContactType::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ContactTypes, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackingCriteriaContactType::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ContactTypes, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPackingCriteriaInteractionWeight::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPackingCriteriaInteractionWeight())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPackingCriteriaInteractionWeight::SSEGeometryPackingCriteriaInteractionWeight() :
      m_InteractionWeightCutoff(),
      m_Comparison()
    {
    }

    //! @brief constructor from a interaction weight cutoff and a comparison
    //! @param INTERACTION_WEIGHT_CUTOFF interaction weight cutoff
    //! @param COMPARISON Comparison operator
    SSEGeometryPackingCriteriaInteractionWeight::SSEGeometryPackingCriteriaInteractionWeight
    (
      const double INTERACTION_WEIGHT_CUTOFF,
      const math::Comparisons< double>::Comparison &COMPARISON
    ) :
      m_InteractionWeightCutoff( INTERACTION_WEIGHT_CUTOFF),
      m_Comparison( COMPARISON)
    {
    }

    //! @brief virtual copy constructor
    SSEGeometryPackingCriteriaInteractionWeight *SSEGeometryPackingCriteriaInteractionWeight::Clone() const
    {
      return new SSEGeometryPackingCriteriaInteractionWeight( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEGeometryPackingCriteriaInteractionWeight::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief evaluate the given SSEGeometryPacking according to interaction weight cutoff criteria
    //! @param SSE_GEOMETRY_PACKING SSEGeometryPacking to be evaluated
    //! @return true if SSEGeometryPacking follows interaction weight cutoff criteria
    bool SSEGeometryPackingCriteriaInteractionWeight::operator()
    (
      const SSEGeometryPacking &SSE_GEOMETRY_PACKING
    ) const
    {
      // evaluate the interaction weight cutoff using the comparison operator
      return ( *m_Comparison)->operator ()( SSE_GEOMETRY_PACKING.GetInteractionWeight(), m_InteractionWeightCutoff);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackingCriteriaInteractionWeight::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_InteractionWeightCutoff, ISTREAM);
      io::Serialize::Read( m_Comparison, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackingCriteriaInteractionWeight::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_InteractionWeightCutoff, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Comparison, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from a strand weight cutoff and a comparison
    //! @param STRAND_WEIGHT_CUTOFF strand weight cutoff
    //! @param COMPARISON Comparison operator
    SSEGeometryPackingCriteriaStrandWeight::SSEGeometryPackingCriteriaStrandWeight
    (
      const double STRAND_WEIGHT_CUTOFF,
      const math::Comparisons< double>::Comparison &COMPARISON
    ) :
      m_StrandWeightCutoff( STRAND_WEIGHT_CUTOFF),
      m_Comparison( COMPARISON)
    {
    }

    //! @brief virtual copy constructor
    SSEGeometryPackingCriteriaStrandWeight *SSEGeometryPackingCriteriaStrandWeight::Clone() const
    {
      return new SSEGeometryPackingCriteriaStrandWeight( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEGeometryPackingCriteriaStrandWeight::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief evaluate the given SSEGeometryPacking according to strand weight cutoff criteria
    //! @param SSE_GEOMETRY_PACKING SSEGeometryPacking to be evaluated
    //! @return true if SSEGeometryPacking follows strand weight cutoff criteria
    bool SSEGeometryPackingCriteriaStrandWeight::operator()
    (
      const SSEGeometryPacking &SSE_GEOMETRY_PACKING
    ) const
    {
      // evaluate the weight cutoff using the comparison operator
      return ( *m_Comparison)->operator ()( SSE_GEOMETRY_PACKING.GetStrandStrandPairingWeight(), m_StrandWeightCutoff);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackingCriteriaStrandWeight::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_StrandWeightCutoff, ISTREAM);
      io::Serialize::Read( m_Comparison, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackingCriteriaStrandWeight::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_StrandWeightCutoff, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Comparison, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPackingCriteriaDistancePerType::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPackingCriteriaDistancePerType())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPackingCriteriaDistancePerType::SSEGeometryPackingCriteriaDistancePerType()
    {
    }

    //! @brief virtual copy constructor
    SSEGeometryPackingCriteriaDistancePerType *SSEGeometryPackingCriteriaDistancePerType::Clone() const
    {
      return new SSEGeometryPackingCriteriaDistancePerType( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEGeometryPackingCriteriaDistancePerType::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief evaluate the given SSEGeometryPacking according to the distance criteria
    //! @param SSE_GEOMETRY_PACKING SSEGeometryPacking to be evaluated
    //! @return true if SSEGeometryPacking follows the distance criteria
    bool SSEGeometryPackingCriteriaDistancePerType::operator()
    (
      const SSEGeometryPacking &SSE_GEOMETRY_PACKING
    ) const
    {
      // return true if the distance is within the range given by the contact type
      return SSE_GEOMETRY_PACKING.GetContactType()->GetDistanceRange().IsWithin( SSE_GEOMETRY_PACKING.GetDistance());
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPackingCriteriaDistancePerType::Read( std::istream &ISTREAM)
    {
      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPackingCriteriaDistancePerType::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_packing_list_pickers.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_geometry_packer_all_fragment_pairs.h"
#include "assemble/bcl_assemble_sse_geometry_packer_best_fragment_pairs.h"
#include "assemble/bcl_assemble_sse_geometry_packing_compare.h"
#include "util/bcl_util_enumerate.hpp"
// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief private constructor for constructing all SSEGeometryPackingListPickers
    SSEGeometryPackingListPickers::SSEGeometryPackingListPickers() :
      e_BestInteractionWeight
      (
        AddEnum
        (
          "BestInteractionWeight",
          SSEGeometryPackerInterface< storage::List< SSEGeometryPacking> >::WrapPacker
          (
            util::ShPtr< SSEGeometryPackerInterface< storage::List< SSEGeometryPacking> > >
            (
              new SSEGeometryPackerBestFragmentPairs
              (
                GetSSEGeometryPackers().e_Default,
                SSEGeometryPackingCompareInteractionWeight()
              )
            ), true, false
          )
        )
      ),
      e_BestDistance
      (
        AddEnum
        (
          "BestDistance",
          SSEGeometryPackerInterface< storage::List< SSEGeometryPacking> >::WrapPacker
          (
            util::ShPtr< SSEGeometryPackerInterface< storage::List< SSEGeometryPacking> > >
            (
              new SSEGeometryPackerBestFragmentPairs
              (
                GetSSEGeometryPackers().e_Default,
                SSEGeometryPackingCompareDistance()
              )
            ), true, false
          )
        )
      ),
      e_SSEClash
      (
        AddEnum
        (
          "SSEClash",
          SSEGeometryPackerInterface< storage::List< SSEGeometryPacking> >::WrapPacker
          (
            util::ShPtr< SSEGeometryPackerInterface< storage::List< SSEGeometryPacking> > >
            (
              new SSEGeometryPackerBestFragmentPairs
              (
                GetSSEGeometryPackers().e_SSEClash,
                SSEGeometryPackingCompareInteractionWeight()
              )
            ), true, false
          )
        )
      ),
      e_SSEClash_NoCache
      (
        AddEnum
        (
          "SSEClash_NoCache",
          SSEGeometryPackerInterface< storage::List< SSEGeometryPacking> >::WrapPacker
          (
            util::ShPtr< SSEGeometryPackerInterface< storage::List< SSEGeometryPacking> > >
            (
              new SSEGeometryPackerBestFragmentPairs
              (
                GetSSEGeometryPackers().e_SSEClash_NoCache,
                SSEGeometryPackingCompareInteractionWeight()
              )
            ), false, false
          )
        )
      )
    {
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEGeometryPackingListPickers::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief access static instance of SSEGeometryPackingListPickers enums
    //! @return static instance of SSEGeometryPackingListPickers enums
    const SSEGeometryPackingListPickers &GetSSEGeometryPackingListPickers()
    {
      return SSEGeometryPackingListPickers::GetEnums();
    }

  } // namespace assemble

  namespace util
  {

  /////////////////////////////
  // explicit instantiations //
  /////////////////////////////

    template class BCL_API Enumerate< ShPtr< assemble::SSEGeometryPackerInterface< storage::List< assemble::SSEGeometryPacking> > >, assemble::SSEGeometryPackingListPickers>;

  } // namespace util
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_packing_pickers.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_collector_topology_sheet.h"
#include "assemble/bcl_assemble_sse_geometry_packer_best_fragment_pair.h"
#include "assemble/bcl_assemble_sse_geometry_packing_compare.h"
#include "util/bcl_util_enumerate.hpp"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief private constructor for constructing all SSEGeometryPackingPickers
    SSEGeometryPackingPickers::SSEGeometryPackingPickers() :
        e_BestInteractionWeight
        (
          AddEnum
          (
            "BestInteractionWeight",
            SSEGeometryPackerInterface< SSEGeometryPacking>::WrapPacker
            (
              util::ShPtr< SSEGeometryPackerInterface< SSEGeometryPacking> >
              (
                new SSEGeometryPackerBestFragmentPair
                (
                  GetSSEGeometryPackers().e_Default,
                  SSEGeometryPackingCompareInteractionWeight()
                )
              ), true, false
            )
          )
        ),
        e_BestInteractionWeight_NoCache
        (
          AddEnum
          (
            "BestInteractionWeight_NoCache",
            SSEGeometryPackerInterface< SSEGeometryPacking>::WrapPacker
            (
              util::ShPtr< SSEGeometryPackerInterface< SSEGeometryPacking> >
              (
                new SSEGeometryPackerBestFragmentPair
                (
                  GetSSEGeometryPackers().e_Default_NoCache,
                  SSEGeometryPackingCompareInteractionWeight()
                )
              ), false, false
            )
          )
        ),
        e_BestStrandPairing
        (
          AddEnum
          (
            "BestStrandPairing",
            SSEGeometryPackerInterface< SSEGeometryPacking>::WrapPacker
            (
              util::ShPtr< SSEGeometryPackerInterface< SSEGeometryPacking> >
              (
                new SSEGeometryPackerBestFragmentPair
                (
                  GetSSEGeometryPackers().e_Default,
                  *CollectorTopologySheet::GetPackingCriteria(),
                  *CollectorTopologySheet::GetPackingComparison()
                )
              ),
              true, false
            )
          )
        ),
        e_BestStrandPairing_NoCache
        (
          AddEnum
          (
            "BestStrandPairing_NoCache",
            SSEGeometryPackerInterface< SSEGeometryPacking>::WrapPacker
            (
              util::ShPtr< SSEGeometryPackerInterface< SSEGeometryPacking> >
              (
                new SSEGeometryPackerBestFragmentPair
                (
                  GetSSEGeometryPackers().e_Default_NoCache,
                  *CollectorTopologySheet::GetPackingCriteria(),
                  *CollectorTopologySheet::GetPackingComparison()
                )
              ), false, false
            )
          )
        )
      {
      }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEGeometryPackingPickers::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief access function to a static instance of SSEGeometryPackingPickers
    //! @return reference to a static instance of SSEGeometryPackingPickers
    const SSEGeometryPackingPickers &GetSSEGeometryPackingPickers()
    {
      return SSEGeometryPackingPickers::GetEnums();
    }

  } // namespace assemble

  namespace util
  {

  /////////////////////////////
  // explicit instantiations //
  /////////////////////////////

    template class BCL_API Enumerate< ShPtr< assemble::SSEGeometryPackerInterface< assemble::SSEGeometryPacking> >, assemble::SSEGeometryPackingPickers>;

  } // namespace util
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_geometry_phi_psi.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "biol/bcl_biol_aa_sequence_factory.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEGeometryPhiPsi::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEGeometryPhiPsi())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEGeometryPhiPsi::SSEGeometryPhiPsi() :
      m_Geometry(),
      m_PhiPsi()
    {
    }

    //! @brief construct from an SSE
    //! @param ORIGINAL_SSE SSE to build from
    SSEGeometryPhiPsi::SSEGeometryPhiPsi( const SSE &ORIGINAL_SSE) :
      m_Geometry( new SSEGeometry( ORIGINAL_SSE)),
      m_PhiPsi( new biol::AASequencePhiPsi( ORIGINAL_SSE))
    {
    }

    //! @brief construct from phi/psi angles
    //! @param PHI_PSI phi/psi angles
    //! @param SS_TYPE SS type to use to build the geometry
    //! @param IDENTIFICATION identification for this geometry
    //! @param SET_GEOMETRY bool whether to set the geometry using the given SS type, if it is coil, or undefined,
    //!        the geometry is not constructed
    SSEGeometryPhiPsi::SSEGeometryPhiPsi
    (
      const biol::AASequencePhiPsi &PHI_PSI,
      const biol::SSType &SS_TYPE,
      const std::string &IDENTIFICATION,
      const bool SET_GEOMETRY
    ) :
      m_Geometry( new SSEGeometry( SS_TYPE, IDENTIFICATION)),
      m_PhiPsi( PHI_PSI.Clone())
    {
      // build the geometry if requested
      if( SET_GEOMETRY && SS_TYPE.IsDefined() && SS_TYPE->IsStructured())
      {
        SetSSEGeometryUsingPhiPsi();
      }
    }

    //! @brief copy constructor
    //! @param GEOMETRY SSEGeometryPhiPsi to be copied
    SSEGeometryPhiPsi::SSEGeometryPhiPsi( const SSEGeometryPhiPsi &GEOMETRY) :
      m_Geometry( GEOMETRY.m_Geometry.HardCopy()),
      m_PhiPsi( GEOMETRY.m_PhiPsi.HardCopy())
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEGeometryPhiPsi
    SSEGeometryPhiPsi *SSEGeometryPhiPsi::Clone() const
    {
      return new SSEGeometryPhiPsi( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEGeometryPhiPsi::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief use the phi/psi information to build the SSEGeometry object
    void SSEGeometryPhiPsi::SetSSEGeometryUsingPhiPsi()
    {
      // construct a poly-A string of a length to match the number of phi/psis
      const std::string dummy_string( m_PhiPsi->GetAngles().GetSize(), 'A');

      // build a dummy sequence using the phi/psi angles
      biol::AASequence dummy_seq
      (
        biol::AASequenceFactory::BuildSequenceFromFASTAString( dummy_string, biol::GetAAClasses().e_AABackBone)
      );

      // fit the dummy sequence
      biol::AASequenceFactory::FitSequence( dummy_seq, *m_PhiPsi, GetType());

      // update the geometry by constructing an SSE and using it to build a SSEGeometry
      const std::string identification( GetIdentification());
      m_Geometry = util::ShPtr< SSEGeometry>( new SSEGeometry( SSE( dummy_seq, GetType())));
      m_Geometry->SetIdentification( identification);
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief translate the object along a given TRANSLATION vector
    //! @param TRANSLATION Translation to be applied
    void SSEGeometryPhiPsi::Translate( const linal::Vector3D &TRANSLATION)
    {
      m_Geometry->Translate( TRANSLATION);
      m_PhiPsi->Translate( TRANSLATION);
    }

    //! @brief transform the object by a given TransformationMatrix3D
    //! @param TRANSFORMATION_MATRIX_3D TransformationMatrix3D to be applied
    void SSEGeometryPhiPsi::Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
    {
      m_Geometry->Transform( TRANSFORMATION_MATRIX_3D);
      m_PhiPsi->Transform( TRANSFORMATION_MATRIX_3D);
    }

    //! @brief rotate the object by a given RotationMatrix3D
    //! @param ROTATION_MATRIX_3D RotationMatrix3D to be applied
    void SSEGeometryPhiPsi::Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
    {
      m_Geometry->Rotate( ROTATION_MATRIX_3D);
      m_PhiPsi->Rotate( ROTATION_MATRIX_3D);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator = SSEGeometryPhiPsi assign operator
    //! @param SSE_GEOMETRY_PHI_PSI_RHS SSEGeometry to be assigned to
    //! @return this SSEGeometryPhiPsi after assignment
    SSEGeometryPhiPsi &SSEGeometryPhiPsi::operator =( const SSEGeometryPhiPsi &SSE_GEOMETRY_PHI_PSI_RHS)
    {
      // assign members
      m_Geometry = SSE_GEOMETRY_PHI_PSI_RHS.m_Geometry.HardCopy();
      m_PhiPsi = SSE_GEOMETRY_PHI_PSI_RHS.m_PhiPsi.HardCopy();

      //end
      return *this;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEGeometryPhiPsi::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Geometry, ISTREAM);
      io::Serialize::Read( m_PhiPsi, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEGeometryPhiPsi::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Geometry, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_PhiPsi, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  /////////////////////////
  // SSEGeometryLessThan //
  /////////////////////////

    //! @brief return true if SSE_GEO_A is less than SSE_GEO_B in size
    //! @param SSE_GEO_A first SSEGeometryPhiPsi
    //! @param SSE_GEO_B second SSEGeometryPhiPsi
    //! @return true if SSE_GEO_A is less than SSE_GEO_B in size
    bool SSEGeometryPhiPsiLessThan::operator()
    (
      const SSEGeometryPhiPsi &SSE_GEO_A,
      const SSEGeometryPhiPsi &SSE_GEO_B
    ) const
    {
      return SSEGeometryInterfaceLessThan()( SSE_GEO_A, SSE_GEO_B);
    }

    //! @brief return true if PTR_SSE_GEO_A is less than PTR_SSE_GEO_B in size
    //! @param PTR_SSE_GEO_A first SSEGeometryPhiPsi
    //! @param PTR_SSE_GEO_B second SSEGeometryPhiPsi
    //! @return true if PTR_SSE_GEO_A is less than PTR_SSE_GEO_B in size
    bool SSEGeometryPhiPsiLessThan::operator()
    (
      const util::PtrInterface< SSEGeometryPhiPsi> &PTR_SSE_GEO_A,
      const util::PtrInterface< SSEGeometryPhiPsi> &PTR_SSE_GEO_B
    ) const
    {
      return operator()( *PTR_SSE_GEO_A, *PTR_SSE_GEO_B);
    }

    //! @brief return true if PTR_SSE_GEO_A is less than PTR_SSE_GEO_B in size
    //! @param PTR_SSE_GEO_A first SSEGeometryPhiPsi
    //! @param PTR_SSE_GEO_B second SSEGeometryPhiPsi
    //! @return true if PTR_SSE_GEO_A is less than PTR_SSE_GEO_B in size
    bool SSEGeometryPhiPsiLessThan::operator()
    (
      const util::PtrInterface< const SSEGeometryPhiPsi> &PTR_SSE_GEO_A,
      const util::PtrInterface< const SSEGeometryPhiPsi> &PTR_SSE_GEO_B
    ) const
    {
      return operator()( *PTR_SSE_GEO_A, *PTR_SSE_GEO_B);
    }

  } // namespace assemble
  
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_pair_template.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEPairTemplate::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEPairTemplate())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEPairTemplate::SSEPairTemplate() :
      m_FirstSSEGeometry(),
      m_SecondSSEGeometry(),
      m_LoopLength( util::GetUndefined< size_t>()),
      m_Packing()
    {
    }

    //! @brief construct from two SSE geometries
    //! @param SP_FIRST_SSE_GEOMETRY first SSE geometry
    //! @param SP_SECOND_SSE_GEOMETRY second SSE geometry
    //! @param LOOP_LENGTH length of the loop connecting the two geometries
    SSEPairTemplate::SSEPairTemplate
    (
      const util::ShPtr< SSEGeometryInterface> &SP_FIRST_SSE_GEOMETRY,
      const util::ShPtr< SSEGeometryInterface> &SP_SECOND_SSE_GEOMETRY,
      const size_t LOOP_LENGTH
    ) :
      m_FirstSSEGeometry( SP_FIRST_SSE_GEOMETRY),
      m_SecondSSEGeometry( SP_SECOND_SSE_GEOMETRY),
      m_LoopLength( LOOP_LENGTH),
      m_Packing( *SP_FIRST_SSE_GEOMETRY, *SP_SECOND_SSE_GEOMETRY)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEPairTemplate
    SSEPairTemplate *SSEPairTemplate::Clone() const
    {
      return new SSEPairTemplate( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &SSEPairTemplate::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPairTemplate::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_FirstSSEGeometry, ISTREAM);
      io::Serialize::Read( m_SecondSSEGeometry, ISTREAM);
      io::Serialize::Read( m_LoopLength, ISTREAM);
      io::Serialize::Read( m_Packing, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPairTemplate::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_FirstSSEGeometry, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SecondSSEGeometry, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_LoopLength, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Packing, OSTREAM, INDENT) << '\n';

      // end
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_pool_agreement.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "util/bcl_util_si_ptr_list.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPoolAgreement::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEPoolAgreement())
    );

    //! @brief default scheme as string
    //! @return string for default scheme
    const std::string &SSEPoolAgreement::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "sse_pool_agreement");

      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    //! @param SCHEME scheme for function
    //! @param LOG before adding differences, take log
    SSEPoolAgreement::SSEPoolAgreement( const bool LOG, const std::string &SCHEME) :
      m_Scheme( SCHEME),
      m_Log( LOG)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEPoolAgreement
    SSEPoolAgreement *SSEPoolAgreement::Clone() const
    {
      return new SSEPoolAgreement( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPoolAgreement::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this function class
    //! @return the scheme for this function class
    const std::string &SSEPoolAgreement::GetScheme() const
    {
      return m_Scheme;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief virtual operator taking two ARGUMENTs and returning a t_ResultType object
    //! @param POOL the pool to be evaluated
    //! @param POOL_TEMPLATE the template to evaluate against
    //! @return double that expresses the agreement of the pool to the template
    double SSEPoolAgreement::AgreementToTemplate( const SSEPool &POOL, const SSEPool &POOL_TEMPLATE) const
    {
      const double missing_sse_penalty_multiplier( 3.0); // multiplier
      const int tolerate_shift_residues( 1); // number of residues difference in beginning and end, that is not penalized

      // initialize agreement
      double agreement( 0.0);

      // iterate over the sses in the template
      for
      (
        SSEPool::const_iterator temp_itr( POOL_TEMPLATE.Begin()), temp_itr_end( POOL_TEMPLATE.End());
        temp_itr != temp_itr_end; ++temp_itr
      )
      {
        // if the current SSE is empty
        if( ( *temp_itr)->GetSize() == 0)
        {
          // warn user and skip this SSE
          BCL_MessageCrt( "Empty SSE found " + ( *temp_itr)->GetIdentification());
          continue;
        }

        // ignore coils for agreement evaluation
        if( !( *temp_itr)->GetType()->IsStructured())
        {
          continue;
        }

        // find overlapping sses in the POOL in question include identical, exclude different type
        const util::SiPtrList< const SSE> overlap_sses( POOL.GetOverlappingSSEs( **temp_itr, false, true));

        // number of overlapping
        const size_t nr_overlapping( overlap_sses.GetSize());

        // no sse found - total miss
        if( nr_overlapping == 0)
        {
          BCL_MessageDbg
          (
            "no overlapping sse found for template: " + ( *temp_itr)->GetIdentification()
          );
          double penalty( ( *temp_itr)->GetSize());
          if( m_Log)
          {
            penalty = std::log( penalty + 1);
          }
          agreement += missing_sse_penalty_multiplier * penalty;
          continue;
        }

        // initialize this agreement
        double this_agreement( 0.0);

        // iterate over overlap
        for
        (
          util::SiPtrList< const SSE>::const_iterator over_itr( overlap_sses.Begin()), over_itr_end( overlap_sses.End());
          over_itr != over_itr_end;
          ++over_itr
        )
        {
          // calculate the overlap and store it
          storage::VectorND< 2, int> this_overlap( Overlap( **over_itr, **temp_itr));

          // calculate the score and sum it up
          double shift_left(   std::max( 0, math::Absolute( this_overlap.First()) - tolerate_shift_residues));
          double shift_right(  std::max( 0, math::Absolute( this_overlap.Second()) - tolerate_shift_residues));
          double shift_length( math::Absolute( this_overlap.First() + this_overlap.Second()));

          if( m_Log)
          {
            shift_left   = std::log( shift_left + 1);
            shift_right  = std::log( shift_right + 1);
            shift_length = std::log( shift_length + 1);
          }

          BCL_MessageDbg
          (
            "Agreement between " + ( *temp_itr)->GetIdentification() + " and " +
            ( *over_itr)->GetIdentification() + " ==> " +
            util::Format()( shift_left) + "\t" +
            util::Format()( shift_right) + "\t" +
            util::Format()( shift_length)
          );

          // add the agreement scores
          this_agreement += shift_left + shift_right + shift_length;
        }

        // normalize this agreement sum by number of overlap and add it to the global agreement value
        agreement += this_agreement / double( nr_overlapping);
      }

      return agreement;
    }

    //! @brief Q3 score for two SSEPools
    //! @param POOL_A the pool a
    //! @param POOL_B the pool b
    //! @return number_correct_sse/total_number_res * 100%
    double SSEPoolAgreement::Q3Score( const SSEPool &POOL_A, const SSEPool &POOL_B) const
    {
      storage::Map< util::SiPtr< const biol::AAData>, biol::SSType> per_res_sstype_a;
      for( SSEPool::const_iterator sse_itr( POOL_A.Begin()), sse_itr_end( POOL_A.End()); sse_itr != sse_itr_end; ++sse_itr)
      {
        const biol::SSType &current_type( ( *sse_itr)->GetType());
        for( SSE::const_iterator aa_itr( ( *sse_itr)->Begin()), aa_itr_end( ( *sse_itr)->End()); aa_itr != aa_itr_end; ++aa_itr)
        {
          if( !per_res_sstype_a.Insert( std::pair< util::SiPtr< const biol::AAData>, biol::SSType>( ( *aa_itr)->GetData(), current_type)).second)
          {
            BCL_MessageCrt( "supplied pool with overlapping sse definitions at res: " + ( *aa_itr)->GetIdentification())
            return util::GetUndefined< double>();
          }
        }
      }

      int total_number( per_res_sstype_a.GetSize());
      int correct_number( 0);

      for( SSEPool::const_iterator sse_itr( POOL_B.Begin()), sse_itr_end( POOL_B.End()); sse_itr != sse_itr_end; ++sse_itr)
      {
        const biol::SSType &current_type( ( *sse_itr)->GetType());
        for( SSE::const_iterator aa_itr( ( *sse_itr)->Begin()), aa_itr_end( ( *sse_itr)->End()); aa_itr != aa_itr_end; ++aa_itr)
        {
          const storage::Map< util::SiPtr< const biol::AAData>, biol::SSType>::const_iterator find_itr( per_res_sstype_a.Find( ( *aa_itr)->GetData()));

          // residue in pool a that is not present in the pool b
          if( find_itr == per_res_sstype_a.End())
          {
            ++total_number;
          }
          else if( find_itr->second == current_type)
          {
            ++correct_number;
          }
        }
      }

      return double( 100 * correct_number) / double( total_number);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief virtual operator taking two pools and returning the symmetric agreement, by taking the average of the
    //!        agreement if each pool is treated as template to the other
    //! @param POOL_A the pool a
    //! @param POOL_B the pool b
    //! @return double that expresses the agreement between two pools
    double SSEPoolAgreement::operator()( const SSEPool &POOL_A, const SSEPool &POOL_B) const
    {
      const double agreement_a_b( AgreementToTemplate( POOL_A, POOL_B));
      const double agreement_b_a( AgreementToTemplate( POOL_B, POOL_A));
      return agreement_a_b + agreement_b_a;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPoolAgreement::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Scheme, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPoolAgreement::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Scheme, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief calculate the overlap between two sequences
    //! @param SEQUENCE the sequence of interest
    //! @param SEQUENCE_TEMPLATE the reference sequence
    //! @return pair where first is the overlap on the left (first seq id difference) and the right (last seqid difference),
    //!         where the sign indicates if the SEQUENCE is shorter (negative) or longer (positive) then the template, sum
    //!         of those two is the overall length difference
    storage::VectorND< 2, int> SSEPoolAgreement::Overlap
    (
      const biol::AASequence &SEQUENCE,
      const biol::AASequence &SEQUENCE_TEMPLATE
    )
    {
      BCL_Assert( SEQUENCE.GetSize() > 0 && SEQUENCE_TEMPLATE.GetSize() > 0, "empty sequences supplied");
      return
        storage::VectorND< 2, int>
        (
          SEQUENCE_TEMPLATE.GetFirstAA()->GetSeqID() - SEQUENCE.GetFirstAA()->GetSeqID(),
          SEQUENCE.GetLastAA()->GetSeqID() - SEQUENCE_TEMPLATE.GetLastAA()->GetSeqID()
        );
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_pool.h"

// includes from bcl - sorted alphabetically
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter.h"
#include "fold/bcl_fold_stage_factory.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_range_set.h"
#include "pdb/bcl_pdb_line.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> SSEPool::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEPool())
    );

    //! @brief return command line flag for providing a pool file
    //! @return command line flag for providing a pool file
    util::ShPtr< command::FlagInterface> &SSEPool::GetFlagPoolRead()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "pool", "file with sse definitions to be used in constructing SSE pool",
          command::Parameter
          (
            "pool_filename", "filename for input SSE definitions to be used in constructing SSE pool", "pool.txt"
          )
        )
      );
      // end
      return s_flag;
    }

    //! @brief return command line flag for setting minimum helix and strand lengths to be considered from the pool
    //! @return command line flag setting minimum helix and strand lengths to be considered from the pool
    util::ShPtr< command::FlagInterface> &SSEPool::GetFlagMinSSELengths()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "pool_min_sse_lengths", "minimal sse lengths for sses in the pool to be considered in folding"
        )
      );
      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_helix_length_param
      (
        new command::Parameter
        (
          "pool_min_helix_length", "\tminimal length of helices from the pool to be considered in folding", "9"
        )
      );
      static util::ShPtr< command::ParameterInterface> s_strand_length_param
      (
        new command::Parameter
        (
          "pool_min_strand_length", "\tminimal length of strands from the pool to be considered in folding", "5"
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters into flag
        flag->PushBack( s_helix_length_param);
        flag->PushBack( s_strand_length_param);
      }

      // end
      return s_flag;
    }

    //! @brief return command line flag for setting minimum helix and strand lengths to be considered from the pool
    //! @return command line flag setting minimum helix and strand lengths to be considered from the pool
    storage::Map< biol::SSType, size_t> SSEPool::GetCommandLineMinSSELengths()
    {
      // initialize sse min sizes for the pool
      storage::Map< biol::SSType, size_t> pool_sse_min_sizes;

      // set the values from the command line
      pool_sse_min_sizes[ biol::GetSSTypes().HELIX] =
          GetFlagMinSSELengths()->GetParameterList()( 0)->GetNumericalValue< size_t>();
      pool_sse_min_sizes[ biol::GetSSTypes().STRAND] =
          GetFlagMinSSELengths()->GetParameterList()( 1)->GetNumericalValue< size_t>();

      // end
      return pool_sse_min_sizes;
    }

    //! @brief return command line flag for specifying a pool prefix - to be used when different pools postfixes are
    //!        specified within a stages file
    //! @return command line flag setting the prefix of pool files that will be used
    util::ShPtr< command::FlagInterface> &SSEPool::GetFlagPoolPrefix()
    {
      // initialize static flag
      static util::ShPtr< command::FlagInterface> s_flag
      (
        new command::FlagStatic
        (
          "pool_prefix", "return command line flag for specifying a pool prefix - to be used when different pools "
          " postfixes are specified within a stages file. This flag does nothing unless the "
          + util::Format()( fold::StageFactory::e_PoolPostfix) + " tag is used in a stages file. In which case, the "
          " pool file will be "
          "searched for as \"<pool_prefix>.<pool_postfix_from_stages_file>\". The period (\".\") will be added "
          "automatically so do not include this in either the prefix or postfix."
        )
      );
      // initialize parameters
      static util::ShPtr< command::ParameterInterface> s_param
      (
        new command::Parameter
        (
          "pool_prefix", "\tstring which is the prefix for accessing the desired pool", "myproteinpoolprefix"
        )
      );

      // if the flag is initialized for the first time
      if( s_flag->GetParameterList().IsEmpty())
      {
        util::ShPtr< command::FlagStatic> flag( s_flag);
        // insert parameters into flag
        flag->PushBack( s_param);
      }

      // end
      return s_flag;

    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSEPool::SSEPool() :
      m_Data()
    {
    }

    //! @brief constructor from a vector of sses
    //! @param SSE_VECTOR vector of sses
    //! @param IGNORE_UNSTRUCTURED ignore unstructured sses
    //! @param IDEALIZE whether to idealize the SSEs (or simply move them to the origin)
    SSEPool::SSEPool
    (
      const util::SiPtrVector< const SSE> &SSE_VECTOR,
      const bool IGNORE_UNSTRUCTURED,
      const bool IDEALIZE
    ) :
      m_Data()
    {
      Initialize( SSE_VECTOR, IGNORE_UNSTRUCTURED, IDEALIZE);
    }

    //! @brief constructor from a list of sses
    //! @param SSE_LIST list of sses
    //! @param IGNORE_UNSTRUCTURED ignore unstructured sses
    //! @param IDEALIZE whether to idealize the SSEs (or simply move them to the origin)
    SSEPool::SSEPool
    (
      const util::SiPtrList< const SSE> &SSE_LIST,
      const bool IGNORE_UNSTRUCTURED,
      const bool IDEALIZE
    ) :
      m_Data()
    {
      Initialize( util::SiPtrVector< const SSE>( SSE_LIST.Begin(), SSE_LIST.End()), IGNORE_UNSTRUCTURED, IDEALIZE);
    }

    //! @brief virtual copy constructor
    SSEPool *SSEPool::Clone() const
    {
      return new SSEPool( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPool::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns SiPtrVector of all SSEs
    //! @return SiPtrVector of all SSEs
    util::SiPtrVector< const SSE> SSEPool::GetSSEs() const
    {
      util::SiPtrVector< const SSE> sses;

      //loop over all SSElements
      for
      (
        const_iterator set_itr( m_Data.Begin()), set_itr_end( m_Data.End());
        set_itr != set_itr_end;
        ++set_itr
      )
      {
        sses.PushBack( &( ( **set_itr)));
      }

      return sses;
    }

    //! @brief Get the total number of potentially structured AAs
    size_t SSEPool::GetNumberPotentiallyStructuredAAs() const
    {
      // set of structured ranges
      math::RangeSet< int> structured_ranges;
      //loop over all SSElements
      for
      (
        const_iterator set_itr( m_Data.Begin()), set_itr_end( m_Data.End());
        set_itr != set_itr_end;
        ++set_itr
      )
      {
        structured_ranges +=
          math::Range< int>( ( ( **set_itr).GetFirstAA())->GetSeqID(), ( ( **set_itr).GetLastAA())->GetSeqID());
      }
      size_t number_structured( 0);
      for
      (
        storage::Set< math::Range< int> >::const_iterator
          itr( structured_ranges.GetRanges().Begin()), itr_end( structured_ranges.GetRanges().End());
        itr != itr_end;
        ++itr
      )
      {
        // offset of 1 because the range borders are closed, so the last position would otherwise not be counted
        number_structured += itr->GetWidth() + 1;
      }
      return number_structured;
    }

    //! @brief returns SiPtrVector of all SSEs of given SS_TYPE
    //! @param SS_TYPE SSType of interest
    //! @return SiPtrVector of all SSEs of given SS_TYPE
    util::SiPtrVector< const SSE> SSEPool::GetSSEs( const biol::SSType &SS_TYPE) const
    {
      util::SiPtrVector< const SSE> sses;

      //loop over all SSElements
      for
      (
        const_iterator set_itr( m_Data.Begin()), set_itr_end( m_Data.End());
        set_itr != set_itr_end;
        ++set_itr
      )
      {
        if( ( *set_itr)->GetType() == SS_TYPE)
        {
          sses.PushBack( ( **set_itr));
        }
      }

      return sses;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief returns whether the pool has overlapping SSEs
    //! @return whether the pool has overlapping SSEs
    bool SSEPool::IsOverlapping() const
    {
      // iterate over all SSEs in the pool
      for( const_iterator itr_a( m_Data.Begin()), itr_end( m_Data.End()); itr_a != itr_end; ++itr_a)
      {
        // create a second iterator
        const_iterator itr_b( itr_a);
        ++itr_b;

        for( ; itr_b != itr_end; ++itr_b)
        {
          // if overlapping return true
          if( biol::DoOverlap( **itr_a, **itr_b))
          {
            return true;
          }
        }
      }

      // if no overlaps found return false
      return false;
    }

    //! @brief removes the identical SSEs with the provided PROTEIN_MODEL from pool
    //! @param PROTEIN_MODEL protein model
    //! @return SiPtrList of SSEs in the pool excluding ones that are identical to SSEs in the provided PROTEIN_MODEL
    util::SiPtrList< const SSE> SSEPool::GetNonIdenticalSSEs
    (
      const ProteinModel &PROTEIN_MODEL
    ) const
    {
      // get sses in the protein model and sort them in a set
      const util::SiPtrVector< const SSE> sses_in_model( PROTEIN_MODEL.GetSSEs());
      const storage::Set< util::SiPtr< const SSE>, SSELessThan> sses_in_model_sorted
      (
        sses_in_model.Begin(), sses_in_model.End()
      );

      // construct the list to be returned
      util::SiPtrList< const SSE> non_identical_sses;

      // take the difference of sses in pool and the protein model using the SSELessThan
      std::set_difference
      (
        m_Data.Begin(),
        m_Data.End(),
        sses_in_model_sorted.Begin(),
        sses_in_model_sorted.End(),
        std::inserter( non_identical_sses.InternalData(), non_identical_sses.InternalData().begin()),
        SSELessThan()
      );

      // return non_identical_sses
      return non_identical_sses;
    }

    //! @brief removes the overlapping SSEs with the provided PROTEIN_MODEL from pool
    //! @param PROTEIN_MODEL protein model
    //! @return SiPtrList of SSEs where there are no overlapping SSEs with the provided PROTEIN_MODEL
    util::SiPtrList< const SSE> SSEPool::GetNonOverlappingSSEs
    (
      const ProteinModel &PROTEIN_MODEL
    ) const
    {

      //TODO get Chain directly and do a find instead of iteration
      // initialize the list to be returned
      util::SiPtrList< const SSE> sse_list;

      // get the sses in the protein model
      util::SiPtrVector< const SSE> sses_from_model( PROTEIN_MODEL.GetSSEs());

      // iterate over sses in this pool
      for
      (
        const_iterator sse_itr_a( m_Data.Begin()),
          sse_itr_end_a( m_Data.End());
        sse_itr_a != sse_itr_end_a;
        ++sse_itr_a
      )
      {
        // initialize bool
        bool overlaps( false);

        // iterate over the sses in the protein model
        for
        (
          util::SiPtrVector< const SSE>::const_iterator sse_itr_b( sses_from_model.Begin()),
            sse_itr_end_b( sses_from_model.End());
          sse_itr_b != sse_itr_end_b;
          ++sse_itr_b
        )
        {
          // if these two sses overlap set the flag and break
          if( biol::DoOverlap( **sse_itr_a, **sse_itr_b))
          {
            overlaps = true; break;
          }
        }

        // if the sse did not overlap with any sse from the protein model
        if( !overlaps)
        {
          // insert this sse into the pool to be returned
          sse_list.PushBack( *sse_itr_a);
        }

      }

      // end
      return sse_list;
    }

    //! @brief return the SSEs of the given type in the pool which do not overlap with SSEs in the given model
    //! @param PROTEIN_MODEL protein model to compare to
    //! @param SSE_TYPE which SSE type to consider
    //! @return SSEs of the given type in the pool which do not overlap with SSEs in the given model
    util::SiPtrList< const SSE> SSEPool::GetNonOverlappingSSEs
    (
      const ProteinModel &PROTEIN_MODEL,
      const biol::SSType &SSE_TYPE
    ) const
    {
      //TODO get Chain directly and do a find instead of iteration
       // initialize the list to be returned
       util::SiPtrList< const SSE> sse_list;

       // get the sses in the protein model
       util::SiPtrVector< const SSE> sses_from_model( PROTEIN_MODEL.GetSSEs());

       // iterate over sses in this pool
       for
       (
         const_iterator sse_itr_a( m_Data.Begin()),
           sse_itr_end_a( m_Data.End());
         sse_itr_a != sse_itr_end_a;
         ++sse_itr_a
       )
       {
         // initialize bool
         bool overlaps( false);

         // iterate over the sses in the protein model
         for
         (
           util::SiPtrVector< const SSE>::const_iterator sse_itr_b( sses_from_model.Begin()),
             sse_itr_end_b( sses_from_model.End());
           sse_itr_b != sse_itr_end_b;
           ++sse_itr_b
         )
         {
           // if these two sses overlap set the flag and break
           if( biol::DoOverlap( **sse_itr_a, **sse_itr_b))
           {
             overlaps = true; break;
           }
         }

         // if the sse did not overlap with any sse from the protein model and is of the given type
         if( !overlaps && ( **sse_itr_a).GetType() == SSE_TYPE)
         {
           // insert this sse into the pool to be returned
           sse_list.PushBack( *sse_itr_a);
         }
       }

       return sse_list;
    }

    //! @brief returns overlapping SSEs in the pool with the SSEs from provided SSE_DOMAIN
    //! @param SSE_DOMAIN domain
    //! @param EXCLUDE_IDENTICAL boolean to decide whether SSEs from domain should be included in the return
    //! @param EXCLUDE_DIFFERENT_SSTYPE whether to exclude overlapping SSEs that differ in SSType
    //! @return SiPtrList of SSEs which overlap with SSEs with the provided SSE_DOMAIN
    util::SiPtrList< const SSE> SSEPool::GetOverlappingSSEs
    (
      const DomainInterface &SSE_DOMAIN,
      const bool EXCLUDE_IDENTICAL,
      const bool EXCLUDE_DIFFERENT_SSTYPE
    ) const
    {
      // initialize the list to be returned
      util::SiPtrList< const SSE> sse_list;

      // get the sses in the protein model
      util::SiPtrVector< const SSE> sses_from_model( SSE_DOMAIN.GetSSEs());

      // iterate over sses in this pool
      for
      (
        const_iterator sse_itr_a( m_Data.Begin()),
          sse_itr_end_a( m_Data.End());
        sse_itr_a != sse_itr_end_a;
        ++sse_itr_a
      )
      {
        // iterate over the sses in the protein model
        for
        (
          util::SiPtrVector< const SSE>::const_iterator sse_itr_b( sses_from_model.Begin()),
            sse_itr_end_b( sses_from_model.End());
          sse_itr_b != sse_itr_end_b;
          ++sse_itr_b
        )
        {
          // if these two sses overlap then
          if( biol::DoOverlap( **sse_itr_a, **sse_itr_b))
          {
            // if the EXCLUDE_IDENTICAL flag is set and they are same continue
            if( EXCLUDE_IDENTICAL && **sse_itr_a == **sse_itr_b)
            {
              continue;
            }

            // if exclude different SSType is given and the types actually differ
            if( EXCLUDE_DIFFERENT_SSTYPE && ( *sse_itr_a)->GetType() != ( *sse_itr_b)->GetType())
            {
              continue;
            }

            // insert this sse to sse_list
            sse_list.PushBack( *sse_itr_a);

            // and break
            break;
          }
        }
      }

      // end
      return sse_list;
    }

    //! @brief returns overlapping SSEs in the pool with the provided TARGET_SSE
    //! @param TARGET_SSE SSE of interest
    //! @param EXCLUDE_IDENTICAL boolean to decide whether SSEs from ProteinModel should be included in the return
    //! @param EXCLUDE_DIFFERENT_SSTYPE whether to exclude overlapping SSEs that differ in SSType
    //! @return SiPtrList of SSEs which overlap with TARGET_SSE
    util::SiPtrList< const SSE> SSEPool::GetOverlappingSSEs
    (
      const SSE &TARGET_SSE,
      const bool EXCLUDE_IDENTICAL,
      const bool EXCLUDE_DIFFERENT_SSTYPE
    ) const
    {
      // initialize the list to be returned
      util::SiPtrList< const SSE> sse_list;

      // iterate over sses in this pool
      for
      (
        const_iterator sse_itr( m_Data.Begin()),
          sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if exclude different SSType is given and the types actually differ
        if( EXCLUDE_DIFFERENT_SSTYPE && ( *sse_itr)->GetType() != TARGET_SSE.GetType())
        {
          continue;
        }

        // if the EXCLUDE_IDENTICAL flag is set and they are same continue
        if( EXCLUDE_IDENTICAL && **sse_itr == TARGET_SSE)
        {
          continue;
        }

        // if these two sses overlap then
        if( biol::DoOverlap( **sse_itr, TARGET_SSE))
        {
          // insert this sse to sse_list
          sse_list.PushBack( *sse_itr);
        }
      }

      // end
      return sse_list;
    }

    //! @brief converts the data in the set from SSELessThan to SSELessThanNoOverlap
    //! @return SSELessThanNoOverlap set
    storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> SSEPool::GetRandomNonOverlappingSet() const
    {
      // copy the initial SSEs in the set
      storage::Set< util::ShPtr< SSE>, SSELessThan> initial_set( m_Data);

      // initialize the set to be returned
      storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> non_overlapping_set;

      // loop until the initial set is empty
      while( !initial_set.IsEmpty())
      {
        // get a random iterator on the set
        storage::Set< util::ShPtr< SSE>, SSELessThan>::iterator sse_itr
        (
          random::GetGlobalRandom().Iterator( initial_set.Begin(), initial_set.End(), initial_set.GetSize())
        );

        // insert the sse into the non overlapping set (if possible)
        non_overlapping_set.Insert( **sse_itr);

        // remove the sse from the initial set
        initial_set.RemoveElement( sse_itr);
      }

      // end
      return non_overlapping_set;
    }

    //! @brief calculates the number of helices and strands in the pool
    //!        this will equal to actual counts if it's non overlapping pool
    //!        if overlapping, it will be average numbers that lead to a complete model with non-overlapping SSEs
    //! @return average number of helices and strands expected in a complete model from this pool
    storage::Pair< double, double> SSEPool::CalculateAverageHelixStrandCounts() const
    {
      // if the SSEs are not overlapping
      if( !IsOverlapping())
      {
        // then return the ratio directly
        return storage::Pair< double, double>
        (
          GetSSEs( biol::GetSSTypes().HELIX).GetSize(),
          GetSSEs( biol::GetSSTypes().STRAND).GetSize()
        );
      }

      // initialize counts
      storage::Pair< double, double> helix_strand_counts( 0.0, 0.0);

      // initialize the number of repeats
      const size_t nr_repeats( 10);

      // if overlapping then we have to get few random non-overlapping sets to calculate the expected average number
      for( size_t i = 0; i < nr_repeats; ++i)
      {
        // new overlapping set
        const storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> non_overlapping_set
        (
          GetRandomNonOverlappingSet()
        );

        // create a new non overlapping pool
        const SSEPool this_pool
        (
          util::SiPtrVector< const SSE>( non_overlapping_set.Begin(), non_overlapping_set.End())
        );

        // sum up the numbers
        helix_strand_counts.First() += ( this_pool.GetSSEs( biol::GetSSTypes().HELIX).GetSize());
        helix_strand_counts.Second() += ( this_pool.GetSSEs( biol::GetSSTypes().STRAND).GetSize());
      }

      // normalize the number
      helix_strand_counts.First() /= nr_repeats;
      helix_strand_counts.Second() /= nr_repeats;

      // end
      return helix_strand_counts;
    }

    //! @brief calculate an estimate of the helix to strand ratio and return it
    //! @return helix to strand ratio ( 0:1 if only strands, 1:0 if only helices)
    storage::Pair< double, double> SSEPool::CalculateHelixToStrandRatio() const
    {
      // get the number of strands and number of helices
      const double nr_helices( GetSSEs( biol::GetSSTypes().HELIX).GetSize());
      const double nr_strands( GetSSEs( biol::GetSSTypes().STRAND).GetSize());

      // make sure there are at least one helix or strand in the pool
      BCL_Assert
      (
        nr_helices + nr_strands > 0, "The pool needs to have at least one helix or strand to calculate ratio!"
      );

      // if only helices
      if( nr_helices > 0 && nr_strands == 0)
      {
        return storage::Pair< double, double>( 1.0, 0.0);
      }
      // if only strands
      if( nr_helices == 0 && nr_strands > 0)
      {
        return storage::Pair< double, double>( 0.0, 1.0);
      }

      // if the loop is not overlapping
      if( !IsOverlapping())
      {
        // then return the ratio directly
        return storage::Pair< double, double>( nr_helices / GetSize(), nr_strands / GetSize());
      }

      // get the average counts for helices and strands
      storage::Pair< double, double> helix_strand_counts( CalculateAverageHelixStrandCounts());

      // normalize by the total counts
      const double total_nr_sses( helix_strand_counts.First() + helix_strand_counts.Second());
      helix_strand_counts.First() /= total_nr_sses;
      helix_strand_counts.Second() /= total_nr_sses;

      // end
      return helix_strand_counts;
    }

    //! @brief number of sses above given length
    //! @param MIN_SIZE_HELIX
    //! @return nr strands size > MIN_SIZE_STRAND + nr helices size > MIN_HELIX_SIZE
    double SSEPool::CountLongNonOverlappingSSEs( const size_t MIN_SIZE_STRAND, const size_t MIN_SIZE_HELIX) const
    {
      double count( 0);

      const size_t nr_repeats( IsOverlapping() ? 10 : 1);

      // if overlapping then we have to get few random non-overlapping sets to calculate the expected average number
      for( size_t i = 0; i < nr_repeats; ++i)
      {
        // new overlapping set
        const storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> non_overlapping_set
        (
          GetRandomNonOverlappingSet()
        );

        // iterate over sses
        for
        (
            storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap>::const_iterator sse_itr( non_overlapping_set.Begin()), sse_itr_end( non_overlapping_set.End());
          sse_itr != sse_itr_end;
          ++sse_itr
        )
        {
          if
          (
               ( ( *sse_itr)->GetType() == biol::GetSSTypes().STRAND && ( *sse_itr)->GetSize() > MIN_SIZE_STRAND)
            || ( ( *sse_itr)->GetType() == biol::GetSSTypes().HELIX && ( *sse_itr)->GetSize() > MIN_SIZE_HELIX)
          )
          {
            count += 1.0;
          }
        }
      }

      // end
      return count / nr_repeats;
    }

    //! @brief prune the pool from sses that are not in the given map or do not have the minimum length
    //! @param MIN_SSE_SIZE_MAP map containing the desired ss types and their minimum length
    void SSEPool::Prune( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE_MAP)
    {
      // new set of sses
      storage::Set< util::ShPtr< SSE>, SSELessThan> new_data;

      // iterate over sses
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThan>::const_iterator sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        storage::Map< biol::SSType, size_t>::const_iterator min_itr( MIN_SSE_SIZE_MAP.Find( ( *sse_itr)->GetType()));

        // sstype in map?
        if( min_itr == MIN_SSE_SIZE_MAP.End())
        {
          continue;
        }

        // sse has minimal size
        if( ( *sse_itr)->GetSize() < min_itr->second)
        {
          continue;
        }

        // insert into new data
        new_data.Insert( *sse_itr);
      }

      // update data
      m_Data = new_data;
    }

    //! @brief chops the SSEs in of the type in the map into chunks of the minimal size given in the map
    //! @param MIN_SSE_SIZE_MAP map containing the desired ss types and their minimum length
    void SSEPool::ChopSSEs( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE_MAP)
    {
      // make a copy of the pool
      SSEPool new_pool( *this);

      // iterate over SSEs in the pool
      for( const_iterator sse_itr( Begin()), sse_itr_end( End()); sse_itr != sse_itr_end; ++sse_itr)
      {
        // cannot chop if size is smaller than 3
        if( ( *sse_itr)->GetSize() < 3)
        {
          new_pool.Insert( *sse_itr);
          continue;
        }

        // check if that type is in the map
        const storage::Map< biol::SSType, size_t>::const_iterator ss_itr( MIN_SSE_SIZE_MAP.Find( ( *sse_itr)->GetType()));

        if( ss_itr == MIN_SSE_SIZE_MAP.End())
        {
          new_pool.Insert( *sse_itr);
          continue;
        }

        // store the set of chopped sses
        const storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> chopped_sses
        (
          // chop sse into two parts that are at least m_MinSSELengths in length
          ( *sse_itr)->Chop( std::max( ss_itr->second, ( *sse_itr)->GetSize() / 2 - 1))
        );

        // chop up this sse and insert the resultant set of sses into SSEPool
        new_pool.InsertElements( chopped_sses.Begin(), chopped_sses.End());
      }

      // update data
      m_Data = new_pool.m_Data;
    }

    //! @brief join adjacent sses if the adjacent sse is shorter than the given sse min size and has the same type, starting from the outside of a sequence of adjacent sses
    //! @param MIN_SSE_SIZE_MAP map containing the desired ss types and their minimum length
    //! @return true if at least one join was performed - one call might not perform all possible joins and it can be necessary to call that function multiple timess
    bool SSEPool::Join( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE_MAP)
    {
      // nothing to do for empty data
      if( m_Data.IsEmpty())
      {
        return false;
      }

      storage::Set< util::ShPtr< SSE>, SSELessThan> new_data;

      bool joined( false);

      // iterate over all sses
      for( const_iterator itr( m_Data.Begin()), itr_end( m_Data.End()); itr != itr_end;)
      {
        const SSE &current_sse( **itr);
        ++itr;

        // is the current sse long enough and should be joined
        const storage::Map< biol::SSType, size_t>::const_iterator find_itr( MIN_SSE_SIZE_MAP.Find( current_sse.GetType()));

        // if this was the last sse
        // or it is of type not to be considered for joining
        // or it is the sse before an sse with different type
        // or the following sse is not adjacent
        // insert to new data and move on
        if
        (
             itr == itr_end
          || find_itr == MIN_SSE_SIZE_MAP.End()
          || current_sse.GetType() != ( *itr)->GetType()
          || !current_sse.DoesPrecede( **itr)
        )
        {
          new_data.Insert( util::ShPtr< SSE>( current_sse.Clone()));
          continue;
        }

        // if either current or next sse is too short, merge them
        if( current_sse.GetSize() < find_itr->second || ( *itr)->GetSize() < find_itr->second)
        {
          joined = true;
          util::ShPtr< SSE> sp_sse( current_sse.Clone());
          sp_sse->AppendSequence( **itr, false);
          new_data.Insert( sp_sse);
          BCL_MessageDbg
          (
            "joining sses: " + current_sse.GetIdentification() + " " + ( *itr)->GetIdentification() +
            " into: " + sp_sse->GetIdentification()
          );
          ++itr;
        }
        else
        {
          new_data.Insert( util::ShPtr< SSE>( current_sse.Clone()));
        }
      }

      // update data
      m_Data = new_data;

      // return if something was joined
      return joined;
    }

    //! @brief separate adjacent sses of identical type, by 2 * nr residues, but only if the resulting sses still have the desired size
    //! @param MIN_SSE_SIZE_MAP map containing the desired ss types and their minimum length
    //! @param NR_RESIDUES number of residues
    //! @return true if at least one separation was performed
    bool SSEPool::Separate( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE_MAP, const size_t NR_RESIDUES)
    {
      // nothing to do for empty data
      if( m_Data.IsEmpty() || NR_RESIDUES == 0)
      {
        return false;
      }

      storage::Set< util::ShPtr< SSE>, SSELessThan> new_data;
      const_iterator itr( m_Data.Begin()), itr_end( m_Data.End());
      util::ShPtr< SSE> sp_previous( *itr);
      ++itr;
      bool separated( false);

      // iterate over all sses
      for( ; itr != itr_end; ++itr)
      {
        util::ShPtr< SSE> sp_current( *itr);

        // are they of different type or do not precede each other
        if
        (
             !sp_previous->GetType()->IsStructured() || !sp_current->GetType()->IsStructured()
          || !sp_previous->DoesPrecede( *sp_current)
        )
        {
          // insert the previous, update the previous and continue
          new_data.Insert( sp_previous.HardCopy());
          sp_previous = sp_current;
          continue;
        }

        // sse type considered and the min size
        const storage::Map< biol::SSType, size_t>::const_iterator find_itr_prev( MIN_SSE_SIZE_MAP.Find( sp_previous->GetType()));
        const storage::Map< biol::SSType, size_t>::const_iterator find_itr_cur( MIN_SSE_SIZE_MAP.Find( sp_current->GetType()));

        if( find_itr_prev == MIN_SSE_SIZE_MAP.End() || find_itr_prev->second == 0)
        {
          // insert the previous and move on
          new_data.Insert( sp_previous.HardCopy());
          sp_previous = sp_current;
          continue;
        }

        biol::AASequence coil_seq;

        // sse type is considered
        // remove residues if remaining length permits
        if( sp_previous->GetSize() >= find_itr_prev->second + NR_RESIDUES)
        {
          separated = true;
          coil_seq.AppendSequence( sp_previous->SubSequence( sp_previous->GetSize() - NR_RESIDUES, NR_RESIDUES));
          sp_previous = util::ShPtr< SSE>( new SSE( sp_previous->SubSequence( 0, sp_previous->GetSize() - NR_RESIDUES), sp_previous->GetType()));
        }

        if( sp_current->GetSize() >= find_itr_cur->second + NR_RESIDUES)
        {
          separated = true;
          coil_seq.AppendSequence( sp_current->SubSequence( 0, NR_RESIDUES));
          sp_current = util::ShPtr< SSE>( new SSE( sp_current->SubSequence( NR_RESIDUES, sp_current->GetSize() - NR_RESIDUES), sp_current->GetType()));
        }

        // insert previous, coil and update
        new_data.Insert( sp_previous.HardCopy());
        if( coil_seq.GetSize() > 0)
        {
          new_data.Insert( util::ShPtr< SSE>( new SSE( coil_seq, biol::GetSSTypes().COIL)));
        }
        sp_previous = sp_current;
      }

      // insert the last element
      new_data.Insert( sp_previous.HardCopy());
      m_Data = new_data;

      // end
      return separated;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read SSEPool from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPool::Read( std::istream &ISTREAM)
    {
      // read member
      io::Serialize::Read( m_Data, ISTREAM);

      //end
      return ISTREAM;
    }

    //! @brief read SSEPool from std::istream from a specially formatted pool file
    //! @param ISTREAM input stream
    //! @param PROTEIN_MODEL ProteinModel which SSEs belong to
    //! @param MIN_HELIX_LENGTH Minimal length for a HELIX to be added to the pool
    //! @param MIN_STRAND_LENGTH Minimal length for a STRAND to be added to the pool
    //! @return istream which was read from
    std::istream &SSEPool::ReadSSEPool
    (
      std::istream &ISTREAM,
      const ProteinModel &PROTEIN_MODEL,
      const size_t MIN_HELIX_LENGTH,
      const size_t MIN_STRAND_LENGTH
    )
    {
      m_Data.Reset();

      // read the identifier
      util::ObjectInterface::ReadIdentifier( ISTREAM);

      // initialize buffer
      std::string buffer;

      // while reading lines from STREAM into buffer and EOF is not hit
      while( !ISTREAM.eof() && std::getline( ISTREAM, buffer))
      {
        // if buffer is empty break
        if( buffer.empty())
        {
          break;
        }
        pdb::LineType line_type( util::TrimString( buffer.substr( 0, 6)));

        // if the line type read is END, then break
        if( line_type == pdb::GetLineTypes().END)
        {
          break;
        }
        // initialize pdb line from buffer
        pdb::Line current_line( buffer);

        // if helix
        if( line_type == pdb::GetLineTypes().HELIX)
        {
          // find the chain with matching chain id
          const util::SiPtr< const Chain> this_chain
          (
            PROTEIN_MODEL.GetChain( current_line.GetChar( pdb::GetEntryTypes().HELIXChainID_Initial))
          );

          // assert the chain is found
          BCL_Assert
          (
            this_chain.IsDefined(),
            "Unable to find the chain with id " +
              util::Format()( current_line.GetChar( pdb::GetEntryTypes().HELIXChainID_Initial))
          );

          const size_t seq_id_start
          (
            current_line.GetNumericalValue< size_t>( pdb::GetEntryTypes().HELIXSequenceID_Initial)
          );
          const size_t seq_id_end
          (
            current_line.GetNumericalValue< size_t>( pdb::GetEntryTypes().HELIXSequenceID_Terminal)
          );

          // if this sse is not long enough skip
          if( seq_id_end - seq_id_start + 1 < MIN_HELIX_LENGTH)
          {
            continue;
          }

          // create sse from subsequence
          util::ShPtr< SSE> this_sse
          (
            new SSE
            (
              this_chain->GetSequence()->SubSequence
              (
                seq_id_start - 1,
                seq_id_end - seq_id_start + 1
              ),
              biol::GetSSTypes().HELIX
            )
          );

          // check that the seqids and names of sses in the pool and the created one is correct
          BCL_Assert
          (
            size_t( this_sse->GetFirstAA()->GetSeqID()) == seq_id_start &&
            size_t( this_sse->GetLastAA()->GetSeqID()) == seq_id_end &&
            this_sse->GetFirstAA()->GetType()->GetParentTypeString() ==
              biol::GetAATypes().AATypeFromThreeLetterCode
              (
                current_line.GetString( pdb::GetEntryTypes().HELIXResidueName_Initial)
              )->GetParentTypeString() &&
            this_sse->GetLastAA()->GetType()->GetParentTypeString() ==
              biol::GetAATypes().AATypeFromThreeLetterCode
              (
                current_line.GetString( pdb::GetEntryTypes().HELIXResidueName_Terminal)
              )->GetParentTypeString(),
            "The seqids and residue names do not match for pool and protein_model " + current_line.GetString() +
            " for SSE " + this_sse->GetType().GetName() + " " + this_sse->GetChainID() + "|" +
              util::Format()( this_sse->GetFirstAA()->GetSeqID()) + "|" +
              util::Format()( this_sse->GetFirstAA()->GetType()->GetParentTypeString()) + "|" +
              util::Format()( this_sse->GetLastAA()->GetSeqID()) + " " +
              util::Format()( this_sse->GetLastAA()->GetType()->GetParentTypeString())
          );

          // initialize sse coordinates to origin and idealize
          this_sse->SetToIdealConformationAtOrigin();

          // insert this sse into the set
          if( !m_Data.Insert( this_sse).second)
          {
            BCL_MessageCrt( "unable to insert sse:" + current_line.GetString());
          }
        }
        // else if strand
        else if( line_type == pdb::GetLineTypes().SHEET)
        {
          // find the chain with matching chain id
          const util::SiPtr< const Chain> this_chain
          (
            PROTEIN_MODEL.GetChain( current_line.GetChar( pdb::GetEntryTypes().SHEETChainID_Initial))
          );

          // assert the chain is found
          BCL_Assert
          (
            this_chain.IsDefined(),
            "Unable to find the chain with id " +
              util::Format()( current_line.GetChar( pdb::GetEntryTypes().SHEETChainID_Initial))
          );

          const size_t seq_id_start
          (
            current_line.GetNumericalValue< size_t>( pdb::GetEntryTypes().SHEETSequenceID_Initial)
          );
          const size_t seq_id_end
          (
            current_line.GetNumericalValue< size_t>( pdb::GetEntryTypes().SHEETSequenceID_Terminal)
          );

          // if this sse is not long enough skip
          if( seq_id_end - seq_id_start + 1 < MIN_STRAND_LENGTH)
          {
            continue;
          }

          // create sse from subsequence
          util::ShPtr< SSE> this_sse
          (
            new SSE
            (
              this_chain->GetSequence()->SubSequence
              (
                seq_id_start - 1,
                seq_id_end - seq_id_start + 1
              ),
              biol::GetSSTypes().STRAND
            )
          );

          // check that the seqids and names of sses in the pool and the created one is correct
//          BCL_Assert
//          (
//            size_t( this_sse->GetFirstAA()->GetSeqID()) == seq_id_start &&
//            size_t( this_sse->GetLastAA()->GetSeqID()) == seq_id_end &&
//            this_sse->GetFirstAA()->GetType()->GetParentTypeString() ==
//              biol::GetAATypes().AATypeFromThreeLetterCode
//              (
//                current_line.GetString( pdb::GetEntryTypes().SHEETResidueName_Initial)
//              )->GetParentTypeString() &&
//            this_sse->GetLastAA()->GetType()->GetParentTypeString() ==
//              biol::GetAATypes().AATypeFromThreeLetterCode
//              (
//                current_line.GetString( pdb::GetEntryTypes().SHEETResidueName_Terminal)
//              )->GetParentTypeString(),
//              "The seqids and residue names do not match for pool and protein_model " + current_line.GetString() +
//              " for SSE " + this_sse->GetType().GetName() + " " + this_sse->GetChainID() + " " +
//                util::Format()( this_sse->GetFirstAA()->GetSeqID()) + " " +
//                util::Format()( this_sse->GetFirstAA()->GetType()->GetParentTypeString()) + " " +
//                util::Format()( this_sse->GetLastAA()->GetSeqID()) + " " +
//                util::Format()( this_sse->GetLastAA()->GetType()->GetParentTypeString())
//          );
          BCL_Assert
          (
            size_t( this_sse->GetFirstAA()->GetSeqID()) == seq_id_start,
              "The seqids start end " + current_line.GetString() +
              " for SSE " + this_sse->GetType().GetName() + " " + this_sse->GetChainID() + " " +
                util::Format()( this_sse->GetFirstAA()->GetSeqID()) + " " +
                util::Format()( this_sse->GetFirstAA()->GetType()->GetParentTypeString()) + " " +
                util::Format()( this_sse->GetLastAA()->GetSeqID()) + " " +
                util::Format()( this_sse->GetLastAA()->GetType()->GetParentTypeString())
          );

          BCL_Assert
          (

            size_t( this_sse->GetLastAA()->GetSeqID()) == seq_id_end
            ,
              "The seqids end " + current_line.GetString() +
              " for SSE " + this_sse->GetType().GetName() + " " + this_sse->GetChainID() + " " +
                util::Format()( this_sse->GetFirstAA()->GetSeqID()) + " " +
                util::Format()( this_sse->GetFirstAA()->GetType()->GetParentTypeString()) + " " +
                util::Format()( this_sse->GetLastAA()->GetSeqID()) + " " +
                util::Format()( this_sse->GetLastAA()->GetType()->GetParentTypeString())
          );
          BCL_Assert
          (

            this_sse->GetFirstAA()->GetType()->GetParentTypeString() ==
              biol::GetAATypes().AATypeFromThreeLetterCode
              (
                current_line.GetString( pdb::GetEntryTypes().SHEETResidueName_Initial)
              )->GetParentTypeString()
            ,
              "The aa type strings " + current_line.GetString() +
              " for SSE " + this_sse->GetType().GetName() + " " + this_sse->GetChainID() + " " +
                util::Format()( this_sse->GetFirstAA()->GetSeqID()) + " " +
                util::Format()( this_sse->GetFirstAA()->GetType()->GetParentTypeString()) + " " +
                util::Format()( this_sse->GetLastAA()->GetSeqID()) + " " +
                util::Format()( this_sse->GetLastAA()->GetType()->GetParentTypeString())
          );

          BCL_Assert
          (
            this_sse->GetLastAA()->GetType()->GetParentTypeString() ==
              biol::GetAATypes().AATypeFromThreeLetterCode
              (
                current_line.GetString( pdb::GetEntryTypes().SHEETResidueName_Terminal)
              )->GetParentTypeString(),
              "The aa type last " + current_line.GetString() + "|" + biol::GetAATypes().AATypeFromThreeLetterCode
              (
                current_line.GetString( pdb::GetEntryTypes().SHEETResidueName_Terminal)
              )->GetParentTypeString() +
              "| for SSE " + this_sse->GetType().GetName() + " " + this_sse->GetChainID() + " " +
                util::Format()( this_sse->GetFirstAA()->GetSeqID()) + " " +
                util::Format()( this_sse->GetFirstAA()->GetType()->GetParentTypeString()) + " " +
                util::Format()( this_sse->GetLastAA()->GetSeqID()) + " " +
                util::Format()( this_sse->GetLastAA()->GetType()->GetParentTypeString())
          );
          // initialize sse coordinates to origin and idealize
          this_sse->SetToIdealConformationAtOrigin();

          // insert this sse into the set
          if( !m_Data.Insert( this_sse).second)
          {
            BCL_MessageCrt( "unable to insert sse:" + current_line.GetString());
          }
        }

        // if an unrecognized line type is supplied, break
        else
        {
          BCL_MessageCrt
          (
            "The following line type is not a helix or sheet " + line_type.GetName()
          );
          break;
        };
      } // while stream

      // end
      return ISTREAM;
    }

    //! @brief read SSEPool from std::istream from a specially formatted pool file
    //! @param ISTREAM input stream
    //! @param SEQUENCE aa sequence to which SSEs belong to
    //! @param MIN_HELIX_LENGTH Minimal length for a HELIX to be added to the pool
    //! @param MIN_STRAND_LENGTH Minimal length for a STRAND to be added to the pool
    //! @return istream which was read from
    std::istream &SSEPool::ReadSSEPool
    (
      std::istream &ISTREAM,
      const biol::AASequence &SEQUENCE,
      const size_t MIN_HELIX_LENGTH,
      const size_t MIN_STRAND_LENGTH
    )
    {
      // read the identifier
      util::ObjectInterface::ReadIdentifier( ISTREAM);

      // initialize buffer
      std::string buffer;

      // while reading lines from STREAM into buffer and EOF is not hit
      while( !ISTREAM.eof() && std::getline( ISTREAM, buffer))
      {
        // if buffer is empty break
        if( buffer.empty())
        {
          break;
        }
        pdb::LineType line_type( util::TrimString( buffer.substr( 0, 6)));

        // if the line type read is END, then break
        if( line_type == pdb::GetLineTypes().END)
        {
          break;
        }
        // initialize pdb line from buffer
        pdb::Line current_line( buffer);

        // if helix
        if( line_type == pdb::GetLineTypes().HELIX)
        {
          // skip if sequence chain id does not agree
          if( SEQUENCE.GetChainID() != current_line.GetChar( pdb::GetEntryTypes().HELIXChainID_Initial))
          {
            continue;
          }

          const size_t seq_id_start
          (
            current_line.GetNumericalValue< size_t>( pdb::GetEntryTypes().HELIXSequenceID_Initial)
          );
          const size_t seq_id_end
          (
            current_line.GetNumericalValue< size_t>( pdb::GetEntryTypes().HELIXSequenceID_Terminal)
          );

          // if this sse is not long enough skip
          if( seq_id_end - seq_id_start + 1 < MIN_HELIX_LENGTH)
          {
            continue;
          }

          // create sse from subsequence
          util::ShPtr< SSE> this_sse
          (
            new SSE
            (
              SEQUENCE.SubSequence
              (
                seq_id_start - 1,
                seq_id_end - seq_id_start + 1
              ),
              biol::GetSSTypes().HELIX
            )
          );

          // check that the seqids and names of sses in the pool and the created one is correct
          BCL_Assert
          (
            size_t( this_sse->GetFirstAA()->GetSeqID()) == seq_id_start &&
            size_t( this_sse->GetLastAA()->GetSeqID()) == seq_id_end &&
            this_sse->GetFirstAA()->GetType()->GetParentType() ==
              biol::GetAATypes().AATypeFromThreeLetterCode
              (
                current_line.GetString( pdb::GetEntryTypes().HELIXResidueName_Initial)
              )->GetParentType() &&
            this_sse->GetLastAA()->GetType()->GetParentType() ==
              biol::GetAATypes().AATypeFromThreeLetterCode
              (
                current_line.GetString( pdb::GetEntryTypes().HELIXResidueName_Terminal)
              )->GetParentType(),
            "The seqids and residue names do not match for pool and protein_model " + current_line.GetString() +
            " for SSE " + this_sse->GetIdentification()
          );

          // initialize sse coordinates to origin and idealize
          this_sse->SetToIdealConformationAtOrigin();

          // insert this sse into the set
          if( !m_Data.Insert( this_sse).second)
          {
            BCL_MessageCrt( "unable to insert sse:" + current_line.GetString());
          }
        }
        // else if strand
        else if( line_type == pdb::GetLineTypes().SHEET)
        {
          // find the chain with matching chain id
          if( SEQUENCE.GetChainID() != current_line.GetChar( pdb::GetEntryTypes().SHEETChainID_Initial))
          {
            continue;
          }

          const size_t seq_id_start
          (
            current_line.GetNumericalValue< size_t>( pdb::GetEntryTypes().SHEETSequenceID_Initial)
          );
          const size_t seq_id_end
          (
            current_line.GetNumericalValue< size_t>( pdb::GetEntryTypes().SHEETSequenceID_Terminal)
          );

          // if this sse is not long enough skip
          if( seq_id_end - seq_id_start + 1 < MIN_STRAND_LENGTH)
          {
            continue;
          }

          // create sse from subsequence
          util::ShPtr< SSE> this_sse
          (
            new SSE
            (
              SEQUENCE.SubSequence
              (
                seq_id_start - 1,
                seq_id_end - seq_id_start + 1
              ),
              biol::GetSSTypes().STRAND
            )
          );

          // check that the seqids and names of sses in the pool and the created one is correct
          BCL_Assert
          (
            size_t( this_sse->GetFirstAA()->GetSeqID()) == seq_id_start &&
            size_t( this_sse->GetLastAA()->GetSeqID()) == seq_id_end &&
            this_sse->GetFirstAA()->GetType()->GetParentType() ==
              biol::GetAATypes().AATypeFromThreeLetterCode
              (
                current_line.GetString( pdb::GetEntryTypes().SHEETResidueName_Initial)
              )->GetParentType() &&
            this_sse->GetLastAA()->GetType()->GetParentType() ==
              biol::GetAATypes().AATypeFromThreeLetterCode
              (
                current_line.GetString( pdb::GetEntryTypes().SHEETResidueName_Terminal)
              )->GetParentType(),
              "The seqids and residue names do not match for pool and protein_model " + current_line.GetString() +
              " for SSE " + this_sse->GetIdentification()
          );

          // initialize sse coordinates to origin and idealize
          this_sse->SetToIdealConformationAtOrigin();

          // insert this sse into the set
          if( !m_Data.Insert( this_sse).second)
          {
            BCL_MessageCrt( "unable to insert sse:" + current_line.GetString());
          }
        }

        // if an unrecognized line type is supplied, break
        else
        {
          BCL_MessageCrt
          (
            "The following line type is not a helix or sheet " + line_type.GetName()
          );
          break;
        };
      } // while stream

      // end
      return ISTREAM;
    }

    //! @brief ReadSSEPoolInformation reads the pool file and gives the information it contains
    //!        This function does not create an SSE pool.
    //! @param POOL_FILENAME is the name and path of the file which contains the SSE pool
    //! @return returns a storage::Vector of the pdb::Lines which are contained in the SSE pool
    storage::Vector< pdb::Line> SSEPool::ReadSSEPoolInformation
    (
      const std::string &POOL_FILENAME
    )
    {
      // create io::IFStream "read" to be used to read in "POOL_FILENAME"
      io::IFStream read;

      // open "read" and bind it to "POOL_FILENAME"
      io::File::MustOpenIFStream( read, POOL_FILENAME.c_str());

      // read the identifier
      SSEPool().ReadIdentifier( read);

      // create std::string "buffer" which will be used to temporarily hold each line as it is read in
      std::string buffer;

      // create storage::Vector< pdb::Line> "pdb_lines" which will be used to hold all the pdb::Lines in the pool file
      storage::Vector< pdb::Line> pdb_lines;

      // get lines from "read" and put into "buffer" while EOF is not hit and a line can be gotten
      while( !read.eof() && std::getline( read, buffer))
      {
        // if buffer is empty break
        if( buffer.empty())
        {
          break;
        }

        // insert the current pool line contained in "buffer" into "pdb_lines"
        pdb_lines.PushBack( pdb::Line( buffer));
      }

      // close and clear the stream
      io::File::CloseClearFStream( read);

      // return the vector of pdb lines
      return pdb_lines;
    }

    //! @brief GetChainsRepresented obtains a storage::Set of all the chain ids in a pool file
    //!        This function does not create an SSE pool.
    //! @param POOL_FILENAME is the name and path of the file which contains the SSE pool
    //! @return returns a storage::Set< char> which has all the chain ids contained in the SSE pool
    storage::Set< char> SSEPool::GetChainsRepresented
    (
      const std::string &POOL_FILENAME
    )
    {
      // create vector of pdb::Lines "pdb_lines" and initialize with the lines in "POOL_FILENAME"
      const storage::Vector< pdb::Line> pdb_lines( ReadSSEPoolInformation( POOL_FILENAME));

      // create Set "chain_ids" to hold the chain ids that are in "pdb_lines"
      storage::Set< char> chain_ids;

      // iterate through "pdb_lines" to get the chain ids
      for
      (
        storage::Vector< pdb::Line>::const_iterator line_itr( pdb_lines.Begin()), line_itr_end( pdb_lines.End());
        line_itr != line_itr_end;
        ++line_itr
      )
      {
        // true if pdb::Line currently denoted by "line_itr" is of type HELIX
        if( line_itr->GetType() == pdb::GetLineTypes().HELIX)
        {
          // create const char "helix_id_initial" and "helix_id_terminal" initialize with chain ids from "line_itr"
          const char helix_id_initial( line_itr->GetChar( pdb::GetEntryTypes().HELIXChainID_Initial)),
                     helix_id_terminal( line_itr->GetChar( pdb::GetEntryTypes().HELIXChainID_Terminal));

          // make sure that the helix is contained within a single chain
          BCL_Assert
          (
            helix_id_initial == helix_id_terminal,
            "Initial helix id " + util::Format()( helix_id_initial) + " does not match terminal helix id " +
            util::Format()( helix_id_terminal)
          );

          // insert "strand_id_initial" into "chain_ids"
          chain_ids.Insert( helix_id_initial);
        }
        // true if pdb::Line currently denoted by "line_itr" is of type STRAND
        else if( line_itr->GetType() == pdb::GetLineTypes().SHEET)
        {
          // create const char "strand_id_initial" and "strand_id_terminal" initialize with chain ids from "line_itr"
          const char strand_id_initial( line_itr->GetChar( pdb::GetEntryTypes().SHEETChainID_Initial)),
                     strand_id_terminal( line_itr->GetChar( pdb::GetEntryTypes().SHEETChainID_Terminal));

          // make sure that the sheet is contained within a single chain
          BCL_Assert
          (
            strand_id_initial == strand_id_terminal,
            "Initial strand id " + util::Format()( strand_id_initial) + " does not match terminal stand id " +
            util::Format()( strand_id_terminal)
          );

          // insert "strand_id_initial" into "chain_ids"
          chain_ids.Insert( strand_id_initial);
        }
      }

      // return "chain_ids" which has the chain ids in "pdb_lines"
      return chain_ids;
    }

    //! @brief write to SSEPool std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT indentation
    //! @return output stream which was written to
    std::ostream &SSEPool::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write member
      io::Serialize::Write( m_Data, OSTREAM, INDENT);

      //end
      return OSTREAM;
    }

    //! @brief write SSEPool to std::ostream
    //! @param OSTREAM output stream to write to
    //! @return output stream which was written to
    std::ostream &SSEPool::WriteSSEPool( std::ostream &OSTREAM) const
    {
      // output identifier first
      util::ObjectInterface::WriteIdentifier( OSTREAM, 0);

      // serial of sses when written
      size_t sse_serial( 1);

      // iterate over the pool
      for
      (
        const_iterator sse_itr( m_Data.Begin()), sse_itr_end( m_Data.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // Write to pdb line
        const util::ShPtr< pdb::Line> this_line( pdb::Factory::WriteSSEDefinitionToLine( **sse_itr, sse_serial));

        if( this_line.IsDefined())
        {
          // write to stream
          OSTREAM << this_line->GetString() << '\n';

          // increment sse serial
          ++sse_serial;
        }
        else
        {
          BCL_MessageDbg( "did not write SSE to pool: " + ( *sse_itr)->GetIdentification());
        }
      }

      // print out the end
      OSTREAM << pdb::Line( pdb::GetLineTypes().END).GetString() << '\n';

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief finds SSEs in pool that agree best with SSEs in PROTEIN_MODEL
    //! @param PROTEIN_MODEL protein model whose SSEs are to be checked against the pool
    //! @return ShPtrVector to SSEs in pool that agree best with SSEs in PROTEIN_MODEL
    util::SiPtrVector< const SSE> SSEPool::FindBestMatchFromPool( const ProteinModel &PROTEIN_MODEL) const
    {
      // initialize the SiPtrVector to be returned
      util::SiPtrVector< const SSE> best_matches_from_pool;

      // get the sses in the protein model
      util::SiPtrVector< const SSE> sses_from_model( PROTEIN_MODEL.GetSSEs());

      // iterate over the sses in the protein model
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr_protein_model( sses_from_model.Begin()),
          sse_itr_end_protein_model( sses_from_model.End());
        sse_itr_protein_model != sse_itr_end_protein_model;
        ++sse_itr_protein_model
      )
      {
        // store the SiPtr to matching SSE
        util::SiPtr< const SSE> this_match( FindBestMatchFromPool( **sse_itr_protein_model).First());

        // if match is defined
        if( this_match.IsDefined())
        {
          // pushback SiPtr to identified sses from pool into best_matches_from_pool
          best_matches_from_pool.PushBack( this_match);
        }
        else
        {
          BCL_MessageStd
          (
            "no appropriate sse in pool for real sse " +
            util::Format()( ( *sse_itr_protein_model)->GetFirstAA()->GetSeqID()) + " " +
            util::Format()( ( *sse_itr_protein_model)->GetLastAA()->GetSeqID())
          );
        }
      }

      // return SiPtrVector of best matches from pool
      return best_matches_from_pool;
    }

    //! @brief finds SSEs in pool that agree best with SSE that is passed to function
    //! @param TARGET_SSE SSE to be checked against the pool
    //! @param MATCH_THRESHOLD the multiplier for setting the minimum threshold to be considered a match. This value is
    //!                        multiplied by the length of the TARGET_SSE to get the minimum threshold value
    //! @return ShPtr to SSE in pool that agrees best with SSE that is passed to function
    storage::Pair< util::SiPtr< const SSE>, double>
    SSEPool::FindBestMatchFromPool( const SSE &TARGET_SSE, const double MATCH_THRESHOLD) const
    {
      // initialize SiPtr to be returned
      storage::Pair< util::SiPtr< const SSE>, double> best_match_from_pool;
      best_match_from_pool.Second() = MATCH_THRESHOLD * double( TARGET_SSE.GetSize());

      // get list of SSEs in pool that overlap with TARGET_SSE
      util::SiPtrList< const SSE> overlapping_sse_list( GetOverlappingSSEs( TARGET_SSE, false));

      if( overlapping_sse_list.IsEmpty())
      {
        BCL_MessageDbg( "GetOverlappingSSEs function didn't find any match ");
      }

      // iterate over sses in overlapping_sse_list
      for
      (
        util::SiPtrList< const SSE>::const_iterator sse_itr( overlapping_sse_list.Begin()),
          sse_itr_end( overlapping_sse_list.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // skip all the sse pairs that are not of the same type
        if( TARGET_SSE.GetType() != ( *sse_itr)->GetType())
        {
          continue;
        }

        // calculate "temp overlap measure" between TARGET_SSE and sse from list
        const double temp_overlap_measure( CalculateOverlapMeasure( TARGET_SSE, **sse_itr));

        if( temp_overlap_measure < best_match_from_pool.Second())
        {
          best_match_from_pool.First() = *sse_itr;
          best_match_from_pool.Second() = temp_overlap_measure;
        }
      }

      BCL_MessageDbg
      (
        "best_overlap_measure " + util::Format()( best_match_from_pool.Second()) +
         " , " + util::Format()( TARGET_SSE.GetType().GetName())
      );

      return best_match_from_pool;
    }

    //! @brief calculates overlap measure between TARGET_SSE and SSE_FROM_POOL
    //! @param TARGET_SSE SSE to be checked against SSE from pool
    //! @param SSE_FROM_POOL SSE to be checked against TARGET_SSE
    //! @return int overlap measure
    int SSEPool::CalculateOverlapMeasure( const SSE &TARGET_SSE, const SSE &SSE_FROM_POOL) const
    {
      // total number of residues that the two SSEs differ in
      int residue_difference
      (
        math::Absolute( TARGET_SSE.GetFirstAA()->GetSeqID() - SSE_FROM_POOL.GetFirstAA()->GetSeqID()) +
        math::Absolute( TARGET_SSE.GetLastAA()->GetSeqID() - SSE_FROM_POOL.GetLastAA()->GetSeqID())
      );

      // difference in length between the two SSEs
      int length_difference( math::Absolute( int( TARGET_SSE.GetSize()) - int( SSE_FROM_POOL.GetSize())));

      // calculate overlap measure as sum residue_difference and length_difference
      int overlap_measure( residue_difference + length_difference);

      return overlap_measure;
    }

    //! @brief function to return statistics table header names
    //! @return vector of table header names
    const storage::Vector< std::string> &SSEPool::GetStatisticsTableHeaders()
    {
      // initialize static variable
      static storage::Vector< std::string> header_names;

      // if not initialized yet
      if( header_names.IsEmpty())
      {
        header_names.PushBack( "nr_sse");
        header_names.PushBack( "nr_helix");
        header_names.PushBack( "nr_strand");
        header_names.PushBack( "nr_sse_pool");
        header_names.PushBack( "nr_helix_pool");
        header_names.PushBack( "nr_strand_pool");
        header_names.PushBack( "nr_identified_sses");
        header_names.PushBack( "nr_identified_helix");
        header_names.PushBack( "nr_identified_strand");
        header_names.PushBack( "nr_missing_sses");
        header_names.PushBack( "nr_missing_helix");
        header_names.PushBack( "nr_missing_strand");
        header_names.PushBack( "nr_correct_sses_pool");
        header_names.PushBack( "nr_correct_helix_pool");
        header_names.PushBack( "nr_correct_strand_pool");
        header_names.PushBack( "nr_false_sses_pool");
        header_names.PushBack( "nr_false_helix_pool");
        header_names.PushBack( "nr_false_strand_pool");
        header_names.PushBack( "nr_overlaps");
        header_names.PushBack( "nr_helix_overlaps");
        header_names.PushBack( "nr_strand_overlaps");
        header_names.PushBack( "best_avg_overlap");
        header_names.PushBack( "best_avg_helix_overlap");
        header_names.PushBack( "best_avg_strand_overlap");
        header_names.PushBack( "best_avg_shift");
        header_names.PushBack( "best_avg_helix_shift");
        header_names.PushBack( "best_avg_strand_shift");
        header_names.PushBack( "best_avg_length_dev");
        header_names.PushBack( "best_avg_helix_length_dev");
        header_names.PushBack( "best_avg_strand_length_dev");
        header_names.PushBack( "all_avg_overlap");
        header_names.PushBack( "all_avg_helix_overlap");
        header_names.PushBack( "all_avg_strand_overlap");
        header_names.PushBack( "all_avg_shift");
        header_names.PushBack( "all_avg_helix_shift");
        header_names.PushBack( "all_avg_strand_shift");
        header_names.PushBack( "all_avg_length_dev");
        header_names.PushBack( "all_avg_helix_length_dev");
        header_names.PushBack( "all_avg_strand_length_dev");
        header_names.PushBack( "best_sum_overlap");
        header_names.PushBack( "best_sum_helix_overlap");
        header_names.PushBack( "best_sum_strand_overlap");
        header_names.PushBack( "best_sum_shift");
        header_names.PushBack( "best_sum_helix_shift");
        header_names.PushBack( "best_sum_strand_shift");
        header_names.PushBack( "best_sum_length_dev");
        header_names.PushBack( "best_sum_helix_length_dev");
        header_names.PushBack( "best_sum_strand_length_dev");
        header_names.PushBack( "all_sum_overlap");
        header_names.PushBack( "all_sum_helix_overlap");
        header_names.PushBack( "all_sum_strand_overlap");
        header_names.PushBack( "all_sum_shift");
        header_names.PushBack( "all_sum_helix_shift");
        header_names.PushBack( "all_sum_strand_shift");
        header_names.PushBack( "all_sum_length_dev");
        header_names.PushBack( "all_sum_helix_length_dev");
        header_names.PushBack( "all_sum_strand_length_dev");
      }

      // end
      return header_names;
    }

    //! @brief function to calculate to statistics with regards to the given domain
    //! @param SSE_DOMAIN domain to be used for comparison against the given pool
    //! @return a table with a single row that stores the statistics regarding the pool
    storage::Table< double> SSEPool::CalculateStatistics( const DomainInterface &SSE_DOMAIN) const
    {
      // construct table header
      const util::ShPtr< storage::TableHeader> sp_table_header
      (
        new storage::TableHeader( GetStatisticsTableHeaders())
      );

      // create table
      storage::Table< double> table( sp_table_header);

      // get the sses in the protein model
      util::SiPtrVector< const SSE> sses_from_model( SSE_DOMAIN.GetSSEs());

      // get SSEs from protein and construct another pool
      SSEPool native_pool( sses_from_model);

      // construct initial values
      const double nr_sse( native_pool.GetSize());
      const double nr_helix( native_pool.GetSSEs( biol::GetSSTypes().HELIX).GetSize());
      const double nr_strand( native_pool.GetSSEs( biol::GetSSTypes().STRAND).GetSize());
      const double nr_sse_pool( GetSize());
      const double nr_helix_pool( GetSSEs( biol::GetSSTypes().HELIX).GetSize());
      const double nr_strand_pool( GetSSEs( biol::GetSSTypes().STRAND).GetSize());

      // construct row_data with initial numbers
      storage::Vector< double> row_data
      (
        storage::Vector< double>::Create( nr_sse, nr_helix, nr_strand, nr_sse_pool, nr_helix_pool, nr_strand_pool)
      );

      // allocate memory
      row_data.AllocateMemory( sp_table_header->GetSize());

      // initialize sum for overlap
      double best_overlap_sum( 0.0);
      double best_overlap_helix_sum( 0.0);
      double best_overlap_strand_sum( 0.0);
      double best_shift_sum( 0.0);
      double best_shift_helix_sum( 0.0);
      double best_shift_strand_sum( 0.0);
      double best_length_dev_sum( 0.0);
      double best_length_dev_helix_sum( 0.0);
      double best_length_dev_strand_sum( 0.0);
      double all_overlap_sum( 0.0);
      double all_overlap_helix_sum( 0.0);
      double all_overlap_strand_sum( 0.0);
      double all_shift_sum( 0.0);
      double all_shift_helix_sum( 0.0);
      double all_shift_strand_sum( 0.0);
      double all_length_dev_sum( 0.0);
      double all_length_dev_helix_sum( 0.0);
      double all_length_dev_strand_sum( 0.0);

      //  initialize counts for overlaps
      double nr_overlaps( 0);
      double nr_helix_overlaps( 0);
      double nr_strand_overlaps( 0);

      // initialize counter for identified sses, helices and strands
      double nr_identified_sses( 0);
      double nr_identified_helix( 0);
      double nr_identified_strand( 0);

      // iterate over the sses in the protein model
      for
      (
        util::SiPtrVector< const SSE>::const_iterator
          sse_itr( sses_from_model.Begin()), sse_itr_end( sses_from_model.End());
        sse_itr != sse_itr_end; ++sse_itr
      )
      {
        // create reference on the SSE
        const SSE &this_sse( **sse_itr);

        BCL_MessageDbg( "Looking at SSE " + this_sse.GetIdentification());

        // initialize the values for the best overlap, shift and length dev for this SSE
        util::SiPtr< const SSE> best_match;
        double best_overlap( std::numeric_limits< double>::max());
        double best_shift( std::numeric_limits< double>::max());
        double best_length_dev( std::numeric_limits< double>::max());

        // get list of SSEs in pool that overlap with this SSE and exclude ones that do not match the type
        util::SiPtrList< const SSE> overlapping_sses( GetOverlappingSSEs( this_sse, false, true));

        // if no match
        if( overlapping_sses.IsEmpty())
        {
          continue;
          BCL_MessageDbg( "\tno overlapping SSEs");
        }

        // increment counters
        ++nr_identified_sses;
        // if helix
        if( this_sse.GetType() == biol::GetSSTypes().HELIX)
        {
          ++nr_identified_helix;
        }
        // else if strand
        else
        {
          ++nr_identified_strand;
        }

        // iterate over overlapping SSEs from pool
        for
        (
          util::SiPtrList< const SSE>::const_iterator
            pool_itr( overlapping_sses.Begin()), pool_itr_end( overlapping_sses.End());
          pool_itr != pool_itr_end; ++pool_itr
        )
        {
          // calculate the the shift, length deviation and the overlap measure
          const double this_shift
          (
            math::Absolute( this_sse.GetFirstAA()->GetSeqID() - ( *pool_itr)->GetFirstAA()->GetSeqID()) +
            math::Absolute( this_sse.GetLastAA()->GetSeqID() - ( *pool_itr)->GetLastAA()->GetSeqID())
          );
          const double this_length_dev( math::Absolute( int( this_sse.GetSize()) - int( ( *pool_itr)->GetSize())));
          const double this_overlap( this_shift + this_length_dev);

          BCL_MessageDbg
          (
            "\tvs " + ( *pool_itr)->GetIdentification() +
            "\toverlap:\t" + util::Format()( this_overlap) +
            "\tshift:\t" + util::Format()( this_shift) +
            "\tlength_dev:\t" + util::Format()( this_length_dev)
          );

          // if this overlap is better than the best one so far
          if( this_overlap < best_overlap)
          {
            best_match = *pool_itr;
            best_overlap = this_overlap;
            best_shift = this_shift;
            best_length_dev = this_length_dev;
          }

          // update the stats for all overlaps
          ++nr_overlaps;
          all_overlap_sum += this_overlap;
          all_shift_sum += this_shift;
          all_length_dev_sum += this_length_dev;

          // if helix
          if( ( *pool_itr)->GetType() == biol::GetSSTypes().HELIX)
          {
            all_overlap_helix_sum += this_overlap;
            all_length_dev_helix_sum += this_length_dev;
            all_shift_helix_sum += this_shift;
            ++nr_helix_overlaps;
          }
          else
          {
            all_overlap_strand_sum += this_overlap;
            all_length_dev_strand_sum += this_length_dev;
            all_shift_strand_sum += this_shift;
            ++nr_strand_overlaps;
          }
        }

        // assert a match was found
        BCL_Assert( best_match.IsDefined(), "A match should have been found");

        BCL_MessageDbg
        (
          "\tbest overlap " + best_match->GetIdentification() +
          "\toverlap:\t" + util::Format()( best_overlap) +
          "\tshift:\t" + util::Format()( best_shift) +
          "\tlength_dev:\t" + util::Format()( best_length_dev)
        );

        // update the sums
        best_overlap_sum += best_overlap;
        best_shift_sum += best_shift;
        best_length_dev_sum += best_length_dev;

        // if helix
        if( ( *sse_itr)->GetType() == biol::GetSSTypes().HELIX)
        {
          best_overlap_helix_sum += best_overlap;
          best_length_dev_helix_sum += best_length_dev;
          best_shift_helix_sum += best_shift;
        }
        else
        {
          best_overlap_strand_sum += best_overlap;
          best_length_dev_strand_sum += best_length_dev;
          best_shift_strand_sum += best_shift;
        }
      }

      // calculate the identified sse counts and add values to row data
      row_data.PushBack( nr_identified_sses);
      row_data.PushBack( nr_identified_helix);
      row_data.PushBack( nr_identified_strand);
      row_data.PushBack( nr_sse - nr_identified_sses);
      row_data.PushBack( nr_helix - nr_identified_helix);
      row_data.PushBack( nr_strand - nr_identified_strand);

      // get the overlapping SSEs from the pool
      const SSEPool overlapping_pool_sses( GetOverlappingSSEs( SSE_DOMAIN, false, true));

      // update counts for the correct and false sses from the pool
      const double nr_correct_sses_pool( overlapping_pool_sses.GetSize());
      const double nr_correct_helix_pool( overlapping_pool_sses.GetSSEs( biol::GetSSTypes().HELIX).GetSize());
      const double nr_correct_strand_pool( overlapping_pool_sses.GetSSEs( biol::GetSSTypes().STRAND).GetSize());
      row_data.PushBack( nr_correct_sses_pool);
      row_data.PushBack( nr_correct_helix_pool);
      row_data.PushBack( nr_correct_strand_pool);
      row_data.PushBack( nr_sse_pool - nr_correct_sses_pool);
      row_data.PushBack( nr_helix_pool - nr_correct_helix_pool);
      row_data.PushBack( nr_strand_pool - nr_correct_strand_pool);

      // counts for overlaps
      row_data.PushBack( nr_overlaps);
      row_data.PushBack( nr_helix_overlaps);
      row_data.PushBack( nr_strand_overlaps);

      // calculate and insert the average overlap measures for best overlaps
      row_data.PushBack( nr_identified_sses    == 0 ? 0.0 : best_overlap_sum / nr_identified_sses);
      row_data.PushBack( nr_identified_helix   == 0 ? 0.0 : best_overlap_helix_sum / nr_identified_helix);
      row_data.PushBack( nr_identified_strand  == 0 ? 0.0 : best_overlap_strand_sum / nr_identified_strand);
      row_data.PushBack( nr_identified_sses    == 0 ? 0.0 : best_shift_sum / nr_identified_sses);
      row_data.PushBack( nr_identified_helix   == 0 ? 0.0 : best_shift_helix_sum / nr_identified_helix);
      row_data.PushBack( nr_identified_strand  == 0 ? 0.0 : best_shift_strand_sum / nr_identified_strand);
      row_data.PushBack( nr_identified_sses    == 0 ? 0.0 : best_length_dev_sum / nr_identified_sses);
      row_data.PushBack( nr_identified_helix   == 0 ? 0.0 : best_length_dev_helix_sum / nr_identified_helix);
      row_data.PushBack( nr_identified_strand  == 0 ? 0.0 : best_length_dev_strand_sum / nr_identified_strand);

      // insert average overlap measures for all overlaps
      row_data.PushBack( nr_overlaps        == 0 ? 0.0 : all_overlap_sum / nr_overlaps);
      row_data.PushBack( nr_helix_overlaps  == 0 ? 0.0 : all_overlap_helix_sum / nr_helix_overlaps);
      row_data.PushBack( nr_strand_overlaps == 0 ? 0.0 : all_overlap_strand_sum / nr_strand_overlaps);
      row_data.PushBack( nr_overlaps        == 0 ? 0.0 : all_shift_sum / nr_overlaps);
      row_data.PushBack( nr_helix_overlaps  == 0 ? 0.0 : all_shift_helix_sum / nr_helix_overlaps);
      row_data.PushBack( nr_strand_overlaps == 0 ? 0.0 : all_shift_strand_sum / nr_strand_overlaps);
      row_data.PushBack( nr_overlaps        == 0 ? 0.0 : all_length_dev_sum / nr_overlaps);
      row_data.PushBack( nr_helix_overlaps  == 0 ? 0.0 : all_length_dev_helix_sum / nr_helix_overlaps);
      row_data.PushBack( nr_strand_overlaps == 0 ? 0.0 : all_length_dev_strand_sum / nr_strand_overlaps);

      // insert the sums
      row_data.PushBack( best_overlap_sum);
      row_data.PushBack( best_overlap_helix_sum);
      row_data.PushBack( best_overlap_strand_sum);
      row_data.PushBack( best_shift_sum);
      row_data.PushBack( best_shift_helix_sum);
      row_data.PushBack( best_shift_strand_sum);
      row_data.PushBack( best_length_dev_sum);
      row_data.PushBack( best_length_dev_helix_sum);
      row_data.PushBack( best_length_dev_strand_sum);
      row_data.PushBack( all_overlap_sum);
      row_data.PushBack( all_overlap_helix_sum);
      row_data.PushBack( all_overlap_strand_sum);
      row_data.PushBack( all_shift_sum);
      row_data.PushBack( all_shift_helix_sum);
      row_data.PushBack( all_shift_strand_sum);
      row_data.PushBack( all_length_dev_sum);
      row_data.PushBack( all_length_dev_helix_sum);
      row_data.PushBack( all_length_dev_strand_sum);

      // construct and insert row
      table.InsertRow( "pool", row_data);

      // end
      return table;
    }

    //! @brief initialize from a vector of sses
    //! @param SSE_VECTOR vector of sses
    //! @param IGNORE_UNSTRUCTURED ignore unstructured sses
    //! @param IDEALIZE whether to idealize the SSEs (or simply move them to the origin)
    void SSEPool::Initialize
    (
      const util::SiPtrVector< const SSE> &SSE_VECTOR,
      const bool IGNORE_UNSTRUCTURED,
      const bool IDEALIZE
    )
    {
      // iterate over sses in the vector
      for
      (
        util::SiPtrVector< const SSE>::const_iterator sse_itr( SSE_VECTOR.Begin()),
          sse_itr_end( SSE_VECTOR.End());
        sse_itr != sse_itr_end;
        ++sse_itr
      )
      {
        // if not structured
        if( IGNORE_UNSTRUCTURED && !( *sse_itr)->GetType()->IsStructured())
        {
          continue;
        }

        // copy sse
        util::ShPtr< SSE> current_sse( ( *sse_itr)->Clone());

        // idealize if idealize param is true
        if( IDEALIZE)
        {
          // reset to unit conformation (ideal in origin)
          current_sse->SetToIdealConformationAtOrigin();
        }
        // just move to origin
        else
        {
          current_sse->Transform( math::Inverse( current_sse->GetOrientation()));
        }

        // insert into the set
        m_Data.Insert( current_sse);
      }
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_pool_insert_coil_into_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "math/bcl_math_mutate_result.h"
#include "math/bcl_math_running_average_sd.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPoolInsertCoilIntoSSE::s_Instance
    (
      GetObjectInstances().AddInstance
      (
        new SSEPoolInsertCoilIntoSSE
        (
          sspred::GetMethods().e_Undefined,
          util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> >(),
          1
        )
      )
    );

    //! @brief the default scheme for this class
    const std::string &SSEPoolInsertCoilIntoSSE::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "pool_insert_coil_into_sse");
      return s_default_scheme;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from locator and mutate
    //! @param SS_METHOD the method to use to locate the largest drop in the ss prediction for the located sse
    //! @param SP_LOCATE_SSE picker of sse from domain
    //! @param COIL_LENGTH length of the coil to insert
    //! @param SCHEME the scheme
    SSEPoolInsertCoilIntoSSE::SSEPoolInsertCoilIntoSSE
    (
      const sspred::Method &SS_METHOD,
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > &SP_LOCATE_SSE,
      const size_t COIL_LENGTH,
      const std::string &SCHEME
    ) :
      m_Method( SS_METHOD),
      m_SSELocator( SP_LOCATE_SSE),
      m_CoilLength( COIL_LENGTH),
      m_Scheme( SCHEME)
    {
      BCL_Assert( m_CoilLength > 0, "coil length needs to be at least 1, but is: " + util::Format()( m_CoilLength));
    }

    //! @brief Clone function
    //! @return pointer to new SSEPoolInsertCoilIntoSSE
    SSEPoolInsertCoilIntoSSE *SSEPoolInsertCoilIntoSSE::Clone() const
    {
      return new SSEPoolInsertCoilIntoSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPoolInsertCoilIntoSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &SSEPoolInsertCoilIntoSSE::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that mutates a pool by splitting a single sse
    //! @param SSE_POOL
    //! @return MutateResult that results from mutating to the SSE_POOL
    math::MutateResult< SSEPool> SSEPoolInsertCoilIntoSSE::operator()( const SSEPool &SSE_POOL) const
    {
      // pick a sse from the pool
      util::SiPtrList< const SSE> pool_sses( SSE_POOL.Begin(), SSE_POOL.End());
      const util::SiPtr< const SSE> picked_sse( m_SSELocator->Locate( SSE_POOL));

      // was picking successful
      if( !picked_sse.IsDefined())
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      const biol::SSType picked_type( picked_sse->GetType());

      // length of sse to split
      const size_t seq_length( picked_sse->GetSize());

      // need at least coil residues plus two to split
      if( seq_length < m_CoilLength)
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // determine all n residue averages
      storage::List< storage::VectorND< 3, math::RunningAverageSD< double> > > mean_list;
      if( m_CoilLength && picked_sse->GetSize() <= m_CoilLength)
      {
        // iterate over the sequence
        for
        (
          biol::AASequence::const_iterator aa_itr( picked_sse->Begin()), aa_itr_end( picked_sse->End() - m_CoilLength + 1);
          aa_itr != aa_itr_end;
          ++aa_itr
        )
        {
          storage::VectorND< 3, math::RunningAverageSD< double> > stats;

          for
          (
            biol::AASequence::const_iterator aa_itr_local( aa_itr), aa_itr_local_end( aa_itr + m_CoilLength);
            aa_itr_local != aa_itr_local_end;
            ++aa_itr_local
          )
          {
            const linal::Vector3D current_prediction( ( *aa_itr_local)->GetData()->GetSSPrediction( m_Method)->GetThreeStatePrediction());
            // add pseudo probability
            stats( 0) +=  current_prediction( 0);
            stats( 1) +=  current_prediction( 1);
            stats( 2) +=  current_prediction( 2);
          }
          mean_list.PushBack( stats);
        }
      }

      // find the lowest mean starting from pos 1
      storage::List< storage::VectorND< 3, math::RunningAverageSD< double> > >::const_iterator itr( mean_list.Begin()), itr_end( mean_list.End());
      math::RunningAverageSD< double> lowest( itr->operator ()( picked_type));
      size_t split_pos( 0);
      for( size_t i( 0); itr != itr_end; ++itr, ++i)
      {
        if( lowest.GetAverage() > itr->operator ()( picked_type).GetAverage())
        {
          lowest = itr->operator ()( picked_type);
          split_pos = i;
        }
      }

      util::ShPtr< SSE> sp_sse_left( new SSE( picked_sse->SubSequence( 0, split_pos), picked_type));
      util::ShPtr< SSE> sp_sse_coil( new SSE( picked_sse->SubSequence( split_pos, m_CoilLength), biol::GetSSTypes().COIL));
      util::ShPtr< SSE> sp_sse_right( new SSE( picked_sse->SubSequence( split_pos + m_CoilLength, seq_length - split_pos - m_CoilLength), picked_type));

      BCL_MessageDbg
      (
        "inserted coil into sse: " + picked_sse->GetIdentification() + "\nresulting in\n" +
        sp_sse_left->GetIdentification() + '\n' + sp_sse_coil->GetIdentification() + '\n' + sp_sse_right->GetIdentification()
      );

      // replace with new sses
      util::SiPtrList< const SSE>::iterator new_end
      (
        std::remove_if
        (
          pool_sses.Begin(), pool_sses.End(),
          SSECompare( *picked_sse)
        )
      );

      util::ShPtr< SSEPool> sp_pool( new SSEPool( util::SiPtrList< const SSE>( pool_sses.Begin(), new_end), false));
      if( sp_sse_left->GetSize() > 0)
      {
        sp_pool->Insert( sp_sse_left);
      }
      sp_pool->Insert( sp_sse_coil);
      if( sp_sse_right->GetSize() > 0)
      {
        sp_pool->Insert( sp_sse_right);
      }

      // end
      return math::MutateResult< SSEPool>( sp_pool, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPoolInsertCoilIntoSSE::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Method    , ISTREAM);
      io::Serialize::Read( m_SSELocator, ISTREAM);
      io::Serialize::Read( m_CoilLength, ISTREAM);
      io::Serialize::Read( m_Scheme    , ISTREAM);

      BCL_Assert( m_CoilLength > 0, "coil length needs to be at least 1, but is: " + util::Format()( m_CoilLength));

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPoolInsertCoilIntoSSE::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Method    , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SSELocator, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_CoilLength, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme    , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_pool_join_sses.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! @brief the default scheme for this class
    const std::string &SSEPoolJoinSSEs::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "pool_join_sses");
      return s_default_scheme;
    }

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPoolJoinSSEs::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEPoolJoinSSEs( util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> >(), false, false))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from scheme
    //! @param SP_LOCATE_SSE locator of sse from domain
    //! @param JOIN_LEFT join the sse left to the located; default: true
    //! @param JOIN_RIGHT join the sse right to the located; default: true
    //! @param SCHEME the scheme
    SSEPoolJoinSSEs::SSEPoolJoinSSEs
    (
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > &SP_LOCATE_SSE,
      const bool JOIN_LEFT,
      const bool JOIN_RIGHT,
      const std::string &SCHEME
    ) :
      m_SSELocator( SP_LOCATE_SSE),
      m_JoinLeft(   JOIN_LEFT),
      m_JoinRight(  JOIN_RIGHT),
      m_Scheme(     SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEPoolJoinSSEs
    SSEPoolJoinSSEs *SSEPoolJoinSSEs::Clone() const
    {
      return new SSEPoolJoinSSEs( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPoolJoinSSEs::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &SSEPoolJoinSSEs::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that mutates a pool by joining multiple sses
    //! @param SSE_POOL
    //! @return MutateResult that results from mutating to the SSE_POOL
    math::MutateResult< SSEPool> SSEPoolJoinSSEs::operator()( const SSEPool &SSE_POOL) const
    {
      // locate an sses
      const util::SiPtr< const SSE> located_sse( m_SSELocator->Locate( SSE_POOL));

      // was locating successful
      if( !located_sse.IsDefined())
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // create new sequence
      biol::AASequence new_sequence( *located_sse);

      // neighbor sses
      const storage::VectorND< 2, util::SiPtr< const SSE> > neighbors( SSE_POOL.GetAdjacentSSEs( *located_sse));

      if( !neighbors.First().IsDefined() || !neighbors.Second().IsDefined())
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      bool joined_left( false);
      bool joined_right( false);

      util::SiPtrList< const SSE> pool_sses( SSE_POOL.Begin(), SSE_POOL.End());
      util::SiPtrList< const SSE>::iterator new_end( std::remove_if( pool_sses.Begin(), pool_sses.End(), SSECompare( *located_sse)));

      storage::Set< biol::SSType> ss_types;
      ss_types.Insert( located_sse->GetType());

      // find left adjacent sse
      if( m_JoinLeft && neighbors.First().IsDefined())
      {
        new_sequence.PrependSequence( *neighbors.First());
        joined_left = true;
        new_end = std::remove_if( pool_sses.Begin(), new_end, SSECompare( *neighbors.First()));
        ss_types.Insert( neighbors.First()->GetType());
      }

      // find right adjacent sse
      if( m_JoinRight && neighbors.Second().IsDefined())
      {
        new_sequence.AppendSequence( *neighbors.Second());
        joined_right = true;
        new_end = std::remove_if( pool_sses.Begin(), new_end, SSECompare( *neighbors.Second()));
        ss_types.Insert( neighbors.Second()->GetType());
      }

      // if there was no join, skip
      if( !joined_left && !joined_right)
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // joined sse
      util::ShPtr< SSE> sp_sse( new SSE( new_sequence, *random::GetGlobalRandom().Iterator( ss_types.Begin(), ss_types.End(), ss_types.GetSize())));

      BCL_MessageDbg
      (
        "joined sses: " +
        std::string( joined_left ? "\nleft: " + neighbors.First()->GetIdentification() : "") +
        "\nmiddle: " + located_sse->GetIdentification() +
        std::string( joined_right ? "\nright: " + neighbors.Second()->GetIdentification() : "") +
        "\ninto: " + sp_sse->GetIdentification()
      )

      // new pool
      util::ShPtr< SSEPool> sp_pool( new SSEPool( util::SiPtrList< const SSE>( pool_sses.Begin(), new_end), false));
      sp_pool->Insert( sp_sse);

      // end
      return math::MutateResult< SSEPool>( sp_pool, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPoolJoinSSEs::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_SSELocator, ISTREAM);
      io::Serialize::Read( m_JoinLeft  , ISTREAM);
      io::Serialize::Read( m_JoinRight , ISTREAM);
      io::Serialize::Read( m_Scheme    , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPoolJoinSSEs::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_SSELocator, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_JoinLeft  , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_JoinRight , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme    , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_pool_move_aa.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! @brief the default scheme for this class
    const std::string &SSEPoolMoveAA::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "pool_move_aa");
      return s_default_scheme;
    }

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPoolMoveAA::s_Instance
    (
      GetObjectInstances().AddInstance( new SSEPoolMoveAA( math::Range< size_t>( 1, 1)))
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from max number of residues to move
    //! @param RESIDUES_TO_MOVE_RANGE range of number of residues to move
    //! @param SCHEME the scheme
    SSEPoolMoveAA::SSEPoolMoveAA
    (
      const math::Range< size_t> &RESIDUES_TO_MOVE_RANGE,
      const std::string &SCHEME
    ) :
      m_ResdiuesToMoveRange( RESIDUES_TO_MOVE_RANGE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEPoolMoveAA
    SSEPoolMoveAA *SSEPoolMoveAA::Clone() const
    {
      return new SSEPoolMoveAA( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPoolMoveAA::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &SSEPoolMoveAA::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that mutates a pool by shifting aas between sses
    //! @param SSE_POOL
    //! @return MutateResult that results from mutating to the SSE_POOL
    math::MutateResult< SSEPool> SSEPoolMoveAA::operator()( const SSEPool &SSE_POOL) const
    {
      // all sses from the pool
      util::SiPtrList< const SSE> pool_sses( SSE_POOL.Begin(), SSE_POOL.End());

      if( pool_sses.GetSize() < 2)
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // pick an sse randomly
      const size_t index( random::GetGlobalRandom().Random( pool_sses.GetSize() - 2));

      // identify two adjacent sses
      util::SiPtrList< const SSE>::const_iterator itr1( pool_sses.Begin());
      util::SiPtrList< const SSE>::const_iterator itr2( pool_sses.Begin());
      std::advance( itr1, index);
      std::advance( itr2, index + 1);

      const SSE &sse1( **itr1);
      const SSE &sse2( **itr2);

      // check that the sses are consecutive
      if( ( ( *itr2)->GetFirstAA()->GetSeqID() - ( *itr1)->GetLastAA()->GetSeqID()) != 1)
      {
        BCL_MessageDbg
        (
          "this mutate only works for pools of consecutive SSEs, but encountered:\n" +
          ( *itr1)->GetIdentification() + '\n' + ( *itr2)->GetIdentification()
        );
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // create new pool
      util::SiPtrList< const SSE>::iterator new_end
      (
        std::remove_if
        (
          pool_sses.Begin(), pool_sses.End(),
          SSECompare( sse1)
        )
      );

      new_end = std::remove_if
      (
        pool_sses.Begin(), new_end,
        SSECompare( sse2)
      );

      util::ShPtr< SSEPool> sp_pool( new SSEPool( util::SiPtrList< const SSE>( pool_sses.Begin(), new_end), false));

      // create two new sses
      size_t nr_res( random::GetGlobalRandom().Random( m_ResdiuesToMoveRange));
      const bool move_up( random::GetGlobalRandom().Boolean());

      BCL_MessageDbg( "sses before moving aa:\n" + sse1.GetIdentification() + '\n' + sse2.GetIdentification());

      // move residues up in sequence to next SSE
      if( move_up)
      {
        BCL_MessageDbg( "sses after moving aa:");
        if( nr_res < sse1.GetSize())
        {
          util::ShPtr< SSE> sp_sse( new SSE( sse1.SubSequence( 0, sse1.GetSize() - nr_res), sse1.GetType()));
          sp_pool->Insert( sp_sse);
          BCL_MessageDbg( sp_sse->GetIdentification());
        }

        // reduce the number of residues if necessary
        nr_res = std::min( nr_res, sse1.GetSize());

        // sequence for other sse
        biol::AASequence seq2( sse2);
        seq2.PrependSequence( sse1.SubSequence( sse1.GetSize() - nr_res, nr_res));

        // new sse
        util::ShPtr< SSE> sp_sse( new SSE( seq2, sse2.GetType()));
        sp_pool->Insert( sp_sse);
        BCL_MessageDbg( sp_sse->GetIdentification());
      }
      // move residues down in sequence to previous sse
      else
      {
        BCL_MessageDbg( "sses after moving aa:");
        if( nr_res < sse2.GetSize())
        {
          util::ShPtr< SSE> sp_sse( new SSE( sse2.SubSequence( nr_res, sse2.GetSize() - nr_res), sse2.GetType()));
          sp_pool->Insert( sp_sse);
          BCL_MessageDbg( sp_sse->GetIdentification());
        }

        // reduce the number of residues if necessary
        nr_res = std::min( nr_res, sse2.GetSize());
        biol::AASequence seq1( sse1);
        seq1.AppendSequence( sse2.SubSequence( 0, nr_res));

        // new sse
        util::ShPtr< SSE> sp_sse( new SSE( seq1, sse1.GetType()));
        sp_pool->Insert( sp_sse);
        BCL_MessageDbg( sp_sse->GetIdentification());
      }

      // end
      return math::MutateResult< SSEPool>( sp_pool, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPoolMoveAA::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_ResdiuesToMoveRange, ISTREAM);
      io::Serialize::Read( m_Scheme             , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPoolMoveAA::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_ResdiuesToMoveRange, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme             , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_pool_mutate_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPoolMutateSSE::s_Instance
    (
      GetObjectInstances().AddInstance
      (
        new SSEPoolMutateSSE
        (
          util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> >(),
          util::ShPtr< math::MutateInterface< SSE> >()
        )
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief construct from a sse pick and mutate
    //! @param SP_LOCATE_SSE locator of sse from domain
    //! @param SP_SSE_MUTATE mutate for an sse
    SSEPoolMutateSSE::SSEPoolMutateSSE
    (
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > &SP_LOCATE_SSE,
      const util::ShPtr< math::MutateInterface< SSE> > &SP_SSE_MUTATE
    ) :
      m_LocateSSE( SP_LOCATE_SSE),
      m_MutateSSE( SP_SSE_MUTATE)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEPoolMutateSSE
    SSEPoolMutateSSE *SSEPoolMutateSSE::Clone() const
    {
      return new SSEPoolMutateSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPoolMutateSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &SSEPoolMutateSSE::GetScheme() const
    {
      return m_MutateSSE->GetScheme();
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that mutates a pool by mutating a single sse
    //! @param SSE_POOL
    //! @return MutateResult that results from mutating to the SSE_POOL
    math::MutateResult< SSEPool> SSEPoolMutateSSE::operator()( const SSEPool &SSE_POOL) const
    {
      // pick a sse from the pool
      const util::SiPtr< const SSE> located_sse( m_LocateSSE->Locate( SSE_POOL));

      // was picking successful
      if( !located_sse.IsDefined())
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // mutate the sse
      math::MutateResult< SSE> result( m_MutateSSE->operator ()( *located_sse));

      // was mutating successful
      if( !result.GetArgument().IsDefined())
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // replace with new sse
      util::SiPtrList< const SSE> pool_sses( SSE_POOL.Begin(), SSE_POOL.End());
      util::SiPtrList< const SSE>::iterator new_end
      (
        std::remove_if
        (
          pool_sses.Begin(), pool_sses.End(),
          SSECompare( *located_sse)
        )
      );

      util::ShPtr< SSEPool> sp_pool( new SSEPool( util::SiPtrList< const SSE>( pool_sses.Begin(), new_end), false));
      sp_pool->Insert( result.GetArgument());

      // end
      return math::MutateResult< SSEPool>( sp_pool, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPoolMutateSSE::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_LocateSSE, ISTREAM);
      io::Serialize::Read( m_MutateSSE, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPoolMutateSSE::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_LocateSSE, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_MutateSSE, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_pool_split_sse.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse_pool.h"
#include "math/bcl_math_mutate_result.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! @brief the default scheme for this class
    const std::string &SSEPoolSplitSSE::GetDefaultScheme()
    {
      static const std::string s_default_scheme( "pool_split_sse");
      return s_default_scheme;
    }

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSEPoolSplitSSE::s_Instance
    (
      GetObjectInstances().AddInstance
      (
        new SSEPoolSplitSSE
        (
          sspred::GetMethods().e_Undefined,
          util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> >(),
          util::ShPtr< math::MutateInterface< SSE> >()
        )
      )
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief constructor from locator and mutate
    //! @param SS_METHOD the method to use to locate the largest drop in the ss prediction for the located sse
    //! @param SP_LOCATE_SSE locator of sse from domain
    //! @param SP_MUTATE_SSE mutate to apply to sse that has the lower of the predictions
    //! @param SCHEME the scheme
    SSEPoolSplitSSE::SSEPoolSplitSSE
    (
      const sspred::Method &SS_METHOD,
      const util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > &SP_LOCATE_SSE,
      const util::ShPtr< math::MutateInterface< SSE> > &SP_MUTATE_SSE,
      const std::string &SCHEME
    ) :
      m_Method( SS_METHOD),
      m_SSELocator( SP_LOCATE_SSE),
      m_SSEMutate( SP_MUTATE_SSE),
      m_Scheme( SCHEME)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSEPoolSplitSSE
    SSEPoolSplitSSE *SSEPoolSplitSSE::Clone() const
    {
      return new SSEPoolSplitSSE( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSEPoolSplitSSE::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief gets the scheme for this mutate
    //! @return the scheme for this mutate
    const std::string &SSEPoolSplitSSE::GetScheme() const
    {
      return m_Scheme;
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief operator that mutates a pool by splitting a single sse
    //! @param SSE_POOL SSEPool to be mutated
    //! @return MutateResult that results from mutating to the SSE_POOL
    math::MutateResult< SSEPool> SSEPoolSplitSSE::operator()( const SSEPool &SSE_POOL) const
    {
      // locate a sse from the pool
      const util::SiPtr< const SSE> located_sse( m_SSELocator->Locate( SSE_POOL));

      // was locating successful
      if( !located_sse.IsDefined())
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // length of sse to split
      const size_t seq_length( located_sse->GetSize());

      // need at least two residues to split
      if( seq_length < 2)
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // find drop in prediction
      const storage::Pair< util::SiPtr< const biol::AABase>, double> aa_pos_left_diff( FindLargestSSPredDifferencePosition( *located_sse, m_Method));

      // no drop could be identified
      if( !aa_pos_left_diff.First().IsDefined())
      {
        return math::MutateResult< SSEPool>( util::ShPtr< SSEPool>(), *this);
      }

      // either left or right sse to mutate (the one with the lower prediction)
      const bool left( aa_pos_left_diff.Second() > 0.0);
      const size_t split_pos( aa_pos_left_diff.First()->GetSeqID() - located_sse->GetFirstAA()->GetSeqID());

      util::ShPtr< SSE> sp_sse_a( new SSE( located_sse->SubSequence( 0, split_pos), located_sse->GetType()));
      util::ShPtr< SSE> sp_sse_b( new SSE( located_sse->SubSequence( split_pos, seq_length - split_pos), located_sse->GetType()));

      // mutate either sse
      if( m_SSEMutate.IsDefined())
      {
        if( left)
        {
          math::MutateResult< SSE> result( m_SSEMutate->operator ()( *sp_sse_a));
          if( result.GetArgument().IsDefined())
          {
            sp_sse_a = result.GetArgument();
          }
        }
        else
        {
          math::MutateResult< SSE> result( m_SSEMutate->operator ()( *sp_sse_b));
          if( result.GetArgument().IsDefined())
          {
            sp_sse_b = result.GetArgument();
          }
        }
      }

      BCL_MessageDbg
      (
        "split sse: " + located_sse->GetIdentification() + "\nat: " +
        aa_pos_left_diff.First()->GetIdentification() +
        "\ninto\n" +
        sp_sse_a->GetIdentification() + "\n" + sp_sse_b->GetIdentification()
      );

      // replace with new sses
      util::SiPtrList< const SSE> pool_sses( SSE_POOL.Begin(), SSE_POOL.End());
      util::SiPtrList< const SSE>::iterator new_end
      (
        std::remove_if
        (
          pool_sses.Begin(), pool_sses.End(),
          SSECompare( *located_sse)
        )
      );

      util::ShPtr< SSEPool> sp_pool( new SSEPool( util::SiPtrList< const SSE>( pool_sses.Begin(), new_end), false));
      sp_pool->Insert( sp_sse_a);
      sp_pool->Insert( sp_sse_b);

      // end
      return math::MutateResult< SSEPool>( sp_pool, *this);
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSEPoolSplitSSE::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Method    , ISTREAM);
      io::Serialize::Read( m_SSELocator, ISTREAM);
      io::Serialize::Read( m_SSEMutate , ISTREAM);
      io::Serialize::Read( m_Scheme    , ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSEPoolSplitSSE::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Method    , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SSELocator, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_SSEMutate , OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Scheme    , OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief find the amino acid right to the highest difference for the given sspred::Method and SSType and report the difference
    //! @param ELEMENT the secondary structure element
    //! @param SSMETHOD the ssprediction method
    //! @return Pair of difference (right-left) and the amino acid to the left
    storage::Pair< util::SiPtr< const biol::AABase>, double> SSEPoolSplitSSE::FindLargestSSPredDifferencePosition
    (
      const SSE &ELEMENT, const sspred::Method &SSMETHOD
    )
    {
      // initialize the pair
      storage::Pair< util::SiPtr< const biol::AABase>, double> aa_diff( util::SiPtr< const biol::AABase>(), 0.0);

      // sequence too short
      if( ELEMENT.GetSize() < 2)
      {
        return aa_diff;
      }

      // sstype
      const biol::SSType sstype( ELEMENT.GetType());

      // iterator for amino acids
      SSE::const_iterator itr( ELEMENT.Begin()), itr_end( ELEMENT.End());

      // first aa
      aa_diff.First() = *itr;
      double left_prediction( ( *itr)->GetSSPrediction( SSMETHOD)->GetThreeStatePrediction()( sstype));

      // next aa
      ++itr;

      // iterate over all aas
      while( itr != itr_end)
      {
        const double prediction( ( *itr)->GetSSPrediction( SSMETHOD)->GetThreeStatePrediction()( sstype));
        const double difference( prediction - left_prediction);

        // update the highest difference if necessary
        if( math::Absolute( difference) > math::Absolute( aa_diff.Second()))
        {
          aa_diff.First() = *itr;
          aa_diff.Second() = difference;
        }

        // go to next
        left_prediction = prediction;
        ++itr;
      }

      // if largest difference is 0, do not return a position
      if( aa_diff.Second() == 0.0)
      {
        aa_diff.First() = util::SiPtr< const biol::AABase>();
      }

      // end
      return aa_diff;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_sse_transformer.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> SSETransformer::s_Instance
    (
      GetObjectInstances().AddInstance( new SSETransformer())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    SSETransformer::SSETransformer() :
      m_Sequence()
    {
    }

    //! @brief construct from a transformation matrix and chain IDs
    //! @param SP_SEQUENCE sequence used to generate new SSE
    //! @param SP_TRANSFORMATION the transformation to apply to sse
    SSETransformer::SSETransformer
    (
      const util::ShPtr< biol::AASequence> &SP_SEQUENCE,
      const util::ShPtr< math::TransformationMatrix3D> &SP_TRANSFORMATION
    ) :
      m_Sequence( SP_SEQUENCE),
      m_Transformation( SP_TRANSFORMATION)
    {
    }

    //! @brief Clone function
    //! @return pointer to new SSETransformer
    SSETransformer *SSETransformer::Clone() const
    {
      return new SSETransformer( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &SSETransformer::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

  ///////////////
  // operators //
  ///////////////

    //! @brief returns SSE after transformation
    //! @param INITIAL_SSE SSE to be transformed
    //! @return SSE after transformation
    util::ShPtr< SSE> SSETransformer::operator ()( const SSE &INITIAL_SSE) const
    {
      // create a new SSE
      util::ShPtr< SSE> sp_sse( INITIAL_SSE.Clone());

      // connect the aa data and set to the correct chain id
      m_Sequence->ConnectAADataByPdbID( *sp_sse, false);

      // transform
      sp_sse->Transform( *m_Transformation);

      // end
      return sp_sse;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &SSETransformer::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_Sequence, ISTREAM);
      io::Serialize::Read( m_Transformation, ISTREAM);

      // return the stream
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &SSETransformer::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_Sequence, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_Transformation, OSTREAM, INDENT);

      // return the stream
      return OSTREAM;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_template_instantiations.h"

// includes from bcl - sorted alphabetically

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

    template class BCL_API LocatorSSEFurthest< DomainInterface>;

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_topology.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"
#include "assemble/bcl_assemble_sse_geometry_packing_pickers.h"
#include "contact/bcl_contact_map.h"
#include "math/bcl_math_running_min_max.h"
#include "math/bcl_math_sum_function.h"
#include "util/bcl_util_color_gradient.h"
#include "util/bcl_util_colors.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  ///////////
  // enums //
  ///////////

    //! @brief conversion to a string from a Type
    //! @param TYPE the type to get a string for
    //! @return a string representing that type
    const std::string &Topology::GetTypeName( const Type &TYPE)
    {
      static const std::string s_descriptors[] =
      {
        "beta-sheet",
        "beta-barrel",
        "helix-bundle",
        "undefined"
      };
      return s_descriptors[ size_t( TYPE)];
    }

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> Topology::s_Instance
    (
      GetObjectInstances().AddInstance( new Topology())
    );

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    Topology::Topology() :
      m_Type( s_NumberTypes),
      m_Graph(),
      m_Elements(),
      m_Geometry()
    {
    }

    //! @brief constructor from vector of SSE Geometries
    //! @param GEOMETRY_VECTOR SiPtrVector of Geometries
    Topology::Topology( const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR) :
      m_Type( s_NumberTypes),
      m_Graph(),
      m_Elements( GEOMETRY_VECTOR),
      m_Geometry( CalculateCenterOfGeometries( GEOMETRY_VECTOR))
    {
    }

    //! @brief constructor from an orientation
    //! @param ORIENTATION math::TransformationMatrix3D that defines the orientation
    Topology::Topology( const math::TransformationMatrix3D &ORIENTATION) :
      m_Type( s_NumberTypes),
      m_Graph(),
      m_Elements(),
      m_Geometry( ORIENTATION)
    {
    }

    //! @brief private constructor from data members
    //! @param GRAPH graph to be used
    Topology::Topology
    (
      const GraphType &GRAPH
    ) :
      m_Type( s_NumberTypes),
      m_Graph( GRAPH),
      m_Elements( GetElementsVectorFromGraph( GRAPH)),
      m_Geometry()
    {
    }

    //! @brief Clone function
    //! @return pointer to new Topology
    Topology *Topology::Clone() const
    {
      return new Topology( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &Topology::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief set the graph
    //! @param GRAPH Graph to be copied
    void Topology::SetGraph( const GraphType &GRAPH)
    {
      m_Graph = GRAPH;
      m_Elements = GetElementsVectorFromGraph( m_Graph);
    }

    //! @brief get packing object for two SSEGeometries
    //! @param SP_GEOMETRY_A SiPtr to first SSEGeometry of interest
    //! @param SP_GEOMETRY_B SiPtr to second SSEGeometry of interest
    //! @return packing between SSEGeometry behind SP_GEOMETRY_A and SP_GEOMETRY_B
    const SSEGeometryPacking &Topology::GetPackingForSSEGeometryPair
    (
      const util::SiPtr< const SSEGeometryInterface> &SP_GEOMETRY_A,
      const util::SiPtr< const SSEGeometryInterface> &SP_GEOMETRY_B
    ) const
    {
      // initialize a static undefined SSEPacking
      static const SSEGeometryPacking s_undefined_packing;

      // if any of the pointers are not defined
      if( !SP_GEOMETRY_A.IsDefined() || !SP_GEOMETRY_B.IsDefined())
      {
        return s_undefined_packing;
      }

      // find the corresponding vertices
      const util::ShPtr< GraphType::VertexType> vertex_a( m_Graph.FindVertex( SP_GEOMETRY_A));
      const util::ShPtr< GraphType::VertexType> vertex_b( m_Graph.FindVertex( SP_GEOMETRY_B));

      // if any of the vertices can't be found
      if( !vertex_a.IsDefined() || !vertex_b.IsDefined())
      {
        return s_undefined_packing;
      }

      // now find the corresponding edge
      const GraphType::EdgeType &edge( vertex_a->FindEdge( *vertex_b));

      // if the edge can't be found
      if( !edge.IsDefined())
      {
        return s_undefined_packing;
      }

      // return the data
      return edge.GetData();
    }

    //! @brief returns the geometric center of the Sheet
    //! @return the geometric center of the Sheet
    linal::Vector3D Topology::GetCenter() const
    {
      return m_Geometry.GetOrigin();
    }

    //! @brief return the orientation of the Sheet
    //! @return orientation
    linal::Vector3D Topology::GetAxis( const coord::Axis &AXIS) const
    {
      return m_Geometry.GetAxis( AXIS);
    }

    //! @brief return the orientation and Position as TransformationMatrix3D
    //! @return TransformationMatrix3D that defines orientation and position
    const math::TransformationMatrix3D Topology::GetOrientation() const
    {
      return m_Geometry;
    }

    //! @brief initialize the orientation using type information
    void Topology::SetOrientationFromType()
    {
      // if type is sheet or beta barrel
      if( m_Type == e_Sheet || m_Type == e_BetaBarrel)
      {
        // store number of strands
        const size_t nr_strands( m_Elements.GetSize());

        // decide on the center strand index
        const size_t center_strand_index( ( nr_strands - 1) / 2);

        // initialize transformation to the center strand
        math::TransformationMatrix3D transformation( m_Elements( center_strand_index)->GetOrientation());

        // if there are even number of strands
        // then calculate the translation that will move the origin to the middle point of the two center strands
        if( nr_strands % 2 == 0)
        {
          // get the translation from selected middle strand to the other one
          linal::Vector3D translation
          (
            m_Elements( center_strand_index + 1)->GetCenter() - m_Elements( center_strand_index)->GetCenter()
          );

          // update the geometry with half of this translation
          transformation( translation / 2);
        }

        // make sure the y axis points from left to right according to order vector
        // first calculate the axis from left to right
        linal::Vector3D left_to_right_vector
        (
           m_Elements.LastElement()->GetCenter() - m_Elements.FirstElement()->GetCenter()
        );

        // store the y axis
        linal::Vector3D y_axis( transformation.GetAxis( coord::GetAxes().e_Y));

        // calculate the angle between the y axis and the left_to_right_vector
        const double angle( linal::ProjAngle( left_to_right_vector, y_axis));

        // if they are pointing in opposite directions, thus the angle is larger than 90 degrees
        if( angle >= math::g_Pi / 2)
        {
          // set the y axis to the opposite
          transformation.SetAxis( coord::GetAxes().e_Y, -y_axis);
        }

        // set the geometry
        m_Geometry = transformation;
      }
      else
      {
        BCL_MessageStd( "Topology can set orientation only for sheet or beta-barrels at this point");
      }

    }

    //! @brief get the identification of this topology with detailed connectivity map information
    //! @return the identification of this topology  with detailed connectivity map information
    std::string Topology::GetIdentification() const
    {
      // initialize identification to show number of strands and the topology type
      std::string identification( "number_elements: ");
      identification += util::Format()( m_Elements.GetSize()) +
                        " type: " + util::Format()( m_Type) + "\n";
      identification += "Connectivity Map\n";

      // iterate over strands in the given order
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator
          element_itr( m_Elements.Begin()), element_itr_end( m_Elements.End());
        element_itr != element_itr_end; ++element_itr
      )
      {
        // add the identification of this strand
        identification += ( *element_itr)->GetIdentification() + "\n";

        // get the corresponding vertex
        util::ShPtr< GraphType::VertexType> vertex( m_Graph.FindVertex( *element_itr));

        // iterate over the edges this vertex is connected to
        for
        (
          GraphType::EdgeContainerType::const_iterator
            edge_itr( vertex->GetEdges().Begin()), edge_itr_end( vertex->GetEdges().End());
          edge_itr != edge_itr_end; ++edge_itr
        )
        {
          // add the additional information
          identification +=
            "\t"               + edge_itr->GetTarget()->GetData()->GetIdentification() +
            "\n\t" + edge_itr->GetData().GetIdentification() + "\n";
        }
      }
      identification += "\n";

      // end
      return identification;
    }

    //! @brief get Identification of this topology in a ordered fashion
    //! @return string with identification
    std::string Topology::GetOrderedIdentification() const
    {
      // initialize identification to show number of strands and the topology type
      std::string identification;
      identification +=
        "number elements " + util::Format()( m_Elements.GetSize()) +
         "\ttype: " + util::Format()( m_Type) + "\n";

      // initialize element ctr
      size_t element_ctr( 0);

      // iterate over strands in the given order
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator
          element_itr( m_Elements.Begin()), element_itr_end( m_Elements.End());
        element_itr != element_itr_end; ++element_itr
      )
      {
        // increment strand ctr
        ++element_ctr;

        // add identification of the strand
        identification += ( *element_itr)->GetIdentification();

        // if not the first SSE
        if( element_itr != m_Elements.Begin())
        {
          // add the orientation with respect to the previous strand
          identification += "\t";

          // get the packing
          const SSEGeometryPacking &this_packing( GetPackingForSSEGeometryPair( *( element_itr - 1), *element_itr));
          identification += this_packing.GetIdentification();
        }

        identification += "\n";
      }
      // end
      return identification;
    }

  ////////////////
  // operations //
  ////////////////

    //! @brief finds unconnected sub-topologies within this topology and returns them in a vector
    //! @return vector of sub-topologies
    util::ShPtrVector< Topology> Topology::GetSubTopologies() const
    {
      // instantiate the vector of sub-topologies
      util::ShPtrVector< Topology> sub_topologies_vector;

      // make a copy of the vertex data
      GraphType::VertexContainerType remaining_vertices( m_Graph.GetVertices());

      BCL_MessageDbg( "Creating sub-topologies");

      // while there are vertices remaining that are not part of any subgraph
      while( !remaining_vertices.IsEmpty())
      {
        // construct a vector of vertices that are reachable from the first element, remove that element from remaining
        util::ShPtr< GraphType> sp_subgraph( new GraphType( m_Graph.IsDirected()));

        // get the first vertex in the remaining vertices
        util::ShPtr< GraphType::VertexType> sp_first_vertex( remaining_vertices.FirstElement());

        // add this node and remove from the remaining vertices
        sp_subgraph->AddVertex( sp_first_vertex->GetData());
        remaining_vertices.Remove( remaining_vertices.Begin());

        // expand the subgraph as far as it can go
        ExpandSubGraph( sp_first_vertex, *sp_subgraph, remaining_vertices);

        // create the new topology
        util::ShPtr< Topology> sp_sub_topology( new Topology( *sp_subgraph));

        // output subgraph
        BCL_MessageDbg( "Subgraph found " + sp_sub_topology->GetIdentification());

        // add it to the vector
        sub_topologies_vector.PushBack( sp_sub_topology);
      }

      // end
      return sub_topologies_vector;
    }

    //! @brief creates a subtopology composed of the given SSEGeometryInterfaces
    //! @param ELEMENTS vector of elements that should be added to the subtopology
    //! @return ShPtr to a new SubTopology
    util::ShPtr< Topology> Topology::GetSubTopology
    (
      const util::SiPtrVector< const SSEGeometryInterface> &ELEMENTS
    ) const
    {
      // make sure all given elements are part of the m_Elements
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator itr( ELEMENTS.Begin()), itr_end( ELEMENTS.End());
        itr != itr_end; ++itr
      )
      {
        // if this is not found
        if( std::find( m_Elements.Begin(), m_Elements.End(), *itr) == m_Elements.End())
        {
          BCL_MessageStd
          (
            "Given element is not found in the topology" + ( *itr)->GetIdentification()
          );
        }
      }

      // create new topology
      util::ShPtr< Topology> sp_topology( new Topology( ELEMENTS));

      // set type and orientation
      sp_topology->SetType( m_Type);
      sp_topology->SetOrientationFromType();

      // construct a new subgraph
      GraphType subgraph;

      // iterate over the elements
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator itr( ELEMENTS.Begin()), itr_end( ELEMENTS.End());
        itr != itr_end; ++itr
      )
      {
        // add this vertex
        subgraph.AddVertex( *itr);
      }

      // iterate over the elements
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator itr_a( ELEMENTS.Begin()), itr_end( ELEMENTS.End());
        itr_a != itr_end; ++itr_a
      )
      {
        // iterate over all the other elements
        for
        (
          util::SiPtrVector< const SSEGeometryInterface>::const_iterator itr_b( itr_a + 1); itr_b != itr_end; ++itr_b
        )
        {
          // get the edge
          GraphType::EdgeType this_edge( m_Graph.FindEdge( *m_Graph.FindVertex( *itr_a), *m_Graph.FindVertex( *itr_b)));

          // if the edge is defined
          if( this_edge.IsDefined())
          {
            // then add it to the subgraph
            subgraph.AddEdge( *itr_a, *itr_b, this_edge.GetData());
            SSEGeometryPacking reverse_packing( this_edge.GetData());
            reverse_packing.Reverse();
            subgraph.AddEdge( *itr_b, *itr_a, reverse_packing);
          }
        }
      }

      // set the graph and return
      sp_topology->SetGraph( subgraph);
      return sp_topology;
    }

    //! @brief orders the elements in the topology
    //! @return whether ordering succeeded
    bool Topology::OrderElements()
    {
      // if there is only one element
      if( m_Elements.GetSize() == 1)
      {
        // then it's already ordered
        return true;
      }

      // first determine if this is a barrel or not
      // find all vertices that have one edge
      util::SiPtrVector< const GraphType::VertexType> terminal_vertices
      (
        m_Graph.GetVerticesWithNEdges( 1)
      );

      // also check the number of center_vertices with connectivity of 2
      const size_t nr_center_vertices( m_Graph.GetNumberVerticesWithNEdges( 2));

      // if the sum of nr_center_vertices and terminal_vertices is not equal to number of SSEs then we have a problem
      if( nr_center_vertices + terminal_vertices.GetSize() != m_Elements.GetSize())
      {
        BCL_MessageVrb
        (
          "This topology can't be ordered, #edge vertices: " +
          util::Format()( terminal_vertices.GetSize()) +
          " + #center_vertices: " + util::Format()( nr_center_vertices) +
          " != #total vertices: " + util::Format()( m_Elements.GetSize())
        )
        return false;
      }

      // store the first vertex
      const util::SiPtr< const GraphType::VertexType> first_vertex( *m_Graph.GetVertices().Begin());

      // initialize two vertex pointer, one for previous one for this one
      util::SiPtrVector< const GraphType::VertexType> seed_vertices;
      util::SiPtrVector< const GraphType::VertexType> next_seed_vertices( first_vertex);

      // initialize order vector
      util::SiPtrVector< const SSEGeometryInterface> ordered_elements;
      ordered_elements.PushBack( first_vertex->GetData());

      // while not all SSEGeometriess are collected in the order vector
      while( ordered_elements.GetSize() != m_Elements.GetSize())
      {
        // update seed vertices
        seed_vertices = next_seed_vertices;
        // reset the next seed vertices
        next_seed_vertices = util::SiPtrVector< GraphType::VertexType>();

        // iterate over seed vertices
        for
        (
          util::SiPtrVector< const GraphType::VertexType>::const_iterator
            seed_itr( seed_vertices.Begin()), seed_itr_end( seed_vertices.End());
          seed_itr != seed_itr_end; ++seed_itr
        )
        {
          BCL_MessageDbg( "seed is: " + ( *seed_itr)->GetData()->GetIdentification());

          // iterate over all connect edges
          for
          (
            GraphType::EdgeContainerType::const_iterator
              edge_itr( ( *seed_itr)->GetEdges().Begin()), edge_itr_end( ( *seed_itr)->GetEdges().End());
            edge_itr != edge_itr_end; ++edge_itr
          )
          {
            // store the target
            util::SiPtr< const GraphType::VertexType> sp_target_vertex( edge_itr->GetTarget());
            BCL_MessageDbg
            (
              "looking at edge to: " + sp_target_vertex->GetData()->GetIdentification()
            );

            // see if this vertex is already in the data
            util::SiPtrVector< const SSEGeometryInterface>::const_iterator search_itr
            (
              std::find( ordered_elements.Begin(), ordered_elements.End(), sp_target_vertex->GetData())
            );

            // if it's already in the ordered elements
            if( search_itr != ordered_elements.End())
            {
              // then skip
              continue;
            }

            // put this into next targets
            next_seed_vertices.PushBack( sp_target_vertex);

            // find the index of this_vertex in the order_vector
            const size_t index_this_vertex( ordered_elements.GetIndex( ( *seed_itr)->GetData()));

            // if it's first element
            if( index_this_vertex == 0)
            {
              // insert at the beginning
              ordered_elements.InsertElement( 0, sp_target_vertex->GetData());
            }
            // else if it's the last element
            else if( index_this_vertex == ordered_elements.GetSize() - 1)
            {
              // insert at the end
              ordered_elements.PushBack( sp_target_vertex->GetData());
            }
            // otherwise the order vector is wrong
            else
            {
              // there is a problem with the order vector warn the user and die
              BCL_MessageStd( "The ordered geometries is not correct for this topology!");
              return false;
            }
          } // edge_itr
        } // seed_itr
      }

      // if this point is reached the elements were ordered successfully
      // so update the internal elements and return
      m_Elements = ordered_elements;
      return true;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &Topology::Read( std::istream &ISTREAM)
    {
      // read members

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &Topology::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members

      // end
      return OSTREAM;
    }

    //! @brief write graphviz script
    //! @param OSTREAM the stream the script is written to
    //! @return the stream the script was written to
    std::ostream &Topology::WriteGraphVizScript
    (
      std::ostream &OSTREAM,
      const math::SumFunction< SSEGeometryPacking, double> &COLOR_EDGE
    ) const
    {
      OSTREAM << "Graph G {\n";
      OSTREAM << "overlap=scale\n"; // prevent nodes from overlapping
      OSTREAM << "splines=true\n"; // prevent edges from overlapping with nodes

      const util::Format color_format( util::Format().W( 5).FFP( 3));
      const util::Format seqid_format( util::Format().W( 3).R());
      const util::Format pos_format( util::Format().FFP( 1));

      // write vertices
      std::string nodes_helices( "{node [shape=circle,style=\"setlinewidth(5)\"]\n");
      std::string nodes_strand( "{node [shape=box,height=0.4,width=0.8,style=\"setlinewidth(5)\"]\n");

      int max_seqid( 0);
      storage::VectorND< 3, math::RunningMinMax< double> > min_max_coord;
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator
          ele_itr( m_Elements.Begin()), ele_itr_end( m_Elements.End());
        ele_itr != ele_itr_end;
        ++ele_itr
      )
      {
        min_max_coord( 0) += ( *ele_itr)->GetCenter()( 0);
        min_max_coord( 1) += ( *ele_itr)->GetCenter()( 1);
        min_max_coord( 2) += ( *ele_itr)->GetCenter()( 2);

        util::SiPtr< const SSE> ptr_sse( *ele_itr);

        // try to cast to sse
        if( ptr_sse.IsDefined())
        {
          max_seqid = std::max( max_seqid, ptr_sse->GetLastAA()->GetSeqID());
        }
      }

      // coordinate with largest range is outside of plane
      coord::Axis axis_a( coord::GetAxes().e_X);
      coord::Axis axis_b( coord::GetAxes().e_Y);
      {
        storage::Map< double, coord::Axis> width_axis;
        width_axis[ min_max_coord( 0).GetRange()] = coord::GetAxes().e_X;
        width_axis[ min_max_coord( 1).GetRange()] = coord::GetAxes().e_Y;
        width_axis[ min_max_coord( 2).GetRange()] = coord::GetAxes().e_Z;

        if( width_axis.GetSize() >= 2)
        {
          axis_a = width_axis.ReverseBegin()->second;
          axis_b = ( ++width_axis.ReverseBegin())->second;
          if( axis_a < axis_b)
          {
            std::swap( axis_a, axis_b);
          }
        }
      }

      const math::Range< double> seqid_range( 0.0, double( max_seqid));
      const util::ColorGradient color_gradient( seqid_range, util::GetColors().GetRainbow());
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator
          ele_itr( m_Elements.Begin()), ele_itr_end( m_Elements.End());
        ele_itr != ele_itr_end;
        ++ele_itr
      )
      {
        util::SiPtr< const SSE> ptr_sse( *ele_itr);
        std::string node;
        node += " \"" + ( *ele_itr)->GetIdentification() + "\" [label=\"";

        // try to cast to sse
        if( ptr_sse.IsDefined())
        {
          // label
          node += std::string( 1, ptr_sse->GetChainID()) + ' ';
          node += seqid_format( ptr_sse->GetFirstAA()->GetSeqID()) + '-';
          node += seqid_format( ptr_sse->GetLastAA()->GetSeqID()) + '\"';

          // color
          const double mid_seq_id( ( ptr_sse->GetFirstAA()->GetSeqID() + ptr_sse->GetLastAA()->GetSeqID()) / 2.0);
          const linal::Vector3D color( util::Colors::ConvertRGBToHSV( color_gradient( mid_seq_id)));
          node += ",color=\"" + color_format( color.X()) + ' ' + color_format( color.Y()) + ' ' + color_format( color.Z()) + '\"';
        }
        else
        {
          node += ( *ele_itr)->GetIdentification() + '\"';
        }
        node += ",pos=\"" + pos_format( ( *ele_itr)->GetCenter()( axis_a)) + ", " + pos_format( ( *ele_itr)->GetCenter()( axis_b)) + '\"';
        node += "]\n";

        if( ( *ele_itr)->GetType() == biol::GetSSTypes().HELIX)
        {
          nodes_helices += node;
        }
        else if( ( *ele_itr)->GetType() == biol::GetSSTypes().STRAND)
        {
          nodes_strand += node;
        }
      }
      nodes_helices += "}\n";
      nodes_strand += "}\n";

      OSTREAM << nodes_helices << '\n';
      OSTREAM << nodes_strand << '\n';

      // write edges
      storage::Set< std::string> edges;
      const util::ColorGradient edge_color_gradient( math::Range< double>( -1.0, 1.0), storage::Vector< util::Color>::Create( util::GetColors().e_Blue, util::GetColors().e_White, util::GetColors().e_Red));
      for
      (
        GraphType::VertexContainerType::const_iterator
          vert_itr( m_Graph.GetVertices().Begin()), vert_itr_end( m_Graph.GetVertices().End());
        vert_itr != vert_itr_end;
        ++vert_itr
      )
      {
        const util::SiPtr< const SSE> ptr_sse_a( ( *vert_itr)->GetData());
        double mid_seq_id_a( util::GetUndefined< double>());
        if( ptr_sse_a.IsDefined())
        {
          mid_seq_id_a = ( ptr_sse_a->GetFirstAA()->GetSeqID() + ptr_sse_a->GetLastAA()->GetSeqID()) * 0.5;
        }

        const std::string identification_a( ( *vert_itr)->GetData()->GetIdentification());

        for
        (
          GraphType::EdgeContainerType::const_iterator
            edge_itr( ( *vert_itr)->GetEdges().Begin()), edge_itr_end( ( *vert_itr)->GetEdges().End());
          edge_itr != edge_itr_end;
          ++edge_itr
        )
        {
          const std::string identification_b( edge_itr->GetTarget()->GetData()->GetIdentification());
          // draw only one connection
          if( identification_a > edge_itr->GetTarget()->GetData()->GetIdentification())
          {
            continue;
          }

          const std::string style
          (
            edge_itr->GetData().GetContactType() == contact::GetTypes().STRAND_STRAND ?
              "bold" : "dashed"
          );
          const util::SiPtr< const SSE> ptr_sse_b( edge_itr->GetTarget()->GetData());
          double width( 1.0);
          if( ptr_sse_b.IsDefined() && util::IsDefined( mid_seq_id_a))
          {
            const double mid_seq_id_b( ( ptr_sse_b->GetFirstAA()->GetSeqID() + ptr_sse_b->GetLastAA()->GetSeqID()) * 0.5);
            math::Range< double> width_range( 1.0, 10.0);
            width = width_range( math::Absolute( mid_seq_id_b - mid_seq_id_a), seqid_range);
          }

          const double score( COLOR_EDGE.operator()( edge_itr->GetData()));
          if( math::EqualWithinTolerance( score, 0.0)) // skip interactions with neutral score
          {
            continue;
          }

          const linal::Vector3D edge_color( util::Colors::ConvertRGBToHSV( edge_color_gradient( score))); // color

          std::stringstream ss;
          ss << '\"' << identification_a << "\" -- \"" << identification_b
             << "\" ["
             << "len=" << util::Format()( edge_itr->GetData().GetDistance() / 10.0)
             << ", weight=" << util::Format()( -edge_itr->GetData().GetDistance())
             << ", style=" << style
             << ", penwidth=" << width
             << ", color=\"" + color_format( edge_color.X()) + ' ' + color_format( edge_color.Y()) + ' ' + color_format( edge_color.Z()) + '\"'
             << "];";

          edges.Insert( ss.str());
        }
      }

      // iterate over edge strings
      for( storage::Set< std::string>::const_iterator itr( edges.Begin()), itr_end( edges.End()); itr != itr_end; ++itr)
      {
        OSTREAM << *itr << '\n';
      }

      OSTREAM << "}\n";

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    //! @brief builds a topology from the given vector of SSEGeometryInterface derived object, packer and criteria
    //! @param SSE_GEOMETRY_VECTOR SiPtrVector of SSEGeometryInterface derived objects
    //! @param PACKER SSEGeometryPackingPicker to be used to calculate the edges
    //! @param PACKING_CRITERIA criteria to decide whether the SSEPacking can be considered a connected edge
    //! @return topology graph constructed
    Topology::GraphType Topology::BuildTopologyGraphFromGeometries
    (
      const util::SiPtrVector< const SSEGeometryInterface> &SSE_GEOMETRY_VECTOR,
      const SSEGeometryPackingPicker &PACKER,
      const math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> &PACKING_CRITERIA
    )
    {
      // initialize a directed graph
      GraphType graph( true);

      BCL_MessageDbg( "adding SSEGeometries to the topology");

      // iterate over all the geometries to add the vertices
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator
          geometry_itr( SSE_GEOMETRY_VECTOR.Begin()), geometry_itr_end( SSE_GEOMETRY_VECTOR.End());
        geometry_itr != geometry_itr_end; ++geometry_itr
      )
      {
        // add the vertices for these geometries
        graph.AddVertex( *geometry_itr);
      }

      // iterate over all the geometries this time to add the edges
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator
          geometry_itr_a( SSE_GEOMETRY_VECTOR.Begin()), geometry_itr_end( SSE_GEOMETRY_VECTOR.End());
        geometry_itr_a != geometry_itr_end; ++geometry_itr_a
      )
      {
        for
        (
          util::SiPtrVector< const SSEGeometryInterface>::const_iterator geometry_itr_b( geometry_itr_a + 1);
          geometry_itr_b != geometry_itr_end; ++geometry_itr_b
        )
        {
          // calculate the packing
          SSEGeometryPacking this_packing( ( *PACKER)->operator()( **geometry_itr_a, **geometry_itr_b));

          // if this is a valid packing
          if( PACKING_CRITERIA( this_packing))
          {
            // add the edge
            graph.AddEdge( *geometry_itr_a, *geometry_itr_b, this_packing);
            // reverse the packing
            this_packing.Reverse();
            // add the other edge
            graph.AddEdge( *geometry_itr_b, *geometry_itr_a, this_packing);
          }
        }
      }

      return graph;
    }

    //! @brief builds a topology from the given vector of SSEGeometryInterface derived object, packer and criteria
    //! @param SSE_GEOMETRY_VECTOR SiPtrVector of SSEGeometryInterface derived objects
    //! @param PACKER SSEGeometryPackingPicker to be used to calculate the edges
    //! @param PACKING_CRITERIA criteria to decide whether the SSEPacking can be considered a connected edge
    //! @return topology constructed
    util::ShPtr< Topology> Topology::BuildTopologyFromGeometries
    (
      const util::SiPtrVector< const SSEGeometryInterface> &SSE_GEOMETRY_VECTOR,
      const SSEGeometryPackingPicker &PACKER,
      const math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> &PACKING_CRITERIA
    )
    {
      // construct a topology and return it
      return
        util::ShPtr< Topology>
        (
          new Topology( BuildTopologyGraphFromGeometries( SSE_GEOMETRY_VECTOR, PACKER, PACKING_CRITERIA))
        );
    }

    //! @brief builds a topology from the given protein model based on its amino acid contacts
    //! @param PROTEIN the protein model to use
    //! @return the topology
    util::ShPtr< Topology> Topology::BuildTopologyFromContacts( const ProteinModel &PROTEIN)
    {
      GraphType topology_graph( true);

      // iterate over all SSEs to add the vertices
      util::SiPtrVector< const SSE> sses( PROTEIN.GetSSEs());
      for
      (
        util::SiPtrVector< const SSE>::const_iterator itr( sses.Begin()), itr_end( sses.End());
        itr != itr_end; ++itr
      )
      {
        topology_graph.AddVertex( *itr);
      }

      contact::Map contact_map( PROTEIN, 0);
      for
      (
        util::SiPtrVector< const SSE>::const_iterator itr_sse_a( sses.Begin()), itr_sse_end( sses.End());
        itr_sse_a != itr_sse_end; ++itr_sse_a
      )
      {
        for
        (
          util::SiPtrVector< const SSE>::const_iterator itr_sse_b( itr_sse_a + 1);
          itr_sse_b != itr_sse_end; ++itr_sse_b
        )
        {
          if( contact::Map::IsInContact( contact_map, **itr_sse_a, **itr_sse_b))
          {
            SSEGeometryPackingPicker packer( GetSSEGeometryPackingPickers().e_BestInteractionWeight);
            SSEGeometryPacking this_packing( ( *packer)->operator()( **itr_sse_a, **itr_sse_b));
            topology_graph.AddEdge( *itr_sse_a, *itr_sse_b, this_packing);
            this_packing.Reverse();
            topology_graph.AddEdge( *itr_sse_b, *itr_sse_a, this_packing);
          }
        }
      }

      return util::ShPtr< Topology>( new Topology( topology_graph));
    }

    //! @brief collects the SiPtrVector of SSEGeometryInterfaces from the Graph vertex data
    //! @param GRAPH reference to the graph from which the elements vector will be collected
    //! @return the SiPtrVector of SSEGeometryInterfaces from the Graph vertex data
    util::SiPtrVector< const SSEGeometryInterface> Topology::GetElementsVectorFromGraph
    (
      const Topology::GraphType &GRAPH
    )
    {
      // initialize vector
      util::SiPtrVector< const SSEGeometryInterface> elements;

      // iterate over vertices
      for
      (
        Topology::GraphType::VertexContainerType::const_iterator
          vertex_itr( GRAPH.GetVertices().Begin()), vertex_itr_end( GRAPH.GetVertices().End());
        vertex_itr != vertex_itr_end; ++vertex_itr
      )
      {
        // pushback into the elements vector
        elements.PushBack( ( *vertex_itr)->GetData());
      }

      // end
      return elements;
    }

    //! @brief static function that calculates the center of a vector SSEGeometries
    //! @param GEOMETRY_VECTOR SiPtrVector of SSE Geometries
    //! @return linal::Vector3D that represents the center of the given geometries
    linal::Vector3D Topology::CalculateCenterOfGeometries
    (
      const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR
    )
    {
      // initialize center
      linal::Vector3D center;

      // iterate over geometries
      for
      (
        util::SiPtrVector< const SSEGeometryInterface>::const_iterator
          geometry_itr( GEOMETRY_VECTOR.Begin()), geometry_itr_end( GEOMETRY_VECTOR.End());
        geometry_itr != geometry_itr_end; ++geometry_itr
      )
      {
        // sum up the center
        center += ( *geometry_itr)->GetCenter();
      }

      // normalize by the number of geometries
      center /= double( GEOMETRY_VECTOR.GetSize());

      // end
      return center;
    }

    //! @brief expands the given subgraph starting from origin_vertex and updates the remaining vertices
    //! @param SP_ORIGIN_VERTEX SiPtr to the origin vertex from the complete graph
    //! @param SUB_GRAPH non-const reference to subgraph to be expanded
    //! @param REMAINING_VERTICES non-const reference to container of remaining vertices
    void Topology::ExpandSubGraph
    (
      const util::SiPtr< const Topology::GraphType::VertexType> &SP_ORIGIN_VERTEX,
      Topology::GraphType &SUB_GRAPH,
      Topology::GraphType::VertexContainerType &REMAINING_VERTICES
    ) const
    {
      // find the corresponding vertex to SP_ORIGIN_VERTEX from this sub-graph
      util::ShPtr< GraphType::VertexType> origin_vertex_subgraph
      (
        SUB_GRAPH.FindVertex( SP_ORIGIN_VERTEX->GetData())
      );

      BCL_Assert( origin_vertex_subgraph.IsDefined(), "couldn't find SP_ORIGIN_VERTEX in the subgraph");

      // iterate over the edges of the given origin vertex
      for
      (
        GraphType::EdgeContainerType::const_iterator
          edge_itr( SP_ORIGIN_VERTEX->GetEdges().Begin()), edge_itr_end( SP_ORIGIN_VERTEX->GetEdges().End());
        edge_itr != edge_itr_end; ++edge_itr
      )
      {
        // find the corresponding vertex in this sub-graph that has the same data as
        // the vertex pointed by the edge in the topology graph
        util::ShPtr< GraphType::VertexType> target_vertex_subgraph
        (
          SUB_GRAPH.FindVertex( edge_itr->GetTarget()->GetData())
        );

        // create a bool to store whether the target vertex was found
        bool target_vertex_found( target_vertex_subgraph.IsDefined());

        // if such a vertex does not exist yet in our sub-graph
        if( !target_vertex_found)
        {
          // create a corresponding vertex
          target_vertex_subgraph = util::ShPtr< GraphType::VertexType>
          (
            new GraphType::VertexType( edge_itr->GetTarget()->GetData())
          );

          // add this vertex to the subgraph
          BCL_Assert
          (
            SUB_GRAPH.AddVertex( target_vertex_subgraph),
            "The vertex was not added to the graph"
          );

          // remove it from the remaining vertices
          RemoveVertexFromVector( *edge_itr->GetTarget(), REMAINING_VERTICES);

          // make a copy of the packing
          SSEGeometryPacking this_packing( edge_itr->GetData());

          // add the edge from origin to target
          origin_vertex_subgraph->AddEdge( target_vertex_subgraph, this_packing);

          // reverse the packing and add the edge from target to origin
          this_packing.Reverse();
          target_vertex_subgraph->AddEdge( origin_vertex_subgraph, this_packing);

          // keep expanding the subgraph
          ExpandSubGraph( edge_itr->GetTarget(), SUB_GRAPH, REMAINING_VERTICES);

        }
        // else if the vertex was found but the edges are not found
        else if( !origin_vertex_subgraph->FindEdge( *target_vertex_subgraph).IsDefined())
        {
          // make a copy of the packing
          SSEGeometryPacking this_packing( edge_itr->GetData());

          // add the edge from origin to target
          origin_vertex_subgraph->AddEdge( target_vertex_subgraph, this_packing);

          // reverse the packing and add the edge from target to origin
          this_packing.Reverse();
          target_vertex_subgraph->AddEdge( origin_vertex_subgraph, this_packing);
        }
      }
    }

    //! @brief finds and removes the vertex from a vector of vertices
    //! @param VERTEX vertex to be searched
    //! @param VERTEX_VECTOR Vertex vector to be searched
    void Topology::RemoveVertexFromVector
    (
      const Topology::GraphType::VertexType &VERTEX,
      Topology::GraphType::VertexContainerType &VERTEX_VECTOR
    )
    {
      // iterate over the vertex vector
      for
      (
        GraphType::VertexContainerType::iterator
          vertex_itr( VERTEX_VECTOR.Begin()), vertex_itr_end( VERTEX_VECTOR.End());
        vertex_itr != vertex_itr_end; ++vertex_itr
      )
      {
        // if has the same vertex data
        if( vertex_itr->GetPointer() == &VERTEX)
        {
          // remove this element and break out of loop
          VERTEX_VECTOR.RemoveElement( vertex_itr);
          return;
        }
      }
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_topology_distance.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_protein_model.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! single instance of that class
    const util::SiPtr< const util::ObjectInterface> TopologyDistance::s_Instance
    (
      GetObjectInstances().AddInstance( new TopologyDistance())
    );

    //! @brief returns default distance cutoff
    //! @return default distance cutoff
    double TopologyDistance::GetDefaultDistanceCutoff()
    {
      return 5.0;
    }

    //! @brief returns default angle cutoff
    //! @return default angle cutoff
    double TopologyDistance::GetDefaultAngleCutoff()
    {
      return math::g_Pi / 2.0;
    }

  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief default constructor
    TopologyDistance::TopologyDistance() :
      m_DistanceCutoff( GetDefaultDistanceCutoff()),
      m_AngleCutoff( GetDefaultAngleCutoff())
    {
    }

    //! @brief constructor from a distance cutoff and angle cutoff
    //! @param DISTANCE_CUTOFF distance cutoff
    //! @param ANGLE_CUTOFF angle cutoff
    TopologyDistance::TopologyDistance( const double DISTANCE_CUTOFF, const double ANGLE_CUTOFF) :
      m_DistanceCutoff( DISTANCE_CUTOFF),
      m_AngleCutoff( ANGLE_CUTOFF)
    {
    }

    //! @brief Clone function
    //! @return pointer to new TopologyDistance
    TopologyDistance *TopologyDistance::Clone() const
    {
      return new TopologyDistance( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &TopologyDistance::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief returns distance cutoff
    //! @return distance cutoff
    double TopologyDistance::GetDistanceCutoff() const
    {
      return m_DistanceCutoff;
    }

    //! @brief returns angle cutoff
    //! @return angle cutoff
    double TopologyDistance::GetAngleCutoff() const
    {
      return m_AngleCutoff;
    }

  ////////////////
  // operations //
  ////////////////

  ///////////////
  // operators //
  ///////////////

    //! @brief calculates the distance between two given protein models
    //! @param MODEL ProteinModel for which distance to given TEMPLATE_MODEL will be calculated
    //! @param TEMPLATE_MODEL ProteinModel that will be used as a template
    double TopologyDistance::operator()( const ProteinModel &MODEL, const ProteinModel &TEMPLATE_MODEL) const
    {

      // static variable to hold missing SSE penalty
      static const double s_penalty_missing_penalty( 2.0);

      // calculate maximum penalty
      const double maximum_penalty
      (
        ( TEMPLATE_MODEL.GetNumberSSE( biol::GetSSTypes().HELIX) + TEMPLATE_MODEL.GetNumberSSE( biol::GetSSTypes().STRAND))
        * s_penalty_missing_penalty
      );

      // initialize distance
      double model_topology_distance( 0.0);

      // iterate over chains in model
      for
      (
        util::ShPtrVector< Chain>::const_iterator temp_chain_itr( TEMPLATE_MODEL.GetChains().Begin()),
          temp_chain_itr_end( TEMPLATE_MODEL.GetChains().End());
        temp_chain_itr != temp_chain_itr_end; ++temp_chain_itr
      )
      {
        // make a reference to this chain
        const Chain &temp_chain( **temp_chain_itr);

        // get the corresponding chain from the model
        const util::ShPtr< Chain> sp_chain( MODEL.GetChain( temp_chain.GetChainID()));

        // if the chain do not exist
        if( !sp_chain.IsDefined())
        {
          // add penalty to score
          BCL_MessageDbg( "Following Chain is missing: " + util::Format()( temp_chain.GetChainID()));
          model_topology_distance +=
            s_penalty_missing_penalty *
            ( temp_chain.GetNumberSSE( biol::GetSSTypes().HELIX) + temp_chain.GetNumberSSE( biol::GetSSTypes().STRAND));
          continue;
        }

        // get the distance between these two chains
        model_topology_distance += operator()( *sp_chain, temp_chain);
      }

      // normalize by the maximum penalty
      model_topology_distance = 100 * ( model_topology_distance / maximum_penalty);

      // end
      return model_topology_distance;
    }

    //! @brief calculates the distance between two given chains
    //! @param CHAIN Chain for which distance to given TEMPLATE_CHAIN will be calculated
    //! @param TEMPLATE_CHAIN Chain that will be used as a template
    double TopologyDistance::operator()( const Chain &CHAIN, const Chain &TEMPLATE_CHAIN) const
    {
      // initialize static penalties
      static const double penalty_missing_sse( 2.0);

      // initialize distance
      double chain_topology_distance( 0.0);

      // otherwise iterate over SSEs in the template model
      for
      (
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator
          temp_sse_itr( TEMPLATE_CHAIN.GetData().Begin()), temp_sse_itr_end( TEMPLATE_CHAIN.GetData().End());
        temp_sse_itr != temp_sse_itr_end; ++temp_sse_itr
      )
      {
        // skip if not a helix or a strand
        if( !( *temp_sse_itr)->GetType()->IsStructured())
        {
          continue;
        }

        // find this SSE in the model
        storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap>::const_iterator sse_itr
        (
          std::find_if( CHAIN.GetData().Begin(), CHAIN.GetData().End(), SSECompare( **temp_sse_itr))
        );

        // if such an SSE is not found
        if( sse_itr == CHAIN.GetData().End())
        {
          BCL_MessageDbg( "Following SSE is missing: " + ( *temp_sse_itr)->GetIdentification());
          chain_topology_distance += penalty_missing_sse;
          continue;
        }

        // calculate the topology distance for these two SSEs and sum it up
        chain_topology_distance += operator()( **sse_itr, **temp_sse_itr);
      }

      // end
      return chain_topology_distance;
    }

    //! @brief calculates the distance between two given SSEs
    //! @param SS_ELEMENT for which distance to given TEMPLATE_SS_ELEMENT will be calculated
    //! @param TEMPLATE_SS_ELEMENT SSE that will be used as a template
    double TopologyDistance::operator()( const SSE &SS_ELEMENT, const SSE &TEMPLATE_SS_ELEMENT) const
    {
      // initialize static penalties
      static const double penalty_dislocated_sse( 1.0);
      static const double penalty_flipped_sse( 0.5);

      // initialize distance
      double sse_topology_distance( 0.0);

      // calculate the distance between centers
      const double sse_pair_distance( linal::Distance( TEMPLATE_SS_ELEMENT.GetCenter(), SS_ELEMENT.GetCenter()));

      // if distance is more than the threshold
      if( sse_pair_distance > m_DistanceCutoff)
      {
        BCL_MessageDbg( "Following SSE is dislocated: " + SS_ELEMENT.GetIdentification());
        // add the dislocated penalty
        sse_topology_distance += penalty_dislocated_sse;
      }
      // if the distance is less than cutoff meaning SSE is in the same spot relatively
      else
      {
        // check if the SSE was flipped
        // calculate the angle deviation between SSEs
        const double sse_pair_angle
        (
          linal::ProjAngle
          (
            TEMPLATE_SS_ELEMENT.GetAxis( coord::GetAxes().e_Z), SS_ELEMENT.GetAxis( coord::GetAxes().e_Z)
          )
        );

        // if the angle deviation is larger than the angle cutoff
        if( sse_pair_angle > m_AngleCutoff)
        {
          BCL_MessageDbg( "Following SSE is flipped: " + SS_ELEMENT.GetIdentification());
          // add the flipped SSE threshold
          sse_topology_distance += penalty_flipped_sse;
        }
      }

      BCL_MessageDbg
      (
        "topology distance for SSE " + SS_ELEMENT.GetIdentification() + " is : " + util::Format()( sse_topology_distance)
      );

      // end
      return sse_topology_distance;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &TopologyDistance::Read( std::istream &ISTREAM)
    {
      // read members
      io::Serialize::Read( m_DistanceCutoff, ISTREAM);
      io::Serialize::Read( m_AngleCutoff, ISTREAM);

      // end
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM outputstream to write to
    //! @param INDENT number of indentations
    //! @return outputstream which was written to
    std::ostream &TopologyDistance::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      // write members
      io::Serialize::Write( m_DistanceCutoff, OSTREAM, INDENT) << '\n';
      io::Serialize::Write( m_AngleCutoff, OSTREAM, INDENT);

      // end
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_voxel_grid_aa.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "biol/bcl_biol_aa_base.h"
#include "graph/bcl_graph_const_graph.h"
#include "graph/bcl_graph_undirected_edge.h"
#include "math/bcl_math_running_average_sd.h"
#include "score/bcl_score_aa_pair_clash.h"
#include "score/bcl_score_aa_pair_hi_res_clash.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    //! @brief calculates AA pair clash score for a vector of AAs via Slicelist usage
    //! @note NOTE: This might have to be moved into a scoring class derived from protein model
    //! @param AAS vector of pointers to the AAs
    //! @return score of the AA pair clash
    double VoxelGridAA::GetAAClashScore( const util::SiPtrVector< const biol::AABase> &AAS)
    {
      // amino acid clash score
      const score::AAPairClash &clash_score( score::AAPairClash::GetInstance());

      double score( 0.0);

      for( size_t i( 0); i < AAS.GetSize(); ++i)
      {
        storage::Vector< storage::Pair< util::SiPtr< const biol::AABase>, double> >
          res( util::VoxelGrid< biol::AABase>::GetNeighbors( *AAS( i), clash_score.GetDistanceCutoff()));
        for( size_t j( 0), r_size( res.GetSize()); j < r_size; ++j)
        {
          const storage::Pair< util::SiPtr< const biol::AABase>, double> &pair( res( j));
          const double closest_distance
          (
            score::AAPairClash::GetInstance().GetClosestDistance( AAS( i)->GetType(), pair.First()->GetType())
          );
          score += score::AAPairClash::GetInstance().CalculateRepulsiveTerm( pair.Second(), closest_distance);
        }
      }

      return score;
    }

    //! @brief calculates AA pair clash score for a vector of AAs via Slicelist usage
    //! @note NOTE: This might have to be moved into a scoring class derived from protein model
    //! @param AAS vector of pointers to the AAs
    //! @return score of the AA pair clash
    double VoxelGridAA::GetAAClashScore()
    {
      // amino acid clash score
      const score::AAPairClash &clash_score( score::AAPairClash::GetInstance());

      double score( 0.0);

      storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> >
        res( util::VoxelGrid< biol::AABase>::GetNeighbors( clash_score.GetDistanceCutoff()));
      for( size_t j( 0), r_size( res.GetSize()); j < r_size; ++j)
      {
        const storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double>
          &triplet( res( j));
        const double closest_distance
        (
          clash_score.GetClosestDistance( triplet.First()->GetType(), triplet.Second()->GetType())
        );
        score += clash_score.CalculateRepulsiveTerm( triplet.Third(), closest_distance);
      }

      return score;
    }

    //! @brief Get a matrix with counts of AAs interacting at particular distance between each SSE
    linal::Matrix< float> VoxelGridAA::GetSSEInteractionMatrix
    (
      const util::SiPtrVector< const SSE> &SSES,
      const util::SiPtrVector< const biol::AABase> &AAS,
      const size_t &SEQ_EXCLUSION,
      const double &RESOLUTION,
      const bool   &CONSIDER_LOOPS,
      const double &MIN_CONTACT_P,
      const bool   &CONSIDER_POINT_CONTACTS,
      const bool   &MUTUALLY_CLOSEST_DIFF_SSE_CONNECTIONS_ONLY
    )
    {
      bool prev_prefer_ca( m_PreferCA);
      m_PreferCA = true;
      this->SetObjects( AAS);
      storage::Vector< int> first_ids( size_t( 128), std::numeric_limits< int>::max());
      storage::Vector< int> last_ids( size_t( 128), -std::numeric_limits< int>::max());
      for( auto itr( AAS.Begin()), itr_end( AAS.End()); itr != itr_end; ++itr)
      {
        size_t chain_id( ( *itr)->GetChainID());
        if( first_ids( chain_id) > ( *itr)->GetSeqID())
        {
          first_ids( chain_id) = ( *itr)->GetSeqID();
        }
        if( last_ids( chain_id) < ( *itr)->GetSeqID())
        {
          last_ids( chain_id) = ( *itr)->GetSeqID();
        }
      }

      // hash sses for all amino acid ids
      storage::Vector< storage::Vector< size_t> > sse_id( size_t( 128));
      storage::Vector< storage::Vector< size_t> > have_used( size_t( 128));
      for( size_t chain_id( 0), mx_chain_id( first_ids.GetSize()); chain_id < mx_chain_id; ++chain_id)
      {
        if( last_ids( chain_id) >= first_ids( chain_id))
        {
          sse_id( chain_id).Resize( last_ids( chain_id) - first_ids( chain_id) + 1, util::GetUndefined< size_t>());
          if( MUTUALLY_CLOSEST_DIFF_SSE_CONNECTIONS_ONLY)
          {
            have_used( chain_id).Resize( last_ids( chain_id) - first_ids( chain_id) + 1, size_t( 0));
          }
        }
      }

      size_t current_sse_id( 0);
      for
      (
        auto itr_sses( SSES.Begin()), itr_sses_end( SSES.End());
        itr_sses != itr_sses_end;
        ++itr_sses, ++current_sse_id
      )
      {
        // skip loops unless they're desired
        if( !CONSIDER_LOOPS && !( *itr_sses)->GetType()->IsStructured())
        {
          --current_sse_id;
          continue;
        }
        size_t chain_id( ( *itr_sses)->GetChainID());
        const int first_id( first_ids( chain_id));
        storage::Vector< size_t> &chain_vec( sse_id( chain_id));

        int seq_id_start( ( *itr_sses)->GetFirstAA()->GetSeqID() - first_id);
        int seq_id_end( ( *itr_sses)->GetLastAA()->GetSeqID() - first_id);
        for( int pos( seq_id_start); pos <= seq_id_end; ++pos)
        {
          chain_vec( pos) = current_sse_id;
        }
      }

      const size_t n_sses( current_sse_id);
      linal::Matrix< float> interactions( n_sses, n_sses, float( 0));
      score::AAPairHiResClash clash;
      typedef storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> >
              t_Vector;
      t_Vector neighbors( GetNeighbors( RESOLUTION));
      storage::Vector< storage::Vector< math::RunningMinMax< int> > > aas_involved
      (
        n_sses,
        storage::Vector< math::RunningMinMax< int> >( n_sses)
      );
      // if only looking for mutually closest
      if( MUTUALLY_CLOSEST_DIFF_SSE_CONNECTIONS_ONLY)
      {
        // first, remove intra-sse connections and other connections that are simply too close
        size_t n_used( 0);
        for
        (
          auto itr_valid( neighbors.Begin()), itr_placement( neighbors.Begin()), itr_end( neighbors.End());
          itr_valid != itr_end;
          ++itr_valid
        )
        {
          const auto &triplet( *itr_valid);
          const size_t chain_id_a( triplet.First()->GetChainID()), chain_id_b( triplet.Second()->GetChainID());
          const size_t sse1( sse_id( chain_id_a)( triplet.First()->GetSeqID() - first_ids( chain_id_a)));
          const size_t sse2( sse_id( chain_id_b)( triplet.Second()->GetSeqID() - first_ids( chain_id_b)));
          if( sse1 == sse2)
          {
            continue;
          }
          if( biol::SequenceSeparation( *triplet.First(), *triplet.Second()) < SEQ_EXCLUSION)
          {
            // ignore adjacent aas
            continue;
          }
          if( !CONSIDER_LOOPS && !util::IsDefined( std::max( sse1, sse2)))
          {
            continue;
          }
          if( itr_placement != itr_valid)
          {
            *itr_placement = *itr_valid;
          }
          ++itr_placement;
          ++n_used;
        }
        neighbors.Resize( n_used);

        // Now sort connections by distance
        neighbors.Sort( storage::LessThanThird());

        // go through connections between sses in order of ascending distance
        for
        (
          auto itr_valid( neighbors.Begin()), itr_end( neighbors.End());
          itr_valid != itr_end;
          ++itr_valid
        )
        {
          const auto &triplet( *itr_valid);
          const size_t chain_id_a( triplet.First()->GetChainID()), chain_id_b( triplet.Second()->GetChainID());
//            BCL_MessageStd
//            (
//              triplet.First()->GetIdentification()
//              + " " + triplet.Second()->GetIdentification()
//              + " " + util::Format()( triplet.Third())
//            );
          size_t &have_used_a( have_used( chain_id_a)( triplet.First()->GetSeqID() - first_ids( chain_id_a)));
          size_t &have_used_b( have_used( chain_id_b)( triplet.Second()->GetSeqID() - first_ids( chain_id_b)));
          if( have_used_a && have_used_b)
          {
            continue;
          }
          have_used_a = have_used_b = 1;
          const size_t sse1( sse_id( chain_id_a)( triplet.First()->GetSeqID() - first_ids( chain_id_a)));
          const size_t sse2( sse_id( chain_id_b)( triplet.Second()->GetSeqID() - first_ids( chain_id_b)));
          if( !CONSIDER_LOOPS && ( !util::IsDefined( sse1) || !util::IsDefined( sse2)))
          {
            continue;
          }
          aas_involved( sse1)( sse2) += ( triplet.First()->GetSeqID());
          aas_involved( sse2)( sse1) += ( triplet.Second()->GetSeqID());
        }
      }
      else
      {
        for( auto itr_valid( neighbors.Begin()), itr_end( neighbors.End()); itr_valid != itr_end; ++itr_valid)
        {
          const auto &triplet( *itr_valid);
          const size_t chain_id_a( triplet.First()->GetChainID()), chain_id_b( triplet.Second()->GetChainID());
          const size_t sse1( sse_id( chain_id_a)( triplet.First()->GetSeqID() - first_ids( chain_id_a)));
          const size_t sse2( sse_id( chain_id_b)( triplet.Second()->GetSeqID() - first_ids( chain_id_b)));
          if( !util::IsDefined( sse1) || !util::IsDefined( sse2))
          {
            continue;
          }
          if( sse1 == sse2)
          {
            continue;
          }
          if( biol::SequenceSeparation( *triplet.First(), *triplet.Second()) < SEQ_EXCLUSION)
          {
            // ignore adjacent aas
            continue;
          }
          const double p( clash.GetContactProbability( *triplet.First(), *triplet.Second(), triplet.Third()));
          //          BCL_MessageStd
          //          (
          //            triplet.First()->GetIdentification()
          //            + " " + triplet.Second()->GetIdentification()
          //            + " " + util::Format()( p)
          //            + " " + util::Format()( triplet.Third())
          //          );
          if( p > MIN_CONTACT_P)
          {
            aas_involved( sse1)( sse2) += ( triplet.First()->GetSeqID());
            aas_involved( sse2)( sse1) += ( triplet.Second()->GetSeqID());
          }
        }
      }
      for( size_t i( 0); i < n_sses; ++i)
      {
        for( size_t j( i + 1); j < n_sses; ++j)
        {
          const auto &set_ij( aas_involved( i)( j));
          if( set_ij.GetMin() > set_ij.GetMax())
          {
            continue;
          }
          const size_t ij_range( set_ij.GetRange() + 1);
          const auto &set_ji( aas_involved( j)( i));
          const size_t ji_range( set_ji.GetRange() + 1);
          const size_t min_sz( std::min( ij_range, ji_range));
          const size_t interaction_size
          (
            MUTUALLY_CLOSEST_DIFF_SSE_CONNECTIONS_ONLY
            ? std::max( ( ij_range + ji_range) / 2, min_sz)
            : min_sz
          );
          if( CONSIDER_POINT_CONTACTS || min_sz > size_t( 2))
          {
            interactions( i, j) = interactions( j, i) = interaction_size;
          }
        }
      }
      m_PreferCA = prev_prefer_ca;

      return interactions;
    }

    //! @brief Get the SSE connections
    storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> >
    VoxelGridAA::GetSSEConnections
    (
      const util::SiPtrVector< const SSE> &SSES,
      const util::SiPtrVector< const biol::AABase> &AAS,
      const size_t &SEQ_EXCLUSION,
      const double &RESOLUTION,
      const bool   &CONSIDER_LOOPS,
      const bool   &MUTUALLY_CLOSEST_DIFF_SSE_CONNECTIONS_ONLY,
      const bool   &CONSIDER_INTRA_LOOP_CLASHES
    )
    {
      this->SetObjects( AAS);
      storage::Vector< int> first_ids( size_t( 128), std::numeric_limits< int>::max());
      storage::Vector< int> last_ids( size_t( 128), -std::numeric_limits< int>::max());
      for( auto itr( AAS.Begin()), itr_end( AAS.End()); itr != itr_end; ++itr)
      {
        size_t chain_id( ( *itr)->GetChainID());
        if( first_ids( chain_id) > ( *itr)->GetSeqID())
        {
          first_ids( chain_id) = ( *itr)->GetSeqID();
        }
        if( last_ids( chain_id) < ( *itr)->GetSeqID())
        {
          last_ids( chain_id) = ( *itr)->GetSeqID();
        }
      }

      // hash sses for all amino acid ids
      storage::Vector< storage::Vector< size_t> > sse_id( size_t( 128));
      storage::Vector< storage::Vector< double> > min_distance( size_t( 128));
      for( size_t chain_id( 0), mx_chain_id( first_ids.GetSize()); chain_id < mx_chain_id; ++chain_id)
      {
        if( last_ids( chain_id) >= first_ids( chain_id))
        {
          sse_id( chain_id).Resize( last_ids( chain_id) - first_ids( chain_id) + 1, util::GetUndefined< size_t>());
          if( MUTUALLY_CLOSEST_DIFF_SSE_CONNECTIONS_ONLY)
          {
            min_distance( chain_id).Resize( last_ids( chain_id) - first_ids( chain_id) + 1, math::GetHighestBoundedValue< double>());
          }
        }
      }

      size_t current_sse_id( 0);
      for
      (
        auto itr_sses( SSES.Begin()), itr_sses_end( SSES.End());
        itr_sses != itr_sses_end;
        ++itr_sses, ++current_sse_id
      )
      {
        // skip loops (leave them as undefined, since they are not part of a real sse)
        if( !( *itr_sses)->GetType()->IsStructured() && ( !CONSIDER_LOOPS || CONSIDER_INTRA_LOOP_CLASHES))
        {
          continue;
        }
        size_t chain_id( ( *itr_sses)->GetChainID());
        const int first_id( first_ids( chain_id));
        storage::Vector< size_t> &chain_vec( sse_id( chain_id));

        int seq_id_start( ( *itr_sses)->GetFirstAA()->GetSeqID() - first_id);
        int seq_id_end( ( *itr_sses)->GetLastAA()->GetSeqID() - first_id);
        for( int pos( seq_id_start); pos <= seq_id_end; ++pos)
        {
          chain_vec( pos) = current_sse_id;
        }
      }

      typedef storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> >
              t_Vector;
      t_Vector neighbors( GetNeighbors( RESOLUTION));
      typename t_Vector::iterator itr_valid( neighbors.Begin()),
                                  itr_placement( neighbors.Begin()),
                                  itr_end( neighbors.End());
      for( ; itr_valid != itr_end; ++itr_valid)
      {
        const auto &triplet( *itr_valid);
        const size_t chain_id_a( triplet.First()->GetChainID()), chain_id_b( triplet.Second()->GetChainID());
        const size_t sse1( sse_id( chain_id_a)( triplet.First()->GetSeqID() - first_ids( chain_id_a)));
        const size_t sse2( sse_id( chain_id_b)( triplet.Second()->GetSeqID() - first_ids( chain_id_b)));
        if( !CONSIDER_LOOPS && ( !util::IsDefined( sse1) || !util::IsDefined( sse2)))
        {
          continue;
        }
        if( sse1 == sse2 && ( !CONSIDER_LOOPS || util::IsDefined( sse1)))
        {
          continue;
        }
        if( biol::SequenceSeparation( *triplet.First(), *triplet.Second()) < SEQ_EXCLUSION)
        {
          // ignore adjacent aas
          continue;
        }
        if( itr_placement != itr_valid)
        {
          *itr_placement = *itr_valid;
        }
        ++itr_placement;
      }
      neighbors.Resize( std::distance( neighbors.Begin(), itr_placement));
      if( MUTUALLY_CLOSEST_DIFF_SSE_CONNECTIONS_ONLY)
      {
        for( auto itr( neighbors.Begin()), itr_end( neighbors.End()); itr != itr_end; ++itr)
        {
          const auto &triplet( *itr_valid);
          const size_t chain_id_a( triplet.First()->GetChainID()), chain_id_b( triplet.Second()->GetChainID());
          double &min_distance_a( min_distance( chain_id_a)( triplet.First()->GetSeqID() - first_ids( chain_id_a)));
          double &min_distance_b( min_distance( chain_id_b)( triplet.Second()->GetSeqID() - first_ids( chain_id_b)));
          min_distance_a = std::min( min_distance_a, triplet.Third());
          min_distance_b = std::min( min_distance_b, triplet.Third());
        }
        itr_valid = neighbors.Begin();
        itr_placement = neighbors.Begin();
        itr_end = neighbors.End();
        for( ; itr_valid != itr_end; ++itr_valid)
        {
          const auto &triplet( *itr_valid);
          const size_t chain_id_a( triplet.First()->GetChainID()), chain_id_b( triplet.Second()->GetChainID());
          const double &min_distance_a( min_distance( chain_id_a)( triplet.First()->GetSeqID() - first_ids( chain_id_a)));
          const double &min_distance_b( min_distance( chain_id_b)( triplet.Second()->GetSeqID() - first_ids( chain_id_b)));
          if( triplet.Third() <= min_distance_a && triplet.Third() <= min_distance_b)
          {
            if( itr_placement != itr_valid)
            {
              *itr_placement = *itr_valid;
            }
            ++itr_placement;
          }
        }
        neighbors.Resize( std::distance( neighbors.Begin(), itr_placement));
      }
      return neighbors;
    }

    //! @brief Get the SSE connections
    size_t VoxelGridAA::GetMinSSEMovesToRemoveClashes
    (
      const util::SiPtrVector< const SSE> &SSES,
      const util::SiPtrVector< const biol::AABase> &AAS,
      const bool   &CONSIDER_LOOPS
    )
    {
      this->SetObjects( AAS);
      storage::Vector< int> first_ids( size_t( 128), std::numeric_limits< int>::max());
      storage::Vector< int> last_ids( size_t( 128), -std::numeric_limits< int>::max());
      for( auto itr( AAS.Begin()), itr_end( AAS.End()); itr != itr_end; ++itr)
      {
        size_t chain_id( ( *itr)->GetChainID());
        if( first_ids( chain_id) > ( *itr)->GetSeqID())
        {
          first_ids( chain_id) = ( *itr)->GetSeqID();
        }
        if( last_ids( chain_id) < ( *itr)->GetSeqID())
        {
          last_ids( chain_id) = ( *itr)->GetSeqID();
        }
      }

      // hash sses for all amino acid ids
      storage::Vector< storage::Vector< size_t> > sse_id( size_t( 128));
      for( size_t chain_id( 0), mx_chain_id( first_ids.GetSize()); chain_id < mx_chain_id; ++chain_id)
      {
        if( last_ids( chain_id) >= first_ids( chain_id))
        {
          sse_id( chain_id).Resize( last_ids( chain_id) - first_ids( chain_id) + 1, util::GetUndefined< size_t>());
        }
      }

      size_t current_sse_id( 0);
      for
      (
        auto itr_sses( SSES.Begin()), itr_sses_end( SSES.End());
        itr_sses != itr_sses_end;
        ++itr_sses, ++current_sse_id
      )
      {
        // skip loops unless they're desired
        if( !CONSIDER_LOOPS && !( *itr_sses)->GetType()->IsStructured())
        {
          continue;
        }
        size_t chain_id( ( *itr_sses)->GetChainID());
        const int first_id( first_ids( chain_id));
        storage::Vector< size_t> &chain_vec( sse_id( chain_id));

        int seq_id_start( ( *itr_sses)->GetFirstAA()->GetSeqID() - first_id);
        int seq_id_end( ( *itr_sses)->GetLastAA()->GetSeqID() - first_id);
        for( int pos( seq_id_start); pos <= seq_id_end; ++pos)
        {
          chain_vec( pos) = current_sse_id;
        }
      }

      auto neighbors( GetNeighbors( 4.5));
      storage::Set< graph::UndirectedEdge< size_t> > edges;
      score::AAPairHiResClash clash;
      for( auto itr_valid( neighbors.Begin()), itr_end( neighbors.End()); itr_valid != itr_end; ++itr_valid)
      {
        const auto &triplet( *itr_valid);
        const size_t chain_id_a( triplet.First()->GetChainID()), chain_id_b( triplet.Second()->GetChainID());
        const size_t sse1( sse_id( chain_id_a)( triplet.First()->GetSeqID() - first_ids( chain_id_a)));
        const size_t sse2( sse_id( chain_id_b)( triplet.Second()->GetSeqID() - first_ids( chain_id_b)));
        if( !util::IsDefined( sse1) || !util::IsDefined( sse2))
        {
          continue;
        }
        if( sse1 == sse2)
        {
          continue;
        }
        if( biol::SequenceSeparation( *triplet.First(), *triplet.Second()) < 1)
        {
          // ignore adjacent aas
          continue;
        }
        if( clash( *triplet.First(), *triplet.Second(), triplet.Third()) > 0.05)
        {
          edges.InsertElement( graph::UndirectedEdge< size_t>( sse1, sse2, size_t( 1)));
        }
      }
      graph::ConstGraph< size_t, size_t> clash_graph
      (
        storage::CreateIndexVector( SSES.GetSize()),
        storage::Vector< graph::UndirectedEdge< size_t> >( edges.Begin(), edges.End()),
        0
      );
      if( clash_graph.NumEdges() < 2)
      {
        return clash_graph.NumEdges();
      }
      size_t vertex_cover_size( 0);
      while( clash_graph.NumEdges())
      {
        bool had_tree_nodes( false);
        size_t max_node_size( 0), max_node_id( 0);
        // run through the graph; prune any leaf nodes from any sub-trees in the graph
        for( size_t i( 0), n_sses( SSES.GetSize()); i < n_sses; ++i)
        {
          const size_t n_neigh( clash_graph.GetNeighborIndices( i).GetSize());
          if( n_neigh == size_t( 1))
          {
            const size_t neighbor( clash_graph.GetNeighborIndices( i).FirstElement());
            ++vertex_cover_size;
            clash_graph.RemoveAllEdges( neighbor);
            had_tree_nodes = true;
          }
          else if( n_neigh > max_node_size)
          {
            max_node_size = n_neigh;
            max_node_id = i;
          }
        }
        if( !had_tree_nodes)
        {
          // no tree nodes. Approximation : select the node with the highest number of edges and add it to the cover
          ++vertex_cover_size;
          clash_graph.RemoveAllEdges( max_node_id);
        }
      }
      return vertex_cover_size;
    }

    //! @brief Get the SSE connections
    storage::Vector< storage::Pair< util::SiPtr< const SSE>, linal::Vector3D> >
    VoxelGridAA::GetMinSSEMoveIDsToRemoveClashes
    (
      const util::SiPtrVector< const SSE> &SSES,
      const util::SiPtrVector< const biol::AABase> &AAS,
      const bool   &CONSIDER_LOOPS
    )
    {
      // options that control how the optimal movement from one sse away from another is computed.
      static bool s_use_sse_level_moves( false);
      this->SetObjects( AAS);
      storage::Vector< int> first_ids( size_t( 128), std::numeric_limits< int>::max());
      storage::Vector< int> last_ids( size_t( 128), -std::numeric_limits< int>::max());
      for( auto itr( AAS.Begin()), itr_end( AAS.End()); itr != itr_end; ++itr)
      {
        size_t chain_id( ( *itr)->GetChainID());
        if( first_ids( chain_id) > ( *itr)->GetSeqID())
        {
          first_ids( chain_id) = ( *itr)->GetSeqID();
        }
        if( last_ids( chain_id) < ( *itr)->GetSeqID())
        {
          last_ids( chain_id) = ( *itr)->GetSeqID();
        }
      }

      // hash sses for all amino acid ids
      storage::Vector< storage::Vector< size_t> > sse_id( size_t( 128));
      for( size_t chain_id( 0), mx_chain_id( first_ids.GetSize()); chain_id < mx_chain_id; ++chain_id)
      {
        if( last_ids( chain_id) >= first_ids( chain_id))
        {
          sse_id( chain_id).Resize( last_ids( chain_id) - first_ids( chain_id) + 1, util::GetUndefined< size_t>());
        }
      }

      size_t current_sse_id( 0);
      for
      (
        auto itr_sses( SSES.Begin()), itr_sses_end( SSES.End());
        itr_sses != itr_sses_end;
        ++itr_sses, ++current_sse_id
      )
      {
        // skip loops unless they're desired
        if( !CONSIDER_LOOPS && !( *itr_sses)->GetType()->IsStructured())
        {
          continue;
        }
        size_t chain_id( ( *itr_sses)->GetChainID());
        const int first_id( first_ids( chain_id));
        storage::Vector< size_t> &chain_vec( sse_id( chain_id));

        int seq_id_start( ( *itr_sses)->GetFirstAA()->GetSeqID() - first_id);
        int seq_id_end( ( *itr_sses)->GetLastAA()->GetSeqID() - first_id);
        for( int pos( seq_id_start); pos <= seq_id_end; ++pos)
        {
          chain_vec( pos) = current_sse_id;
        }
      }

      const double allowance( 0.05);

      static score::AAPairHiResClash clash;
      auto neighbors( GetNeighbors( clash.GetDistanceCutoff()));
      storage::Set< graph::UndirectedEdge< double> > edges, interactions;
      storage::Map< storage::Pair< size_t, size_t>, math::RunningAverageSD< linal::Vector3D> > clashed_sse_pairs_to_directions;
      for( auto itr_valid( neighbors.Begin()), itr_end( neighbors.End()); itr_valid != itr_end; ++itr_valid)
      {
        auto &triplet( *itr_valid);
        const size_t chain_id_a( triplet.First()->GetChainID()), chain_id_b( triplet.Second()->GetChainID());
        size_t sse1( sse_id( chain_id_a)( triplet.First()->GetSeqID() - first_ids( chain_id_a)));
        size_t sse2( sse_id( chain_id_b)( triplet.Second()->GetSeqID() - first_ids( chain_id_b)));
        if( !util::IsDefined( sse1) || !util::IsDefined( sse2))
        {
          continue;
        }
        if( sse1 == sse2)
        {
          continue;
        }
        if( biol::SequenceSeparation( *triplet.First(), *triplet.Second()) < 1)
        {
          // ignore adjacent aas
          continue;
        }

        if( double clash_amt = clash( *triplet.First(), *triplet.Second(), triplet.Third()))
        {
          clash_amt += allowance;
          linal::Vector3D translation( triplet.Second()->GetCA().GetCoordinates() - triplet.First()->GetCA().GetCoordinates());
          translation.Normalize();
          translation *= clash_amt;
          clashed_sse_pairs_to_directions[ storage::Pair< size_t, size_t>( sse1, sse2)] += translation;
          clashed_sse_pairs_to_directions[ storage::Pair< size_t, size_t>( sse2, sse1)] += -translation;
          auto itr_clash( edges.InternalData().insert( graph::UndirectedEdge< double>( sse1, sse2, clash_amt)));
          if( !itr_clash.second && itr_clash.first->GetEdgeData() < clash_amt)
          {
            edges.RemoveElement( itr_clash.first);
            edges.Insert( graph::UndirectedEdge< double>( sse1, sse2, clash_amt));
          }
        }
        interactions.InsertElement( graph::UndirectedEdge< double>( sse1, sse2, triplet.Third()));
      }
      graph::ConstGraph< size_t, double> clash_graph
      (
        storage::CreateIndexVector( SSES.GetSize()),
        storage::Vector< graph::UndirectedEdge< double> >( edges.Begin(), edges.End()),
        0
      );
      graph::ConstGraph< size_t, double> interaction_graph
      (
        storage::CreateIndexVector( SSES.GetSize()),
        storage::Vector< graph::UndirectedEdge< double> >( interactions.Begin(), interactions.End()),
        0
      );

      storage::Vector< storage::Pair< util::SiPtr< const SSE>, linal::Vector3D> > sses_to_move;
      if( !clash_graph.NumEdges())
      {
        return sses_to_move;
      }

      // Determine translation vectors
      storage::Map< storage::Pair< size_t, size_t>, linal::Vector3D> clash_removal_translations;
      for
      (
        auto itr_trans( clashed_sse_pairs_to_directions.Begin()), itr_trans_end( clashed_sse_pairs_to_directions.End());
        itr_trans != itr_trans_end;
        ++itr_trans
      )
      {
        linal::Vector3D &trans( clash_removal_translations[ itr_trans->first]);
        if
        (
          !s_use_sse_level_moves
          || itr_trans->second.GetAverage().Norm() * 1.5 > itr_trans->second.GetStandardDeviation().Norm()
        )
        {
          // side chains or just one side of backbone touching backbone of other SSE. In this case, just move
          // the minimal amount in the average direction to resolve the clashes
          trans = itr_trans->second.GetAverage();
          trans.Normalize();

          // multiply by the clashed radius
          trans *=
            std::max
            (
              edges.Find
              (
                graph::UndirectedEdge< double>( itr_trans->first.First(), itr_trans->first.Second(), double( 0.0))
              )->GetEdgeData(),
              0.125
            );
        }
        else
        {
          // severe overlap, e.g. one sse going partly through the core of another. In this case, we treat them as cylinders
          // and move them apart according to their radii
          SSEGeometryPacking packing( *SSES( itr_trans->first.Second()), *SSES( itr_trans->first.First()));
          // highly intersecting SSEs. Have to take more drastic steps to remove the clash
          const linal::Vector3D &direction_a( SSES( itr_trans->first.First())->GetMainAxis().GetDirection()),
                                &direction_b( SSES( itr_trans->first.Second())->GetMainAxis().GetDirection());
          linal::Vector3D norm( linal::CrossProduct( direction_a, direction_b));
          double dist( packing.GetDistance());
          double nrm( norm.Norm());
          const double half_radius
          (
            (
              SSES( itr_trans->first.Second())->GetType()->GetRadialExtent()
              + SSES( itr_trans->first.First())->GetType()->GetRadialExtent()
            ) / 2.0
          );
          if( nrm < 1.0 || packing.GetDistance() > 0.5)
          {
            trans = packing.GetShortestConnection().GetDirection();
          }
          else
          {
            trans = -norm;
          }
          trans.Normalize();
          trans *= -edges.Find
                     (
                       graph::UndirectedEdge< double>( itr_trans->first.First(), itr_trans->first.Second(), double( 0.0))
                     )->GetEdgeData();
        }
      }
      size_t vertex_cover_size( 0);
      while( clash_graph.NumEdges())
      {
        bool had_tree_nodes( false);
        size_t min_node_size( clash_graph.NumEdges() + 1), min_node_id( 0);
        // run through the graph; prune any leaf nodes from any sub-trees in the graph
        for( size_t i( 0), n_sses( SSES.GetSize()); i < n_sses; ++i)
        {
          const size_t n_neigh( clash_graph.GetNeighborIndices( i).GetSize());
          if( !n_neigh)
          {
            continue;
          }
          if( n_neigh == size_t( 1))
          {
            const size_t neighbor( clash_graph.GetNeighborIndices( i).FirstElement());
            const size_t n_interaction_i( interaction_graph.GetNeighborIndices( i).GetSize());
            const size_t n_interaction_neigh( interaction_graph.GetNeighborIndices( neighbor).GetSize());
            if( n_interaction_i <= n_interaction_neigh || clash_graph.GetNeighborIndices( neighbor).GetSize() > size_t( 1))
            {
              sses_to_move.PushBack
              (
                storage::Pair< util::SiPtr< const SSE>, linal::Vector3D>
                (
                  SSES( i),
                  clash_removal_translations[ storage::Pair< size_t, size_t>( i, neighbor)]
                )
              );
              clash_graph.RemoveAllEdges( i);
            }
            else
            {
              sses_to_move.PushBack
              (
                storage::Pair< util::SiPtr< const SSE>, linal::Vector3D>
                (
                  SSES( neighbor),
                  clash_removal_translations[ storage::Pair< size_t, size_t>( neighbor, i)]
                )
              );
              clash_graph.RemoveAllEdges( neighbor);
            }
            ++vertex_cover_size;
            had_tree_nodes = true;
          }
          else if
          (
            n_neigh < min_node_size
            ||
            (
              n_neigh == min_node_size
              && interaction_graph.GetNeighborIndices( min_node_id).GetSize()
                 > interaction_graph.GetNeighborIndices( i).GetSize()
            )
          )
          {
            min_node_size = n_neigh;
            min_node_id = i;
          }
        }
        if( !had_tree_nodes)
        {

          // no tree nodes. Approximation : select the node with the highest number of edges and add it to the cover
          ++vertex_cover_size;
          math::RunningAverageSD< linal::Vector3D> ave_direction;
          double max_distance( 0.0);
          for( size_t j( 0); j < min_node_size; ++j)
          {
            const linal::Vector3D &trans
            (
              clash_removal_translations
              [
                 storage::Pair< size_t, size_t>( min_node_id, clash_graph.GetNeighborIndices( min_node_id)( j))
              ]
            );
            ave_direction += trans;
            max_distance = std::max( clash_graph.GetNeighborData( min_node_id)( j), max_distance);
          }
          BCL_MessageDbg
          (
            "Multiple connections on all nodes, taking node with the lowest degree "
            + util::Format()( ave_direction.GetAverage().Norm())
            + " "
            + util::Format()( ave_direction.GetStandardDeviation().Norm())
          );
          linal::Vector3D translation( ave_direction.GetAverage());
          translation.Normalize();
          translation *= max_distance;
          sses_to_move.PushBack
          (
            storage::Pair< util::SiPtr< const SSE>, linal::Vector3D>
            (
              SSES( min_node_id),
              translation
            )
          );
          clash_graph.RemoveAllEdges( min_node_id);
        }
      }
      return sses_to_move;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_voxel_grid_atom.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "biol/bcl_biol_aa_base.h"

// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {

  //////////
  // data //
  //////////

    // instantiate s_Instance
    const util::SiPtr< const util::ObjectInterface> VoxelGridAtom::s_Instance
    (
      GetObjectInstances().AddInstance( new VoxelGridAtom())
    );

    //! @brief set the group ids for the atoms (indexed by atom PDB_ID). Atoms in the same group will not be reported
    //!        as in-contact.
    //! @param GROUP_IDS a vector containing group ids for all atoms of interest.
    void VoxelGridAtom::SetGroupIDs( const storage::Vector< size_t> &GROUP_IDS)
    {
      BCL_Assert( m_MaxPDBID <= GROUP_IDS.GetSize(), "Inadequate # of group IDs provided!");
      m_PdbIdToSeqID = GROUP_IDS;
      m_PdbIdToGroupIdPtr = util::ToSiPtr( m_PdbIdToSeqID);
    }

    //! @brief Extract an atoms coordinates (Ha2 for Glycine, Cb-Atom otherwise)
    //! @param ATOM pointer to the atom object
    //! @return Reference to the coordinates. null-ptr if coordinates are undefined
    util::SiPtr< const linal::Vector3D> VoxelGridAtom::ExtractPosition( const util::SiPtr< const biol::Atom> &ATOM) const
    {
      // Check if it's coordinates are defined
      if( ATOM->GetCoordinates().IsDefined() && ATOM->GetPdbID() >= 0 && ATOM->GetPdbID() < 1000000)
      { // if so return them
        m_MaxPDBID = std::max( size_t( ATOM->GetPdbID()), m_MaxPDBID);
        return util::SiPtr< const linal::Vector3D>( ATOM->GetCoordinates());
      }
      return util::SiPtr< const linal::Vector3D>();
    }

    //! @brief Update the VoxelGrid with new data
    //! @param NEW_DATA SiPtrVector of the new data
    void VoxelGridAtom::SetObjects( const util::SiPtrVector< const biol::Atom> &NEW_DATA)
    {
      m_MaxPDBID = 0;
      util::VoxelGrid< biol::Atom>::SetObjects( NEW_DATA);
      // reset group ids
      m_PdbIdToGroupIdPtr = util::SiPtr< const storage::Vector< size_t> >();
      m_PdbIdToSSEID.Reset();
      m_PdbIdToSeqID.Reset();
      m_NumberSSEs = 0;
    }

    //! @brief Exclude atoms from the same amino acid from being reported
    //! @param AAs aa vector
    //! @param SEQ_EXCLUSION minimum sequence separation between reported matches
    void VoxelGridAtom::ExcludeResiduesSameAA
    (
      const util::SiPtrVector< const biol::AABase> &AAS,
      const size_t &SEQ_EXCLUSION
    )
    {
      m_SeqExclusion = SEQ_EXCLUSION;
      size_t logical_aa_seq_id( 1);
      char prev_chain( '\0');
      int prev_seq_id( -1000);
      m_PdbIdToSeqID.Reset();
      m_PdbIdToSeqID.Resize( m_MaxPDBID + 1, 0);
      for( auto itr_aa( AAS.Begin()), itr_aa_end( AAS.End()); itr_aa != itr_aa_end; ++itr_aa, ++logical_aa_seq_id)
      {
        if( prev_chain != ( *itr_aa)->GetChainID())
        {
          prev_chain = ( *itr_aa)->GetChainID();
          logical_aa_seq_id += m_SeqExclusion + 1;
        }
        else if( prev_seq_id + 1 < ( *itr_aa)->GetSeqID())
        {
          logical_aa_seq_id += ( *itr_aa)->GetSeqID() - prev_seq_id - 1;
        }
        prev_seq_id = ( *itr_aa)->GetSeqID();
        for
        (
          auto itr_atom( ( *itr_aa)->GetAtoms().Begin()), itr_atom_end( ( *itr_aa)->GetAtoms().End());
          itr_atom != itr_atom_end;
          ++itr_atom
        )
        {
          if( ( *itr_atom)->GetPdbID() >= 0 && ( *itr_atom)->GetPdbID() < m_MaxPDBID)
          {
            m_PdbIdToSeqID( ( *itr_atom)->GetPdbID()) = logical_aa_seq_id;
          }
        }
      }
      m_PdbIdToGroupIdPtr = util::ToSiPtr( m_PdbIdToSeqID);
    }

    //! @brief Exclude residues from the same sse acid from being reported
    //! @note ExcludeResiduesSameAA should not be called if this function is used
    //! @param AAs aa vector
    void VoxelGridAtom::ExcludeResiduesSameSSE
    (
      const util::SiPtrVector< const SSE> &SSES,
      const util::SiPtrVector< const biol::AABase> &AAS,
      const size_t &SEQ_EXCLUSION
    )
    {
      ExcludeResiduesSameAA( AAS, SEQ_EXCLUSION);
      m_PdbIdToSSEID.Reset();
      m_PdbIdToSSEID.Resize( m_MaxPDBID + 1, util::GetUndefined< size_t>());
      m_NumberSSEs = SSES.GetSize();
      // hash sses for all amino acid ids
      size_t current_sse_id( 0);
      for( auto itr_sses( SSES.Begin()), itr_sse_end( SSES.End()); itr_sses != itr_sse_end; ++itr_sses, ++current_sse_id)
      {
        if( !( *itr_sses)->GetType()->IsStructured())
        {
          continue;
        }
        for( auto itr_aa( ( *itr_sses)->Begin()), itr_aa_end( ( *itr_sses)->End()); itr_aa != itr_aa_end; ++itr_aa)
        {
          for
          (
            auto itr_atom( ( *itr_aa)->GetAtoms().Begin()), itr_atom_end( ( *itr_aa)->GetAtoms().End());
            itr_atom != itr_atom_end;
            ++itr_atom
          )
          {
            if( ( *itr_atom)->GetPdbID() >= 0 && ( *itr_atom)->GetPdbID() < m_MaxPDBID)
            {
              m_PdbIdToSSEID( ( *itr_atom)->GetPdbID()) = current_sse_id;
            }
          }
        }
      }
      m_PdbIdToGroupIdPtr = util::ToSiPtr( m_PdbIdToSSEID);
    }

    namespace
    {
      //! Return true if the distance of A is less than B
      bool LessThanDistance
      (
        const storage::Triplet
        <
          util::SiPtr< const biol::Atom>,
          util::SiPtr< const biol::Atom>,
          double
        > &A,
        const storage::Triplet
        <
          util::SiPtr< const biol::Atom>,
          util::SiPtr< const biol::Atom>,
          double
        > &B
      )
      {
        return A.Third() < B.Third();
      }
    }
    //! @brief Get a matrix with counts of AAs interacting at particular distance between each SSE
    linal::Matrix< float> VoxelGridAtom::GetSSEInteractionMatrix( const double &RESOLUTION) const
    {
      BCL_Assert( m_PdbIdToGroupIdPtr.IsDefined() && &*m_PdbIdToGroupIdPtr == &m_PdbIdToSSEID, "SSEs not provided!");
      linal::Matrix< float> interactions( m_NumberSSEs, m_NumberSSEs, float( 0));
      auto interactions_vector( GetNeighbors( RESOLUTION));
      interactions_vector.Sort( LessThanDistance);
      storage::Vector< double> closest_distance( m_PdbIdToSSEID.GetSize(), util::GetUndefined< double>());
      storage::Vector< size_t> residue_counts( m_PdbIdToSSEID.GetSize(), size_t( 0));
      util::SiPtrVector
      <
        storage::Triplet
        <
          util::SiPtr< const biol::Atom>,
          util::SiPtr< const biol::Atom>,
          double
        >
      > true_closest_distances;
      for( auto itr( interactions_vector.Begin()), itr_end( interactions_vector.End()); itr != itr_end; ++itr)
      {
        if
        (
          m_PdbIdToSSEID( itr->First()->GetPdbID()) == util::GetUndefined< size_t>()
          || m_PdbIdToSSEID( itr->Second()->GetPdbID()) == util::GetUndefined< size_t>()
          || std::abs( int( m_PdbIdToSeqID( itr->First()->GetPdbID())) - int( m_PdbIdToSeqID( itr->Second()->GetPdbID()))) <= m_SeqExclusion
          || m_PdbIdToSSEID( itr->First()->GetPdbID()) == m_PdbIdToSSEID( itr->Second()->GetPdbID())
        )
        {
          continue;
        }
        if( !util::IsDefined( closest_distance( itr->First()->GetPdbID())))
        {
          closest_distance( itr->First()->GetPdbID()) = itr->Third();
        }
        if( !util::IsDefined( closest_distance( itr->Second()->GetPdbID())))
        {
          closest_distance( itr->Second()->GetPdbID()) = itr->Third();
        }
        if( closest_distance( itr->First()->GetPdbID()) + 1.0 < itr->Third())
        {
          continue;
        }
        if( closest_distance( itr->Second()->GetPdbID()) + 1.0 < itr->Third())
        {
          continue;
        }
        true_closest_distances.PushBack( *itr);
        ++residue_counts( itr->First()->GetPdbID());
        ++residue_counts( itr->Second()->GetPdbID());
      }
      for( auto itr( true_closest_distances.Begin()), itr_end( true_closest_distances.End()); itr != itr_end; ++itr)
      {
        const auto &triplet( **itr);
        const double interaction_weight
        (
          4.0
          /
          std::max( 4.0, double( residue_counts( triplet.First()->GetPdbID()) + residue_counts( triplet.Second()->GetPdbID())))
        );
        interactions( m_PdbIdToSSEID( triplet.First()->GetPdbID()), m_PdbIdToSSEID( triplet.Second()->GetPdbID())) += interaction_weight;
        interactions( m_PdbIdToSSEID( triplet.Second()->GetPdbID()), m_PdbIdToSSEID( triplet.First()->GetPdbID())) += interaction_weight;
      }
      return interactions;
    }

  } // namespace assemble
} // namespace bcl
// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "assemble/bcl_assemble_voxel_grid_mutation.h"

// includes from bcl - sorted alphabetically
#include "assemble/bcl_assemble_sse.h"
#include "assemble/bcl_assemble_sse_geometry_packing.h"
#include "biol/bcl_biol_aa_base.h"
#include "graph/bcl_graph_const_graph.h"
#include "graph/bcl_graph_undirected_edge.h"
#include "math/bcl_math_running_average_sd.h"
#include "score/bcl_score_aa_pair_clash.h"
#include "score/bcl_score_aa_pair_hi_res_clash.h"
// external includes - sorted alphabetically

namespace bcl
{
  namespace assemble
  {
    //! @brief extract the 3D coordinates of a given t_DataType input. TO BE IMPLEMENTED BY DERIVED CLASSES if one input can have multiple positions
    //! @param INPUT pointer to the t_DataType
    //! @return 3D Vector of the input's coordinates
    util::SiPtrVector< const linal::Vector3D> VoxelGridMutation::ExtractPositions
    (
      const util::SiPtr< const biol::Mutation> &INPUT
    ) const
    {
      util::SiPtrVector< const linal::Vector3D> positions;
      positions.AllocateMemory( INPUT->GetChainIDs().size());
      for( size_t i( 0), sz( INPUT->GetAAs().GetSize()); i < sz; ++i)
      {
        positions.PushBack( ExtractPositionFromChain( INPUT, i));
        if( !positions.LastElement().IsDefined())
        {
          positions.PopBack();
        }
      }
      return positions;
    }

    //! @brief Extract an AA-instance's coordinates (Ha2 for Glycine, Cb-Atom otherwise)
    //! @param AA pointer to the amino acid object
    //! @return Reference to the coordinates. null-ptr if coordinates are undefined
    util::SiPtr< const linal::Vector3D> VoxelGridMutation::ExtractPositionFromChain
    (
      const util::SiPtr< const biol::Mutation> &MUTATION,
      const size_t &CHAIN_INDEX
    ) const
    {
      if( m_PreferCenter)
      {
        auto coords( MUTATION->GetAAs()( CHAIN_INDEX)->GetAtomCoordinates());
        math::RunningAverage< linal::Vector3D> ave_coord;
        for( auto itr( coords.Begin()), itr_end( coords.End()); itr != itr_end; ++itr)
        {
          if( ( *itr)->IsDefined())
          {
            ave_coord += **itr;
          }
        }
        if( ave_coord.GetWeight())
        {
          m_Centers.PushBack( ave_coord.GetAverage());
          return util::SiPtr< const linal::Vector3D>( &m_Centers.LastElement());
        }
      }
      // get firstSideChainAtom
      const biol::Atom &atom( m_PreferCA ? MUTATION->GetAAs()( CHAIN_INDEX)->GetCA() : MUTATION->GetAAs()( CHAIN_INDEX)->GetFirstSidechainAtom());

      // Check if it's coordinates are defined
      if( atom.AllCoordinatesDefined())
      { // if so return them
        return util::SiPtr< const linal::Vector3D>( atom.GetCoordinates());
      }
      return util::SiPtr< const linal::Vector3D>();
    }
  } // namespace assemble
} // namespace bcl
