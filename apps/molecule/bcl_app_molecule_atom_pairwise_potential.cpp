// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// initialize the static initialization fiasco finder, if macro ENABLE_FIASCO_FINDER is defined
#include "util/bcl_util_static_initialization_fiasco_finder.h"
BCL_StaticInitializationFiascoFinder

// include header of this class
#include "bcl_app_molecule_atom_pairwise_potential.h"

// includes from bcl - sorted alphabetically
#include "chemistry/bcl_chemistry_aa_fragment_complete.h"
#include "chemistry/bcl_chemistry_conformation_comparison_interface.h"
#include "chemistry/bcl_chemistry_fragment_ensemble.h"
#include "chemistry/bcl_chemistry_voxel_grid_atom.h"
#include "command/bcl_command_app_default_flags.h"
#include "command/bcl_command_flag_static.h"
#include "command/bcl_command_parameter_check_file_existence.h"
#include "command/bcl_command_parameter_check_ranged.h"
#include "command/bcl_command_parameter_check_serializable.h"
#include "io/bcl_io_directory_entry.h"
#include "io/bcl_io_file.h"
#include "math/bcl_math_histogram.h"
#include "sched/bcl_sched_scheduler_interface.h"
#include "sched/bcl_sched_thunk_job.h"
#include "sched/bcl_sched_unary_function_job_with_data.h"
#include "storage/bcl_storage_pair.h"
#include "storage/bcl_storage_template_instantiations.h"
#include "util/bcl_util_implementation.h"
namespace bcl
{
  namespace app
  {
  //////////////////////////////////
  // construction and destruction //
  //////////////////////////////////

    //! @brief standard constructor
    MoleculeAtomPairwisePotential::MoleculeAtomPairwisePotential() :
      m_InputMoleculeSDF
      (
        new command::FlagStatic
        (
          "molecule_filename",
          "filename for input sdf of fragment ensemble",
          command::Parameter( "input_sdf", "a single SDF file of ligands", "")
        )
      ),
      m_InputPocketPDB
      (
        new command::FlagStatic
        (
          "pocket_filename",
          "filename for a single binding pocket",
          command::Parameter( "input_pdb", "a single PDB file of binding pocket", "")
        )
      ),
      m_InputList
      (
        new command::FlagStatic
        (
          "ligand_pocket_pair_list",
          "filename for a list of SDF and PDB files corresponding to small molecules and binding pockets",
          command::Parameter( "input_paired_list", "a list of SDF and PDB files of corresponding to ligands and binding pockets,respectively", "")
        )
      ),
      m_InputBGCountsFilename
      (
        new command::FlagStatic
        (
          "input_bg_counts_filename",
          "filename for input counts file with which to generate background",
          command::Parameter( "input bg counts file", "if provided then energies will be normalized by these counts", "")
        )
      ),
      m_InputFGCountsFilename
      (
        new command::FlagStatic
        (
          "input_fg_counts_filename",
          "filename for input counts file with which to generate foreground",
          command::Parameter( "input fg counts file", "if provided then energies will be generated by these counts", "")
        )
      ),
      m_OutputFilename
      (
        new command::FlagStatic
        (
          "output_filename",
          "filename for the output map",
          command::Parameter( "output file", "the file to be output", "atom_pair_statistical_potentials.map.txt")
        )
      ),
      m_OutputCountsFilename
      (
        new command::FlagStatic
        (
          "output_counts_filename",
          "filename for the output counts",
          command::Parameter( "output counts file", "the file to be output", "atom_pair_counts.map.txt")
        )
      ),
      m_NeighborDistanceCutoff
      (
        new command::FlagStatic
        (
          "neighbor_distance",
          "distance within which two atoms are neighbors",
          command::Parameter( "neighbor_distance", "distance within which two atoms are neighbors", "")
        )
      ),
      m_BinResolution
      (
        new command::FlagStatic
        (
          "bin_resolution",
          "step size in distance bins",
          command::Parameter( "bin_resolution", "distance interval between bins in histogram", "0.25")
        )
      )
    {
    }

    //! @brief Clone function
    //! @return pointer to new FoldProtein
    MoleculeAtomPairwisePotential *MoleculeAtomPairwisePotential::Clone() const
    {
      return new MoleculeAtomPairwisePotential( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name of the object behind a pointer or the current object
    //! @return the class name
    const std::string &MoleculeAtomPairwisePotential::GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    //! @brief get a description for the app
    //! @return a brief (no more than 3 line) description for the application
    std::string MoleculeAtomPairwisePotential::GetDescription() const
    {
      return "generate pairwise atomic potentials between small molecules and protein binding pockets";
    }

    //! @brief initializes the command object for that executable
    util::ShPtr< command::Command> MoleculeAtomPairwisePotential::InitializeCommand() const
    {
      util::ShPtr< command::Command> sp_cmd( new command::Command());

      // ensemble containing the small molecules
      sp_cmd->AddFlag( m_InputMoleculeSDF);

      // PDB file for a single protein binding pocket
      sp_cmd->AddFlag( m_InputPocketPDB);

      // list of PDB files for multiple protein binding pockets
      sp_cmd->AddFlag( m_InputList);

      // input background counts filename
      sp_cmd->AddFlag( m_InputBGCountsFilename);

      // input foreground counts filename
      sp_cmd->AddFlag( m_InputFGCountsFilename);

      // output filename
      sp_cmd->AddFlag( m_OutputFilename);

      // output counts filename
      sp_cmd->AddFlag( m_OutputCountsFilename);

      // distance specifying neighbors
      sp_cmd->AddFlag( m_NeighborDistanceCutoff);

      // bin resolution
      sp_cmd->AddFlag( m_BinResolution);

      // hydrogen flags
      sdf::AddMoleculeIOPrefFlags( *sp_cmd);

      // add default bcl parameters
      command::GetAppDefaultFlags().AddDefaultCommandlineFlags( *sp_cmd);

      // return assembled Command object
      return sp_cmd;
    }

    //! @brief returns readme information
    //! @return string containing information about application
    const std::string &MoleculeAtomPairwisePotential::GetReadMe() const
    {
      util::Implementation< descriptor::Base< chemistry::AtomConformationalInterface, float> >::SetHaveDisplayedHelp();
      static io::FixedLineWidthWriter writer;
      static std::string s_read_me
      (
        DefaultSectionSeparator() +
        "I. OVERVIEW.\n"
        "This document provides a description of how to run molecule:MultiAlign, terms of use, "
        "appropriate citation.\n\n"
        + DefaultSectionSeparator() +
        "II. WHAT IS BCL::MoleculeAtomPairwisePotential?\n"
        "molecule:MultiAlign is a C++ based application, created by Vanderbilt University's Meiler Laboratory, which is part "
        "of a larger library of applications called BCL::Commons.  molecule:MultiAlign allows simultaneous flexible "
        "alignment of small molecules given an input ensemble. \n"
        "\n"
        + DefaultSectionSeparator() +
        "III. TERMS OF USE.\n"
        + DefaultTermsOfUseString() +
        "\n"
        + DefaultSectionSeparator() +
        "IV. APPROPRIATE CITATIONS FOR USING BCL::MoleculeAtomPairwisePotential.\n"
        "\n"

        "\n"
        + DefaultSectionSeparator() +
        "V. INSTALLATION PROCEDURES.\n"
        + DefaultInstallationProcedure() +
        "\n"
        + DefaultSectionSeparator() +
        "VI. RUNNING molecule:MultiAlign.\n"
        "\n"
        "Example command line:\n"
        "Information concerning syntax and flags can be obtained by typing bcl.exe molecule:MultiAlign -help\n"
        "\n"
        "For more general information about the product, type bcl.exe molecule:MultiAlign -readme\n"
        "\n"
        + DefaultSectionSeparator() +
        "VII. TECHNICAL SUPPORT.\n"
        + DefaultTechnicalSupportString() +
        "\n"
        + DefaultSectionSeparator() +
        "VIII. FUTURE DEVELOPMENT OF BCL::MoleculeAtomPairwisePotential\n"
        "BCL::MoleculeAtomPairwisePotential is under ongoing further development.\n"
        "\n"
        + DefaultSectionSeparator()
      );
      util::Implementation< descriptor::Base< chemistry::AtomConformationalInterface, float> >::ResetHaveDisplayedHelp();
      return s_read_me;
    }

    //! @brief the Main function
    //! @return error code - 0 for success
    int MoleculeAtomPairwisePotential::Main() const
    {
      storage::Vector< storage::Pair< chemistry::FragmentEnsemble, chemistry::FragmentComplete>> all_pairs;
      chemistry::FragmentEnsemble ensemble_a;
      assemble::ProteinModel protein_model;
      const pdb::Factory factory;

      BCL_Assert
      (
        ( m_InputMoleculeSDF->GetFlag() && ( m_InputPocketPDB->GetFlag() || !m_InputList->GetFlag()))
        || ( m_InputList->GetFlag() && !m_InputPocketPDB->GetFlag() && !m_InputMoleculeSDF->GetFlag()),
        "Both an SDF for molecules and a PDB for proteins are required"
      );
      if( m_InputMoleculeSDF->GetFlag() && m_InputPocketPDB->GetFlag())
      {
        // read in ligand(s)
        io::IFStream input_sdf;
        io::File::MustOpenIFStream( input_sdf, m_InputMoleculeSDF->GetFirstParameter()->GetValue());
        ensemble_a = chemistry::FragmentEnsemble( input_sdf, sdf::e_Remove);

        // read in protein
        protein_model = factory.ProteinModelFromPDBFilename( m_InputPocketPDB->GetFirstParameter()->GetValue());
        chemistry::AAFragmentComplete aa_fragment( protein_model.GetAminoAcids(), true);
        aa_fragment.RemoveH();

        storage::Pair< chemistry::FragmentEnsemble, chemistry::FragmentComplete> temp( ensemble_a, aa_fragment);
        all_pairs.PushBack( temp);
        io::File::CloseClearFStream( input_sdf);
      }
      else if( m_InputMoleculeSDF->GetFlag())
      {
        // read in ligand(s)
        io::IFStream input_sdf;
        io::File::MustOpenIFStream( input_sdf, m_InputMoleculeSDF->GetFirstParameter()->GetValue());
        ensemble_a = chemistry::FragmentEnsemble( input_sdf, sdf::e_Remove);
        storage::Pair< chemistry::FragmentEnsemble, chemistry::FragmentComplete> temp( ensemble_a, chemistry::FragmentComplete());
        all_pairs.PushBack( temp);
        io::File::CloseClearFStream( input_sdf);
      }
      // generate potentials from a list of ligand-protein pairs
      else if( m_InputList->GetFlag())
      {
        // read in list
        io::IFStream input_list;
        io::File::MustOpenIFStream( input_list, m_InputList->GetFirstParameter()->GetValue());
        std::string sdf_pdb_line;

        // process input
        auto tokens( util::SplittedStringLineListFromIStream( input_list));
        io::File::CloseClearFStream( input_list);

        if( !tokens.IsEmpty())
        {
          // read in each SDF and PDB in the list
          for( auto itr( tokens.Begin()), itr_end( tokens.End()); itr != itr_end; ++itr)
          {
            if( itr->IsEmpty())
            {
              continue;
            }

            // Get mah small molecules
            BCL_Assert( itr->GetSize() == size_t( 2), "for whatever reason we only support 1 SDF and 1 PDB per line");
            io::IFStream sdf_from_list;
            io::File::MustOpenIFStream(sdf_from_list, ( *itr)( 0));
            chemistry::FragmentEnsemble ensemble_mols( sdf_from_list, sdf::e_Remove);
            ensemble_a = ensemble_mols;
            ensemble_a.WriteMDL( util::GetLogger());
            io::File::CloseClearFStream( sdf_from_list);

            // Get mah pocket
            protein_model = factory.ProteinModelFromPDBFilename( ( *itr)( 1));
            chemistry::AAFragmentComplete aa_fragment( protein_model.GetAminoAcids(), true);
            aa_fragment.RemoveH();

            // Assemble my molecule / pockets pairs
            storage::Pair< chemistry::FragmentEnsemble, chemistry::FragmentComplete> temp_pair( ensemble_mols, aa_fragment);
            all_pairs.PushBack( temp_pair);
          }
        }
        //what is this even doing here?
        else if( !ensemble_a.IsEmpty() && !protein_model.IsEmpty())
        {
          io::File::CloseClearFStream( input_list);
          chemistry::AAFragmentComplete aa_fragment( protein_model.GetAminoAcids(), true);
          aa_fragment.RemoveH();
          BCL_MessageStd( "No input list. Potential statistics will be derived from the input SDF and PDB");
        }
        else
        {
          io::File::CloseClearFStream( input_list);
          BCL_MessageCrt( "One of the input files did not contain molecules. "
            "Please provide a list of ligand-protein pairs or specify individual SDF and PDB files. "
            "Exiting...");
          return 0;
        }
      }

      //Build voxel grids for each molecule-pocket pair
      storage::Map< storage::Pair< chemistry::AtomType, chemistry::AtomType>, math::Histogram> mapped_atom_pairs;
      storage::Map< storage::Pair< chemistry::AtomType, chemistry::AtomType>, size_t> counts_anywhere;
      size_t total_counts_anywhere( 0);
      double neighbor_distance( m_NeighborDistanceCutoff->GetFirstParameter()->GetNumericalValue< double>());
      double bin_res( m_BinResolution->GetFirstParameter()->GetNumericalValue< double>());
      size_t n_bins( ( neighbor_distance - 1) / bin_res);
      math::Histogram background( 0.0, bin_res, n_bins);

      if( !m_InputFGCountsFilename->GetFlag())
      {
        //wrap with ensemble protein pairs
        size_t pair_index( 0);
        for
        (
            auto all_pair_itr( all_pairs.Begin()), all_pair_itr_end( all_pairs.End());
            all_pair_itr != all_pair_itr_end;
            ++all_pair_itr, ++pair_index
        )
        {
          chemistry::VoxelGridAtom voxel_grid_pocket( neighbor_distance);
          voxel_grid_pocket.SetObjects( util::SiPtrVector< const chemistry::AtomConformationalInterface>( all_pair_itr->Second().GetAtomsIterator(), all_pair_itr->Second().GetAtomsIterator().End()));
          bool no_pocket( all_pair_itr->Second().GetSize() == size_t( 0));
          for( chemistry::FragmentEnsemble::iterator ens_a_itr( ensemble_a.Begin()), ens_a_itr_end( ensemble_a.End()); ens_a_itr != ens_a_itr_end; ++ens_a_itr)
          {
            // count number of atoms of each type in ensemble a
            storage::Map< chemistry::AtomType, size_t> atom_type_counts_a;
            for( auto itr_atoms_a( ens_a_itr->GetAtomsIterator()); itr_atoms_a.NotAtEnd(); ++itr_atoms_a)
            {
              auto itr_ins( atom_type_counts_a.Insert( std::make_pair( itr_atoms_a->GetAtomType(), size_t( 1))));
              if( !itr_ins.second)
              {
                itr_ins.first->second += 1;
              }
            }
            chemistry::VoxelGridAtom voxel_grid_mol( neighbor_distance);
            voxel_grid_mol.SetObjects( util::SiPtrVector< const chemistry::AtomConformationalInterface>( ens_a_itr->GetAtomsIterator(), ens_a_itr->GetAtomsIterator().End()));

            // count number of atoms of each type in ensemble b
            storage::Map< chemistry::AtomType, size_t> atom_type_counts_b;
            for( auto itr_atoms_b( all_pair_itr->Second().GetAtomsIterator()); itr_atoms_b.NotAtEnd(); ++itr_atoms_b)
            {
              auto itr_ins( atom_type_counts_b.Insert( std::make_pair( itr_atoms_b->GetAtomType(), size_t( 1))));
              if( !itr_ins.second)
              {
                itr_ins.first->second += 1;
              }
            }
            // compute total number of times atom type a and b are seen together across the ensemble
            if( !no_pocket)
            {
              for( auto itr_atoms_a( atom_type_counts_a.Begin()), itr_atoms_a_end( atom_type_counts_a.End()); itr_atoms_a != itr_atoms_a_end; ++itr_atoms_a)
              {
                for( auto itr_atoms_b( atom_type_counts_b.Begin()), itr_atoms_b_end( atom_type_counts_b.End()); itr_atoms_b != itr_atoms_b_end; ++itr_atoms_b)
                {
                  counts_anywhere[ storage::Pair< chemistry::AtomType, chemistry::AtomType>( itr_atoms_a->first, itr_atoms_b->first)] += itr_atoms_a->second * itr_atoms_b->second;
                }
              }
              total_counts_anywhere += ens_a_itr->GetSize() * all_pair_itr->Second().GetSize();
              auto neighbors( voxel_grid_mol.GetNeighborsIn( voxel_grid_pocket, neighbor_distance));

              //Collect distance statistics on each molecule_atom-pocket_atom pair
              for
              (
                  auto neighbor_itr( neighbors.Begin()), neighbors_itr_end( neighbors.End());
                  neighbor_itr != neighbors_itr_end;
                  ++neighbor_itr
              )
              {
                // Create storage object
                storage::Pair< chemistry::AtomType, chemistry::AtomType> atom_pair( neighbor_itr->First()->GetAtomType(), neighbor_itr->Second()->GetAtomType());
                math::Histogram &hist( mapped_atom_pairs[ atom_pair]);
                if( hist.IsEmpty())
                {
                  hist = math::Histogram( 0.0, bin_res, n_bins);
                }

                // Compute difference between van der waals sums and the actual distance
                double mol_csd_vdw_radius( neighbor_itr->First()->GetAtomType()->GetAtomTypeProperty( chemistry::AtomTypeData::e_VdWaalsRadiusCSD));
//                BCL_MessageStd( "POS 4");
//                BCL_Debug( mol_csd_vdw_radius);
//                BCL_Debug( neighbor_itr->First()->GetAtomType());
                double pocket_csd_vdw_radius( neighbor_itr->Second()->GetAtomType()->GetAtomTypeProperty( chemistry::AtomTypeData::e_VdWaalsRadiusCSD));
//                BCL_MessageStd( "POS 5");
//                BCL_Debug( pocket_csd_vdw_radius);
                double dist_vdw( neighbor_itr->Third() - mol_csd_vdw_radius - pocket_csd_vdw_radius);
                if( dist_vdw < neighbor_distance)
                {
                  hist.PushBack( dist_vdw); // needs to be normalized
                  background.PushBack( dist_vdw);
                }
              }
            }
            else
            {
              if( ens_a_itr->HasBadGeometry())
              {
                continue;
              }
              for( auto itr_atoms_a( atom_type_counts_a.Begin()), itr_atoms_a_end( atom_type_counts_a.End()); itr_atoms_a != itr_atoms_a_end; ++itr_atoms_a)
              {
                for( auto itr_atoms_b( atom_type_counts_a.Begin()), itr_atoms_b_end( atom_type_counts_a.End()); itr_atoms_b != itr_atoms_b_end; ++itr_atoms_b)
                {
                  counts_anywhere[ storage::Pair< chemistry::AtomType, chemistry::AtomType>( itr_atoms_a->first, itr_atoms_b->first)]
                    += itr_atoms_a == itr_atoms_b
                       ? itr_atoms_a->second * ( itr_atoms_b->second - size_t( 1))
                       : itr_atoms_a->second * itr_atoms_b->second;
                }
              }
              total_counts_anywhere += ens_a_itr->GetSize() * ( ens_a_itr->GetSize() - 1);
              auto neighbors( voxel_grid_mol.GetNeighbors( neighbor_distance));

              //Collect distance statistics on each molecule_atom-pocket_atom pair
              for
              (
                  auto neighbor_itr( neighbors.Begin()), neighbors_itr_end( neighbors.End());
                  neighbor_itr != neighbors_itr_end;
                  ++neighbor_itr
              )
              {
                // Compute difference between van der waals sums and the actual distance
                double mol_csd_vdw_radius( neighbor_itr->First()->GetAtomType()->GetAtomTypeProperty( chemistry::AtomTypeData::e_VdWaalsRadiusCSD));
//                BCL_MessageStd( "POS 4");
//                BCL_Debug( mol_csd_vdw_radius);
//                BCL_Debug( neighbor_itr->First()->GetAtomType());
                double pocket_csd_vdw_radius( neighbor_itr->Second()->GetAtomType()->GetAtomTypeProperty( chemistry::AtomTypeData::e_VdWaalsRadiusCSD));
//                BCL_MessageStd( "POS 5");
//                BCL_Debug( pocket_csd_vdw_radius);
                double dist_vdw( neighbor_itr->Third());
                if( dist_vdw < neighbor_distance)
                {
                  if( neighbor_itr->First()->FindBondTo( *neighbor_itr->Second()) != neighbor_itr->First()->GetBonds().End())
                  {
                    continue;
                  }
                  // Create storage object
                  storage::Pair< chemistry::AtomType, chemistry::AtomType> atom_pair
                  (
                    neighbor_itr->First()->GetAtomType(),
                    neighbor_itr->Second()->GetAtomType()
                  );
                  math::Histogram &hist( mapped_atom_pairs[ atom_pair]);
                  if( hist.IsEmpty())
                  {
                    hist = math::Histogram( 0.0, bin_res, n_bins);
                  }
                  hist.PushBack( dist_vdw); // needs to be normalized
                  background.PushBack( dist_vdw);
                  std::swap( atom_pair.First(), atom_pair.Second());
                  math::Histogram &histb( mapped_atom_pairs[ atom_pair]);
                  if( histb.IsEmpty())
                  {
                    histb = math::Histogram( 0.0, bin_res, n_bins);
                  }
                  histb.PushBack( dist_vdw); // needs to be normalized
                  background.PushBack( dist_vdw);
                }
              }
            }
          }
        }
      }

      // Normalize by total number of contacts at each distance bin
      linal::Vector< double> bgv( background.GetHistogram());

      if( m_OutputCountsFilename->GetFlag())
      {
        //output atomtype pair counts for each distance bin
        io::OFStream counts_out;
        io::File::MustOpenOFStream( counts_out, m_OutputCountsFilename->GetFirstParameter()->GetValue());
        counts_out << mapped_atom_pairs << '\n';
        io::File::CloseClearFStream( counts_out);
        return 0;
      }

      // get background
      storage::Map< storage::Pair< chemistry::AtomType, chemistry::AtomType>, math::Histogram> mapped_atom_pair_counts, native_counts;
      if( m_InputBGCountsFilename->GetFlag())
      {
        io::IFStream( file);
        io::File::MustOpenIFStream( file, m_InputBGCountsFilename->GetFirstParameter()->GetValue());
        io::Serialize::Read( mapped_atom_pair_counts, file);
        io::File::CloseClearFStream( file);
      }
      else
      {
        bgv.Normalize();
      }

      // get foreground if pre-computed in earlier run
      if( m_InputFGCountsFilename->GetFlag())
      {
        io::IFStream( file);
        io::File::MustOpenIFStream( file, m_InputFGCountsFilename->GetFirstParameter()->GetValue());
        io::Serialize::Read( native_counts, file);
        io::File::CloseClearFStream( file);
      }

      //Map atom pairs to a potential value based on normalized contacts per distance
      if( m_OutputFilename->GetFlag())
      {
        storage::Map< storage::Pair< chemistry::AtomType, chemistry::AtomType>, linal::Vector< double> > mapped_atom_pair_potentials;
        if( !m_InputBGCountsFilename->GetFlag())
        {
          BCL_MessageStd( "POS 6");
          BCL_Debug( mapped_atom_pairs);
          for
          (
            // Go through atom type pairs
            auto mapped_atom_pairs_itr( mapped_atom_pairs.Begin()), mapped_atom_pairs_itr_end( mapped_atom_pairs.End());
            mapped_atom_pairs_itr != mapped_atom_pairs_itr_end;
            ++mapped_atom_pairs_itr
          )
          {
            linal::Vector< double> hist( mapped_atom_pairs_itr->second.GetHistogram());
            if( hist.Sum() > n_bins * 2)
            {
              hist.Normalize();
              // For each atom type pair evaluate potential at each distance

              linal::Vector< double> &energies( mapped_atom_pair_potentials[ mapped_atom_pairs_itr->first] = hist);
              for( size_t dist_bin_index( 0); dist_bin_index < n_bins; ++dist_bin_index)
              {
                if( bgv( dist_bin_index))
                {
                  energies( dist_bin_index) = !energies( dist_bin_index) ? 2.0 : -log( energies( dist_bin_index) / bgv( dist_bin_index));
                }
              }
              BCL_MessageStd( "POS 7");
              BCL_Debug( energies);
            }
          }
        }
        //get background counts from input file, get input counts from sdf/pdb files in input list
        else if( m_InputBGCountsFilename->GetFlag() && !m_InputFGCountsFilename->GetFlag())
        {
          for
          (
            // Go through atom type pairs
            auto mapped_atom_pairs_itr( mapped_atom_pairs.Begin()), mapped_atom_pairs_itr_end( mapped_atom_pairs.End());
            mapped_atom_pairs_itr != mapped_atom_pairs_itr_end;
            ++mapped_atom_pairs_itr
          )
          {
            auto itr_found_types( mapped_atom_pair_counts.Find( mapped_atom_pairs_itr->first));
            if( itr_found_types == mapped_atom_pair_counts.End())
            {
              continue;
            }
            linal::Vector< double> hist( mapped_atom_pairs_itr->second.GetHistogram());
            if( hist.Sum() > n_bins * 2)
            {
              hist.Normalize();
              linal::Vector< double> bg_vec( itr_found_types->second.GetHistogram());
              bg_vec.Normalize();
              linal::Vector< double> &energies( mapped_atom_pair_potentials[ mapped_atom_pairs_itr->first] = hist);
              for( size_t dist_bin_index( 0); dist_bin_index < n_bins; ++dist_bin_index)
              {
                if( bg_vec( dist_bin_index))
                {
                  energies( dist_bin_index) = !energies( dist_bin_index) ? 2.0 : -log( energies( dist_bin_index) / bg_vec( dist_bin_index));
                }
              }
            }
          }
        }
        else if( m_InputBGCountsFilename->GetFlag() && m_InputFGCountsFilename->GetFlag())
        {
          const size_t final_bin( std::min( size_t( 5.0 / ( bin_res)), n_bins));
          for
          (
            auto native_counts_itr( native_counts.Begin()), native_counts_itr_end( native_counts.End());
            native_counts_itr != native_counts_itr_end;
            ++native_counts_itr
          )
          {
            auto itr_found_types( mapped_atom_pair_counts.Find( native_counts_itr->first));
            if( itr_found_types == mapped_atom_pair_counts.End())
            {
              continue;
            }
            static const double pseudocount( 100.0);
            double original_sum( native_counts_itr->second.GetHistogram().Sum());
            native_counts_itr->second.AddPseudoCount( pseudocount);
            double histsumpseudo
            (
              pseudocount / native_counts_itr->second.GetHistogram().Sum()
            );
            linal::Vector< double> hist( native_counts_itr->second.GetHistogram());
            if( original_sum > 100000)
            {
              hist.SetToSum( 1.0);
              const double bg_old_sum( itr_found_types->second.GetHistogram().Sum());
              const double bg_pseudo( histsumpseudo * bg_old_sum / ( 1.0 - histsumpseudo * hist.GetSize()));
              itr_found_types->second.AddPseudoCount( bg_pseudo);
              linal::Vector< double> bg_vec( itr_found_types->second.GetHistogram());
              bg_vec.SetToSum( 1.0);
              linal::Vector< double> &energies( mapped_atom_pair_potentials[ native_counts_itr->first] = linal::Vector< double>( final_bin, double( 0.0)));
              bool have_seen_one( false);
              for( size_t dist_bin_index( 0); dist_bin_index < final_bin; ++dist_bin_index)
              {
                if( bg_vec( dist_bin_index) * bg_old_sum - bg_pseudo > 5000.0)
                {
                  have_seen_one = true;
                  energies( dist_bin_index) = !hist( dist_bin_index) ? 1.0 : std::min( -log( hist( dist_bin_index) / bg_vec( dist_bin_index)), 1.0);
                }
                else
                {
                  energies( dist_bin_index) = 1.0;
                }
              }
            }
          }
        }

        //output the current atom type - potential mappings
        io::OFStream potentials_out;
        io::File::MustOpenOFStream( potentials_out, m_OutputFilename->GetFirstParameter()->GetValue());
        potentials_out << mapped_atom_pair_potentials << '\n';
        io::File::CloseClearFStream( potentials_out);
        //      BCL_Debug(mapped_atom_pair_potentials);
      }

      return 0;
    }

  //////////////////////
  // input and output //
  //////////////////////

    //! @brief read from std::istream
    //! @param ISTREAM input stream
    //! @return istream which was read from
    std::istream &MoleculeAtomPairwisePotential::Read( std::istream &ISTREAM)
    {
      return ISTREAM;
    }

    //! @brief write to std::ostream
    //! @param OSTREAM output stream to write to
    //! @param INDENT number of indentations
    //! @return output stream which was written to
    std::ostream &MoleculeAtomPairwisePotential::Write( std::ostream &OSTREAM, const size_t INDENT) const
    {
      return OSTREAM;
    }

  //////////////////////
  // helper functions //
  //////////////////////

    const ApplicationType MoleculeAtomPairwisePotential::MoleculeAtomPairwisePotential_Instance
    (
      GetAppGroups().AddAppToGroup( new MoleculeAtomPairwisePotential(), GetAppGroups().e_Molecule)
    );

  } // namespace app
} // namespace bcl

