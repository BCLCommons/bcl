// (c) Copyright BCL @ Vanderbilt University 2014
// (c) BCL Homepage: http://www.meilerlab.org/bclcommons
// (c) BCL Code Repository: https://github.com/BCLCommons/bcl
// (c)
// (c) The BioChemical Library (BCL) was originally developed by contributing members of the Meiler Lab @ Vanderbilt University.
// (c)
// (c) The BCL is now made available as an open-source software package distributed under the permissive MIT license,
// (c) developed and maintained by the Meiler Lab at Vanderbilt University and contributing members of the BCL Commons.
// (c)
// (c) External code contributions to the BCL are welcome. Please visit the BCL Commons GitHub page for information on how you can contribute.
// (c)
// (c) This file is part of the BCL software suite and is made available under the MIT license.
// (c)

// include example header
#include "example.h"
// include the header of the class which this example is for
#include "release/bcl_app_cluster.h"

// includes from bcl - sorted alphabetically
#include "example_application_example_helper.h"
#include "cluster/bcl_cluster.h"
#include "io/bcl_io_directory_entry.h"
#include "io/bcl_io_file.h"

// external includes - sorted alphabetically

namespace bcl
{
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //!
  //! @example example_app_cluster.cpp
  //! @brief TODO: add an detailed description for this example
  //!
  //! @author alexanns, kothiwsk
  //! @date Sep 17, 2011
  //! @remarks status complete
  //!
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  class ExampleAppCluster :
    public ExampleInterface
  {
  public:

    ExampleAppCluster *Clone() const
    {
      return new ExampleAppCluster( *this);
    }

  /////////////////
  // data access //
  /////////////////

    //! @brief returns class name
    //! @return the class name as const ref std::string
    const std::string &GetClassIdentifier() const
    {
      return GetStaticClassName( *this);
    }

    int Run() const
    {
    ////////////////
    // unit tests //
    ////////////////

      // unit tests of application class functions, if applicable, go here

    ////////////////////
    // initialization //
    ////////////////////

      // create a helper to run this application
      ApplicationExampleHelper cluster( app::Cluster::Cluster_Instance);

      // check that flags are needed
      BCL_ExampleCheck( cluster.CheckCommandString( false), false);

    ///////////
    // files //
    ///////////

      // create filenames for any input/output files used/generated by the test
      cluster.SetFlag( "distance_input_file", AddExampleInputPathToFilename( e_Cluster, "models_10.matrix"));
      cluster.SetFlag("input_format", "TableLowerTriangle");
      cluster.SetFlag("output_file", AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10.out"));
      cluster.SetFlag("output_format", "Rows");

      // check a valid set of flags.  Since all later commands depend on this command succeeding, make it an assert
      BCL_ExampleCheck( cluster.CheckCommandString( true), true);

      const std::string models_10_rows_filename
      (
        AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10.Rows.out")
      );

      // file containing five arbitrary structures from the csd
      const std::string models_10_rows_filename_correct
      (
        AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10.Rows.out.correct")
      );

      // run a valid set of flags, check that the return status is 0
      if( BCL_ExampleCheck( cluster.RunCommand(), 0))
      {
        // if the application ran successfully, check that files match
        BCL_ExampleIndirectCheck
        (
          io::File::FilesMatch( models_10_rows_filename_correct, models_10_rows_filename),
          true,
          "cluster generated incorrectly"
        );
      }

      // precluster
      {
        cluster.SetFlag( "precluster", "3.5");
        // check a valid set of flags.  Since all later commands depend on this command succeeding, make it an assert
        BCL_ExampleCheck( cluster.CheckCommandString( true), true);
        cluster.SetFlag( "output_file", AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10_precluster.out"));

        const std::string models_10_rows_filename
        (
          AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10_precluster.Rows.out")
        );

        // file containing five arbitrary structures from the csd
        const std::string models_10_rows_filename_correct
        (
          models_10_rows_filename + ".correct"
        );

        // run a valid set of flags, check that the return status is 0
        if( BCL_ExampleCheck( cluster.RunCommand(), 0))
        {
          // if the application ran successfully, check that files match
          BCL_ExampleIndirectCheck
          (
            io::File::FilesMatch( models_10_rows_filename_correct, models_10_rows_filename),
            true,
            "cluster generated incorrectly"
          );
        }
      }

      // pymol output
      {
        cluster.UnsetFlag( "precluster");
        cluster.UnsetFlag( "output_format");
        cluster.SetFlag( "output_format", "Centers");
        cluster.SetFlag
        (
          "output_pymol",
          storage::Vector< std::string>::Create
          (
            "100", "2", "20", "20", "10",
            AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "color_description_dendrogram.py")
          )
        );
        cluster.SetFlag
        (
          "pymol_color_nodes_by_description",
          storage::Vector< std::string>::Create
          (
            AddExampleInputPathToFilename( e_Cluster, "descriptions.ls"), "9.0", "32.0"
          )
        );

        cluster.SetFlag( "output_file", AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10.out"));

        // check a valid set of flags.  Since all later commands depend on this command succeeding, make it an assert
        BCL_ExampleCheck( cluster.CheckCommandString( true), true);

        const std::string models_10_rows_filename
        (
          AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10.Centers.out")
        );

        // file containing five arbitrary structures from the csd
        const std::string models_10_rows_filename_correct
        (
          models_10_rows_filename + ".correct"
        );

        // run a valid set of flags, check that the return status is 0
        if( BCL_ExampleCheck( cluster.RunCommand(), 0))
        {
          // if the application ran successfully, check that files match
          BCL_ExampleIndirectCheck
          (
            io::File::FilesMatch( models_10_rows_filename_correct, models_10_rows_filename),
            true,
            "cluster generated incorrectly"
          );
        }
      }

      // output all node members
      {
        cluster.SetFlag( "output_node_members", AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10_node_members"));
        cluster.SetFlag( "output_file", AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10_output_members.out"));
        cluster.UnsetFlag( "output_pymol");

        // check a valid set of flags.  Since all later commands depend on this command succeeding, make it an assert
        BCL_ExampleCheck( cluster.CheckCommandString( true), true);

        const std::string models_10_rows_filename
        (
          AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10_output_members.Centers.out")
        );

        // file containing five arbitrary structures from the csd
        const std::string models_10_rows_filename_correct
        (
          models_10_rows_filename + ".correct"
        );

        // run a valid set of flags, check that the return status is 0
        if( BCL_ExampleCheck( cluster.RunCommand(), 0))
        {
          // if the application ran successfully, check that files match
          BCL_ExampleIndirectCheck
          (
            io::File::FilesMatch( models_10_rows_filename_correct, models_10_rows_filename),
            true,
            "cluster generated incorrectly"
          );

          const std::string node_files_base( AddExampleOutputPathToFilename( cluster::GetNamespaceIdentifier(), "models_10_node_members_node_"));

          bool all_exist( true);

          // check to make sure all the expected files are present
          for( int x( 1); x <= 19; ++x)
          {
            if( x == 11)
            {
              continue;
            }
            const io::DirectoryEntry current_file( node_files_base + util::Format()( x) + ".ls");
            const bool current_existance( current_file.DoesExist());
            if( !current_existance)
            {
              BCL_MessageDbg( "expected file " + current_file.GetFullName() + " does not exist");
            }
            all_exist &= current_existance;
          }

          BCL_ExampleIndirectCheck
          (
            all_exist,
            true,
            "not all expected files exist"
          );
        }
      }

    ///////////////////////
    // integration tests //
    ///////////////////////

      // set flags; check valid and invalid command lines; check results

      return 0;
    }

    static const ExampleClass::EnumType s_Instance;

  }; //end ExampleAppCluster

  const ExampleClass::EnumType ExampleAppCluster::s_Instance
  (
    GetExamples().AddEnum( ExampleAppCluster())
  );

} // namespace bcl
