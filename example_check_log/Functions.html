<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<head>
<script src="sorttable.js"></script>
</head>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<h2>15054 externally accessible functions founds in include and source directories</h2>
<h3>Clone and GetClassIdentifier are ignored</h3>
<h3>Sorting may take >10 seconds due to the size of the table</h3>

  <H4>Credit for classes / examples is distributed equally among the authors of the class / example</H4>
  <H4>All columns of the table can be sorted by clicking on the appropriate heading</H4>
  <table tableborder="0" cellpadding="1" cellspacing="3" class="sortable">
    <thead>
      <tr>
        <th scope="col" bgcolor="#D5CCB1"><font color="#3300FF" style="bold">Filename</th>
        <th scope="col" bgcolor="#D5CCB1"><font color="#3300FF" style="bold">Class</th>
        <th scope="col" bgcolor="#D5CCB1"><font color="#3300FF" style="bold">Function</th>
        <th scope="col" bgcolor="#D5CCB1"><font color="#3300FF" style="bold">Author(s)</th>
      </tr>
    </thead>
    
    <tbody>
      <tr bgcolor="#FAF0D4">
        <td>apps.cpp</td>
        <td></td>
        <td>main( const int NUMBER_ARGUMENTS, const char *ARGUMENTS[])
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl.h</td>
        <td></td>
        <td>GetCopyright()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align.h</td>
        <td></td>
        <td>GetCharId( const t_Member &MEMBER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align.h</td>
        <td></td>
        <td>GetCompleteId( const t_Member &MEMBER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_dp.h</td>
        <td>AlignerDP</td>
        <td>AlignPair( util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_A, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_B ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_dp.h</td>
        <td>AlignerDP</td>
        <td>SetScoringFunction( const score::AssignmentWithGap< t_Member> &SCORE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_dynamic_programming.h</td>
        <td>AlignerDynamicProgramming</td>
        <td>AlignPair( util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_VERTICAL, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_HORIZONTAL ) const
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_dynamic_programming.h</td>
        <td>AlignerDynamicProgramming</td>
        <td>AlignerDynamicProgramming( const score::AssignmentWithGap< t_Member> &SCORE_ASSIGNMENT = score::AssignmentWithGap< t_Member>() )
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_dynamic_programming.h</td>
        <td>AlignerDynamicProgramming</td>
        <td>SetScoringFunction( const score::AssignmentWithGap< t_Member> &SCORE)
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_merge.h</td>
        <td>AlignerMerge</td>
        <td>AlignMultiple( util::ShPtrList< AlignmentInterface< t_Member> > &ALIGNMENTS ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_merge.h</td>
        <td>AlignerMerge</td>
        <td>AlignPair( util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_A, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_B ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_merge.h</td>
        <td>AlignerMerge</td>
        <td>SetScoringFunction( const score::AssignmentWithGap< t_Member> &SCORE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_merge.h</td>
        <td></td>
        <td>AddInstance( new AlignerMerge< t_Member>())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_progressive.h</td>
        <td>AlignerProgressive</td>
        <td>AlignMultiple( util::ShPtrList< AlignmentInterface< t_Member> > &ALIGNMENTS ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_progressive.h</td>
        <td>AlignerProgressive</td>
        <td>AlignerProgressive( const util::ShPtr< PairwiseAlignerInterface< t_Member> > &PAIRWISE_ALIGNER = GetPairwiseAlignerClasses< t_Member>().e_AlignerDynamicProgramming->HardCopy(), const score::AssignmentWithGap< t_Member> &SCORE = score::AssignmentWithGap< t_Member>(), bool FULL_LINKAGE = false )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_progressive.h</td>
        <td>AlignerProgressive</td>
        <td>SetFullLinkage( const bool FULL_LINKAGE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_progressive.h</td>
        <td>AlignerProgressive</td>
        <td>SetPairwiseAligner( const util::ShPtr< PairwiseAlignerInterface< t_Member> > &PAIRWISE_ALIGNER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_progressive.h</td>
        <td>AlignerProgressive</td>
        <td>SetScoringFunction( const score::AssignmentWithGap< t_Member> &SCORE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_progressive.h</td>
        <td></td>
        <td>AddInstance( new AlignerProgressive< t_Member>())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_shift.h</td>
        <td>AlignerShift</td>
        <td>AlignPair( util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_TOP, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_BOTTOM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_shift.h</td>
        <td>AlignerShift</td>
        <td>AlignPairPair( util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_LEFT_TOP, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_LEFT_BOTTOM, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_RIGHT_TOP, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_RIGHT_BOTTOM, const size_t MAX_NUMBER_GAPS_RIGHT, const size_t MAX_NUMBER_GAPS_LEFT, const bool INSERT_SEPARATOR ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_shift.h</td>
        <td>AlignerShift</td>
        <td>AlignerShift()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_shift.h</td>
        <td>AlignerShift</td>
        <td>AlignmentsPairPair( util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_LEFT_TOP, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_LEFT_BOTTOM, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_RIGHT_TOP, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT_RIGHT_BOTTOM, const size_t MAX_NUMBER_GAPS_RIGHT, const size_t MAX_NUMBER_GAPS_LEFT, const bool INSERT_SEPARATOR ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_shift.h</td>
        <td>AlignerShift</td>
        <td>SetMaxNumberGaps( const size_t MAX_NUMBER_GAPS_LEFT, const size_t MAX_NUMBER_GAPS_RIGHT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_shift.h</td>
        <td>AlignerShift</td>
        <td>SetMinNumberAssignmentsWithoutGap( const size_t MIN_NUMBER_ASSIGNMENTS_WITHOUT_GAP)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_shift.h</td>
        <td>AlignerShift</td>
        <td>SetScoreComparisonFunction( const util::SiPtr< const util::BinaryFunctionInterface< double, double, bool> > &SP_COMPARISON)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_shift.h</td>
        <td>AlignerShift</td>
        <td>SetScoringFunction( const score::AssignmentWithGap< t_Member> &SCORE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_shift.h</td>
        <td>AlignerShift</td>
        <td>SetScoringFunction( const util::ShPtr< function::UnaryInterface< const AlignmentInterface< t_Member>, double> > &SP_SCORE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_shift.h</td>
        <td></td>
        <td>AddInstance( new AlignerShift< t_Member>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_wordbased.h</td>
        <td>AlignerWordbased</td>
        <td>AlignPair( util::ShPtr< AlignmentInterface< t_Member> > &QUERY_ALIGNMENT, util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_wordbased.h</td>
        <td>AlignerWordbased</td>
        <td>AlignPairwise( util::ShPtr< AlignmentInterface< t_Member> > &QUERY_ALIGNMENT, util::ShPtrList< AlignmentInterface< t_Member> > &ALIGNMENT_LIST ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_wordbased.h</td>
        <td>AlignerWordbased</td>
        <td>AlignerWordbased( const score::AssignmentWithGap< t_Member> &SCORE_ASSIGNMENT = score::AssignmentWithGap< t_Member>(), const size_t WORD_LENGTH = s_DefaultWordLength, const size_t MAXIMAL_EXTENSION_WITHOUT_IMPROVEMENT = s_DefaultMaximalExtensionWithoutImprovement )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_aligner_wordbased.h</td>
        <td>AlignerWordbased</td>
        <td>GenerateHits( util::ShPtr< AlignmentInterface< t_Member> > &QUERY_ALIGNMENT, util::ShPtrList< AlignmentInterface< t_Member> > &ALIGNMENT_LIST ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_aligner_wordbased.h</td>
        <td>AlignerWordbased</td>
        <td>SetScoringFunction( const score::AssignmentWithGap< t_Member> &SCORE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>AlignmentHit( const util::ShPtr< AlignmentWord< t_Member> > &ALIGNMENT_A, const util::ShPtr< AlignmentWord< t_Member> > &ALIGNMENT_B )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>AlignmentHit()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>AppendNextAssignment()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>Empty() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetAppendAssignment() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetAssignments() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetBeginItrA() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetBeginItrB() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetChildAlignments() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetDepth() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetEndItrA() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetEndItrB() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetPrependAssignment() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetSequences() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>GetSize() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>IsEmpty() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>PrependNextAssignment()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_hit.h</td>
        <td>AlignmentHit</td>
        <td>ResetAssignments()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_hit.h</td>
        <td></td>
        <td>AddInstance( new AlignmentHit< t_Member>())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_interface.h</td>
        <td>AlignmentInterface</td>
        <td>Append( const util::ShPtr< Assignment< t_Member> > &SP_ASSIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_interface.h</td>
        <td>AlignmentInterface</td>
        <td>Append( const util::ShPtrList< Assignment< t_Member> > &SP_LIST_ASSIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_interface.h</td>
        <td>AlignmentInterface</td>
        <td>GetChildAlignmentsIterator() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_interface.h</td>
        <td>AlignmentInterface</td>
        <td>GetSequenceIds() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_interface.h</td>
        <td>AlignmentInterface</td>
        <td>IsSubAlignment( const AlignmentInterface< t_Member> &SUB_ALIGNMENT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_interface.h</td>
        <td>AlignmentInterface</td>
        <td>Prepend( const util::ShPtr< Assignment< t_Member> > &SP_ASSIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_interface.h</td>
        <td>AlignmentInterface</td>
        <td>Prepend( const util::ShPtrList< Assignment< t_Member> > &SP_LIST_ASSIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_interface.h</td>
        <td>AlignmentInterface</td>
        <td>Score( const score::AssignmentWithGap< t_Member> SCORE_ASSIGNMENT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>AlignmentLeaf( const AlignmentInterface< t_Member> &ALIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>AlignmentLeaf( const util::ShPtr< SequenceInterface< t_Member> > &SP_SEQUENCE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>AlignmentLeaf( const util::ShPtrList< SequenceInterface< t_Member> > &SP_SEQUENCE_LIST)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>Empty() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>GetAssignments() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>GetChildAlignments() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>GetDepth() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>GetSequences() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>GetSize() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>IsEmpty() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_leaf.h</td>
        <td>AlignmentLeaf</td>
        <td>ResetAssignments()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_leaf.h</td>
        <td></td>
        <td>AddInstance( new AlignmentLeaf< t_Member>())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>AlignmentNode( const AlignmentInterface< t_Member> &ALIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>AlignmentNode( const util::ShPtrList< AlignmentInterface< t_Member> > &SP_CHILD_ALIGNMENT_LIST)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>AlignmentNode( util::ShPtr< AlignmentInterface< t_Member> > &SP_CHILD_ALIGNMENT_A, util::ShPtr< AlignmentInterface< t_Member> > &SP_CHILD_ALIGNMENT_B )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>AlignmentNode()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>Empty() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>GetAssignments() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>GetChildAlignments() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>GetDepth() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>GetSequences() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>GetSize() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>IsEmpty() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node.h</td>
        <td>AlignmentNode</td>
        <td>ResetAssignments()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node.h</td>
        <td></td>
        <td>AddInstance( new AlignmentNode< t_Member>())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>AlignmentNodeReference( const util::SiPtr< const AlignmentInterface< t_Member> > &SP_CHILD_ALIGNMENT_A, const util::SiPtr< const AlignmentInterface< t_Member> > &SP_CHILD_ALIGNMENT_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>AlignmentNodeReference( const util::SiPtrList< const AlignmentInterface< t_Member> > &SP_CHILD_ALIGNMENT_LIST)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>AlignmentNodeReference()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>Empty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>GetAssignments() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>GetChildAlignments() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>GetChildAlignmentsIterator() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>GetDepth() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>GetSequences() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>IsEmpty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_node_reference.h</td>
        <td>AlignmentNodeReference</td>
        <td>ResetAssignments()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_node_reference.h</td>
        <td></td>
        <td>AddInstance( new AlignmentNodeReference< t_Member>())
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>AlignmentWord( const util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>AlignmentWord( const util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT, typename AlignmentInterface< t_Member>::const_iterator &ITR_WORD_BEGIN, typename AlignmentInterface< t_Member>::const_iterator &ITR_WORD_END )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>AlignmentWord()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>Empty() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>GetAssignments() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>GetBeginItr() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>GetChildAlignments() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>GetCompleteAlignment() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>GetDepth() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>GetEndItr() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>GetSequences() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>GetSize() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>IsEmpty() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>ResetAssignments()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>ScoreSelf( const score::AssignmentWithGap< t_Member> &ASSIGN_SCORE) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>ScoreWith( const biol::AASequence &SEQUENCE, const score::AssignmentWithGap< t_Member> &ASSIGN_SCORE) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_alignment_word.h</td>
        <td>AlignmentWord</td>
        <td>ToString() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_alignment_word.h</td>
        <td></td>
        <td>AddInstance( new AlignmentWord< t_Member>())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>Append( const util::SiPtr< const t_Member> &SP_MEMBER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>Append( const util::SiPtrList< const t_Member> &SP_MEMBER_LIST)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const Assignment< t_Member> &ASSIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const Assignment< t_Member> &ASSIGNMENT, const util::SiPtr< const t_Member> &SP_MEMBER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const Assignment< t_Member> &ASSIGNMENT_TOP, const Assignment< t_Member> &ASSIGNMENT_BOTTOM)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const util::SiPtr< const t_Member> &SP_MEMBER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const util::SiPtr< const t_Member> &SP_MEMBER, const Assignment< t_Member> &ASSIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const util::SiPtr< const t_Member> &SP_MEMBER_A, const util::SiPtr< const t_Member> &SP_MEMBER_B)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>GetMembers() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>GetSize() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>IsEqual( const Assignment< t_Member> &ASSIGNMENT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>IsIdentical( const Assignment< t_Member> &ASSIGNMENT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_assignment.h</td>
        <td>Assignment</td>
        <td>ToString( const char GAP_CHAR = s_DefaultGapChar) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_assignment.h</td>
        <td></td>
        <td>AddInstance( new Assignment< t_Member>())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_blc.h</td>
        <td>HandlerBLC</td>
        <td>GetFileExtension() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_blc.h</td>
        <td>HandlerBLC</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_blc.h</td>
        <td>HandlerBLC</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_blc.h</td>
        <td>HandlerBLC</td>
        <td>WriteAlignment( std::ostream &OSTREAM, const AlignmentInterface< t_Member> &ALIGNMENT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_blocked.h</td>
        <td>HandlerBlocked</td>
        <td>BlockSize() const
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_blocked.h</td>
        <td>HandlerBlocked</td>
        <td>GetFileExtension() const
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_blocked.h</td>
        <td>HandlerBlocked</td>
        <td>HandlerBlocked( const bool UNGAPPED, const size_t BLOCK_SIZE, const score::AssignmentWithGap< t_Member> &SCORE_ASSIGNMENT )
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_blocked.h</td>
        <td>HandlerBlocked</td>
        <td>HandlerBlocked()
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_blocked.h</td>
        <td>HandlerBlocked</td>
        <td>SetBlockSize( const size_t BLOCK_SIZE)
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_blocked.h</td>
        <td>HandlerBlocked</td>
        <td>SetUnGapped( const bool BOOL)
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_blocked.h</td>
        <td>HandlerBlocked</td>
        <td>UnGapped() const
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_blocked.h</td>
        <td>HandlerBlocked</td>
        <td>WriteAlignment( std::ostream &OSTREAM, const AlignmentInterface< t_Member> &ALIGNMENT) const
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_classes.h</td>
        <td>HandlerClasses</td>
        <td>GetFlagInputFormat()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_classes.h</td>
        <td>HandlerClasses</td>
        <td>GetFlagOutputFormats()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_classes.h</td>
        <td></td>
        <td>GetHandlerClasses()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_fasta.h</td>
        <td>HandlerFasta</td>
        <td>GetFileExtension() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_fasta.h</td>
        <td>HandlerFasta</td>
        <td>WriteAlignment( std::ostream &OSTREAM, const AlignmentInterface< t_Member> &ALIGNMENT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_interface.h</td>
        <td>HandlerInterface</td>
        <td>ReadAlignment( std::istream &ISTREAM, const SequenceInterface< t_Member> &SEQUENCE_TYPE, const char CHAIN_ID = Ã ) const
</td>
        <td>alexanns, heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_interface.h</td>
        <td>HandlerInterface</td>
        <td>ReadAlignment( std::istream &ISTREAM, const util::ShPtrVector< SequenceInterface< t_Member> > &SEQUENCES ) const
</td>
        <td>alexanns, heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_interface.h</td>
        <td>HandlerInterface</td>
        <td>SetAssignmentScore( const util::ShPtr< function::UnaryInterface< const Assignment< t_Member>, double> > &SP_ASSIGNMENT_SCORE )
</td>
        <td>alexanns, heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_pir.h</td>
        <td>HandlerPIR</td>
        <td>GetBlockSize() const
</td>
        <td>teixeipl, heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_pir.h</td>
        <td>HandlerPIR</td>
        <td>GetFileExtension() const
</td>
        <td>teixeipl, heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_pir.h</td>
        <td>HandlerPIR</td>
        <td>HandlerPIR( const char DELIM)
</td>
        <td>teixeipl, heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_pir.h</td>
        <td>HandlerPIR</td>
        <td>HandlerPIR( const size_t BLOCK_SIZE = s_BlockSize)
</td>
        <td>teixeipl, heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_pir.h</td>
        <td>HandlerPIR</td>
        <td>SetBlockSize( const size_t BLOCK_SIZE)
</td>
        <td>teixeipl, heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_pir.h</td>
        <td>HandlerPIR</td>
        <td>WriteAlignment( std::ostream &OSTREAM, const AlignmentInterface< t_Member> &ALIGNMENT) const
</td>
        <td>teixeipl, heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_standard.h</td>
        <td>HandlerStandard</td>
        <td>GetFileExtension() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_standard.h</td>
        <td>HandlerStandard</td>
        <td>HandlerStandard( const util::ShPtr< function::UnaryInterface< const Assignment< t_Member>, double> > &SCORE_ASSIGNMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_handler_standard.h</td>
        <td>HandlerStandard</td>
        <td>SetAssignmentScore( const util::ShPtr< function::UnaryInterface< const Assignment< t_Member>, double> > &SP_ASSIGNMENT_SCORE )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_handler_standard.h</td>
        <td>HandlerStandard</td>
        <td>WriteAlignment( std::ostream &OSTREAM, const AlignmentInterface< t_Member> &ALIGNMENT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_hit_alignment.h</td>
        <td>HitAlignment</td>
        <td>GetBeginInParentAlignmentA() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_hit_alignment.h</td>
        <td>HitAlignment</td>
        <td>GetBeginInParentAlignmentB() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_hit_alignment.h</td>
        <td>HitAlignment</td>
        <td>GetEndInParentAlignmentA() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_hit_alignment.h</td>
        <td>HitAlignment</td>
        <td>GetEndInParentAlignmentB() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_hit_alignment.h</td>
        <td>HitAlignment</td>
        <td>GetScore() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_hit_alignment.h</td>
        <td>HitAlignment</td>
        <td>HitAlignment()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_hit_alignment.h</td>
        <td>HitAlignment</td>
        <td>SetScore( double SCORE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_hit_alignment.h</td>
        <td>HitAlignment</td>
        <td>operator <( const HitAlignment &HIT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_multiple_aligner_classes.h</td>
        <td></td>
        <td>GetMultipleAlignerClasses()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_pairwise_aligner_classes.h</td>
        <td></td>
        <td>GetPairwiseAlignerClasses()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_pairwise_aligner_interface.h</td>
        <td>PairwiseAlignerInterface</td>
        <td>AlignPairwise( util::ShPtr< AlignmentInterface< t_Member> > &ALIGNMENT, util::ShPtrList< AlignmentInterface< t_Member> > &ALIGNMENT_LIST ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>AddMember( const char &ONE_LETTER_CODE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>Append( const SequenceInterface< t_Member> &SEQUENCE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>Begin()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>Begin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>Construct( const std::string &ID, const std::string &MEMBERS, const char CHAIN_ID = Ã ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>End()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>End() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>GetFirstMember() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>GetLastMember() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>GetMembers() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>GetSequenceId() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>GetSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>ReverseBegin()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>ReverseBegin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>ReverseEnd()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>ReverseEnd() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>Sequence( const SequenceInterface< t_Member> &SEQEUENCE, const std::string &IDENTIFICATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_sequence.h</td>
        <td>Sequence</td>
        <td>Sequence( const util::ShPtrVector< t_Member> &MEMBER, const std::string &IDENTIFICATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_word_generator_high_scoring.h</td>
        <td>WordGeneratorHighScoring</td>
        <td>Generate( const util::ShPtr< AlignmentInterface< t_Member> > &QUERY_ALIGNMENT, const size_t WORD_LENGTH ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_word_generator_high_scoring.h</td>
        <td>WordGeneratorHighScoring</td>
        <td>GenerateWordAndScore( const util::ShPtr< AlignmentInterface< t_Member> > &QUERY_ALIGNMENT, const size_t WORD_LENGTH ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_word_generator_high_scoring.h</td>
        <td>WordGeneratorHighScoring</td>
        <td>WordGeneratorHighScoring( const score::AssignmentWithGap< t_Member> &SCORE_ASSIGNMENT = score::AssignmentWithGap< t_Member>() )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_word_generator_high_scoring.h</td>
        <td></td>
        <td>AddInstance( new WordGeneratorHighScoring< t_Member>())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_word_generator_subsequences.h</td>
        <td>WordGeneratorSubsequences</td>
        <td>Generate( const util::ShPtr< AlignmentInterface< t_Member> > &QUERY_ALIGNMENT, const size_t WORD_LENGTH ) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_align_word_generator_subsequences.h</td>
        <td>WordGeneratorSubsequences</td>
        <td>WordGeneratorSubsequences()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_align_word_generator_subsequences.h</td>
        <td></td>
        <td>AddInstance( new WordGeneratorSubsequences< t_Member>())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_add_fragments.cpp</td>
        <td>AddFragments</td>
        <td>AddFragments()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_add_fragments.cpp</td>
        <td>AddFragments</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_add_fragments.cpp</td>
        <td>AddFragments</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_add_fragments.cpp</td>
        <td></td>
        <td>AddAppToGroup( new AddFragments(), GetAppGroups().e_Molecule)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_alchemical_transformation_mapper.cpp</td>
        <td>AlchemicalTransformationMapper</td>
        <td>AlchemicalTransformationMapper()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_alchemical_transformation_mapper.cpp</td>
        <td>AlchemicalTransformationMapper</td>
        <td>AlignPairs( const storage::Vector< chemistry::FragmentComplete> &MOLECULES ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_alchemical_transformation_mapper.cpp</td>
        <td>AlchemicalTransformationMapper</td>
        <td>Analyze() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_alchemical_transformation_mapper.cpp</td>
        <td>AlchemicalTransformationMapper</td>
        <td>BuildTransformationGraph() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_alchemical_transformation_mapper.cpp</td>
        <td>AlchemicalTransformationMapper</td>
        <td>InitializeCommand() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_alchemical_transformation_mapper.cpp</td>
        <td>AlchemicalTransformationMapper</td>
        <td>Main() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_alchemical_transformation_mapper.cpp</td>
        <td>AlchemicalTransformationMapper</td>
        <td>WriteAtomMask( const graph::ConstGraph< std::string, double> &GRAPH, const storage::Vector< chemistry::FragmentComplete> &MOLECULES ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_alchemical_transformation_mapper.cpp</td>
        <td></td>
        <td>AddAppToGroup( new AlchemicalTransformationMapper(), GetAppGroups().e_Molecule)
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_align_binding_poses.h</td>
        <td>AlignBindingPoses</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_align_binding_poses.h</td>
        <td>AlignBindingPoses</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_align_binding_poses.h</td>
        <td>AlignBindingPoses</td>
        <td>WriteContacts( const chemistry::FragmentComplete &FRAG, const assemble::ProteinModel &MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_align_to_msa.cpp</td>
        <td>AlignToMSA</td>
        <td>AlignToMSA()
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_align_to_msa.cpp</td>
        <td>AlignToMSA</td>
        <td>InitializeCommand() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_align_to_msa.cpp</td>
        <td>AlignToMSA</td>
        <td>Main() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_align_to_msa.cpp</td>
        <td></td>
        <td>AddAppToGroup( new AlignToMSA(), GetAppGroups().e_InternalBiol)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_align_to_scaffold.h</td>
        <td>AlignToScaffold</td>
        <td>FindIsomorphism( const chemistry::FragmentComplete &MOLECULE, graph::ConstGraph< size_t, size_t> &SCAFFOLD_GRAPH ) const
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_align_to_scaffold.h</td>
        <td>AlignToScaffold</td>
        <td>InitializeCommand() const
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_align_to_scaffold.h</td>
        <td>AlignToScaffold</td>
        <td>Main() const
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_alignment.h</td>
        <td>Alignment</td>
        <td>GetBCLScopedName() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_alignment.h</td>
        <td>Alignment</td>
        <td>GetDescription() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_alignment.h</td>
        <td>Alignment</td>
        <td>GetReadMe() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_alignment.h</td>
        <td>Alignment</td>
        <td>InitializeCommand() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_alignment.h</td>
        <td>Alignment</td>
        <td>Main() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_analyze_fld_results.cpp</td>
        <td>AnalyzeFLDResults</td>
        <td>AnalyzeFLDResults()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_analyze_fld_results.cpp</td>
        <td>AnalyzeFLDResults</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_analyze_fld_results.cpp</td>
        <td>AnalyzeFLDResults</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_analyze_fld_results.cpp</td>
        <td></td>
        <td>AddAppToGroup( new AnalyzeFLDResults(), GetAppGroups().e_ChemInfo)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_analyze_loops.h</td>
        <td>AnalyzeLoops</td>
        <td>AnalyzeLoops()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_analyze_loops.h</td>
        <td>AnalyzeLoops</td>
        <td>InitializeCommand() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_analyze_loops.h</td>
        <td>AnalyzeLoops</td>
        <td>Main() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_analyze_restraint_agreement.cpp</td>
        <td>ProteinStatistics</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_analyze_restraint_agreement.cpp</td>
        <td>ProteinStatistics</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_analyze_restraint_agreement.cpp</td>
        <td>ProteinStatistics</td>
        <td>Main() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_analyze_restraint_agreement.cpp</td>
        <td></td>
        <td>AddAppToGroup( new ProteinStatistics(), GetAppGroups().e_Restraint)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_analyze_spin_label_parameters.h</td>
        <td>AnalyzeSpinLabelParameters</td>
        <td>AnalyzeSpinLabelParameters()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_analyze_spin_label_parameters.h</td>
        <td>AnalyzeSpinLabelParameters</td>
        <td>InitializeCommand() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_analyze_spin_label_parameters.h</td>
        <td>AnalyzeSpinLabelParameters</td>
        <td>Main() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_apps.h</td>
        <td>Apps</td>
        <td>GetApplicationNames() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_apps.h</td>
        <td>Apps</td>
        <td>GetApplicationsParameter()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_apps.h</td>
        <td>Apps</td>
        <td>GetDefaultCommandLineArgumentsFile()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_apps.h</td>
        <td>Apps</td>
        <td>GetExecutablePath()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_apps.h</td>
        <td>Apps</td>
        <td>GetReleaseApplicationNames() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_apps.h</td>
        <td>Apps</td>
        <td>WriteGenericHelp( std::ostream &OSTREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_apps.h</td>
        <td>Apps</td>
        <td>WriteList( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_apps.h</td>
        <td></td>
        <td>GetApps()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_benchmark_sse_pool.cpp</td>
        <td>BenchmarkSSEPool</td>
        <td>CalculateSumRow( const storage::Table< double> &TABLE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_benchmark_sse_pool.cpp</td>
        <td>BenchmarkSSEPool</td>
        <td>InitializeCommand() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_benchmark_sse_pool.cpp</td>
        <td>BenchmarkSSEPool</td>
        <td>Main() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_benchmark_sse_pool.cpp</td>
        <td></td>
        <td>AddAppToGroup( new BenchmarkSSEPool(), GetAppGroups().e_InternalBiol)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_conformer_library.cpp</td>
        <td>BuildConformerLibrary</td>
        <td>FindConformers( const chemistry::FragmentComplete &MOLECULE, const size_t &MOLECULE_INDEX ) const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_conformer_library.cpp</td>
        <td>BuildConformerLibrary</td>
        <td>InitializeCommand() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_conformer_library.cpp</td>
        <td>BuildConformerLibrary</td>
        <td>Main() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_conformer_library.cpp</td>
        <td></td>
        <td>AddAppToGroup( new BuildConformerLibrary(), GetAppGroups().e_Molecule)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_fragment_library.h</td>
        <td>BuildFragmentLibrary</td>
        <td>GetDescription() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_fragment_library.h</td>
        <td>BuildFragmentLibrary</td>
        <td>GetReadMe() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_fragment_library.h</td>
        <td>BuildFragmentLibrary</td>
        <td>GetWebText() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_fragment_library.h</td>
        <td>BuildFragmentLibrary</td>
        <td>InitializeCommand() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_fragment_library.h</td>
        <td>BuildFragmentLibrary</td>
        <td>Main() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_rotamer_library.h</td>
        <td>BuildRotamerLibrary</td>
        <td>GetDescription() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_rotamer_library.h</td>
        <td>BuildRotamerLibrary</td>
        <td>GetReadMe() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_rotamer_library.h</td>
        <td>BuildRotamerLibrary</td>
        <td>GetWebText() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_rotamer_library.h</td>
        <td>BuildRotamerLibrary</td>
        <td>InitializeCommand() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_rotamer_library.h</td>
        <td>BuildRotamerLibrary</td>
        <td>Main() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_scaffold_library.h</td>
        <td>BuildScaffoldLibrary</td>
        <td>DetermineIfGraphContainsIncompleteRingSystems( const graph::ConstGraph< size_t, size_t> &GRAPH, const chemistry::ConfigurationalBondTypeData::Data &DATA )
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_scaffold_library.h</td>
        <td>BuildScaffoldLibrary</td>
        <td>DetermineIfGraphContainsUnclosedRings( const graph::ConstGraph< size_t, size_t> &GRAPH, const chemistry::ConfigurationalBondTypeData::Data &DATA )
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_scaffold_library.h</td>
        <td>BuildScaffoldLibrary</td>
        <td>GetNextPairToCompare() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_scaffold_library.h</td>
        <td>BuildScaffoldLibrary</td>
        <td>InitializeCommand() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_scaffold_library.h</td>
        <td>BuildScaffoldLibrary</td>
        <td>Main() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_build_scaffold_library.h</td>
        <td>BuildScaffoldLibrary</td>
        <td>MakeHashStringFromGraph( const graph::ConstGraph< size_t, size_t> &GRAPH)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_build_scaffold_library.h</td>
        <td>BuildScaffoldLibrary</td>
        <td>MakeHashStringFromMap( const storage::Map< size_t, size_t> &MAP)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_calculate_cone_model_parameters.cpp</td>
        <td>CalculateConeModelParameters</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_calculate_cone_model_parameters.cpp</td>
        <td>CalculateConeModelParameters</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_calculate_cone_model_parameters.cpp</td>
        <td>CalculateConeModelParameters</td>
        <td>Main() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_calculate_cone_model_parameters.cpp</td>
        <td></td>
        <td>AddAppToGroup( new CalculateConeModelParameters(), GetAppGroups().e_InternalBiol)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_cluster.h</td>
        <td>Cluster</td>
        <td>Cluster()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_cluster.h</td>
        <td>Cluster</td>
        <td>GetDescription() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_cluster.h</td>
        <td>Cluster</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_cluster.h</td>
        <td>Cluster</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_cluster.h</td>
        <td>Cluster</td>
        <td>Main() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_conformer_generator.h</td>
        <td>ConformerGenerator</td>
        <td>GetDescription() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_conformer_generator.h</td>
        <td>ConformerGenerator</td>
        <td>GetReadMe() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_conformer_generator.h</td>
        <td>ConformerGenerator</td>
        <td>GetWebText() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_conformer_generator.h</td>
        <td>ConformerGenerator</td>
        <td>InitializeCommand() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_conformer_generator.h</td>
        <td>ConformerGenerator</td>
        <td>Main() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_contact_prediction.h</td>
        <td>ContactPrediction</td>
        <td>GetBCLScopedName() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_contact_prediction.h</td>
        <td>ContactPrediction</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_contact_prediction.h</td>
        <td>ContactPrediction</td>
        <td>GetReadMe() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_contact_prediction.h</td>
        <td>ContactPrediction</td>
        <td>Main() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_cpu_benchmark.cpp</td>
        <td>CPUBenchmark</td>
        <td>GetReadMe() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_cpu_benchmark.cpp</td>
        <td>CPUBenchmark</td>
        <td>Main() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_cpu_benchmark.cpp</td>
        <td></td>
        <td>AddAppToGroup( new CPUBenchmark(), GetAppGroups().e_Utility)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_create_sse_pool.h</td>
        <td>CreateSSEPool</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_create_sse_pool.h</td>
        <td>CreateSSEPool</td>
        <td>GetReadMe() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_create_sse_pool.h</td>
        <td>CreateSSEPool</td>
        <td>InitializeCommand() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_create_sse_pool.h</td>
        <td>CreateSSEPool</td>
        <td>Main() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_analyze.h</td>
        <td>DescriptorAnalyze</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_analyze.h</td>
        <td>DescriptorAnalyze</td>
        <td>GetDescription() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_analyze.h</td>
        <td>DescriptorAnalyze</td>
        <td>GetReadMe() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_analyze.h</td>
        <td>DescriptorAnalyze</td>
        <td>InitializeCommand() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_analyze.h</td>
        <td>DescriptorAnalyze</td>
        <td>Main() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_convert_code_object_file.h</td>
        <td>DescriptorConvertCodeObjectFile</td>
        <td>InitializeCommand() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_convert_code_object_file.h</td>
        <td>DescriptorConvertCodeObjectFile</td>
        <td>Main() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_dataset_similarity_measures.cpp</td>
        <td>DescriptorDatasetSimilarityMeasures</td>
        <td>DescriptorDatasetSimilarityMeasures()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_dataset_similarity_measures.cpp</td>
        <td>DescriptorDatasetSimilarityMeasures</td>
        <td>InitializeCommand() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_dataset_similarity_measures.cpp</td>
        <td>DescriptorDatasetSimilarityMeasures</td>
        <td>Main() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_dataset_similarity_measures.cpp</td>
        <td></td>
        <td>AddAppToGroup( new DescriptorDatasetSimilarityMeasures(), GetAppGroups().e_Descriptor)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_generate_dataset.h</td>
        <td>DescriptorGenerateDataset</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_generate_dataset.h</td>
        <td>DescriptorGenerateDataset</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_generate_dataset.h</td>
        <td>DescriptorGenerateDataset</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_generate_dataset.h</td>
        <td>DescriptorGenerateDataset</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_generate_dataset.h</td>
        <td>DescriptorGenerateDataset</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_generate_pca_eigenvectors.cpp</td>
        <td>DescriptorGeneratePCAEigenVectors</td>
        <td>InitializeCommand() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_generate_pca_eigenvectors.cpp</td>
        <td>DescriptorGeneratePCAEigenVectors</td>
        <td>Main() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_generate_pca_eigenvectors.cpp</td>
        <td></td>
        <td>AddAppToGroup( new DescriptorGeneratePCAEigenVectors(), GetAppGroups().e_Descriptor)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_refine_by_score.h</td>
        <td>DescriptorRefineByScore</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_refine_by_score.h</td>
        <td>DescriptorRefineByScore</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_refine_by_score.h</td>
        <td>DescriptorRefineByScore</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_refine_by_score.h</td>
        <td>DescriptorRefineByScore</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_refine_by_score.h</td>
        <td>DescriptorRefineByScore</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_score_dataset.h</td>
        <td>DescriptorScoreDataset</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_score_dataset.h</td>
        <td>DescriptorScoreDataset</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_score_dataset.h</td>
        <td>DescriptorScoreDataset</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_score_dataset.h</td>
        <td>DescriptorScoreDataset</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_score_dataset.h</td>
        <td>DescriptorScoreDataset</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_sequential_feature_selection.h</td>
        <td>DescriptorSequentialFeatureSelection</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_sequential_feature_selection.h</td>
        <td>DescriptorSequentialFeatureSelection</td>
        <td>GetDescription() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_sequential_feature_selection.h</td>
        <td>DescriptorSequentialFeatureSelection</td>
        <td>GetReadMe() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_descriptor_sequential_feature_selection.h</td>
        <td>DescriptorSequentialFeatureSelection</td>
        <td>InitializeCommand() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_descriptor_sequential_feature_selection.h</td>
        <td>DescriptorSequentialFeatureSelection</td>
        <td>Main() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_distribution_plot_from_tables.cpp</td>
        <td>DistributionPlotFromTables</td>
        <td>DistributionPlotFromTables()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_distribution_plot_from_tables.cpp</td>
        <td>DistributionPlotFromTables</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_distribution_plot_from_tables.cpp</td>
        <td>DistributionPlotFromTables</td>
        <td>Main() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_distribution_plot_from_tables.cpp</td>
        <td></td>
        <td>AddAppToGroup( new DistributionPlotFromTables(), GetAppGroups().e_Bcl)
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>EvoGenAnalysis</td>
        <td>EvoGenAnalysis()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>EvoGenAnalysis</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>EvoGenAnalysis</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetFitness() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetMemberNumber() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetName() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetNumericalFitness() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetOperation() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetParentNames() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetParentValues() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetPopAndMemberNumbersFromString( const std::string &STRING)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetPopulation() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GetPopulationNumber() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GraphNode( const util::ObjectDataLabel &LABEL)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>GraphNode()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td>GraphNode</td>
        <td>HasParent( const std::string &PARENT_NAME) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evogen_analysis.cpp</td>
        <td></td>
        <td>AddAppToGroup( new EvoGenAnalysis(), GetAppGroups().e_ChemInfo)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>EvoGen</td>
        <td>EvoGen()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>EvoGen</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>EvoGen</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>EvoGen</td>
        <td>SetupDescriptorString() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>EvoGen</td>
        <td>SetupInitialPopulation( chemistry::FragmentEnsemble &INIT_POP, const storage::Vector< chemistry::FragmentComplete> &MOLECULES, size_t POP_SIZE) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolInfo</td>
        <td>MolInfo( const std::string &IDENTIFIER, const chemistry::FragmentComplete &MOLECULE, const float &FITNESS, const std::string &HISTORY = Ó, const size_t &AGE = 0 )
</td>
        <td>geanesar,brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolInfo</td>
        <td>MolInfo()
</td>
        <td>geanesar,brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolInfo</td>
        <td>operator <( const MolInfo &SECOND) const
</td>
        <td>geanesar,brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolInfo</td>
        <td>operator >( const MolInfo &SECOND) const
</td>
        <td>geanesar,brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>CopyByTournament( const std::vector< MolInfo> &FROM, std::vector< MolInfo> &TO, size_t NUM, size_t TOURN_SIZE, const bool &REPLACEMENT = false ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>CopyHighestScoring( std::vector< MolInfo> &FROM, std::vector< MolInfo> &TO, size_t NUM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>EscapeQuotes( const std::string &STR) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>GenerateMolecules( std::vector< MolInfo> &MOLS) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>GetMolInfos() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>MolOptimizer()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>Next()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>PrepareForCSV( const std::string &STR) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>RemoveWhitespace( const std::string &STR) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>ScoreMoleculeInternal( const chemistry::FragmentComplete &MOL) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>ScoreMolecules( std::vector< MolInfo> &MOL_INFOS)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>ScoreMoleculesExternal( std::vector< MolInfo> &MOL_INFOS) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SelectMoleculeTournament( const std::vector< MolInfo> &MOLS, size_t TOURN_SIZE, const std::set< int> &IGNORE_INDICES = std::set< int>() ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetEvolutionBalanceReactionDominant()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetEvolutionBalanceReactionInsertionOnly()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetEvolutionBalanceRecombinationDominant()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetEvolutionBalanceRecombinationInsertionOnly()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetEvolutionBalancedBalanced()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetFinalPopSize( const size_t &POP_SIZE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetInitialPopulation( const chemistry::FragmentEnsemble &MOLS)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetLogFile( const std::string &FILENAME)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetMaxToGenerate( const size_t &MAX)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetModelCmd( const std::string &CMD)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetModelDescriptor( const std::string &DESCRIPTOR)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetModelTypeExternal()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetModelTypeInternal()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetModifyTypeTournament( const float &FACTOR)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetReplacementTypeTournament( const float &FACTOR)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetRetirementTypeAll()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetRetirementTypeNone()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetRetirementTypeProbabilistic()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetSelectionTop()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetupInsertOperation( const std::string &INSERT_MOL_FILENAME)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>SetupReactOperation( const std::string &REACTANT_FILENAME, const std::string &REACTION_DIRNAME)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>StartLogging()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>StopLogging()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td>MolOptimizer</td>
        <td>WriteLog( const std::string &STR)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td></td>
        <td>AddAppToGroup( new EvoGen(), GetAppGroups().e_ChemInfo)
</td>
        <td>geanesar, geanesar,brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td></td>
        <td>operator <( const std::pair< const MolInfo *, size_t> &FIRST, const std::pair< const MolInfo *, size_t> &SECOND)
</td>
        <td>geanesar, geanesar,brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td></td>
        <td>operator <( const util::ShPtr< MolInfo> &FIRST, const util::ShPtr< MolInfo> &SECOND)
</td>
        <td>geanesar, geanesar,brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td></td>
        <td>operator >( const std::pair< const MolInfo *, size_t> &FIRST, const std::pair< const MolInfo *, size_t> &SECOND)
</td>
        <td>geanesar, geanesar,brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_evolutionary_generator.cpp</td>
        <td></td>
        <td>operator >( const util::ShPtr< MolInfo> &FIRST, const util::ShPtr< MolInfo> &SECOND)
</td>
        <td>geanesar, geanesar,brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_exposure_prediction.cpp</td>
        <td>ExposurePrediction</td>
        <td>ExposurePrediction()
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_exposure_prediction.cpp</td>
        <td>ExposurePrediction</td>
        <td>GetReadMe() const
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_exposure_prediction.cpp</td>
        <td>ExposurePrediction</td>
        <td>InitializeCommand() const
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_exposure_prediction.cpp</td>
        <td>ExposurePrediction</td>
        <td>Main() const
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_exposure_prediction.cpp</td>
        <td></td>
        <td>AddAppToGroup( new ExposurePrediction(), GetAppGroups().e_BioInfo)
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_extract_fld_fragments.cpp</td>
        <td>ExtractFocusedLibraryDesignFragments</td>
        <td>ExtractFocusedLibraryDesignFragments()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_extract_fld_fragments.cpp</td>
        <td>ExtractFocusedLibraryDesignFragments</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_extract_fld_fragments.cpp</td>
        <td>ExtractFocusedLibraryDesignFragments</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_extract_fld_fragments.cpp</td>
        <td></td>
        <td>AddAppToGroup( new ExtractFocusedLibraryDesignFragments(), GetAppGroups().e_Molecule)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_extract_mcs.h</td>
        <td>ExtractMCS</td>
        <td>FindMCS( chemistry::FragmentComplete &MCS) const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_extract_mcs.h</td>
        <td>ExtractMCS</td>
        <td>InitializeCommand() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_extract_mcs.h</td>
        <td>ExtractMCS</td>
        <td>Main() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_extract_sites.cpp</td>
        <td>ExtractSites</td>
        <td>InitializeCommand() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_extract_sites.cpp</td>
        <td>ExtractSites</td>
        <td>Main() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_extract_sites.cpp</td>
        <td></td>
        <td>AddAppToGroup( new ExtractSites(), GetAppGroups().e_InternalBiol)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fit_in_density.cpp</td>
        <td>FitInDensity</td>
        <td>GetBCLScopedName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fit_in_density.cpp</td>
        <td>FitInDensity</td>
        <td>GetDescription() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fit_in_density.cpp</td>
        <td>FitInDensity</td>
        <td>GetReadMe() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fit_in_density.cpp</td>
        <td>FitInDensity</td>
        <td>InitializeCommand() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fit_in_density.cpp</td>
        <td>FitInDensity</td>
        <td>Main() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fit_in_density.cpp</td>
        <td></td>
        <td>AddAppToGroup( new FitInDensity(), GetAppGroups().e_Density)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fit_in_density_minimize.cpp</td>
        <td>FitInDensityMinimize</td>
        <td>GetBCLScopedName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fit_in_density_minimize.cpp</td>
        <td>FitInDensityMinimize</td>
        <td>GetDescription() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fit_in_density_minimize.cpp</td>
        <td>FitInDensityMinimize</td>
        <td>GetReadMe() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fit_in_density_minimize.cpp</td>
        <td>FitInDensityMinimize</td>
        <td>InitializeCommand() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fit_in_density_minimize.cpp</td>
        <td>FitInDensityMinimize</td>
        <td>Main() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fit_in_density_minimize.cpp</td>
        <td></td>
        <td>AddAppToGroup( new FitInDensityMinimize(), GetAppGroups().e_Density)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>FocusedLibraryDesign</td>
        <td>GetReadMe() const
</td>
        <td>geanesar, loweew, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>FocusedLibraryDesign</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar, loweew, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>FocusedLibraryDesign</td>
        <td>Main() const
</td>
        <td>geanesar, loweew, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>AddMolecule( const chemistry::FragmentComplete &MOLECULE)
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>CheckUniqueConfiguration( const chemistry::FragmentComplete &MOLECULE)
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>CheckUniqueConstitution( const chemistry::FragmentComplete &MOLECULE)
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>GetMolecules()
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberMCIterations()
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberMCSkipped()
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberMCUnimproved()
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberMoleculesBuilt()
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberMoleculesToBuild()
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>IncreaseMoleculeBuiltCount()
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>ThreadManager</td>
        <td>ThreadManager( util::ShPtr< chemistry::FragmentComplete> START_FRAGMENT, util::ShPtr< chemistry::FragmentComplete> MUTABLE_FRAGMENT, storage::Vector< size_t> MUTABLE_ATOM_INDICES, util::ShPtr< chemistry::FragmentEnsemble> FRAGMENT_POOL, descriptor::CheminfoProperty PROPERTY_SCORER, bool INTERNAL_MCM_OPTI, opti::Tracker< chemistry::FragmentComplete, double> MCM_OPTI_GOAL, bool SAVE_ALL_ACCEPTED_IMPROVED, const size_t &NUMBER_OF_MOLECULES, const size_t &NUMBER_OF_ITERATIONS, const size_t &NUMBER_UNIMPROVED_ITERATIONS, const size_t &NUMBER_SKIPPED_ITERATIONS, const float &METROPOLIS_TEMPERATURE, const size_t &NUMBER_THREADS, const std::string &OUTPUT_FILENAME, const std::string &DRUG_LIKENESS_TYPE, const float &VDW_SCORE_CUTOFF, const util::Implementation< chemistry::FragmentSplitInterface> &SPLIT_IMPLEMENTATION, const size_t &MAX_SEQUENTIAL_MUTATES, const float &RING_SWAP_PROB, const float &CYCLIZE_PROB, const float &ALCHEMY_PROB, const float &REMOVE_ATOM_PROB, const float &REMOVE_BOND_PROB, const float &ADD_MEDCHEM_PROB, const float &SWAP_AMIDE_PROB, const float &FLUORINATE_PROB, const float &HALOGENATE_PROB, const float &EXTEND_WITH_LINKER_PROB, const std::string &POSE_DEPENDENT_MDL_PROPERTY, const std::string &POSE_DEPENDENT_RESOLVE_CLASHES, const bool &CORINA_CONFS )
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design.cpp</td>
        <td>Worker</td>
        <td>RunThread()
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design.cpp</td>
        <td></td>
        <td>AddAppToGroup( new FocusedLibraryDesign(), GetAppGroups().e_ChemInfo)
</td>
        <td>geanesar, loweew, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>FitnessFunctionRaw</td>
        <td>FitnessFunctionRaw( const descriptor::CheminfoProperty &DESCRIPTOR )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>FitnessFunctionRaw</td>
        <td>FitnessFunctionRaw()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>FitnessFunctionRaw</td>
        <td>GetSerializer() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>FitnessFunctionRaw</td>
        <td>operator ()( const chemistry::FragmentComplete &FRAGMENT) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>FocusedLibraryDesignOld</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>FocusedLibraryDesignOld</td>
        <td>Main() const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>ThreadManager</td>
        <td>GetMolecules() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>ThreadManager</td>
        <td>ThreadAddMolecule( const chemistry::FragmentComplete &MOLECULE, const size_t &START_MOL_ID, const float &SCORE, const size_t &TOTAL_MOLS_BUILT )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>ThreadManager</td>
        <td>ThreadManager( const chemistry::FragmentEnsemble &INITIAL_MOLS, const mc::Approximator< chemistry::FragmentComplete, float> &APPROXIMATOR, const float &SCORE_CUTOFF, const size_t &REQUESTED_MOLECULES, const size_t &NUMBER_THREADS, const size_t &MOL_WRITE_SIZE, const std::string &OUTPUT_FILENAME )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>ThreadManager</td>
        <td>WriteMols( const bool &FLUSH = false) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_old.h</td>
        <td>Worker</td>
        <td>RunThread()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>FitnessFunctionRaw</td>
        <td>FitnessFunctionRaw( const descriptor::CheminfoProperty &DESCRIPTOR )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>FitnessFunctionRaw</td>
        <td>FitnessFunctionRaw()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>FitnessFunctionRaw</td>
        <td>GetSerializer() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>FitnessFunctionRaw</td>
        <td>operator ()( const chemistry::FragmentComplete &FRAGMENT) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>FocusedLibraryDesignRecombinationOld</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar, loweew, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>FocusedLibraryDesignRecombinationOld</td>
        <td>Main() const
</td>
        <td>geanesar, loweew, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>HasValenceElectrons</td>
        <td>GetSerializer() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>HasValenceElectrons</td>
        <td>operator ()( const chemistry::FragmentComplete &MOLECULE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>MoleculeTooBig</td>
        <td>GetSerializer() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>MoleculeTooBig</td>
        <td>MoleculeTooBig()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>MoleculeTooBig</td>
        <td>operator ()( const chemistry::FragmentComplete &MOLECULE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ObjectiveFunctionPredict</td>
        <td>ObjectiveFunctionPredict( model::RetrieveInterface::t_Container MODELS, util::ShPtrList< descriptor::Combine< chemistry::AtomConformationalInterface, float> > CODES, const size_t CONF_NUM, const size_t BIN_SIZE, const std::string &CONF_COMPARER )
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ObjectiveFunctionPredict</td>
        <td>ObjectiveFunctionPredict( model::RetrieveInterface::t_Container MODELS, util::ShPtrList< descriptor::Combine< chemistry::AtomConformationalInterface, float> > CODES, const size_t CONF_NUM, const size_t BIN_SIZE, const std::string &CONF_COMPARER, const bool CORINA_BOOL )
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ObjectiveFunctionPredict</td>
        <td>ObjectiveFunctionPredict( model::RetrieveInterface::t_Container MODELS, util::ShPtrList< descriptor::Combine< chemistry::AtomConformationalInterface, float> > CODES, util::ShPtr< chemistry::SampleConformations> SAMPLE_CONFORMATIONS )
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ObjectiveFunctionPredict</td>
        <td>ObjectiveFunctionPredict( model::RetrieveInterface::t_Container MODELS, util::ShPtrList< descriptor::Combine< chemistry::AtomConformationalInterface, float> > CODES, util::ShPtr< chemistry::SampleConformations> SAMPLE_CONFORMATIONS, const bool CORINA_BOOL )
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ObjectiveFunctionPredict</td>
        <td>ObjectiveFunctionPredict()
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ObjectiveFunctionPredict</td>
        <td>operator ()( const chemistry::FragmentComplete &MOLECULE) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ThreadManager</td>
        <td>AddMolecule( const chemistry::FragmentComplete &MOLECULE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ThreadManager</td>
        <td>GetMolecules()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberMoleculesBuilt()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberMoleculesToBuild()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ThreadManager</td>
        <td>IncreaseMoleculeBuiltCount()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>ThreadManager</td>
        <td>ThreadManager( util::ShPtr< chemistry::FragmentComplete> BASE_FRAGMENT, util::ShPtr< chemistry::FragmentEnsemble> FRAGMENT_POOL, model::RetrieveInterface::t_Container MODELS, util::ShPtrList< descriptor::Combine< chemistry::AtomConformationalInterface, float> > CODES, descriptor::CheminfoProperty PROPERTY_SCORER, const size_t &CONFORMATION_NUMBER, const size_t &BIN_SIZE, const std::string &CONFORMATION_COMPARER, const size_t &NUMBER_OF_MOLECULES, const size_t &NUMBER_THREADS, const std::string &OUTPUT_FILENAME )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td>Worker</td>
        <td>RunThread()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_focused_library_design_recombination_old.cpp</td>
        <td></td>
        <td>AddAppToGroup( new FocusedLibraryDesignRecombinationOld(), GetAppGroups().e_ChemInfo)
</td>
        <td>geanesar, loweew, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fold.cpp</td>
        <td>Fold</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>karakam, pinojc, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fold.cpp</td>
        <td>Fold</td>
        <td>GetDescription() const
</td>
        <td>karakam, pinojc, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fold.cpp</td>
        <td>Fold</td>
        <td>GetReadMe() const
</td>
        <td>karakam, pinojc, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fold.cpp</td>
        <td>Fold</td>
        <td>GetWebText() const
</td>
        <td>karakam, pinojc, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fold.cpp</td>
        <td>Fold</td>
        <td>InitializeCommand() const
</td>
        <td>karakam, pinojc, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fold.cpp</td>
        <td>Fold</td>
        <td>Main() const
</td>
        <td>karakam, pinojc, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fold.cpp</td>
        <td></td>
        <td>AddAppToGroup( new Fold(), GetAppGroups().e_Protein)
</td>
        <td>pinojc, karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fold_analysis.cpp</td>
        <td>FoldAnalysis</td>
        <td>InitializeCommand() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fold_analysis.cpp</td>
        <td>FoldAnalysis</td>
        <td>Main() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fold_analysis.cpp</td>
        <td></td>
        <td>AddAppToGroup( new FoldAnalysis(), GetAppGroups().e_Protein)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fold_recognition.cpp</td>
        <td>FoldRecognition</td>
        <td>InitializeCommand() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fold_recognition.cpp</td>
        <td>FoldRecognition</td>
        <td>Main() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fold_recognition.cpp</td>
        <td></td>
        <td>AddAppToGroup( new FoldRecognition(), GetAppGroups().e_Sequence)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fusion_protein.cpp</td>
        <td>FusionProtein</td>
        <td>GetBCLScopedName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fusion_protein.cpp</td>
        <td>FusionProtein</td>
        <td>GetDescription() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fusion_protein.cpp</td>
        <td>FusionProtein</td>
        <td>GetReadMe() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fusion_protein.cpp</td>
        <td>FusionProtein</td>
        <td>InitializeCommand() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fusion_protein.cpp</td>
        <td>FusionProtein</td>
        <td>Main() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fusion_protein.cpp</td>
        <td>Result</td>
        <td>Append( const Result &RESULT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fusion_protein.cpp</td>
        <td>Result</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fusion_protein.cpp</td>
        <td>Result</td>
        <td>Result()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_fusion_protein.cpp</td>
        <td>Result</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_fusion_protein.cpp</td>
        <td></td>
        <td>AddAppToGroup( new FusionProtein(), GetAppGroups().e_Protein)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_aa_pair_statistics.h</td>
        <td>GenerateAAPairStatistics</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_aa_pair_statistics.h</td>
        <td>GenerateAAPairStatistics</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_alignment_description.cpp</td>
        <td>GenerateAlignmentDescription</td>
        <td>InitializeCommand() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_alignment_description.cpp</td>
        <td>GenerateAlignmentDescription</td>
        <td>Main() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_alignment_description.cpp</td>
        <td></td>
        <td>AddAppToGroup( new GenerateAlignmentDescription(), GetAppGroups().e_InternalBiol)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_atom_environment_hashmap.h</td>
        <td>GenerateAtomEnvironmentHashmap</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_atom_environment_hashmap.h</td>
        <td>GenerateAtomEnvironmentHashmap</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_atom_environment_hashmap.h</td>
        <td>GenerateAtomEnvironmentHashmap</td>
        <td>Main() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_atom_hybridization_descriptors.h</td>
        <td>GenerateAtomHybridizationDescriptors</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_atom_hybridization_descriptors.h</td>
        <td>GenerateAtomHybridizationDescriptors</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_atom_hybridization_descriptors.h</td>
        <td>GenerateAtomHybridizationDescriptors</td>
        <td>Main() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_exposure_description.cpp</td>
        <td>GenerateExposureDescription</td>
        <td>ComputeRSASA( const double &SASA_VALUE, const biol::AAType &AA_TYPE)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_exposure_description.cpp</td>
        <td>GenerateExposureDescription</td>
        <td>GenerateExposureDescription()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_exposure_description.cpp</td>
        <td>GenerateExposureDescription</td>
        <td>InitializeCommand() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_exposure_description.cpp</td>
        <td>GenerateExposureDescription</td>
        <td>Main() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_exposure_description.cpp</td>
        <td>GenerateExposureDescription</td>
        <td>ReadSASAFile( const std::string &FILENAME)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_exposure_description.cpp</td>
        <td></td>
        <td>AddAppToGroup( new GenerateExposureDescription(), GetAppGroups().e_InternalBiol)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_hierarchical_tree.h</td>
        <td>GenerateHierarchicalTree</td>
        <td>GetDescription() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_hierarchical_tree.h</td>
        <td>GenerateHierarchicalTree</td>
        <td>GetReadMe() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_hierarchical_tree.h</td>
        <td>GenerateHierarchicalTree</td>
        <td>GetWebText() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_hierarchical_tree.h</td>
        <td>GenerateHierarchicalTree</td>
        <td>InitializeCommand() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_hierarchical_tree.h</td>
        <td>GenerateHierarchicalTree</td>
        <td>Main() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_jufo_description.cpp</td>
        <td>GenerateJufoDescription</td>
        <td>CalculateFirstLayerDescriptors( util::ShPtr< biol::AASequence> &SEQUENCE, const size_t OLIGOMERIC_STATE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_jufo_description.cpp</td>
        <td>GenerateJufoDescription</td>
        <td>InitializeCommand() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_jufo_description.cpp</td>
        <td>GenerateJufoDescription</td>
        <td>Main() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_jufo_description.cpp</td>
        <td></td>
        <td>AddAppToGroup( new GenerateJufoDescription(), GetAppGroups().e_InternalBiol)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_license_file.h</td>
        <td>GenerateLicenseFile</td>
        <td>GetDescription() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_license_file.h</td>
        <td>GenerateLicenseFile</td>
        <td>GetReadMe() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_license_file.h</td>
        <td>GenerateLicenseFile</td>
        <td>InitializeCommand() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_license_file.h</td>
        <td>GenerateLicenseFile</td>
        <td>Main() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_random_orientation_in_density.cpp</td>
        <td>GenerateRandomOrientation</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_random_orientation_in_density.cpp</td>
        <td>GenerateRandomOrientation</td>
        <td>Main() const
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_random_orientation_in_density.cpp</td>
        <td></td>
        <td>AddAppToGroup( new GenerateRandomOrientation(), GetAppGroups().e_Density)
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_rosetta_ncaa_instructions.h</td>
        <td>GenerateRosettaNCAAInstructions</td>
        <td>GetDescription() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_rosetta_ncaa_instructions.h</td>
        <td>GenerateRosettaNCAAInstructions</td>
        <td>GetReadMe() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_rosetta_ncaa_instructions.h</td>
        <td>GenerateRosettaNCAAInstructions</td>
        <td>InitializeCommand() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_rosetta_ncaa_instructions.h</td>
        <td>GenerateRosettaNCAAInstructions</td>
        <td>Main() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_rosetta_ncaa_instructions.h</td>
        <td>GenerateRosettaNCAAInstructions</td>
        <td>ReadNCAABase() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_rosetta_ncaa_instructions.h</td>
        <td>GenerateRosettaNCAAInstructions</td>
        <td>WriteRosettaInstructionsFile( const size_t &NTER_INDEX, const size_t &CA_INDEX, const size_t &C_INDEX, const size_t &O_INDEX, const storage::Vector< size_t> &IGNORE_INDICES, const size_t &UPPER_N_INDEX, const size_t &LOWER_C_INDEX, const float &FORMAL_CHARGE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_sse_pair_matrix.cpp</td>
        <td>GenerateSSEPairMatrix</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_sse_pair_matrix.cpp</td>
        <td>GenerateSSEPairMatrix</td>
        <td>Main() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_sse_pair_matrix.cpp</td>
        <td></td>
        <td>AddAppToGroup( new GenerateSSEPairMatrix(), GetAppGroups().e_Protein)
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_wordbased_aligner_statistics.cpp</td>
        <td>GenerateWordbasedAlignerStatistics</td>
        <td>GenerateWordbasedAlignerStatistics()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_generate_wordbased_aligner_statistics.cpp</td>
        <td>GenerateWordbasedAlignerStatistics</td>
        <td>Main() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_generate_wordbased_aligner_statistics.cpp</td>
        <td></td>
        <td>AddAppToGroup( new GenerateWordbasedAlignerStatistics(), GetAppGroups().e_InternalBiol)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>AddFlagToGroup( const util::ShPtr< command::FlagInterface> &FLAG)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>AddGroupFlags( command::Command &COMMAND)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>AddInstance( const util::ShPtr< Interface> &APP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>Contains( const Interface &APP) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>GetLengthLongestAppGroupName()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>GetLengthLongestAppName()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>GetLengthLongestAppNameThisGroup() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>GetName() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>GroupHandler( const std::string &NAME, const std::string &DESCRIPTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>GroupHandler()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_group_handler.h</td>
        <td>GroupHandler</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0, const size_t &APP_INDENT = s_LongestNameSize, const bool &INCLUDE_DESCRIPTION = true, const bool &INCLUDE_MEMBERS = true, const bool &INCLUDE_MEMBER_DESCRIPTIONS = true, const bool &INCLUDE_MEMBER_ALIASES = true ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_groups.h</td>
        <td>Groups</td>
        <td>AddAppToGroup( Interface *const &APPLICATION, ApplicationGroup &GROUPS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_groups.h</td>
        <td>Groups</td>
        <td>AddAppToGroups( Interface *const &APPLICATION, const storage::Vector< ApplicationGroup> &GROUPS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_groups.h</td>
        <td>Groups</td>
        <td>AddGroup( const GroupHandler &GROUP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_groups.h</td>
        <td>Groups</td>
        <td>GetApplicationGroupsForApp( const Interface &APP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_groups.h</td>
        <td>Groups</td>
        <td>WriteList( std::ostream &OSTREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_groups.h</td>
        <td></td>
        <td>GetAppGroups()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_help.cpp</td>
        <td>Help</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_help.cpp</td>
        <td>Help</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_help.cpp</td>
        <td>Help</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_help.cpp</td>
        <td></td>
        <td>AddAppToGroups( new Help(), storage::Vector< ApplicationGroup>( GetAppGroups().Begin(), GetAppGroups().End()) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>DefaultInstallationProcedure()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>DefaultReadMe()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>DefaultSectionSeparator()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>DefaultTechnicalSupportString() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>DefaultTermsOfUseString()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>GetBCLScopedName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>GetDescription() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>GetLicenseExpirationTime() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>GetLicensedName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>GetNameForGroup( const std::string &GROUP_NAME = Ó) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>GetReadMe() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>GetWebText() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_interface.h</td>
        <td>Interface</td>
        <td>IsReleaseApplication() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_interface_release.h</td>
        <td>InterfaceRelease</td>
        <td>IsReleaseApplication() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_jufo.h</td>
        <td>Jufo</td>
        <td>GetDescription() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_jufo.h</td>
        <td>Jufo</td>
        <td>GetReadMe() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_jufo.h</td>
        <td>Jufo</td>
        <td>GetWebText() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_jufo.h</td>
        <td>Jufo</td>
        <td>InitializeCommand() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_jufo.h</td>
        <td>Jufo</td>
        <td>Main() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>AlkylLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const storage::Vector< size_t> &LINK_INDICES_A, const storage::Vector< size_t> &LINK_INDICES_B, const size_t &REPEATS ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>AmideLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const storage::Vector< size_t> &LINK_INDICES_A, const storage::Vector< size_t> &LINK_INDICES_B, const size_t &REPEATS ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>CallCleaner( const chemistry::FragmentComplete &FRAGMENT, const chemistry::FragmentComplete &REFERENCE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>DirectLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const storage::Vector< size_t> &LINK_INDICES_A, const storage::Vector< size_t> &LINK_INDICES_B ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>EthoxyLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const storage::Vector< size_t> &LINK_INDICES_A, const storage::Vector< size_t> &LINK_INDICES_B, const size_t &REPEATS ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>GenerateAmideLinker( const std::string &CONNECTION, const size_t &REPEATS ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>GetDescription() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>InitializeCommand() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>LigandLocalDock( const chemistry::FragmentEnsemble &ENSEMBLE, const descriptor::CheminfoProperty &SCORER ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>Main() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>MethoxyLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const storage::Vector< size_t> &LINK_INDICES_A, const storage::Vector< size_t> &LINK_INDICES_B, const size_t &REPEATS ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>OpenValence( const chemistry::FragmentComplete &FRAGMENT, const size_t &ATOM_INDEX ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>SingleElementLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const storage::Vector< size_t> &LINK_INDICES_A, const storage::Vector< size_t> &LINK_INDICES_B, const storage::Vector< std::string> &ELEMENT_TYPE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_link_fragments.h</td>
        <td>LinkFragments</td>
        <td>UreaLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const storage::Vector< size_t> &LINK_INDICES_A, const storage::Vector< size_t> &LINK_INDICES_B, const size_t &REPEATS ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_loop_template.h</td>
        <td>LoopTemplate</td>
        <td>InitializeCommand() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_loop_template.h</td>
        <td>LoopTemplate</td>
        <td>LoopTemplate()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_loop_template.h</td>
        <td>LoopTemplate</td>
        <td>Main() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_make_chimeric_molecule.h</td>
        <td>MakeChimericMolecule</td>
        <td>GetReadMe() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_make_chimeric_molecule.h</td>
        <td>MakeChimericMolecule</td>
        <td>InitializeCommand() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_make_chimeric_molecule.h</td>
        <td>MakeChimericMolecule</td>
        <td>Main() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_make_fld_scaffold.cpp</td>
        <td>MakeFocusedLibraryDesignScaffold</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_make_fld_scaffold.cpp</td>
        <td>MakeFocusedLibraryDesignScaffold</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_make_fld_scaffold.cpp</td>
        <td>MakeFocusedLibraryDesignScaffold</td>
        <td>MakeFocusedLibraryDesignScaffold()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_make_fld_scaffold.cpp</td>
        <td></td>
        <td>AddAppToGroup( new MakeFocusedLibraryDesignScaffold(), GetAppGroups().e_Molecule)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_make_grow_fragments.cpp</td>
        <td>MakeGrowFragments</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_make_grow_fragments.cpp</td>
        <td>MakeGrowFragments</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_make_grow_fragments.cpp</td>
        <td>MakeGrowFragments</td>
        <td>MakeGrowFragments()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_make_grow_fragments.cpp</td>
        <td></td>
        <td>AddAppToGroup( new MakeGrowFragments(), GetAppGroups().e_Molecule)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_match_reactions.cpp</td>
        <td>MatchReactions</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_match_reactions.cpp</td>
        <td>MatchReactions</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_match_reactions.cpp</td>
        <td>MatchReactions</td>
        <td>MatchReactions()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_match_reactions.cpp</td>
        <td></td>
        <td>AddAppToGroup( new MatchReactions(), GetAppGroups().e_Molecule)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>FunctionCombine</td>
        <td>FunctionCombine()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>FunctionCombine</td>
        <td>GetFunctions() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>FunctionCombine</td>
        <td>PushBack( const util::ShPtr< math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> > &SP_FUNCTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>FunctionCombine</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>MinimizeScoreWeightSet</td>
        <td>CreateCrossValidationTables( const storage::Table< double> &TRUE_ENTRIES, const storage::Table< double> &FALSE_ENTRIES ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>MinimizeScoreWeightSet</td>
        <td>CreateCrossValidationTablesFromFile( const std::string &FILE_NAME, const storage::Table< double> &WEIGHT_RANGE_TABLE ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>MinimizeScoreWeightSet</td>
        <td>EnrichmentObjective( const storage::Vector< std::string> &TABLE_FILE_NAMES, const std::string &CRITERIA_NAME, const storage::Table< double> &WEIGHT_RANGE_TABLE, storage::Map< std::string, util::ShPtr< FunctionCombine< linal::Vector< double>, double> > > &CONSENSUS_MAP, math::RunningAverageSD< storage::Vector< double> > &AVE_SD ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>MinimizeScoreWeightSet</td>
        <td>InitializeCommand() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>MinimizeScoreWeightSet</td>
        <td>Main() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>MinimizeScoreWeightSet</td>
        <td>MinimizeScoreWeightSet()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>MinimizeScoreWeightSet</td>
        <td>PrintIndividualEnrichments( const linal::Vector< double> &WEIGHTS, const storage::Map< std::string, util::ShPtr< FunctionCombine< linal::Vector< double>, double> > > &CONSENSUS_MAP ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>MinimizeScoreWeightSet</td>
        <td>ROCIntegralObjective( const std::string &TABLE_FILE_NAME, const std::string &CRITERIA_NAME, const storage::Table< double> &WEIGHT_RANGE_TABLE, const math::Comparisons< double>::Comparison &COMPARISON, math::RunningAverageSD< storage::Vector< double> > &AVE_SD ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>NthBest</td>
        <td>NthBest( const size_t POSITION_N)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>NthBest</td>
        <td>NthBest()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>NthBest</td>
        <td>operator ()( const storage::Vector< t_ResultType> &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>SumVector</td>
        <td>SumVector()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td>SumVector</td>
        <td>operator ()( const storage::Vector< t_ResultType> &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_minimize_score_weight_set.cpp</td>
        <td></td>
        <td>AddAppToGroup( new MinimizeScoreWeightSet(), GetAppGroups().e_Bcl)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_compute_statistics.h</td>
        <td>ModelComputeStatistics</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>butkiem1, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_compute_statistics.h</td>
        <td>ModelComputeStatistics</td>
        <td>GetDescription() const
</td>
        <td>butkiem1, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_compute_statistics.h</td>
        <td>ModelComputeStatistics</td>
        <td>GetReadMe() const
</td>
        <td>butkiem1, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_compute_statistics.h</td>
        <td>ModelComputeStatistics</td>
        <td>InitializeCommand() const
</td>
        <td>butkiem1, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_compute_statistics.h</td>
        <td>ModelComputeStatistics</td>
        <td>Main() const
</td>
        <td>butkiem1, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_prediction_merge.h</td>
        <td>ModelPredictionMerge</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_prediction_merge.h</td>
        <td>ModelPredictionMerge</td>
        <td>GetDescription() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_prediction_merge.h</td>
        <td>ModelPredictionMerge</td>
        <td>GetReadMe() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_prediction_merge.h</td>
        <td>ModelPredictionMerge</td>
        <td>GetWebText() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_prediction_merge.h</td>
        <td>ModelPredictionMerge</td>
        <td>InitializeCommand() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_prediction_merge.h</td>
        <td>ModelPredictionMerge</td>
        <td>Main() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_test.h</td>
        <td>ModelTest</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_test.h</td>
        <td>ModelTest</td>
        <td>InitializeCommand() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_test.h</td>
        <td>ModelTest</td>
        <td>Main() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_test_ann_with_dropout_resampling.h</td>
        <td>ModelTestANNWithDropoutResampling</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_test_ann_with_dropout_resampling.h</td>
        <td>ModelTestANNWithDropoutResampling</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_test_ann_with_dropout_resampling.h</td>
        <td>ModelTestANNWithDropoutResampling</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_train.h</td>
        <td>ModelTrain</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_train.h</td>
        <td>ModelTrain</td>
        <td>GetDescription() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_train.h</td>
        <td>ModelTrain</td>
        <td>GetReadMe() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_train.h</td>
        <td>ModelTrain</td>
        <td>GetWebText() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_model_train.h</td>
        <td>ModelTrain</td>
        <td>InitializeCommand() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_model_train.h</td>
        <td>ModelTrain</td>
        <td>Main() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_atom_pairwise_potential.h</td>
        <td>MoleculeAtomPairwisePotential</td>
        <td>GetDescription() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_atom_pairwise_potential.h</td>
        <td>MoleculeAtomPairwisePotential</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_atom_pairwise_potential.h</td>
        <td>MoleculeAtomPairwisePotential</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_atom_pairwise_potential.h</td>
        <td>MoleculeAtomPairwisePotential</td>
        <td>Main() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_compare.h</td>
        <td>MoleculeCompare</td>
        <td>GetDescription() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_compare.h</td>
        <td>MoleculeCompare</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_compare.h</td>
        <td>MoleculeCompare</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_compare.h</td>
        <td>MoleculeCompare</td>
        <td>Main() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_coordinates.h</td>
        <td>MoleculeCoordinates</td>
        <td>ContainsOnlyGasteigerAtomTypes( const storage::VectorND< t_N, size_t> &TYPE)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_coordinates.h</td>
        <td>MoleculeCoordinates</td>
        <td>ConvertAtomBondTypeIntoString( const storage::VectorND< t_N, size_t> &TYPE)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_coordinates.h</td>
        <td>MoleculeCoordinates</td>
        <td>GetDescription() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_coordinates.h</td>
        <td>MoleculeCoordinates</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_coordinates.h</td>
        <td>MoleculeCoordinates</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_coordinates.h</td>
        <td>MoleculeCoordinates</td>
        <td>Main() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_extract_protein_pocket.h</td>
        <td>MoleculeExtractProteinPocket</td>
        <td>GetDescription() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_extract_protein_pocket.h</td>
        <td>MoleculeExtractProteinPocket</td>
        <td>GetReadMe() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_extract_protein_pocket.h</td>
        <td>MoleculeExtractProteinPocket</td>
        <td>InitializeCommand() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_extract_protein_pocket.h</td>
        <td>MoleculeExtractProteinPocket</td>
        <td>Main() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_features.h</td>
        <td>MoleculeFeatures</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_features.h</td>
        <td>MoleculeFeatures</td>
        <td>Main() const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_filter.h</td>
        <td>FilterStatistics</td>
        <td>FilterStatistics( const Type &TYPE, const std::string &DESCRIPTION = std::string())
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_filter.h</td>
        <td>FilterStatistics</td>
        <td>FilterStatistics()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_filter.h</td>
        <td>FilterStatistics</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_filter.h</td>
        <td>FilterStatistics</td>
        <td>GetMatchedCount() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_filter.h</td>
        <td>FilterStatistics</td>
        <td>GetTimer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_filter.h</td>
        <td>FilterStatistics</td>
        <td>GetTypeDescription( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_filter.h</td>
        <td>FilterStatistics</td>
        <td>StartFilter()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_filter.h</td>
        <td>FilterStatistics</td>
        <td>StopFilter( const bool &MATCHED)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_filter.h</td>
        <td>MoleculeFilter</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_filter.h</td>
        <td>MoleculeFilter</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_filter.h</td>
        <td>MoleculeFilter</td>
        <td>GetWebText() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_filter.h</td>
        <td>MoleculeFilter</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_filter.h</td>
        <td>MoleculeFilter</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>MoleculeFit</td>
        <td>GetReadMe() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>MoleculeFit</td>
        <td>InitializeCommand() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>MoleculeFit</td>
        <td>Main() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>AddMolecule( const chemistry::FragmentComplete &MOLECULE, const size_t &MOL_INDEX )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>GetCurrentMolIndex()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>GetMolecules()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberMoleculesFit()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberMoleculesToFit()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>GetNumberThreads()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>GetReceptorFilename()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>SetupAlignToScaffold()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>SetupConformerGenerator()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>SetupMolAlign()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>SetupPoseOptimizer()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>ThreadManager</td>
        <td>ThreadManager( const util::ShPtr< storage::Vector< chemistry::FragmentComplete>> &INPUT_FRAGMENTS, const std::string &OUTPUT_FILENAME, const size_t &NUMBER_THREADS, const util::ShPtr< storage::Vector< chemistry::FragmentComplete>> &SCAFFOLD_FRAGMENTS, const descriptor::CheminfoProperty &PROPERTY_SCORER, const std::string &POSE_DEPENDENT_MDL_PROPERTY, const std::string &RECEPTOR_FILENAME, const std::string &ROUTINE, const size_t &POSE_SAMPLING_ITERATIONS, const size_t &POSE_CYCLES, const size_t &REFINEMENT_ITERATIONS, const float &METROPOLIS_TEMP, const size_t &ALIGNMENT_SOLUTIONS, const opti::Tracker< chemistry::FragmentComplete, double> &OPTI_GOAL, const chemistry::RotamerLibraryFile &ROT_LIB, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>Worker</td>
        <td>GenerateConformers( const chemistry::FragmentComplete &MOLECULE, const bool &LOCAL )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>Worker</td>
        <td>MCSAlignThenDock( chemistry::FragmentComplete &MOLECULE, const storage::Vector<chemistry::FragmentComplete > &SCAFFOLDS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>Worker</td>
        <td>MolAlignThenLocalDock( chemistry::FragmentComplete &MOLECULE, const storage::Vector<chemistry::FragmentComplete > &SCAFFOLDS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>Worker</td>
        <td>PoseSensitiveMCSAlignment( chemistry::FragmentComplete &MOLECULE, const storage::Vector<chemistry::FragmentComplete > &SCAFFOLDS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>Worker</td>
        <td>PropertyBasedAlignment( chemistry::FragmentComplete &MOLECULE, const storage::Vector<chemistry::FragmentComplete > &SCAFFOLDS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>Worker</td>
        <td>ProteinLigandDocking( chemistry::FragmentComplete &MOLECULE, bool LOCAL )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>Worker</td>
        <td>RunThread()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>Worker</td>
        <td>SmallMoleculeAlignment( chemistry::FragmentComplete &MOLECULE, const storage::Vector<chemistry::FragmentComplete > &SCAFFOLDS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_fit.cpp</td>
        <td>Worker</td>
        <td>SmallMoleculeMCSAlignment( chemistry::FragmentComplete &MOLECULE, const storage::Vector<chemistry::FragmentComplete > &SCAFFOLDS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_fit.cpp</td>
        <td></td>
        <td>AddAppToGroup( new MoleculeFit(), GetAppGroups().e_ChemInfo)
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_multialign.h</td>
        <td>MoleculeMultiAlign</td>
        <td>GetDescription() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_multialign.h</td>
        <td>MoleculeMultiAlign</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_multialign.h</td>
        <td>MoleculeMultiAlign</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_multialign.h</td>
        <td>MoleculeMultiAlign</td>
        <td>Main() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_properties.h</td>
        <td>MoleculeProperties</td>
        <td>CheckParametersAreAcceptable() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_properties.h</td>
        <td>MoleculeProperties</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_properties.h</td>
        <td>MoleculeProperties</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_properties.h</td>
        <td>MoleculeProperties</td>
        <td>GetWebText() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_properties.h</td>
        <td>MoleculeProperties</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_properties.h</td>
        <td>MoleculeProperties</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_reorder.h</td>
        <td>MoleculeReorder</td>
        <td>CanonicalizeAtoms( chemistry::FragmentEnsemble &ENSEMBLE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_reorder.h</td>
        <td>MoleculeReorder</td>
        <td>CheckParametersAreAcceptable() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_reorder.h</td>
        <td>MoleculeReorder</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_reorder.h</td>
        <td>MoleculeReorder</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_reorder.h</td>
        <td>MoleculeReorder</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_reorder.h</td>
        <td>MoleculeReorder</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_reorder.h</td>
        <td>MoleculeReorder</td>
        <td>ReorderAtoms( chemistry::FragmentEnsemble &ENSEMBLE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_reorder.h</td>
        <td>MoleculeReorder</td>
        <td>WriteEnsemble( const chemistry::FragmentEnsemble &ENSEMBLE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_split.h</td>
        <td>MoleculeSplit</td>
        <td>GetDescription() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_split.h</td>
        <td>MoleculeSplit</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_split.h</td>
        <td>MoleculeSplit</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_split.h</td>
        <td>MoleculeSplit</td>
        <td>Main() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_unique.h</td>
        <td>MoleculeUnique</td>
        <td>CheckParametersAreAcceptable() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_unique.h</td>
        <td>MoleculeUnique</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_unique.h</td>
        <td>MoleculeUnique</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_unique.h</td>
        <td>MoleculeUnique</td>
        <td>GetWebText() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_unique.h</td>
        <td>MoleculeUnique</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_unique.h</td>
        <td>MoleculeUnique</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_molecule_unique.h</td>
        <td>MoleculeUnique</td>
        <td>MoleculeUnique( const MoleculeUnique &APP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_molecule_unique.h</td>
        <td>MoleculeUnique</td>
        <td>PostProcess( const bool &WAS_UNIQUE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_msa2pssm.h</td>
        <td>MSA2PSSM</td>
        <td>ComputeBlastProfile( const std::string &ALIGNED, const linal::Vector< double> &BACKGROUND_AA_FREQ ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_msa2pssm.h</td>
        <td>MSA2PSSM</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_msa2pssm.h</td>
        <td>MSA2PSSM</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_msa2pssm.h</td>
        <td>MSA2PSSM</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_nmr_file_convert.cpp</td>
        <td>NmrFileConvert</td>
        <td>GenerateProteinModel( const std::string &PDB_STRING) const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_nmr_file_convert.cpp</td>
        <td>NmrFileConvert</td>
        <td>InitializeCommand() const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_nmr_file_convert.cpp</td>
        <td>NmrFileConvert</td>
        <td>Main() const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_nmr_file_convert.cpp</td>
        <td></td>
        <td>AddAppToGroup( new NmrFileConvert(), GetAppGroups().e_Restraint)
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize.h</td>
        <td>Optimize</td>
        <td>InitializeCommand() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_optimize.h</td>
        <td>Optimize</td>
        <td>Main() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize.h</td>
        <td>Optimize</td>
        <td>Optimize()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctions</td>
        <td>AddFunction( const util::ShPtr< math::FunctionInterfaceSerializable< t_Argument, t_Return> > &FUNCTION)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>ConstructMutateCombine() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>ConstructObjectProbabilityDistribution() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>ConstructSumFunction() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>CreateTable() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>GetWeight( const MathFunction &FUNCTION)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>MathFunctionsWeightSet( const MathFunctions< t_Argument, t_Return> &MATH_FUNCTIONS, const double DEFAULT_WEIGHT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>MathFunctionsWeightSet( const storage::Table< double> &TABLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>MathFunctionsWeightSet()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>Reset()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>SetWeight( const std::string &FUNCTION_NAME, const double WEIGHT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>MathFunctionsWeightSet</td>
        <td>SetWeights( const double WEIGHT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>OptimizeDataSetPairwise</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>OptimizeDataSetPairwise</td>
        <td>Main() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td>OptimizeDataSetPairwise</td>
        <td>OptimizeDataSetPairwise()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_optimize_data_set_pairwise.cpp</td>
        <td></td>
        <td>AddAppToGroup( new OptimizeDataSetPairwise(), GetAppGroups().e_Restraint)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>GenerateAlignments( const storage::Vector< std::string> &PDB_VECTOR) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>GetDescription() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>GetFlagSpecifyQualityResidues()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>GetLicensedName() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>Main() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>MatrixOutput( const storage::Map< quality::Measure, storage::Table< double> > &QUALITY_MEASURES, const storage::Map< quality::Measure, storage::Table< double> > &NORM100_QUALITY_MEASURE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>ProteinCompare()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>ProteinModelCompareAll( storage::Map< quality::Measure, storage::Table< double> > &QUALITY_MEASURES, storage::Map< quality::Measure, storage::Table< double> > &NORM100_QUALITY_MEASURES, const storage::Vector< std::string> &STRING_VECTOR_A, const storage::Vector< std::string> &STRING_VECTOR_B, const bool HALF ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>ProteinModelCompareTopology( const storage::Vector< std::string> &STRING_VECTOR, const storage::Table< double> &TOPOLOGY_TABLE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_compare.h</td>
        <td>ProteinCompare</td>
        <td>StringVectorFromPDBListParameter( const util::ShPtr< command::FlagInterface> &FLAG ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_convert.cpp</td>
        <td>PDBConvert</td>
        <td>GetDescription() const
</td>
        <td>alexanns, karakam, lib14, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_convert.cpp</td>
        <td>PDBConvert</td>
        <td>GetPdbWriteFilesTypeDescriptor( const PdbWriteFilesType &PDB_WRITE_FILES_TYPE)
</td>
        <td>alexanns, karakam, lib14, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_convert.cpp</td>
        <td>PDBConvert</td>
        <td>GetReadMe() const
</td>
        <td>alexanns, karakam, lib14, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_convert.cpp</td>
        <td>PDBConvert</td>
        <td>GetRosettaLoopFileTypeDescriptor( const RosettaLoopFileType &ROSETTA_LOOP_FILE_TYPE)
</td>
        <td>alexanns, karakam, lib14, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_convert.cpp</td>
        <td>PDBConvert</td>
        <td>Main() const
</td>
        <td>alexanns, karakam, lib14, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_convert.cpp</td>
        <td>PDBConvert</td>
        <td>MergeHelixBasedTMStretches( const assemble::ProteinModel &MODEL) const
</td>
        <td>alexanns, karakam, lib14, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_convert.cpp</td>
        <td>PDBConvert</td>
        <td>WriteLoopsFile( const assemble::Chain &CHAIN) const
</td>
        <td>alexanns, karakam, lib14, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_convert.cpp</td>
        <td>PDBConvert</td>
        <td>WriteProteinParamsFile( const biol::AASequence &SEQUENCE) const
</td>
        <td>alexanns, karakam, lib14, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_convert.cpp</td>
        <td>PDBConvert</td>
        <td>WriteProteinParamsFiles( const assemble::ProteinModel &MODEL) const
</td>
        <td>alexanns, karakam, lib14, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_convert.cpp</td>
        <td></td>
        <td>AddAppToGroup( new PDBConvert(), GetAppGroups().e_Protein)
</td>
        <td>alexanns, woetzen, karakam, lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_to_density.cpp</td>
        <td>DensityFromPDB</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pdb_to_density.cpp</td>
        <td>DensityFromPDB</td>
        <td>Main() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pdb_to_density.cpp</td>
        <td></td>
        <td>AddAppToGroup( new DensityFromPDB(), GetAppGroups().e_Density)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_perturb_protein.cpp</td>
        <td>ProteinPerturb</td>
        <td>GetDefaultPerturbation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_perturb_protein.cpp</td>
        <td>ProteinPerturb</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_perturb_protein.cpp</td>
        <td>ProteinPerturb</td>
        <td>GetPerturbation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_perturb_protein.cpp</td>
        <td>ProteinPerturb</td>
        <td>GetStartModel() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_perturb_protein.cpp</td>
        <td>ProteinPerturb</td>
        <td>InitializeCommand() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_perturb_protein.cpp</td>
        <td>ProteinPerturb</td>
        <td>Main() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_perturb_protein.cpp</td>
        <td></td>
        <td>AddAppToGroup( new ProteinPerturb(), GetAppGroups().e_Protein)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pharm_map.h</td>
        <td>PharmMap</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_pharm_map.h</td>
        <td>PharmMap</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_pharm_map.h</td>
        <td>PharmMap</td>
        <td>ParsePharmMapCSV( const std::string &FILENAME) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_protein_comparison_gallery.cpp</td>
        <td>ProteinComparisonGallery</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_protein_comparison_gallery.cpp</td>
        <td>ProteinComparisonGallery</td>
        <td>Main() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_protein_comparison_gallery.cpp</td>
        <td>ProteinComparisonGallery</td>
        <td>ProteinComparisonGallery()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_protein_comparison_gallery.cpp</td>
        <td></td>
        <td>AddAppToGroup( new ProteinComparisonGallery(), GetAppGroups().e_Protein)
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_protein_docking.h</td>
        <td>ProteinDocking</td>
        <td>GetDescription() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_protein_docking.h</td>
        <td>ProteinDocking</td>
        <td>InitializeCommand() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_protein_docking.h</td>
        <td>ProteinDocking</td>
        <td>ProteinDocking()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_quench_reactive_groups.cpp</td>
        <td>QuenchReactiveGroups</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_quench_reactive_groups.cpp</td>
        <td>QuenchReactiveGroups</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_quench_reactive_groups.cpp</td>
        <td>QuenchReactiveGroups</td>
        <td>QuenchReactiveGroups()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_quench_reactive_groups.cpp</td>
        <td></td>
        <td>AddAppToGroup( new QuenchReactiveGroups(), GetAppGroups().e_Molecule)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_react_fragments.cpp</td>
        <td>React</td>
        <td>InitializeCommand() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_react_fragments.cpp</td>
        <td>React</td>
        <td>Main() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_react_fragments.cpp</td>
        <td>React</td>
        <td>React()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_react_fragments.cpp</td>
        <td></td>
        <td>AddAppToGroup( new React(), GetAppGroups().e_Molecule)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_reaction_combichem.h</td>
        <td>ReactionCombichem</td>
        <td>CallCleaner( const chemistry::FragmentComplete &FRAGMENT, const chemistry::FragmentComplete &REFERENCE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_reaction_combichem.h</td>
        <td>ReactionCombichem</td>
        <td>GetDescription() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_reaction_combichem.h</td>
        <td>ReactionCombichem</td>
        <td>InitializeCommand() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_reaction_combichem.h</td>
        <td>ReactionCombichem</td>
        <td>LigandLocalDock( const chemistry::FragmentEnsemble &ENSEMBLE, const descriptor::CheminfoProperty &SCORER, const chemistry::FragmentComplete &REFERENCE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_reaction_combichem.h</td>
        <td>ReactionCombichem</td>
        <td>Main() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_reaction_combichem.h</td>
        <td>ReactionCombichem</td>
        <td>RemoveWhitespace( const std::string &STR) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>GetDescription() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>GetReadMe() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>InitializeCommand() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>Main() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>loweew, heinzes1, putnamdk, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>GetDescription() const
</td>
        <td>loweew, heinzes1, putnamdk, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>GetReadMe() const
</td>
        <td>loweew, heinzes1, putnamdk, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>InitializeCommand() const
</td>
        <td>loweew, heinzes1, putnamdk, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>Main() const
</td>
        <td>loweew, heinzes1, putnamdk, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_restraint_saxs_prep.h</td>
        <td>RestraintSaxsPrep</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_restraint_saxs_prep.h</td>
        <td>RestraintSaxsPrep</td>
        <td>GetDescription() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_restraint_saxs_prep.h</td>
        <td>RestraintSaxsPrep</td>
        <td>GetReadMe() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_restraint_saxs_prep.h</td>
        <td>RestraintSaxsPrep</td>
        <td>InitializeCommand() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_restraint_saxs_prep.h</td>
        <td>RestraintSaxsPrep</td>
        <td>Main() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_saxs_statistics.cpp</td>
        <td>SaxsStatistics</td>
        <td>InitializeCommand() const
</td>
        <td>putnamdk, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_saxs_statistics.cpp</td>
        <td>SaxsStatistics</td>
        <td>Main() const
</td>
        <td>putnamdk, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_saxs_statistics.cpp</td>
        <td>SaxsStatistics</td>
        <td>SaxsStatistics()
</td>
        <td>putnamdk, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_saxs_statistics.cpp</td>
        <td></td>
        <td>AddAppToGroup( new SaxsStatistics(), GetAppGroups().e_InternalBiol)
</td>
        <td>putnamdk, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_scatterplot_from_tables.h</td>
        <td>ScatterplotFromTables</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_scatterplot_from_tables.h</td>
        <td>ScatterplotFromTables</td>
        <td>Main() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_scatterplot_from_tables.h</td>
        <td>ScatterplotFromTables</td>
        <td>ScatterplotFromTables()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>CalculateEnrichments() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>CalculateStatistics() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>CheckProteinValidity( const assemble::ProteinModel &PROTEIN) const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>DetermineRank() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>GetDescription() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>GetLicensedName() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>GetReadMe() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>GetWebText() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>InitializeCommand() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>InitializeScores() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>Main() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>PDBFilesWithMembraneFromCommandLine() const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_score_protein.cpp</td>
        <td>ProteinScore</td>
        <td>ScoreSinglePDB( const std::string &FILENAME, const biol::Membrane &MEMBRANE, const math::TransformationMatrix3D &TRANSFORMATION, storage::Row< double> &ROW ) const
</td>
        <td>woetzen, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_score_protein.cpp</td>
        <td></td>
        <td>AddAppToGroup( new ProteinScore(), GetAppGroups().e_Protein)
</td>
        <td>karakam, weinerbe, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_set_sample_by_parts_atoms.h</td>
        <td>SetSampleByPartsAtoms</td>
        <td>GetDescription() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_set_sample_by_parts_atoms.h</td>
        <td>SetSampleByPartsAtoms</td>
        <td>GetReadMe() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_set_sample_by_parts_atoms.h</td>
        <td>SetSampleByPartsAtoms</td>
        <td>InitializeCommand() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_set_sample_by_parts_atoms.h</td>
        <td>SetSampleByPartsAtoms</td>
        <td>Main() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_accessibility_restraints.cpp</td>
        <td>RestraintSimulateAccessibility</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_accessibility_restraints.cpp</td>
        <td>RestraintSimulateAccessibility</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_accessibility_restraints.cpp</td>
        <td>RestraintSimulateAccessibility</td>
        <td>Main() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_accessibility_restraints.cpp</td>
        <td>RestraintSimulateAccessibility</td>
        <td>RestraintSimulateAccessibility()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_accessibility_restraints.cpp</td>
        <td></td>
        <td>AddAppToGroup( new RestraintSimulateAccessibility(), GetAppGroups().e_Restraint)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>GenerateProteinModel( const std::string &PDB_STRING) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>GetAccessibleResidues( const assemble::ProteinModel &MODEL) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>GetAllRestraintsInfo( const util::SiPtrVector< const biol::AABase> &RESIDUES) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>GetDistanceUpperLowerBounds( const linal::Vector3D &COORDINATES_A, const linal::Vector3D &COORDINATES_B ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>GetDistributionBiasAmount() const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>GetExactRestraints( const util::SiPtrVector< const biol::AABase> &RESIDUES ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>GetExplicitlyAllowedRestraints( const util::SiPtrVector< const biol::AABase> &RESIDUES ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>GetRestraintInformation( const biol::AABase &RESI_A, const biol::AABase &RESI_B, const storage::VectorND< 3, double> &DISTANCE_UPPER_LOWER_BOUND ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>Main() const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>OrderRestraintByDistanceChange( const storage::Vector < storage::Pair < storage::VectorND< 2, storage::Triplet< char, int, biol::Atom> >, storage::VectorND< 3, double> > > &RESTRAINTS, const assemble::ProteinModel &START_STATE, const assemble::ProteinModel &END_STATE ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>RandomizeRestraintOrder( const storage::Vector < storage::Pair < storage::VectorND< 2, storage::Triplet< char, int, biol::Atom> >, storage::VectorND< 3, double> > > &RESTRAINTS ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>WriteDistanceRestraintsModifiedCASPFormat( const storage::Vector < storage::Pair < storage::VectorND< 2, storage::Triplet< char, int, biol::Atom> >, storage::VectorND< 3, double> > > &RESTRAINTS, std::ostream &OSTREAM ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>WriteDistanceRestraintsRosettaFormat( const storage::Vector < storage::Pair < storage::VectorND< 2, storage::Triplet< char, int, biol::Atom> >, storage::VectorND< 3, double> > > &RESTRAINTS, std::ostream &OSTREAM ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>WriteDistanceRestraintsRosettaMiniFormat( const storage::Vector < storage::Pair < storage::VectorND< 2, storage::Triplet< char, int, biol::Atom> >, storage::VectorND< 3, double> > > &RESTRAINTS, std::ostream &OSTREAM ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td>RestraintSimulateDistances</td>
        <td>WriteNumberOfDesiredRestraints( const storage::Vector < storage::Pair < storage::VectorND< 2, storage::Triplet< char, int, biol::Atom> >, storage::VectorND< 3, double> > > &RESTRAINTS, const size_t NUMBER_TO_OUTPUT ) const
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_distance_restraints.cpp</td>
        <td></td>
        <td>AddAppToGroup( new RestraintSimulateDistances(), GetAppGroups().e_Restraint)
</td>
        <td>alexanns, teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_rdc_restraints.cpp</td>
        <td>RestraintSimulateRdcs</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_rdc_restraints.cpp</td>
        <td>RestraintSimulateRdcs</td>
        <td>GetRestraintAtomType( const std::string &ATOM_TYPE_FILE) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_rdc_restraints.cpp</td>
        <td>RestraintSimulateRdcs</td>
        <td>InitializeCommand() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_simulate_rdc_restraints.cpp</td>
        <td>RestraintSimulateRdcs</td>
        <td>Main() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_simulate_rdc_restraints.cpp</td>
        <td></td>
        <td>AddAppToGroup( new RestraintSimulateRdcs(), GetAppGroups().e_Restraint)
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>CalculateInformationGain( const linal::Matrix< double> &TABLE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>CalculateMutualInformation( const linal::Matrix< double> &TABLE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>CalculatePercentageCorrectPredictions( const linal::Matrix< double> &TABLE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>CalculatePercentagesByColumns( const linal::Matrix< double> &TABLE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>CalculatePercentagesByRows( const linal::Matrix< double> &TABLE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>CollapseTableTo2State( const linal::Matrix< double> &TABLE, const size_t INDEX) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>InitializeCommand() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>Main() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>Print2StateTable( const linal::Matrix< double> &TWO_STATE_TABLE, const std::string &STATE_NAME, const util::Format &FORMAT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>Print3StateSSTable( const linal::Matrix< double> &THREE_STATE_TABLE, const util::Format &FORMAT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>Print3StateTMTable( const linal::Matrix< double> &THREE_STATE_TABLE, const util::Format &FORMAT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>Print9StateTable( const linal::Matrix< double> &NINE_STATE_TABLE, const util::Format &FORMAT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_sspred.cpp</td>
        <td>SSPred</td>
        <td>ReadPdbTagsAndMembranes() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_sspred.cpp</td>
        <td></td>
        <td>AddAppToGroup( new SSPred(), GetAppGroups().e_Sequence)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_noe.cpp</td>
        <td>StatisticNoe</td>
        <td>GetHydrogenAtomPairs( const storage::List < storage::Pair< util::SiPtr< const biol::Atom>, util::SiPtr< const biol::AABase> > > &HYDROGEN_ATOM_LIST ) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_noe.cpp</td>
        <td>StatisticNoe</td>
        <td>GetHydrogenAtoms( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_noe.cpp</td>
        <td>StatisticNoe</td>
        <td>GetNumberOfBonds( const std::string &ATOM_STRING) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_noe.cpp</td>
        <td>StatisticNoe</td>
        <td>GetProteinModel( const std::string &PDB_FILENAME) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_noe.cpp</td>
        <td>StatisticNoe</td>
        <td>InitializeCommand() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_noe.cpp</td>
        <td>StatisticNoe</td>
        <td>IsBackboneH( const biol::AtomType &ATOM_TYPE) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_noe.cpp</td>
        <td>StatisticNoe</td>
        <td>IsBackboneHA( const biol::AtomType &ATOM_TYPE) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_noe.cpp</td>
        <td>StatisticNoe</td>
        <td>IsBackboneProton( const biol::AtomType &ATOM_TYPE) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_noe.cpp</td>
        <td>StatisticNoe</td>
        <td>Main() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_noe.cpp</td>
        <td></td>
        <td>AddAppToGroup( new StatisticNoe(), GetAppGroups().e_Restraint)
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>AddSpinLabelsAndGiveDistanceBetween( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const assemble::ProteinModel &PROTEIN ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CalculateCBCACAAngleSummation( const biol::AABase &AA_BASE_A, const biol::AABase &AA_BASE_B) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CalculateEPRDistanceAgreement() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CalculateExperimentalSL_CBStatistics( const std::string &RESTRAINT_FILENAME, math::Histogram &TOTAL_HISTOGRAM, const assemble::ProteinModel &PROTEIN_MODEL, math::Histogram2D &HISTOGRAM_2D ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CalculateRadiusOfGyration( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CalculateSLNC_CBNCStatistics( const util::SiPtrVector< const biol::AABase> &AA_LIST, math::Histogram &TOTAL_HISTOGRAM, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CalculateSL_CBDistance( const biol::AABase &AA_BASE_A, const biol::AABase &AA_BASE_B, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CalculateSL_CBStatistics( const util::SiPtrVector< const biol::AABase> &AA_LIST, math::Histogram &TOTAL_HISTOGRAM, const assemble::ProteinModel &PROTEIN_MODEL, math::Histogram2D &HISTOGRAM_2D ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CalculateSL_CB_SL_CBStatistics( const storage::Vector< t_DataType_A> &AA_LIST_A, const storage::Vector< t_DataType_B> &AA_LIST_B, const assemble::AANeighborListContainer &NEIGHBOR_LIST, storage::Vector< math::Histogram> &OFFSET_HISTOGRAM_VECTOR, math::Histogram &TOTAL_HISTOGRAM, const assemble::ProteinModel &PROTEIN_MODEL, storage::Vector< storage::VectorND< 2, storage::Vector< double> > > &DSL_VS_DCB_POINTS ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CalculateSL_NHDistance( const biol::AABase &AA_BASE_A, const biol::AABase &AA_BASE_B, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CreateHistogram2DFromValuePairFile() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>CreateHistogramFromValueFile() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>GetAAsWithAcceptableNeighborCount( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>GetNeighborMeasureValue( const assemble::AANeighborList &RESIDUE_AND_NEIGHBOR_LIST, const bool PRINT_ACCESSIBILITY_STATISTICS = false ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>GetProteinModel( const std::string &PDB_FILENAME) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>GetSSETypesFromCommandLine( const command::FlagInterface &FLAG) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>GetSpinLabelCoordinates( const biol::AABase &AMINO_ACID, const assemble::ProteinModel &PROTEIN, const double &SL_LENGTH, const double &MIN_CA_CB_SL_ANGLE, const double &MAX_CA_CB_SL_ANGLE, const double &MIN_SL_DIHEDRAL_ANGLE, const double &MAX_SL_DIHEDRAL_ANGLE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>Main() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>NeighborMeasureValueMeetsCriteria( const double &NEIGHBOR_MEASURE_VALUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>SLClash( const linal::Vector3D &SL_COORDINATES, const assemble::ProteinModel &PROTEIN, const double CLASH_THRESHOLD ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>SL_CB_SL_CBStatisticsSSESpecific( const assemble::ProteinModel &PROTEIN_MODEL, storage::Vector< math::Histogram> &OFFSET_HISTOGRAM_VECTOR, math::Histogram &TOTAL_HISTOGRAM, storage::Vector< storage::VectorND< 2, storage::Vector< double> > > &DSL_VS_DCB_POINTS ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td>StatisticSpinLabel</td>
        <td>WriteHistogram( const std::string &FILENAME, const t_HistogramType &HISTOGRAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_statistic_spin_label.cpp</td>
        <td></td>
        <td>AddAppToGroup( new StatisticSpinLabel(), GetAppGroups().e_InternalBiol)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_template_model.h</td>
        <td>TemplateModel</td>
        <td>GetDescription() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_template_model.h</td>
        <td>TemplateModel</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_template_model.h</td>
        <td>TemplateModel</td>
        <td>InitializeCommand() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_template_model.h</td>
        <td>TemplateModel</td>
        <td>Main() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_template_model.h</td>
        <td>TemplateModel</td>
        <td>TemplateModel()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_write_app_web_text.cpp</td>
        <td>WriteAppWebText</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_write_app_web_text.cpp</td>
        <td>WriteAppWebText</td>
        <td>InitializeCommand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_write_app_web_text.cpp</td>
        <td>WriteAppWebText</td>
        <td>Main() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_write_app_web_text.cpp</td>
        <td></td>
        <td>AddAppToGroup( new WriteAppWebText(), GetAppGroups().e_Utility)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_write_bcl_object.cpp</td>
        <td>WriteObject</td>
        <td>GetDeprecatedAppNames() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_write_bcl_object.cpp</td>
        <td>WriteObject</td>
        <td>GetDescription() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_write_bcl_object.cpp</td>
        <td>WriteObject</td>
        <td>InitializeCommand() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_app_write_bcl_object.cpp</td>
        <td>WriteObject</td>
        <td>Main() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_app_write_bcl_object.cpp</td>
        <td></td>
        <td>AddAppToGroup( new WriteObject(), GetAppGroups().e_Utility)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_exposure_interface.h</td>
        <td>AAExposureInterface</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_exposure_interface.h</td>
        <td>AAExposureInterface</td>
        <td>GetFlagMinimalSequenceSeparation()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_exposures.h</td>
        <td></td>
        <td>GetAAExposures()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>AANeighborCount( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>GetDefaultMinimalSequenceSeparation()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>GetDefaultThresholdLowHigh()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>GetHistogramFileName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>GetRange() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>GetThresholdRange() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>IsDirect() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>SetMinimalSequenceSeparation( const size_t MINIMAL_SEQUENCE_SEPARATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>SetThresholdRange( const math::Range< double> &RANGE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_count.h</td>
        <td>AANeighborCount</td>
        <td>operator ()( const AANeighborList &AA_NEIGHBOR_LIST) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>AANeighborList( const AANeighborList &PARENT, const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>AANeighborList( const biol::AABase &CENTER_AMINO_ACID = GetDefaultCenterAA())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>AANeighborList( const biol::AABase &CENTER_AMINO_ACID, const NeighborContainerType &AMINO_ACIDS_DISTANCES, const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>AANeighborList( const biol::AABase &CENTER_AMINO_ACID, const util::SiPtrVector< const biol::AABase> &AMINO_ACIDS, const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>Begin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>DecreaseDistanceCutoff( const double DISTANCE_CUTOFF)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>End() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>GetCenterAminoAcid() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>GetDefaultCenterAA()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>GetSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>IncreaseMinimalSequenceSeparation( const size_t MIN_SEQ_SEPARATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>IsEmpty() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>PruneResiduesSameSSE( const ProteinModel &MODEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list.h</td>
        <td>AANeighborList</td>
        <td>RemoveNeighborsWithDifferentChainID()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>AANeighborListContainer( const AANeighborListContainer &AMINO_ACIDS, const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>AANeighborListContainer( const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>AANeighborListContainer( const storage::Vector< storage::Triplet< util::SiPtr< const biol::AABase>, util::SiPtr< const biol::AABase>, double> > &NEIGHBORS, const util::SiPtrVector< const biol::AABase> &AAS, const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>AANeighborListContainer( const util::SiPtrVector< const biol::AABase> &AMINO_ACIDS, const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>AANeighborListContainer( const util::SiPtrVector< const biol::AABase> &AMINO_ACIDS_A, const util::SiPtrVector< const biol::AABase> &AMINO_ACIDS_B, const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>Begin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>End() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>Find( const biol::AABase &AMINO_ACID) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>GetConsiderDifferentChain() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>GetNumberNeighbors() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>GetSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>IntersectionSize( const AANeighborListContainer &CONTAINER) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>IsEmpty() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>Prune( const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container.h</td>
        <td>AANeighborListContainer</td>
        <td>PruneResiduesSameSSE( const ProteinModel &MODEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container_generator_protein_model.h</td>
        <td>AANeighborListContainerGeneratorProteinModel</td>
        <td>AANeighborListGenerator( const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN, const bool CACHED )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container_generator_protein_model.h</td>
        <td>AANeighborListContainerGeneratorProteinModel</td>
        <td>operator ()( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container_generator_sse.h</td>
        <td>AANeighborListContainerGeneratorSSE</td>
        <td>AANeighborListGenerator( const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN, const bool CACHED )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container_generator_sse.h</td>
        <td>AANeighborListContainerGeneratorSSE</td>
        <td>operator ()( const SSE &ELEMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container_generator_sse_pair.h</td>
        <td>AANeighborListContainerGeneratorSSEPair</td>
        <td>AANeighborListGenerator( const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN, const bool CACHED )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container_generator_sse_pair.h</td>
        <td>AANeighborListContainerGeneratorSSEPair</td>
        <td>operator ()( const SSE &ELEMENT_A, const SSE &ELEMENT_B) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_list_container_pruner.h</td>
        <td>AANeighborListContainerPruner</td>
        <td>AANeighborListContainerPruner( const double DISTANCE_CUTOFF, const size_t MIN_SEQ_SEPARATION, const bool CONSIDER_DIFFERENT_CHAIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_list_container_pruner.h</td>
        <td>AANeighborListContainerPruner</td>
        <td>operator ()( const AANeighborListContainer &CONTAINER) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>AANeighborVector( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>GetDefaultThresholdLowHigh()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>GetHistogramFileName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>GetRange() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>GetThresholdRange() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>IsDirect() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>NeighborVector( const AANeighborList &AA_NEIGHBOR_LIST, const math::Range< double> &THRESHOLD_LOW_HIGH, const bool NORMALIZE_BY_NEIGHBOR_COUNT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>SetMinimalSequenceSeparation( const size_t MINIMAL_SEQUENCE_SEPARATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>SetThresholdRange( const math::Range< double> &RANGE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_neighbor_vector.h</td>
        <td>AANeighborVector</td>
        <td>operator ()( const AANeighborList &AA_NEIGHBOR_LIST) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>AASasaOLS( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>GetDefaultSphereRadius()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>GetHistogramFileName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>GetRange() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>GetThresholdRange() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>IsDirect() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>SetMinimalSequenceSeparation( const size_t MINIMAL_SEQUENCE_SEPARATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>SetThresholdRange( const math::Range< double> &RANGE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_aa_sasa_ols.h</td>
        <td>AASasaOLS</td>
        <td>operator ()( const AANeighborList &AA_NEIGHBOR_LIST) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_analyze_chi_angle_pair_distribution.h</td>
        <td>AnalyzeChiAnglePairDistribution</td>
        <td>AnalyzeChiAnglePairDistribution()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_analyze_chi_angle_pair_distribution.h</td>
        <td>AnalyzeChiAnglePairDistribution</td>
        <td>GetMinMax()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_analyze_chi_angle_pair_distribution.h</td>
        <td>AnalyzeChiAnglePairDistribution</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_analyze_chi_angle_pair_distribution.h</td>
        <td>AnalyzeChiAnglePairDistribution</td>
        <td>operator ()( const ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_analyze_chi_angle_recovery.h</td>
        <td>AnalyzeChiAngleRecovery</td>
        <td>AnalyzeChiAngleRecovery()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_analyze_chi_angle_recovery.h</td>
        <td>AnalyzeChiAngleRecovery</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_analyze_chi_angle_recovery.h</td>
        <td>AnalyzeChiAngleRecovery</td>
        <td>operator ()( const ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_analyze_protein_ensemble_aa_neighborhood.h</td>
        <td>AnalyzeProteinEnsembleAANeighborhood</td>
        <td>AnalyzeProteinEnsembleAANeighborhood()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_analyze_protein_ensemble_aa_neighborhood.h</td>
        <td>AnalyzeProteinEnsembleAANeighborhood</td>
        <td>GetOutFilePostfix() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_analyze_protein_ensemble_aa_neighborhood.h</td>
        <td>AnalyzeProteinEnsembleAANeighborhood</td>
        <td>operator ()( const ProteinEnsemble &ENSEMBLE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_analyze_protein_ensemble_interface.h</td>
        <td>AnalyzeProteinEnsembleInterface</td>
        <td>GetFlagOutFilePrefix()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_analyze_protein_ensemble_interface.h</td>
        <td>AnalyzeProteinEnsembleInterface</td>
        <td>WriteAnalysisFile( const std::string &OUT_FILE_PREFIX, const ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_biomolecule.h</td>
        <td>Biomolecule</td>
        <td>Biomolecule( const storage::Set< biol::AtomType> &ATOM_TYPES, const util::ShPtr< quality::SuperimposeInterface> &SUPERIMPOSE, const double THRESHOLD )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_biomolecule.h</td>
        <td>Biomolecule</td>
        <td>Biomolecule()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_biomolecule.h</td>
        <td>Biomolecule</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_biomolecule.h</td>
        <td>Biomolecule</td>
        <td>operator ()( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>AddLoops( const bool UNDEFINED_COORDINATES, const bool MERGE_CONSECUTIVE_SSES, const biol::SSType &SS_TYPE = biol::GetSSTypes().COIL )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>AdoptSSEsMaintainCoordinates( const util::SiPtrVector< const SSE> &SSES)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Chain( const Chain &CHAIN_RHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Chain( const util::ShPtr< biol::AASequence> &SP_SEQUENCE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Chain( const util::ShPtr< biol::AASequence> &SP_SEQUENCE, const Domain &SOURCE_DOMAIN)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Chain( const util::ShPtr< biol::AASequence> &SP_SEQUENCE, const util::ShPtrVector< SSE> &SSE_VECTOR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Chain()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>ChopSSEs( const storage::VectorND< 3, size_t> &MIN_SSE_LENGTHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>ConnectSSEToChainData()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>DoesContain( const SSE &THIS_SSE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>DoesContainOverlapping( const SSE &THIS_SSE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>FilterByMinSSESizes( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>FindSSE( const SSE &SSE_TO_SEARCH) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetCenter() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetChainID() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetData() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetIdentification() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetNumberAAs() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetNumberSSE( const biol::SSType &SS_TYPE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetNumberSSEs() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetSSEHashString() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetSSEs( const biol::SSType &SS_TYPE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetSSEs( const storage::Set< biol::SSType> &SS_TYPES) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetSSEs() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>GetSequence()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>HardCopy() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Insert( const Domain &NEW_DOMAIN)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Insert( const util::ShPtr< SSE> &NEW_SSE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Insert( const util::ShPtrVector< SSE> &NEW_SSE_VECTOR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>IsEmpty() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Join( const biol::SSType &SS_TYPE, const bool TEST_PEPTIDE_BOND)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Remove( const SSE &SSELEMENT)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Replace( const util::ShPtr< SSE> &SP_SSE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>ReplaceWithOverlapping( const util::ShPtr< SSE> &SP_SSE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>SetChainID( const char CHAINID)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>SetToIdealConformation( const bool KEEP_POSITION = true)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>Translate( const linal::Vector3D &TRANSLATION_VECTOR_3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>Chain</td>
        <td>operator =( const Chain &CHAIN_RHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td>ChainLessThan</td>
        <td>operator ()( const Chain &CHAIN_LHS, const Chain &CHAIN_RHS) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain.h</td>
        <td>ChainLessThan</td>
        <td>operator ()( const util::PtrInterface< Chain> &PTR_CHAIN_LHS, const util::PtrInterface< Chain> &PTR_CHAIN_RHS ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain.h</td>
        <td></td>
        <td>ConstructChainWithSSEsFromConformation( const util::ShPtr< biol::AASequence> &SP_SEQUENCE)
</td>
        <td>karakam, weinerbe, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain_multiplier.h</td>
        <td>ChainMultiplier</td>
        <td>ChainMultiplier( const util::ShPtr< util::FunctionInterface< SSE, util::ShPtr< SSE> > > &SSE_TRANSFORMER, const char INITIAL_CHAIN_ID, const util::ShPtr< math::TransformationMatrix3D> &TRANSFORMATION, const util::ShPtr< biol::AASequence> &SEQUENCE )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain_multiplier.h</td>
        <td>ChainMultiplier</td>
        <td>ChainMultiplier()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain_multiplier.h</td>
        <td>ChainMultiplier</td>
        <td>GetInitialChainID() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain_multiplier.h</td>
        <td>ChainMultiplier</td>
        <td>GetNewChainID() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain_multiplier.h</td>
        <td>ChainMultiplier</td>
        <td>GetTransformationMatrix() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain_multiplier.h</td>
        <td>ChainMultiplier</td>
        <td>HardCopy() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain_multiplier.h</td>
        <td>ChainMultiplier</td>
        <td>operator ()( const Chain &CHAIN) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_chain_multiplier.h</td>
        <td>ChainMultiplierLessThan</td>
        <td>operator ()( const ChainMultiplier &CHAIN_MULTIPLIER_LHS, const ChainMultiplier &CHAIN_MULTIPLIER_RHS ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_chain_multiplier.h</td>
        <td>ChainMultiplierLessThan</td>
        <td>operator ()( const util::PtrInterface< ChainMultiplier> &PTR_CHAIN_MULTIPLIER_LHS, const util::PtrInterface< ChainMultiplier> &PTR_CHAIN_MULTIPLIER_RHS ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_aa_specified.h</td>
        <td>CollectorAASpecified</td>
        <td>Collect( const ProteinModel &MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_aa_specified.h</td>
        <td>CollectorAASpecified</td>
        <td>CollectorAASpecified( const std::string &RESI_LIST_FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_aa_specified.h</td>
        <td>CollectorAASpecified</td>
        <td>CollectorAASpecified()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_aa_specified.h</td>
        <td>CollectorAASpecified</td>
        <td>GetResidueList() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_aa_specified.h</td>
        <td>CollectorAASpecified</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_aa_specified.h</td>
        <td>CollectorAASpecified</td>
        <td>ReadAALocators( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_aa_type.h</td>
        <td>CollectorAAType</td>
        <td>Collect( const util::SiPtrVector< const biol::AABase> &RESIDUES) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_aa_type.h</td>
        <td>CollectorAAType</td>
        <td>CollectorAAType( const storage::Set< biol::AAType> &AA_TYPES)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_aa_type.h</td>
        <td>CollectorAAType</td>
        <td>CollectorAAType()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_aa_type.h</td>
        <td>CollectorAAType</td>
        <td>Locate( const util::SiPtrVector< const biol::AABase> &RESIDUES) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_all_possible_domains.h</td>
        <td>CollectorAllPossibleDomains</td>
        <td>Collect( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_all_possible_domains.h</td>
        <td>CollectorAllPossibleDomains</td>
        <td>CollectorAllPossibleDomains( const math::Range< size_t> DOMAIN_SIZE = math::Range< size_t>( 0, std::numeric_limits< size_t>::max()), const bool CONNECTED_DOMAIN = false, const util::ShPtr< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> > &PACKING_CRITERIA = GetDefaultPackingCriteria() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_all_possible_domains.h</td>
        <td>CollectorAllPossibleDomains</td>
        <td>GetDefaultPackingCriteria()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_all_possible_domains.h</td>
        <td>CollectorAllPossibleDomains</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_common_aa.h</td>
        <td>CollectorCommonAA</td>
        <td>Collect( const storage::VectorND< 2, ProteinModel> &PROTEIN_MODELS) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_common_aa.h</td>
        <td>CollectorCommonAA</td>
        <td>Collect( const storage::VectorND< 2, util::SiPtr< const util::SiPtrList< const biol::AABase> > > &AAS_DEFINED )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_common_aa.h</td>
        <td>CollectorCommonAA</td>
        <td>CollectCommonCoordinates( const storage::VectorND< 2, util::SiPtr< const util::SiPtrList< const biol::AABase> > > &AAS_DEFINED, const storage::Set< biol::AtomType> &ATOM_TYPES, size_t &NR_COMMON_RESIDUES )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_common_aa.h</td>
        <td>CollectorCommonAA</td>
        <td>CollectCommonCoordinates( const util::SiPtrList< const biol::AABase> &AAS_DEFINED_A, const util::SiPtrList< const biol::AABase> &AAS_DEFINED_B, const storage::Set< biol::AtomType> &ATOM_TYPES, size_t &NR_COMMON_RESIDUES )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_common_aa.h</td>
        <td>CollectorCommonAA</td>
        <td>CollectDefinedAAsInChains( const ProteinModel &PROTEIN_MODEL )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_common_aa.h</td>
        <td>CollectorCommonAA</td>
        <td>CollectDefinedAAsInSSEs( const ProteinModel &PROTEIN_MODEL )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_common_aa.h</td>
        <td>CollectorCommonAA</td>
        <td>CollectorCommonAA( const CollectorCommonAA &COLLECTOR)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_common_aa.h</td>
        <td>CollectorCommonAA</td>
        <td>CollectorCommonAA()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_common_aa.h</td>
        <td>CollectorCommonAA</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_protein_model_conformation_by_score.h</td>
        <td>CollectorProteinModelConformationByScore</td>
        <td>Collect( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_protein_model_conformation_by_score.h</td>
        <td>CollectorProteinModelConformationByScore</td>
        <td>CollectorProteinModelConformationByScore( const size_t NUM_TO_COLLECT, const util::ShPtr< util::BinaryFunctionInterfaceSerializable< double, double, bool> > &SORT, const bool CONSIDER_CURRENT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_protein_model_conformation_by_score.h</td>
        <td>CollectorProteinModelConformationByScore</td>
        <td>CollectorProteinModelConformationByScore( const util::ShPtr< math::FunctionInterfaceSerializable< ProteinModel, double> > &SCORE, const size_t NUM_TO_COLLECT, const util::ShPtr< util::BinaryFunctionInterfaceSerializable< double, double, bool> > &SORT, const bool CONSIDER_CURRENT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_protein_model_conformation_by_score.h</td>
        <td>CollectorProteinModelConformationByScore</td>
        <td>CollectorProteinModelConformationByScore()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_protein_model_conformation_by_score.h</td>
        <td>CollectorProteinModelConformationByScore</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_protein_model_conformations.h</td>
        <td>CollectorProteinModelConformations</td>
        <td>Collect( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_protein_model_conformations.h</td>
        <td>CollectorProteinModelConformations</td>
        <td>CollectorProteinModelConformations( const bool CONSIDER_CURRENT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_protein_model_conformations.h</td>
        <td>CollectorProteinModelConformations</td>
        <td>CollectorProteinModelConformations()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_protein_model_conformations.h</td>
        <td>CollectorProteinModelConformations</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sheet.h</td>
        <td>CollectorSheet</td>
        <td>Collect( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sheet.h</td>
        <td>CollectorSheet</td>
        <td>CollectorSheet()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sheet.h</td>
        <td>CollectorSheet</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse.h</td>
        <td>CollectorSSE</td>
        <td>Collect( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse.h</td>
        <td>CollectorSSE</td>
        <td>Collect( const util::SiPtrVector< const SSE> &SSES) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse.h</td>
        <td>CollectorSSE</td>
        <td>CollectorSSE( const biol::SSType &SS_TYPE)
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse.h</td>
        <td>CollectorSSE</td>
        <td>CollectorSSE( const storage::Set< biol::SSType> &SS_TYPES)
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse.h</td>
        <td>CollectorSSE</td>
        <td>CollectorSSE()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse.h</td>
        <td>CollectorSSE</td>
        <td>GetSSTypes() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse.h</td>
        <td>CollectorSSE</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse.h</td>
        <td>CollectorSSE</td>
        <td>SetSSTypes( const storage::Set< biol::SSType> &SS_TYPES)
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>Collect( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>CollectorSSEPaired( const SSEGeometryPackingPicker &PACKING_PICKER, const storage::Set< contact::Type> &CONTACT_TYPES, const double MAX_DISTANCE, const bool ORTHOGONAL_CONNECTION )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>CollectorSSEPaired()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>GetContactTypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>GetMaxDistance() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>GetOrthogonalConnection() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>SetContactTypes( const storage::Set< contact::Type> &CONTACT_TYPES)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>SetMaxDistance( const double MAX_DISTANCE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_paired.h</td>
        <td>CollectorSSEPaired</td>
        <td>SetOrthogonalConnection( const bool ORTHOGONAL_CONNECTION)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_size.h</td>
        <td>CollectorSSESize</td>
        <td>Collect( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_size.h</td>
        <td>CollectorSSESize</td>
        <td>CollectorSSESize( const math::Range< size_t> &SIZE_RANGE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_size.h</td>
        <td>CollectorSSESize</td>
        <td>CollectorSSESize( const storage::Map< biol::SSType, math::Range< size_t> > &SIZE_RANGE_MAP)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_size.h</td>
        <td>CollectorSSESize</td>
        <td>GetRanges() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_size.h</td>
        <td>CollectorSSESize</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_unpaired.h</td>
        <td>CollectorSSEUnpaired</td>
        <td>Collect( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_unpaired.h</td>
        <td>CollectorSSEUnpaired</td>
        <td>CollectorSSEUnpaired( const contact::Type &CONTACT_TYPE, const double MAX_DISTANCE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_unpaired.h</td>
        <td>CollectorSSEUnpaired</td>
        <td>CollectorSSEUnpaired()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_unpaired.h</td>
        <td>CollectorSSEUnpaired</td>
        <td>GetContactType() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_unpaired.h</td>
        <td>CollectorSSEUnpaired</td>
        <td>GetMaxDistance() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_unpaired.h</td>
        <td>CollectorSSEUnpaired</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_sse_unpaired.h</td>
        <td>CollectorSSEUnpaired</td>
        <td>SetContactType( const contact::Type &CONTACT_TYPE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_sse_unpaired.h</td>
        <td>CollectorSSEUnpaired</td>
        <td>SetMaxDistance( const double MAX_DISTANCE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_topology_combined.h</td>
        <td>CollectorTopologyCombined</td>
        <td>CalculateTopology( const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_topology_combined.h</td>
        <td>CollectorTopologyCombined</td>
        <td>Collect( const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_topology_combined.h</td>
        <td>CollectorTopologyCombined</td>
        <td>CollectorTopologyCombined( const bool INCLUDE_UNPACKED_GEOMETRIES = true)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_topology_combined.h</td>
        <td>CollectorTopologyCombined</td>
        <td>GetPackingCriteria()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_topology_combined.h</td>
        <td>CollectorTopologyCombined</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_topology_sheet.h</td>
        <td>CollectorTopologySheet</td>
        <td>CalculateTopology( const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_topology_sheet.h</td>
        <td>CollectorTopologySheet</td>
        <td>Collect( const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_topology_sheet.h</td>
        <td>CollectorTopologySheet</td>
        <td>CollectorTopologySheet()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_topology_sheet.h</td>
        <td>CollectorTopologySheet</td>
        <td>GetPackingComparison()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_collector_topology_sheet.h</td>
        <td>CollectorTopologySheet</td>
        <td>GetPackingCriteria()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_collector_topology_sheet.h</td>
        <td>CollectorTopologySheet</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>ChopSSEs( const storage::VectorND< 3, size_t> &MIN_SSE_LENGTHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>CreateSequenceFromSSEs() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>DoesContain( const SSE &THIS_SSE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>DoesContainOverlapping( const SSE &THIS_SSE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Domain( const Domain &DOMAIN_RHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Domain( const storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> &SSE_SET)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Domain( const storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> &SSE_SET, const util::ShPtr< Topology> &SP_TOPOLOGY )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Domain( const util::ShPtrVector< SSE> &SSE_VECTOR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Domain( const util::ShPtrVector< SSE> &SSE_VECTOR, const util::ShPtr< Topology> &SP_TOPOLOGY )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Domain()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>FilterByMinSSESizes( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>FindSSE( const SSE &SSE_TO_SEARCH) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetCenter() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetChainIds() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetData() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetNumberAAs() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetNumberSSE( const biol::SSType &SS_TYPE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetNumberSSEs() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetOrientation() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetSSEs( const biol::SSType &SS_TYPE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetSSEs() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>GetTopology() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>HardCopy() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Insert( const Domain &NEW_DOMAIN)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Insert( const util::ShPtr< SSE> &SSELEMENT)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Insert( const util::ShPtrVector< SSE> &SSE_VECTOR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>IsEmpty() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Join( const biol::SSType &SS_TYPE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Remove( const SSE &SSELEMENT)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Replace( const util::ShPtr< SSE> &SP_SSE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>ReplaceWithOverlapping( const util::ShPtr< SSE> &SP_SSE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>SetData( const storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> &SSE_SET)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>SetToIdealConformation( const bool KEEP_POSITION = true)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>SetTopology( const util::ShPtr< Topology> &SP_TOPOLOGY)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>Translate( const linal::Vector3D &TRANSLATION_VECTOR_3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain.h</td>
        <td>Domain</td>
        <td>operator =( const Domain &DOMAIN_RHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>DoesContain( const SSE &THIS_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>DoesContainOverlapping( const SSE &THIS_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetAdjacentSSEs( const SSE &TARGET_SSE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetAminoAcids() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetAtomCoordinates( const storage::Set< biol::AtomType> &ATOM_TYPES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetAtomCoordinates() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetAtoms( const storage::Set< biol::AtomType> &ATOM_TYPES) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetAtoms() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetCenter() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetIdentification() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetNeighborSSEs( const SSE &TARGET_SSE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetNumberSSEs( const biol::SSType &SS_TYPE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetNumberSSEs() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetOverlappingSSEs( const SSE &TARGET_SSE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetSSEGeometries( const biol::SSType &SS_TYPE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetSSEGeometries() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetSSEs( const biol::SSType &SS_TYPE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetSSEs( const storage::Set< biol::SSType> &SS_TYPES) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetSSEsWithShortLoops( const SSE &TARGET_SSE, const size_t MAX_LOOP_LENGTH ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetSSEsWithShortLoops( const size_t MAX_LOOP_LENGTH ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>GetSSEsWithShortLoops( const util::SiPtrList< const SSE> &SSE_LIST, const size_t MAX_LOOP_LENGTH ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_domain_interface.h</td>
        <td>DomainInterface</td>
        <td>IsEmpty() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_ensemble.h</td>
        <td>Element</td>
        <td>Element( t_DataType &ELEMENT, double POPULATION_SIZE = 1.0)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_ensemble.h</td>
        <td>Element</td>
        <td>Element()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_ensemble.h</td>
        <td>Element</td>
        <td>GetElement()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_ensemble.h</td>
        <td>Element</td>
        <td>GetPopulationSize() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_ensemble.h</td>
        <td>Element</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_ensemble.h</td>
        <td>Ensemble</td>
        <td>AddElement( Element &ELEMENT)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_ensemble.h</td>
        <td>Ensemble</td>
        <td>AddElement( t_DataType &ELEMENT, double POPULATION_SIZE = 1.0)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_ensemble.h</td>
        <td>Ensemble</td>
        <td>Begin()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_ensemble.h</td>
        <td>Ensemble</td>
        <td>End()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_ensemble.h</td>
        <td>Ensemble</td>
        <td>Ensemble( const t_InputIterator &ITERATOR, const t_InputIterator &ITERATOR_END)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_ensemble.h</td>
        <td>Ensemble</td>
        <td>Ensemble()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_ensemble.h</td>
        <td>Ensemble</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_ensemble.h</td>
        <td>Ensemble</td>
        <td>GetSize() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_ensemble.h</td>
        <td>Ensemble</td>
        <td>RemoveElement( iterator ITERATOR)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>CalculateSSEGeometries()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>CalculateTopology()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>FitSSEs( const util::SiPtrVector< const SSE> &SSES_TO_FIT) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>FoldTemplate( const FoldTemplate &FOLD_TEMPLATE)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>FoldTemplate( const ProteinModel &PROTEIN_MODEL, const util::ShPtr< CollectorTopologyInterface> &TOPOLOGY_COLLECTOR, const std::string &PDB_ID = GetDefaultPDBID(), const bool TRIM_GEOMETRIES = true )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>FoldTemplate( const util::ShPtrVector< SSEGeometryPhiPsi> &GEOMETRIES, const util::ShPtr< CollectorTopologyInterface> &TOPOLOGY_COLLECTOR, const std::string &PDB_ID = GetDefaultPDBID(), const bool SORT_BY_SIZE = true )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>FoldTemplate()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetCenter() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetDefaultPDBID()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetGeometries() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetGeometryIndentifications() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetHelicalGeometries() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetPDBID() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetRadiusOfGyration() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetStrandGeometries() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetSubDomain( const size_t HELICES, const size_t STRANDS) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetSubDomain( const util::SiPtrVector< const SSE> &SSES, const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE = SSEGeometryWithinSizeTolerance() ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetTopology() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>HasDefinedAngles() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>HasDefinedGeometries() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>HasSimilarSizeGeometries( const util::SiPtrVector< const SSE> &SSES, const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &GEOMETRY_COMPARE ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>HasSimilarSizeGeometry( const util::SiPtr< const SSE> &SP_SSE, const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &GEOMETRY_COMPARE ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>IsTopologyInitialized() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATIONMATRIX3D)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>SetTopology( const Topology &TOPOLOGY)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>WriteCompact( std::ostream &OSTREAM) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>operator =( const FoldTemplate &FOLD_TEMPLATE)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template_handler.h</td>
        <td>FoldTemplateHandler</td>
        <td>FoldTemplateHandler()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template_handler.h</td>
        <td>FoldTemplateHandler</td>
        <td>GetFlagFoldTemplates()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template_handler.h</td>
        <td>FoldTemplateHandler</td>
        <td>GetRandomSubTemplate( const util::SiPtrVector< const SSE> &SSES, const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE = SSEGeometryWithinSizeTolerance() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_fold_template_handler.h</td>
        <td>FoldTemplateHandler</td>
        <td>GetRandomTemplate( const size_t HELICES, const size_t STRANDS)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_fold_template_handler.h</td>
        <td>FoldTemplateHandler</td>
        <td>GetRandomTemplate( const util::SiPtrVector< const SSE> &SSES, const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE = SSEGeometryWithinSizeTolerance() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>GetAAID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>GetAAType() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>GetLocatorChain() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>GetUsePDBID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>Locate( ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>Locate( SSE &SSE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>Locate( const DomainInterface &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>Locate( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>Locate( const SSE &SSE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>Locate( const util::SiPtrVector< const biol::AABase> &RESIDUE_LIST) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>Locate( util::SiPtrVector< biol::AABase> &RESIDUE_LIST) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>LocateSSE( ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>LocateSSE( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>LocatorAA( const char CHAIN_ID, const int AA_ID, const biol::AAType &TYPE, const bool USE_PDB_ID = false)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>LocatorAA( const char CHAIN_ID, const int AA_ID, const bool USE_PDB_ID = false)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>LocatorAA()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>ReadIdentification( std::istream &ISTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>SetAAID( const int AA_ID)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_aa.h</td>
        <td>LocatorAA</td>
        <td>SetLocatorChain( const LocatorChain &LOCATOR_CHAIN)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_aa.h</td>
        <td></td>
        <td>operator <( const LocatorAA &LOCATOR_A, const LocatorAA &LOCATOR_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>GetAAType() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>GetAtomType() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>GetChainID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>GetLocatorAA() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>GetSeqID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>Locate( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>LocateAtom( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>LocateAtomFromModel( const ProteinModel &PROTEIN_MODEL, const char CHAIN_ID, const int SEQ_ID, const biol::AtomType &ATOM_TYPE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>LocatorAtom( const char CHAIN_ID, const int AA_ID, const biol::AtomType &ATOM_TYPE, const biol::AAType &AA_TYPE, const bool USE_PDB_ID = false )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>LocatorAtom( const char CHAIN_ID, const int AA_ID, const biol::AtomType &ATOM_TYPE, const bool USE_PDB_ID = false)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>LocatorAtom( const char CHAIN_ID, const int AA_ID, const bool USE_PDB_ID = false)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>LocatorAtom()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>ReadIdentification( std::istream &ISTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>SetAtomType( const biol::AtomType &ATOM_TYPE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom.h</td>
        <td>LocatorAtom</td>
        <td>SetLocatorAA( const LocatorAA &LOCATOR_AA)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td></td>
        <td>operator !=( const LocatorAtom &LOCATOR_A, const LocatorAtom &LOCATOR_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom.h</td>
        <td></td>
        <td>operator <( const LocatorAtom &LOCATOR_A, const LocatorAtom &LOCATOR_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom.h</td>
        <td></td>
        <td>operator ==( const LocatorAtom &LOCATOR_A, const LocatorAtom &LOCATOR_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>CreateLocator( const biol::AABase &AA_BASE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>CreateLocators( const biol::AASequence &SEQUENCE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>GetNameFromPair( const LocatorAtomCoordinatesInterface &LOCATOR_A, const LocatorAtomCoordinatesInterface &LOCATOR_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>GetPymolAtomSelection() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>GetPymolName() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>GetPymolResidueSelection() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>IsWithin( const SSE &SSE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>LocateAA( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>LocateAA( const SSE &SSE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>LocateAA( const util::SiPtrVector< const biol::AABase> &RESIDUE_LIST) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>LocateAtom( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>LocateAtomCopy( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>LocateSSE( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>LocateSSE( const storage::Set< util::SiPtr< const SSE>, SSELessThanNoOverlap> &SSES ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>LocatorAtomCoordinatesInterface</td>
        <td>LocateSSE( const util::SiPtrVector< const SSE> &SSES) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>PtrLessThan</td>
        <td>operator ()( const util::PtrInterface< LocatorAtomCoordinatesInterface> &LHS, const util::PtrInterface< LocatorAtomCoordinatesInterface> &RHS ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td>PtrResidueLessThan</td>
        <td>operator ()( const util::PtrInterface< LocatorAtomCoordinatesInterface> &LHS, const util::PtrInterface< LocatorAtomCoordinatesInterface> &RHS ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td></td>
        <td>operator !=( const LocatorAtomCoordinatesInterface &LHS, const LocatorAtomCoordinatesInterface &RHS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_atom_coordinates_interface.h</td>
        <td></td>
        <td>operator <( const LocatorAtomCoordinatesInterface &LHS, const LocatorAtomCoordinatesInterface &RHS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_chain.h</td>
        <td>LocatorChain</td>
        <td>GetChainID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_chain.h</td>
        <td>LocatorChain</td>
        <td>Locate( const ProteinModel &MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_chain.h</td>
        <td>LocatorChain</td>
        <td>LocatorChain( const char CHAIN_ID)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_chain.h</td>
        <td>LocatorChain</td>
        <td>LocatorChain()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_chain.h</td>
        <td>LocatorChain</td>
        <td>SetChainID( const char CHAINID)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_domain_random.h</td>
        <td>LocatorDomainRandom</td>
        <td>GetDomainSizeRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_domain_random.h</td>
        <td>LocatorDomainRandom</td>
        <td>GetSSType() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_domain_random.h</td>
        <td>LocatorDomainRandom</td>
        <td>Locate( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_domain_random.h</td>
        <td>LocatorDomainRandom</td>
        <td>LocatorDomainRandom( const math::Range< size_t> &DOMAIN_SIZE_RANGE, const biol::SSType &SS_TYPE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_domain_random.h</td>
        <td>LocatorDomainRandom</td>
        <td>LocatorDomainRandom()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_domain_specified.h</td>
        <td>LocatorDomainSpecified</td>
        <td>Locate( const ProteinModel &MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_domain_specified.h</td>
        <td>LocatorDomainSpecified</td>
        <td>LocatorDomainSpecified( const util::ShPtrList < find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > &LOCATORS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_domain_specified.h</td>
        <td>LocatorDomainSpecified</td>
        <td>LocatorDomainSpecified()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_domain_specified.h</td>
        <td>LocatorDomainSpecified</td>
        <td>WritePymolDomainFile( std::ostream &OSTREAM, const std::string &PYMOL_NAME) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_domain_sse_pool_overlapping.h</td>
        <td>LocatorDomainSSEPoolOverlapping</td>
        <td>GetPool() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_domain_sse_pool_overlapping.h</td>
        <td>LocatorDomainSSEPoolOverlapping</td>
        <td>Locate( const ProteinModel &MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_domain_sse_pool_overlapping.h</td>
        <td>LocatorDomainSSEPoolOverlapping</td>
        <td>LocatorDomainSSEPoolOverlapping( const SSEPool &POOL)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_domain_sse_pool_overlapping.h</td>
        <td>LocatorDomainSSEPoolOverlapping</td>
        <td>LocatorDomainSSEPoolOverlapping()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>EndAALocator() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>GetChainID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>GetSSEID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>GetSSEIDString() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>Locate( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>LocatorSSE( const char CHAINID, const int SSE_START, const int SSE_END, const bool USE_PDB_ID = false)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>LocatorSSE()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>SetSSEID( const int NEW_SSE_START, const int NEW_SSE_END)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse.h</td>
        <td>LocatorSSE</td>
        <td>StartAALocator() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_from_protein_model_data.h</td>
        <td>LocatorSSEFromProteinModelData</td>
        <td>Locate( const DomainInterface &PROTEIN_MODEL) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_from_protein_model_data.h</td>
        <td>LocatorSSEFromProteinModelData</td>
        <td>LocatorSSEFromProteinModelData( const ProteinModelData::Type KEY)
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_from_protein_model_data.h</td>
        <td>LocatorSSEFromProteinModelData</td>
        <td>LocatorSSEFromProteinModelData()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_furthest.h</td>
        <td>LocatorSSEFurthest</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_furthest.h</td>
        <td>LocatorSSEFurthest</td>
        <td>Locate( const DomainInterface &SSE_DOMAIN, const t_CriteriaType &CRITERIA) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_furthest.h</td>
        <td>LocatorSSEFurthest</td>
        <td>LocatorSSEFurthest( const find::CollectorCriteriaInterface< util::SiPtrList< const SSE>, DomainInterface, t_CriteriaType> &COLLECTOR )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_furthest.h</td>
        <td>LocatorSSEFurthest</td>
        <td>LocatorSSEFurthest( const util::ShPtr< find::CollectorCriteriaInterface< util::SiPtrList< const SSE>, DomainInterface, t_CriteriaType> > &SP_COLLECTOR )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_furthest.h</td>
        <td>LocatorSSEFurthest</td>
        <td>LocatorSSEFurthest()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_random.h</td>
        <td>LocatorSSERandom</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_random.h</td>
        <td>LocatorSSERandom</td>
        <td>Locate( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_random.h</td>
        <td>LocatorSSERandom</td>
        <td>LocatorSSERandom()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_terminus_residue.h</td>
        <td>LocatorSSETerminusResidue</td>
        <td>GetChainID() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_terminus_residue.h</td>
        <td>LocatorSSETerminusResidue</td>
        <td>GetIdentification() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_terminus_residue.h</td>
        <td>LocatorSSETerminusResidue</td>
        <td>GetLocateCTerminus() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_terminus_residue.h</td>
        <td>LocatorSSETerminusResidue</td>
        <td>GetSSEID() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_terminus_residue.h</td>
        <td>LocatorSSETerminusResidue</td>
        <td>GetSSEIDString() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_terminus_residue.h</td>
        <td>LocatorSSETerminusResidue</td>
        <td>Locate( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_terminus_residue.h</td>
        <td>LocatorSSETerminusResidue</td>
        <td>LocatorSSETerminusResidue( const char CHAINID, const int SSE_START, const biol::AASequenceFlexibility::SequenceDirection &TERMINUS )
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_terminus_residue.h</td>
        <td>LocatorSSETerminusResidue</td>
        <td>LocatorSSETerminusResidue()
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_unpaired.h</td>
        <td>LocatorSSEUnpaired</td>
        <td>GetCollector() const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_unpaired.h</td>
        <td>LocatorSSEUnpaired</td>
        <td>Locate( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_unpaired.h</td>
        <td>LocatorSSEUnpaired</td>
        <td>LocatorSSEUnpaired( const find::PickCriteriaInterface< util::SiPtr< const SSE>, util::SiPtrList< const SSE>, linal::Vector3D> &PICK, const contact::Type &CONTACT_TYPE, const double MAX_DISTANCE )
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_unpaired.h</td>
        <td>LocatorSSEUnpaired</td>
        <td>LocatorSSEUnpaired( const util::ShPtr< find::PickCriteriaInterface< util::SiPtr< const SSE>, util::SiPtrList< const SSE>, linal::Vector3D> > &SP_PICK, const contact::Type &CONTACT_TYPE, const double MAX_DISTANCE )
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_unpaired.h</td>
        <td>LocatorSSEUnpaired</td>
        <td>LocatorSSEUnpaired()
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sse_unpaired.h</td>
        <td>LocatorSSEUnpaired</td>
        <td>SetCollector( const CollectorSSEUnpaired &COLLECTOR)
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sse_unpaired.h</td>
        <td>LocatorSSEUnpaired</td>
        <td>SetPick( const util::ShPtr< find::PickCriteriaInterface< util::SiPtr< const SSE>, util::SiPtrList< const SSE>, linal::Vector3D> > &PICK)
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sses_random.h</td>
        <td>LocatorSSEsRandom</td>
        <td>Locate( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sses_random.h</td>
        <td>LocatorSSEsRandom</td>
        <td>LocatorSSEsRandom( const size_t NUMBER_SSES, const util::ShPtr< find::CollectorInterface< util::SiPtrList< const SSE>, DomainInterface> > &SP_COLLECTOR_SSE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sses_random.h</td>
        <td>LocatorSSEsRandom</td>
        <td>LocatorSSEsRandom()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sub_domain_random.h</td>
        <td>LocatorSubDomainRandom</td>
        <td>GetLocateConsecutive() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sub_domain_random.h</td>
        <td>LocatorSubDomainRandom</td>
        <td>GetSizeRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sub_domain_random.h</td>
        <td>LocatorSubDomainRandom</td>
        <td>GetUseTopologyOrder() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sub_domain_random.h</td>
        <td>LocatorSubDomainRandom</td>
        <td>Locate( const util::ShPtr< Domain> &SP_DOMAIN) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sub_domain_random.h</td>
        <td>LocatorSubDomainRandom</td>
        <td>LocatorSubDomainRandom( const math::Range< size_t> &SIZE_RANGE, bool LOCATE_CONSECUTIVE, bool USE_TOPOLOGY_ORDER )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_locator_sub_domain_random.h</td>
        <td>LocatorSubDomainRandom</td>
        <td>LocatorSubDomainRandom( const math::Range< size_t> SIZE_RANGE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_locator_sub_domain_random.h</td>
        <td>LocatorSubDomainRandom</td>
        <td>LocatorSubDomainRandom()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_pick_protein_model_conformation_random.h</td>
        <td>PickProteinModelConformationRandom</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_pick_protein_model_conformation_random.h</td>
        <td>PickProteinModelConformationRandom</td>
        <td>Pick( const util::SiPtrList< const ProteinModel> &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_pick_protein_model_conformation_random.h</td>
        <td>PickProteinModelConformationRandom</td>
        <td>PickProteinModelConformationRandom()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_pick_sse_furthest_euclidean.h</td>
        <td>PickSSEFurthestEuclidean</td>
        <td>Pick( const util::SiPtrList< const SSE> &SSE_LIST, const linal::Vector3D &REFERENCE_POINT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_pick_sse_furthest_euclidean.h</td>
        <td>PickSSEFurthestEuclidean</td>
        <td>PickSSEFurthestEuclidean()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_pick_sse_furthest_euclidean_center.h</td>
        <td>PickSSEFurthestEuclideanCenter</td>
        <td>Pick( const util::SiPtrList< const SSE> &SSE_LIST, const t_CriteriaType &CRITERIA) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_pick_sse_furthest_euclidean_center.h</td>
        <td>PickSSEFurthestEuclideanCenter</td>
        <td>PickSSEFurthestEuclideanCenter()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_pick_sse_random.h</td>
        <td>PickSSERandom</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_pick_sse_random.h</td>
        <td>PickSSERandom</td>
        <td>Pick( const util::SiPtrList< const SSE> &SSE_LIST) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_pick_sse_random.h</td>
        <td>PickSSERandom</td>
        <td>PickSSERandom( const storage::Set< biol::SSType> &SS_TYPES)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_pick_sse_random.h</td>
        <td>PickSSERandom</td>
        <td>PickSSERandom()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_pick_sse_short_loops.h</td>
        <td>PickSSEShortLoops</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_pick_sse_short_loops.h</td>
        <td>PickSSEShortLoops</td>
        <td>Pick( const util::SiPtrList< const SSE> &SSE_LIST, const DomainInterface &SSE_DOMAIN) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_pick_sse_short_loops.h</td>
        <td>PickSSEShortLoops</td>
        <td>PickSSEShortLoops( const size_t MAX_LOOP_LENGTH = 5)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_pick_sses_random.h</td>
        <td>PickSSEsRandom</td>
        <td>Pick( const util::SiPtrList< const SSE> &SSE_LIST) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_pick_sses_random.h</td>
        <td>PickSSEsRandom</td>
        <td>PickSSEsRandom( const storage::Set< biol::SSType> &SS_TYPES, const size_t NUM_SSES)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_pick_sses_random.h</td>
        <td>PickSSEsRandom</td>
        <td>PickSSEsRandom()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model.h</td>
        <td>PrinterProteinModel</td>
        <td>GetPrefix() const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model.h</td>
        <td>PrinterProteinModel</td>
        <td>GetStorageStrings( const std::string &PREFIX, const std::string &TAG, const size_t ROUND_NUMBER, const size_t STAGE_NUMBER )
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model.h</td>
        <td>PrinterProteinModel</td>
        <td>Initialize( const size_t &ROUND_NUMBER)
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model.h</td>
        <td>PrinterProteinModel</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model.h</td>
        <td>PrinterProteinModel</td>
        <td>Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model.h</td>
        <td>PrinterProteinModel</td>
        <td>PrinterProteinModel( const std::string &PREFIX)
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model.h</td>
        <td>PrinterProteinModel</td>
        <td>PrinterProteinModel( const std::string &PREFIX, const util::ShPtr< ProteinStorageFile> &STORAGE, const quality::SuperimposeMeasure &SUPERIMPOSE = quality::GetSuperimposeMeasures().e_NoSuperimpose )
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model.h</td>
        <td>PrinterProteinModel</td>
        <td>PrinterProteinModel()
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model.h</td>
        <td>PrinterProteinModel</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_ensemble.h</td>
        <td>PrinterProteinModelEnsemble</td>
        <td>GetPrefix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_ensemble.h</td>
        <td>PrinterProteinModelEnsemble</td>
        <td>Initialize( const size_t &ROUND_NUMBER)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_ensemble.h</td>
        <td>PrinterProteinModelEnsemble</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_ensemble.h</td>
        <td>PrinterProteinModelEnsemble</td>
        <td>Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_ensemble.h</td>
        <td>PrinterProteinModelEnsemble</td>
        <td>PrinterProteinModelEnsemble( const std::string &PREFIX)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_ensemble.h</td>
        <td>PrinterProteinModelEnsemble</td>
        <td>PrinterProteinModelEnsemble( const std::string &PREFIX, const util::ShPtr< ProteinStorageFile> &STORAGE, const quality::SuperimposeMeasure &SUPERIMPOSE = quality::GetSuperimposeMeasures().e_NoSuperimpose )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_ensemble.h</td>
        <td>PrinterProteinModelEnsemble</td>
        <td>PrinterProteinModelEnsemble()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_ensemble.h</td>
        <td>PrinterProteinModelEnsemble</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_movie.h</td>
        <td>PrinterProteinModelMovie</td>
        <td>GetPrefix() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_movie.h</td>
        <td>PrinterProteinModelMovie</td>
        <td>Initialize( const size_t &ROUND_NUMBER)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_movie.h</td>
        <td>PrinterProteinModelMovie</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_movie.h</td>
        <td>PrinterProteinModelMovie</td>
        <td>Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_movie.h</td>
        <td>PrinterProteinModelMovie</td>
        <td>PrinterProteinModelMovie( const std::string &PREFIX, const util::ShPtr< mc::MoviePrinterInterface> &MOVIE_PRINTER, const util::ShPtr< score::ProteinModelScoreSum> &SCORING_FUNCTION, const storage::Set< opti::StepStatusEnum> &STEP_STATUS_SET, const quality::SuperimposeMeasure &SUPERIMPOSE, const storage::Set< quality::Measure> &QUALITIES )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_movie.h</td>
        <td>PrinterProteinModelMovie</td>
        <td>PrinterProteinModelMovie()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_movie.h</td>
        <td>PrinterProteinModelMovie</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_multimer.h</td>
        <td>PrinterProteinModelMultimer</td>
        <td>CalculateBestMultimer( const ProteinModel &MODEL, const ProteinModel &NATIVE, const quality::Measure &QUALITY, const util::ShPtr< ProteinModelMultiplier> &MULTIPLIER )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_multimer.h</td>
        <td>PrinterProteinModelMultimer</td>
        <td>GetPrefix() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_multimer.h</td>
        <td>PrinterProteinModelMultimer</td>
        <td>Initialize( const size_t &ROUND_NUMBER)
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_multimer.h</td>
        <td>PrinterProteinModelMultimer</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_multimer.h</td>
        <td>PrinterProteinModelMultimer</td>
        <td>Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_multimer.h</td>
        <td>PrinterProteinModelMultimer</td>
        <td>PrinterProteinModelMultimer( const std::string &PREFIX, const util::ShPtr< ProteinModel> &NATIVE_MULTIMER_MODEL, const util::ShPtr< ProteinStorageFile> &STORAGE, const quality::SuperimposeMeasure &SUPERIMPOSE = quality::GetSuperimposeMeasures().e_NoSuperimpose )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_protein_model_multimer.h</td>
        <td>PrinterProteinModelMultimer</td>
        <td>PrinterProteinModelMultimer()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_protein_model_multimer.h</td>
        <td>PrinterProteinModelMultimer</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>CollectColumnNames() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>Filename() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>GetPrefix() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>Initialize( const size_t &ROUND_NUMBER)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>Print( const opti::Tracker< ProteinModel, double> &TRACKER) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>PrinterTrackerHistory( const std::string &PATH, const std::string &PREFIX, const util::ShPtr< score::ProteinModelScoreSum> &SP_SCORING_FUNCTION, const util::ShPtr< mc::TemperatureInterface> &SP_TEMPERATURE, const storage::Set< quality::Measure> &QUALITIES )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>PrinterTrackerHistory()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_printer_tracker_history.h</td>
        <td>PrinterTrackerHistory</td>
        <td>WriteToFile( const opti::Tracker< ProteinModel, double> &TRACKER) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>Begin()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>Begin() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>Difference( ProteinEnsemble &OTHER_ENSEMBLE, const t_Comparison &COMP) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>Empty() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>End()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>End() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetConformationalEnsemble() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetCoordinates( const find::LocatorInterface< linal::Vector3D, ProteinModel> &COORD_LOCATOR ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetDistanceChanges( const restraint::DataPairwise &DATA_PAIR, const ProteinEnsemble &OTHER_ENSEMBLE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetDistanceChangesMeanSD( const restraint::DataPairwise &DATA_PAIR, const ProteinEnsemble &OTHER_ENSEMBLE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetDistanceChangesMeanSD( const restraint::DataSetPairwise &DATA_SET, const ProteinEnsemble &OTHER_ENSEMBLE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetDistanceStatistics( const restraint::DataPairwise &DATA_PAIR) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetDistances( const restraint::DataPairwise &DATA_PAIR) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetEnsembleData()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetEnsembleData() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetEnsembleFromFile( const std::string &FILENAME, const size_t COLUMN, const biol::AAClass &AA_CLASS, const std::string &PREFIX = std::string(), const bool &STATUS_MESSAGE = false, const size_t &INPUT_START = 0, const size_t &INPUT_MAX = math::GetHighestBoundedValue< size_t>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetFlagPDBList()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetNameFormatter() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetPDBNames() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>GetSize() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>HardCopy() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>InsertElement( const size_t POS, const util::ShPtr< ProteinModel> &ELEMENT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>InsertElement( const util::ShPtr< ProteinModel> &ELEMENT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>IsEmpty() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>ProteinEnsemble( const ProteinModel &MODEL)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>ProteinEnsemble( const std::string &FILENAME, const size_t COLUMN, const biol::AAClass &AA_CLASS, const std::string &PREFIX = std::string(), const bool &STATUS_MESSAGE = false, const size_t &INPUT_START = 0, const size_t &INPUT_MAX = math::GetHighestBoundedValue< size_t>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>ProteinEnsemble( const t_InputIterator &FIRST, const t_InputIterator &LAST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>ProteinEnsemble( const util::ShPtr< ProteinModel> &MODEL)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>ProteinEnsemble()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>ReadSSPredictions( const storage::Set< sspred::Method> &SS_METHODS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>RemoveElement( iterator ITR)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>Reset()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>SetConformationalEnsemble( const ProteinEnsemble &ENSEMBLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>SetIdentifiers( const storage::Vector< std::string> &IDENTIFIERS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>SetSSEPoolData( const util::ShPtr< SSEPool> &SSE_POOL)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>Sort( const t_Comparison &COMP)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_ensemble.h</td>
        <td>ProteinEnsemble</td>
        <td>operator =( const ProteinModel &PROTEIN_MODEL)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>AddLoops( const bool UNDEFINED_COORDINATES, const bool MERGE_CONSECUTIVE_SSES, const biol::SSType &SS_TYPE = biol::GetSSTypes().COIL )
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>AdoptSSEsMaintainCoordinates( const util::SiPtrVector< const SSE> &SSES)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>CalculateFragmentInteractions() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>ChopSSEs( const storage::VectorND< 3, size_t> &MIN_SSE_LENGTHS)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>ConnectSSEToChainData()
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>DoesContain( const SSE &THIS_SSE) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Empty() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>FilterByMinSSESizes( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES )
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>FindSSE( const SSE &SSE_TO_SEARCH) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetAminoAcids() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetAtomCoordinates( const storage::Set< biol::AtomType> &ATOM_TYPES ) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetAtomCoordinates() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetAtoms( const storage::Set< biol::AtomType> &ATOM_TYPES ) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetAtoms() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetCenter() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetCenterOfMass() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetCenterOfSSEs() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetChain( const char CHAIN_ID)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetChain( const char CHAIN_ID) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetChainIDs() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetChains( const std::string &CHAIN_IDS) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetChains()
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetChains() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetChangeSignal() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetConformationalEnsemble() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetDefinedAtomCoordinates( const storage::Set< biol::AtomType> &ATOM_TYPES ) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetDestructorSignal() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetEmptyChains() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetFragmentIDs() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetFragments() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetIdentification() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetNeighborSSEs( const SSE &TARGET_SSE ) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetNumberAAs() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetNumberOfChains() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetNumberSSE( const biol::SSType &SS_TYPE) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetNumberSSEs() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetOverlappingSSEs( const SSE &TARGET_SSE ) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetOverlappingSSEs( const util::SiPtrList< const SSE> &SSE_LIST ) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetProteinModelData() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSE( const biol::AABase &RESIDUE) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEGeometries() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEHashString() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEs( const biol::SSType &SS_TYPE) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEs( const storage::Set< biol::SSType> &SS_TYPES) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEs() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEsAsDomain( const biol::SSType &SS_TYPE) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEsAsDomain() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEsWithShortLoops( const SSE &TARGET_SSE, const size_t MAX_LOOP_LENGTH ) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEsWithShortLoops( const size_t MAX_LOOP_LENGTH ) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSSEsWithShortLoops( const util::SiPtrList< const SSE> &SSE_LIST, const size_t MAX_LOOP_LENGTH ) const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetSequences() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>HardCopy( const ProteinModel &PROTEIN_MODEL)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>HardCopy() const
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Insert( const util::ShPtr< Chain> &SP_CHAIN)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Insert( const util::ShPtr< SSE> &SP_SSE)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Join( const biol::SSType &SS_TYPE, const bool TEST_PEPTIDE_BOND)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>ProteinModel( const util::ShPtr< Chain> &CHAIN)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>ProteinModel( const util::ShPtrVector< Chain> &CHAINS)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>ProteinModel()
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Remove( const SSE &THIS_SSE)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Replace( const storage::Set< util::ShPtr< SSE>, SSELessThanNoOverlap> &SSELEMENTS)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Replace( const util::ShPtr< Chain> &SP_CHAIN)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Replace( const util::ShPtr< SSE> &SP_SSE)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Replace( const util::ShPtrVector< SSE> &SSELEMENTS)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>ReplaceResize( const util::ShPtr< SSE> &SP_SSE)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>ReplaceWithOverlapping( const util::ShPtr< SSE> &SP_SSE)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>SetConformationalEnsemble( const ProteinEnsemble &ENSEMBLE)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>SetProteinModelData( const util::ShPtr< ProteinModelData> &SP_PROTEIN_MODEL_DATA)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>SetSSEPoolData( const util::ShPtr< SSEPool> &SSE_POOL)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>SetToIdealConformation( const bool KEEPPOSITION = true)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATIONMATRIX3D)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model.h</td>
        <td>ProteinModel</td>
        <td>operator =( const ProteinModel &PROTEIN_MODEL)
</td>
        <td>staritrd, karakam, meilerj, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_data.h</td>
        <td>ProteinModelData</td>
        <td>GetData( const Type &KEY) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_data.h</td>
        <td>ProteinModelData</td>
        <td>GetKeys() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_data.h</td>
        <td>ProteinModelData</td>
        <td>GetTypeName( const Type &TYPE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_data.h</td>
        <td>ProteinModelData</td>
        <td>HardCopy() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_data.h</td>
        <td>ProteinModelData</td>
        <td>Insert( const ProteinModelData &PROTEIN_MODEL_DATA, const bool REPLACE = false)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_data.h</td>
        <td>ProteinModelData</td>
        <td>Insert( const Type &KEY, const util::ShPtr< util::ObjectInterface> &SP_DATA)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_data.h</td>
        <td>ProteinModelData</td>
        <td>IsEmpty() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_data.h</td>
        <td>ProteinModelData</td>
        <td>ProteinModelData()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_data.h</td>
        <td>ProteinModelData</td>
        <td>Replace( const Type &KEY, const util::ShPtr< util::ObjectInterface> &SP_DATA)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>ConstructExtendedSequence( const biol::AASequence &AA_SEQUENCE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>ConstructInvertedChain( const Chain &CHAIN)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>ConstructInvertedModel( const ProteinModel &MODEL)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>DoesContainCoil( const util::ShPtr< biol::AASequence> &SP_SEQUENCE, const size_t BEGIN_SEQ_ID, const size_t END_SEQ_ID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>GenerateDescription( const Chain &CHAIN)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>GenerateDescription( const ProteinModel &MODEL)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>GetCoilCacheSize() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>GetInvertedModel( const ProteinModel &MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>GetModelCacheSize() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>GetUseCache() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>ProteinModelInverter( const bool USE_CACHE = false, const size_t MODEL_CACHE_SIZE = 2, const size_t COIL_CACHE_SIZE = 30 )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_inverter.h</td>
        <td>ProteinModelInverter</td>
        <td>Reset()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_moment_of_inertia.h</td>
        <td>ProteinModelMomentOfInertia</td>
        <td>ProteinModelAAExposureToCoordinateWeightMatrix( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_moment_of_inertia.h</td>
        <td>ProteinModelMomentOfInertia</td>
        <td>ProteinModelMomentOfInertia( const biol::AATypeData::PropertyType &PROPERTY, const util::ShPtr< AAExposureInterface> &EXPOSURE_WEIGHT_FUNCTION, const bool CONSIDER_ONLY_NEGATIVE_PROPERTY )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_moment_of_inertia.h</td>
        <td>ProteinModelMomentOfInertia</td>
        <td>ProteinModelToCoordinateWeightMatrix( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_moment_of_inertia.h</td>
        <td>ProteinModelMomentOfInertia</td>
        <td>TransformationAndMoments( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>ChainIDMapping() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>GetCenter() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>GetChainMultipliers() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>GetNumberMultimers() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>GetOrientation() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>GetTargetChains() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>GetTransformationMatrices() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>HardCopy() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>ProteinModelMultiplier( const linal::Vector3D &SYMMETRY_AXIS, const linal::Vector3D &DIHEDRAL_AXIS, const size_t SUBUNITS, const ProteinModel &PROTEIN_MODEL, const bool CACHE = false )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>ProteinModelMultiplier( const linal::Vector3D &SYMMETRY_AXIS, const size_t SUBUNITS, const ProteinModel &PROTEIN_MODEL, const bool CACHE = false )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>ProteinModelMultiplier( const storage::Vector< storage::Triplet< char, char, math::TransformationMatrix3D> > &TRANSFORMATIONS, const ProteinModel &PROTEIN_MODEL, const bool CACHE = false )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>ProteinModelMultiplier()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_multiplier.h</td>
        <td>ProteinModelMultiplier</td>
        <td>operator ()( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>Empty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>GetChemicalRepresentation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>GetIterator() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>GetIteratorNonConst()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>GetRequiresCoordinates() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>HardCopy() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>ProteinModelWithCache( const ProteinModel &MODEL, const bool &REQUIRE_COORDINATES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>ProteinModelWithCache( const ProteinModelWithCache &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>ProteinModelWithCache()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>ResetCache() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_cache.h</td>
        <td>ProteinModelWithCache</td>
        <td>operator =( const ProteinModelWithCache &PROTEIN_MODEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_mutations.h</td>
        <td>ProteinModelWithMutations</td>
        <td>Empty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_mutations.h</td>
        <td>ProteinModelWithMutations</td>
        <td>GetMutations() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_mutations.h</td>
        <td>ProteinModelWithMutations</td>
        <td>HardCopy() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_mutations.h</td>
        <td>ProteinModelWithMutations</td>
        <td>IsWildType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_mutations.h</td>
        <td>ProteinModelWithMutations</td>
        <td>Mutate( const biol::Mutation &MUTATION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_mutations.h</td>
        <td>ProteinModelWithMutations</td>
        <td>OnlyHasMutation( const biol::Mutation &MUTATION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_mutations.h</td>
        <td>ProteinModelWithMutations</td>
        <td>ProteinModelWithMutations( const ProteinModel &MODEL, const bool &REQUIRE_COORDINATES, const storage::Vector< biol::Mutation> &MUTATIONS = storage::Vector< biol::Mutation>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_model_with_mutations.h</td>
        <td>ProteinModelWithMutations</td>
        <td>ProteinModelWithMutations()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_model_with_mutations.h</td>
        <td>ProteinModelWithMutations</td>
        <td>RevertToWildType()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>Delete()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>Filename( const std::string &SOURCE, const std::string &KEY) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>GetAllKeys( const std::string &SOURCE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>GetAllSources() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>GetDefaultStorage()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>GetDefaultStorageFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>GetInitializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>GetInitializerTypeDescriptor( const InitializerType &INIT_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>GetSize( const std::string &SOURCE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>IsValidKey( const std::string &KEY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>KeyToString( const size_t &KEY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>ProteinStorageFile( const std::string &INITIALIZER = std::string(), const InitializerType &INIT_TYPE = e_Attach, const io::StreamBufferClass &COMPRESSION = io::StreamBufferClass() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>Retrieve( const std::string &SOURCE, const std::string &KEY) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>RetrieveEnsemble( const std::string &SOURCE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>RetrieveEnsemble( const std::string &SOURCE, const math::Range< size_t> &RANGE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>RetrieveEnsemble( const std::string &SOURCE, const storage::Vector< std::string> &KEYS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>RetrieveRemarkLines( const std::string &SOURCE, const std::string &KEY ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>SetDirectory( const std::string &INITIALIZER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>SetFactory( const util::ShPtr< pdb::Factory> &FACTORY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>Store( const ProteinModel &MOLECULE, const std::string &SOURCE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>Store( const ProteinModel &MOLECULE, const std::string &SOURCE, const std::string &KEY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>Store( const util::ShPtrList< ProteinModel> &ENSEMBLE, const std::string &SOURCE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_storage_file.h</td>
        <td>ProteinStorageFile</td>
        <td>WillOverwrite() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>ProteinWithCacheDatasetFromFile( const ProteinWithCacheDatasetFromFile &PARENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>ProteinWithCacheDatasetFromFile( const bool &REQUIRE_COORDINATES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>RequiresResultLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_dataset_from_file.h</td>
        <td>ProteinWithCacheDatasetFromFile</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GenerateProteinModelFromFile( const std::string &FILENAME, const bool &REQUIRE_COORDINATES, const biol::AAClass &CLASS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GetAAClass() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GetAllKeys() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GetAllLocations() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GetDirectory() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GetFilename( const std::string &KEY) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GetKeySize( const std::string &KEY) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GetRequireCoordinates() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>ProteinWithCacheStorageFile( const ProteinWithCacheStorageFile &PARENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>ProteinWithCacheStorageFile( const bool &REQUIRE_COORDINATES, const bool &AUTOLOAD = true )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>Retrieve( const std::string &KEY) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>RetrieveEnsemble( const math::Range< size_t> &RANGE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_cache_storage_file.h</td>
        <td>ProteinWithCacheStorageFile</td>
        <td>RetrieveEnsemble( const storage::Vector< std::string> &KEYS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>ProteinWithMutationsDatasetFromFile( const ProteinWithMutationsDatasetFromFile &PARENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>ProteinWithMutationsDatasetFromFile( const bool &REQUIRE_COORDINATES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>RequiresResultLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_protein_with_mutations_dataset_from_file.h</td>
        <td>ProteinWithMutationsDatasetFromFile</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>Calculate( const quality::Measure &QUALITY_MEASURE, const ProteinModel &PROTEIN_MODEL, const ProteinModel &NATIVE_MODEL, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>Calculate( const quality::Measure &QUALITY_MEASURE, const ProteinModel &PROTEIN_MODEL, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>CoordinatesAndResidueCountFromAlignment( const align::AlignmentInterface< biol::AABase> &ALIGNMENT, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>CoordinatesFromAlignment( const align::AlignmentInterface< biol::AABase> &ALIGNMENT, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>CoordinatesFromAlignments( const storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > &ALIGNMENTS, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>CreateAlignmentFromCollectorAASpecified( const ProteinModel &PROTEIN_MODEL, const CollectorAASpecified &COLLECTOR )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>CreateAlignmentFromProteinModelSSEs( const ProteinModel &PROTEIN_MODEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>CreateAlignmentFromProteinModelSequences( const ProteinModel &PROTEIN_MODEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>CreateAlignmentProteinModelSequencesToSSEs( const ProteinModel &PROTEIN_MODEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>CreateAlignmentProteinModels( const ProteinModel &PROTEIN_MODEL_A, const ProteinModel &PROTEIN_MODEL_B )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>GetAllDesiredAtomCoordinates( const storage::VectorND< 2, util::SiPtrList< const biol::AABase> > &COMMON_AAS, const storage::Set< biol::AtomType> &DESIRED_ATOMS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>GetChainAlignments( const align::HandlerInterface< biol::AABase> &HANDLER, const storage::Vector< io::DirectoryEntry> &ALIGN_FILES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>GetChainAndSequenceCoordinates( const ProteinModel &MODEL, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>GetFlagAlignments()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>GetSSEAndSequenceCoordinates( const Chain &CHAIN, const Chain &NATIVE, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>Quality( const quality::Measure &QUALITY_MEASURE, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>Quality()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>RMSD100( const double RMSD, const size_t NUMBER_RESIDUES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>RemoveAssignmentsWithGapsFromAlignment( const align::AlignmentInterface< biol::AABase> &ALIGNMENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>RemoveUndefinedAminoAcidsFromAlignment( const align::AlignmentInterface< biol::AABase> &ALIGNMENT, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>RemoveUndefinedTemplateAminoAcidsFromAlignment( const align::AlignmentInterface< biol::AABase> &ALIGNMENT, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>SuperimposeModel( const quality::SuperimposeMeasure &SUPERIMPOSE_MEASURE, ProteinModel &PROTEIN_MODEL, const ProteinModel &REFERENCE_MODEL, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>SuperimposeModel( const quality::SuperimposeMeasure &SUPERIMPOSE_MEASURE, ProteinModel &PROTEIN_MODEL, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>SuperimposeModelWithAlignment( const quality::SuperimposeMeasure &SUPERIMPOSE_MEASURE, ProteinModel &PROTEIN_MODEL, const ProteinModel &REFERENCE_MODEL, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality.h</td>
        <td>Quality</td>
        <td>operator ()( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality_batch.h</td>
        <td>QualityBatch</td>
        <td>ColumnNamesFromQualities( const storage::Set< quality::Measure> &QUALITIES )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality_batch.h</td>
        <td>QualityBatch</td>
        <td>ConstructTable( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality_batch.h</td>
        <td>QualityBatch</td>
        <td>ConstructTable( const ProteinModel &PROTEIN_MODEL_A, const ProteinModel &PROTEIN_MODEL_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality_batch.h</td>
        <td>QualityBatch</td>
        <td>ContructTableWithCompletenessOnly( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality_batch.h</td>
        <td>QualityBatch</td>
        <td>QualityBatch( const storage::Set< quality::Measure> &QUALITIES, const storage::Set< biol::AtomType> &ATOM_TYPES, const std::string &QUALITY_SUFFIX = Ó, const bool USE_READABLE_NAMES = false )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality_batch.h</td>
        <td>QualityBatch</td>
        <td>QualityBatch()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_quality_batch.h</td>
        <td>QualityBatch</td>
        <td>operator ()( const ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_quality_batch.h</td>
        <td>QualityBatch</td>
        <td>operator ()( const ProteinModel &PROTEIN_MODEL_A, const ProteinModel &PROTEIN_MODEL_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sheet_template_handler.h</td>
        <td>SheetTemplateHandler</td>
        <td>GetFlagSheetTemplates()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sheet_template_handler.h</td>
        <td>SheetTemplateHandler</td>
        <td>GetRandomTemplate( const size_t NR_STRANDS)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sheet_template_handler.h</td>
        <td>SheetTemplateHandler</td>
        <td>GetRandomTemplate( const util::SiPtrVector< const SSE> &SSES, const math::BinaryFunctionInterface< SSE, SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE = SSEGeometryWithinSizeTolerance() )
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>Append( const biol::AABase &AMINO_ACID, const bool IDEALIZE = true)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>AppendSequence( const AASequence &AA_SEQUENCE, const bool IDEALIZE = true)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>Chop( const size_t &SIZE) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>FitToSSE( const SSE &SSE_TEMPLATE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetCenter() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetCentralAA() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetCoordinateChangeSignal() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetDestructorSignal() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetExtent( const coord::Axis &AXIS) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetFragments() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetGeometries() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetGeometryCoordinateChangeSignal() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetGeometryDestructorSignal() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetHashString() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetIdentification() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetLength() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetMainAxis() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetOrientation() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetRadialExtent() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetRotation() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetSSEGeometries() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>GetType() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>HardCopy() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>IsDefined() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>IsPredictedTransmembrane() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>Prepend( const biol::AABase &AMINO_ACID, const bool IDEALIZE = true)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>PrependSequence( const AASequence &AA_SEQUENCE, const bool IDEALIZE = true)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>Rotate( const linal::Vector3D &ROTATION_POINT, const linal::Vector3D &ROTATION_AXIS, const double &ANGLE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SSE( const SSE &SSE_TO_COPY)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SSE( const biol::AASequence &SEQUENCE, const biol::SSType &SS_TYPE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SSE( const biol::SSType &SS_TYPE = biol::GetSSTypes().e_Undefined)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SetExtents( const linal::Vector3D &EXTENT)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SetFragmentGeometries( size_t FRAGMENT_LENGTH = 0)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SetGeometry()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SetOrigin( const linal::Vector3D &LOCATION)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SetToIdealConformationAtOrigin()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SetToIdealConformationInPlace()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>SetType( const biol::SSType &SS_TYPE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse.h</td>
        <td>SSE</td>
        <td>operator =( const SSE &SSE_RHS)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse.h</td>
        <td></td>
        <td>operator ==( const SSE &SSE_LHS, const SSE &SSE_RHS)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompare</td>
        <td>SSECompare( const SSE &THIS_SSE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompare</td>
        <td>operator ()( const SSE &THIS_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompare</td>
        <td>operator ()( const util::PtrInterface< SSE> &PTR_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompare</td>
        <td>operator ()( const util::PtrInterface< const SSE> &PTR_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompareByIdentity</td>
        <td>SSECompareByIdentity( const size_t BEGIN_SEQ_ID, const size_t END_SEQ_ID, const char CHAIN_ID, const biol::SSType &SS_TYPE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompareByIdentity</td>
        <td>operator ()( const SSE &THIS_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompareByIdentity</td>
        <td>operator ()( const util::PtrInterface< SSE> &PTR_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompareByIdentity</td>
        <td>operator ()( const util::PtrInterface< const SSE> &PTR_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompareOverlap</td>
        <td>SSECompareOverlap( const SSE &THIS_SSE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompareOverlap</td>
        <td>operator ()( const SSE &THIS_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompareOverlap</td>
        <td>operator ()( const util::PtrInterface< SSE> &PTR_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSECompareOverlap</td>
        <td>operator ()( const util::PtrInterface< const SSE> &PTR_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThan</td>
        <td>operator ()( const SSE &SSE_A, const SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThan</td>
        <td>operator ()( const util::PtrInterface< SSE> &PTR_SSE_A, const util::PtrInterface< SSE> &PTR_SSE_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThan</td>
        <td>operator ()( const util::PtrInterface< SSE> &PTR_SSE_A, const util::PtrInterface< const SSE> &PTR_SSE_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThan</td>
        <td>operator ()( const util::PtrInterface< const SSE> &PTR_SSE_A, const util::PtrInterface< SSE> &PTR_SSE_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThan</td>
        <td>operator ()( const util::PtrInterface< const SSE> &PTR_SSE_A, const util::PtrInterface< const SSE> &PTR_SSE_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanBySize</td>
        <td>operator ()( const SSE &SSE_A, const SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanBySize</td>
        <td>operator ()( const util::PtrInterface< SSE> &PTR_SSE_A, const util::PtrInterface< SSE> &PTR_SSE_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanBySize</td>
        <td>operator ()( const util::PtrInterface< SSE> &PTR_SSE_A, const util::PtrInterface< const SSE> &PTR_SSE_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanBySize</td>
        <td>operator ()( const util::PtrInterface< const SSE> &PTR_SSE_A, const util::PtrInterface< SSE> &PTR_SSE_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanBySize</td>
        <td>operator ()( const util::PtrInterface< const SSE> &PTR_SSE_A, const util::PtrInterface< const SSE> &PTR_SSE_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanNoOverlap</td>
        <td>operator ()( const SSE &SSE_A, const SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanNoOverlap</td>
        <td>operator ()( const SSE &SSE_A, const util::PtrInterface< SSE> &PTR_SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanNoOverlap</td>
        <td>operator ()( const SSE &SSE_A, const util::PtrInterface< const SSE> &PTR_SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanNoOverlap</td>
        <td>operator ()( const util::PtrInterface< SSE> &PTR_SSE_A, const SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanNoOverlap</td>
        <td>operator ()( const util::PtrInterface< SSE> &PTR_SSE_A, const util::PtrInterface< SSE> &PTR_SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanNoOverlap</td>
        <td>operator ()( const util::PtrInterface< const SSE> &PTR_SSE_A, const SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare.h</td>
        <td>SSELessThanNoOverlap</td>
        <td>operator ()( const util::PtrInterface< const SSE> &PTR_SSE_A, const util::PtrInterface< const SSE> &PTR_SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare_extent.h</td>
        <td>SSECompareExtent</td>
        <td>SSECompareExtent( const double TOLERANCE, const coord::Axis &AXIS)
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare_extent.h</td>
        <td>SSECompareExtent</td>
        <td>SSECompareExtent()
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare_extent.h</td>
        <td>SSECompareExtent</td>
        <td>operator ()( const SSE &SSE_A, const SSE &SSE_B) const
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_compare_type.h</td>
        <td>SSECompareType</td>
        <td>GetSerializer() const
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_compare_type.h</td>
        <td>SSECompareType</td>
        <td>operator ()( const SSE &SSE_A, const SSE &SSE_B) const
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factories.h</td>
        <td>SSEFactories</td>
        <td>Create( const SSEFactory &FACTORY, const sspred::Method &SS_METHOD, const storage::Map< biol::SSType, double> &SSTYPE_THRESHOLDS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_factories.h</td>
        <td></td>
        <td>GetSSEFactories()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factory_conformation.h</td>
        <td>SSEFactoryConformation</td>
        <td>SSEFactoryConformation( const storage::VectorND< 3, size_t> &MIN_SSE_LENGTHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_factory_conformation.h</td>
        <td>SSEFactoryConformation</td>
        <td>SSEFactoryConformation()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factory_conformation.h</td>
        <td>SSEFactoryConformation</td>
        <td>SetMethod( const sspred::Method &SS_METHOD)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_factory_conformation.h</td>
        <td>SSEFactoryConformation</td>
        <td>SetThresholds( const storage::Map< biol::SSType, double> &SSTYPE_THRESHOLDS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factory_conformation.h</td>
        <td>SSEFactoryConformation</td>
        <td>operator ()( const biol::AASequence &SEQUENCE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_factory_interface.h</td>
        <td>SSEFactoryInterface</td>
        <td>operator ()( const util::SiPtrVector< biol::AASequence> &SEQUENCES) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>DefaultMutate() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>DefaultScoringFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>GetScoringFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>SSEFactoryMC( const sspred::Method &SSMETHOD, const double CONFIDENCE_THRESHOLD )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>SetMaxNumberIterations( const size_t MAX_NUMBER_ITERATIONS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>SetMethod( const sspred::Method &SS_METHOD)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>SetMutate( const util::ShPtr< math::MutateInterface< SSEPool> > &SP_MUTATE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>SetNumberOptimizations( const size_t NUMBER_OPTIMZATIONS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>SetScoringFunction( const util::ShPtr< math::BinaryFunctionInterface< SSEPool, biol::Membrane, double> > &SP_SCORING)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>SetThresholds( const storage::Map< biol::SSType, double> &SSTYPE_THRESHOLDS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_factory_mc.h</td>
        <td>SSEFactoryMC</td>
        <td>operator ()( const biol::AASequence &SEQUENCE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetCenter() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetCentralAA() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetExtent( const coord::Axis &AXIS) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetFragments() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetGeometries() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetGeometryCoordinateChangeSignal() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetGeometryDestructorSignal() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetIdentification() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetLength() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetMainAxis() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetOrientation() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetRadialExtent() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetRotation() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetSSEGeometries() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>GetType() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>IsDefined() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>SSEGeometry( const SSEGeometry &GEOMETRY)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>SSEGeometry( const SSEGeometryInterface &GEOMETRY)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>SSEGeometry( const SSEGeometryInterface &GEOMETRY, const int &CENTRAL_AA)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>SSEGeometry( const biol::SSType &SSTYPE = biol::GetSSTypes().e_Undefined, const std::string &IDENTIFICATION = Ó, const double &LENGTH = util::GetUndefinedDouble() )
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>SetIdentification( const std::string &IDENTIFICATION)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry.h</td>
        <td>SSEGeometry</td>
        <td>operator =( const SSEGeometry &SSE_GEOMETRY_RHS)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_compare.h</td>
        <td>SSEGeometryWithinSizeTolerance</td>
        <td>SSEGeometryWithinSizeTolerance( const size_t HELIX_TOLERANCE = 2, const size_t STRAND_TOLERANCE = 2)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_compare.h</td>
        <td>SSEGeometryWithinSizeTolerance</td>
        <td>operator ()( const SSE &SSE_TO_COMPARE, const SSEGeometryPhiPsi &GEOMTRY_PHI_PSI) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_interface.h</td>
        <td>SSEGeometryInterface</td>
        <td>BeginOfZ() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_interface.h</td>
        <td>SSEGeometryInterface</td>
        <td>EndOfZ() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_interface.h</td>
        <td>SSEGeometryInterface</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_interface.h</td>
        <td>SSEGeometryInterface</td>
        <td>GetCenter() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_interface.h</td>
        <td>SSEGeometryInterface</td>
        <td>GetRotation() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_interface.h</td>
        <td>SSEGeometryInterfaceLessThan</td>
        <td>operator ()( const SSEGeometryInterface &SSE_GEO_A, const SSEGeometryInterface &SSE_GEO_B ) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_interface.h</td>
        <td>SSEGeometryInterfaceLessThan</td>
        <td>operator ()( const util::PtrInterface< SSEGeometryInterface> &PTR_SSE_GEO_A, const util::PtrInterface< SSEGeometryInterface> &PTR_SSE_GEO_B ) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_interface.h</td>
        <td>SSEGeometryInterfaceLessThan</td>
        <td>operator ()( const util::PtrInterface< const SSEGeometryInterface> &PTR_SSE_GEO_A, const util::PtrInterface< const SSEGeometryInterface> &PTR_SSE_GEO_B ) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_interface.h</td>
        <td></td>
        <td>operator ==( const SSEGeometryInterface &SSE_GEOMETRY_LHS, const SSEGeometryInterface &SSE_GEOMETRY_RHS )
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_all_fragment_pairs.h</td>
        <td>SSEGeometryPackerAllFragmentPairs</td>
        <td>GetClashDistanceCutoffMap()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_all_fragment_pairs.h</td>
        <td>SSEGeometryPackerAllFragmentPairs</td>
        <td>GetDistanceCutoffMap()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_all_fragment_pairs.h</td>
        <td>SSEGeometryPackerAllFragmentPairs</td>
        <td>GetMinimalInterfaceLength() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_all_fragment_pairs.h</td>
        <td>SSEGeometryPackerAllFragmentPairs</td>
        <td>SSEGeometryPackerAllFragmentPairs( const double MINIMAL_INTERFACE_LENGTH )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_all_fragment_pairs.h</td>
        <td>SSEGeometryPackerAllFragmentPairs</td>
        <td>SSEGeometryPackerAllFragmentPairs( const double MINIMAL_INTERFACE_LENGTH, const storage::Map< biol::SSType, storage::Map< biol::SSType, double> > &DISTANCE_CUTOFFS )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_all_fragment_pairs.h</td>
        <td>SSEGeometryPackerAllFragmentPairs</td>
        <td>SSEGeometryPackerAllFragmentPairs()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_all_fragment_pairs.h</td>
        <td>SSEGeometryPackerAllFragmentPairs</td>
        <td>operator ()( const SSEGeometryInterface &SSE_GEOMETRY_A, const SSEGeometryInterface &SSE_GEOMETRY_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pair.h</td>
        <td>SSEGeometryPackerBestFragmentPair</td>
        <td>GetMinimalInterfaceLength() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pair.h</td>
        <td>SSEGeometryPackerBestFragmentPair</td>
        <td>SSEGeometryPackerBestFragmentPair( const SSEGeometryPacker &PACKER, const math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> &COMPARISION_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pair.h</td>
        <td>SSEGeometryPackerBestFragmentPair</td>
        <td>SSEGeometryPackerBestFragmentPair( const SSEGeometryPacker &PACKER, const math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> &CRITERIA, const math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> &COMPARISION_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pair.h</td>
        <td>SSEGeometryPackerBestFragmentPair</td>
        <td>SSEGeometryPackerBestFragmentPair()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pair.h</td>
        <td>SSEGeometryPackerBestFragmentPair</td>
        <td>operator ()( const SSEGeometryInterface &SSE_GEOMETRY_A, const SSEGeometryInterface &SSE_GEOMETRY_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pairs.h</td>
        <td>SSEGeometryPackerBestFragmentPairs</td>
        <td>GetMinimalInterfaceLength() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pairs.h</td>
        <td>SSEGeometryPackerBestFragmentPairs</td>
        <td>SSEGeometryPackerBestFragmentPairs( const SSEGeometryPacker &PACKER, const math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> &COMPARISION_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pairs.h</td>
        <td>SSEGeometryPackerBestFragmentPairs</td>
        <td>SSEGeometryPackerBestFragmentPairs( const SSEGeometryPacker &PACKER, const math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> &CRITERIA, const math::BinaryFunctionInterface< SSEGeometryPacking, SSEGeometryPacking, bool> &COMPARISION_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pairs.h</td>
        <td>SSEGeometryPackerBestFragmentPairs</td>
        <td>SSEGeometryPackerBestFragmentPairs()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_best_fragment_pairs.h</td>
        <td>SSEGeometryPackerBestFragmentPairs</td>
        <td>operator ()( const SSEGeometryInterface &SSE_GEOMETRY_A, const SSEGeometryInterface &SSE_GEOMETRY_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_cache_wrapper.h</td>
        <td>SSEGeometryPackerCacheWrapper</td>
        <td>GetMinimalInterfaceLength() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_cache_wrapper.h</td>
        <td>SSEGeometryPackerCacheWrapper</td>
        <td>SSEGeometryPackerCacheWrapper( const util::ShPtr< SSEGeometryPackerInterface< t_ReturnType> > &SP_PACKER_FUNCTION, const bool IS_SYMMETRIC )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_cache_wrapper.h</td>
        <td>SSEGeometryPackerCacheWrapper</td>
        <td>SSEGeometryPackerCacheWrapper()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_cache_wrapper.h</td>
        <td>SSEGeometryPackerCacheWrapper</td>
        <td>operator ()( const SSEGeometryInterface &SSE_GEOMETRY_A, const SSEGeometryInterface &SSE_GEOMETRY_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packer_cache_wrapper.h</td>
        <td></td>
        <td>AddInstance( new SSEGeometryPackerCacheWrapper< t_ReturnType>())
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packer_interface.h</td>
        <td>SSEGeometryPackerInterface</td>
        <td>WrapPacker( const util::ShPtr< SSEGeometryPackerInterface< t_ReturnType> > &SP_PACKER_FUNCTION, const bool CACHEABLE, const bool IS_SYMMETRIC )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packers.h</td>
        <td></td>
        <td>GetSSEGeometryPackers()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>AngleSSEConnection( const SSEGeometryInterface &SSE_GEOMETRY, const coord::LineSegment3D &SHORTEST_CONNECTION )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>CalulateTwistAngle( const SSEGeometryInterface &SSE_GEOMETRY_A, const SSEGeometryInterface &SSE_GEOMETRY_B, const coord::LineSegment3D &SHORTEST_CONNECTION )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetContactType() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetDefaultFragmentMinimalInterfaceLength()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetDistance() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetFirstSSEGeometry() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetIdentification() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetInteractionWeight() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetMinimalInterfaceLength() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetOrientation() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetOrientationName( const Orientation &ORIENTATION)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetOrthogonalConnection() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetRelativePosition() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetRelativePositionWeight() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetSecondSSEGeometry() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetShortestConnection() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetStrandStrandPairingWeight() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>GetTwistAngle() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>Initialize( const SSEGeometryInterface &SSE_GEOMETRY_A, const SSEGeometryInterface &SSE_GEOMETRY_B, const bool &ALLOW_UNDEFINED_TYPES = true )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>InteractionWeight( const SSEGeometryInterface &SSE_GEOMETRY_A, const SSEGeometryInterface &SSE_GEOMETRY_B, const coord::LineSegment3D &SHORTEST_CONNECTION )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>IsDefined() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>OrientationFromSSEs( const SSEGeometryInterface &SSE_GEOMETRY_A, const SSEGeometryInterface &SSE_GEOMETRY_B )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>OrientationFromTwistAngle( const double TWIST_ANGLE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>Reverse()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>SSEGeometryPacking( const SSEGeometryInterface &SSE_GEOMETRY_A, const SSEGeometryInterface &SSE_GEOMETRY_B, const double MINIMAL_INTERFACE_LENGTH = GetDefaultFragmentMinimalInterfaceLength(), const bool &ALLOW_UNDEFINED_TYPES = true )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing.h</td>
        <td>SSEGeometryPacking</td>
        <td>SSEGeometryPacking()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_compare.h</td>
        <td>SSEGeometryPackingCompareDistance</td>
        <td>operator ()( const SSEGeometryPacking &SSE_GEOMETRY_PACKING_A, const SSEGeometryPacking &SSE_GEOMETRY_PACKING_B ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_compare.h</td>
        <td>SSEGeometryPackingCompareInteractionWeight</td>
        <td>operator ()( const SSEGeometryPacking &SSE_GEOMETRY_PACKING_A, const SSEGeometryPacking &SSE_GEOMETRY_PACKING_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaCombine</td>
        <td>SSEGeometryPackingCriteriaCombine( const util::ShPtrVector< math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> > &CRITERIA_VECTOR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaCombine</td>
        <td>SSEGeometryPackingCriteriaCombine()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaCombine</td>
        <td>operator ()( const SSEGeometryPacking &SSE_GEOMETRY_PACKING) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaContactType</td>
        <td>SSEGeometryPackingCriteriaContactType( const contact::Type &CONTACT_TYPE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaContactType</td>
        <td>SSEGeometryPackingCriteriaContactType( const storage::Set< contact::Type> &CONTACT_TYPES)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaContactType</td>
        <td>SSEGeometryPackingCriteriaContactType()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaContactType</td>
        <td>operator ()( const SSEGeometryPacking &SSE_GEOMETRY_PACKING) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaDistance</td>
        <td>SSEGeometryPackingCriteriaDistance( const double DISTANCE_CUTOFF, const math::Comparisons< double>::Comparison &COMPARISON )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaDistance</td>
        <td>SSEGeometryPackingCriteriaDistance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaDistance</td>
        <td>operator ()( const SSEGeometryPacking &SSE_GEOMETRY_PACKING) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaDistancePerType</td>
        <td>SSEGeometryPackingCriteriaDistancePerType()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaDistancePerType</td>
        <td>operator ()( const SSEGeometryPacking &SSE_GEOMETRY_PACKING) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaInteractionWeight</td>
        <td>SSEGeometryPackingCriteriaInteractionWeight( const double INTERACTION_WEIGHT_CUTOFF, const math::Comparisons< double>::Comparison &COMPARISON )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaInteractionWeight</td>
        <td>SSEGeometryPackingCriteriaInteractionWeight()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaInteractionWeight</td>
        <td>operator ()( const SSEGeometryPacking &SSE_GEOMETRY_PACKING) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaStrandWeight</td>
        <td>SSEGeometryPackingCriteriaStrandWeight( const double STRAND_WEIGHT_CUTOFF, const math::Comparisons< double>::Comparison &COMPARISON )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaStrandWeight</td>
        <td>SSEGeometryPackingCriteriaStrandWeight()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_criteria.h</td>
        <td>SSEGeometryPackingCriteriaStrandWeight</td>
        <td>operator ()( const SSEGeometryPacking &SSE_GEOMETRY_PACKING) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_packing_list_pickers.h</td>
        <td></td>
        <td>GetSSEGeometryPackingListPickers()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_packing_pickers.h</td>
        <td></td>
        <td>GetSSEGeometryPackingPickers()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetCenter() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetCentralAA() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetExtent( const coord::Axis &AXIS) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetFragments() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetGeometries() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetGeometryCoordinateChangeSignal() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetGeometryDestructorSignal() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetIdentification() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetLength() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetMainAxis() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetOrientation() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetPhiPsi() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetRadialExtent() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetRotation() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetSSEGeometries() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetSSEGeometry() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>GetType() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>IsDefined() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>SSEGeometryPhiPsi( const SSE &ORIGINAL_SSE)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>SSEGeometryPhiPsi( const SSEGeometryPhiPsi &GEOMETRY)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>SSEGeometryPhiPsi( const biol::AASequencePhiPsi &PHI_PSI, const biol::SSType &SS_TYPE = biol::GetSSTypes().e_Undefined, const std::string &IDENTIFICATION = Ó, const bool SET_GEOMETRY = false )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>SSEGeometryPhiPsi()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>SetSSEGeometryUsingPhiPsi()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsi</td>
        <td>operator =( const SSEGeometryPhiPsi &SSE_GEOMETRY_PHI_PSI_RHS)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsiLessThan</td>
        <td>operator ()( const SSEGeometryPhiPsi &SSE_GEO_A, const SSEGeometryPhiPsi &SSE_GEO_B) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsiLessThan</td>
        <td>operator ()( const util::PtrInterface< SSEGeometryPhiPsi> &PTR_SSE_GEO_A, const util::PtrInterface< SSEGeometryPhiPsi> &PTR_SSE_GEO_B ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_geometry_phi_psi.h</td>
        <td>SSEGeometryPhiPsiLessThan</td>
        <td>operator ()( const util::PtrInterface< const SSEGeometryPhiPsi> &PTR_SSE_GEO_A, const util::PtrInterface< const SSEGeometryPhiPsi> &PTR_SSE_GEO_B ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pair_template.h</td>
        <td>SSEPairTemplate</td>
        <td>GetFirstGeometry() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pair_template.h</td>
        <td>SSEPairTemplate</td>
        <td>GetLoopLength() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pair_template.h</td>
        <td>SSEPairTemplate</td>
        <td>GetPacking() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pair_template.h</td>
        <td>SSEPairTemplate</td>
        <td>GetSecondGeometry() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pair_template.h</td>
        <td>SSEPairTemplate</td>
        <td>SSEPairTemplate( const util::ShPtr< SSEGeometryInterface> &SP_FIRST_SSE_GEOMETRY, const util::ShPtr< SSEGeometryInterface> &SP_SECOND_SSE_GEOMETRY, const size_t LOOP_LENGTH )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pair_template.h</td>
        <td>SSEPairTemplate</td>
        <td>SSEPairTemplate()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>Begin() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>CalculateAverageHelixStrandCounts() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>CalculateHelixToStrandRatio() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>CalculateOverlapMeasure( const SSE &TARGET_SSE, const SSE &SSE_FROM_POOL) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>CalculateStatistics( const DomainInterface &SSE_DOMAIN) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>ChopSSEs( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE_MAP)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>CountLongNonOverlappingSSEs( const size_t MIN_SIZE_STRAND, const size_t MIN_SIZE_HELIX) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>End() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>FindBestMatchFromPool( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>FindBestMatchFromPool( const SSE &TARGET_SSE, const double MATCH_THRESHOLD = double( 2)) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetChainsRepresented( const std::string &POOL_FILENAME )
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetCommandLineMinSSELengths()
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetFlagMinSSELengths()
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetFlagPoolPrefix()
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetFlagPoolRead()
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetNonIdenticalSSEs( const ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetNonOverlappingSSEs( const ProteinModel &PROTEIN_MODEL) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetNonOverlappingSSEs( const ProteinModel &PROTEIN_MODEL, const biol::SSType &SSE_TYPE ) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetNumberAAs() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetNumberPotentiallyStructuredAAs() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetOverlappingSSEs( const DomainInterface &SSE_DOMAIN, const bool EXCLUDE_IDENTICAL = true, const bool EXCLUDE_DIFFERENT_SSTYPE = false ) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetOverlappingSSEs( const SSE &TARGET_SSE, const bool EXCLUDE_IDENTICAL = true, const bool EXCLUDE_DIFFERENT_SSTYPE = false ) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetRandomNonOverlappingSet() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetSSEs( const biol::SSType &SS_TYPE) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetSSEs() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetSize() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>GetStatisticsTableHeaders()
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>Insert( const util::ShPtr< SSE> &SP_SSE)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>InsertElements( const SSEPool &SSE_POOL)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>InsertElements( const t_IteratorType &ITR_BEGIN, const t_IteratorType &ITR_END)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>IsOverlapping() const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>Join( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE_MAP)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>Prune( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE_MAP)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>ReadSSEPool( std::istream &ISTREAM, const ProteinModel &PROTEIN_MODEL, const size_t MIN_HELIX_LENGTH = 7, const size_t MIN_STRAND_LENGTH = 5 )
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>ReadSSEPool( std::istream &ISTREAM, const biol::AASequence &SEQUENCE, const size_t MIN_HELIX_LENGTH = 7, const size_t MIN_STRAND_LENGTH = 5 )
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>ReadSSEPoolInformation( const std::string &POOL_FILENAME )
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>SSEPool( const util::SiPtrList< const SSE> &SSE_LIST, const bool IGNORE_UNSTRUCTURED = true, const bool IDEALIZE = true )
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>SSEPool( const util::SiPtrVector< const SSE> &SSE_VECTOR, const bool IGNORE_UNSTRUCTURED = true, const bool IDEALIZE = true )
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>SSEPool()
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>Separate( const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE_MAP, const size_t NR_RESIDUES)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool.h</td>
        <td>SSEPool</td>
        <td>WriteSSEPool( std::ostream &OSTREAM) const
</td>
        <td>linders, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_agreement.h</td>
        <td>SSEPoolAgreement</td>
        <td>AgreementToTemplate( const SSEPool &POOL, const SSEPool &POOL_TEMPLATE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_agreement.h</td>
        <td>SSEPoolAgreement</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_agreement.h</td>
        <td>SSEPoolAgreement</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_agreement.h</td>
        <td>SSEPoolAgreement</td>
        <td>Overlap( const biol::AASequence &SEQUENCE, const biol::AASequence &SEQUENCE_TEMPLATE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_agreement.h</td>
        <td>SSEPoolAgreement</td>
        <td>Q3Score( const SSEPool &POOL_A, const SSEPool &POOL_B) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_agreement.h</td>
        <td>SSEPoolAgreement</td>
        <td>SSEPoolAgreement( const bool LOG = true, const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_agreement.h</td>
        <td>SSEPoolAgreement</td>
        <td>operator ()( const SSEPool &POOL_A, const SSEPool &POOL_B) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_insert_coil_into_sse.h</td>
        <td>SSEPoolInsertCoilIntoSSE</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_insert_coil_into_sse.h</td>
        <td>SSEPoolInsertCoilIntoSSE</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_insert_coil_into_sse.h</td>
        <td>SSEPoolInsertCoilIntoSSE</td>
        <td>SSEPoolInsertCoilIntoSSE( const sspred::Method &SS_METHOD, const util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > &SP_LOCATE_SSE, const size_t COIL_LENGTH, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_insert_coil_into_sse.h</td>
        <td>SSEPoolInsertCoilIntoSSE</td>
        <td>operator ()( const SSEPool &SSE_POOL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_join_sses.h</td>
        <td>SSEPoolJoinSSEs</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_join_sses.h</td>
        <td>SSEPoolJoinSSEs</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_join_sses.h</td>
        <td>SSEPoolJoinSSEs</td>
        <td>SSEPoolJoinSSEs( const util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > &SP_LOCATE_SSE, const bool JOIN_LEFT = true, const bool JOIN_RIGHT = true, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_join_sses.h</td>
        <td>SSEPoolJoinSSEs</td>
        <td>operator ()( const SSEPool &SSE_POOL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_move_aa.h</td>
        <td>SSEPoolMoveAA</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_move_aa.h</td>
        <td>SSEPoolMoveAA</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_move_aa.h</td>
        <td>SSEPoolMoveAA</td>
        <td>SSEPoolMoveAA( const math::Range< size_t> &RESIDUES_TO_MOVE_RANGE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_move_aa.h</td>
        <td>SSEPoolMoveAA</td>
        <td>operator ()( const SSEPool &SSE_POOL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_mutate_sse.h</td>
        <td>SSEPoolMutateSSE</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_mutate_sse.h</td>
        <td>SSEPoolMutateSSE</td>
        <td>SSEPoolMutateSSE( const util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > &SP_LOCATE_SSE, const util::ShPtr< math::MutateInterface< SSE> > &SP_SSE_MUTATE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_mutate_sse.h</td>
        <td>SSEPoolMutateSSE</td>
        <td>operator ()( const SSEPool &SSE_POOL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_split_sse.h</td>
        <td>SSEPoolSplitSSE</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_split_sse.h</td>
        <td>SSEPoolSplitSSE</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_pool_split_sse.h</td>
        <td>SSEPoolSplitSSE</td>
        <td>SSEPoolSplitSSE( const sspred::Method &SS_METHOD, const util::ShPtr< find::LocatorInterface< util::SiPtr< const SSE>, DomainInterface> > &SP_LOCATE_SSE, const util::ShPtr< math::MutateInterface< SSE> > &SP_MUTATE_SSE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_pool_split_sse.h</td>
        <td>SSEPoolSplitSSE</td>
        <td>operator ()( const SSEPool &SSE_POOL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_transformer.h</td>
        <td>SSETransformer</td>
        <td>SSETransformer( const util::ShPtr< biol::AASequence> &SP_SEQUENCE, const util::ShPtr< math::TransformationMatrix3D> &SP_TRANSFORMATION )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_sse_transformer.h</td>
        <td>SSETransformer</td>
        <td>SSETransformer()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_sse_transformer.h</td>
        <td>SSETransformer</td>
        <td>operator ()( const SSE &INITIAL_SSE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>BuildTopologyFromContacts( const ProteinModel &PROTEIN)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>BuildTopologyFromGeometries( const util::SiPtrVector< const SSEGeometryInterface> &SSE_GEOMETRY_VECTOR, const SSEGeometryPackingPicker &PACKER, const math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> &PACKING_CRITERIA )
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>BuildTopologyGraphFromGeometries( const util::SiPtrVector< const SSEGeometryInterface> &SSE_GEOMETRY_VECTOR, const SSEGeometryPackingPicker &PACKER, const math::FunctionInterfaceSerializable< SSEGeometryPacking, bool> &PACKING_CRITERIA )
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>CalculateCenterOfGeometries( const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR )
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetCenter() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetElements() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetElementsVectorFromGraph( const GraphType &GRAPH )
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetGraph() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetIdentification() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetOrderedIdentification() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetOrientation() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetPackingForSSEGeometryPair( const util::SiPtr< const SSEGeometryInterface> &SP_GEOMETRY_A, const util::SiPtr< const SSEGeometryInterface> &SP_GEOMETRY_B ) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetSubTopologies() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetSubTopology( const util::SiPtrVector< const SSEGeometryInterface> &ELEMENTS) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetType() const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>GetTypeName( const Type &TYPE)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>OrderElements()
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>SetElements( const util::SiPtrVector< const SSEGeometryInterface> &ELEMENTS)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>SetGraph( const GraphType &GRAPH)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>SetOrientation( const math::TransformationMatrix3D &ORIENTATION)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>SetOrientationFromType()
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>SetType( const Type TOPOLOGY_TYPE)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>Topology( const GraphType &GRAPH)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>Topology( const math::TransformationMatrix3D &ORIENTATION)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>Topology( const util::SiPtrVector< const SSEGeometryInterface> &GEOMETRY_VECTOR)
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>Topology()
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology.h</td>
        <td>Topology</td>
        <td>WriteGraphVizScript( std::ostream &OSTREAM, const math::SumFunction< SSEGeometryPacking, double> &COLOR_EDGE ) const
</td>
        <td>karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology_distance.h</td>
        <td>TopologyDistance</td>
        <td>GetAngleCutoff() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology_distance.h</td>
        <td>TopologyDistance</td>
        <td>GetDefaultAngleCutoff()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology_distance.h</td>
        <td>TopologyDistance</td>
        <td>GetDefaultDistanceCutoff()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology_distance.h</td>
        <td>TopologyDistance</td>
        <td>GetDistanceCutoff() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology_distance.h</td>
        <td>TopologyDistance</td>
        <td>TopologyDistance( const double DISTANCE_CUTOFF, const double ANGLE_CUTOFF)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology_distance.h</td>
        <td>TopologyDistance</td>
        <td>TopologyDistance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology_distance.h</td>
        <td>TopologyDistance</td>
        <td>operator ()( const Chain &CHAIN, const Chain &TEMPLATE_CHAIN) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_topology_distance.h</td>
        <td>TopologyDistance</td>
        <td>operator ()( const ProteinModel &MODEL, const ProteinModel &TEMPLATE_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_topology_distance.h</td>
        <td>TopologyDistance</td>
        <td>operator ()( const SSE &SS_ELEMENT, const SSE &TEMPLATE_SS_ELEMENT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_aa.h</td>
        <td>VoxelGridAA</td>
        <td>ExtractPosition( const util::SiPtr< const biol::AABase> &AA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_aa.h</td>
        <td>VoxelGridAA</td>
        <td>GetAAClashScore( const util::SiPtrVector< const biol::AABase> &AAS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_aa.h</td>
        <td>VoxelGridAA</td>
        <td>GetAAClashScore()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_aa.h</td>
        <td>VoxelGridAA</td>
        <td>GetMinSSEMoveIDsToRemoveClashes( const util::SiPtrVector< const SSE> &SSES, const util::SiPtrVector< const biol::AABase> &AAS, const bool &CONSIDER_LOOPS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_aa.h</td>
        <td>VoxelGridAA</td>
        <td>GetMinSSEMovesToRemoveClashes( const util::SiPtrVector< const SSE> &SSES, const util::SiPtrVector< const biol::AABase> &AAS, const bool &CONSIDER_LOOPS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_aa.h</td>
        <td>VoxelGridAA</td>
        <td>GetSSEConnections( const util::SiPtrVector< const SSE> &SSES, const util::SiPtrVector< const biol::AABase> &AAS, const size_t &SEQ_EXCLUSION, const double &RESOLUTION, const bool &CONSIDER_LOOPS, const bool &MUTUALLY_CLOSEST_DIFF_SSE_CONNECTIONS_ONLY = false, const bool &CONSIDER_INTRA_LOOP_CLASHES = true )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_aa.h</td>
        <td>VoxelGridAA</td>
        <td>GetSSEInteractionMatrix( const util::SiPtrVector< const SSE> &SSES, const util::SiPtrVector< const biol::AABase> &AAS, const size_t &SEQ_EXCLUSION, const double &RESOLUTION, const bool &CONSIDER_LOOPS, const double &MIN_CONTACT_P, const bool &CONSIDER_POINT_CONTACTS, const bool &MUTUALLY_CLOSEST_DIFF_SSE_CONNECTIONS_ONLY = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_aa.h</td>
        <td>VoxelGridAA</td>
        <td>IsSameItem( const biol::AABase &ITEM_1, const biol::AABase &ITEM_2) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_aa.h</td>
        <td>VoxelGridAA</td>
        <td>VoxelGridAA( const double &RESOLUTION = 4.0, const bool &CACHE_EDGES = false, const bool &PREFER_CA = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>ExcludeResiduesSameAA( const util::SiPtrVector< const biol::AABase> &AAS, const size_t &SEQ_EXCLUSION = 0 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>ExcludeResiduesSameSSE( const util::SiPtrVector< const SSE> &SSES, const util::SiPtrVector< const biol::AABase> &AAS, const size_t &SEQ_EXCLUSION = 0 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>ExtractPosition( const util::SiPtr< const biol::Atom> &ATOM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>GetSSEInteractionMatrix( const double &RESOLUTION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>IsSameItem( const biol::Atom &ITEM_1, const biol::Atom &ITEM_2) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>SetGroupIDs( const storage::Vector< size_t> &GROUP_IDS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>SetObjects( const util::SiPtrVector< const biol::Atom> &NEW_DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>VoxelGridAtom( const double &RESOLUTION = 4.0, const bool &CACHE_EDGES = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_mutation.h</td>
        <td>VoxelGridMutation</td>
        <td>ExtractPosition( const util::SiPtr< const biol::Mutation> &MUTATION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_mutation.h</td>
        <td>VoxelGridMutation</td>
        <td>ExtractPositions( const util::SiPtr< const biol::Mutation> &INPUT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_mutation.h</td>
        <td>VoxelGridMutation</td>
        <td>IsSameItem( const biol::Mutation &ITEM_1, const biol::Mutation &ITEM_2) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_assemble_voxel_grid_mutation.h</td>
        <td>VoxelGridMutation</td>
        <td>SetObjects( const util::SiPtrVector< const biol::Mutation> &NEW_DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_assemble_voxel_grid_mutation.h</td>
        <td>VoxelGridMutation</td>
        <td>VoxelGridMutation( const double &RESOLUTION = 4.0, const bool &CACHE_EDGES = false, const bool &PREFER_CA = false, const bool &PREFER_CENTER = true)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>AA( const AA &AMINO_ACID)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>AA( const AABase &AA_BASE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>AA( const util::ShPtr< AAData> &SP_AA_DATA)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>AA()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>CalculateOmega( const Atom &PREVIOUS_CA, const Atom &PREVIOUS_C) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>CalculatePhi( const Atom &PREVIOUS_C) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>CalculatePsi( const Atom &FOLLOWING_N) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>Empty( const util::ShPtr< AAData> &SP_AA_DATA) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetAAClass() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetAtom( const AtomType &ATOM_TYPE) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetAtomCoordinates( const storage::Set< AtomType> &ATOM_TYPES) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetAtomCoordinates() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetAtoms( const storage::Set< AtomType> &ATOM_TYPES) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetAtoms() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetCA() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetCenter() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetFirstSidechainAtom() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetNumberOfAtoms() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>GetTypesOfAtoms() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>Phi() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>Psi() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>SetAtom( const Atom &ATOM)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>SetAtoms( const util::SiPtrVector< const Atom> &ATOMS)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>SetToIdealConformation( const SSType &SS_TYPE, const math::TransformationMatrix3D &TRANSFORMATION_MATRIX3D )
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa.h</td>
        <td>AA</td>
        <td>operator =( const AA &AA_RHS)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>AABackBone( const AABackBone &AA_BACKBONE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>AABackBone( const AABase &AA_BASE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>AABackBone( const AABase &AA_BASE, const util::SiPtrVector< const Atom> &ATOMS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>AABackBone( const AACaCb &AA_CACB)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>AABackBone( const util::ShPtr< AAData> &SP_AA_DATA)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>AABackBone()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>CalculateOmega( const Atom &PREVIOUS_CA, const Atom &PREVIOUS_C) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>CalculatePhi( const Atom &PREVIOUS_C) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>CalculatePsi( const Atom &FOLLOWING_N) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>Empty( const util::ShPtr< AAData> &SP_AA_DATA) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetAAClass() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetAtom( const AtomType &ATOM_TYPE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetAtomCoordinates( const storage::Set< AtomType> &ATOM_TYPES) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetAtomCoordinates() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetAtoms( const storage::Set< AtomType> &ATOM_TYPES) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetAtoms() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetCA() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetCenter() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetFirstSidechainAtom() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetNumberOfAtoms() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>GetTypesOfAtoms() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>Phi() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>Psi() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>SetAtom( const Atom &ATOM)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>SetAtoms( const util::SiPtrVector< const Atom> &ATOMS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>SetToIdealConformation( const SSType &SS_TYPE, const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone.h</td>
        <td>AABackBone</td>
        <td>operator =( const AABackBone &AA_BACKBONE_RHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>AABackBoneCompleter( const bool ADD_AMIDE_HYDROGENS = true, const bool ADD_CARBONYL_OXYGENS = true, const bool ADD_HA_HYDROGENS = true )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>CompleteAASequence( const AASequence &AA_SEQUENCE, const util::SiPtr< const AABase> &SP_PREV_AA, const util::SiPtr< const AABase> &SP_NEXT_AA ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>CompleteChain( const assemble::Chain &CHAIN) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>CompleteProteinModel( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GenerateC( const AABase &AMINO_ACID, const double PHI, const double BOND_LENGTH = GetAtomTypes().C->GetBondLength( GetAtomTypes().N) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GenerateCOCA( const AABase &AMINO_ACID, const double PHI )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GenerateHA( const AABase &AMINO_ACID, const double BOND_LENGTH = GetAtomTypes().CA->GetBondLength( GetAtomTypes().HA) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GenerateHNCA( const AABase &AMINO_ACID )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GenerateHydrogen( const AABase &AMINO_ACID, const linal::Vector3D &PREV_C_COORD, const double BOND_LENGTH = GetAtomTypes().N->GetBondLength( GetAtomTypes().H) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GenerateN( const AABase &AMINO_ACID, const double BOND_LENGTH = GetAtomTypes().C->GetBondLength( GetAtomTypes().N) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GenerateOxygen( const AABase &AMINO_ACID, const linal::Vector3D &NEXT_N_COORD, const double BOND_LENGTH = GetAtomTypes().C->GetBondLength( GetAtomTypes().O) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GetAddAmideHydrogens() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GetAddCarbonylOxygens() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_back_bone_completer.h</td>
        <td>AABackBoneCompleter</td>
        <td>GetAddHAHydrogens() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>AABase( const AABase &AA_BASE_RHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>AABase( const util::ShPtr< AAData> &SP_AA_DATA)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>AABase()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>AreAminoAcidsPeptideBonded( const AABase &AA_LEFT, const AABase &AA_RIGHT, const bool TEST_OMEGA )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>CalculateCenterOfMassOfSideChain() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>CalculatePhiPsi( const Atom &PREVIOUS_C, const Atom &FOLLOWING_N) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>CalculateSideChainDihedralAngles() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>Construct( const char ONE_LETTER_CODE, const int SEQ_ID)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>DoesPrecede( const AABase &AMINO_ACID) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetAtoms( const chemistry::ElementType &ELEMENT_TYPE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetBlastProfile() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetBlastProfilePtr() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetChainID() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetData() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetExposurePrediction() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetIdentification() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetPdbICode() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetPdbID() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetSSPrediction( const sspred::Method &SS_METHOD ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetSSPredictions() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetSeqID() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>GetType() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>HasDefinedCoordinates( const storage::Set< AtomType> &ATOM_TYPES = GetAtomTypes().GetBackBoneAtomTypes() ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>Locator( const bool USE_PDB_ID) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>PeptideBondLengthAndAngle( const AABase &AA_LEFT, const AABase &AA_RIGHT )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>ReadBlastProfile( std::istream &ISTREAM)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>ReadFasta( std::istream &ISTREAM, const size_t SEQ_ID = 1)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>RemoveStructureBasedSSTMInfo()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>SetBlastProfile( const BlastProfile &BLAST_PROFILE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>SetData( const util::ShPtr< AAData> &SP_AA_DATA)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>SetExposurePrediction( const double &EXPOSURE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>SetSSPrediction( const sspred::Method &SS_METHOD, const sspred::MethodInterface &PREDICTION )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>SetSSPredictions( const storage::Map< sspred::Method, util::ShPtr< sspred::MethodInterface> > &PREDICTIONS_MAP )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>SetType( const AAType &TYPE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>WriteFasta( std::ostream &OSTREAM) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td>AABase</td>
        <td>operator =( const AABase &AA_BASE_RHS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td></td>
        <td>FirstSidechainAtomDistance( const AABase &AMINO_ACID_A, const AABase &AMINO_ACID_B)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td></td>
        <td>NearestAtomVdWSphereSeparation( const AABase &AMINO_ACID_A, const AABase &AMINO_ACID_B, const bool &IGNORE_BB_BB)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_base.h</td>
        <td></td>
        <td>SequenceSeparation( const AABase &AMINO_ACID_A, const AABase &AMINO_ACID_B)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_base.h</td>
        <td></td>
        <td>operator ==( const AABase &AMINO_ACID_A, const AABase &AMINO_ACID_B)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>AACaCb( const AABase &AA_BASE)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>AACaCb( const AABase &AA_BASE, const Atom &ATOM_CA, const Atom &ATOM_CB )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>AACaCb( const AABase &AMINO_ACID, const util::SiPtrVector< const Atom> &ATOMS )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>AACaCb( const AACaCb &AACACB)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>AACaCb( const util::ShPtr< AAData> &SP_AA_DATA)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>AACaCb()
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>CalculateOmega( const Atom &PREVIOUS_CA, const Atom &PREVIOUS_C) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>CalculatePhi( const Atom &PREVIOUS_C) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>CalculatePsi( const Atom &FOLLOWING_N) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>Empty( const util::ShPtr< AAData> &SP_AA_DATA) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetAAClass() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetAtom( const AtomType &ATOM_TYPE) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetAtomCoordinates( const storage::Set< AtomType> &ATOM_TYPES) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetAtomCoordinates() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetAtoms( const storage::Set< AtomType> &ATOM_TYPES) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetAtoms() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetCA() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetCenter() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetFirstSidechainAtom() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetNumberOfAtoms() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>GetTypesOfAtoms() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>Phi() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>Psi() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>SetAtom( const Atom &ATOM)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>SetAtoms( const util::SiPtrVector< const Atom> &ATOMS)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>SetToIdealConformation( const SSType &SS_TYPE, const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_ca_cb.h</td>
        <td>AACaCb</td>
        <td>operator =( const AACaCb &AACACB_RHS)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_classes.h</td>
        <td></td>
        <td>GetAAClasses()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareBySeqID</td>
        <td>AACompareBySeqID( const int SEQ_ID)
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareBySeqID</td>
        <td>operator ()( const AABase &AMINO_ACID) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareBySeqID</td>
        <td>operator ()( const util::PtrInterface< AABase> &SP_AMINO_ACID) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareBySeqID</td>
        <td>operator ()( const util::PtrInterface< const AABase> &SP_AMINO_ACID) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareData</td>
        <td>AACompareData()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareData</td>
        <td>operator ()( const AABase &AA_BASE_LHS, const AABase &AA_BASE_RHS) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareData</td>
        <td>operator ()( const util::PtrInterface< AABase> &SP_AA_BASE_LHS, const util::PtrInterface< AABase> &SP_AA_BASE_RHS ) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareData</td>
        <td>operator ()( const util::PtrInterface< const AABase> &SP_AA_BASE_LHS, const util::PtrInterface< const AABase> &SP_AA_BASE_RHS ) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareDataPtr</td>
        <td>operator ()( const AABase &AA_BASE_LHS, const AABase &AA_BASE_RHS) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareDataPtr</td>
        <td>operator ()( const util::PtrInterface< AABase> &SP_AA_BASE_LHS, const util::PtrInterface< AABase> &SP_AA_BASE_RHS ) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_compare.h</td>
        <td>AACompareDataPtr</td>
        <td>operator ()( const util::PtrInterface< const AABase> &SP_AA_BASE_LHS, const util::PtrInterface< const AABase> &SP_AA_BASE_RHS ) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_compare.h</td>
        <td>AALessThanSeqID</td>
        <td>operator ()( const AABase &AA_BASE_LHS, const AABase &AA_BASE_RHS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_compare.h</td>
        <td>AALessThanSeqID</td>
        <td>operator ()( const util::PtrInterface< AABase> &SP_AA_BASE_LHS, const util::PtrInterface< AABase> &SP_AA_BASE_RHS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_compare.h</td>
        <td>AALessThanSeqID</td>
        <td>operator ()( const util::PtrInterface< const AABase> &SP_AA_BASE_LHS, const util::PtrInterface< const AABase> &SP_AA_BASE_RHS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>AAComplete( const AABackBone &AA_BACKBONE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>AAComplete( const AABase &AA_BASE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>AAComplete( const AABase &AA_BASE, const util::SiPtrVector< const Atom> &ATOMS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>AAComplete( const AACaCb &AA_CACB)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>AAComplete( const AAComplete &AA_COMPLETE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>AAComplete( const util::ShPtr< AAData> &SP_AA_DATA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>AAComplete()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>CalculateOmega( const Atom &PREVIOUS_CA, const Atom &PREVIOUS_C) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>CalculatePhi( const Atom &PREVIOUS_C) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>CalculatePsi( const Atom &FOLLOWING_N) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>Empty( const util::ShPtr< AAData> &SP_AA_DATA) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetAAClass() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetAtom( const AtomType &ATOM_TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetAtomCoordinates( const storage::Set< AtomType> &ATOM_TYPES) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetAtomCoordinates() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetAtoms( const storage::Set< AtomType> &ATOM_TYPES) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetAtoms() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetCA() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetCenter() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetFirstSidechainAtom() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetNumberOfAtoms() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>GetTypesOfAtoms() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>Phi() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>Psi() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>SetAtom( const Atom &ATOM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>SetAtoms( const util::SiPtrVector< const Atom> &ATOMS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>SetToIdealConformation( const SSType &SS_TYPE, const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_complete.h</td>
        <td>AAComplete</td>
        <td>operator =( const AAComplete &AA_COMPLETE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>AAData( const AAType &AA_TYPE = GetAATypes().e_Undefined, const int SEQ_ID = s_DefaultSeqID, const int PDB_ID = s_DefaultPdbID, const char PDB_I_CODE = s_DefaultPdbICode, const char CHAIN_ID = s_DefaultChainID )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>GetBlastProfile() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>GetChainID() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>GetExposurePrediction() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>GetPdbICode() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>GetPdbID() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>GetSSPrediction( const sspred::Method &SS_METHOD) const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>GetSSPredictions() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>GetSeqID() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>GetType() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>SetChainID( char ID)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>SetSeqID( int ID)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_data.h</td>
        <td>AAData</td>
        <td>operator <( const AAData &RHS_AA_DATA) const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>AASequence( const AAClass &AACLASS, const size_t LENGTH, const char CHAIN_ID, const std::string &FASTA_HEADER = GetDefaultFastaHeader() )
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>AASequence( const AASequence &AA_SEQUENCE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>AASequence( const util::ShPtrVector< AABase> &DATA, const char CHAIN_ID = s_DefaultChainID, const std::string &FASTA_HEADER = GetDefaultFastaHeader() )
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>AASequence()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>AddMember( const char &ONE_LETTER_CODE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>AppendSequence( const AASequence &SEQUENCE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>Begin()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>Begin() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>CalculatePhiPsi( const int SEQ_ID) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>ChopSequence( const size_t SIZE) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>ClipEnds( const size_t NUMBER_AMINO_ACIDS)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>ConnectAADataByPdbID( AASequence &AA_SEQUENCE, const bool &SET_ATOMS = true) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>Construct( const std::string &ID, const std::string &MEMBERS, const char CHAIN_ID = 0 ) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>CountDefinedAACoordinates( const storage::Set< AtomType> &ATOM_TYPES = GetAtomTypes().GetBackBoneAtomTypes() ) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>DoesPrecede( const AASequence &SEQUENCE) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>End()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>End() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>FindAABySeqID( const int SEQ_ID)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>FindAABySeqID( const int SEQ_ID) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetAA( const size_t INDEX) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetAtomCoordinates( const storage::Set< AtomType> &ATOM_TYPES ) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetAtomCoordinates() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetAtoms( const storage::Set< AtomType> &ATOM_TYPES ) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetAtoms() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetCenter() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetChainID() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetData( const AAType &AA_TYPE) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetData()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetData() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetDefaultFastaHeader()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetFastaHeader() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetFirstAA() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetFirstMember() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetLastAA() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetLastMember() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetMembers()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetMembers() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetSequenceId() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetSequenceIdentification() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetSize() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>HardCopy() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>HasDefinedCoordinates( const storage::Set< AtomType> &ATOM_TYPES = GetAtomTypes().GetBackBoneAtomTypes() ) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>Initialize( const AAClass &AA_CLASS, const size_t LENGTH)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>IsContinuous( const util::ShPtrVector< AABase> &DATA)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>PopBack()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>PrependSequence( const AASequence &SEQUENCE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>PushBack( const AABase &AMINO_ACID)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>PushBack( const util::ShPtr< AABase> &SP_AMINO_ACID)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>PushFront( const AABase &AMINO_ACID)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>Reset()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>ReverseBegin()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>ReverseBegin() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>ReverseEnd()
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>ReverseEnd() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATIONMATRIX3D)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>Sequence() const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>SetAA( const size_t INDEX, const AABase &AMINO_ACID)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>SetChainID( const char CHAIN_ID)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>SetData( const util::ShPtrVector< AABase> &AA_SEQUENCE_DATA)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>SetFastaHeader( const std::string &FASTA_HEADER)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>SubSequence( const size_t &INDEX, const size_t LENGTH) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATIONMATRIX3D)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>WriteFasta( std::ostream &OSTREAM, const size_t BLOCK_SIZE = 50) const
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td>AASequence</td>
        <td>operator =( const AASequence &AA_SEQUENCE)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td></td>
        <td>CalculateSequenceDistance( const AASequence &SEQUENCE_A, const AASequence &SEQUENCE_B)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td></td>
        <td>CreateWindowsFromAminoAcids( const AASequence &SEQUENCE, const size_t WINDOW_RADIUS, const AABase &UNDEFINED_AA )
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td></td>
        <td>DoOverlap( const AASequence &SEQUENCE_A, const AASequence &SEQUENCE_B)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence.h</td>
        <td></td>
        <td>GetPeptideBondLength( const AABase &N_TERMINAL_AA, const AABase &C_TERMINAL_AA)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence.h</td>
        <td></td>
        <td>operator ==( const AASequence &SEQUENCE_A, const AASequence &SEQUENCE_B)
</td>
        <td>staritrd, karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>AASequenceFactory()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>AppendAA( AASequence &SEQUENCE, const AABase &AMINO_ACID, const double PHI, const double PSI )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>AppendSequence( AASequence &N_TERMINAL_SEQUENCE, const AASequence &C_TERMINAL_SEQUENCE, const double PHI, const double PSI )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>BuildSequenceFromFASTA( std::istream &ISTREAM, const AAClass &AA_CLASS = GetAAClasses().e_AA, const char CHAIN_ID = Ã )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>BuildSequenceFromFASTAString( const std::string &SEQUENCE_STRING, const AAClass &AA_CLASS = GetAAClasses().e_AA, const char CHAIN_ID = Ã )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>CalculateSuperimposition( const AASequence &AA_SEQUENCE_A, const AASequence &AA_SEQUENCE_B )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>FitSequence( AASequence &SEQUENCE, const AASequencePhiPsi &PHI_PSI, const SSType &SS_TYPE )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>IdealizeSequence( AASequence &AA_SEQUENCE, const SSType &SS_TYPE)
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>PrependAA( const AABase &AMINO_ACID, AASequence &SEQUENCE, const double PHI, const double PSI )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>PrependSequence( const AASequence &N_TERMINAL_SEQUENCE, AASequence &C_TERMINAL_SEQUENCE, const double PHI, const double PSI )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>ReadSequenceData( const storage::Vector< std::string> &FILENAMES)
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>TransformationAppend( const AASequence &N_TERMINAL_SEQUENCE, const AABase &C_TERMINAL_AA, const double PHI )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_factory.h</td>
        <td>AASequenceFactory</td>
        <td>TransformationPrepend( const AABase &N_TERMINAL_AA, const AASequence &C_TERMINAL_SEQUENCE, const double PHI )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_flexibility.h</td>
        <td>AASequenceFlexibility</td>
        <td>CalculatePhiPsiChange( AASequence &SEQUENCE, const int SEQ_ID, const storage::VectorND< 2, double> &PHI_PSI )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_flexibility.h</td>
        <td>AASequenceFlexibility</td>
        <td>CalculateTransformation( const linal::Vector3D &ATOM_BEGIN, const linal::Vector3D &ATOM_END, const double ROTATION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_flexibility.h</td>
        <td>AASequenceFlexibility</td>
        <td>ChangePhiPsi( AASequence &SEQUENCE, const int SEQ_ID, const storage::VectorND< 2, double> &PHI_PSI_CHANGE, const SequenceDirection &SEQUENCE_DIRECTION = e_Bidirectional )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_flexibility.h</td>
        <td>AASequenceFlexibility</td>
        <td>GetNumberDifferentPhiPsi( const AASequence &SEQUENCE_A, const AASequence &SEQUENCE_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_flexibility.h</td>
        <td>AASequenceFlexibility</td>
        <td>GetSequenceDirectionName( const SequenceDirection &SEQUENCE_DIRECTION)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_flexibility.h</td>
        <td>AASequenceFlexibility</td>
        <td>SetPhiPsi( AASequence &SEQUENCE, const int SEQ_ID, const storage::VectorND< 2, double> &PHI_PSI, const SequenceDirection &SEQUENCE_DIRECTION = e_Bidirectional )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_flexibility.h</td>
        <td>AASequenceFlexibility</td>
        <td>TransformAtom( AABase &AMINO_ACID, const AtomType &ATOM_TYPE, const math::TransformationMatrix3D &TRANSFORMATION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>AASequencePhiPsi( const AASequence &SEQUENCE)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>AASequencePhiPsi( const linal::Vector3D &N_COORDS, const linal::Vector3D &CA_COORDS, const linal::Vector3D &C_COORDS, const storage::Vector< storage::VectorND< 2, double> > &ANGLES )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>AASequencePhiPsi()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>GetAngles() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>GetC() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>GetCA() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>GetCenter() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>GetN() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>IsDefined() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_sequence_phi_psi.h</td>
        <td>AASequencePhiPsi</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_side_chain_factory.h</td>
        <td>AASideChainFactory</td>
        <td>AASideChainFactory( const bool INCLUDE_HYDROGEN, const bool INCLUDE_BACKBONE = true, const std::string &TABLE_FILE_NAME = GetDefaultTableFileName() )
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_side_chain_factory.h</td>
        <td>AASideChainFactory</td>
        <td>AASideChainFactory()
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_side_chain_factory.h</td>
        <td>AASideChainFactory</td>
        <td>AddSideChain( AABase &AA_BASE) const
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_side_chain_factory.h</td>
        <td>AASideChainFactory</td>
        <td>GenerateAtoms( const AAType &AATYPE) const
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_side_chain_factory.h</td>
        <td>AASideChainFactory</td>
        <td>GetDefaultTableFileName()
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_side_chain_factory.h</td>
        <td>AASideChainFactory</td>
        <td>ProteinModelWithSideChains( const assemble::ProteinModel &THIS_MODEL) const
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>AATypeData( const std::string &THREE_LETTER_CODE, const char ONE_LETTER_CODE, const bool IS_NATURAL_AA, const std::string &PARENT_TYPE )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>AATypeData( const std::string &THREE_LETTER_CODE, const char ONE_LETTER_CODE, const bool IS_NATURAL_AA, const std::string &PARENT_TYPE, const storage::Set< AtomType> &ATOM_TYPES, const AtomType &FIRST_SIDECHAIN_ATOM_TYPE, const double NATURAL_PREVALENCE, const double STERICAL_PARAMETER, const double POLARIZABILITY, const double VOLUME, const double HYDROPHOBICITY, const double ISOELECTRIC_POINT, const double CHARGE, const double PK_EMBOSS, const double PK_DTASELECT, const double PK_SOLOMON, const double PK_SILLERO, const double PK_RODWELL, const double PK_PATRICKIOS, const double PK_WIKIPEDIA, const double PK_LEHNINGER, const double PK_GRIMSELY, const double PK_BJELLQVIST, const double PK_PROMOST, const double PK_BJELLQVIST_NTERM, const double PK_BJELLQVIST_CTERM, const double PK_PROMOST_NTERM, const double PK_PROMOST_CTERM, const double PK_CAREY_NTERM, const double PK_CAREY_CTERM, const double HELIX_PROBABILITY, const double STRAND_PROBABILITY, const double FREE_ENERGY_HELIX, const double FREE_ENERGY_STRAND, const double FREE_ENERGY_COIL, const double TRANSFER_FREE_ENERGY_WHIMLEY_WHITE, const double TRANSFER_FREE_ENERGY_ENGELMAN_SEITZ_GOLDMAN, const double TRANSFER_FREE_ENERGY_KYTE_DOOLITTLE, const double TRANSFER_FREE_ENERGY_EISENBERG, const double TRANSFER_FREE_ENERGY_HOPP_WOODS, const double TRANSFER_FREE_ENERGY_GUY, const double TRANSFER_FREE_ENERGY_JANIN, const double TRANSFER_FREE_ENERGY_PUNTA_MARITAN_1D, const double TRANSFER_FREE_ENERGY_PUNTA_MARITAN_3D, const double FREE_ENERGY_CORE, const double FREE_ENERGY_TRANSITION, const double FREE_ENERGY_SOLUTION, const double FREE_ENERGY_CORE_HELIX, const double FREE_ENERGY_TRANSITION_HELIX, const double FREE_ENERGY_SOLUTION_HELIX, const double FREE_ENERGY_CORE_STRAND, const double FREE_ENERGY_TRANSITION_STRAND, const double FREE_ENERGY_SOLUTION_STRAND, const double FREE_ENERGY_CORE_COIL, const double FREE_ENERGY_TRANSITION_COIL, const double FREE_ENERGY_SOLUTION_COIL, const double FREE_ENERGY_CORE_PORE, const double FREE_ENERGY_CORE_MEMBRANE, const double BETA_BARREL_HYDROPHOBICITY, const double FREE_ENERGY_EXT_BLAST_BB, const double FREE_ENERGY_EXT_TYPE_BB, const double SASA, const double SIDE_CHAIN_GIRTH, const double SIDE_CHAIN_POLARIZABILITY, const double SIDE_CHAIN_TOPOLOGICAL_POLAR_SURFACE_AREA, const double SIDE_CHAIN_VAN_DER_WAALS_SURFACE_AREA, const int HBOND_ACCEPTORS, const int HBOND_DONORS, const bool IS_AROMATIC, const double VDW_RADIUS_CB )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>AATypeData()
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>AddAtomTypePDBAtomNameMapping( const AtomType &ATOM_TYPE, const std::string &PDB_ATOM_NAME)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>DoesContainAtomType( const AtomType &ATOM_TYPE) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetAAProperty( const PropertyType PROPERTY) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetAllowedAtomTypes() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetAllowedHeavyAtomTypes() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetAtomTypeFromAtomName( const std::string &ATOM_NAME) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetChemistryAtomType( const AtomType &ATOM_TYPE) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetFirstSidechainAtomType() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetFragment( const bool &C_TERMINAL, const bool &N_TERMINAL ) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetOneLetterCode() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetPDBAtomName( const AtomType &ATOM_TYPE) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetParentType() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetParentTypeString() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetPropertiesForANN() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetPropertyDescriptor( const PropertyType &PROPERTY_TYPE)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetSideChainDihedralAngleAtomTypes() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetStructureFactor() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetThreeLetterCode() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>GetVdwRadiusToOtherAA( const AtomType &ATOM_TYPE) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_type_data.h</td>
        <td>AATypeData</td>
        <td>IsNaturalAminoAcid() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_types.h</td>
        <td>AATypes</td>
        <td>AATypeFromOneLetterCode( const char ONE_LETTER_CODE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_types.h</td>
        <td>AATypes</td>
        <td>AATypeFromThreeLetterCode( const std::string &THREE_LETTER_CODE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_types.h</td>
        <td>AATypes</td>
        <td>AATypeParentFromThreeLetterCode( const std::string &THREE_LETTER_CODE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_types.h</td>
        <td>AATypes</td>
        <td>GetNaturalAATypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_aa_types.h</td>
        <td>AATypes</td>
        <td>HaveSameParent( const std::string &THREE_LETTER_CODE_LHS, const std::string &THREE_LETTER_CODE_RHS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_aa_types.h</td>
        <td></td>
        <td>GetAATypes()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_align_by_aa_data.h</td>
        <td>AlignByAAData</td>
        <td>AlignByAAData()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_align_by_aa_data.h</td>
        <td>AlignByAAData</td>
        <td>AlignPair( util::ShPtr< align::AlignmentInterface< AABase> > &ALIGNMENT_A, util::ShPtr< align::AlignmentInterface< AABase> > &ALIGNMENT_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_align_by_aa_data.h</td>
        <td>AlignByAAData</td>
        <td>AlignPair( util::ShPtr< align::AlignmentInterface< AABase> > &ALIGNMENT_A, util::ShPtr< align::AlignmentInterface< AABase> > &ALIGNMENT_B, const util::BinaryFunctionInterface< AABase, AABase, bool> &COMPARISON ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_align_by_aa_data.h</td>
        <td>AlignByAAData</td>
        <td>AlignPair( util::ShPtr< align::AlignmentInterface< AABase> > &ALIGNMENT_A, util::ShPtr< align::AlignmentInterface< AABase> > &ALIGNMENT_B, const util::ShPtr< align::AlignmentInterface< AABase> > &TEMPLATE_ALIGNMENT ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_align_by_aa_data.h</td>
        <td>AlignByAAData</td>
        <td>AlignPairWithNode( align::AlignmentInterface< AABase> &NODE, const util::BinaryFunctionInterface< AABase, AABase, bool> &COMPARISON ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_align_by_aa_data.h</td>
        <td>AlignByAAData</td>
        <td>AlignPairWithNode( align::AlignmentInterface< AABase> &NODE, const util::ShPtr< align::AlignmentInterface< AABase> > &TEMPLATE_ALIGNMENT ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_align_by_aa_data.h</td>
        <td>AlignByAAData</td>
        <td>SetScoringFunction( const score::AssignmentWithGap< AABase> &SCORE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_align_by_pdb_id.h</td>
        <td>AlignByPdbID</td>
        <td>AlignByPdbID()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_align_by_pdb_id.h</td>
        <td>AlignByPdbID</td>
        <td>AlignPair( util::ShPtr< align::AlignmentInterface< AABase> > &ALIGNMENT_A, util::ShPtr< align::AlignmentInterface< AABase> > &ALIGNMENT_B ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_align_by_pdb_id.h</td>
        <td>AlignByPdbID</td>
        <td>SetScoringFunction( const score::AssignmentWithGap< AABase> &SCORE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>AllCoordinatesDefined() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>Atom( const AtomType &ATOM_TYPE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>Atom( const AtomType &ATOM_TYPE, const size_t PDB_ID, const double B_FACTOR = util::GetUndefinedDouble() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>Atom( const linal::Vector3D &COORDINATES, const AtomType &ATOM_TYPE, const size_t PDB_ID = util::GetUndefinedSize_t(), const double B_FACTOR = util::GetUndefinedDouble() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>Atom()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>FindAtom( const util::SiPtrVector< const Atom> &ATOM_LIST, const AtomType &ATOM_TYPE )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>GetBFactor() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>GetCenter() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>GetCoordinates() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>GetPdbID() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>GetType() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATIONMATRIX3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>SetCoordinates( const linal::Vector3D &COORDINATES)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATIONMATRIX3D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td>Atom</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom.h</td>
        <td></td>
        <td>Dihedral( const Atom &ATOM_A, const Atom &ATOM_B, const Atom &ATOM_C, const Atom &ATOM_D)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td></td>
        <td>Distance( const Atom &ATOM_A, const Atom &ATOM_B)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom.h</td>
        <td></td>
        <td>ProjAngle( const Atom &ATOM_A, const Atom &ATOM_B, const Atom &ATOM_C)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom.h</td>
        <td></td>
        <td>SquareDistance( const Atom &ATOM_A, const Atom &ATOM_B)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_group_type_data.h</td>
        <td>AtomGroupTypeData</td>
        <td>AtomGroupTypeData( const AtomType &BASE_ATOM_TYPE, const double &DISPLACED_SOLVENT_VOLUME, const double &RADIUS, const size_t &HYDROGEN_COUNT, const double &H2O_SCATTERING_LENGTH, const double &D20_SCATTERING_LENGTH )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_group_type_data.h</td>
        <td>AtomGroupTypeData</td>
        <td>AtomGroupTypeData()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_group_type_data.h</td>
        <td>AtomGroupTypeData</td>
        <td>GetSerializer() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_group_type_data.h</td>
        <td>AtomGroupTypeData</td>
        <td>operator ()( const restraint::SasDataParameters &FORM_FACTOR_DATA) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_group_types.h</td>
        <td>AtomGroupTypes</td>
        <td>GetType( const AAType &AA, const AtomType &ATOMTYPE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_group_types.h</td>
        <td>AtomGroupTypes</td>
        <td>GetTypeString( const AAType &AA, const AtomType &ATOMTYPE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_group_types.h</td>
        <td></td>
        <td>GetAtomGroupTypes()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>AtomTypeData( const std::string &ATOM_NAME, const chemistry::ElementType &ELEMENT_TYPE, const bool IN_BACKBONE, const bool IN_SIDE_CHAIN, const coord::CylinderCoordinates &HELIX_CYLINDER_COORDINATES, const coord::CylinderCoordinates &STRAND_CYLINDER_COORDINATES )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>AtomTypeData()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetBondLength( const AtomType &ATOM_TYPE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetConnections() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetCoordinates( const SSType &SS_TYPE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetDoubleBondConnections() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetElementType() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetHelixCoordinates() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetName() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetStrandCoordinates() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>IsBackBone() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>IsSideChain() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetBackBoneAtomNames() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetBackBoneAtomTypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetCACB() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetCommandLineAtoms()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetFirstSidechainAtomTypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetFlagAtomTypes()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetSideChainAtomTypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetSubsetName( const Subset &SUBSET)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetTerminalAtomTypeFromName( const std::string &ATOM_NAME) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetTerminalExtraAtomTypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_atom_types.h</td>
        <td>AtomTypes</td>
        <td>TypeFromPDBAtomName( const std::string &PDB_ATOM_NAME) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_atom_types.h</td>
        <td></td>
        <td>GetAtomTypes()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>BlastProfile( const linal::Vector< double> &PROFILE, const double &MATCH_WEIGHT = util::GetUndefined< double>(), const double &POSITION_INFORMATION = util::GetUndefined< double>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>BlastProfile()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>CalculateConservation() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>GetAlignmentWeight() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>GetPositionInformation() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>GetProbabilities() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>GetProfile( const AAType &TYPE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>GetProfile() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>ReadProfile( std::istream &ISTREAM)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>SetProfile( const linal::Vector< double> &PROFILE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile.h</td>
        <td>BlastProfile</td>
        <td>WriteProfile( std::ostream &OSTREAM) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile_handler.h</td>
        <td>BlastProfileHandler</td>
        <td>BlastProfileHandler()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile_handler.h</td>
        <td>BlastProfileHandler</td>
        <td>ReadProfileForAA( std::istream &ISTREAM, AABase &AMINO_ACID)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile_handler.h</td>
        <td>BlastProfileHandler</td>
        <td>ReadProfileForAASequence( std::istream &ISTREAM, AASequence &AA_SEQUENCE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile_handler.h</td>
        <td>BlastProfileHandler</td>
        <td>ReadProfilesForConstAASequence( const AASequence &SEQUENCE, const std::string &PREFIX, const std::string &EXTENSION = Ó )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile_handler.h</td>
        <td>BlastProfileHandler</td>
        <td>ReadProfilesForConstAASequence( const AASequence &SEQUENCE, storage::Vector< BlastProfile> &PROFILES, std::istream &ISTREAM )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile_handler.h</td>
        <td>BlastProfileHandler</td>
        <td>TryReadProfileForProteinModel( assemble::ProteinModel &PROTEIN_MODEL, const std::string &PREFIX, const std::string &EXTENSION = Ó )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile_handler.h</td>
        <td>BlastProfileHandler</td>
        <td>WriteProfileForAA( std::ostream &OSTREAM, const AABase &AMINO_ACID)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_blast_profile_handler.h</td>
        <td>BlastProfileHandler</td>
        <td>WriteProfileForAASequence( std::ostream &OSTREAM, const AASequence &AA_SEQUENCE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_blast_profile_handler.h</td>
        <td>BlastProfileHandler</td>
        <td>WriteProfileForProteinModel( const assemble::ProteinModel &PROTEIN_MODEL, const std::string &PREFIX, const std::string &PATH = Ó )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>CalculateAngleDifference( const ChiAngle &CHI_ANGLE, const math::Angle::Unit &ANGLE_UNIT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>ChiAngle( const Chi &CHI)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>ChiAngle( const Chi &CHI, const double ANGLE, const math::Angle::Unit &UNIT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>ChiAngle()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>GetAngle( const math::Angle::Unit &ANGLE_UNIT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>GetChi() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>GetChiName( const Chi &CHI_ANGLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>GetCircle( const math::Angle::Unit &UNIT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>GetMaxAngle( const math::Angle::Unit &UNIT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>ReadSimple( std::istream &ISTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_chi_angle.h</td>
        <td>ChiAngle</td>
        <td>WriteSimple( const math::Angle::Unit &ANGLE_UNIT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_dssp.h</td>
        <td>Bridge</td>
        <td>operator <( const Bridge &BRIDGE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_dssp.h</td>
        <td>BridgePartner</td>
        <td>BridgePartner( const util::SiPtr< const AABase> &PARTNER, const size_t LADDER, const bool PARALLEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_dssp.h</td>
        <td>BridgePartner</td>
        <td>BridgePartner()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_dssp.h</td>
        <td>DSSP</td>
        <td>DSSP( const double MAX_HYDROGEN_BOND_ENERGY = GetDefaultHBondMaxEnergy())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_dssp.h</td>
        <td>DSSP</td>
        <td>GetDefaultHBondMaxEnergy()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_dssp.h</td>
        <td>DSSP</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_dssp.h</td>
        <td>DSSP</td>
        <td>GetStatistics( size_t &NR_OF_RESIDUES, size_t &NR_OF_CHAINS, size_t &NR_OF_SS_BRIDGES, size_t &NR_OF_INTRA_CHAIN_SS_BRIDGES, size_t &NR_OF_HYDROGEN_BONDS, size_t NR_OF_HYDROGEN_BONDS_PER_DISTANCE[ s_HistogramSize], size_t NR_RES_PER_ALPHA_HELIX_HISTOGRAM[ s_HistogramSize] ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_dssp.h</td>
        <td>DSSP</td>
        <td>Reset() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_dssp.h</td>
        <td>DSSP</td>
        <td>SetPDBSSPred( assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_dssp.h</td>
        <td>DSSP</td>
        <td>WriteToFile( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_dssp.h</td>
        <td>DSSP</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_environment_type_data.h</td>
        <td>EnvironmentTypeData</td>
        <td>EnvironmentTypeData( const std::string &TWO_LETTER_CODE, const std::string &REDUCED_TYPE_NAME, const size_t REDUCED_INDEX, const bool IS_GAP, const double DEFAULT_THICKNESS )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_environment_type_data.h</td>
        <td>EnvironmentTypeData</td>
        <td>EnvironmentTypeData()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_environment_type_data.h</td>
        <td>EnvironmentTypeData</td>
        <td>GetDefaultThickness() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_environment_type_data.h</td>
        <td>EnvironmentTypeData</td>
        <td>GetReducedIndex() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_environment_type_data.h</td>
        <td>EnvironmentTypeData</td>
        <td>GetReducedType() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_environment_type_data.h</td>
        <td>EnvironmentTypeData</td>
        <td>GetReducedTypeString() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_environment_type_data.h</td>
        <td>EnvironmentTypeData</td>
        <td>GetTwoLetterCode() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_environment_type_data.h</td>
        <td>EnvironmentTypeData</td>
        <td>IsGap() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_environment_types.h</td>
        <td>EnvironmentTypes</td>
        <td>EnvironmentTypeFromTwoLetterCode( const std::string &TWO_LETTER_CODE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_environment_types.h</td>
        <td>EnvironmentTypes</td>
        <td>GetNumberReducedTypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_environment_types.h</td>
        <td>EnvironmentTypes</td>
        <td>GetReducedTypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_environment_types.h</td>
        <td></td>
        <td>GetEnvironmentTypes()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>Calculate( AASequence &SEQUENCE, const ExposureType &EXPOSURE_TYPE = e_ProtomericContactNumber)
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>Calculate( assemble::ProteinModel &MODEL, const ExposureType &EXPOSURE_TYPE = e_ProtomericContactNumber )
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>Calculate( assemble::ProteinModelWithCache &MODEL, const ExposureType &EXPOSURE_TYPE = e_ProtomericContactNumber )
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>ExposurePrediction()
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>GetFileExtension( const ExposureType &EXPOSURE_TYPE)
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>GetModelPath( const ExposureType &EXPOSURE_TYPE)
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>ReadPredictions( assemble::ProteinModel &PROTEIN_MODEL, const std::string &PREFIX, const std::string &PATH, const ExposureType &EXPOSURE_TYPE = e_ProtomericContactNumber )
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>ReadPredictions( std::istream &ISTREAM, AASequence &SEQUENCE)
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>ReadPredictions( std::istream &ISTREAM, assemble::ProteinModel &PROTEIN_MODEL)
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_exposure_prediction.h</td>
        <td>ExposurePrediction</td>
        <td>WritePredictions( std::ostream &OSTREAM, const AASequence &SEQUENCE)
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>BioTransformationMatricesFromPDBTMXML( std::istream &ISTREAM, const std::string &CHAIN_IDS)
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>CalculateSolvationEnergy( const linal::Vector3D &COORDINATES, const linal::Vector3D &TFE) const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>DetermineEnvironmentType( const linal::Vector3D &COORDINATES) const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>DetermineEnvironmentTypeAndWeight( const linal::Vector3D &COORDINATES) const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetCenter() const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetCommandLineMembrane()
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetDestructorSignal() const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetFlagMembrane()
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetLimit( const EnvironmentType &ENVIRONMENT) const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetLimits() const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetNormal() const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetOrientation() const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetParameterCoreThickness()
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetParameterGapThickness()
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetParameterTransitionThickness()
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetThickness( const EnvironmentType &ENVIRONMENT) const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetThicknesses() const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>GetUndefinedMembrane()
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>IsDefined() const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>Membrane( const double THICKNESS_CORE, const double THICKNESS_TRANSITION, const double THICKNESS_GAP, const linal::Vector3D &NORMAL = linal::Vector3D( 0.0, 0.0, 1.0) )
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>Membrane( const storage::Vector< double> &THICKNESSES, const linal::Vector3D &NORMAL = linal::Vector3D( 0.0, 0.0, 1.0), const linal::Vector3D &CENTER = linal::Vector3D() )
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>Membrane()
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>MembraneAndTransformationFromPDBTMXML( std::istream &ISTREAM, const double THICKNESS_TRANSITION, const double THICKNESS_GAP )
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_membrane.h</td>
        <td>Membrane</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>FromString( const std::string &STR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>GetAAs() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>GetChainIDs() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>GetLabel( const bool &WITH_DATA = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>GetMutantType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>GetNativeType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>GetResidueNumber() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>Mutation( const int RESNUM, const AAType &NATIVE, const AAType &MUTANT, const std::string &CHAIN_IDS = std::string())
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>Mutation()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>SetAA( const AABase &BASE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>ToString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>TryRead( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>operator <( const Mutation &POINT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_mutation.h</td>
        <td>Mutation</td>
        <td>operator ==( const Mutation &POINT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_charge.h</td>
        <td>ProteinCharge</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_charge.h</td>
        <td>ProteinCharge</td>
        <td>ProteinCharge( const AASequence &SEQUENCE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_charge.h</td>
        <td>ProteinCharge</td>
        <td>ProteinCharge( const storage::Map< AAType, size_t> &AA_COUNT, const AAType &N_TERM_AA, const AAType &C_TERM_AA )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_charge.h</td>
        <td>ProteinCharge</td>
        <td>ProteinCharge()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_charge.h</td>
        <td>ProteinCharge</td>
        <td>SetPKProperty( const AATypeData::PropertyType &PROPERTY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_charge.h</td>
        <td>ProteinCharge</td>
        <td>operator ()( const double &PH) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>GetIterator() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>GetIteratorNonConst()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>GetMutant( const Mutation &MUTATION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>GetNativeType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>ProteinMutationSet( const ProteinMutationSet &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>ProteinMutationSet( const assemble::ProteinModel &MODEL, const bool &REQUIRE_COORDINATES, const storage::Vector< Mutation> &MUTATIONS = storage::Vector< Mutation>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>ProteinMutationSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>ResetCache() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_mutation_set.h</td>
        <td>ProteinMutationSet</td>
        <td>operator =( const ProteinMutationSet &PROTEIN_MODEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_params.h</td>
        <td>ProteinParams</td>
        <td>CalcualteExtinctionCoefficient( const storage::Map< AAType, size_t> &AA_COUNT, storage::Table< double> &RESULT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_params.h</td>
        <td>ProteinParams</td>
        <td>CalcualteMolecularWeight( const storage::Map< AAType, size_t> &AA_COUNT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_params.h</td>
        <td>ProteinParams</td>
        <td>CalculatePI( const storage::Map< AAType, size_t> &AA_COUNT, const AAType &N_TERM_AATYPE, const AAType &C_TERM_AATYPE, const AATypeData::PropertyType &PK_PROPERTY )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_params.h</td>
        <td>ProteinParams</td>
        <td>CountAAs( const AASequence &SEQUENCE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_protein_params.h</td>
        <td>ProteinParams</td>
        <td>ProteinParams()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_protein_params.h</td>
        <td>ProteinParams</td>
        <td>operator ()( const AASequence &SEQUENCE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>GetDefaultInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>GetHistogramFilename() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>GetRandomPhiPsi( const AAType &AA_TYPE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>GetRandomPhiPsi( const AAType &AA_TYPE, const SSType SS_TYPE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>GetRandomPhiPsi( const AAType &AA_TYPE, const SSType SS_TYPE, const EnvironmentType &ENV_TYPE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>Ramachandran( const std::string &SS_TYPE_HISTOGRAM_FILENAME)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>Ramachandran()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ramachandran.h</td>
        <td>Ramachandran</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_rotamer.h</td>
        <td>ChiAngleLessThan</td>
        <td>operator ()( const ChiAngle &CHI_ANGLE_A, const ChiAngle &CHI_ANGLE_B) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>Begin() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>ChiMatchDependent( const Rotamer &ROTAMER, const math::Angle::Unit &ANGLE_UNIT, const double TOLERANCE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>End() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>GetAngle( const ChiAngle::Chi &CHI, const math::Angle::Unit &ANGLE_UNIT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>GetChis() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>GetSize() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>Insert( const ChiAngle &CHI_ANGLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>IsEmpty() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>ReadSimple( std::istream &ISTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>Rotamer()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_rotamer.h</td>
        <td>Rotamer</td>
        <td>WriteSimple( const math::Angle::Unit &ANGLE_UNIT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_rotamer_library.h</td>
        <td>RotamerLibrary</td>
        <td>CreateRotamerLibrary( const std::string &LIBRARY_FILE_NAME)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_rotamer_library.h</td>
        <td>RotamerLibrary</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_rotamer_library.h</td>
        <td>RotamerLibrary</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>AllocateMemory( const size_t &SIZE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>Begin()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>Begin() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>End()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>End() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>GetData() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>GetFlagInputFormat()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>PushBack( const SasaPoint &DATAPOINT_OBJECT)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>ReadFromDataFile( std::istream &ISTREAM)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>SasaData( const storage::Vector< SasaPoint> &INIT_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>SasaData()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_sasa_data.h</td>
        <td>SasaData</td>
        <td>WriteToDataFile( std::ostream &OSTREAM) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_sasa_point.h</td>
        <td>SasaPoint</td>
        <td>GetAtomNumber() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_sasa_point.h</td>
        <td>SasaPoint</td>
        <td>GetSolventAccessibleSurface() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_sasa_point.h</td>
        <td>SasaPoint</td>
        <td>GetSolventExcludedSurface() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_sasa_point.h</td>
        <td>SasaPoint</td>
        <td>SasaPoint( const size_t ATOMNUM, const double SES, const double SAS)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_sasa_point.h</td>
        <td>SasaPoint</td>
        <td>SasaPoint()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_sasa_point.h</td>
        <td>SasaPoint</td>
        <td>operator ==( const SasaPoint &POINT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetAnglePerTurn() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetBackbonePhiRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetBackbonePsiRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetContactWindowLength() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetContactWindowRadius() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetFragmentLength() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetIdealPhi() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetIdealPsi() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetOneLetterCode() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetRadialExtent() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetRiseInZPerResidue() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>GetTransformationMatrixForResidues() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>IsStructured() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>SSTypeData( const char ONE_LETTER_CODE, const bool IS_STRUCTURED, const double RADIAL_EXTENT, const double ANGLE_PER_TURN, const double RISE_IN_Z_PER_RESIDUE, const double IDEAL_PHI, const double IDEAL_PSI, const size_t FRAGMENT_LENGTH, const size_t CONTACT_WINDOW_RADIUS, const linal::Vector3D &THREE_STATE_PREDICTION, const math::Range< double> &BACKBONE_PHI_RANGE, const math::Range< double> &BACKBONE_PSI_RANGE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_type_data.h</td>
        <td>SSTypeData</td>
        <td>SSTypeData()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_types.h</td>
        <td>SSTypes</td>
        <td>AreSimilar( const SSType &SS_TYPE_LHS, const SSType &SS_TYPE_RHS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_types.h</td>
        <td>SSTypes</td>
        <td>GetHelixTypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_types.h</td>
        <td>SSTypes</td>
        <td>GetReducedTypes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_types.h</td>
        <td>SSTypes</td>
        <td>PDBHelixClassFromSSType( const SSType &SSTYPE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_types.h</td>
        <td>SSTypes</td>
        <td>SSTypeFromOneLetterCode( const char ONE_LETTER_CODE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_types.h</td>
        <td>SSTypes</td>
        <td>SSTypeFromPDBHelixClass( const size_t HELIX_CLASS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_biol_ss_types.h</td>
        <td>SSTypes</td>
        <td>SSTypeFromPhiPsi( const double PHI, const double PSI) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_biol_ss_types.h</td>
        <td></td>
        <td>GetSSTypes()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_bzip2.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_bzip2_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>Close()
</td>
        <td>alexanns, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_bzip2_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>GetDefaultFileExtension() const
</td>
        <td>alexanns, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_bzip2_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>GetStreamBufferClass() const
</td>
        <td>alexanns, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_bzip2_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>IsOpen()
</td>
        <td>alexanns, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_bzip2_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>IsValidOpenMode( const std::ios_base::openmode OPEN_MODE)
</td>
        <td>alexanns, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_bzip2_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>Open( const char *NAME, const std::ios_base::openmode OPEN_MODE)
</td>
        <td>alexanns, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_bzip2_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>StreamBuffer( const StreamBuffer &BUFFER)
</td>
        <td>alexanns, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_bzip2_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>StreamBuffer()
</td>
        <td>alexanns, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_bzip2_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>seekoff( std::streamoff OFF, std::ios_base::seekdir WAY, std::ios_base::openmode WHICH = std::ios_base::in</td>
        <td>std::ios_base::out )
</td>
        <td>alexanns, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>AAFragmentComplete( const biol::AASequence &SEQUENCE, const bool &ALLOW_UNDEFINED_POSITIONS = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>AAFragmentComplete( const util::SiPtrVector< const biol::AABase> &AA_SEQUENCE, const bool &ALLOW_UNDEFINED_POSITIONS = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>AAFragmentComplete()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>GetAtomsResidue( const size_t &ATOM_ID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>GetAtomsResidueIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>GetAtomsType( const size_t &ATOM_ID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>GetNumberValences() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>GetResidueSequence() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>GetResiduesAsFragments( const bool &CONSIDER_BACK_BONE, const bool &CONSIDER_SIDE_CHAIN) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>ReconstructProteinModel( const assemble::ProteinModel &MODEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_aa_fragment_complete.h</td>
        <td>AAFragmentComplete</td>
        <td>RemoveAtomsUndefinedPos()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_clash_score.h</td>
        <td>AtomClashScore</td>
        <td>AtomClashScore( const bool &CONSIDER_H = false, const bool &DISPLAY = false)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_clash_score.h</td>
        <td>AtomClashScore</td>
        <td>GetClashingPairs( const ConformationInterface &MOLECULE ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_clash_score.h</td>
        <td>AtomClashScore</td>
        <td>GetDefaultScheme()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_clash_score.h</td>
        <td>AtomClashScore</td>
        <td>GetMinimumNonClashingDistance( const size_t &A, const size_t &B) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_clash_score.h</td>
        <td>AtomClashScore</td>
        <td>SetDisplay( const bool &DISP) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_clash_score.h</td>
        <td>AtomClashScore</td>
        <td>Setup( const bool &CONSIDER_H)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_clash_score.h</td>
        <td>AtomClashScore</td>
        <td>UpdateClashingPairs( const AtomVector< AtomComplete> &MOLECULE, storage::Vector< storage::Triplet< size_t, size_t, double> > &CLASHING_PAIRS ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_clash_score.h</td>
        <td>AtomClashScore</td>
        <td>operator ()( const ConformationInterface &MOLECULE ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_clash_score.h</td>
        <td>AtomClashScore</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_complete.h</td>
        <td>AtomComplete</td>
        <td>GetAtomType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_complete.h</td>
        <td>AtomComplete</td>
        <td>GetBondTypeTo( const AtomConformationalInterface &ATOM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_complete.h</td>
        <td>AtomComplete</td>
        <td>GetBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_complete.h</td>
        <td>AtomComplete</td>
        <td>GetChirality() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_complete.h</td>
        <td>AtomComplete</td>
        <td>GetPosition() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_complete.h</td>
        <td>AtomComplete</td>
        <td>SetAtomType( const AtomType &ATOM_TYPE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_complete.h</td>
        <td>AtomComplete</td>
        <td>SetCharge( const short &CHARGE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_complete.h</td>
        <td>AtomComplete</td>
        <td>SetChirality( const Chirality &CHIRALITY)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_complete.h</td>
        <td>AtomComplete</td>
        <td>SetPosition( const linal::Vector3D &POSITION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_configurational_interface.h</td>
        <td>AtomConfigurationalInterface</td>
        <td>GetAtomInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_configurational_interface.h</td>
        <td>AtomConfigurationalInterface</td>
        <td>GetCharge() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_configurational_interface.h</td>
        <td>AtomConfigurationalInterface</td>
        <td>GetElementType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_configurational_interface.h</td>
        <td>AtomConfigurationalInterface</td>
        <td>GetNumberElectronsInValenceBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_configurational_interface.h</td>
        <td>AtomConfigurationalInterface</td>
        <td>GetNumberValenceBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_configurational_interface.h</td>
        <td>AtomConfigurationalInterface</td>
        <td>GetValenceBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_configurational_shared.h</td>
        <td>AtomConfigurationalShared</td>
        <td>GetAtomType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_configurational_shared.h</td>
        <td>AtomConfigurationalShared</td>
        <td>GetBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_configurational_shared.h</td>
        <td>AtomConfigurationalShared</td>
        <td>GetChirality() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_configurational_shared.h</td>
        <td>AtomConfigurationalShared</td>
        <td>GetConstitution() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>CountNonValenceBondsWithProperty( const ConfigurationalBondTypeData::Data &DATA, const size_t &VALUE ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>FindBondTo( const AtomConformationalInterface &ATOM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>GetAtomInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>GetCenter() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>GetCharge() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>GetElementType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>GetNumberCovalentlyBoundHydrogens() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>GetNumberElectronsInValenceBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>GetNumberValenceBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>GetNumberofValenceBondsWithOrder( const size_t BOND_ORDER) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_conformational_interface.h</td>
        <td>AtomConformationalInterface</td>
        <td>GetValenceBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_conformational_shared.h</td>
        <td>AtomConformationalShared</td>
        <td>GetAtomType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_conformational_shared.h</td>
        <td>AtomConformationalShared</td>
        <td>GetBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_conformational_shared.h</td>
        <td>AtomConformationalShared</td>
        <td>GetChirality() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_conformational_shared.h</td>
        <td>AtomConformationalShared</td>
        <td>GetConfiguration() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_conformational_shared.h</td>
        <td>AtomConformationalShared</td>
        <td>GetPosition() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_constitutional_interface.h</td>
        <td>AtomConstitutionalInterface</td>
        <td>GetAtomInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_constitutional_interface.h</td>
        <td>AtomConstitutionalInterface</td>
        <td>GetCharge() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_constitutional_interface.h</td>
        <td>AtomConstitutionalInterface</td>
        <td>GetElementType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_constitutional_interface.h</td>
        <td>AtomConstitutionalInterface</td>
        <td>GetNumberElectronsInValenceBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_constitutional_interface.h</td>
        <td>AtomConstitutionalInterface</td>
        <td>GetNumberValenceBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_constitutional_interface.h</td>
        <td>AtomConstitutionalInterface</td>
        <td>GetValenceBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_constitutional_shared.h</td>
        <td>AtomConstitutionalShared</td>
        <td>GetAtomType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_constitutional_shared.h</td>
        <td>AtomConstitutionalShared</td>
        <td>GetBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment.h</td>
        <td>AtomEnvironment</td>
        <td>AtomEnvironment( const AtomConformationalInterface &ATOM_OF_INTEREST, const size_t NUMBER_SPHERES )
</td>
        <td>mueller, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_environment.h</td>
        <td>AtomEnvironment</td>
        <td>AtomEnvironment()
</td>
        <td>mueller, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment.h</td>
        <td>AtomEnvironment</td>
        <td>GetEnvironmentAtoms() const
</td>
        <td>mueller, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_environment.h</td>
        <td>AtomEnvironment</td>
        <td>MakeAtomEnvironmentStringFour( const AtomConformationalInterface &A)
</td>
        <td>mueller, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment.h</td>
        <td>AtomEnvironment</td>
        <td>MakeAtomEnvironmentStringThree( const AtomConformationalInterface &A)
</td>
        <td>mueller, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_environment.h</td>
        <td>AtomEnvironment</td>
        <td>MakeAtomEnvironmentStringTwo( const AtomConformationalInterface &A)
</td>
        <td>mueller, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>AtomEnvironmentBender( const Atom_type &ATOM_TYPE)
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>AtomEnvironmentBender( const Atom_type &ATOM_TYPE, const std::string &STRING)
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>AtomEnvironmentBender( size_t ATOM_INDEX, const Atom_type &ATOM_TYPE, const ConformationInterface &FRAGMENT)
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>AtomEnvironmentBender()
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>GetAtomEnvironment() const
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>GetAtomOfInterestIndex() const
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>GetAtomType() const
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>GetAtomTypeInfo( const Atom_type &ATOM_TYPE)
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>GetAtomTypeName( const Atom_type &ATOM_TYPE)
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>UnHash() const
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>operator !=( const AtomEnvironmentBender &ATOM) const
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>operator <( const AtomEnvironmentBender &ATOM) const
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_environment_bender.h</td>
        <td>AtomEnvironmentBender</td>
        <td>operator ==( const AtomEnvironmentBender &ATOM) const
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_one_four_interaction_score.h</td>
        <td>AtomOneFourInteractionScore</td>
        <td>AtomOneFourInteractionScore( double LENGTH_WEIGHT = 1.0, double INTERACTION_WEIGHT = 1.0)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_one_four_interaction_score.h</td>
        <td>AtomOneFourInteractionScore</td>
        <td>EstimateMinimumDistance( const AtomConformationalInterface &A, const AtomConformationalInterface &B, const int &BOND_DISTANCE, const storage::Vector< size_t> &RIGID_SUBSTRUCTURES_A, const storage::Vector< size_t> &RIGID_SUBSTRUCTURES_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_one_four_interaction_score.h</td>
        <td>AtomOneFourInteractionScore</td>
        <td>GetDefaultScheme()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_one_four_interaction_score.h</td>
        <td>AtomOneFourInteractionScore</td>
        <td>InitializeInteractionMap()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_one_four_interaction_score.h</td>
        <td>AtomOneFourInteractionScore</td>
        <td>operator ()( const ConformationInterface &MOLECULE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_one_four_interaction_score.h</td>
        <td>AtomOneFourInteractionScore</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>AtomTypeData( const ElementType &ELEMENT_TYPE, const HybridOrbitalType &HYBRIDIZATION, const size_t &HYBRID_ORBITALS_IN_SIGMA_BONDS, const size_t &HYBRID_ORBITALS_NONBINDING, const storage::Set< AtomicOrbitalTypesEnum> &PI_ORBITALS_IN_BONDS, const storage::Set< AtomicOrbitalTypesEnum> &ATOMIC_ORBITALS_NONBINDING, const double &SIGMA_VALENCE_STATE_IONIZATION_POTENTIAL, const double &SIGMA_VALENCE_STATE_ELECTRON_AFFINITY, const double &PI_VALENCE_STATE_IONIZATION_POTENTIAL, const double &PI_VALENCE_STATE_ELECTRON_AFFINITY, const double &LONE_PAIR_IONIZATION_POTENTIAL, const double &LONE_PAIR_ELECTRON_AFFINITY, const double &ATOMIC_POLARIZABILITY )
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>AtomTypeData( const ElementType &ELEMENT_TYPE, const short &CHARGE )
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>AtomTypeData()
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetAtomTypeProperty( const AtomTypeData::Properties &PROPERTY) const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetBaseAtomType() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetElementType() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetFormalCharge() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetFormsOnlyLinearBonds() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetHybridOrbitalType() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetLonePairENFromChargeFunction() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetLonePairENFromSigmaCharge( const double &CHARGE) const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetMaxEContributionToPiSystem() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberBonds() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberElectronsInBonds() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberElectronsInPOrbitals() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberHybridBonds() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberHybridLonePairs() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberHybridOrbitals() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberPiOrbitals() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberSigmaOrbitals() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberUnhybridizedLonePairs() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetNumberUnhybridizedSigmaOrbitals() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetOrbitalENegPos() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetPiENFromCharge( const double &CHARGE) const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetPiENFromChargeFunction() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetPiElectronContributionType() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetPropertyName( const Properties &PROPERTY)
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetSigmaENFromCharge( const double &CHARGE) const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetSigmaENFromChargeFunction() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetStabilityMetric() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetTwoLetterCode() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>GetValenceElectronsSP() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>IsConjugated() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_type_data.h</td>
        <td>AtomTypeData</td>
        <td>IsGasteigerAtomType() const
</td>
        <td>mueller, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetAtomType( const ElementType &ELEMENT_TYPE, const short &CHARGE)
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetAtomType( const std::string &ATOM_TYPE)
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_types.h</td>
        <td>AtomTypes</td>
        <td>GetNumberGasteigerTypes()
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_types.h</td>
        <td></td>
        <td>GetAtomTypes()
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vdw_score.h</td>
        <td>AtomVdwScore</td>
        <td>AtomVdwScore( const bool &CLASH_ONLY = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vdw_score.h</td>
        <td>AtomVdwScore</td>
        <td>SetDisplay( const bool &DISP) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vdw_score.h</td>
        <td>AtomVdwScore</td>
        <td>operator ()( const ConformationInterface &MOLECULE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vdw_score.h</td>
        <td>AtomVdwScore</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>AddAtomsWithConnectivity( const AtomVector< t_Atom> &NEW_ATOMS, const storage::Vector< sdf::BondInfo> &CONNECTING_BONDS )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>AtomVector( const AtomVector< t_Atom> &BASE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>AtomVector( const storage::Vector< sdf::AtomInfo> &ATOM_INFO, const storage::Vector< sdf::BondInfo> &BONDS )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>AtomVector()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>Begin()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>Begin() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>End()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>End() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>First()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>First() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>GetAdjacencyList( const typename t_Atom::t_BondData &BOND_SCHEME) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>GetAtomIndex( const typename t_Atom::t_Interface &ATOM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>GetAtomInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>GetBondInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>GetNumberBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>GetSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>IsEmpty() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>Last()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>Last() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>LinkToLayer( iterate::Generic< const t_OtherAtomType> LAYER)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>Reorder( const storage::Vector< size_t> &NEW_ORDER)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>operator ()( const size_t POS)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>operator ()( const typename t_Atom::t_Interface &ATOM)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>operator ()( const typename t_Atom::t_Interface &ATOM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>operator =( const AtomVector< t_Atom> &VALUE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>operator []( const size_t POS)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_vector.h</td>
        <td>AtomVector</td>
        <td>operator []( const size_t POS) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_with_position_interface.h</td>
        <td>AtomWithPositionInterface</td>
        <td>GetCenter() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atom_with_position_interface.h</td>
        <td>AtomWithPositionInterface</td>
        <td>GetCharge() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atom_with_position_interface.h</td>
        <td>AtomWithPositionInterface</td>
        <td>GetElementType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atomic_orbital_types.h</td>
        <td></td>
        <td>GetAtomicOrbitalTypeString( const AtomicOrbitalTypes &ENUM)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atoms_complete_standardizer.h</td>
        <td>AtomsCompleteStandardizer</td>
        <td>AtomsCompleteStandardizer( AtomVector< AtomComplete> &ATOMS, const std::string &ID, const bool &FORCE_RECALCULATION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_atoms_complete_standardizer.h</td>
        <td>AtomsCompleteStandardizer</td>
        <td>SetConjugationOfBondTypes( AtomVector< AtomComplete> &ATOMS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_atoms_complete_standardizer.h</td>
        <td>AtomsCompleteStandardizer</td>
        <td>TryNeutralize( AtomVector< AtomComplete> &ATOMS, const sdf::NeutralizationPref &PREF)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>BondAngleAssignment( const typename RotamerLibraryInterface::t_BondAnglesWithCounts &BOND_ANGLE_COUNTS, const typename RotamerLibraryInterface::t_BondAngleMapKey &BOND_ANGLE_MAP_KEY, const ConformationInterface &MOLECULE, const size_t &CENTRAL_ATOM_INDICES, const bool &CONSIDER_ALTERNATE_CHIRALITIES = false, const ConformationGraphConverter::AtomComparisonType &ATOM_LEVEL = ConformationGraphConverter::e_AtomType )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>BondAngleAssignment()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>CanFlip() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetAttachedAtomIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetAttachedAtomIndicesInverse() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetBestFreeEnergy() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetBondAngleCounts() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetBondAngleFreeEnergies() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetCanUseBondLengths() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetCentralAtomIndex() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetExpectedFreeEnergy() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetFreeEnergy( const FragmentComplete &FRAGMENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetNumberRingBonds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetPseudocount()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetStandardizedCoordinateMatrix( const ConformationInterface &MOLECULE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>GetStandardizedCoordinateMatrix( const linal::Vector3D &ATOM_POS, const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const size_t &FULL_N_BONDS, const size_t &N_RING_BONDS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>HasAnAmideBond() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_angle_assignment.h</td>
        <td>BondAngleAssignment</td>
        <td>TransferStandardizedCoordinateMatrixForRingSystem( const storage::Vector< sdf::AtomInfo> &MOLECULE, linal::Matrix< double> &STANDARDIZED_COORDS ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_configurational.h</td>
        <td>BondConfigurational</td>
        <td>BondConfigurational( const AtomConfigurationalInterface &ATOM_CONFIGURATIONAL, const ConfigurationalBondType &BASE_BOND )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_configurational.h</td>
        <td>BondConfigurational</td>
        <td>BondConfigurational()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_configurational.h</td>
        <td>BondConfigurational</td>
        <td>GetBondType() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_configurational.h</td>
        <td>BondConfigurational</td>
        <td>GetTargetAtom() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_conformational.h</td>
        <td>BondConformational</td>
        <td>BondConformational( const AtomConformationalInterface &ATOM_CONFORMATIONAL, const ConfigurationalBondType &BASE_BOND )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_conformational.h</td>
        <td>BondConformational</td>
        <td>BondConformational()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_conformational.h</td>
        <td>BondConformational</td>
        <td>GetBondType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_conformational.h</td>
        <td>BondConformational</td>
        <td>GetTargetAtom() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_conformational.h</td>
        <td>BondConformational</td>
        <td>IsDefined() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_constitutional.h</td>
        <td>BondConstitutional</td>
        <td>BondConstitutional( const AtomConstitutionalInterface &ATOM_CONSTITUTIONAL, const ConfigurationalBondType &BASE_BOND )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_constitutional.h</td>
        <td>BondConstitutional</td>
        <td>BondConstitutional( const AtomConstitutionalInterface &ATOM_CONSTITUTIONAL, const ConstitutionalBondType &BASE_BOND )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_constitutional.h</td>
        <td>BondConstitutional</td>
        <td>BondConstitutional()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_constitutional.h</td>
        <td>BondConstitutional</td>
        <td>GetBondType() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_constitutional.h</td>
        <td>BondConstitutional</td>
        <td>GetTargetAtom() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_dihedral_angles.h</td>
        <td>BondDihedralAngles</td>
        <td>GetAveStdDihedralDeviation( const AtomType &ATOM_TYPE_A, const ConfigurationalBondType &BOND_TYPE_AB, const AtomType &ATOM_TYPE_B, const ConfigurationalBondType &BOND_TYPE_BC, const AtomType &ATOM_TYPE_C, const ConfigurationalBondType &BOND_TYPE_CD, const AtomType &ATOM_TYPE_D )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_dihedral_angles.h</td>
        <td>BondDihedralAngles</td>
        <td>GetEstimatedStdForDihedralBondAngleBin( const AtomConformationalInterface &ATOM_B, const AtomConformationalInterface &ATOM_C )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_dihedral_steric_weight.h</td>
        <td>BondDihedralStericWeight</td>
        <td>CalculateBondWeights( const FragmentComplete &CONFORMATION, const size_t N_SPHERES, const double DEPLETION_FACTOR )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_dihedral_steric_weight.h</td>
        <td>BondDihedralStericWeight</td>
        <td>CalculateDualSidedWeight( const FragmentComplete &CONFORMATION, const size_t N_SPHERES )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_isometry.h</td>
        <td></td>
        <td>GetIsometryName( const BondIsometry &ISOMETRY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_isometry_handler.h</td>
        <td>BondIsometryHandler</td>
        <td>AddIsometryInformation( AtomVector< AtomComplete> &FRAGMENT, const bool &FORCE_RECALCULATION = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_lengths.h</td>
        <td>BondLengths</td>
        <td>ComputeVdwRadii( storage::Map< std::string, storage::Vector< double> > &RADII, const storage::Map< std::string, double> &MIN_VALUES )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_lengths.h</td>
        <td>BondLengths</td>
        <td>GetAverageCovalentRadius( const AtomConfigurationalInterface &ATOM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_lengths.h</td>
        <td>BondLengths</td>
        <td>GetAverageCovalentRadius( const AtomConformationalInterface &ATOM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_lengths.h</td>
        <td>BondLengths</td>
        <td>GetAverageCovalentRadius( const AtomConstitutionalInterface &ATOM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_lengths.h</td>
        <td>BondLengths</td>
        <td>GetBondLength( const AtomType &ATOM_TYPE_A, const size_t &BOND_ORDER_OR_AROMATIC, const AtomType &ATOM_TYPE_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_bond_lengths.h</td>
        <td>BondLengths</td>
        <td>GetCovalentRadius( const AtomType &ATOM_TYPE, const size_t &BOND_ORDER_OR_AROMATIC)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_bond_lengths.h</td>
        <td>BondLengths</td>
        <td>GetCovalentRadius( const ElementType &ELEMENT_TYPE, const size_t &NUMBER_BONDS, const size_t &NUMBER_ELECTRONS_IN_BONDS, const size_t &BOND_ORDER_OR_AROMATIC )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_chirality.h</td>
        <td></td>
        <td>GetChiralityName( const Chirality &CHIRALITY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_collector_valence.h</td>
        <td>CollectorValence</td>
        <td>Collect( const FragmentComplete &FRAGMENT) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_collector_valence.h</td>
        <td>CollectorValence</td>
        <td>GetSerializer() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_graph_converter.h</td>
        <td>ConfigurationGraphConverter</td>
        <td>ConfigurationGraphConverter( const AtomComparisonType &ATOM_COMPARISON_TYPE, const ConfigurationalBondTypeData::Data &BOND_TYPE_INFO )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_graph_converter.h</td>
        <td>ConfigurationGraphConverter</td>
        <td>ConfigurationGraphConverter()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_graph_converter.h</td>
        <td>ConfigurationGraphConverter</td>
        <td>GetAtomComparisonType( const AtomComparisonType &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_graph_converter.h</td>
        <td>ConfigurationGraphConverter</td>
        <td>operator ()( const ConfigurationInterface &CONFIGURATION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_interface.h</td>
        <td>ConfigurationInterface</td>
        <td>GetAtomTypesString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_interface.h</td>
        <td>ConfigurationInterface</td>
        <td>GetBondTypesString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_interface.h</td>
        <td>ConfigurationInterface</td>
        <td>GetChiralityString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_interface.h</td>
        <td>ConfigurationInterface</td>
        <td>GetIterator() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_interface.h</td>
        <td>ConfigurationInterface</td>
        <td>GetNumberValences() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_interface.h</td>
        <td>ConfigurationInterface</td>
        <td>WriteMDL( std::ostream &OSTREAM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>Begin() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>ConfigurationSet( iterate::Generic< const ConfigurationInterface> MOLECULES)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>ConfigurationSet()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>End() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>Find( const ConfigurationInterface &FRAGMENT, util::SiPtr< storage::Vector< size_t> > ISOMORPHISM = util::SiPtr< storage::Vector< size_t> >() ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>GetConfigurations() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>GetConfigurationsMap() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>GetConstitutions() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>GetSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set.h</td>
        <td>ConfigurationSet</td>
        <td>Insert( const ConfigurationInterface &FRAGMENT, util::SiPtr< storage::Vector< size_t> > ISOMORPHISM = util::SiPtr< storage::Vector< size_t> >() )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>Begin() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>ConfigurationSetSameConstitution( const util::ShPtr< FragmentConstitutionShared> &CONSTITUTION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>ConfigurationSetSameConstitution()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>End() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>Find( const ConfigurationInterface &FRAGMENT, storage::Vector< size_t> &ISOMORPHISM ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>GetConfigurations() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>GetConstitution() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>GetSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>Insert( const ConfigurationInterface &FRAGMENT, const util::ShPtr< FragmentConstitutionShared> &CONSTITUTION, storage::Vector< size_t> &ISOMORPHISM )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>ConfigurationSetSameConstitution</td>
        <td>SetConstitution( const util::ShPtr< FragmentConstitutionShared> &CONSTITUTION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>Node</td>
        <td>CacheGraph()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configuration_set_same_constitution.h</td>
        <td>Node</td>
        <td>IsGraphCached() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>ConfigurationalBondTypeData( const ConstitutionalBondType &CONSTITUTIONAL_BOND_TYPE, const BondIsometry &ISOMETRY )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>ConfigurationalBondTypeData()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>GetBondData( const Data &DATA_TO_RETRIEVE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>GetConjugation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>GetConstitutionalBondType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>GetDataName( const Data &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>GetIsometry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>GetNumberOfElectrons() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>GetSDAltFileID() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>GetSDFileID() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>IsBondInRing() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>IsBondOrderKnown() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>WithConjugation( const ConstitutionalBondTypeData::Conjugation &CONJUGATION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>WithInRing() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>WithIsometry( const BondIsometry &ISOMETRY) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>WithOrder( const size_t &ORDER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>WithoutAromaticOrder() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_configurational_bond_type_data.h</td>
        <td>ConfigurationalBondTypeData</td>
        <td>WithoutIsometry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_configurational_bond_types.h</td>
        <td></td>
        <td>GetConfigurationalBondTypes()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_dihedral_bins.h</td>
        <td>ConformationComparisonByDihedralBins</td>
        <td>ConformationComparisonByDihedralBins( const double BIN_SIZE = double( 30.0))
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_dihedral_bins.h</td>
        <td>ConformationComparisonByDihedralBins</td>
        <td>DetermineDihedralKey( const double &ANGLE, bool ANGLE_IN_DEGREES = true, bool IS_WRAPPED_AROUND = true ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_dihedral_bins.h</td>
        <td>ConformationComparisonByDihedralBins</td>
        <td>DetermineDihedralKeys( const linal::Vector< double> &ANGLE_VECTOR, bool ANGLE_IN_DEGREES = true, bool IS_WRAPPED_AROUND = true ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_dihedral_bins.h</td>
        <td>ConformationComparisonByDihedralBins</td>
        <td>DetermineWrappedAroundAngle( const double &ANGLE, bool ANGLES_IN_RADIANS) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_dihedral_bins.h</td>
        <td>ConformationComparisonByDihedralBins</td>
        <td>DetermineWrappedAroundAngles( const linal::Vector< double> &ANGLE_VECTOR, bool ANGLES_IN_RADIANS = true ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_dihedral_bins.h</td>
        <td>ConformationComparisonByDihedralBins</td>
        <td>DihedralKeysString( const storage::Vector< int> &DIHEDRAL_KEYS ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_dihedral_bins.h</td>
        <td>ConformationComparisonByDihedralBins</td>
        <td>GetBinSize() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_dihedral_bins.h</td>
        <td>ConformationComparisonByDihedralBins</td>
        <td>KeyToAngle( size_t KEY_VALUE ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_dihedral_bins.h</td>
        <td>ConformationComparisonByDihedralBins</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_dihedrals.h</td>
        <td>ConformationComparisonByDihedrals</td>
        <td>ConformationComparisonByDihedrals( const Method &METHOD = e_Max)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_dihedrals.h</td>
        <td>ConformationComparisonByDihedrals</td>
        <td>GetMethodName( const Method &PROPERTY)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_dihedrals.h</td>
        <td>ConformationComparisonByDihedrals</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_fragments.h</td>
        <td>ConformationComparisonByFragments</td>
        <td>AddSplit( const FragmentSplitInterface &SPLIT)
</td>
        <td>geanesar, aguilaji</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_fragments.h</td>
        <td>ConformationComparisonByFragments</td>
        <td>ConformationComparisonByFragments( const bool &TANIMOTO)
</td>
        <td>geanesar, aguilaji</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_fragments.h</td>
        <td>ConformationComparisonByFragments</td>
        <td>GetSplits() const
</td>
        <td>geanesar, aguilaji</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_fragments.h</td>
        <td>ConformationComparisonByFragments</td>
        <td>GraphVectorFind( const graph::ConstGraph< size_t, size_t> &GRAPH, const storage::Vector< graph::ConstGraph< size_t, size_t> > &GRAPH_VECTOR ) const
</td>
        <td>geanesar, aguilaji</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_fragments.h</td>
        <td>ConformationComparisonByFragments</td>
        <td>MakeFragmentGraphs( const ConformationInterface &MOLECULE ) const
</td>
        <td>geanesar, aguilaji</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_fragments.h</td>
        <td>ConformationComparisonByFragments</td>
        <td>Prepare( const ConformationInterface &MOLECULE) const
</td>
        <td>geanesar, aguilaji</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_fragments.h</td>
        <td>ConformationComparisonByFragments</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>geanesar, aguilaji</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_property.h</td>
        <td>ConformationComparisonByProperty</td>
        <td>ConformationComparisonByProperty( const bool &TANIMOTO)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_property.h</td>
        <td>ConformationComparisonByProperty</td>
        <td>Prepare( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_property.h</td>
        <td>ConformationComparisonByProperty</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_real_space_rmsd.h</td>
        <td>ConformationComparisonByRealSpaceRmsd</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_rmsd.h</td>
        <td>ConformationComparisonByRmsd</td>
        <td>Prepare( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_rmsd.h</td>
        <td>ConformationComparisonByRmsd</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_substructure.h</td>
        <td>ConformationComparisonBySubstructure</td>
        <td>ConformationComparisonBySubstructure( const ConformationComparisonInterface &COMPARISON, const graph::CommonSubgraphIsomorphismBase::SolutionType &TYPE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_substructure.h</td>
        <td>ConformationComparisonBySubstructure</td>
        <td>ConformationComparisonBySubstructure( const bool &TANIMOTO, const graph::CommonSubgraphIsomorphismBase::SolutionType &TYPE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_substructure.h</td>
        <td>ConformationComparisonBySubstructure</td>
        <td>Prepare( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_substructure.h</td>
        <td>ConformationComparisonBySubstructure</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_symmetry_rmsd.h</td>
        <td>ConformationComparisonBySymmetryRmsd</td>
        <td>ConformationComparisonBySymmetryRmsd( const bool &SUPERIMPOSE = true, const size_t &ISO_LIMIT = 1000)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_symmetry_rmsd.h</td>
        <td>ConformationComparisonBySymmetryRmsd</td>
        <td>GetNumberIsomorphisms() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_by_symmetry_rmsd.h</td>
        <td>ConformationComparisonBySymmetryRmsd</td>
        <td>Prepare( const ConformationInterface &MOLECULE) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_by_symmetry_rmsd.h</td>
        <td>ConformationComparisonBySymmetryRmsd</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_interface.h</td>
        <td>ConformationComparisonInterface</td>
        <td>ConformationsAreComparable( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_interface.h</td>
        <td>ConformationComparisonInterface</td>
        <td>GetDisableStrictAtomBondTypeCheckingFlag()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_interface.h</td>
        <td>ConformationComparisonInterface</td>
        <td>GetIgnoreAtomAndBondTypesWhenDeterminingComparability()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_interface.h</td>
        <td>ConformationComparisonInterface</td>
        <td>Prepare( const ConformationInterface &ENSEMBLE) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_interface.h</td>
        <td>ConformationComparisonInterface</td>
        <td>PrepareEnsemble( const FragmentEnsemble &ENSEMBLE) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_multi_align.h</td>
        <td>ConformationComparisonMultiAlign</td>
        <td>AlignFullyFlex( const FragmentEnsemble &ENS_A, const FragmentEnsemble &ENS_B) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_multi_align.h</td>
        <td>ConformationComparisonMultiAlign</td>
        <td>AlignMolecularEnsemble( const FragmentEnsemble &ENSEMBLE_A, const FragmentEnsemble &ENSEMBLE_B ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_multi_align.h</td>
        <td>ConformationComparisonMultiAlign</td>
        <td>BondAlignInfEns( FragmentComplete &MOLECULE_A, const FragmentComplete &MOLECULE_B, const storage::Vector< storage::Triplet< size_t, size_t, float> > &INDICES ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_multi_align.h</td>
        <td>ConformationComparisonMultiAlign</td>
        <td>ConformationComparisonMultiAlign()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_multi_align.h</td>
        <td>ConformationComparisonMultiAlign</td>
        <td>GetAxisAlignedBoundingBox( FragmentComplete &TARGET) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_multi_align.h</td>
        <td>ConformationComparisonMultiAlign</td>
        <td>operator ()( const FragmentEnsemble &MOLECULE_LIST, const FragmentEnsemble &POCKET_LIST ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_property_field_correlation.h</td>
        <td>ConformationComparisonPropertyFieldCorrelation</td>
        <td>ConformationComparisonPropertyFieldCorrelation()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_property_field_correlation.h</td>
        <td>ConformationComparisonPropertyFieldCorrelation</td>
        <td>GetPropertyAtCoordinates( const ConformationInterface &MOLECULE ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_property_field_correlation.h</td>
        <td>ConformationComparisonPropertyFieldCorrelation</td>
        <td>Prepare( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_property_field_correlation.h</td>
        <td>ConformationComparisonPropertyFieldCorrelation</td>
        <td>PrepareEnsemble( const FragmentEnsemble &ENSEMBLE) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_property_field_correlation.h</td>
        <td>ConformationComparisonPropertyFieldCorrelation</td>
        <td>PropertyDistanceScorer( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B, const float &MAX_ATOM_DISTANCE ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_property_field_correlation.h</td>
        <td>ConformationComparisonPropertyFieldCorrelation</td>
        <td>SetProperties( const descriptor::Combine< AtomConformationalInterface, float> &PROPERTIES)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_property_field_correlation.h</td>
        <td>ConformationComparisonPropertyFieldCorrelation</td>
        <td>SetPropertyWeights( const linal::Vector< float> &PROPERTY_WEIGHTS)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_property_field_correlation.h</td>
        <td>ConformationComparisonPropertyFieldCorrelation</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_property_rmsd_x.h</td>
        <td>ConformationComparisonPropertyRMSDX</td>
        <td>ConformationComparisonPropertyRMSDX()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_property_rmsd_x.h</td>
        <td>ConformationComparisonPropertyRMSDX</td>
        <td>Prepare( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_property_rmsd_x.h</td>
        <td>ConformationComparisonPropertyRMSDX</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>ArbitraryScaffoldAlignment( FragmentComplete &MOLECULE_A, const FragmentComplete &MOLECULE_B, const ConformationGraphConverter::AtomComparisonType &ATOM_TYPE, const ConfigurationalBondTypeData::Data &BOND_TYPE ) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>BondAlignInf( FragmentComplete &MOLECULE_A, const FragmentComplete &MOLECULE_B )
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>CheckAtomTypeComplementarity( const util::SiPtr<const AtomConformationalInterface> &MOL_ATOM, const util::SiPtr<const AtomConformationalInterface> &POCKET_ATOM, const double &DISTANCE ) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>CheckPairPotential( const util::SiPtr<const AtomConformationalInterface> &MOL_ATOM, const util::SiPtr<const AtomConformationalInterface> &POCKET_ATOM, const double &DISTANCE ) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>ConformationComparisonPsiField( const bool &ALIGN_TO_SCAFFOLD, const size_t &ITERATIONS, const size_t &LIMIT, const size_t &N_RIGID_TRAJ, const float &ATOM_DIST_UPPER, const float &ATOM_DIST_LOWER, const size_t &N_OUTPUTS )
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>ConformationComparisonPsiField()
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>FieldOptimizeOrientation( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B, const size_t &ITERATIONS, const size_t &MAX_UNIMPROVED, const bool &RECENTER_FIRST = true, const float &MAX_ATOM_DIST = 1.00, const FragmentEnsemble &MOLECULE_A_CONFORMERS = FragmentEnsemble(), const FragmentEnsemble &POCKETS = FragmentEnsemble() ) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>FindIsomorphism( const FragmentComplete &MOLECULE, graph::ConstGraph< size_t, size_t> &SCAFFOLD_GRAPH ) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>GetAlignedAtoms( FragmentComplete &MOLECULE_A, const FragmentComplete &MOLECULE_B, storage::Vector< size_t> &MOL_A_ALIGNED_ATOMS, storage::Vector< size_t> &MOL_B_ALIGNED_ATOMS )
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>GetBaseField( const FragmentComplete &MOL_A, const FragmentComplete &MOL_B, const float &ATOM_DISTANCE = util::GetUndefined< float>(), const FragmentEnsemble &POCKETS = FragmentEnsemble() ) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ConformationComparisonPsiField</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ScoreByField</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ScoreByField</td>
        <td>ScoreByField( const FragmentComplete &MOLECULE_B, const util::SiPtr< const ConformationComparisonPsiField> &PARENT, const float &MAX_ATOM_DISTANCE, const FragmentEnsemble &POCKETS )
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ScoreByField</td>
        <td>SetTracker( const opti::Tracker< FragmentComplete, double> &TRACKER)
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ScoreByField</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>ScoreByField</td>
        <td>operator ()( const FragmentComplete &MOLECULE_A) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>TransformationMutation</td>
        <td>GetScheme() const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>TransformationMutation</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>TransformationMutation</td>
        <td>SetTracker( const opti::Tracker< FragmentComplete, double> &TRACKER)
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>TransformationMutation</td>
        <td>TransformationMutation( const FragmentEnsemble &MOLECULE_A_CONFORMERS, const FragmentComplete &MOL_B, const util::SiPtr< const ConformationComparisonPsiField::ScoreByField> &SCORE_KNOWER, const std::string &MOVIE_FILENAME )
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>TransformationMutation</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_field.h</td>
        <td>TransformationMutation</td>
        <td>operator ()( const FragmentComplete &MOLECULE_A) const
</td>
        <td>geanesar, mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>ConformationComparisonPsiFlexField( const ConformationComparisonPsiField &PSIFIELD, const size_t &N_PAIRS, const size_t &N_BEST_PAIRS_EACH_TRAJ, const size_t &FILTER_ITERATIONS, const size_t &FILTER_LIMIT, const size_t &REFINEMENT_ITERATIONS, const size_t &REFINMENT_LIMIT, const size_t &N_FLEXIBLE_TRAJ, const float &FRACTION_FILTER_INITIAL, const float &FRACTION_FILTER_ITERATIONS, const bool &RIGID_MOL_B, const SampleConformations &SAMPLE_CONFS )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>ConformationComparisonPsiFlexField()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>FieldOptimizeOrientationFlex( const FragmentEnsemble &CONFORMERS_MOL_A, const FragmentEnsemble &CONFORMERS_MOL_B, const size_t &PAIRS, const size_t &ITERATIONS, const size_t &MAX_UNIMPROVED, const size_t &FILTER_ITERATIONS, const size_t &FILTER_LIMIT, const size_t &REFINEMENT_ITERATIONS, const size_t &REFINEMENT_LIMIT, const float &FRACTION_FILTER_INITIAL, const float &FRACTION_FILTER_ITERATIONS, const bool &CENTER_ACONFS_ON_BCONFS = true, const FragmentEnsemble &POCKETS = FragmentEnsemble() ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>GetFractionFilterInitial() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>GetFractionFilterIterative() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>GetNumberConformerPairs() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>GetNumberFilterIterations() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>GetNumberFilterMaxUnimproved() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>GetNumberIterations() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>GetNumberMaxUnimproved() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>GetNumberRefinementIterations() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>GetNumberRefinementMaxUnimproved() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>MakeConformers( const FragmentComplete &MOL) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>PickConformerPairs( const FragmentComplete &MOL, const FragmentEnsemble &ENS)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>ConformationComparisonPsiFlexField</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_comparison_psi_flex_field.h</td>
        <td>TripletComparison</td>
        <td>operator ()( const storage::Triplet< FragmentComplete, FragmentComplete, double> &FIRST, const storage::Triplet< FragmentComplete, FragmentComplete, double> &SECOND)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>ConformationGraphConverter( const AtomComparisonType &ATOM_COMPARISON_TYPE, const ConfigurationalBondTypeData::Data &BOND_TYPE_INFO, const bool &REMOVE_H = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>ConformationGraphConverter()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>ConvertAtomData( const AtomConformationalInterface &ATOM, const AtomComparisonType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>ConvertAtomTypeData( const AtomType &ATOM, const AtomComparisonType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>CountNonRingVariantIsomorphisms( const ConformationInterface &CONFORMATION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>CreateAtomsFromGraph( const t_AtomGraph &GRAPH, const bool &RECALCULATE_CONFIGURATION = true )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>CreateGraphWithAtoms( const ConformationInterface &CONFORMATION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>GetAtomComparisonType( const AtomComparisonType &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>ToTree( const ConformationInterface &CONFORMATION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_graph_converter.h</td>
        <td>ConformationGraphConverter</td>
        <td>operator ()( const ConformationInterface &CONFORMATION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>AreAmideBondsPlaner( const double &TOLERANCE) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>AreAromaticRingsPlaner() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>CountNonValenceBondsWithProperty( const ConfigurationalBondTypeData::Data &DATA, const size_t &VALUE ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetAtomCoordinates() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetAtomTypesString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetAtomTypesVector() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetAtomsWithBadGeometry() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetBondAngles() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetBondAnglesByType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetBondLengthsByType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetBondTypesString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetCenter() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetChangeSignal() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetChiralityString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetDihedralAngles() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetDihedralAnglesByType() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetDoubleBondIsometryString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetElementTypesString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetHeavyAtomCoordinates() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetIterator() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetNumberHydrogens() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetNumberValences() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetSumFormula() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>GetTotalAmideBondNonPlanarity( const double &TOLERANCE) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>HasBadGeometry() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>HasChiralCenters() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>HasIsometry() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>HasNonGasteigerAtomTypes( iterate::Generic< const AtomConformationalInterface> ATOMS)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>HasNonGasteigerAtomTypes() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATION_MATRIX_3D)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATION_MATRIX_3D)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>WriteMDL( std::ostream &OSTREAM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_interface.h</td>
        <td>ConformationInterface</td>
        <td>operator =( const ConformationInterface &C)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>Begin() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>ConformationSet( util::Implementation< ConformationComparisonInterface> METHOD, double TOLERANCE = double( 1.0) )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>ConformationSet()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>End() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>GetConfigurations() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>GetConformations() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>GetConformationsMap() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>GetSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>Insert( const ConformationInterface &FRAGMENT)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set.h</td>
        <td>ConformationSet</td>
        <td>Setup( util::Implementation< ConformationComparisonInterface> METHOD, double TOLERANCE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set_same_configuration.h</td>
        <td>ConformationSetSameConfiguration</td>
        <td>Begin() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set_same_configuration.h</td>
        <td>ConformationSetSameConfiguration</td>
        <td>ConformationSetSameConfiguration( util::Implementation< ConformationComparisonInterface> METHOD, double TOLERANCE )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set_same_configuration.h</td>
        <td>ConformationSetSameConfiguration</td>
        <td>ConformationSetSameConfiguration()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set_same_configuration.h</td>
        <td>ConformationSetSameConfiguration</td>
        <td>End() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set_same_configuration.h</td>
        <td>ConformationSetSameConfiguration</td>
        <td>GetConfiguration() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set_same_configuration.h</td>
        <td>ConformationSetSameConfiguration</td>
        <td>GetConformations() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set_same_configuration.h</td>
        <td>ConformationSetSameConfiguration</td>
        <td>GetSize() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set_same_configuration.h</td>
        <td>ConformationSetSameConfiguration</td>
        <td>Insert( const ConformationInterface &FRAGMENT, util::ShPtr< FragmentConfigurationShared> CONFIGURATION = util::ShPtr< FragmentConfigurationShared>(), util::SiPtr< storage::Vector< size_t> > ISOMORPHISM = util::SiPtr< storage::Vector< size_t> >() )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set_same_constitution.h</td>
        <td>ConformationSetSameConstitution</td>
        <td>Begin() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set_same_constitution.h</td>
        <td>ConformationSetSameConstitution</td>
        <td>ConformationSetSameConstitution( util::Implementation< ConformationComparisonInterface> METHOD, double TOLERANCE = double( 0.5) )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set_same_constitution.h</td>
        <td>ConformationSetSameConstitution</td>
        <td>ConformationSetSameConstitution()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set_same_constitution.h</td>
        <td>ConformationSetSameConstitution</td>
        <td>End() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set_same_constitution.h</td>
        <td>ConformationSetSameConstitution</td>
        <td>GetConfigurations() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set_same_constitution.h</td>
        <td>ConformationSetSameConstitution</td>
        <td>GetConformations() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set_same_constitution.h</td>
        <td>ConformationSetSameConstitution</td>
        <td>GetConformationsMap() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_conformation_set_same_constitution.h</td>
        <td>ConformationSetSameConstitution</td>
        <td>GetSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_conformation_set_same_constitution.h</td>
        <td>ConformationSetSameConstitution</td>
        <td>Insert( const ConformationInterface &FRAGMENT, const util::ShPtr< FragmentConstitutionShared> &CONSTITUTION, storage::Vector< size_t> &ISOMORPHISM )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_graph_converter.h</td>
        <td>ConstitutionGraphConverter</td>
        <td>ConstitutionGraphConverter( const AtomComparisonType &ATOM_COMPARISON_TYPE, const ConstitutionalBondTypeData::Data &BOND_TYPE_INFO )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_graph_converter.h</td>
        <td>ConstitutionGraphConverter</td>
        <td>ConstitutionGraphConverter()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_graph_converter.h</td>
        <td>ConstitutionGraphConverter</td>
        <td>GetAtomComparisonType( const AtomComparisonType &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_graph_converter.h</td>
        <td>ConstitutionGraphConverter</td>
        <td>operator ()( const ConstitutionInterface &CONSTITUTION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_interface.h</td>
        <td>ConstitutionInterface</td>
        <td>GetAtomTypesString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_interface.h</td>
        <td>ConstitutionInterface</td>
        <td>GetBondTypesString() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_interface.h</td>
        <td>ConstitutionInterface</td>
        <td>GetNumberHydrogens() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_interface.h</td>
        <td>ConstitutionInterface</td>
        <td>GetNumberValences() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_interface.h</td>
        <td>ConstitutionInterface</td>
        <td>GetSumFormula() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_interface.h</td>
        <td>ConstitutionInterface</td>
        <td>WriteMDL( std::ostream &OSTREAM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>ConstitutionSet</td>
        <td>Begin() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>ConstitutionSet</td>
        <td>ConstitutionSet( iterate::Generic< const ConstitutionInterface> MOLECULES)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>ConstitutionSet</td>
        <td>ConstitutionSet()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>ConstitutionSet</td>
        <td>End() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>ConstitutionSet</td>
        <td>Find( const ConstitutionInterface &FRAGMENT, util::SiPtr< storage::Vector< size_t> > ISOMORPHISM = util::SiPtr< storage::Vector< size_t> >() ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>ConstitutionSet</td>
        <td>GetConstitutions() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>ConstitutionSet</td>
        <td>GetSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>ConstitutionSet</td>
        <td>Insert( const ConstitutionInterface &FRAGMENT, util::SiPtr< storage::Vector< size_t> > ISOMORPHISM = util::SiPtr< storage::Vector< size_t> >() )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>Node</td>
        <td>CacheGraph()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitution_set.h</td>
        <td>Node</td>
        <td>IsGraphCached() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>ConstitutionalBondTypeData( const size_t &NUMBER_ELECTRONS, const size_t &SD_FILE_ID, const size_t &SD_FILE_ALT_ID, const Conjugation &CONJUGATION, const bool &IS_IN_RING )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>ConstitutionalBondTypeData()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>GetBondData( const Data &DATA_TO_RETRIEVE) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>GetConjugation() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>GetConjugationName( const Conjugation &CONJUGATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>GetDataName( const Data &DATA)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>GetNumberOfElectrons() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>GetSDAltFileID() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>GetSDFileID() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>IsBondInRing() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>IsBondOrderKnown() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>WithConjugation( const Conjugation &CONJUGATION) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>WithInRing() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>WithIsometry( const BondIsometry &ISOMETRY) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>WithOrder( const size_t &ORDER) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td>ConstitutionalBondTypeData</td>
        <td>WithoutAromaticOrder() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td></td>
        <td>operator <<( std::ostream &OSTREAM, const ConstitutionalBondTypeData::Conjugation &CONJUGATION )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_type_data.h</td>
        <td></td>
        <td>operator >>( std::istream &ISTREAM, ConstitutionalBondTypeData::Conjugation &CONJUGATION )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_types.h</td>
        <td>ConstitutionalBondTypes</td>
        <td>FindBondTypeFromSDFInfo( const size_t &SDF_ID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_constitutional_bond_types.h</td>
        <td>ConstitutionalBondTypes</td>
        <td>GetValenceBonds( const size_t &VALENCE_BONDS, const size_t &ELECTRONS_IN_VALENCE_BONDS ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_constitutional_bond_types.h</td>
        <td></td>
        <td>GetConstitutionalBondTypes()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_coulombic_score.h</td>
        <td>CoulombicScore</td>
        <td>CoulombicScore( const descriptor::CheminfoProperty &ATOM_CHARGE, double WEIGHT)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_coulombic_score.h</td>
        <td>CoulombicScore</td>
        <td>CoulombicScore()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_coulombic_score.h</td>
        <td>CoulombicScore</td>
        <td>GetDefaultScheme()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_coulombic_score.h</td>
        <td>CoulombicScore</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_cs_code.h</td>
        <td>CsCode</td>
        <td>CompareAtomsAndBonds( const storage::Pair< ConfigurationalBondType, util::SiPtr< const AtomConformationalInterface> > &LHS, const storage::Pair< ConfigurationalBondType, util::SiPtr< const AtomConformationalInterface> > &RHS )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_cs_code.h</td>
        <td>CsCode</td>
        <td>GenerateCodeVector( const ConformationInterface &MOLECULE, const AtomConformationalInterface &ATOM, const ConfigurationalBondType &BOND_TYPE, const size_t NR_HYDROGENS, const float RING_CLOSURE, storage::Vector< descriptor::CheminfoProperty> &PROPERTIES )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_cs_code.h</td>
        <td>CsCode</td>
        <td>LimitedDepthFirstSearch( const ConformationInterface &MOLECULE, const AtomConformationalInterface &ATOM, const AtomEnvironment &ATOM_ENVIRONMENT, const size_t DEPTH, storage::Vector< float> &CODE, storage::Vector< descriptor::CheminfoProperty> &PROPERTIES, const bool &ONLY_FOLLOW_CONJUGATED_BONDS = false )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_cs_code.h</td>
        <td>CsCode</td>
        <td>ParseChemicalShifts( const ConformationInterface &MOLECULE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_descriptor_dimension.h</td>
        <td></td>
        <td>DetermineDescriptorDimension( const DescriptorDimension &PREFERENCE, const descriptor::Type &FEATURE_TYPE, const descriptor::Type &RESULT_TYPE, const descriptor::Type &ID_TYPE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_descriptor_dimension.h</td>
        <td></td>
        <td>GetDescriptorDimensionName( const DescriptorDimension &PREFERENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_descriptor_to_score_adaptor.h</td>
        <td>DescriptorToScoreAdaptor</td>
        <td>DescriptorToScoreAdaptor( const descriptor::CheminfoProperty &PROPERTY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_descriptor_to_score_adaptor.h</td>
        <td>DescriptorToScoreAdaptor</td>
        <td>DescriptorToScoreAdaptor()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_descriptor_to_score_adaptor.h</td>
        <td>DescriptorToScoreAdaptor</td>
        <td>GetProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_descriptor_to_score_adaptor.h</td>
        <td>DescriptorToScoreAdaptor</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_descriptor_to_score_adaptor.h</td>
        <td>DescriptorToScoreAdaptor</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_descriptor_to_score_adaptor.h</td>
        <td>DescriptorToScoreAdaptor</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_descriptor_to_score_adaptor.h</td>
        <td>DescriptorToScoreAdaptor</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_descriptor_to_score_adaptor.h</td>
        <td>DescriptorToScoreAdaptor</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>ElectronConfiguration( const size_t VALENCE_ELECTRONS_SP, const size_t VALENCE_ELECTRONS_SPD, const size_t NUMBER_ELECTRONS_1S, const size_t NUMBER_ELECTRONS_1P, const size_t NUMBER_ELECTRONS_1D, const size_t NUMBER_ELECTRONS_1F, const size_t NUMBER_ELECTRONS_2S, const size_t NUMBER_ELECTRONS_2P, const size_t NUMBER_ELECTRONS_2D, const size_t NUMBER_ELECTRONS_2F, const size_t NUMBER_ELECTRONS_3S, const size_t NUMBER_ELECTRONS_3P, const size_t NUMBER_ELECTRONS_3D, const size_t NUMBER_ELECTRONS_3F, const size_t NUMBER_ELECTRONS_4S, const size_t NUMBER_ELECTRONS_4P, const size_t NUMBER_ELECTRONS_4D, const size_t NUMBER_ELECTRONS_4F, const size_t NUMBER_ELECTRONS_5S, const size_t NUMBER_ELECTRONS_5P, const size_t NUMBER_ELECTRONS_5D, const size_t NUMBER_ELECTRONS_5F, const size_t NUMBER_ELECTRONS_6S, const size_t NUMBER_ELECTRONS_6P, const size_t NUMBER_ELECTRONS_6D, const size_t NUMBER_ELECTRONS_6F, const size_t NUMBER_ELECTRONS_7S, const size_t NUMBER_ELECTRONS_7P, const size_t NUMBER_ELECTRONS_7D, const size_t NUMBER_ELECTRONS_7F )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>ElectronConfiguration()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>GetDescriptor( const AngularMomentumQuantumNumber &NUM)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>GetDescriptor( const PrincipalQuantumNumber &NUM)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>MaxValenceElectronsSP() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>UnpairedValenceElectronsSP() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>ValenceElectronsP() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>ValenceElectronsS() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>ValenceElectronsSP() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>ValenceElectronsSPD() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>operator ()( const AngularMomentumQuantumNumber ANGULAR_MOMENTUM_QUANTUM_NUMBER ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_electron_configuration.h</td>
        <td>ElectronConfiguration</td>
        <td>operator ()( const PrincipalQuantumNumber PRINCIPAL_QUANTUM_NUMBER, const AngularMomentumQuantumNumber ANGULAR_MOMENTUM_QUANTUM_NUMBER ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_structure_factor.h</td>
        <td>ElementStructureFactor</td>
        <td>ElementStructureFactor( const double A1, const double A2, const double A3, const double A4, const double B1, const double B2, const double B3, const double B4, const double C, const double VOLUME = util::GetUndefinedDouble() )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_structure_factor.h</td>
        <td>ElementStructureFactor</td>
        <td>ElementStructureFactor()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_structure_factor.h</td>
        <td>ElementStructureFactor</td>
        <td>GetAValues() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_structure_factor.h</td>
        <td>ElementStructureFactor</td>
        <td>GetBValues() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_structure_factor.h</td>
        <td>ElementStructureFactor</td>
        <td>GetC() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_structure_factor.h</td>
        <td>ElementStructureFactor</td>
        <td>GetSerializer() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_structure_factor.h</td>
        <td>ElementStructureFactor</td>
        <td>GetVolume() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_structure_factor.h</td>
        <td>ElementStructureFactor</td>
        <td>operator ()( const restraint::SasDataParameters &VALUES) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>ElementTypeData( const size_t ATOMIC_NUMBER, const size_t PERIOD, const size_t MAIN_GROUP, const std::string &CHEMICAL_SYMBOL, const std::string &CHEMICAL_NAME, const double MASS, const double GYROMAGNETIC_RATIO, const double COVALENT_RADIUS, const double VDW_RADIUS, const double MELTING_POINT, const double BOILING_POINT, const double VDW_DALTON, const double PVDW_DALTON, const double ELECTRO_NEGATIVITY, const double IONIZATION_POTENTIAL, const ElectronConfiguration &ELECTRON_CONFIGURATION, const float PYMOL_COLOR_R, const float PYMOL_COLOR_G, const float PYMOL_COLOR_B, const ElementStructureFactor &STRUCTURE_FACTOR )
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>ElementTypeData()
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetAtomicNumber() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetChemicalName() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetChemicalSymbol() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetElectronConfiguration() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetMainGroup() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetPeriod() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetProperty( const ElementTypeData::Properties &PROPERTY) const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetPropertyName( const Properties &PROPERTY)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetPymolColorRGB() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>GetStructureFactor() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_type_data.h</td>
        <td>ElementTypeData</td>
        <td>IsConjugatable() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_element_types.h</td>
        <td>ElementTypes</td>
        <td>ElementTypeLookup( const std::string &SYMBOL) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_element_types.h</td>
        <td></td>
        <td>GetElementTypes()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_add_med_chem.h</td>
        <td>FragmentAddMedChem</td>
        <td>FragmentAddMedChem( const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_add_med_chem.h</td>
        <td>FragmentAddMedChem</td>
        <td>FragmentAddMedChem( const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_add_med_chem.h</td>
        <td>FragmentAddMedChem</td>
        <td>FragmentAddMedChem( const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_add_med_chem.h</td>
        <td>FragmentAddMedChem</td>
        <td>FragmentAddMedChem( const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_add_med_chem.h</td>
        <td>FragmentAddMedChem</td>
        <td>FragmentAddMedChem( const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const std::string &DRUG_LIKENESS_TYPE, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_add_med_chem.h</td>
        <td>FragmentAddMedChem</td>
        <td>FragmentAddMedChem()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_add_med_chem.h</td>
        <td>FragmentAddMedChem</td>
        <td>IsRingSubstitutionDirected( const FragmentComplete &MOLECULE, util::SiPtr< const AtomConformationalInterface> &ATOM ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_add_med_chem.h</td>
        <td>FragmentAddMedChem</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_alchemy.h</td>
        <td>FragmentAlchemy</td>
        <td>FragmentAlchemy( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_alchemy.h</td>
        <td>FragmentAlchemy</td>
        <td>FragmentAlchemy( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_alchemy.h</td>
        <td>FragmentAlchemy</td>
        <td>FragmentAlchemy( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_alchemy.h</td>
        <td>FragmentAlchemy</td>
        <td>FragmentAlchemy( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_alchemy.h</td>
        <td>FragmentAlchemy</td>
        <td>FragmentAlchemy( const std::string &DRUG_LIKENESS_TYPE, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_alchemy.h</td>
        <td>FragmentAlchemy</td>
        <td>FragmentAlchemy()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_alchemy.h</td>
        <td>FragmentAlchemy</td>
        <td>IsRingSubstitutionDirected( const FragmentComplete &MOLECULE, util::SiPtr< const AtomConformationalInterface> &ATOM ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_alchemy.h</td>
        <td>FragmentAlchemy</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_align_to_scaffold.h</td>
        <td>FragmentAlignToScaffold</td>
        <td>AlignToScaffold( FragmentComplete &TARGET_MOL, const FragmentComplete &SCAFFOLD_MOL )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_align_to_scaffold.h</td>
        <td>FragmentAlignToScaffold</td>
        <td>FragmentAlignToScaffold( const ConformationGraphConverter::AtomComparisonType &ATOM_TYPE, const ConfigurationalBondTypeData::Data &BOND_TYPE, const size_t &MIN_ISO_SIZE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_align_to_scaffold.h</td>
        <td>FragmentAlignToScaffold</td>
        <td>FragmentAlignToScaffold()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_align_to_scaffold.h</td>
        <td>FragmentAlignToScaffold</td>
        <td>GetMutex()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_align_to_scaffold.h</td>
        <td>FragmentAlignToScaffold</td>
        <td>PoseSensitiveAlignToScaffold( FragmentComplete &TARGET_MOL, const FragmentComplete &SCAFFOLD_MOL, const descriptor::CheminfoProperty &SCORE, const std::string &MDL, const std::string &BINDING_POCKET_FILENAME )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>Canonicalize()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>EncodeTerminalResonance()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>FragmentComplete( const AtomVector< AtomComplete> &ATOMS, const std::string &NAME )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>FragmentComplete( const AtomVector< AtomComplete> &ATOMS, const std::string &NAME, const storage::Map< std::string, std::string> &STORED_PROPERTIES )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>FragmentComplete( const ConfigurationInterface &CONFIGURATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>FragmentComplete( const ConformationInterface &CONFORMATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>FragmentComplete( const ConstitutionInterface &CONSTITUTION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>FragmentComplete()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetAdjacencyList( const ConfigurationalBondTypeData::Data &BOND_SCHEME) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetAtomIndex( const AtomConformationalInterface &ATOM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetAtomInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetAtomVector() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetAtomsIterator() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetBondInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetMergedProperties() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetName() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetNumberAtoms() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>GetNumberBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>HasValences() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>IdealizeGeometry()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>RemoveH()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>SaturateWithH()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>SetAtomCoordinates( const storage::Vector< linal::Vector3D> &COORDINATES, const storage::Vector< size_t> &INDICES = storage::Vector< size_t>() )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>StandardizeBondLengths()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_complete.h</td>
        <td>FragmentComplete</td>
        <td>UpdateH()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>FragmentConfigurationShared( const ConfigurationInterface &CONFIGURATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>FragmentConfigurationShared( const ConformationInterface &CONFORMATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>FragmentConfigurationShared( const FragmentConfigurationShared &CONFORMATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>FragmentConfigurationShared( const util::ShPtr< FragmentConstitutionShared> &CONSTITUTION, const AtomVector< AtomConfigurationalShared> &ATOMS_CONFIGURATIONAL )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>FragmentConfigurationShared()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>GetAdjacencyList( const ConfigurationalBondTypeData::Data &BOND_SCHEME) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>GetAtomInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>GetAtomsIterator() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>GetBondInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>GetConstitution() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>GetMergedProperties() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>GetName() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>GetNumberAtoms() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>GetNumberBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_configuration_shared.h</td>
        <td>FragmentConfigurationShared</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>FragmentConformationShared( const ConfigurationInterface &CONFIGURATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>FragmentConformationShared( const ConformationInterface &CONFORMATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>FragmentConformationShared( const FragmentConformationShared &CONFORMATION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>FragmentConformationShared( const util::ShPtr< FragmentConfigurationShared> &CONFIGURATION, const AtomVector< AtomConformationalShared> &ATOMS_CONFORMATIONAL )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>FragmentConformationShared()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetAdjacencyList( const ConfigurationalBondTypeData::Data &BOND_SCHEME) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetAtomIndex( const AtomConformationalInterface &ATOM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetAtomInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetAtomsIterator() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetBondInfo() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetConfiguration() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetConstitution() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetMergedProperties() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetName() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetNumberAtoms() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>GetNumberBonds() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_conformation_shared.h</td>
        <td>FragmentConformationShared</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_connector.h</td>
        <td>FragmentConnector</td>
        <td>FragmentConnector( const FragmentComplete &FRAGMENT, const storage::Vector< size_t> &VERTICES )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_connector.h</td>
        <td>FragmentConnector</td>
        <td>FragmentConnector()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_connector.h</td>
        <td>FragmentConnector</td>
        <td>GetFragment() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_connector.h</td>
        <td>FragmentConnector</td>
        <td>GetVertices() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_connector.h</td>
        <td>FragmentConnector</td>
        <td>operator ()( const FragmentComplete &FRAGMENT, const ConfigurationalBondType &BOND_TYPE, const storage::Pair< size_t, size_t> &INDICES_TO_CONNECT, const storage::Vector< size_t> &ISOMORPHISM )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_connector.h</td>
        <td>FragmentConnector</td>
        <td>operator ()( const FragmentComplete &FRAGMENT, const storage::Map< size_t, size_t> &COMMON_VERTICES, const storage::Vector< size_t> &ISOMORPHISM )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>FragmentConstitutionShared( const AtomVector< AtomConstitutionalShared> &CONSTITUTION)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>FragmentConstitutionShared( const ConfigurationInterface &CONFIGURATION)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>FragmentConstitutionShared( const ConformationInterface &CONFORMATION)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>FragmentConstitutionShared( const ConstitutionInterface &CONSTITUTION)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>FragmentConstitutionShared( const FragmentConstitutionShared &CONSTITUTION)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>FragmentConstitutionShared()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>GetAdjacencyList( const ConstitutionalBondTypeData::Data &BOND_SCHEME) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>GetAtomInfo() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>GetAtomsIterator() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>GetBondInfo() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>GetName() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>GetNumberAtoms() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>GetNumberBonds() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>IsAtomInMolecule( const AtomConstitutionalInterface &ATOM) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_constitution_shared.h</td>
        <td>FragmentConstitutionShared</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_cyclize.h</td>
        <td>FragmentCyclize</td>
        <td>FragmentCyclize( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_cyclize.h</td>
        <td>FragmentCyclize</td>
        <td>FragmentCyclize( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_cyclize.h</td>
        <td>FragmentCyclize</td>
        <td>FragmentCyclize( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_cyclize.h</td>
        <td>FragmentCyclize</td>
        <td>FragmentCyclize()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_cyclize.h</td>
        <td>FragmentCyclize</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>CollisionScore( const FragmentComplete &MOLECULE, const FragmentEnsemble &POCKET, const linal::Vector< double> &BFACTOR ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>FragmentDockEngine( const SampleConformations &SAMPLER )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>FragmentDockEngine( const SampleConformations &SAMPLER, const descriptor::CheminfoProperty &SCORER )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>FragmentDockEngine( const SampleConformations &SAMPLER, const std::string &MOVIE_FILENAME )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>FragmentDockEngine( const std::string &MOVIE_FILENAME )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>FragmentDockEngine()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>GetSerializer() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>InteractionScore( const FragmentComplete &MOLECULE, const FragmentComplete &POCKET, const descriptor::CheminfoProperty &MODEL ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>SampleLigandConfsGlobal( const FragmentComplete &MOLECULE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>SampleLigandConfsLocal( const FragmentComplete &MOLECULE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>TransformCoordinates( const FragmentComplete &MOLECULE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_dock_engine.h</td>
        <td>FragmentDockEngine</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>Append( const FragmentEnsemble &ENSEMBLE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>Begin()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>Begin() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>End()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>End() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>FragmentEnsemble( const storage::List< FragmentComplete> &MOLECULES)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>FragmentEnsemble( std::istream &ISTREAM, const sdf::HydrogenHandlingPref &H_PREF = sdf::e_Maintain, const math::Range< size_t> &RANGE = math::Range< size_t>( 0, std::numeric_limits< size_t>::max()), const sdf::NeutralizationPref &NEUTRALIZATION = sdf::e_CmdLine )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>FragmentEnsemble()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>GetMolecules()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>GetMolecules() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>GetSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>IsEmpty() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>PopBack()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>PushBack( const FragmentComplete &MOL_OBJ)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>ReadMoreFromMdl( std::istream &ISTREAM, const sdf::HydrogenHandlingPref &H_PREF = sdf::e_Maintain, const math::Range< size_t> &RANGE = math::Range< size_t>( 0, std::numeric_limits< size_t>::max()), const sdf::NeutralizationPref &NEUTRALIZATION = sdf::e_CmdLine )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>RemoveH()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>SaturateWithH()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>Shuffle()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>Sort( const std::string PROPERTY_NAME)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>Sort( const storage::Vector< std::string> PROPERTY_NAMES)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ensemble.h</td>
        <td>FragmentEnsemble</td>
        <td>WriteMDL( std::ostream &OSTREAM) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_base.h</td>
        <td>FragmentEvolveBase</td>
        <td>FinalizeMolecule( const FragmentComplete &MOLECULE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_base.h</td>
        <td>FragmentEvolveBase</td>
        <td>GetCorina3DCoordinates( const ConformationInterface &MOLECULE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_base.h</td>
        <td>FragmentEvolveBase</td>
        <td>MakeBCLConformer( const FragmentComplete &MOLECULE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_base.h</td>
        <td>FragmentEvolveBase</td>
        <td>NumberBadBonds( const FragmentComplete &MOLECULE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>BadBond</td>
        <td>BadBond( const ElementType &ELEMENT1, const ElementType &ELEMENT2, const int &BOND_ORDER, const bool &IN_RING )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>BadBond</td>
        <td>BadBond()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>CollectFragmentsFromBondBreakage( graph::ConstGraph< size_t, size_t> &MOLECULE_GRAPH, const size_t &FROM, const size_t &TO ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>Combine( const FragmentComplete &FIRST_MOLECULE, const FragmentComplete &SECOND_MOLECULE, const size_t MAX_FRAG_SIZE = 50 ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>FragmentEvolveImplementations( const EvolveType &EVOLVE_TYPE, const bool &ALLOW_BAD_BONDS = true)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>FragmentsFromRandomBondBreakage( const FragmentComplete &MOLECULE, graph::ConstGraph< size_t, size_t> &MOLECULE_GRAPH, const size_t &EDGE_TYPE = 1 ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>GetEvolveType() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>GetEvolveTypeString( const FragmentEvolveImplementations::EvolveType &EVOLVE_TYPE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>GetFragmentList() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>GetSerializer() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>MakeMolecules( const util::SiPtrVector< const FragmentComplete> &MEMBERS ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>MutateAdd( const FragmentComplete &MOLECULE, const FragmentEnsemble &FRAGMENTS ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>MutateDel( const FragmentComplete &MOLECULE) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>NumRequiredMols() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>ReadFragmentsFromFile() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>SetAllowBadBonds( const bool &ALLOW_BAD_BONDS)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>SetFragmentList( const FragmentEnsemble &FRAGMENT_LIST)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>SetFragmentList( const std::string &FILENAME)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_evolve_implementations.h</td>
        <td>FragmentEvolveImplementations</td>
        <td>SetFragmentList( const util::ShPtr< FragmentEnsemble> &FRAGMENT_LIST)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>AlkylLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const size_t&LINK_INDEX_A, const size_t&LINK_INDEX_B, const size_t &REPEATS ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>AmideLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const size_t&LINK_INDEX_A, const size_t&LINK_INDEX_B, const size_t &REPEATS ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>DirectLink( const FragmentComplete &FRAGMENT_A, const FragmentComplete &FRAGMENT_B, const size_t&LINK_INDEX_A, const size_t&LINK_INDEX_B ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>EthoxyLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const size_t&LINK_INDEX_A, const size_t&LINK_INDEX_B, const size_t &REPEATS ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>FragmentExtendWithLinker( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const bool &CORINA_CONFS )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>FragmentExtendWithLinker( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>FragmentExtendWithLinker( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>FragmentExtendWithLinker()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>GenerateAmideLinker( const std::string &CONNECTION, const size_t &REPEATS ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>MethoxyLink( const chemistry::FragmentComplete &FRAGMENT_A, const chemistry::FragmentComplete &FRAGMENT_B, const size_t&LINK_INDEX_A, const size_t&LINK_INDEX_B, const size_t &REPEATS ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>OpenValence( const chemistry::FragmentComplete &FRAGMENT, const size_t &ATOM_INDEX ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>RingExtension( const chemistry::FragmentComplete &FRAGMENT_A, const size_t&LINK_INDEX_A, const size_t &REPEATS, const storage::Vector< std::string> &ELEMENT_TYPE ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>RingLink( const FragmentComplete &FRAGMENT_A, const FragmentComplete &FRAGMENT_B, const size_t&LINK_INDEX_A, const size_t&LINK_INDEX_B ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>SingleElementLink( const FragmentComplete &FRAGMENT_A, const FragmentComplete &FRAGMENT_B, const size_t&LINK_INDEX_A, const size_t&LINK_INDEX_B, const storage::Vector< std::string> &ELEMENT_TYPE ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_extend_with_linker.h</td>
        <td>FragmentExtendWithLinker</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>AddFlags( command::Command &CMD, const std::string &NAME = Ó)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>CleanUp()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>FragmentFeed( const std::string &NAME = Ó)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>FragmentFeed( const std::string &NAME, const sdf::HydrogenHandlingPref &PREF)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>FragmentFeed( const storage::Vector< std::string> &FILENAMES, const sdf::HydrogenHandlingPref &PREF, const size_t &MAX_TO_READ = std::numeric_limits< size_t>::max(), const sdf::NeutralizationPref &NEUTRALIZE = sdf::e_CmdLine )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>FragmentFeed( std::istream &STREAM, const sdf::HydrogenHandlingPref &PREF, const size_t &MAX_TO_READ = std::numeric_limits< size_t>::max(), const size_t &INPUT_START = size_t( 0), const sdf::NeutralizationPref &NEUTRALIZE = sdf::e_CmdLine )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>GetName() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>GetPosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>NotAtEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>Restart()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>operator *()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>operator ++()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed.h</td>
        <td>FragmentFeed</td>
        <td>operator ->()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed_from_file.h</td>
        <td>FragmentFeedFromFile</td>
        <td>CountMolecules( const std::string &FILENAME, const size_t &MAX = std::numeric_limits< size_t>::max() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed_from_file.h</td>
        <td>FragmentFeedFromFile</td>
        <td>FragmentFeedFromFile( const FragmentFeedFromFile &FEED)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed_from_file.h</td>
        <td>FragmentFeedFromFile</td>
        <td>FragmentFeedFromFile()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed_from_file.h</td>
        <td>FragmentFeedFromFile</td>
        <td>GetParameter() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed_from_file.h</td>
        <td>FragmentFeedFromFile</td>
        <td>GetSize( const size_t &MAX_TO_CONSIDER = std::numeric_limits< size_t>::max())
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed_from_file.h</td>
        <td>FragmentFeedFromFile</td>
        <td>Open( const std::string &LOCATION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed_from_file.h</td>
        <td>FragmentFeedFromFile</td>
        <td>RetrieveNextMolecule( sdf::MdlHandler &HANDLER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed_from_file.h</td>
        <td>FragmentFeedFromFile</td>
        <td>Skip()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed_from_stream.h</td>
        <td>FragmentFeedFromStream</td>
        <td>FragmentFeedFromStream( const FragmentFeedFromStream &FEED)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed_from_stream.h</td>
        <td>FragmentFeedFromStream</td>
        <td>FragmentFeedFromStream( std::istream &INPUT_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed_from_stream.h</td>
        <td>FragmentFeedFromStream</td>
        <td>GetParameter() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed_from_stream.h</td>
        <td>FragmentFeedFromStream</td>
        <td>GetSize( const size_t &MAX_TO_CONSIDER = std::numeric_limits< size_t>::max())
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed_from_stream.h</td>
        <td>FragmentFeedFromStream</td>
        <td>Open( const std::string &LOCATION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_feed_from_stream.h</td>
        <td>FragmentFeedFromStream</td>
        <td>RetrieveNextMolecule( sdf::MdlHandler &HANDLER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_feed_from_stream.h</td>
        <td>FragmentFeedFromStream</td>
        <td>Skip()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_fluorinate.h</td>
        <td>FragmentFluorinate</td>
        <td>FragmentFluorinate( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_fluorinate.h</td>
        <td>FragmentFluorinate</td>
        <td>FragmentFluorinate( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_fluorinate.h</td>
        <td>FragmentFluorinate</td>
        <td>FragmentFluorinate( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_fluorinate.h</td>
        <td>FragmentFluorinate</td>
        <td>FragmentFluorinate( const std::string &DRUG_LIKENESS_TYPE, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_fluorinate.h</td>
        <td>FragmentFluorinate</td>
        <td>FragmentFluorinate()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_fluorinate.h</td>
        <td>FragmentFluorinate</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_graph_marker.h</td>
        <td>FragmentGraphMarker</td>
        <td>FragmentGraphMarker( const ConformationGraphConverter &BOND_TYPE, const util::Implementation< FragmentSplitInterface> &SPLIT_PARAMETER )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_graph_marker.h</td>
        <td>FragmentGraphMarker</td>
        <td>GetConstitution() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_graph_marker.h</td>
        <td>FragmentGraphMarker</td>
        <td>Insert( const ConformationInterface &ENSEMBLE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_graph_marker.h</td>
        <td>FragmentGraphMarker</td>
        <td>Insert( const FragmentEnsemble &ENSEMBLE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_graph_marker.h</td>
        <td>FragmentGraphMarker</td>
        <td>operator ()( const ConformationInterface &CONFORMATION) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_graph_marker.h</td>
        <td>FragmentGraphMarker</td>
        <td>operator ()( const FragmentEnsemble &ENSEMBLE) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_grow.h</td>
        <td>FragmentGrow</td>
        <td>AddFragment( const FragmentComplete &BASE, const FragmentComplete &FRAGMENT, const util::SiPtr< const AtomConformationalInterface> &BASE_ATOM, const util::SiPtr< const AtomConformationalInterface> &FRAGMENT_ATOM, const size_t &MAX_BOND_ORDER = 0 )
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_grow.h</td>
        <td>FragmentGrow</td>
        <td>AddFragmentFromList( const FragmentComplete &FRAGMENT, const FragmentEnsemble &FRAGMENT_LIST ) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_grow.h</td>
        <td>FragmentGrow</td>
        <td>FragmentGrow( const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const find::CollectorInterface< util::SiPtrList< const AtomConformationalInterface>, FragmentComplete> &ATOM_COLLECTOR, const find::PickInterface< util::SiPtr< const AtomConformationalInterface>, util::SiPtrList< const AtomConformationalInterface> > &ATOM_PICKER, const find::PickInterface< const FragmentComplete &, FragmentEnsemble> &FRAGMENT_PICKER )
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_grow.h</td>
        <td>FragmentGrow</td>
        <td>FragmentGrow()
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_grow.h</td>
        <td>FragmentGrow</td>
        <td>GetFragmentPool() const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_grow.h</td>
        <td>FragmentGrow</td>
        <td>GrowFragment( const FragmentComplete &FRAGMENT) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_grow.h</td>
        <td>FragmentGrow</td>
        <td>RemoveSingleH( const FragmentComplete &MOLECULE) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_grow.h</td>
        <td>FragmentGrow</td>
        <td>SetFragmentPool( const util::ShPtr< FragmentEnsemble> &FragmentPool)
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_grow.h</td>
        <td>FragmentGrow</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_halogenate.h</td>
        <td>FragmentHalogenate</td>
        <td>FragmentHalogenate( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_halogenate.h</td>
        <td>FragmentHalogenate</td>
        <td>FragmentHalogenate( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_halogenate.h</td>
        <td>FragmentHalogenate</td>
        <td>FragmentHalogenate( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_halogenate.h</td>
        <td>FragmentHalogenate</td>
        <td>FragmentHalogenate( const std::string &DRUG_LIKENESS_TYPE, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_halogenate.h</td>
        <td>FragmentHalogenate</td>
        <td>FragmentHalogenate()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_halogenate.h</td>
        <td>FragmentHalogenate</td>
        <td>IsRingSubstitutionDirected( const FragmentComplete &MOLECULE, util::SiPtr< const AtomConformationalInterface> &ATOM ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_halogenate.h</td>
        <td>FragmentHalogenate</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_make_conformers.h</td>
        <td>FragmentMakeConformers</td>
        <td>FragmentMakeConformers( const RotamerLibraryFile &ROT_LIB, const size_t &N_ITERATIONS, const float &CLASH_TOLERANCE, const bool &GENERATE_3D, const bool &CORINA )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_make_conformers.h</td>
        <td>FragmentMakeConformers</td>
        <td>FragmentMakeConformers( const RotamerLibraryFile &ROT_LIB, const std::string &COMPARER, const float &COMPARER_TOLERANCE, const bool &CLUSTER, const size_t &N_ITERATIONS, const float &CLASH_TOLERANCE, const bool &GENERATE_3D, const bool &CORINA, const bool &LOCAL = false )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_make_conformers.h</td>
        <td>FragmentMakeConformers</td>
        <td>FragmentMakeConformers()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_make_conformers.h</td>
        <td>FragmentMakeConformers</td>
        <td>GetCorina3DCoordinates( const ConformationInterface &MOLECULE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_make_conformers.h</td>
        <td>FragmentMakeConformers</td>
        <td>GetMutex()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_make_conformers.h</td>
        <td>FragmentMakeConformers</td>
        <td>MakeConformer( const FragmentComplete &MOLECULE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_make_conformers.h</td>
        <td>FragmentMakeConformers</td>
        <td>MakeConformerBCLIdeal( const FragmentComplete &MOLECULE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_make_conformers.h</td>
        <td>FragmentMakeConformers</td>
        <td>MakeConformers( const FragmentComplete &MOLECULE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>Clean( AtomVector< AtomComplete> &ATOMS, const FragmentComplete &REFERENCE_MOL, const std::string &DRUG_LIKENESS_TYPE = Ó, const bool &SKIP_NEUT = false )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>FragmentMapConformer( const std::string &DRUG_LIKENESS_TYPE, const bool &CORINA_CONFS )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>FragmentMapConformer( const std::string &DRUG_LIKENESS_TYPE, const std::string &MDL, const std::string &BINDING_POCKET_FILENAME, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS = false )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>FragmentMapConformer()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>GetBFactors() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>GetMDL() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>GetMutex()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>GetPocketFilename() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>IsConstitutionDruglike( const FragmentComplete &MOLECULE)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>IsConstitutionDruglikeAndHitlike( const FragmentComplete &MOLECULE)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_map_conformer.h</td>
        <td>FragmentMapConformer</td>
        <td>MapConformer( const FragmentComplete &STARTING_MOL, const FragmentComplete &NEW_MOL, const ConformationGraphConverter::AtomComparisonType &ATOM_COMPARISON = ConformationGraphConverter::AtomComparisonType::e_AtomType, const ConfigurationalBondTypeData::Data &BOND_COMPARISON = ConfigurationalBondTypeData::Data::e_BondOrderAmideOrAromaticWithRingness, const bool &COMPLEMENT = true )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_molecule.h</td>
        <td>FragmentMolecule</td>
        <td>FragmentMolecule( util::ShPtr< ConfigurationSet> &CONFIGURATION, const size_t MAX_ROT )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_molecule.h</td>
        <td>FragmentMolecule</td>
        <td>FragmentMolecule( util::ShPtr< ConstitutionSet> &CONSTITUTION_SET, const size_t MAX_ROT )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_molecule.h</td>
        <td>FragmentMolecule</td>
        <td>FragmentMolecule()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_molecule.h</td>
        <td>FragmentMolecule</td>
        <td>GetConfigurations() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_molecule.h</td>
        <td>FragmentMolecule</td>
        <td>GetConstitutions() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_molecule.h</td>
        <td>FragmentMolecule</td>
        <td>GetSize() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_molecule.h</td>
        <td>FragmentMolecule</td>
        <td>operator ()( const FragmentComplete &MOLECULE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_mutate_mcm.h</td>
        <td>FragmentMutateMCM</td>
        <td>FragmentMutateMCM( const opti::Tracker< FragmentComplete, double> &OPTI_GOAL, const util::Implementation< FragmentSplitInterface> &SPLITTER, const util::ShPtr< SearchFragmentLibraryFromTree> &TREE_SEARCH, const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_mutate_mcm.h</td>
        <td>FragmentMutateMCM</td>
        <td>FragmentMutateMCM( const opti::Tracker< FragmentComplete, double> &OPTI_GOAL, const util::Implementation< FragmentSplitInterface> &SPLITTER, const util::ShPtr< SearchFragmentLibraryFromTree> &TREE_SEARCH, const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &CORINA_CONFS, const size_t &MAX_SEQUENTIAL_MUTATES, const float &RING_SWAP_PROB, const float &CYCLIZE_PROB, const float &ALCHEMY_PROB, const float &REMOVE_ATOM_PROB, const float &REMOVE_BOND_PROB, const float &ADD_MEDCHEM_PROB, const float &SWAP_AMIDE_PROB, const float &FLUORINATE_PROB, const float &HALOGENATE_PROB, const float &EXTEND_WITH_LINKER_PROB )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_mutate_mcm.h</td>
        <td>FragmentMutateMCM</td>
        <td>FragmentMutateMCM( const opti::Tracker< FragmentComplete, double> &OPTI_GOAL, const util::Implementation< FragmentSplitInterface> &SPLITTER, const util::ShPtr< SearchFragmentLibraryFromTree> &TREE_SEARCH, const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_mutate_mcm.h</td>
        <td>FragmentMutateMCM</td>
        <td>FragmentMutateMCM( const opti::Tracker< FragmentComplete, double> &OPTI_GOAL, const util::Implementation< FragmentSplitInterface> &SPLITTER, const util::ShPtr< SearchFragmentLibraryFromTree> &TREE_SEARCH, const util::ShPtr< FragmentEnsemble> &FRAGMENT_POOL, const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS, const size_t &MAX_SEQUENTIAL_MUTATES, const float &RING_SWAP_PROB, const float &CYCLIZE_PROB, const float &ALCHEMY_PROB, const float &REMOVE_ATOM_PROB, const float &REMOVE_BOND_PROB, const float &ADD_MEDCHEM_PROB, const float &SWAP_AMIDE_PROB, const float &FLUORINATE_PROB, const float &HALOGENATE_PROB, const float &EXTEND_WITH_LINKER_PROB )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_mutate_mcm.h</td>
        <td>FragmentMutateMCM</td>
        <td>FragmentMutateMCM()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_mutate_mcm.h</td>
        <td>FragmentMutateMCM</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_probability_score.h</td>
        <td>FragmentProbabilityScore</td>
        <td>FragmentProbabilityScore( const util::ShPtrVector< RotamerDihedralBondData> &FRAGMENT_DATA, const bool &CONSIDER_ISOMETRY_CHANGE = true )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_probability_score.h</td>
        <td>FragmentProbabilityScore</td>
        <td>FragmentProbabilityScore()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_probability_score.h</td>
        <td>FragmentProbabilityScore</td>
        <td>Get14InteractionScore( const FragmentComplete &MOLECULE ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_probability_score.h</td>
        <td>FragmentProbabilityScore</td>
        <td>GetDefaultScheme()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_probability_score.h</td>
        <td>FragmentProbabilityScore</td>
        <td>GetDihedralBin( const FragmentComplete &MOLECULE, const storage::VectorND< 4, size_t> &DIHEDRAL_BOND, t_Map &BIN_HASH_TO_BIN ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_probability_score.h</td>
        <td>FragmentProbabilityScore</td>
        <td>GetMolecularBinFromFragment( const FragmentComplete &MOLECULE, const storage::Vector< storage::VectorND< 4, size_t> > &FRAGMENT_ISOMORPHISM, t_Map &BIN_HASH_TO_BIN ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_probability_score.h</td>
        <td>FragmentProbabilityScore</td>
        <td>GetRotamerData() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_probability_score.h</td>
        <td>FragmentProbabilityScore</td>
        <td>GetScoreComponents( const FragmentComplete &FRAG_COMP) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_probability_score.h</td>
        <td>FragmentProbabilityScore</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>FragmentReact( const ReactionSearch &CATALOG = ReactionSearch() )
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>IsGood() const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>ReactCenterContaining( const FragmentComplete &MOL, storage::Vector< size_t> &ATOM_INDICES, const bool &REQUIRE_ALL = true ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>ReactExhaustive( const FragmentComplete &MOL ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>ReactExhaustiveOneReactantHelper( const util::SiPtr< const ReactionComplete> &RXN, const FragmentComplete &MOL ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>ReactExhaustiveOneReaction( const FragmentComplete &MOL, const ReactionComplete &RXN ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>ReactExhaustiveThreeReactantHelper( const util::SiPtr< const ReactionComplete> &RXN, const FragmentComplete &MOL ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>ReactExhaustiveTwoReactantHelper( const util::SiPtr< const ReactionComplete> &RXN, const FragmentComplete &MOL ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>ReactRandom( const FragmentComplete &MOL ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_react.h</td>
        <td>FragmentReact</td>
        <td>RemoveWhitespace( const std::string &STR) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_remove_atom.h</td>
        <td>FragmentRemoveAtom</td>
        <td>FragmentRemoveAtom( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_remove_atom.h</td>
        <td>FragmentRemoveAtom</td>
        <td>FragmentRemoveAtom( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_remove_atom.h</td>
        <td>FragmentRemoveAtom</td>
        <td>FragmentRemoveAtom( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_remove_atom.h</td>
        <td>FragmentRemoveAtom</td>
        <td>FragmentRemoveAtom( const std::string &DRUG_LIKENESS_TYPE, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_remove_atom.h</td>
        <td>FragmentRemoveAtom</td>
        <td>FragmentRemoveAtom()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_remove_atom.h</td>
        <td>FragmentRemoveAtom</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_remove_bond.h</td>
        <td>FragmentRemoveBond</td>
        <td>FragmentRemoveBond( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_remove_bond.h</td>
        <td>FragmentRemoveBond</td>
        <td>FragmentRemoveBond( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_remove_bond.h</td>
        <td>FragmentRemoveBond</td>
        <td>FragmentRemoveBond( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_remove_bond.h</td>
        <td>FragmentRemoveBond</td>
        <td>FragmentRemoveBond( const std::string &DRUG_LIKENESS_TYPE, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_remove_bond.h</td>
        <td>FragmentRemoveBond</td>
        <td>FragmentRemoveBond()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_remove_bond.h</td>
        <td>FragmentRemoveBond</td>
        <td>RemoveBond( const FragmentComplete &FRAGMENT, const sdf::BondInfo &BOND) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_remove_bond.h</td>
        <td>FragmentRemoveBond</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>FragmentRingSwap( const util::ShPtr< SearchFragmentLibraryFromTree> &FRAGMENT_LIBRARY = util::ShPtr< SearchFragmentLibraryFromTree>(), const std::string &DRUG_LIKENESS_TYPE = Ó, const FragmentComplete &REFERENCE_FRAGMENT = FragmentComplete(), const FragmentComplete &SCAFFOLD_FRAGMENT = FragmentComplete(), const storage::Vector< size_t> &MUTABLE_ATOM_INDICES = storage::Vector< size_t>(), const bool &CORINA = false, const bool &FIX_GEOMETRY = true, const bool &NEUTRALIZE = true, const double &RING_INITIATION_PROBABILITY = 0.1, const bool &PREVENT_MORE_THAN_ONE_RING_FROM_CHANGING_SIZE = true, const bool &ALLOW_LARGE_RING_COLLAPSE = false )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>FragmentRingSwap( const util::ShPtr< SearchFragmentLibraryFromTree> &FRAGMENT_LIBRARY = util::ShPtr< SearchFragmentLibraryFromTree>(), const std::string &DRUG_LIKENESS_TYPE = Ó, const FragmentComplete &REFERENCE_FRAGMENT = FragmentComplete(), const FragmentComplete &SCAFFOLD_FRAGMENT = FragmentComplete(), const storage::Vector< size_t> &MUTABLE_ATOM_INDICES = storage::Vector< size_t>(), const std::string &MDL = std::string(), const descriptor::CheminfoProperty &PROPERTY_SCORER = descriptor::CheminfoProperty(), const bool &RESOLVE_CLASHES = false, const storage::Vector< float> &BFACTORS = storage::Vector< float>(), const bool &CORINA = false, const bool &FIX_GEOMETRY = true, const bool &NEUTRALIZE = true, const double &RING_INITIATION_PROBABILITY = 0.1, const bool &PREVENT_MORE_THAN_ONE_RING_FROM_CHANGING_SIZE = true, const bool &ALLOW_LARGE_RING_COLLAPSE = false )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetCounts( const FragmentComplete &FRAG)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetGlobalRandomNonringAtom( const FragmentComplete &FRAG)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetGlobalRandomRingSystem( const FragmentComplete &FRAG, bool ALLOW_LARGE_RING_COLLAPSE = false)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetNumberDoubleBondValences( const FragmentComplete &FRAG)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetNumberDoubleBondValences( const FragmentComplete &FRAG, const storage::Vector< size_t> &RING)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetRandomNonringAtom( const FragmentComplete &FRAG, const size_t ATOM_INDEX)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetRandomRingSystem( const FragmentComplete &FRAG, const size_t ATOM_INDEX, bool ONLY_SELECT_COLLAPSABLE_RINGS = false)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetRingSizeInformation( const FragmentComplete &FRAG)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetRingSizeInformation( const FragmentComplete &FRAG, const storage::Vector< size_t> &RING )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>GetSubstitutents( const FragmentComplete &FRAG, const storage::Vector< size_t> &RING, const bool &COLLAPSE )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>IsCollapsible( const FragmentComplete &FRAG, const storage::Vector< size_t> &RING )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>IsRingSubstitutionDirected( const FragmentComplete &MOLECULE, util::SiPtr< const AtomConformationalInterface> &ATOM ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>SortedVectorsDifferByNoMoreThanOneElement( const linal::Vector< float> &VEC_A, const linal::Vector< float> &VEC_B )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_ring_swap.h</td>
        <td>FragmentRingSwap</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_common_substructure.h</td>
        <td>FragmentSplitCommonSubstructure</td>
        <td>FragmentSplitCommonSubstructure( const std::string &FILENAME = Ó, const ConformationGraphConverter::AtomComparisonType ATOM_COMPARISON = ConformationGraphConverter::e_ElementType, const ConfigurationalBondTypeData::Data BOND_COMPARISON = ConfigurationalBondTypeData::e_BondOrderAmideOrAromaticWithRingness, const bool &COMPLEMENT = false )
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_common_substructure.h</td>
        <td>FragmentSplitCommonSubstructure</td>
        <td>GetClassDescription() const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_common_substructure.h</td>
        <td>FragmentSplitCommonSubstructure</td>
        <td>GetMinSize() const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_common_substructure.h</td>
        <td>FragmentSplitCommonSubstructure</td>
        <td>ReadFile() const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_common_substructure.h</td>
        <td>FragmentSplitCommonSubstructure</td>
        <td>operator ()( const ConformationInterface &CONFORMATION) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_conformations.h</td>
        <td>FragmentSplitConformations</td>
        <td>FragmentSplitConformations()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_conformations.h</td>
        <td>FragmentSplitConformations</td>
        <td>GetMinSize() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_conformations.h</td>
        <td>FragmentSplitConformations</td>
        <td>operator ()( const ConformationInterface &MOLECULE) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_ecfp_fragments.h</td>
        <td>FragmentSplitECFPFragments</td>
        <td>FragmentSplitECFPFragments( const size_t &STEPS = 4)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_ecfp_fragments.h</td>
        <td>FragmentSplitECFPFragments</td>
        <td>GetClassDescription() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_ecfp_fragments.h</td>
        <td>FragmentSplitECFPFragments</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_ecfp_fragments.h</td>
        <td>FragmentSplitECFPFragments</td>
        <td>GetMinSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_gadd_fragments.h</td>
        <td>FragmentSplitGADDFragments</td>
        <td>FragmentSplitGADDFragments()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_gadd_fragments.h</td>
        <td>FragmentSplitGADDFragments</td>
        <td>GetClassDescription() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_gadd_fragments.h</td>
        <td>FragmentSplitGADDFragments</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_gadd_fragments.h</td>
        <td>FragmentSplitGADDFragments</td>
        <td>GetMinSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_interface.h</td>
        <td>FragmentSplitInterface</td>
        <td>ConvertComponentsIntoEnsemble( const ConformationInterface &MOLECULE, const storage::List< storage::Vector< size_t> > &COMPONENTS, const ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH, const bool &INVERT_OUTPUT = false ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_interface.h</td>
        <td>FragmentSplitInterface</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_interface.h</td>
        <td>FragmentSplitInterface</td>
        <td>operator ()( const ConformationInterface &CONFORMATION) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_isolate.h</td>
        <td>FragmentSplitIsolate</td>
        <td>FragmentSplitIsolate( const size_t MIN_SIZE = size_t( 2))
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_isolate.h</td>
        <td>FragmentSplitIsolate</td>
        <td>GetClassDescription() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_isolate.h</td>
        <td>FragmentSplitIsolate</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_isolate.h</td>
        <td>FragmentSplitIsolate</td>
        <td>GetMinSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_largest_component.h</td>
        <td>FragmentSplitLargestComponent</td>
        <td>FragmentSplitLargestComponent( const size_t MIN_SIZE = size_t( 2))
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_largest_component.h</td>
        <td>FragmentSplitLargestComponent</td>
        <td>GetClassDescription() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_largest_component.h</td>
        <td>FragmentSplitLargestComponent</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_largest_component.h</td>
        <td>FragmentSplitLargestComponent</td>
        <td>GetMinSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_linear_fragments.h</td>
        <td>FragmentSplitLinearFragments</td>
        <td>FragmentSplitLinearFragments( const size_t &STEPS = 7)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_linear_fragments.h</td>
        <td>FragmentSplitLinearFragments</td>
        <td>GetClassDescription() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_linear_fragments.h</td>
        <td>FragmentSplitLinearFragments</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_linear_fragments.h</td>
        <td>FragmentSplitLinearFragments</td>
        <td>GetFragments( const ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH, const storage::Set< size_t> &CURRENT_CHAIN, const size_t &CURRENT_INDEX, storage::Set< storage::Vector< size_t> > &FRAGMENTS, const size_t &MAX_STEPS, const bool &IGNORE_H = false ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_linear_fragments.h</td>
        <td>FragmentSplitLinearFragments</td>
        <td>GetMinSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_rigid.h</td>
        <td>FragmentSplitRigid</td>
        <td>FragmentSplitRigid( const size_t MIN_SIZE = size_t( 1), const bool &CONSIDER_AMIDE_RIGID = true)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_rigid.h</td>
        <td>FragmentSplitRigid</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_rigid.h</td>
        <td>FragmentSplitRigid</td>
        <td>GetMinSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_rings.h</td>
        <td>FragmentSplitRings</td>
        <td>FragmentSplitRings( bool GET_RINGS, const size_t MIN_SIZE = size_t( 2))
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_rings.h</td>
        <td>FragmentSplitRings</td>
        <td>GetClassDescription() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_rings.h</td>
        <td>FragmentSplitRings</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_rings.h</td>
        <td>FragmentSplitRings</td>
        <td>GetMinSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_rings_with_unsaturated_substituents.h</td>
        <td>FragmentSplitRingsWithUnsaturatedSubstituents</td>
        <td>GetClassDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_rings_with_unsaturated_substituents.h</td>
        <td>FragmentSplitRingsWithUnsaturatedSubstituents</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_rings_with_unsaturated_substituents.h</td>
        <td>FragmentSplitRingsWithUnsaturatedSubstituents</td>
        <td>GetMinSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_scaffolds.h</td>
        <td>FragmentSplitScaffolds</td>
        <td>FragmentSplitScaffolds( const size_t MIN_SIZE = size_t( 2), const bool &INVERT = false)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_scaffolds.h</td>
        <td>FragmentSplitScaffolds</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_scaffolds.h</td>
        <td>FragmentSplitScaffolds</td>
        <td>GetMinSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_unbridged_rings.h</td>
        <td>FragmentSplitUnbridgedRings</td>
        <td>FragmentSplitUnbridgedRings( bool GET_AROMATIC, const size_t MAX_SIZE = size_t( 100))
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_unbridged_rings.h</td>
        <td>FragmentSplitUnbridgedRings</td>
        <td>GetClassDescription() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_unbridged_rings.h</td>
        <td>FragmentSplitUnbridgedRings</td>
        <td>GetComponentVertices( const ConformationInterface &MOLECULE, ConformationGraphConverter::t_AtomGraph &MOLECULE_GRAPH ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_unbridged_rings.h</td>
        <td>FragmentSplitUnbridgedRings</td>
        <td>GetMaxSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_split_unbridged_rings.h</td>
        <td>FragmentSplitUnbridgedRings</td>
        <td>GetMinSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_split_unbridged_rings.h</td>
        <td>FragmentSplitUnbridgedRings</td>
        <td>IsBridgeHead( const AtomConformationalInterface &ATOM)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>ConformerSwap( const FragmentEnsemble &ENSEMBLE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>FragmentStochasticPoseOptimizer( const descriptor::CheminfoProperty &PROPERTY_SCORER, const storage::Vector< float> &BFACTORS, const std::string &MDL, const std::string &BINDING_POCKET_FILENAME, const size_t &ITERATIONS, const size_t &ATTEMPTS, const size_t &REFINEMENT_ITERATIONS, const float &TEMPERATURE = 1.0, const opti::Tracker< FragmentComplete, double> &OPTI = opti::e_SmallerIsBetter, const float &VDW_CLASH_CUTOFF = 5.0 )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>FragmentStochasticPoseOptimizer()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>GetBFactors() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>GetBestScoringNonClashingPose( const FragmentEnsemble &ENSEMBLE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>GetMDL() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>GetMutex()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>GetPocket() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>GetPocketFilename() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>GoodLigandVDWScore( const FragmentComplete &MOLECULE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>MCMDocker( const FragmentEnsemble &ENSEMBLE, const bool &LOCAL = false )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>OptimizePoseConf( const FragmentEnsemble &ENSEMBLE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>PerturbMoleculePose( const FragmentComplete &MOLECULE, const FragmentEnsemble &CONF_ENSEMBLE = FragmentEnsemble() )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>ProteinLigandClash( const FragmentComplete &MOLECULE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>ResolveClashes( const FragmentEnsemble &ENSEMBLE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>RunMCMDocker( const FragmentEnsemble &ENSEMBLE, const bool &LOCAL = false, const bool &REFINE = true )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_stochastic_pose_optimizer.h</td>
        <td>FragmentStochasticPoseOptimizer</td>
        <td>StochasticPoseOptimization( const FragmentEnsemble &ENSEMBLE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_swap_amide.h</td>
        <td>FragmentSwapAmide</td>
        <td>FragmentSwapAmide( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_swap_amide.h</td>
        <td>FragmentSwapAmide</td>
        <td>FragmentSwapAmide( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_swap_amide.h</td>
        <td>FragmentSwapAmide</td>
        <td>FragmentSwapAmide( const std::string &DRUG_LIKENESS_TYPE, const FragmentComplete &REFERENCE_FRAGMENT, const FragmentComplete &SCAFFOLD_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOM_INDICES, const std::string &MDL, const descriptor::CheminfoProperty &PROPERTY_SCORER, const bool &RESOLVE_CLASHES, const storage::Vector< float> &BFACTORS, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_swap_amide.h</td>
        <td>FragmentSwapAmide</td>
        <td>FragmentSwapAmide( const std::string &DRUG_LIKENESS_TYPE, const bool &CORINA_CONFS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_swap_amide.h</td>
        <td>FragmentSwapAmide</td>
        <td>FragmentSwapAmide()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_swap_amide.h</td>
        <td>FragmentSwapAmide</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_track_mutable_atoms.h</td>
        <td>FragmentTrackMutableAtoms</td>
        <td>FragmentTrackMutableAtoms()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_track_mutable_atoms.h</td>
        <td>FragmentTrackMutableAtoms</td>
        <td>GetBaseFragment( const FragmentComplete &FRAGMENT, const FragmentComplete &MUTATABLE_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOMS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_track_mutable_atoms.h</td>
        <td>FragmentTrackMutableAtoms</td>
        <td>GetRandomBaseFragment( const FragmentComplete &FRAGMENT, const util::Implementation< FragmentSplitInterface> &SPLITTER )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_track_mutable_atoms.h</td>
        <td>FragmentTrackMutableAtoms</td>
        <td>GetRandomRestrictedBaseFragment( const FragmentComplete &FRAGMENT, const FragmentSplitInterface &SPLITTER, const FragmentComplete &MUTATABLE_FRAGMENT, const storage::Vector< size_t> &MUTABLE_ATOMS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_fragment_track_mutable_atoms.h</td>
        <td>FragmentTrackMutableAtoms</td>
        <td>LocalRandomPickAtom( const FragmentComplete &FRAGMENT, const FragmentComplete &REF_FRAGMENT )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_fragment_track_mutable_atoms.h</td>
        <td>FragmentTrackMutableAtoms</td>
        <td>RandomPickAtom( const FragmentComplete &FRAGMENT)
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_has_properties.h</td>
        <td>HasProperties</td>
        <td>GetStoredProperties() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_has_properties.h</td>
        <td>HasProperties</td>
        <td>GetStoredPropertiesNonConst()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_has_properties.h</td>
        <td>HasProperties</td>
        <td>HasProperties( const HasPropertiesInterface< t_OtherBaseType> &PROPERTIES)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_has_properties.h</td>
        <td>HasProperties</td>
        <td>HasProperties( const SmallMoleculeMiscProperties &STORED_PROPERTIES)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_has_properties.h</td>
        <td>HasProperties</td>
        <td>HasProperties()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_has_properties_interface.h</td>
        <td>HasPropertiesInterface</td>
        <td>GetMDLProperty( const std::string &NAME) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_has_properties_interface.h</td>
        <td>HasPropertiesInterface</td>
        <td>GetMDLPropertyAsVector( const std::string &NAME) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_has_properties_interface.h</td>
        <td>HasPropertiesInterface</td>
        <td>IsPropertyStored( const std::string &NAME) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_has_properties_interface.h</td>
        <td>HasPropertiesInterface</td>
        <td>RemoveProperty( const std::string &NAME)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_has_properties_interface.h</td>
        <td>HasPropertiesInterface</td>
        <td>ResetStoredProperties()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_has_properties_interface.h</td>
        <td>HasPropertiesInterface</td>
        <td>StoreProperties( const HasPropertiesInterface< t_BaseClass> &BASE)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_has_properties_interface.h</td>
        <td>HasPropertiesInterface</td>
        <td>StoreProperty( const std::string &NAME, const std::string &PROPERTY)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_has_properties_interface.h</td>
        <td>HasPropertiesInterface</td>
        <td>StoreProperty( const std::string &NAME, const t_VectorType &PROPERTY)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_hybrid_orbital_type_data.h</td>
        <td>HybridOrbitalTypeData</td>
        <td>GetNumberOfPossibleSigmaBondingPartners() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_hybrid_orbital_type_data.h</td>
        <td>HybridOrbitalTypeData</td>
        <td>GetOrbitals() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_hybrid_orbital_type_data.h</td>
        <td>HybridOrbitalTypeData</td>
        <td>HybridOrbitalTypeData( const storage::Set< AtomicOrbitalTypesEnum> &ORBITALS )
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_hybrid_orbital_type_data.h</td>
        <td>HybridOrbitalTypeData</td>
        <td>HybridOrbitalTypeData()
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_hybrid_orbital_types.h</td>
        <td>HybridOrbitalTypes</td>
        <td>HybridOrbitalTypes()
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_hybrid_orbital_types.h</td>
        <td></td>
        <td>GetHybridOrbitalTypes()
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_hydrogens_handler.h</td>
        <td>HydrogensHandler</td>
        <td>DetermineCoordinates( const AtomComplete &ATOM)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_hydrogens_handler.h</td>
        <td>HydrogensHandler</td>
        <td>GetIdealizedGeometry( const HybridOrbitalType &ORBITAL_TYPE, const double &BOND_LENGTH )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_hydrogens_handler.h</td>
        <td>HydrogensHandler</td>
        <td>HandleHydrogenPref( AtomVector< AtomComplete> &ATOMS, const sdf::HydrogenHandlingPref &H_PREF, const storage::Vector< size_t> &ADD_H )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_hydrogens_handler.h</td>
        <td>HydrogensHandler</td>
        <td>Remove( AtomVector< AtomComplete> &ATOMS)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_hydrogens_handler.h</td>
        <td>HydrogensHandler</td>
        <td>Saturate( AtomVector< AtomComplete> &ATOMS)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_hydrogens_handler.h</td>
        <td>HydrogensHandler</td>
        <td>SaturatePartial( AtomVector< AtomComplete> &ATOMS, const storage::Vector< size_t> &ADD_H)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_hydrogens_handler.h</td>
        <td>HydrogensHandler</td>
        <td>SetUndefinedHCoordinates( const AtomComplete &ATOM, AtomVector< AtomComplete> &VECT)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_hydrogens_handler.h</td>
        <td>HydrogensHandler</td>
        <td>UpdateHCoordinates( const AtomComplete &ATOM, AtomVector< AtomComplete> &VECT)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ligand_design_helper.h</td>
        <td>LigandDesignHelper</td>
        <td>CalculateProperties( const std::string &MOLECULE, const std::string &PROPERTIES )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ligand_design_helper.h</td>
        <td>LigandDesignHelper</td>
        <td>GetAvailablePredictions()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ligand_design_helper.h</td>
        <td>LigandDesignHelper</td>
        <td>GetAvailableProperties()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ligand_design_helper.h</td>
        <td>LigandDesignHelper</td>
        <td>ProcessMolecule( const std::string &MOLECULE, const std::string &DESCRIPTORS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ligand_design_helper.h</td>
        <td>LigandDesignHelper</td>
        <td>SetJarDirectory( const std::string &JAR_FILE_DIR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>CollisionScore( const FragmentComplete &MOL, const FragmentComplete &POCK, const storage::Vector< double> &BFACTOR = storage::Vector< double>(), const bool &STARTING_POSE_BIAS = false ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>GetSerializer() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>LigandPocketFitScore( const FragmentComplete &POCKET )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>LigandPocketFitScore( const FragmentComplete &POCKET, const linal::Vector3D &START_POSITION )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>LigandPocketFitScore()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>Prepare( const ConformationInterface &MOLECULE) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>PropertyCorrelationScore( const FragmentComplete &MOL, const FragmentComplete &POCK ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ligand_pocket_fit_score.h</td>
        <td>LigandPocketFitScore</td>
        <td>operator ()( const FragmentComplete &MOLECULE, const FragmentComplete &POCKET ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_merge_fragment_complete.h</td>
        <td>MergeFragmentComplete</td>
        <td>MergeFragmentParts( const FragmentComplete &MOLECULE_A, const FragmentComplete &MOLECULE_B, const storage::Map< size_t, size_t> &COMMON_INDICES, const AtomComplete &NEIGHBOR_ATOM, const size_t EDGE_DATA, const bool PERPENDICULAR_RING )
</td>
        <td>geanesar, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_merge_fragment_complete.h</td>
        <td>MergeFragmentComplete</td>
        <td>MergeFragments( const FragmentComplete &MOLECULE_A, const FragmentComplete &MOLECULE_B, const ConfigurationalBondType &BOND_TYPE, const storage::Pair< size_t, size_t> &INDICES_TO_CONNECT )
</td>
        <td>geanesar, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_merge_fragment_complete.h</td>
        <td>MergeFragmentComplete</td>
        <td>MergeFragments( const FragmentComplete &MOLECULE_A, const FragmentComplete &MOLECULE_B, const storage::Map< size_t, size_t> &COMMON_INDICES, storage::Vector< size_t> &APPENDED_ATOMS )
</td>
        <td>geanesar, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_merge_fragment_complete.h</td>
        <td>MergeFragmentComplete</td>
        <td>MultipointMergeFragments( const FragmentComplete &MOLECULE_A, const FragmentComplete &MOLECULE_B, const storage::List< ConfigurationalBondType> &BOND_TYPES, const storage::List< storage::Pair< size_t, size_t> > &INDICES_TO_CONNECT )
</td>
        <td>geanesar, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_minimize_ligand_in_pocket.h</td>
        <td>MinimizeLigandInPocket</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_minimize_ligand_in_pocket.h</td>
        <td>MinimizeLigandInPocket</td>
        <td>MinimizeLigandInPocket( const size_t &ITERATIONS, const size_t &ITERATION_LIMIT, const linal::Vector3D &START_POSITION )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_minimize_ligand_in_pocket.h</td>
        <td>MinimizeLigandInPocket</td>
        <td>MinimizeLigandInPocket( const size_t &ITERATIONS, const size_t &ITERATION_LIMIT, const linal::Vector3D &START_POSITION, const std::string &MOVIE_FILENAME )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_minimize_ligand_in_pocket.h</td>
        <td>MinimizeLigandInPocket</td>
        <td>MinimizeLigandInPocket()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_minimize_ligand_in_pocket.h</td>
        <td>MinimizeLigandInPocket</td>
        <td>OrientLigandInPocketEngine( const FragmentComplete &MOL, const FragmentComplete &POCK, const size_t &ITERATIONS, const size_t &ITERATION_LIMIT, const linal::Vector3D &START_POS ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_minimize_ligand_in_pocket.h</td>
        <td>MinimizeLigandInPocket</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_minimize_ligand_in_pocket.h</td>
        <td>MinimizeLigandInPocket</td>
        <td>operator ()( const ConformationInterface &MOLECULE, const ConformationInterface &POCKET ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecular_configuration_shared.h</td>
        <td>MolecularConfigurationShared</td>
        <td>MolecularConfigurationShared( const ConformationInterface &CONFORMATION)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecular_configuration_shared.h</td>
        <td>MolecularConfigurationShared</td>
        <td>MolecularConfigurationShared( const util::ShPtr< MolecularConstitutionShared> &CONSTITUTION, const AtomVector< AtomConfigurationalShared> &ATOMCONFIGURATION )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecular_configuration_shared.h</td>
        <td>MolecularConfigurationShared</td>
        <td>MolecularConfigurationShared()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecular_conformation_shared.h</td>
        <td>MolecularConformationShared</td>
        <td>MolecularConformationShared( const ConformationInterface &CONFORMATION)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecular_conformation_shared.h</td>
        <td>MolecularConformationShared</td>
        <td>MolecularConformationShared( const util::ShPtr< MolecularConfigurationShared> &CONFIGURATION, const AtomVector< AtomConformationalShared> &ATOMCONFIGURATION )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecular_conformation_shared.h</td>
        <td>MolecularConformationShared</td>
        <td>MolecularConformationShared()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecular_constitution_shared.h</td>
        <td>MolecularConstitutionShared</td>
        <td>MolecularConstitutionShared( const AtomVector< AtomConstitutionalShared> &CONSTITUTION)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecular_constitution_shared.h</td>
        <td>MolecularConstitutionShared</td>
        <td>MolecularConstitutionShared( const ConformationInterface &CONFORMATION)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecular_constitution_shared.h</td>
        <td>MolecularConstitutionShared</td>
        <td>MolecularConstitutionShared()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_complete.h</td>
        <td>MoleculeComplete</td>
        <td>GetNumberValences() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_complete.h</td>
        <td>MoleculeComplete</td>
        <td>MoleculeComplete( const t_DataType &CONSTRUCTOR_OBJECT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_complete.h</td>
        <td>MoleculeComplete</td>
        <td>MoleculeComplete()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>Append( const MoleculeEnsemble &ENSEMBLE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>Begin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>End()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>GetMolecules()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>GetMolecules() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>MoleculeEnsemble( const storage::List< MoleculeComplete> &MOLECULES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>MoleculeEnsemble( std::istream &ISTREAM, const math::Range< size_t> &RANGE = math::Range< size_t>( 0, std::numeric_limits< size_t>::max()) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>MoleculeEnsemble()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>PushBack( const MoleculeComplete &MOL_OBJ)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>ReadMoreFromMdl( std::istream &ISTREAM, const math::Range< size_t> &RANGE = math::Range< size_t>( 0, std::numeric_limits< size_t>::max()) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_ensemble.h</td>
        <td>MoleculeEnsemble</td>
        <td>WriteMDL( std::ostream &OSTREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>BuserScore( const MoleculeEnvironment &OTHER) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>GetAtomType() const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>GetMoleculeEnvironment() const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>MoleculeEnvironment( const MoleculeEnvironment &OTHER)
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>MoleculeEnvironment( const t_AtomType &ATOM_TYPE)
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>MoleculeEnvironment( const t_AtomType &ATOM_TYPE, const ConformationInterface &FRAGMENT)
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>MoleculeEnvironment()
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>TanimotoScore( const MoleculeEnvironment &OTHER) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>operator !=( const MoleculeEnvironment &MOLECULE) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>operator ()( const ConformationInterface& OTHER, const ConformationInterface& THIS ) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_environment.h</td>
        <td>MoleculeEnvironment</td>
        <td>operator ==( const MoleculeEnvironment &ATOM) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>AverageFeatures( const FragmentComplete &SCAFFOLD, const FragmentEnsemble &MOLECULES, const std::vector< std::vector< std::map< size_t, float> > > &MAPS = std::vector< std::vector< std::map< size_t, float> > >(), const ConformationGraphConverter::AtomComparisonType &ATOM_COMPARISON_TYPE = ConformationGraphConverter::e_ElementType, const ConfigurationalBondTypeData::Data &BOND_TYPE_INFO = ConfigurationalBondTypeData::e_BondOrderOrAromatic ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>CompareCommonStructs( const storage::Vector< size_t> &SCAFF_ISO_MOL_1, const std::map< size_t, float> &PERTURBS_MOL_1, const storage::Vector< size_t> &SCAFF_ISO_MOL_2, const std::map< size_t, float> &PERTURBS_MOL_2 ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>CompareSubstructuresNaive( const FragmentComplete &MOLECULE, const FragmentEnsemble &ENSEMBLE, const ConformationGraphConverter::AtomComparisonType &ATOM_TYPE = ConformationGraphConverter::e_ElementType, const ConfigurationalBondTypeData::Data &BOND_TYPE = ConfigurationalBondTypeData::e_BondOrderAmideOrAromaticWithRingness, const bool &NORMALIZE = false, const bool &IGNORE_H = false, const bool &AVERAGE = false, const size_t &MOL_INDEX = util::GetUndefinedSize_t(), const bool &OUTPUT_INTERMEDIATES = false ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>CompareSubstructuresRigorous( const FragmentComplete &MOLECULE, const FragmentEnsemble &ENSEMBLE, const ConformationGraphConverter::AtomComparisonType &ATOM_TYPE = ConformationGraphConverter::e_ElementType, const ConfigurationalBondTypeData::Data &BOND_TYPE = ConfigurationalBondTypeData::e_BondOrderAmideOrAromaticWithRingness, const bool &MUTUALLY_MATCHING_ATOMS = false, const bool &NORMALIZE = false, const bool &AVERAGE = false, const size_t &MOL_INDEX = util::GetUndefinedSize_t(), const bool &OUTPUT_INTERMEDIATES = false ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>ExtractFragments( const FragmentComplete &MOLECULE, const std::map< size_t, float> &ATOM_SCORES, const math::Range< float> &CONFIDENCE_INTERVAL ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>GetFeatureRMSDOnScaffold( const FragmentComplete &SCAFFOLD, const FragmentEnsemble &MOLS, const std::vector< std::vector< std::map< size_t, float> > > &MAPS, const ConformationGraphConverter::AtomComparisonType &ATOM_COMPARISON_TYPE = ConformationGraphConverter::e_ElementType, const ConfigurationalBondTypeData::Data &BOND_TYPE_INFO = ConfigurationalBondTypeData::e_BondOrderOrAromatic ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>MoleculeFeatureMapper( const util::ObjectDataLabel &SCORE_LABEL )
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>MoleculeFeatureMapper()
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>Perturb( const FragmentComplete &MOLECULE, const bool &IGNORE_H = false, const bool &SPLIT_LARGEST = false, storage::Vector< size_t> ATOM_INDICES = storage::Vector< size_t>() ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_feature_mapper.h</td>
        <td>MoleculeFeatureMapper</td>
        <td>PerturbByFragment( const FragmentComplete &MOLECULE, const util::Implementation< chemistry::FragmentSplitInterface> &SPLITTER, const ConformationGraphConverter::AtomComparisonType &ATOM_TYPE = ConformationGraphConverter::e_ElementType, const ConfigurationalBondTypeData::Data &BOND_TYPE = ConfigurationalBondTypeData::e_BondOrderAmideOrAromaticWithRingness, const bool &MUTUALLY_MATCHING_ATOMS = false, const bool &NORMALIZE = false, const bool &IGNORE_H = false, const bool &AVERAGE = false, const size_t &MOL_INDEX = util::GetUndefinedSize_t(), const bool &OUTPUT_INTERMEDIATES = false ) const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>CacheHashes( const FindType &TYPE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>Find( const ConformationInterface &MOLECULE, const FindType &TYPE = e_Conformation) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>GetAllKeys() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>GetFilename() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>GetFindTypeString( const FindType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>GetKeySize( const std::string &KEY) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>MoleculeStorageFile( const bool &STORE = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>Retrieve( const std::string &KEY) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>RetrieveEnsemble( const math::Range< size_t> &RANGE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>RetrieveEnsemble( const storage::Vector< std::string> &KEYS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_molecule_storage_file.h</td>
        <td>MoleculeStorageFile</td>
        <td>Store( const ConformationInterface &MOLECULE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_bond_angles.h</td>
        <td>MutateBondAngles</td>
        <td>GetFragmentData() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_bond_angles.h</td>
        <td>MutateBondAngles</td>
        <td>GetMoleculeDihedralBondIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_bond_angles.h</td>
        <td>MutateBondAngles</td>
        <td>GetProbability() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_bond_angles.h</td>
        <td>MutateBondAngles</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_bond_angles.h</td>
        <td>MutateBondAngles</td>
        <td>Mutate( const FragmentComplete &MOLECULE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_bond_angles.h</td>
        <td>MutateBondAngles</td>
        <td>Mutate( const FragmentComplete &MOLECULE, bool SWAP_Z ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_bond_angles.h</td>
        <td>MutateBondAngles</td>
        <td>MutateBondAngles( const util::ShPtr< BondAngleAssignment> &FRAGMENT, const FragmentComplete &MOLECULE, const MutateChirality &MUTATE_CHIRALITY, bool CHANGE_CHIRALITY = false, bool UNBIASED = false, bool SAMPLE_LENGTHS = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_bond_angles.h</td>
        <td>MutateBondAngles</td>
        <td>MutateBondAngles()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_bond_angles.h</td>
        <td>MutateBondAngles</td>
        <td>RotateBond( AtomVector< AtomComplete> &ATOM_INFO, const storage::Vector< size_t> &CONNECTED_ATOMS, double ANGULAR_CHANGE, const size_t &ORIGINATING_ATOM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>ApplyChirality( AtomVector< AtomComplete> &MOLECULE, const AtomVector< AtomComplete> &TEMPLATE, const bool &FORCE_ALTER_LABEL = false ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>ApplyDoubleBondIsometry( AtomVector< AtomComplete> &MOLECULE, const AtomVector< AtomComplete> &TEMPLATE, const bool &FORCE_ALTER_LABEL = false ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>GetBondInfo() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>GetChiralCenters() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>GetDownstreamAtoms( const size_t &ATOMA, const size_t &ATOMB) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>MutateChirality( const FragmentComplete &FRAGMENT, bool UNKNOWN_CHIRAL_ONLY = true)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>MutateChirality()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>MutateSpecificChirality( AtomVector< AtomComplete> &MOLECULE, const size_t &ATOM_INDEX, const bool &ALTER_CHIRALITY_LABEL = true, const bool &FORCE_ALTER_LABEL = false ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>MutateSpecificChirality( const FragmentComplete &MOLECULE, const size_t &ATOM_INDEX, const bool &ALTER_CHIRALITY_LABEL = true, const bool &FORCE_ALTER_LABEL = false ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_chirality.h</td>
        <td>MutateChirality</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_clash_resolver.h</td>
        <td>MutateClashResolver</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_clash_resolver.h</td>
        <td>MutateClashResolver</td>
        <td>MutateClashResolver( const double &MAX_CYCLES = 1.0 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_clash_resolver.h</td>
        <td>MutateClashResolver</td>
        <td>Setup( const FragmentComplete &CONF, const util::ShPtrVector< MutateBondAngles> &MUT_BA, const util::ShPtr< AtomClashScore> &CLASH )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_clash_resolver.h</td>
        <td>MutateClashResolver</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_dihedral_bond.h</td>
        <td>MutateDihedralBond</td>
        <td>GetAtomIndexA() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_dihedral_bond.h</td>
        <td>MutateDihedralBond</td>
        <td>GetAtomIndexB() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_dihedral_bond.h</td>
        <td>MutateDihedralBond</td>
        <td>GetAtomIndexC() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_dihedral_bond.h</td>
        <td>MutateDihedralBond</td>
        <td>GetAtomIndexD() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_dihedral_bond.h</td>
        <td>MutateDihedralBond</td>
        <td>GetConnectedAtoms() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_dihedral_bond.h</td>
        <td>MutateDihedralBond</td>
        <td>GetMoleculeDihedralBondIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_dihedral_bond.h</td>
        <td>MutateDihedralBond</td>
        <td>Mutate( const FragmentComplete &MOLECULE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_dihedral_bond.h</td>
        <td>MutateDihedralBond</td>
        <td>MutateDihedralBond( const AtomConformationalInterface &ATOM_B, const AtomConformationalInterface &ATOM_C, const graph::ConstGraph< size_t, size_t> &GRAPH, const FragmentComplete &MOLECULE, const bool &FLIP_ONLY, const bool &WIGGLE_ONLY )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_dihedral_bond.h</td>
        <td>MutateDihedralBond</td>
        <td>RemoveClash( const FragmentComplete &MOLECULE, const size_t &ATOM_A, const size_t &ATOM_B, const double &MIN_DISTANCE, const double &LOWER_BOUND=0.0, const double &UPPER_BOUND=400.0 ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_dihedrals_interface.h</td>
        <td>MutateDihedralsInterface</td>
        <td>GetChooseBestOnlyFlag() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_dihedrals_interface.h</td>
        <td>MutateDihedralsInterface</td>
        <td>GetChooseBestOnlySharedPointer()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_dihedrals_interface.h</td>
        <td>MutateDihedralsInterface</td>
        <td>MutateDihedralsInterface()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_dihedrals_interface.h</td>
        <td>MutateDihedralsInterface</td>
        <td>operator ()( const FragmentComplete &FRAGMENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>GetConnectedAtoms( const graph::UndirectedEdge< ConfigurationalBondType> &ATOM_INDICES, const graph::ConstGraph< size_t, size_t> &GRAPH )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>GetConnectedAtoms() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>GetDihedralAngle( const storage::Vector< sdf::AtomInfo> &ATOM_INFO, const storage::VectorND< 4, size_t> &DIHEDRAL_BOND )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>GetDihedralAngles( const storage::Vector< sdf::AtomInfo> &ATOM_INFO, const storage::Vector< storage::VectorND< 4, size_t> > &DIHEDRAL_BONDS )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>GetFragmentData() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>GetMoleculeDihedralBondIndices() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>GetProbability() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>GetScheme() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>Mutate( const FragmentComplete &MOLECULE ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>MutateFragment( const util::ShPtr< RotamerDihedralBondData> &FRAGMENT, const graph::ConstGraph< size_t, size_t> &GRAPH, const FragmentComplete &MOLECULE, const MutateChirality &MUTATE_CHIRALITY, bool CHANGE_CHIRALITY = false, bool UNBIASED = false, bool SAMPLE_DIHEDRALS = false, bool CHECK_AMIDE_PLANARITY = true )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>MutateFragment()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_fragment.h</td>
        <td>MutateFragment</td>
        <td>RotateBond( storage::Vector< sdf::AtomInfo> &ATOM_INFO, const storage::Vector< size_t> &CONNECTED_ATOMS, double NEW_ANGLE, double EXISTING_ANGLE )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_molecule_generic.h</td>
        <td>MutateMoleculeGeneric</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_molecule_generic.h</td>
        <td>MutateMoleculeGeneric</td>
        <td>MutateMoleculeGeneric( const std::string &MOVIE_FILENAME )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_molecule_generic.h</td>
        <td>MutateMoleculeGeneric</td>
        <td>MutateMoleculeGeneric()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_molecule_generic.h</td>
        <td>MutateMoleculeGeneric</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_molecule_generic.h</td>
        <td>MutateMoleculeGeneric</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_multi_fragment.h</td>
        <td>MutateMultiFragment</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_multi_fragment.h</td>
        <td>MutateMultiFragment</td>
        <td>MutateMultiFragment( const util::ShPtrVector< MutateDihedralsInterface> &FRAGMENT_MUTATES, const util::ShPtrVector< MutateDihedralsInterface> &DIHEDRAL_BOND_MUTATES_RANDOM, const double &RANDOM_DIHEDRAL_MUTATE_FREQUENCY, const size_t &N_DIHEDRALS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_mutate_multi_fragment.h</td>
        <td>MutateMultiFragment</td>
        <td>MutateMultiFragment()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_mutate_multi_fragment.h</td>
        <td>MutateMultiFragment</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_perturb_molecule_pose.h</td>
        <td>PerturbMoleculePose</td>
        <td>PerturbMoleculePose( const FragmentEnsemble &ENSEMBLE )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_perturb_molecule_pose.h</td>
        <td>PerturbMoleculePose</td>
        <td>PerturbMoleculePose( const FragmentEnsemble &ENSEMBLE, const float &ROT, const float &TRANS )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_perturb_molecule_pose.h</td>
        <td>PerturbMoleculePose</td>
        <td>PerturbMoleculePose()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_perturb_molecule_pose.h</td>
        <td>PerturbMoleculePose</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>Calculate( const std::string &DETAILS_FILENAME)
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>CalculateMaps( const FragmentComplete &SCAFFOLD, const FragmentEnsemble &INPUT_MOLECULES, const bool &REPLACE_ZERO_PROPERTIES = false, const float &SCORE_TOLERANCE = 0.0, const bool &BINARY = false )
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>CalculateMaps( const FragmentComplete &SCAFFOLD, const FragmentEnsemble &INPUT_MOLECULES, const size_t &USE )
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>CalculatePropertyDiffStatistics( const std::vector< PharmMapMolData> &DATA, const storage::Vector< storage::Pair< size_t, size_t> > &CHANGED_PAIRS ) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>CalculatePropertyDifferences( const std::vector< PharmMapMolData> &DATA, const storage::Vector< storage::Pair< size_t, size_t> > &CHANGED_PAIRS ) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>CalculateScoreDiffStatistics( const std::vector< PharmMapMolData> &DATA, const storage::Vector< storage::Pair< size_t, size_t> > &CHANGED_PAIRS ) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>FindScaffolds( const FragmentEnsemble &MOLECULES, const float &SAMPLING, const size_t &MIN_SCAFF_SIZE, const bool &PRINT_STATUS = false ) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>GetChangedGrowPoints( const storage::Map< size_t, storage::Vector< size_t> > &MOL_1_FRAGS, const storage::Map< size_t, storage::Vector< size_t> > &MOL_2_FRAGS, const graph::ConstGraph< size_t, size_t> &MOL_1_GRAPH, const graph::ConstGraph< size_t, size_t> &MOL_2_GRAPH, const storage::Vector< size_t> &GROW_POINT_INDICES ) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>GetMolecules() const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>GetProperties() const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>GetPropertyStrings() const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>MolecularFeatureMap( const FragmentComplete &SCAFFOLD, const FragmentEnsemble &MOLECULES, const util::ObjectDataLabel &MODEL, const std::string &OUT_PREFIX ) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>PharmacophoreMapper( const util::ObjectDataLabel &SCORE_LABEL, const util::ObjectDataLabel &PROPERTY_LABEL, const ConformationGraphConverter::AtomComparisonType &ATOM_COMPARISON_TYPE = ConformationGraphConverter::e_ElementType, const ConfigurationalBondTypeData::Data &BOND_TYPE_INFO = ConfigurationalBondTypeData::e_BondOrderAmideOrAromaticWithRingness )
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>ScoreMolecules( const FragmentComplete &SCAFFOLD, const FragmentEnsemble &MOLECULES, const storage::Map< size_t, linal::Vector< float> > &COEFF_MAP ) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>SetProperties( const util::ObjectDataLabel &PROPERTIES)
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>SetupMolData( const FragmentComplete &SCAFFOLD, const FragmentEnsemble &MOLECULES)
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>WriteDetailsCSV( const std::string &DETAILS_PREFIX) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>WriteDetailsMols( const std::string &DETAILS_PREFIX) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pharmacophore_mapper.h</td>
        <td>PharmacophoreMapper</td>
        <td>WriteMapsPML( const std::string &SCAFFOLD_FILENAME, const std::string &OUTPUT_FILENAME) const
</td>
        <td>geanesar, loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pick_atom_by_element.h</td>
        <td>PickAtomByElement</td>
        <td>GetElementType() const
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pick_atom_by_element.h</td>
        <td>PickAtomByElement</td>
        <td>GetSerializer() const
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pick_atom_by_element.h</td>
        <td>PickAtomByElement</td>
        <td>Pick( const util::SiPtrList< const AtomConformationalInterface> &ATOMS) const
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pick_atom_by_element.h</td>
        <td>PickAtomByElement</td>
        <td>PickAtomByElement( const ElementType &ELEMENT_TYPE)
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pick_atom_by_element.h</td>
        <td>PickAtomByElement</td>
        <td>PickAtomByElement()
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pick_atom_by_element.h</td>
        <td>PickAtomByElement</td>
        <td>SetElementType( const ElementType &ELEMENT_TYPE)
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pick_atom_random.h</td>
        <td>PickAtomRandom</td>
        <td>Pick( const util::SiPtrList< const AtomConformationalInterface> &ATOMS) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pick_fragment_property_weighted.h</td>
        <td>PickFragmentPropertyWeighted</td>
        <td>GetPropertyName() const
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pick_fragment_property_weighted.h</td>
        <td>PickFragmentPropertyWeighted</td>
        <td>Pick( const FragmentEnsemble &FRAGMENTS) const
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pick_fragment_property_weighted.h</td>
        <td>PickFragmentPropertyWeighted</td>
        <td>PickFragmentPropertyWeighted( const std::string &PROPERTY_NAME)
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pick_fragment_property_weighted.h</td>
        <td>PickFragmentPropertyWeighted</td>
        <td>PickFragmentPropertyWeighted()
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_pick_fragment_property_weighted.h</td>
        <td>PickFragmentPropertyWeighted</td>
        <td>SetPropertyName( const std::string &PROPERTY_NAME)
</td>
        <td>morettr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_pick_fragment_random.h</td>
        <td>PickFragmentRandom</td>
        <td>Pick( const FragmentEnsemble &FRAGMENTS) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>AddAtomType( const AtomType &ATOM_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>CouldBeConjugated() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>CouldHaveHybridization( const HybridOrbitalType &HYBRID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>Finalize( const AtomConformationalInterface &ATOM, const size_t &SMALLEST_RING_SIZE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>GetAlternateTypeWithCharge( const short &CHARGE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>GetAlternateTypes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>GetMaxElectronsParticipatingInPiSystem() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>GetMostStableType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>GetNumberPossibleTypes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>MustBeConjugated() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>PossibleAtomTypesForAtom( const ElementType &ELEMENT, const size_t &NUMBER_ELECTRONS_IN_BONDS, const size_t &NUMBER_BONDS, const short &SUSPECTED_CHARGE, const bool &IN_AROMATIC_RING )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>PossibleAtomTypesForAtom()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>SetToType( const AtomType &ATOM_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_possible_atom_types_for_atom.h</td>
        <td>PossibleAtomTypesForAtom</td>
        <td>WriteDetailedScheme( std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_priority_dihedral_angles.h</td>
        <td>PriorityDihedralAngles</td>
        <td>CalculateMultiplicity( const ConformationInterface &MOLECULE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_priority_dihedral_angles.h</td>
        <td>PriorityDihedralAngles</td>
        <td>GetDihedralEdges( const ConformationInterface &MOLECULE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_priority_dihedral_angles.h</td>
        <td>PriorityDihedralAngles</td>
        <td>GetPriority( const ConformationInterface &MOLECULE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_priority_dihedral_angles.h</td>
        <td>PriorityDihedralAngles</td>
        <td>GetWrappingAngle()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_priority_dihedral_angles.h</td>
        <td>PriorityDihedralAngles</td>
        <td>SetWrappingAngle( const double &WRAPPING_ANGLE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_priority_dihedral_angles.h</td>
        <td>PriorityDihedralAngles</td>
        <td>operator ()( const ConformationInterface &MOLECULE) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_priority_dihedral_angles.h</td>
        <td>PriorityDihedralAngles</td>
        <td>operator ()( const ConformationInterface &MOLECULE_A, const ConformationInterface &MOLECULE_B ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetDescription() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetNumberProducts() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetNumberReactants() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetNumberReactiveAtoms() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetProduct( const size_t &INDEX) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetProductStructures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetProducts() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetReactant( const size_t &INDEX) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetReactantStructures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetReactants() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetReactiveAtomsAllProducts() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetReactiveAtomsAllReactants() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetReactiveAtomsInProduct( const size_t &INDEX) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>GetReactiveAtomsInReactant( const size_t &INDEX) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>HasValidAtomMap() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>ReactionComplete( const storage::Vector< ReactionStructure> &REACTANTS, const storage::Vector< ReactionStructure> &PRODUCTS, const storage::Map< size_t, storage::Pair< size_t, size_t> > &REACTIVE_ATOMS_REACTANTS, const storage::Map< size_t, storage::Pair< size_t, size_t> > &REACTIVE_ATOMS_PRODUCTS, const std::string &DESCRIPTION = std::string() )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>ReactionComplete()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>Reverse()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>SetAtomMappings( const storage::Map< size_t, storage::Pair< size_t, size_t> > &REACTIVE_ATOMS_REACTANTS, const storage::Map< size_t, storage::Pair< size_t, size_t> > &REACTIVE_ATOMS_PRODUCTS )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>WriteRXN( std::ostream &OSTREAM) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_complete.h</td>
        <td>ReactionComplete</td>
        <td>operator ==( const ReactionComplete &OTHER) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>Append( const ReactionEnsemble &ENSEMBLE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>Begin()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>Begin() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>End()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>End() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>GetReactions()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>GetReactions() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>GetSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>IsEmpty() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>PushBack( const ReactionComplete &RXN_OBJ)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>ReactionEnsemble( const storage::List< ReactionComplete> &REACTIONS)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>ReactionEnsemble( std::istream &ISTREAM, const math::Range< size_t> &RANGE = math::Range< size_t>( 0, std::numeric_limits< size_t>::max()) )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>ReactionEnsemble()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>ReadMoreFromRXN( std::istream &ISTREAM, const math::Range< size_t> &RANGE = math::Range< size_t>( 0, std::numeric_limits< size_t>::max()) )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_ensemble.h</td>
        <td>ReactionEnsemble</td>
        <td>WriteRXN( std::ostream &OSTREAM) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>AddMolecule( const FragmentComplete &MOLECULE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>ChooseRandomAvailableRxn( const FragmentComplete &MOL ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>ChooseRandomReactants( const ReactionComplete_p &RXN_P ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>ChooseRandomRxnAndReactants( const FragmentComplete &MOLECULE ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>FindReactions( const ConformationInterface &MOLECULE) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>GetAvailableReactants( const ReactionComplete_p &REACTION ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>GetMolecules() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>GetReactions() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>GetStructureTree() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>Initialize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>IsEmpty() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>ReactionSearch( const FragmentEnsemble &REACTANTS = FragmentEnsemble(), const ReactionEnsemble &REACTIONS = ReactionEnsemble(), const bool &REMOVE_DEFICIENT_RXNS = true )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>ReactionSearch( const ReactionSearch &OTHER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>ReactionSearch( const std::string &REACTANT_FILENAME, const std::string &REACTION_DIRECTORY )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>RemoveReactantDeficientReactions() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>Reset()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_search.h</td>
        <td>ReactionSearch</td>
        <td>SetMolecules( const util::ShPtr< storage::Vector< FragmentComplete> > &MOLECULES)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>AromaticityMatches( const Aromaticity &QUERY, const Aromaticity &TEST)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>ContainedIn( const ConformationInterface &CONFORMATION) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>Contains( const ReactionStructure &OTHER) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>GetFragment() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>GetGraph() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>GetMatchingSubstructures( const ConformationInterface &CONFORMATION) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>GetSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>ReactionStructure( const FragmentComplete &FRAGMENT, const std::vector< Aromaticity> &AROMATICITY = std::vector< Aromaticity>() )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>ReactionStructure()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>SetAllowedAromaticity( const size_t &ATOM_NO, const Aromaticity &AROMATICITY)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_structure.h</td>
        <td>ReactionStructure</td>
        <td>operator ==( const ReactionStructure &OTHER) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>ReactionWorker</td>
        <td>ExecuteIntramolecularReaction( const ReactionComplete &REACTION, const FragmentComplete &MOLECULE ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>ReactionWorker</td>
        <td>ExecuteReaction( const ReactionComplete &REACTION, const FragmentEnsemble &MOLECULES ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>ReactionWorker</td>
        <td>IsSelfReactive( const ReactionComplete &REACTION, const FragmentComplete &MOLECULE ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>ReactionWorker</td>
        <td>MatchesProducts( const ConformationInterface &MOLECULE, const ReactionComplete &REACTION, const storage::Vector< size_t> &PRODUCT_NUMS = storage::Vector< size_t>() ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>ReactionWorker</td>
        <td>MatchesReactants( const ConformationInterface &MOLECULE, const ReactionComplete &REACTION, const storage::Vector< size_t> &REACTANT_NUMS = storage::Vector< size_t>() ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>ReactionWorker</td>
        <td>React( const ReactionComplete &REACTION, const FragmentEnsemble &MOLECULES ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>ReactionWorker</td>
        <td>ReactionWorker( const ConformationGraphConverter::AtomComparisonType &ATOM_COMPARISON = ConformationGraphConverter::e_ElementType, const ConfigurationalBondTypeData::Data &BOND_COMPARISON = ConfigurationalBondTypeData::e_BondOrderOrAromatic )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>ReactionWorker</td>
        <td>ReactionWorker( const ReactionWorker &OTHER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>ReactionWorker</td>
        <td>operator =( const ReactionWorker &OTHER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_reaction_worker.h</td>
        <td>SubstituentInfo</td>
        <td>SubstituentInfo()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ring_fragment_map.h</td>
        <td>RingFragmentMap</td>
        <td>GetConnectedVertices() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ring_fragment_map.h</td>
        <td>RingFragmentMap</td>
        <td>GetConnectedVerticesForRotation() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ring_fragment_map.h</td>
        <td>RingFragmentMap</td>
        <td>GetMoleculeAtom() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ring_fragment_map.h</td>
        <td>RingFragmentMap</td>
        <td>GetMoleculeAtomInRing() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_ring_fragment_map.h</td>
        <td>RingFragmentMap</td>
        <td>RingFragmentMap( const size_t MOLECULE_ATOM, bool MOLECULE_ATOM_IN_RING, const storage::Vector< size_t> &CONNECTED_VERTICES, const storage::Vector< size_t> &CONNECTED_VERTICES_FOR_ROTATION )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_ring_fragment_map.h</td>
        <td>RingFragmentMap</td>
        <td>RingFragmentMap()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>CalculateClusterCenters( size_t MAX_COUNTS)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>GetAverageStucture( size_t MAX_COUNTS)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>GetClusters() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>GetConfiguration() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>GetIsomorphismWeights( const storage::Vector< storage::Vector< size_t> > &ISO, const size_t &MOLECULE_SIZE )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>GetMaxInstance() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>GetMaxWeight() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>GetPriority() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>GetSimulatedWeightUnseenRotamers() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>GetStats() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>PruneNonPlanarAromaticRings()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>PruneRotamersByInstances( size_t CUT_OFF)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>PruneRotamersByWeight( double CUT_OFF)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>RotamerClusterCenter( const ConformationInterface &MOLECULE, const double BIN_SIZE = double( 30.0))
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>operator ()( const FragmentComplete &CONFORMATION, const double WEIGHT, const bool &SIMULATED = false )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_cluster_center.h</td>
        <td>RotamerClusterCenter</td>
        <td>operator ()( const graph::SubgraphIsomorphism< util::SiPtr< const AtomConformationalInterface>, size_t> &ATOM_ISO, const storage::Vector< storage::Vector< size_t> > &ISO, const std::string &NAME, const bool &SIMULATED = false )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>ContainsRingRotamers() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>ContainsRings() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetBinSize() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetCenterBondIsomorphism() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetCenterBondIsomorphisms() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetCenterBonds() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetFragment() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetFragmentCounts() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetImputedRotamerCounts( const linal::Vector< int> &BINS) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetIsomorphismWeights() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetIsomorphisms() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetMoleculeCenterBonds() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetNonRingBonds() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetRotamerBonds() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetRotamerCounts() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>GetRotamers() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>HasIncompleteRings() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>IfFullIntersection( const storage::Vector< size_t> &CONTAINER, const linal::Vector< size_t> &ELEMENTS )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>RotamerDihedralBondData( const ConformationInterface &MOLECULE, const SmallMoleculeFragmentIsomorphism &FRAGMENT, const storage::List< storage::Vector< size_t> > &ISOMORPHISMS )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_dihedral_bond_data.h</td>
        <td>RotamerDihedralBondData</td>
        <td>RotamerDihedralBondData()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>CalculateCenter( size_t MAX_COUNTS)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>GetAverage() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>GetClusterCenter() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>GetGraph() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>GetNumberInstances() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>GetRotamers() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>GetSimulatedInstances() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>GetWeights() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>RotamerEnsemble( const FragmentConformationShared &MOLECULE, const graph::ConstGraph< size_t, size_t> &GRAPH, const double WEIGHT, double BIN_SIZE, const bool &SIMULATED )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>RotamerEnsemble()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_ensemble.h</td>
        <td>RotamerEnsemble</td>
        <td>operator ()( const FragmentConformationShared &FRAGMENT, const double WEIGHT, const bool &SIMULATED = false)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>GetBondAngleMap() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>GetFileExtension() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>GetFilename() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>GetPrefix() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>GetRootConstitutions() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>GetRotamerFinder()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>IsDefined() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>RetrieveAssociatedConfigurations( const storage::Set< size_t> &IDS) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>RetrieveConfigurationMapping() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>RetrieveConstitution( const storage::Vector< size_t> &IDS) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>RetrieveRotamerRequirementsGraph() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>RetrieveRotamerSubstructureTree() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>RotamerLibraryFile( const std::string &ALIAS)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_library_file.h</td>
        <td>RotamerLibraryFile</td>
        <td>RotamerLibraryFile()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_library_interface.h</td>
        <td>RotamerLibraryInterface</td>
        <td>Create( FragmentEnsemble &CONFORMATIONS) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_rotamer_library_interface.h</td>
        <td>RotamerLibraryInterface</td>
        <td>CreateConstitutionGraphFromString( const storage::Vector< std::string> &GRAPH_VERTEX_EDGE_DATA, const storage::Vector< std::string> &MOLECULE_INFO ) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_rotamer_library_interface.h</td>
        <td>RotamerLibraryInterface</td>
        <td>GetDefault()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>CheckForWholeRings( const FragmentComplete &MOLECULE, const util::ShPtr< FragmentEnsemble> &FRAGMENTS ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>GetSerializer() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>HasUndefinedCoordinates( const ConformationInterface &MOLECULE) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>SampleConformations( const RotamerLibraryInterface &ROTAMER_LIBRARY, const std::string &CONFORMATION_COMPARER, const double &TOLERANCE, const size_t NUMBER_CONFORMATIONS, const size_t &MAX_ITERATIONS, const bool CHANGE_CHIRALITY, const double &RANDOM_DIHEDRAL_CHANGE_CHANCE = double( 0.0), bool GENERATE_3D = false, double CLASH_TOLERANCE = 0.1, bool CLUSTER = true, double NUMBER_CLASH_RESOLUTION_CYCLES = 0.1, std::string SCORES_FILENAME = Ó )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>SampleConformations()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>Sampling( const FragmentComplete &STARTING_ARGUMENT, FragmentEnsemble &CONFORMATION_SET, const util::ShPtr< math::MutateInterface< FragmentComplete> > &MUTATE, const FragmentProbabilityScore &SCORE, const size_t &MAX_ITERATIONS, const double &CLASH_TOLERANCE, bool &SHARED_CHOOSE_ONLY_BEST, AtomClashScore &SHARED_CLASH_SCORE ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>SetOutputScoreFilename( const std::string &FILENAME)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>SetSamplingPreferences( const bool &SAMPLE_DIHEDRALS, const bool &SAMPLE_RINGS, const bool &SAMPLE_BOND_ANGLES, const bool &SAMPLE_CHIRALITY )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_sample_conformations.h</td>
        <td>SampleConformations</td>
        <td>operator ()( const FragmentComplete &MOLECULE) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_score_function_generic.h</td>
        <td>ScoreFunctionGeneric</td>
        <td>GetSerializer() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_score_function_generic.h</td>
        <td>ScoreFunctionGeneric</td>
        <td>ScoreFunctionGeneric( const descriptor::CheminfoProperty &DESCRIPTOR )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_score_function_generic.h</td>
        <td>ScoreFunctionGeneric</td>
        <td>ScoreFunctionGeneric()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_score_function_generic.h</td>
        <td>ScoreFunctionGeneric</td>
        <td>operator ()( const FragmentComplete &MOLECULE ) const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_search_fragment_library_from_tree.h</td>
        <td>SearchFragmentLibraryFromTree</td>
        <td>CheckSubStructure( const graph::ConstGraph< size_t, size_t> &MOLECULE_GRAPH, const graph::ConstGraph< size_t, size_t> &FRAGMENT_GRAPH )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_search_fragment_library_from_tree.h</td>
        <td>SearchFragmentLibraryFromTree</td>
        <td>CreateFragmentIsomorphismObject( const FragmentComplete &MOLECULE, const graph::ConstGraph< size_t, size_t> &MOLECULE_GRAPH, const graph::ConstGraph< size_t, size_t> &FRAGMENT_GRAPH, const FragmentComplete &FRAGMENT )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_search_fragment_library_from_tree.h</td>
        <td>SearchFragmentLibraryFromTree</td>
        <td>FindFragmentsOfMolecule( const ConformationInterface &MOLECULE ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_search_fragment_library_from_tree.h</td>
        <td>SearchFragmentLibraryFromTree</td>
        <td>GetBondAngleAssignments( const ConformationInterface &MOLECULE, const bool &ENFORCE_CHIRALITY ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_search_fragment_library_from_tree.h</td>
        <td>SearchFragmentLibraryFromTree</td>
        <td>GetRotamerLibrary() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_search_fragment_library_from_tree.h</td>
        <td>SearchFragmentLibraryFromTree</td>
        <td>SearchFragmentLibraryFromTree( const RotamerLibraryInterface &FRAGMENT_LIBRARY)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_search_fragment_library_from_tree.h</td>
        <td>SearchFragmentLibraryFromTree</td>
        <td>SearchFragmentLibraryFromTree()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>ContainsIncompleteHydrogenation( const size_t &ISOMORPHISM_NUMBER) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>ContainsIncompleteRings( const size_t &ISOMORPHISM_NUMBER) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>ContainsOnlyIncompleteHydrogenation() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>ContainsRingConformations() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>ContainsRings() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetBestFreeEnergy() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetBestFreeEnergyNoIsometry() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetBinSize() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetDihedralAngleIndices() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetDihedralEdges() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetEstimatedMaxRotamers() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetExpectedFreeEnergy( const bool &CONSIDER_ISOMETRY) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetFragment() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetFragmentCSI() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetFragmentCounts() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetFragmentSize() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetMaxRotamerCount() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetMolecule() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetNumberAromaticRingSystems() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetNumberChainBonds() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetNumberChainSystems() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetNumberDihedralChainBonds() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetNumberRingBonds() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetNumberRingSystems() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetPseudocount()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetRotamerBins() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetRotamerCoordinates() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetRotamerCounts() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetRotamerDihedralFineEnergy( const linal::Vector< double> &ROTAMER_ANGLES, const linal::Vector< int> &ROTAMER ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetRotamerFreeEnergy( const linal::Vector< int> &ROTAMER, const bool &CONSIDER_ISOMETRY_CHANGES) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetRotamerNumbers() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetRotamers() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>GetRotatableBondNumber() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>IsDefined() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>SmallMoleculeFragmentIsomorphism( const FragmentComplete &MOLECULE, const FragmentComplete &FRAGMENT, const graph::SubgraphIsomorphism< size_t, size_t> &FRAGMENT_CSI, bool REMOVE_RING_ROTAMER_INFO_UNLESS_FRAGMENT_IS_JUST_A_RING = true )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_isomorphism.h</td>
        <td>SmallMoleculeFragmentIsomorphism</td>
        <td>SmallMoleculeFragmentIsomorphism()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_mapping.h</td>
        <td>SmallMoleculeFragmentMapping</td>
        <td>Filter( const util::ShPtrVector< RotamerDihedralBondData> &ROTAMERS )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_mapping.h</td>
        <td>SmallMoleculeFragmentMapping</td>
        <td>GetAllRings( const ConformationInterface &MOLECULE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_fragment_mapping.h</td>
        <td>SmallMoleculeFragmentMapping</td>
        <td>GetRingVertices( const ConformationInterface &MOLECULE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_fragment_mapping.h</td>
        <td>SmallMoleculeFragmentMapping</td>
        <td>MapFragmentIsomorphisms( const FragmentComplete &MOLECULE, const util::ShPtrVector< SmallMoleculeFragmentIsomorphism> &FRAGMENTS, const storage::Set< size_t> &SAMPLE_PARTS = storage::Set< size_t>() )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>Begin() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>End() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>GetMDLProperties() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>GetMDLProperty( const std::string &NAME) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>GetMDLPropertyAsVector( const std::string &NAME) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>GetSize() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>IsEmpty() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>Merge( const SmallMoleculeMiscProperties &PROPERTIES)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>RemoveConformationalDescriptors()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>RemoveProperty( const std::string &NAME)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>SetMDLProperty( const std::string &NAME, const std::string &VALUE)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>SetMDLProperty( const std::string &NAME, const t_VectorType &PROPERTY)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>SmallMoleculeMiscProperties( const SmallMoleculeMiscProperties &PROPERTIES_A, const SmallMoleculeMiscProperties &PROPERTIES_B )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>SmallMoleculeMiscProperties( const storage::Map< std::string, std::string> &PROPERTIES_MAP)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_misc_properties.h</td>
        <td>SmallMoleculeMiscProperties</td>
        <td>SmallMoleculeMiscProperties()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>GenerateDataSet()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>RequiresResultLabels() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>SmallMoleculeQsarStorageFile( const SmallMoleculeQsarStorageFile &PARENT)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_qsar_storage_file.h</td>
        <td>SmallMoleculeQsarStorageFile</td>
        <td>SmallMoleculeQsarStorageFile()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_string_properties_cached.h</td>
        <td>SmallMoleculeStringPropertiesCached</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_string_properties_cached.h</td>
        <td>SmallMoleculeStringPropertiesCached</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_string_properties_cached.h</td>
        <td>SmallMoleculeStringPropertiesCached</td>
        <td>SmallMoleculeStringPropertiesCached()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_string_properties_cached.h</td>
        <td>SmallMoleculeStringPropertiesCached</td>
        <td>operator ()( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_string_properties_mapped.h</td>
        <td>SmallMoleculeStringPropertiesMapped</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_string_properties_mapped.h</td>
        <td>SmallMoleculeStringPropertiesMapped</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_string_properties_mapped.h</td>
        <td>SmallMoleculeStringPropertiesMapped</td>
        <td>SmallMoleculeStringPropertiesMapped()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_string_properties_mapped.h</td>
        <td>SmallMoleculeStringPropertiesMapped</td>
        <td>operator ()( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_string_properties_name.h</td>
        <td>SmallMoleculeStringPropertiesName</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_string_properties_name.h</td>
        <td>SmallMoleculeStringPropertiesName</td>
        <td>operator ()( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_string_properties_numeric.h</td>
        <td>SmallMoleculeStringPropertiesNumeric</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_string_properties_numeric.h</td>
        <td>SmallMoleculeStringPropertiesNumeric</td>
        <td>PreReadHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_string_properties_numeric.h</td>
        <td>SmallMoleculeStringPropertiesNumeric</td>
        <td>SmallMoleculeStringPropertiesNumeric( const std::string &ALIAS = Ó)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_string_properties_numeric.h</td>
        <td>SmallMoleculeStringPropertiesNumeric</td>
        <td>operator ()( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_string_properties_types.h</td>
        <td>SmallMoleculeStringPropertiesTypes</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_small_molecule_string_properties_types.h</td>
        <td>SmallMoleculeStringPropertiesTypes</td>
        <td>SmallMoleculeStringPropertiesTypes( const std::string &ALIAS, const std::string &DESCRIPTION, const function::MemberConst< ConformationInterface, std::string> &FUNCTION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_small_molecule_string_properties_types.h</td>
        <td>SmallMoleculeStringPropertiesTypes</td>
        <td>operator ()( const ConformationInterface &MOLECULE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_solvents.h</td>
        <td></td>
        <td>IsDefined( const Solvents &SOLVENT)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_solvents.h</td>
        <td></td>
        <td>SolventFromString( const std::string &SOLVENT)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_stereocenters_handler.h</td>
        <td>StereocentersHandler</td>
        <td>AddChiralityFromConformation( AtomVector< AtomComplete> &MOLECULE)
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_stereocenters_handler.h</td>
        <td>StereocentersHandler</td>
        <td>CalculateFromConformation( const AtomConformationalInterface &ATOM )
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_stereocenters_handler.h</td>
        <td>StereocentersHandler</td>
        <td>CalculateFromConformation( const iterate::Generic< const AtomConformationalInterface> &MOLECULE )
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_stereocenters_handler.h</td>
        <td>StereocentersHandler</td>
        <td>DescriptorToChirality( const float &VALUE)
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_stereocenters_handler.h</td>
        <td>StereocentersHandler</td>
        <td>GetSubstituentsOrderedByPriority( const AtomConformationalInterface &BASE )
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_stereocenters_handler.h</td>
        <td>StereocentersHandler</td>
        <td>GetUniqueConnectedSubstituentsByPriority( const AtomConformationalInterface &BASE )
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_stereocenters_handler.h</td>
        <td>StereocentersHandler</td>
        <td>UpdateChiralityFromConformation( AtomComplete &ATOM)
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_sub_fragment.h</td>
        <td>SubFragment</td>
        <td>GetThisToNode() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_sub_fragment.h</td>
        <td>SubFragment</td>
        <td>GetThisToNodeSet() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_sub_fragment.h</td>
        <td>SubFragment</td>
        <td>GetThisToParent() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_sub_fragment.h</td>
        <td>SubFragment</td>
        <td>GetThisToParentSet() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_sub_fragment.h</td>
        <td>SubFragment</td>
        <td>SubFragment( const FragmentComplete &MOLECULE )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_sub_fragment.h</td>
        <td>SubFragment</td>
        <td>SubFragment( const SubFragment &PARENT_FRAGMENT, const storage::Vector< size_t> &SUB_INDICES )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_sub_fragment.h</td>
        <td>SubFragment</td>
        <td>SubFragment()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_substituent_conformational.h</td>
        <td>SubstituentConformational</td>
        <td>GetRootAtom() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_substituent_conformational.h</td>
        <td>SubstituentConformational</td>
        <td>SubstituentConformational( const AtomConformationalInterface &ATOM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_substituent_conformational.h</td>
        <td>SubstituentConformational</td>
        <td>SubstituentConformational()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_substituent_conformational.h</td>
        <td>SubstituentConformational</td>
        <td>operator <( const SubstituentConformational &RHS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_valence_handler.h</td>
        <td>ValenceHandler</td>
        <td>DetermineCoordinates( const AtomConformationalInterface &ATOM)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_valence_handler.h</td>
        <td>ValenceHandler</td>
        <td>GetIdealizedGeometry( const HybridOrbitalType &ORBITAL_TYPE, const double &BOND_LENGTH )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>ExtractPosition( const util::SiPtr< const AtomConformationalInterface> &ATOM) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_chemistry_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>IsSameItem( const AtomConformationalInterface &ITEM_1, const AtomConformationalInterface &ITEM_2) const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_chemistry_voxel_grid_atom.h</td>
        <td>VoxelGridAtom</td>
        <td>VoxelGridAtom( const double &RESOLUTION = 4.0, const bool &CACHE_EDGES = false)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_dendrogram.h</td>
        <td>Dendrogram</td>
        <td>Dendrogram( const util::ShPtr< LinkageInterface< t_DataType, t_PrecisionType> > &DISTANCE, const util::ShPtr< storage::List< t_DataType> > &DATA, const t_PrecisionType HEIGHT_CUTOFF, const util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> &BINARY_PREDICATE = ( **math::Comparisons< t_PrecisionType>::GetEnums().e_Less), const t_PrecisionType PRECLUSTER_THRESHOLD = util::GetUndefined< t_PrecisionType>(), const t_PrecisionType SIMILARITY_THRESHOLD = util::GetUndefined< t_PrecisionType>() )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_dendrogram.h</td>
        <td>Dendrogram</td>
        <td>Dendrogram( const util::ShPtr< LinkageInterface< t_DataType, t_PrecisionType> > &DISTANCE, const util::ShPtr< storage::List< t_DataType> > &DATA, const util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> &BINARY_PREDICATE = ( **math::Comparisons< t_PrecisionType>::GetEnums().e_Less), const t_PrecisionType PRECLUSTER_THRESHOLD = util::GetUndefined< t_PrecisionType>(), const t_PrecisionType SIMILARITY_THRESHOLD = util::GetUndefined< t_PrecisionType>() )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_dendrogram.h</td>
        <td>Dendrogram</td>
        <td>Dendrogram()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_dendrogram.h</td>
        <td>Dendrogram</td>
        <td>GetBinaryPredicate() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_dendrogram.h</td>
        <td>Dendrogram</td>
        <td>GetData() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_dendrogram.h</td>
        <td>Dendrogram</td>
        <td>GetHeightCutoff() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_dendrogram.h</td>
        <td>Dendrogram</td>
        <td>GetLinkage() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_dendrogram.h</td>
        <td>Dendrogram</td>
        <td>GetNode() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_dendrogram.h</td>
        <td>KeyCompare</td>
        <td>KeyCompare( const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &COMPARISON)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_dendrogram.h</td>
        <td>KeyCompare</td>
        <td>operator ()( const t_PrecisionType &LHV, const t_PrecisionType &RHV) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_dendrogram.h</td>
        <td></td>
        <td>AddInstance( new Dendrogram< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_dendrogram.h</td>
        <td></td>
        <td>operator ==( const Dendrogram< t_DataType, t_PrecisionType> &DENDROGRAM_A, const Dendrogram< t_DataType, t_PrecisionType> &DENDROGRAM_B )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_dendrogram_uncached.h</td>
        <td>DendrogramUncached</td>
        <td>DendrogramUncached( const util::ShPtr< LinkageInterface< t_DataType, t_PrecisionType> > &DISTANCE, const util::ShPtr< storage::List< t_DataType> > &DATA, const t_PrecisionType HEIGHT_CUTOFF, const util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> &BINARY_PREDICATE = ( **math::Comparisons< t_PrecisionType>::GetEnums().e_Less), const t_PrecisionType PRECLUSTER_THRESHOLD = util::GetUndefined< t_PrecisionType>(), const t_PrecisionType SIMILARITY_THRESHOLD = util::GetUndefined< t_PrecisionType>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_dendrogram_uncached.h</td>
        <td>DendrogramUncached</td>
        <td>DendrogramUncached( const util::ShPtr< LinkageInterface< t_DataType, t_PrecisionType> > &DISTANCE, const util::ShPtr< storage::List< t_DataType> > &DATA, const util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> &BINARY_PREDICATE = ( **math::Comparisons< t_PrecisionType>::GetEnums().e_Less), const t_PrecisionType PRECLUSTER_THRESHOLD = util::GetUndefined< t_PrecisionType>(), const t_PrecisionType SIMILARITY_THRESHOLD = util::GetUndefined< t_PrecisionType>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_dendrogram_uncached.h</td>
        <td>DendrogramUncached</td>
        <td>DendrogramUncached()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_dendrogram_uncached.h</td>
        <td>DendrogramUncached</td>
        <td>operator ()( const double HEIGHT_CUTOFF)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_dendrogram_uncached.h</td>
        <td>DendrogramUncached</td>
        <td>operator ()()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_dendrogram_uncached.h</td>
        <td></td>
        <td>AddInstance( new DendrogramUncached< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_distances_euclidean.h</td>
        <td>DistancesEuclidean</td>
        <td>DistancesEuclidean()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_distances_euclidean.h</td>
        <td>DistancesEuclidean</td>
        <td>operator ()( const storage::VectorND< 2, util::SiPtr< const linal::Vector< t_PrecisionType> > > &OBJECTS ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_distances_euclidean.h</td>
        <td></td>
        <td>AddInstance( new DistancesEuclidean< t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_distances_stored.h</td>
        <td>DistancesStored</td>
        <td>DistancesStored( const DistancesStored< t_DataType, t_PrecisionType> &DISTANCE_STORED)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_distances_stored.h</td>
        <td>DistancesStored</td>
        <td>DistancesStored( const storage::HashMap< size_t, storage::HashMap< size_t, t_PrecisionType> > &DATA )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_distances_stored.h</td>
        <td>DistancesStored</td>
        <td>DistancesStored()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_distances_stored.h</td>
        <td>DistancesStored</td>
        <td>GetData() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_distances_stored.h</td>
        <td>DistancesStored</td>
        <td>SetData( const storage::HashMap< size_t, storage::HashMap< size_t, t_PrecisionType> > &DATA )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_distances_stored.h</td>
        <td>DistancesStored</td>
        <td>operator ()( const storage::VectorND< 2, util::SiPtr< const t_DataType> > &OBJECTS) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_distances_stored.h</td>
        <td></td>
        <td>AddInstance( new DistancesStored< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_classes.h</td>
        <td></td>
        <td>GetInputClasses()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_features.h</td>
        <td>InputFeatures</td>
        <td>HandleInput( io::IFStream &IFSTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_features.h</td>
        <td>InputFeatures</td>
        <td>InputFeatures( const util::Implementation< model::RetrieveDataSetBase> &RETRIEVER, bool SCALE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_features.h</td>
        <td>InputFeatures</td>
        <td>InputFeatures()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_interface.h</td>
        <td>InputInterface</td>
        <td>GetInputObjects() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_interface.h</td>
        <td>InputInterface</td>
        <td>InputInterface( const InputInterface &INPUT_INTERFACE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_interface.h</td>
        <td>InputInterface</td>
        <td>InputInterface( const util::ShPtr< storage::List< t_DataType> > &OBJECTS )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_interface.h</td>
        <td>InputInterface</td>
        <td>InputInterface()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_interface.h</td>
        <td>InputInterface</td>
        <td>SetInputObjects( const util::ShPtr< storage::List< t_DataType> > &OBJECTS )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_pairwise_list.h</td>
        <td>InputPairwiseList</td>
        <td>HandleInput( io::IFStream &IFSTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_pairwise_list.h</td>
        <td>InputPairwiseList</td>
        <td>InputPairwiseList()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_pairwise_list.h</td>
        <td></td>
        <td>AddInstance( new InputPairwiseList< t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_table.h</td>
        <td>InputTable</td>
        <td>HandleInput( io::IFStream &IFSTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_table.h</td>
        <td>InputTable</td>
        <td>InputTable( const InputTable &INPUT_TABLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_table.h</td>
        <td>InputTable</td>
        <td>InputTable( const bool READ_UPPER_TRIANGLE, const bool READ_LOWER_TRIANGLE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_table.h</td>
        <td>InputTable</td>
        <td>InputTable()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_table.h</td>
        <td>InputTable</td>
        <td>StoreEntireMatrix( const storage::Table< t_PrecisionType> &TABLE, storage::HashMap< size_t, storage::HashMap< size_t, t_PrecisionType> > &DATA, const storage::List< std::string>::const_iterator &COLUMN_LAST_OBJECT_MAKER_ITERATOR ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_table.h</td>
        <td>InputTable</td>
        <td>StoreLowerTriangle( const storage::Table< t_PrecisionType> &TABLE, storage::HashMap< size_t, storage::HashMap< size_t, t_PrecisionType> > &DATA ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_input_table.h</td>
        <td>InputTable</td>
        <td>StoreUpperTriangle( const storage::Table< t_PrecisionType> &TABLE, storage::HashMap< size_t, storage::HashMap< size_t, t_PrecisionType> > &DATA ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_input_table.h</td>
        <td></td>
        <td>AddInstance( new InputTable())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_average.h</td>
        <td>LinkageAverage</td>
        <td>LinkageAverage( const LinkageAverage< t_DataType, t_PrecisionType> &LINKAGE_AVERAGE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_average.h</td>
        <td>LinkageAverage</td>
        <td>LinkageAverage( const util::ShPtr < math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &FUNCTION )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_average.h</td>
        <td>LinkageAverage</td>
        <td>LinkageAverage()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_average.h</td>
        <td>LinkageAverage</td>
        <td>operator ()( const Node< t_DataType, t_PrecisionType> &NODE_A, const Node< t_DataType, t_PrecisionType> &NODE_B) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_average.h</td>
        <td></td>
        <td>AddInstance( new LinkageAverage< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_classes.h</td>
        <td></td>
        <td>GetLinkageClasses()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_complete.h</td>
        <td>LinkageComplete</td>
        <td>LinkageComplete( const LinkageComplete< t_DataType, t_PrecisionType> &LINKAGE_COMPLETE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_complete.h</td>
        <td>LinkageComplete</td>
        <td>LinkageComplete( const util::ShPtr< math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &FUNCTION, const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &BINARY_PREDICATE )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_complete.h</td>
        <td>LinkageComplete</td>
        <td>LinkageComplete()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_complete.h</td>
        <td>LinkageComplete</td>
        <td>operator ()( const Node< t_DataType, t_PrecisionType> &NODE_A, const Node< t_DataType, t_PrecisionType> &NODE_B) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_complete.h</td>
        <td></td>
        <td>AddInstance( new LinkageComplete< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_interface.h</td>
        <td>LinkageInterface</td>
        <td>GetDistanceFunction() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_interface.h</td>
        <td>LinkageInterface</td>
        <td>LinkageInterface( const util::ShPtr < math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &FUNCTION )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_interface.h</td>
        <td>LinkageInterface</td>
        <td>LinkageInterface( const util::ShPtr < math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &FUNCTION, const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &BINARY_PREDICATE )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_interface.h</td>
        <td>LinkageInterface</td>
        <td>LinkageInterface()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_interface.h</td>
        <td>LinkageInterface</td>
        <td>SetBinaryPredicate( const util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> &BINARY_PREDICATE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_interface.h</td>
        <td>LinkageInterface</td>
        <td>SetDistanceFunction( const util::ShPtr< math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &DISTANCE_FUNCTION )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_interface.h</td>
        <td>LinkageInterface</td>
        <td>operator ()( const Node< t_DataType, t_PrecisionType> &NODE) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_single.h</td>
        <td>LinkageSingle</td>
        <td>LinkageSingle( const LinkageSingle< t_DataType, t_PrecisionType> &LINKAGE_SINGLE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_single.h</td>
        <td>LinkageSingle</td>
        <td>LinkageSingle( const util::ShPtr < math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &FUNCTION, const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &BINARY_PREDICATE )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_single.h</td>
        <td>LinkageSingle</td>
        <td>LinkageSingle()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_single.h</td>
        <td>LinkageSingle</td>
        <td>operator ()( const Node< t_DataType, t_PrecisionType> &NODE_A, const Node< t_DataType, t_PrecisionType> &NODE_B) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_single.h</td>
        <td></td>
        <td>AddInstance( new LinkageSingle< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_total.h</td>
        <td>LinkageTotal</td>
        <td>LinkageTotal( const LinkageTotal< t_DataType, t_PrecisionType> &LINKAGE_TOTAL)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_total.h</td>
        <td>LinkageTotal</td>
        <td>LinkageTotal( const util::ShPtr < math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &FUNCTION )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_total.h</td>
        <td>LinkageTotal</td>
        <td>LinkageTotal()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_linkage_total.h</td>
        <td>LinkageTotal</td>
        <td>operator ()( const Node< t_DataType, t_PrecisionType> &NODE_A, const Node< t_DataType, t_PrecisionType> &NODE_B) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_linkage_total.h</td>
        <td></td>
        <td>AddInstance( new LinkageTotal< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>CountNumberBaseNodes( const bool FOR_VISUALIZATION = false) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>ExpandAllNodes() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>GetCenter( const util::ShPtr< math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &MEMBER_DISTANCE_FUNCTION, const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &BINARY_PREDICATE ) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>GetGirth() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>GetIdentifier() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>GetMembers()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>GetNodes()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>GetOrphanedMembers() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>GetSmallestLargestDefinedGirth() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>IsLeaf() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>Node( const util::ShPtrList< Node< t_DataType, t_PrecisionType> > &NODES, const t_PrecisionType &GIRTH, const size_t IDENTIFIER = util::GetUndefinedSize_t())
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>Node( const util::ShPtrList< Node< t_DataType, t_PrecisionType> > &NODES, const util::SiPtrList< t_DataType> &MEMBERS, const t_PrecisionType &GIRTH, const size_t IDENTIFIER = util::GetUndefinedSize_t() )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>Node( const util::SiPtrList< t_DataType> &MEMBERS, const size_t IDENTIFIER = util::GetUndefinedSize_t())
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>Node()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>RemoveNodesBelowSize( const size_t SIZE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>RemoveNodesWithHighSimilarity( const t_PrecisionType GIRTH_CUTOFF, const util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> &BINARY_PREDICATE )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>RemoveNodesWithLowSimilarity( const t_PrecisionType GIRTH_CUTOFF, const util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> &BINARY_PREDICATE )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>RemoveSingularBranches()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>SetGirth( const t_PrecisionType GIRTH)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>SetIdentifier( const size_t IDENTIFIER)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>SetMembers( const util::SiPtrList< t_DataType> &MEMBERS)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td>Node</td>
        <td>SetNodes( const util::ShPtrList< Node< t_DataType, t_PrecisionType> > &NODES)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node.h</td>
        <td></td>
        <td>AddInstance( new Node< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node.h</td>
        <td></td>
        <td>operator ==( const Node< t_DataType, t_PrecisionType> &NODE_A, const Node< t_DataType, t_PrecisionType> &NODE_B )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node_colorer.h</td>
        <td>NodeColorer</td>
        <td>GetDefaultColor()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node_colorer.h</td>
        <td>NodeColorer</td>
        <td>NodeColorer( const util::ShPtr< util::FunctionInterface< Node< t_DataType, t_PrecisionType>, double> > &DESCRIPTION_FUNCTION, const util::ShPtr< util::FunctionInterface< double, linal::Vector3D> > &COLOR_FUNCTION )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node_colorer.h</td>
        <td>NodeColorer</td>
        <td>NodeColorer()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node_colorer.h</td>
        <td>NodeColorer</td>
        <td>operator ()( const Node< t_DataType, t_PrecisionType> &NODE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node_colorer.h</td>
        <td></td>
        <td>AddInstance( new NodeColorer< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node_description_average.h</td>
        <td>NodeDescriptionAverage</td>
        <td>NodeDescriptionAverage( const util::ShPtr< util::FunctionInterface< t_DataType, double> > &DESCRIPTION_FUNCTION )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node_description_average.h</td>
        <td>NodeDescriptionAverage</td>
        <td>NodeDescriptionAverage()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node_description_average.h</td>
        <td>NodeDescriptionAverage</td>
        <td>operator ()( const Node< t_DataType, t_PrecisionType> &NODE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node_description_average.h</td>
        <td></td>
        <td>AddInstance( new NodeDescriptionAverage< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node_description_from_file.h</td>
        <td>NodeDescriptionFromFile</td>
        <td>NodeDescriptionFromFile( const NodeDescriptionFromFile &DESCRIPTION)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node_description_from_file.h</td>
        <td>NodeDescriptionFromFile</td>
        <td>NodeDescriptionFromFile( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_node_description_from_file.h</td>
        <td>NodeDescriptionFromFile</td>
        <td>NodeDescriptionFromFile()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_node_description_from_file.h</td>
        <td>NodeDescriptionFromFile</td>
        <td>operator ()( const std::string &MEMBER) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_centers.h</td>
        <td>OutputCenters</td>
        <td>OutputCenters( const util::ShPtr< math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &MEMBER_DISTANCE_FUNCTION, const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &BINARY_PREDICATE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_centers.h</td>
        <td>OutputCenters</td>
        <td>OutputCenters()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_classes.h</td>
        <td></td>
        <td>GetOutputClasses()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>GetCylinderLength() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>GetCylinderRadius() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>GetCylinderSeparation() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>GetGirthLabelColor()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>GetLabelMaker() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>GetMaxNodeLabels() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>GetNodeColorer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>GetNumberLabelsAlongYScale() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>OutputPymol( const double CYLINDER_LENGTH, const double CYLINDER_RADIUS, const double CYLINDER_SEPARATION, const util::ShPtr< util::FunctionInterface< Node< t_DataType, t_PrecisionType>, linal::Vector3D> > &NODE_COLORER, const size_t MAX_NUMBER_LABELS, const util::ShPtr < util::FunctionInterface < storage::Triplet < util::SiPtr< const Node< t_DataType, t_PrecisionType> >, storage::VectorND< 4, double>, std::string >, std::string > > &LABEL_MAKER, const util::Color &COLOR, const size_t NUMBER_Y_LABELS, const bool SMALL_NODES_ON_BOTTOM, const storage::VectorND< 2, t_PrecisionType> &MIN_MAX_GIRTH, const bool SCALE_WITH_NODE_SIZE = true )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>OutputPymol()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>SetCylinderLength( const double NEW_CYLINDER_LENGTH)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>SetCylinderRadius( const double NEW_CYLINDER_RADIUS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>SetCylinderSeparation( const double NEW_CYLINDER_SEPARATION)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>SetLabelMaker( const util::ShPtr < util::FunctionInterface < storage::Triplet < util::SiPtr< const Node< t_DataType, t_PrecisionType> >, storage::VectorND< 4, double>, std::string >, std::string > > &LABEL_MAKER )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>SetMaxNodeLabels( const size_t NEW_MAX_NODE_LABELS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>SetNodeColorer( const util::ShPtr< util::FunctionInterface< Node< t_DataType, t_PrecisionType>, linal::Vector3D> > &NEW_COLORER )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>SetNumberLabelsAlongYScale( const size_t NEW_LABELS_ALONG_Y_SCALE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td>OutputPymol</td>
        <td>WriteOutput( const std::string &FILENAME, const util::SiPtrList< const Node< t_DataType, t_PrecisionType> > &NODE_LIST ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol.h</td>
        <td></td>
        <td>AddInstance( new OutputPymol< t_DataType, t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol.h</td>
        <td></td>
        <td>operator ==( const OutputPymol< t_DataType, t_PrecisionType> &OUTPUT_A, const OutputPymol< t_DataType, t_PrecisionType> &OUTPUT_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_protein_model_from_string.h</td>
        <td>OutputPymolLabelProteinModelFromString</td>
        <td>CleanString( std::string &STRING)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_protein_model_from_string.h</td>
        <td>OutputPymolLabelProteinModelFromString</td>
        <td>GetProteinModelFromString( const std::string &PDB_FILENAME )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_protein_model_from_string.h</td>
        <td>OutputPymolLabelProteinModelFromString</td>
        <td>ListNodeMembers( const Node< std::string, t_PrecisionType> &NODE, const std::string &LIST_FILENAME, const std::string &PREFIX = Ó, const std::string &POSTFIX = Ó )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_protein_model_from_string.h</td>
        <td>OutputPymolLabelProteinModelFromString</td>
        <td>OutputPymolLabelProteinModelFromString( const util::ShPtr < math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const std::string> >, t_PrecisionType> > &MEMBER_DISTANCE_FUNCTION, const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &DISTANCE_COMPARATOR, const std::string &PREFIX, const std::string &POSTFIX, const std::string &COLOR, const bool LIST_MEMBERS = false )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_protein_model_from_string.h</td>
        <td>OutputPymolLabelProteinModelFromString</td>
        <td>OutputPymolLabelProteinModelFromString()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_protein_model_from_string.h</td>
        <td>OutputPymolLabelProteinModelFromString</td>
        <td>operator ()( const storage::Triplet < util::SiPtr< const Node< std::string, t_PrecisionType> >, storage::VectorND< 4, double>, std::string > &TRIPLET ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_protein_model_from_string.h</td>
        <td></td>
        <td>AddInstance( new OutputPymolLabelProteinModelFromString< t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_small_molecule.h</td>
        <td>OutputPymolLabelSmallMolecule</td>
        <td>GetObjectNameLabel( const double X_COORDINATE, const double Y_COORDINATE_TOP, const double Y_COORDINATE_BOTTOM, const util::SiPtr< const std::string> NODE_CENTER, const double NODE_CYLINDER_DIAMETER, const util::Color &COLOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_small_molecule.h</td>
        <td>OutputPymolLabelSmallMolecule</td>
        <td>LoadPymolObject( const std::string &FILENAME, const std::string &PYMOL_OBJECT_NAME )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_small_molecule.h</td>
        <td>OutputPymolLabelSmallMolecule</td>
        <td>OutputPymolLabelSmallMolecule( const util::ShPtr < math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const std::string> >, t_PrecisionType> > &MEMBER_DISTANCE_FUNCTION, const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &DISTANCE_COMPARATOR, const std::string &SDF_FILENAME, const util::Color &COLOR, const bool WRITE_MEMBER_MDL = false )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_small_molecule.h</td>
        <td>OutputPymolLabelSmallMolecule</td>
        <td>OutputPymolLabelSmallMolecule()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_small_molecule.h</td>
        <td>OutputPymolLabelSmallMolecule</td>
        <td>TranslatePymolObject( const double X_COORDINATE, const double Y_COORDINATE, const double Z_COORDINATE, const std::string &PYMOL_OBJ_NAME )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_small_molecule.h</td>
        <td>OutputPymolLabelSmallMolecule</td>
        <td>operator ()( const storage::Triplet < util::SiPtr< const Node< std::string, t_PrecisionType> >, storage::VectorND< 4, double>, std::string > &TRIPLET ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_small_molecule.h</td>
        <td></td>
        <td>AddInstance( new OutputPymolLabelSmallMolecule< t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_string.h</td>
        <td>OutputPymolLabelString</td>
        <td>GetCylinderText( const std::string &TEXT_OBJECT_NAME, const double X_COORDINATE, const double Y_COORDINATE, const double Z_COORDINATE, const std::string &LABEL_TEXT, const double TEXT_CYLINDER_RADIUS, const double TEXT_BLOCK_SIZE, const util::Color &COLOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_string.h</td>
        <td>OutputPymolLabelString</td>
        <td>GetCylinderTextRadius( const double TEXT_BLOCK_SIZE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_string.h</td>
        <td>OutputPymolLabelString</td>
        <td>GetLabelCommand( const Node< t_DataType, t_PrecisionType> &NODE, const std::string &LABEL_OBJECT_NAME, const double X_COORDINATE, const double Y_COORDINATE_TOP, const double Y_COORDINATE_BOTTOM, const double NODE_CYLINDER_DIAMETER, const util::Color &COLOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_string.h</td>
        <td>OutputPymolLabelString</td>
        <td>GetTextBlockSize( const double Y_COORDINATE_TOP, const double Y_COORDINATE_BOTTOM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_string.h</td>
        <td>OutputPymolLabelString</td>
        <td>GetTextZCoordinate( const double NODE_CYLINDER_DIAMETER, const double TEXT_CYLINDER_RADIUS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_string.h</td>
        <td>OutputPymolLabelString</td>
        <td>OutputPymolLabelString( const util::ShPtr < math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const std::string> >, t_PrecisionType> > &MEMBER_DISTANCE_FUNCTION, const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &DISTANCE_COMPARATOR, const util::Color &COLOR, const bool LIST_MEMBERS = false )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_string.h</td>
        <td>OutputPymolLabelString</td>
        <td>OutputPymolLabelString()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_pymol_label_string.h</td>
        <td>OutputPymolLabelString</td>
        <td>operator ()( const storage::Triplet < util::SiPtr< const Node< std::string, t_PrecisionType> >, storage::VectorND< 4, double>, std::string > &TRIPLET ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_pymol_label_string.h</td>
        <td></td>
        <td>AddInstance( new OutputPymolLabelString< t_PrecisionType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_rows.h</td>
        <td>OutputRows</td>
        <td>OutputRows()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_rows.h</td>
        <td>OutputRows</td>
        <td>WriteOutput( const std::string &FILENAME, const util::SiPtrList< const Node< t_DataType, t_PrecisionType> > &NODE_LIST ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_sorted_matrix.h</td>
        <td>OutputSortedMatrix</td>
        <td>OutputSortedMatrix( const bool &TABULAR_OUTPUT = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_cluster_output_sorted_matrix.h</td>
        <td>OutputSortedMatrix</td>
        <td>OutputSortedMatrix( const util::ShPtr< math::FunctionInterfaceSerializable< storage::VectorND< 2, util::SiPtr< const t_DataType> >, t_PrecisionType> > &MEMBER_DISTANCE_FUNCTION, const util::ShPtr< util::BinaryFunctionInterface< t_PrecisionType, t_PrecisionType, bool> > &BINARY_PREDICATE, const bool &TABULAR_OUTPUT )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_cluster_output_sorted_matrix.h</td>
        <td>OutputSortedMatrix</td>
        <td>WriteOutput( const std::string &FILENAME, const util::SiPtrList< const Node< t_DataType, t_PrecisionType> > &NODE_LIST ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>AddDefaultCommandlineFlags( Command &COMMAND)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>AddDefaultCommandlineFlags( Command &COMMAND, const storage::Set< FlagTypeEnum> &TYPES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>AddDefaultFlag( const util::ShPtr< FlagInterface> &SH_PTR_FLAG, const FlagType &TYPE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>AddRequiredCommandlineFlags( Command &COMMAND)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>GetAllFlags() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>GetDefaultFlagsOfType( const FlagType &TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>GetFlagType( const std::string &FLAG_NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>GetHelpFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>GetInstance()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>GetReadMeFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>HandleFlags( CommandState &STATE, util::ShPtrVector< FlagInterface> &FLAGS, std::ostream &ERR_STREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_app_default_flags.h</td>
        <td>AppDefaultFlags</td>
        <td>HandleRequiredFlags( CommandState &STATE, std::ostream &ERR_STREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_app_default_flags.h</td>
        <td></td>
        <td>GetAppDefaultFlags()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>AddFlag( const util::ShPtr< FlagInterface> &COMMANDLINE_FLAG_PARAMS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>AddParameter( const util::ShPtr< ParameterInterface> &COMMANDLINE_PARAMETER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>Command( const Command &COMMAND)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>Command()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>DefaultSectionSeparator()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>GetAppFlagsWithParams() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>GetBclFlagsWithParams() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>GetFlagWithParams( const std::string &NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>GetParameters() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>IsFlagSet( const std::string &STRING)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>PushBack( const util::ShPtrVector< FlagInterface> &COMMANDLINE_FLAG_PARAMS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>ReadArguments( const storage::Vector< std::string> &ARGUMENT_LIST, std::ostream &ERROR_STREAM, const bool DRY_RUN = false )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>ResetFlagsAndParameters()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>SetFlags( CommandState &STATE, std::ostream &ERROR_STREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>SetParameters( const util::ShPtr< FlagInterface> &PARAMETERS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>WriteHelp( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>WriteUsage( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>WriteUserCommand( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command.h</td>
        <td>Command</td>
        <td>operator =( const Command &ORIGINAL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command_line_writer.h</td>
        <td>CommandLineWriter</td>
        <td>CreateCommandLine( const storage::Vector< std::string> &ARGUMENTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>CommandState( const bool &DRY_RUN = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>GetArguments( const std::string &FLAG_NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>GetFlagType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>GetGlobalCommandState()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>GetInMainCommandLineParsing()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>GetNumberRemainingParameters() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>GetParseArgumentsSignal() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>GetState() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>GetWasHelpGiven()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>GetWasHelpRequested()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>IsInStaticInitialization()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>ParseArguments( const int NUMBER_ARGUMENTS, const char **ARGUMENTS, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>ParseArguments( const storage::Vector< std::string> &CMD_LINE, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>SetFlagType( const FlagType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>Update( FlagInterface &FLAG, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>Update( ParameterInterface &PARAMETER, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_command_state.h</td>
        <td>CommandState</td>
        <td>WasFlagGiven( const std::string &FLAG_NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_default_flag_types.h</td>
        <td></td>
        <td>GetDefaultFlagTypes()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_default_flag_types.h</td>
        <td></td>
        <td>GetFlagTypeFromName( const std::string &FLAG_NAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_default_flag_types.h</td>
        <td></td>
        <td>GetFlagTypeName( const FlagType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>FlagDynamic( const std::string &NAME, const std::string &DESCRIPTION, const ParameterInterface &TEMPLATE_PARAMETER, const size_t MIN_NUMBER_PARAMETERS = size_t( 0), const size_t MAX_NUMBER_PARAMETERS = util::GetUndefinedSize_t(), t_Signal SIGNAL = NULL )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>FlagDynamic( const std::string &NAME, const std::string &DESCRIPTION, const storage::Vector< Parameter> &TEMPLATE_PARAMETERS, const size_t MIN_NUMBER_PARAMETERS = size_t( 0), const size_t MAX_NUMBER_PARAMETERS = util::GetUndefinedSize_t(), t_Signal SIGNAL = NULL )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>FlagDynamic()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>GetDescription() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>GetFirstParameter() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>GetFlag() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>GetName() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>GetNumberRequiredParameters() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>GetParameterList()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>GetParameterList() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>GetSignal() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>IsValidList( std::ostream &ERROR_STREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>ReadFromList( const storage::Vector< std::string> &PARAMETER_LIST, std::ostream &ERROR_STREAM)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>ResetFlag()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>SetFlag()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>UnsetFlag()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>WriteHelp( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>WriteRequiredUsage( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_dynamic.h</td>
        <td>FlagDynamic</td>
        <td>WriteUserCommand( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_interface.h</td>
        <td>FlagInterface</td>
        <td>FlagInterface( const bool &DEPRECATED = false)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_interface.h</td>
        <td>FlagInterface</td>
        <td>GetNumericalList() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_interface.h</td>
        <td>FlagInterface</td>
        <td>GetObjectList() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_interface.h</td>
        <td>FlagInterface</td>
        <td>GetObjectSet() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_interface.h</td>
        <td>FlagInterface</td>
        <td>GetSize() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_interface.h</td>
        <td>FlagInterface</td>
        <td>GetStringList() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_interface.h</td>
        <td>FlagInterface</td>
        <td>IsUnused() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_interface.h</td>
        <td>FlagInterface</td>
        <td>IsValidList() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_interface.h</td>
        <td>FlagInterface</td>
        <td>SetIsUnused()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>FlagSeparator( const std::string &SEPARATOR_TEXT)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>FlagSeparator()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetFirstParameter() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetFlag() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetName() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetNumberRequiredParameters() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetParameterList()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetParameterList() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetSeparatorText() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetSignal() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>GetSize() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>IsValidList( std::ostream &ERROR_STREAM) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>ReadFromList( const storage::Vector< std::string> &PARAMETER_LIST, std::ostream &ERROR_STREAM)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>ResetFlag()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>SetFlag()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>UnsetFlag()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>WriteHelp( std::ostream &OSTREAM) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>WriteRequiredUsage( std::ostream &OSTREAM) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_separator.h</td>
        <td>FlagSeparator</td>
        <td>WriteUserCommand( std::ostream &OSTREAM) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>FlagStatic( const std::string &NAME, const std::string &DESCRIPTION, FlagInterface::t_Signal SIGNAL = NULL )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>FlagStatic( const std::string &NAME, const std::string &DESCRIPTION, const ParameterInterface &PARAMETER, FlagInterface::t_Signal SIGNAL = NULL )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>FlagStatic( const std::string &NAME, const std::string &DESCRIPTION, const util::ShPtrVector< ParameterInterface> &PARAMETERS, FlagInterface::t_Signal SIGNAL = NULL )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>FlagStatic()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>GetDescription() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>GetFirstParameter() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>GetFlag() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>GetName() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>GetNumberRequiredParameters() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>GetParameterList()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>GetParameterList() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>GetSignal() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>IsValidList( std::ostream &ERROR_STREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>PushBack( const util::ShPtr< ParameterInterface> &PARAMETER)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>ReadFromList( const storage::Vector< std::string> &PARAMETER_LIST, std::ostream &ERROR_STREAM)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>ResetFlag()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>SetFlag()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>UnsetFlag()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>WriteHelp( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>WriteRequiredUsage( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static.h</td>
        <td>FlagStatic</td>
        <td>WriteUserCommand( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>FlagStaticAndDynamic( const std::string &NAME, const std::string &DESCRIPTION, const ParameterInterface &TEMPLATE_PARAMETER, const size_t MIN_NUMBER_PARAMETERS = size_t( 0), const size_t MAX_NUMBER_PARAMETERS = util::GetUndefinedSize_t(), t_Signal SIGNAL = NULL )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>FlagStaticAndDynamic()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetDescription() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetDynamicParameterList() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetFirstParameter() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetFlag() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetName() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetNumberDynamicParameters() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetNumberRequiredParameters() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetNumberStaticParameters() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetParameterList()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetParameterList() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>GetSignal() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>IsValidList( std::ostream &ERROR_STREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>PushBack( const util::ShPtr< ParameterInterface> &PARAMETER)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>ReadFromList( const storage::Vector< std::string> &PARAMETER_LIST, std::ostream &ERROR_STREAM)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>ResetFlag()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>SetFlag()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>UnsetFlag()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>WriteHelp( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>WriteRequiredUsage( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_flag_static_and_dynamic.h</td>
        <td>FlagStaticAndDynamic</td>
        <td>WriteUserCommand( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_guesser.h</td>
        <td>Guesser</td>
        <td>GetDefaultGuesser()
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_guesser.h</td>
        <td>Guesser</td>
        <td>GetTypeName( const MismatchType &TYPE)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_guesser.h</td>
        <td>Guesser</td>
        <td>Guess( const std::string &ARGUMENT, const storage::Vector< std::string> &EXPECTED ) const
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_guesser.h</td>
        <td>Guesser</td>
        <td>ProtectSuffix( const std::string &SUFFIX)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_guesser.h</td>
        <td>Guesser</td>
        <td>RegisterAlias( const std::string &ORIGINAL, const std::string &ALIAS)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_guesser.h</td>
        <td>Guesser</td>
        <td>RegisterSuffix( const std::string &SUFFIX, const std::string &NORMALIZED)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_guesser.h</td>
        <td>Guesser</td>
        <td>WriteGuesses( const std::string &ARGUMENT, const storage::Vector< std::string> &EXPECTED, std::ostream &STREAM, const std::string &ARGUMENT_TYPE_NAME ) const
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>GetDefaultValue() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>GetDescription() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>GetName() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>GetNumericalValue() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>GetParameterCheck() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>GetValue() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>GetWasDefaultGiven() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>GetWasSetInCommandLine() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, std::ostream &ERROR_STREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>Parameter( const std::string &NAME, const std::string &DESCRIPTION)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>Parameter( const std::string &NAME, const std::string &DESCRIPTION, const ParameterCheckInterface &PARAMETER_CHECK )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>Parameter( const std::string &NAME, const std::string &DESCRIPTION, const ParameterCheckInterface &PARAMETER_CHECK, const std::string &DEFAULT_PARAMETER )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>Parameter( const std::string &NAME, const std::string &DESCRIPTION, const std::string &DEFAULT_PARAMETER )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>Parameter()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>Reset()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>SetDefaultParameter( const std::string &PARAMETER)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>SetParameter( const std::string &PARAMETER, std::ostream &ERROR_STREAM)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>SetParameterCheck( const ParameterCheckInterface &CHECK)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter.h</td>
        <td>Parameter</td>
        <td>WriteUserCommand( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter.h</td>
        <td></td>
        <td>StringVectorFromFilenameParameter( const ParameterInterface &PARAMETER)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_allowed.h</td>
        <td>ParameterCheckAllowed</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_allowed.h</td>
        <td>ParameterCheckAllowed</td>
        <td>ParameterCheckAllowed( const storage::Vector< std::string> &ALLOWED_PARAMETERS)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_allowed.h</td>
        <td>ParameterCheckAllowed</td>
        <td>ParameterCheckAllowed()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_allowed.h</td>
        <td>ParameterCheckAllowed</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_allowed_non_const.h</td>
        <td>ParameterCheckAllowedNonConst</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_allowed_non_const.h</td>
        <td>ParameterCheckAllowedNonConst</td>
        <td>ParameterCheckAllowedNonConst( const storage::Vector< std::string> &ALLOWED_PARAMETERS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_allowed_non_const.h</td>
        <td>ParameterCheckAllowedNonConst</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_default.h</td>
        <td>ParameterCheckDefault</td>
        <td>Check( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_default.h</td>
        <td>ParameterCheckDefault</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_default.h</td>
        <td>ParameterCheckDefault</td>
        <td>ParameterCheckDefault()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_default.h</td>
        <td>ParameterCheckDefault</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_enumerate.h</td>
        <td>ParameterCheckEnumerate</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_enumerate.h</td>
        <td>ParameterCheckEnumerate</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_enumerate.h</td>
        <td></td>
        <td>AddInstance( new ParameterCheckEnumerate< t_Enumerate>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_extension.h</td>
        <td>ParameterCheckExtension</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_extension.h</td>
        <td>ParameterCheckExtension</td>
        <td>ParameterCheckExtension( const std::string &EXTENSION)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_extension.h</td>
        <td>ParameterCheckExtension</td>
        <td>ParameterCheckExtension()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_extension.h</td>
        <td>ParameterCheckExtension</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_extensions_file_existence.h</td>
        <td>ParameterCheckExtensionsFileExistence</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_extensions_file_existence.h</td>
        <td>ParameterCheckExtensionsFileExistence</td>
        <td>ParameterCheckExtensionsFileExistence( const std::string &EXTENSION)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_extensions_file_existence.h</td>
        <td>ParameterCheckExtensionsFileExistence</td>
        <td>ParameterCheckExtensionsFileExistence( const storage::Vector< std::string> &EXTENSIONS)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_extensions_file_existence.h</td>
        <td>ParameterCheckExtensionsFileExistence</td>
        <td>ParameterCheckExtensionsFileExistence()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_extensions_file_existence.h</td>
        <td>ParameterCheckExtensionsFileExistence</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_extensions_file_existence.h</td>
        <td>ParameterCheckExtensionsFileExistence</td>
        <td>WriteListOfExtensions( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_file_existence.h</td>
        <td>ParameterCheckFileExistence</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_file_existence.h</td>
        <td>ParameterCheckFileExistence</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_file_in_search_path.h</td>
        <td>ParameterCheckFileInSearchPath</td>
        <td>FindFile( const std::string &PARAMETER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_file_in_search_path.h</td>
        <td>ParameterCheckFileInSearchPath</td>
        <td>GetExecutableDirectoryVariable()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_file_in_search_path.h</td>
        <td>ParameterCheckFileInSearchPath</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_file_in_search_path.h</td>
        <td>ParameterCheckFileInSearchPath</td>
        <td>ParameterCheckFileInSearchPath( const std::string &TARGET_NAME = Ó, const std::string &LAST_RESORT = Ó, const io::Directory::EntryType &TYPE = io::Directory::e_File )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_file_in_search_path.h</td>
        <td>ParameterCheckFileInSearchPath</td>
        <td>ParameterCheckFileInSearchPath( const std::string &TARGET_NAME, const storage::Vector< std::string> &PATHS, const io::Directory::EntryType &TYPE = io::Directory::e_File )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_file_in_search_path.h</td>
        <td>ParameterCheckFileInSearchPath</td>
        <td>ParameterCheckFileInSearchPath( const storage::Vector< std::string> &PATHS, const io::Directory::EntryType &TYPE = io::Directory::e_File )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_file_in_search_path.h</td>
        <td>ParameterCheckFileInSearchPath</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_interface.h</td>
        <td>ParameterCheckInterface</td>
        <td>Check( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>karakam, mendenjl, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_interface.h</td>
        <td>ParameterCheckInterface</td>
        <td>Clean( std::string &PARAMETER) const
</td>
        <td>karakam, mendenjl, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_or.h</td>
        <td>ParameterCheckOr</td>
        <td>Check( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_or.h</td>
        <td>ParameterCheckOr</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_or.h</td>
        <td>ParameterCheckOr</td>
        <td>ParameterCheckOr( const ParameterCheckInterface &CHECK_A, const ParameterCheckInterface &CHECK_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_or.h</td>
        <td>ParameterCheckOr</td>
        <td>ParameterCheckOr( const ParameterCheckInterface &CHECK_A, const ParameterCheckInterface &CHECK_B, const ParameterCheckInterface &CHECK_C )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_or.h</td>
        <td>ParameterCheckOr</td>
        <td>ParameterCheckOr( const ParameterCheckInterface &CHECK_A, const ParameterCheckInterface &CHECK_B, const ParameterCheckInterface &CHECK_C, const ParameterCheckInterface &CHECK_D )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_or.h</td>
        <td>ParameterCheckOr</td>
        <td>ParameterCheckOr( const util::ShPtrVector< ParameterCheckInterface> &CHECKS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_or.h</td>
        <td>ParameterCheckOr</td>
        <td>ParameterCheckOr()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_or.h</td>
        <td>ParameterCheckOr</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_ranged.h</td>
        <td>ParameterCheckRanged</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_ranged.h</td>
        <td>ParameterCheckRanged</td>
        <td>ParameterCheckRanged( const t_DataType MIN)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_ranged.h</td>
        <td>ParameterCheckRanged</td>
        <td>ParameterCheckRanged( const t_DataType MIN, const t_DataType MAX)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_ranged.h</td>
        <td>ParameterCheckRanged</td>
        <td>ParameterCheckRanged()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_ranged.h</td>
        <td>ParameterCheckRanged</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_ranged.h</td>
        <td></td>
        <td>AddInstance( new ParameterCheckRanged< t_DataType>())
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_serializable.h</td>
        <td>ParameterCheckSerializable</td>
        <td>Check( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_serializable.h</td>
        <td>ParameterCheckSerializable</td>
        <td>IsAllowedParameter( const std::string &PARAMETER, const std::string &PARAMETER_NAME, std::ostream &ERROR_STREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_serializable.h</td>
        <td>ParameterCheckSerializable</td>
        <td>ParameterCheckSerializable( const io::SerializationInterface &OBJECT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_check_serializable.h</td>
        <td>ParameterCheckSerializable</td>
        <td>ParameterCheckSerializable()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_command_parameter_check_serializable.h</td>
        <td>ParameterCheckSerializable</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_command_parameter_interface.h</td>
        <td>ParameterInterface</td>
        <td>GetNumericalValue() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact.h</td>
        <td></td>
        <td>GetDefaultSequenceSeparationLongRange()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact.h</td>
        <td></td>
        <td>GetDefaultSequenceSeparationMidRange()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact.h</td>
        <td></td>
        <td>GetDefaultSequenceSeparationRange()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact.h</td>
        <td></td>
        <td>GetDefaultSequenceSeparationShortRange()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_aa_correlation_from_file.h</td>
        <td>AACorrelationFromFile</td>
        <td>AACorrelationFromFile( const std::string &SUFFIX = Ó)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_ann.h</td>
        <td></td>
        <td>ANN_CONTACT_HELIX_HELIX( const linal::Vector< double> &INP)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_ann.h</td>
        <td></td>
        <td>ANN_CONTACT_HELIX_SHEET( const linal::Vector< double> &INP)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_ann.h</td>
        <td></td>
        <td>ANN_CONTACT_SHEET_SHEET( const linal::Vector< double> &INP)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_ann.h</td>
        <td></td>
        <td>ANN_CONTACT_STRAND_STRAND( const linal::Vector< double> &INP)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_calculate_correlations_mi.h</td>
        <td>CalculateCorrelationsMI</td>
        <td>CalculateCorrelationsMI()
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_calculate_correlations_mi.h</td>
        <td>CalculateCorrelationsMI</td>
        <td>operator ()( const align::AlignmentInterface< biol::AABase> &ALIGNMENT_INTERFACE) const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_calculate_correlations_sm.h</td>
        <td>CalculateCorrelationsSM</td>
        <td>CalculateCorrelationsSM()
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_calculate_correlations_sm.h</td>
        <td>CalculateCorrelationsSM</td>
        <td>operator ()( const align::AlignmentInterface< biol::AABase> &ALIGNMENT_INTERFACE) const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_calculate_correlations_sm.h</td>
        <td>CalculateCorrelationsSM</td>
        <td>operator ==( const CalculateCorrelationsSM &CALCULATE_CORRELATIONS) const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_correlation_matrix.h</td>
        <td>CorrelationMatrix</td>
        <td>CorrelationMatrix( const size_t DIMENSIONS = 0, const double VALUE = 0.0, const bool REPLACE = true)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_correlation_matrix.h</td>
        <td>CorrelationMatrix</td>
        <td>GetAverage() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_correlation_matrix.h</td>
        <td>CorrelationMatrix</td>
        <td>GetValue() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_correlation_matrix.h</td>
        <td>CorrelationMatrix</td>
        <td>SetValue( const double &VALUE)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_correlation_matrix.h</td>
        <td>CorrelationMatrix</td>
        <td>operator ()( const size_t I_POS, const size_t J_POS)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_correlation_matrix.h</td>
        <td>CorrelationMatrix</td>
        <td>operator ()( const size_t I_POS, const size_t J_POS) const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>GetAllKeys() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>GetDirectory() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>GetInitializer() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>GetSize() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>Initialize( const std::string &INITIALIZER, const InitializerType INIT_FLAG)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>Retrieve( const std::string &KEY) const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>RetrieveEnsemble( const storage::Vector< std::string> &KEYS) const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>RetrieveEnsemble() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>Store( const AlignmentMatrixPair &ALIGNMENT_MATRIX_PAIR)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>Store( const AlignmentMatrixPair &ALIGNMENT_MATRIX_PAIR, const std::string &KEY)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_correlation_storage_file.h</td>
        <td>CorrelationStorageFile</td>
        <td>Store( const util::ShPtrList< AlignmentMatrixPair> &ENSEMBLE )
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_data.h</td>
        <td>Data</td>
        <td>Data()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_data.h</td>
        <td>Data</td>
        <td>IsDefined() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_data.h</td>
        <td>Data</td>
        <td>MergedPrediction()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_data.h</td>
        <td>Data</td>
        <td>MergedPrediction() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_data.h</td>
        <td>Data</td>
        <td>Swap( const Type CONTACT_TYPE_A, const Type CONTACT_TYPE_B)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_data.h</td>
        <td>Data</td>
        <td>operator []( const Type &CONTACT_TYPE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_data.h</td>
        <td>Data</td>
        <td>operator []( const Type &CONTACT_TYPE) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>GetBoundary() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>GetChain( const char CHAIN_ID) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>GetChains() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>GetContactVector( const storage::VectorND< 2, util::SiPtr< const biol::AAData> > &AA_DATA_POINTERS ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>IsInContact( const Map &CONTACTS, const assemble::SSE &FIRST, const assemble::SSE &SECOND)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>IsInContact( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>IsInContact( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const Type &CONTACT_TYPE )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>Map( const assemble::ProteinModel &PROTEIN_MODEL, const int BOUNDARY = 8 )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>Map( const util::ShPtr< assemble::Chain> &CHAIN, const int BOUNDARY = 8 )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>Map()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>ReadMap( std::istream &ISTREAM)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_map.h</td>
        <td>Map</td>
        <td>WriteMap( std::ostream &OSTREAM, const bool WRITE_ONLY_CONTACTS ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>ContactOrder( const assemble::Chain &CHAIN) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>ContactOrder( const biol::AASequence &AA_SEQEUNCE) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>GetDefaultScheme()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>GetNormalization() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>GetNormalizationTypeDescriptor( const NormalizationType &NORMALIZATION_TYPE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>GetType() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>Order( const NormalizationType NORMALIZE, const std::string &SCHEME, const bool CACHE = false)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>Order()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_order.h</td>
        <td>Order</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_prediction_map.h</td>
        <td>PredictionMap</td>
        <td>GetPredictions( const storage::VectorND< 2, util::SiPtr< const biol::AAData> > &AA_DATA_POINTERS ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_prediction_map.h</td>
        <td>PredictionMap</td>
        <td>GetSequence( const char CHAIN_ID) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_prediction_map.h</td>
        <td>PredictionMap</td>
        <td>GetSequences() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_prediction_map.h</td>
        <td>PredictionMap</td>
        <td>PredictionMap( const assemble::Chain &CHAIN)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_prediction_map.h</td>
        <td>PredictionMap</td>
        <td>PredictionMap( const assemble::ProteinModel &PROTEIN_MODEL)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_prediction_map.h</td>
        <td>PredictionMap</td>
        <td>PredictionMap()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_prediction_map.h</td>
        <td>PredictionMap</td>
        <td>ReadPredictionMap( std::istream &ISTREAM )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_prediction_map.h</td>
        <td>PredictionMap</td>
        <td>WritePredictionMap( std::ostream &OSTREAM, const double MERGED_THRESHOLD = 0.0 ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_recovery.h</td>
        <td>Recovery</td>
        <td>CalculateContingencyMatrix( const assemble::AANeighborListContainer &TEMPLATE_NEIGHBOR_CONTAINER, const assemble::AANeighborListContainer &MODEL_NEIGHBOR_CONTAINER )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_recovery.h</td>
        <td>Recovery</td>
        <td>Recovery( const size_t MIN_SEQUENCE_SEPARATION = g_ContactMinSequenceSeparation, const math::ContingencyMatrixMeasures::MeasureEnum &MEASURE = math::ContingencyMatrixMeasures::e_TruePositiveRate )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_recovery.h</td>
        <td>Recovery</td>
        <td>operator ()( const assemble::ProteinModel &TEMPLATE_MODEL, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_sse_prediction_map.h</td>
        <td>SSEPredictionMap</td>
        <td>GetPrediction( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_sse_prediction_map.h</td>
        <td>SSEPredictionMap</td>
        <td>GetPrediction( const storage::VectorND< 2, util::SiPtr< const assemble::SSE> > &SSE_PAIR) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_sse_prediction_map.h</td>
        <td>SSEPredictionMap</td>
        <td>SSEPredictionMap( const util::ShPtr< PredictionMap> &PREDICTION_MAP, const util::ShPtrVector< assemble::SSE> &SSE_POOL )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_sse_prediction_map.h</td>
        <td>SSEPredictionMap</td>
        <td>SSEPredictionMap()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>Calculate( const assemble::AANeighborListContainer &NEIGHBOR_CONTAINER) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>GetContactsRatio( const math::Range< size_t> &SEQUENCE_SEPARATION_RANGE, const assemble::AANeighborListContainer &NEIGHBOR_CONTAINER )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>GetNumberContacts( const math::Range< size_t> &SEQUENCE_SEPARATION_RANGE, const assemble::AANeighborListContainer &NEIGHBOR_CONTAINER )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>GetSequenceSeparationRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>GetStatisticTypeDescriptor( const StatisticType &STATISTIC_TYPE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>GetUseRatio() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>Statistics( const StatisticType &STATISTIC_TYPE, const bool CACHE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>Statistics( const math::Range< size_t> &SEQUENCE_SEPARATION_RANGE, const bool CALCULATE_RATIO, const bool CACHE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>Statistics()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_statistics.h</td>
        <td>Statistics</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>GetDistanceRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>GetMinimalFragmentInterfaceLength() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>GetMinimalSSEDistance() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>GetPreferredDistanceRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>GetResidueDistanceCutoff() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>GetSSTypes() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>GetTiltAngleRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>GetWindowLengths() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>GetWindowRadii() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>IsValid() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>TypeData( const storage::Pair< size_t, size_t> &WINDOW_RADII, const storage::Pair< size_t, size_t> &WINDOW_LENGTH_PAIR, const bool IS_VALID, const double RESIDUE_DISTANCE_CUTOFF, const double MINIMAL_SSE_DISTANCE, const math::Range< double> &DISTANCE_RANGE, const math::Range< double> &PREFERRED_DISTANCE_RANGE, const math::Range< double> &TILT_ANGLE_RANGE, const double MINIMAL_FRAGMENT_INTERFACE_LENGTH, const storage::Set< biol::SSType> &SS_TYPES )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_type_data.h</td>
        <td>TypeData</td>
        <td>TypeData()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_types.h</td>
        <td>Types</td>
        <td>GetUndefinedLengthPair()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_types.h</td>
        <td>Types</td>
        <td>GetUnknownDistanceRange()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_types.h</td>
        <td>Types</td>
        <td>GetUnknownPreferredDistanceRange()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_types.h</td>
        <td>Types</td>
        <td>GetUnknownResidueDistanceCutoff()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_types.h</td>
        <td>Types</td>
        <td>GetUnknownTiltAngleRange()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_types.h</td>
        <td>Types</td>
        <td>GetValidDistanceRanges() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_types.h</td>
        <td>Types</td>
        <td>Reverse( const Type &TYPE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_contact_types.h</td>
        <td>Types</td>
        <td>TypeFromSSTypes( const assemble::SSEGeometryInterface &SSE_A, const assemble::SSEGeometryInterface &SSE_B ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_contact_types.h</td>
        <td></td>
        <td>GetTypes()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord.h</td>
        <td></td>
        <td>AreDefinedCoordinates( const util::SiPtrVector< const linal::Vector3D> &COORDINATES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord.h</td>
        <td></td>
        <td>CalculateDifferenceDistanceMatrix( const util::SiPtrVector< const linal::Vector3D> &COORDINATES_A, const util::SiPtrVector< const linal::Vector3D> &COORDINATES_B )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord.h</td>
        <td></td>
        <td>CalculateDistanceMatrix( const util::SiPtrVector< const linal::Vector3D> &COORDINATES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord.h</td>
        <td></td>
        <td>CalculatePointDensity( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const linal::Vector3D &RESOLUTION )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord.h</td>
        <td></td>
        <td>CenterOfMass( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const bool SKIP_UNDEFINED = false )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord.h</td>
        <td></td>
        <td>CountNeighbors( const util::SiPtrVector< const linal::Vector3D> &ALL_POINTS, const linal::Vector3D &CURRENT_POINT, const double LOW_THRESHOLD, const double HIGH_THRESHOLD )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord.h</td>
        <td></td>
        <td>EstimateVolume( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const double &SLICE_WIDTH, const double &MAX_DISTANCE, const double &RADIUS = 0.0 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord.h</td>
        <td></td>
        <td>NeighborVector( const util::SiPtrVector< const linal::Vector3D> &ALL_POINTS, const linal::Vector3D &CURRENT_POINT, const double LOW_THRESHOLD, const double HIGH_THRESHOLD, const bool NORMALIZE_BY_NEIGHBOR_COUNT = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord.h</td>
        <td></td>
        <td>NeighborWeight( const double DISTANCE, const double LOW_THRESHOLD, const double HIGH_THRESHOLD)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord.h</td>
        <td></td>
        <td>QuantizePoints( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const linal::Vector3D &RESOLUTION )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord.h</td>
        <td></td>
        <td>RadiusOfGyration( const util::SiPtrVector< const linal::Vector3D> &COORDINATES)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord.h</td>
        <td></td>
        <td>SphericalCoordinates( const double DISTANCE, const double PHI, const double PSI)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord.h</td>
        <td></td>
        <td>SquareRadiusOfGyration( const util::SiPtrVector< const linal::Vector3D> &COORDINATES)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord.h</td>
        <td></td>
        <td>SymmetryFactor( const util::ShPtrVector< util::SiPtrVector< const linal::Vector3D> > &COORDINATES)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord.h</td>
        <td></td>
        <td>TransformCoordinates( util::SiPtrVector< linal::Vector3D> &COORDINATES, const math::TransformationMatrix3D &TRANSFORMATION_MATRIX )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_axes.h</td>
        <td></td>
        <td>GetAxes()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>CyclicCoordinateDescent</td>
        <td>CalculateDistanceSum( const double ROTATION, const double COEFFICIENT_A, const double COEFFICIENT_B, const double COEFFICIENT_C ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>CyclicCoordinateDescent</td>
        <td>CyclicCoordinateDescent()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>CyclicCoordinateDescent</td>
        <td>GetOptimalRotationandDistance( const LineSegment3D &ROTATION_AXIS, const storage::List< TargetAndMovingPointPair> &TARGET_MOVING_POINTS ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>ResultsAndCoefficients</td>
        <td>GetCoefficientA() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>ResultsAndCoefficients</td>
        <td>GetCoefficientB() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>ResultsAndCoefficients</td>
        <td>GetCoefficientC() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>ResultsAndCoefficients</td>
        <td>GetMinimumDistanceSum() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>ResultsAndCoefficients</td>
        <td>GetOptimalRotation() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>ResultsAndCoefficients</td>
        <td>ResultsAndCoefficients( const double OPTIMAL_ROTATION, const double MINIMUM_DISTANCE_SUM, const double COEFFICIENT_A, const double COEFFICIENT_B, const double COEFFICIENT_C )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>ResultsAndCoefficients</td>
        <td>ResultsAndCoefficients()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>TargetAndMovingPointPair</td>
        <td>GetMovingPoint() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>TargetAndMovingPointPair</td>
        <td>GetTargetPoint() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>TargetAndMovingPointPair</td>
        <td>TargetAndMovingPointPair( const linal::Vector3D &TARGET_POINT, const linal::Vector3D &MOVING_POINT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td>TargetAndMovingPointPair</td>
        <td>TargetAndMovingPointPair()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td></td>
        <td>operator ==( const CyclicCoordinateDescent::ResultsAndCoefficients &RESULT_A, const CyclicCoordinateDescent::ResultsAndCoefficients &RESULT_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cyclic_coordinate_descent.h</td>
        <td></td>
        <td>operator ==( const CyclicCoordinateDescent::TargetAndMovingPointPair &PAIR_A, const CyclicCoordinateDescent::TargetAndMovingPointPair &PAIR_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cylinder_coordinates.h</td>
        <td>CylinderCoordinates</td>
        <td>CylinderCoordinates( const double HEIGHT, const double RADIUS, const double ANGLE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cylinder_coordinates.h</td>
        <td>CylinderCoordinates</td>
        <td>CylinderCoordinates()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cylinder_coordinates.h</td>
        <td>CylinderCoordinates</td>
        <td>GetAngle() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cylinder_coordinates.h</td>
        <td>CylinderCoordinates</td>
        <td>GetCartesianCoordinates() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cylinder_coordinates.h</td>
        <td>CylinderCoordinates</td>
        <td>GetHeight() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cylinder_coordinates.h</td>
        <td>CylinderCoordinates</td>
        <td>GetRadius() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_cylinder_coordinates.h</td>
        <td>CylinderCoordinates</td>
        <td>operator !=( const CylinderCoordinates &RHS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_cylinder_coordinates.h</td>
        <td>CylinderCoordinates</td>
        <td>operator ==( const CylinderCoordinates &RHS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_classes.h</td>
        <td>GeometricHashStorageClasses</td>
        <td>ConstructFromCommandline( const std::string &MRC_NAME, const double MRC_RESOLUTION, const double MRC_VOXELSIZE, const storage::VectorND< 3, size_t> &MRC_EXTENSION, const size_t NUMBER_POINTS, const double FEATURE_DISTANCE, const double RATIO_INTENSITY_GRADIENT, const storage::VectorND< 4, double> &THRESHOLD, const double RADIUS, const PointToKeyInterface &POINT_TO_KEY, const size_t MIN_NUMBER_NEIGHBORS, const double MIN_NEIGHBOR_DISTANCE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_classes.h</td>
        <td>GeometricHashStorageClasses</td>
        <td>GetGeometricHashStorageClassFlag() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_classes.h</td>
        <td></td>
        <td>GetGeometricHashStorageClasses()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>Construct( const std::string &MRC_NAME, const double MRC_RESOLUTION, const double MRC_VOXELSIZE, const storage::VectorND< 3, size_t> &MRC_EXTENSION, const size_t NUMBER_POINTS, const double FEATURE_DISTANCE, const double RATIO_INTENSITY_GRADIENT, const storage::VectorND< 4, double> &THRESHOLD, const double FEATURE_RADIUS, const PointToKeyInterface &POINT_TO_KEY, const size_t MIN_NUMBER_NEIGHBORS, const double MIN_NEIGHBOR_DISTANCE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>Finalize()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GeometricHashStorageHashMap( const std::string &MRC_NAME, const double MRC_RESOLUTION, const double MRC_VOXELSIZE, const storage::VectorND< 3, size_t> &MRC_EXTENSION, const size_t NUMBER_POINTS, const double FEATURE_DISTANCE, const double RATIO_INTENSITY_GRADIENT, const storage::VectorND< 4, double> &THRESHOLD, const double FEATURE_RADIUS, const PointToKeyInterface &POINT_TO_KEY, const size_t MIN_NUMBER_NEIGHBORS, const double MIN_NEIGHBOR_DISTANCE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GeometricHashStorageHashMap()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetMRCExtension() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetMRCName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetMRCResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetMRCVoxelSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetMinNeighborDistance() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetMinNumberNeighbors() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetMinimalDistance() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetNumberPoints() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetPointToKey() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetRadius() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetRatioIntensityGradient() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>GetThreshold() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>IsReadOnly() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>IsSimilarTransformation( const math::TransformationMatrix3D &TRANSFORMATIONMATRIX3D, const storage::VectorND< 2, double> &DIFFERENCE_ROT_TRANS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>NumberOfHashkeys() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>NumberOfTransformationMatrices() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>ReturnBestCounts( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const math::TransformationMatrix3D &TRANSFORMATIONMATRIX3D, const size_t NUMBERBESTCOUNTS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>GeometricHashStorageHashMap</td>
        <td>Store( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const math::TransformationMatrix3D &TRANSFORMATIONMATRIX3D )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_hash_map.h</td>
        <td>Sp_CountCompare</td>
        <td>operator ()( const std::pair< util::SiPtr< const math::TransformationMatrix3D>, size_t> &PAIR1, const std::pair< util::SiPtr< const math::TransformationMatrix3D>, size_t> &PAIR2 ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hash_storage_interface.h</td>
        <td>GeometricHashStorageInterface</td>
        <td>ConvertTripletToKey( const storage::Triplet< int, int, int> &HASHKEYS)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hash_storage_interface.h</td>
        <td>GeometricHashStorageInterface</td>
        <td>IsSimilarTransformation( const util::ShPtrVector< math::TransformationMatrix3D> &TRANSFORAMTIONS, const math::TransformationMatrix3D &TRANSFORMATIONMATRIX3D, const storage::VectorND< 2, double> &DIFFERENCE_ROT_TRANS )
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>BuildHash( const PointCloud &FEATURE_CLOUD)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>CalculateBasisTransformationAndCenter( const linal::Vector3D &VECTOR_1, const linal::Vector3D &VECTOR_2, const linal::Vector3D &VECTOR_3 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>CalculateDistanceDistribution( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const double BIN_SIZE, const math::Range< double> &DISTANCE_RANGE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>CalculateDistanceDistribution( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const storage::VectorND< 2, double> &THRESHOLD, const size_t NUMBER_BINS = 20 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>CalculatePointPairs( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const storage::VectorND< 4, double> &THRESHOLD )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>ConvertBasesToTransformationsAndCenter( const storage::List< storage::VectorND< 3, util::SiPtr< const linal::Vector3D> > > &BASES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>CreateEqualOccupiedIntervals( const math::Histogram &DISTANCE_DISTRIBUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>CreateEquidistantIntervals( const storage::VectorND< 2, double> &THRESHOLD)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>DetermineNeighbors( const linal::Vector3D &POINT_OF_INTEREST, const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const double FEATURE_RADIUS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>DeterminePossibleBases( const storage::VectorND< 3, storage::Map< util::SiPtr< const linal::Vector3D>, storage::Set< util::SiPtr< const linal::Vector3D> > > > &POINT_PAIRS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>FilterSimilarTransformations( const storage::List< storage::Pair< util::ShPtr< math::TransformationMatrix3D>, size_t> > &BESTTRANSFORMATIONS, const size_t &KEEPBEST, const storage::VectorND< 2, double> &DIFFERENCE_ROT_TRANS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>GatherEquallyDistributedBases( const storage::VectorND< 3, storage::Map< util::SiPtr< const linal::Vector3D>, storage::Set< util::SiPtr< const linal::Vector3D> > > > &POINT_PAIRS, const size_t NUMBER, const linal::Vector3D &CENTER, const size_t NUMBER_BINS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>GatherEquallyDistributedBases3D( const storage::VectorND< 3, storage::Map< util::SiPtr< const linal::Vector3D>, storage::Set< util::SiPtr< const linal::Vector3D> > > > &POINT_PAIRS, const size_t NUMBER, const linal::Vector3D &CENTER, const size_t NUMBER_BINS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>GeometricHashing( const util::ShPtr< GeometricHashStorageInterface> &STORAGE_SP)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>GeometricHashing()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>NumberPossibleBases( const storage::VectorND< 3, storage::Map< util::SiPtr< const linal::Vector3D>, storage::Set< util::SiPtr< const linal::Vector3D> > > > &POINT_PAIRS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>NumberPossibleBases( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const storage::VectorND< 4, double> &THRESHOLD )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>ReturnBestCounts( const storage::Pair< math::TransformationMatrix3D, linal::Vector3D> &TRANSFORMATION_CENTER, const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const size_t &SAVE_BEST ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>ReturnPossibleBases( const PointCloud &COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometric_hashing.h</td>
        <td>GeometricHashing</td>
        <td>SearchTarget( const PointCloud &COORDINATES, const size_t &SAVE_BEST, const size_t &SEARCH_TRIALS, const storage::VectorND< 2, double> &DIFFERENCE_ROT_TRANS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometry_interface.h</td>
        <td>GeometryInterface</td>
        <td>GetExtents() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometry_interface.h</td>
        <td></td>
        <td>EqualWithinTolerance( const GeometryInterface &GEOMETRY_LHS, const GeometryInterface &GEOMETRY_RHS, const double &RELATIVE_TOLERANCE = 0.001 )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_geometry_interface.h</td>
        <td></td>
        <td>ShortestConnectionBetweenGeometries( const GeometryInterface &GEOMETRY_A, const GeometryInterface &GEOMETRY_B, const double MINIMAL_INTERFACE_LENGTH )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_geometry_interface.h</td>
        <td></td>
        <td>operator ==( const GeometryInterface &GEOMETRY_LHS, const GeometryInterface &GEOMETRY_RHS)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>DistanceToPoint( const linal::Vector2D &POINT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>DoesIntersect( const LineSegment2D &LINE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>GetDirection() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>GetEndPoint() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>GetFootPointFraction( const linal::Vector2D &POINT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>GetLength() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>GetReverse() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>GetStartPoint() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>LineSegment2D( const linal::Vector2D &START_POINT, const linal::Vector2D &END_POINT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>LineSegment2D()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>Overlaps( const LineSegment2D &LINE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>SetDirection( const linal::Vector2D &DIRECTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>SetEndPoint( const linal::Vector2D &END_POINT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>SetStartPoint( const linal::Vector2D &START_POINT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>Shorten( const double LENGTH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>ShortestLineBetween( const LineSegment2D &LINE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_2d.h</td>
        <td>LineSegment2D</td>
        <td>operator ==( const LineSegment2D &LINE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>GetDirection() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>GetEndPoint() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>GetFootPointFraction( const linal::Vector3D &POINT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>GetLength() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>GetReverse() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>GetStartPoint() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>LineSegment3D( const linal::Vector3D &START_POINT, const linal::Vector3D &END_POINT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>LineSegment3D()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>SetDirection( const linal::Vector3D &DIRECTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>SetEndPoint( const linal::Vector3D &END_POINT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>SetStartPoint( const linal::Vector3D &START_POINT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_3d.h</td>
        <td>LineSegment3D</td>
        <td>Shorten( const double LENGTH)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_line_segment_3d.h</td>
        <td></td>
        <td>CalculateDistancePointFromLineSegment( const LineSegment3D &LINESEGMENT, const linal::Vector3D &POINT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_line_segment_3d.h</td>
        <td></td>
        <td>ShortestConnectionBetweenLineSegments3D( const LineSegment3D &LINESEGMENT_A, const LineSegment3D &LINESEGMENT_B )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_moment_of_inertia.h</td>
        <td>MomentOfInertia</td>
        <td>MomentOfInertia()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_moment_of_inertia.h</td>
        <td>MomentOfInertia</td>
        <td>TransformationAndMoments( const linal::MatrixConstInterface< double> &COORDINATES_WEIGHT_MATRIX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_moment_of_inertia.h</td>
        <td>MomentOfInertia</td>
        <td>operator ()( const linal::MatrixConstInterface< double> &COORDINATE_WEIGHT_MATRIX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>GetAxis( const Axis &AXIS) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>GetCenter() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>GetData() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>GetHinge() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>GetOrientation() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>MovableEccentric( MovableInterface &MOVABLE_DATA, const MovableInterface &HINGE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>MovableEccentric( const MovableEccentric &MOVABLE_ECCENTRIC )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>MovableEccentric( const util::SiPtr< MovableInterface> &SP_MOVABLE_DATA, const util::SiPtr< const MovableInterface> &SP_HINGE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>MovableEccentric()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATIONMATRIX3D)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATIONMATRIX3D)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_movable_eccentric.h</td>
        <td>MovableEccentric</td>
        <td>operator =( const MovableEccentric &MOVABLE_ECCENTRIC)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_movable_interface.h</td>
        <td>MovableInterface</td>
        <td>RandomTransformation( const double MAX_TRANSLATION, const double MAX_ROTATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_combine.h</td>
        <td>MoveCombine</td>
        <td>GetMoves() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_combine.h</td>
        <td>MoveCombine</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_combine.h</td>
        <td>MoveCombine</td>
        <td>Move( MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_combine.h</td>
        <td>MoveCombine</td>
        <td>MoveCombine( const util::ShPtrList< MoveInterface> &MOVES_LIST)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_combine.h</td>
        <td>MoveCombine</td>
        <td>MoveCombine()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_defined.h</td>
        <td>MoveRotateDefined</td>
        <td>GenerateRotation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_defined.h</td>
        <td>MoveRotateDefined</td>
        <td>GenerateTransformationInternal( const MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_defined.h</td>
        <td>MoveRotateDefined</td>
        <td>GetFlipMove( const Axis &AXIS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_defined.h</td>
        <td>MoveRotateDefined</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_defined.h</td>
        <td>MoveRotateDefined</td>
        <td>Move( MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_defined.h</td>
        <td>MoveRotateDefined</td>
        <td>MoveRotateDefined( const MoveRotateDefined &MOVE_ROTATE_DEFINED)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_defined.h</td>
        <td>MoveRotateDefined</td>
        <td>MoveRotateDefined( const double ROTATION_ANGLE_RAD, const Axis &ROTATION_AXIS, const bool INTERNAL = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_defined.h</td>
        <td>MoveRotateDefined</td>
        <td>MoveRotateDefined()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_defined.h</td>
        <td>MoveRotateDefined</td>
        <td>operator =( const MoveRotateDefined &MOVE_ROTATE_DEFINED)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>GenerateRandomRotation( const linal::Vector3D &MAX_ROTATION_ANGLES_RAD, const linal::Vector3D &MIN_ROTATION_ANGLES_RAD = linal::Vector3D( 0.0) )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>GenerateRandomRotation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>GenerateRandomTransformationInternal( const MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>Move( MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>MoveRotateRandom( const MoveRotateRandom &MOVE_ROTATE_RANDOM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>MoveRotateRandom( const double MAX_ROTATION_ANGLE_RAD, const bool INTERNAL = true)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>MoveRotateRandom( const double MIN_ROTATION_ANGLE_RAD, const double MAX_ROTATION_ANGLE_RAD, const bool INTERNAL = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>MoveRotateRandom( const linal::Vector3D &MAX_ROTATION_ANGLES_RAD, const bool INTERNAL = true)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>MoveRotateRandom( const linal::Vector3D &MIN_ROTATION_ANGLES_RAD, const linal::Vector3D &MAX_ROTATION_ANGLES_RAD, const bool INTERNAL = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random.h</td>
        <td>MoveRotateRandom</td>
        <td>MoveRotateRandom()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>GetMethod() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>GetMethodDescriptor( const MethodType &METHOD_TYPE)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>Move( MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>MoveRotateRandomExternalReference( const double MAX_ROTATION_ANGLE_RAD, const math::TransformationMatrix3D &REFERENCE_ORIENTATION = math::TransformationMatrix3D(), const MethodType ROTATION_METHOD = e_Internal )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>MoveRotateRandomExternalReference( const double MIN_ROTATION_ANGLE_RAD, const double MAX_ROTATION_ANGLE_RAD, const math::TransformationMatrix3D &REFERENCE_ORIENTATION = math::TransformationMatrix3D(), const MethodType ROTATION_METHOD = e_Internal )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>MoveRotateRandomExternalReference( const linal::Vector3D &MAX_ROTATION_ANGLES_RAD, const math::TransformationMatrix3D &REFERENCE_ORIENTATION = math::TransformationMatrix3D(), const MethodType ROTATION_METHOD = e_Internal )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>MoveRotateRandomExternalReference( const linal::Vector3D &MIN_ROTATION_ANGLES_RAD, const linal::Vector3D &MAX_ROTATION_ANGLES_RAD, const math::TransformationMatrix3D &REFERENCE_ORIENTATION = math::TransformationMatrix3D(), const MethodType ROTATION_METHOD = e_Internal )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>MoveRotateRandomExternalReference()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_rotate_random_external_reference.h</td>
        <td>MoveRotateRandomExternalReference</td>
        <td>SetMethod( const MethodType ROTATION_METHOD)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_transform_random.h</td>
        <td>MoveTransformRandom</td>
        <td>GenerateRandomTransformation( const MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_transform_random.h</td>
        <td>MoveTransformRandom</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_transform_random.h</td>
        <td>MoveTransformRandom</td>
        <td>Move( MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_transform_random.h</td>
        <td>MoveTransformRandom</td>
        <td>MoveTransformRandom( const double MAX_TRANSLATION, const double MAX_ROTATION_ANGLE_RAD, const bool INTERNAL = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_transform_random.h</td>
        <td>MoveTransformRandom</td>
        <td>MoveTransformRandom( const double MIN_TRANSLATION, const double MAX_TRANSLATION, const double MIN_ROTATION_ANGLE_RAD, const double MAX_ROTATION_ANGLE_RAD, const bool INTERNAL = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_transform_random.h</td>
        <td>MoveTransformRandom</td>
        <td>MoveTransformRandom( const linal::Vector3D &MAX_TRANSLATION, const linal::Vector3D &MAX_ROTATION_ANGLE_RAD, const bool INTERNAL = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_transform_random.h</td>
        <td>MoveTransformRandom</td>
        <td>MoveTransformRandom( const linal::Vector3D &MIN_TRANSLATION, const linal::Vector3D &MAX_TRANSLATION, const linal::Vector3D &MIN_ROTATION_ANGLE_RAD, const linal::Vector3D &MAX_ROTATION_ANGLE_RAD, const bool INTERNAL = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_transform_random.h</td>
        <td>MoveTransformRandom</td>
        <td>MoveTransformRandom()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_translate_defined.h</td>
        <td>MoveTranslateDefined</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_translate_defined.h</td>
        <td>MoveTranslateDefined</td>
        <td>Move( MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_translate_defined.h</td>
        <td>MoveTranslateDefined</td>
        <td>MoveTranslateDefined( const linal::Vector3D &TRANSLATION, const bool TRANSLATE_INTERNAL = true)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_translate_defined.h</td>
        <td>MoveTranslateDefined</td>
        <td>MoveTranslateDefined()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_translate_external_axis.h</td>
        <td>MoveTranslateExternalAxis</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_translate_external_axis.h</td>
        <td>MoveTranslateExternalAxis</td>
        <td>Move( MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_translate_external_axis.h</td>
        <td>MoveTranslateExternalAxis</td>
        <td>MoveTranslateExternalAxis( const double MIN_TRANSLATION, const double MAX_TRANSLATION, const Axis &EXTERNAL_AXIS )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_translate_external_axis.h</td>
        <td>MoveTranslateExternalAxis</td>
        <td>MoveTranslateExternalAxis()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_translate_random.h</td>
        <td>MoveTranslateRandom</td>
        <td>GenerateRandomTranslation( const linal::Vector3D &MAX_TRANSLATIONS, const linal::Vector3D &MIN_TRANSLATIONS = linal::Vector3D( 0.0) )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_translate_random.h</td>
        <td>MoveTranslateRandom</td>
        <td>GenerateRandomTranslation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_translate_random.h</td>
        <td>MoveTranslateRandom</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_translate_random.h</td>
        <td>MoveTranslateRandom</td>
        <td>Move( MovableInterface &MOVEABLE_OBJECT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_translate_random.h</td>
        <td>MoveTranslateRandom</td>
        <td>MoveTranslateRandom( const double MAX_TRANSLATION, const bool TRANSLATE_INTERNAL = true)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_translate_random.h</td>
        <td>MoveTranslateRandom</td>
        <td>MoveTranslateRandom( const double MIN_TRANSLATION, const double MAX_TRANSLATION, const bool TRANSLATE_INTERNAL = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_translate_random.h</td>
        <td>MoveTranslateRandom</td>
        <td>MoveTranslateRandom( const linal::Vector3D &MAX_TRANSLATIONS, const bool TRANSLATE_INTERNAL = true)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_move_translate_random.h</td>
        <td>MoveTranslateRandom</td>
        <td>MoveTranslateRandom( const linal::Vector3D &MIN_TRANSLATIONS, const linal::Vector3D &MAX_TRANSLATIONS, const bool TRANSLATE_INTERNAL = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_move_translate_random.h</td>
        <td>MoveTranslateRandom</td>
        <td>MoveTranslateRandom()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_orientation_interface.h</td>
        <td>OrientationInterface</td>
        <td>GenerateRandomTransformationAroundCenter( const double MAX_TRANSLATION, const double MAX_ROTATION, const linal::Vector3D &CENTER = linal::Vector3D() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_orientation_interface.h</td>
        <td>OrientationInterface</td>
        <td>GetAxis( const Axis &AXIS) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_orientation_interface.h</td>
        <td>OrientationInterface</td>
        <td>GetOrientation() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>Begin()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>Begin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>CenterPointCloud()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>DetermineNeighbors( const double DISTANCE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>End()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>End() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>GetCenter() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>GetData()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>GetData() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>GetSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>PointCloud( const storage::Vector< linal::Vector3D> &POINTS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>PointCloud()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>PushBack( const linal::Vector3D &POINT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>RemoveSingles( const size_t MIN_NEIGHBORS, const double DISTANCE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATIONMATRIX3D)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORMATIONMATRIX3D)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>WriteToPDB( const std::string &FILENAME) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>operator const storage::Vector< linal::Vector3D> &() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_cloud.h</td>
        <td>PointCloud</td>
        <td>operator storage::Vector< linal::Vector3D> &()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>GetAngularResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>GetCoordinateSystem() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>GetDistanceResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>PointToKeyCartesian( const double DISTANCE_RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>SetAngularResolution( const double ANGULAR_RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>SetDistanceResolution( const double DISTANCE_RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>operator ()( const linal::Vector3D &POINT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td>PointToKeyCartesian</td>
        <td>operator ()( const storage::Triplet< int, int, int> &TRIPLET) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td></td>
        <td>AddInstance( new PointToKeyCartesian( PointToKeyInterface::GetDefaultDistanceResolution()))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_cartesian.cpp</td>
        <td></td>
        <td>GetCoordinateSystemDescriptor()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_classes.h</td>
        <td>PointToKeyClasses</td>
        <td>GetPointToKeyFunction( const std::string &NAME, const double ANGULAR_RESOLUTION = PointToKeyInterface::GetDefaultAngularResolution(), const double DISTANCE_RESOLUTION = PointToKeyInterface::GetDefaultDistanceResolution() ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_classes.h</td>
        <td></td>
        <td>GetPointToKeyClasses()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_interface.h</td>
        <td>PointToKeyInterface</td>
        <td>GetDefaultAngularResolution()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_interface.h</td>
        <td>PointToKeyInterface</td>
        <td>GetDefaultDistanceResolution()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>GetAngularResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>GetCoordinateSystem() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>GetDistanceResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>PointToKeySpherical( const double ANGULAR_RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>SetAngularResolution( const double ANGULAR_RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>SetDistanceResolution( const double DISTANCE_RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>operator ()( const linal::Vector3D &POINT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td>PointToKeySpherical</td>
        <td>operator ()( const storage::Triplet< int, int, int> &TRIPLET) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td></td>
        <td>AddInstance( new PointToKeySpherical( PointToKeyInterface::GetDefaultAngularResolution()))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical.cpp</td>
        <td></td>
        <td>GetCoordinateSystemDescriptor()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical_radius.h</td>
        <td>PointToKeySphericalRadius</td>
        <td>GetAngularResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical_radius.h</td>
        <td>PointToKeySphericalRadius</td>
        <td>GetCoordinateSystem() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical_radius.h</td>
        <td>PointToKeySphericalRadius</td>
        <td>GetCoordinateSystemDescriptor()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical_radius.h</td>
        <td>PointToKeySphericalRadius</td>
        <td>GetDistanceResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical_radius.h</td>
        <td>PointToKeySphericalRadius</td>
        <td>PointToKeySphericalRadius( const double ANGULAR_RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical_radius.h</td>
        <td>PointToKeySphericalRadius</td>
        <td>SetAngularResolution( const double ANGULAR_RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical_radius.h</td>
        <td>PointToKeySphericalRadius</td>
        <td>SetDistanceResolution( const double DISTANCE_RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_point_to_key_spherical_radius.h</td>
        <td>PointToKeySphericalRadius</td>
        <td>operator ()( const linal::Vector3D &POINT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_point_to_key_spherical_radius.h</td>
        <td>PointToKeySphericalRadius</td>
        <td>operator ()( const storage::Triplet< int, int, int> &TRIPLET) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>Begin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>ConvexHull( const storage::Vector< linal::Vector2D> &POINTS, const double &MAX_SIDE_LENGTH = std::numeric_limits< double>::infinity(), const double &RADIUS = 0.0 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>End()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>Expand( const double &EXPANSION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>FindNearestSide( const linal::Vector2D &POINT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>GetArea() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>GetBarycenter() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>GetCenter() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>GetNumberOfSides() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>GetPerimeter() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>GetSides()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>GetSides() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>IsCornerOf( const linal::Vector2D &POINT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>IsWithin( const linal::Vector2D &POINT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>Polygon( const storage::Vector< linal::Vector2D> &POINTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>Polygon()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>PushBack( const linal::Vector2D &POINT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>operator const storage::Vector< LineSegment2D> &() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_polygon.h</td>
        <td>Polygon</td>
        <td>operator storage::Vector< LineSegment2D> &()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>DistanceAndVolumeOverlap( const Sphere &SPHERE) const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>DoesContain( const linal::Vector3D &POINT) const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>DoesOverlap( const Sphere &SPHERE) const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>FreeSurfaceAreaFraction( const util::SiPtrList< const Sphere> &SPHERES, const size_t NUMBER) const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>GetPosition() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>GetRadius() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>GetSurface() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>GetVolume() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>PointsOnSurfaceByLatiudes( const size_t NUMBER) const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>PointsOnSurfaceRandom( const size_t NUMBER) const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>PointsOnSurfaceSpiral( const size_t NUMBER) const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>Radius( const double VOLUME)
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>SetPosition( const linal::Vector3D &POSITION)
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>SetRadius( const double RADIUS)
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>Sphere( const linal::Vector3D &POSITION, const double RADIUS)
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>Sphere()
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>SurfaceArea( const double RADIUS)
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>SurfaceOverlap( const Sphere &SPHERE) const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>Volume( const double RADIUS)
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td>Sphere</td>
        <td>VolumeOverlap( const Sphere &SPHERE) const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td></td>
        <td>FreeSurface( const util::SiPtrVector< const Sphere> &SPHERES, const size_t NUMBER )
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_sphere.h</td>
        <td></td>
        <td>FreeSurfaceRatio( const util::SiPtrVector< const Sphere> &SPHERES, const size_t NUMBER )
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_sphere.h</td>
        <td></td>
        <td>ListOverlaps( const util::SiPtrVector< const Sphere> &SPHERES)
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>Begin() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>End() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>GetNumberCols() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>GetNumberOfElements() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>GetNumberRows() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>IsDefined() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>IsDiagonal() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>IsSquare() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>IsTriDiagonal() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>SetUnit()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const TransformationMatrix3D &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const util::UndefinedObject DEFINITION_STATE)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator ()( const size_t ROW, const size_t COL) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator =( const TransformationMatrix3D &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_coord_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator []( const size_t ROW) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_crypt.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_crypt_blowfish.h</td>
        <td>BlowFish</td>
        <td>BlowFish( const std::string &PASSWORD)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_crypt_blowfish.h</td>
        <td>BlowFish</td>
        <td>BlowFish()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_crypt_blowfish.h</td>
        <td>BlowFish</td>
        <td>Decrypt( const std::string &ENCRYPTED_MESSAGE)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_crypt_blowfish.h</td>
        <td>BlowFish</td>
        <td>Encrypt( const std::string &ORIGINAL_MESSAGE)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_crypt_blowfish.h</td>
        <td>BlowFish</td>
        <td>SetPassword( const std::string &PASSWORD)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_crypt_sha1.h</td>
        <td>Sha1</td>
        <td>Hash( const std::string &ORIGINAL_MESSAGE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_crypt_sha1.h</td>
        <td>Sha1State</td>
        <td>Sha1State( const std::string &STRING)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_crypt_sha1.h</td>
        <td>Sha1State</td>
        <td>ToHexString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>ConnectionIntensity( const Map &DENSITY_MAP, const linal::Vector3D &COORDINATE_A, const linal::Vector3D &COORDINATE_B )
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>Connectivity( const util::ShPtr< assemble::SSEGeometryInterface> &BODY_A, const bool BODY_A_BEGIN, const util::ShPtr< assemble::SSEGeometryInterface> &BODY_B, const bool BODY_B_BEGIN, const double CONNECTIVITY = util::GetUndefinedDouble(), const double DISTANCE = util::GetUndefinedDouble() )
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>Connectivity()
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>DetermineConnectivities( const Map &DENSITY_MAP, const util::ShPtr< assemble::SSEGeometryInterface> &BODY_A, const util::ShPtr< assemble::SSEGeometryInterface> &BODY_B )
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>DetermineConnectivities( const Map &DENSITY_MAP, const util::ShPtrList< assemble::SSEGeometryInterface> &BODIES )
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetBodyA() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetBodyB() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetConnectivity() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetDistance() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetOrientationA() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetOrientationB() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_connectivity.h</td>
        <td>LessThan</td>
        <td>operator ()( const Connectivity &CONNECTIVITY_LHS, const Connectivity &CONNECTIVITY_RHS ) const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_connectivity.h</td>
        <td></td>
        <td>operator ==( const Connectivity &CONNECTIVITY_LHS, const Connectivity &CONNECTIVITY_RHS)
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_fit_protein_minimizer_mc.h</td>
        <td>FitProteinMinimizerMC</td>
        <td>FitProteinMinimizerMC()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_fit_protein_minimizer_mc.h</td>
        <td>FitProteinMinimizerMC</td>
        <td>SetMaxIterations( const size_t MAX_NUMBER_ITERATIONS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_fit_protein_minimizer_mc.h</td>
        <td>FitProteinMinimizerMC</td>
        <td>SetMaxTranslationAndRotation( const double MAX_TRANSLATION, const double MAX_ROTATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_fit_protein_minimizer_mc.h</td>
        <td>FitProteinMinimizerMC</td>
        <td>SetProteinAgreement( const ProteinAgreement &AGREEMENT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_fit_protein_minimizer_mc.h</td>
        <td>FitProteinMinimizerMC</td>
        <td>SetResolution( const double RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_fit_protein_minimizer_mc.h</td>
        <td>FitProteinMinimizerMC</td>
        <td>SetSimulator( const Simulator &DENSITY_SIMULATOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_fit_protein_minimizer_mc.h</td>
        <td>FitProteinMinimizerMC</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL, const Map &DENSITY_MAP) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>FitProteinMinimizerPowell</td>
        <td>FitProteinMinimizerPowell()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>FitProteinMinimizerPowell</td>
        <td>SetMaxIterations( const size_t MAX_NUMBER_ITERATIONS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>FitProteinMinimizerPowell</td>
        <td>SetMaxTranslationAndRotation( const double MAX_TRANSLATION, const double MAX_ROTATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>FitProteinMinimizerPowell</td>
        <td>SetProteinAgreement( const ProteinAgreement &AGREEMENT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>FitProteinMinimizerPowell</td>
        <td>SetResolution( const double RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>FitProteinMinimizerPowell</td>
        <td>SetSimulator( const Simulator &DENSITY_SIMULATOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>FitProteinMinimizerPowell</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL, const Map &DENSITY_MAP) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>PositionCorrelation( const util::ShPtr< ProteinAgreementInterface> &AGREEMENT, const assemble::ProteinModel &PROTEIN_MODEL )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>TransformedHardCopy( const assemble::ProteinModel &PROTEIN_MODEL, const linal::Vector< double> &VECTOR )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>operator ()( const linal::Vector< double> &VECTOR) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_fit_protein_minimizers.h</td>
        <td></td>
        <td>GetFitProteinMinimizers()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>AddNoise( const random::DistributionInterface &RNG, const double MEAN, const double STANDARD_DEVIATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>BalanceIntensities( const double LENGTH)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>CalculateMinMaxMeanRmsd()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>CalculatePointCloud( const size_t NUMBER_OF_POINTS, const double FEATURE_DISTANCE, const double RATIO_INTENSITY_GRADIENT ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>CommonSubTensor( const Map &DENSITY_MAP) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>ConvertDensityToSpline() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>Correlation( const Map &DENSITY_MAP) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>CrossCorrelationCoefficient( const Map &SIMULATED_DENSITY_MAP, const double CONTOUR_LEVEL ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>EdgeDetectionSobel( const double WEIGTH_FACE = double( 6), const double WEIGHT_EDGE = double( 3), const double WEIGHT_VERTEX = double( 1) )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetAngles() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetAxis() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetCellWidth() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetData()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetData() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetDefaultAngle()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetDefaultAxis()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetDimensions() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetIndex() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetIntervals() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetMaximum() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetMean() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetMinimum() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetOrigin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetRmsd() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetUnitCellLength() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetVolume() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>GetVoxelVolume() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>Histogram( const size_t NR_BINS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>Map( const Map &DENSITY_MAP)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>Map( const math::Tensor< double> &DATA, const linal::VectorND< int, 3> &INDEX, const linal::VectorND< int, 3> &INTERVALS, const linal::Vector3D &LENGTH, const linal::Vector3D &CELLWIDTH, const linal::Vector3D &ANGLE, const linal::VectorND< int, 3> &AXIS, const linal::Vector3D &ORIGIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>Map()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>Normalize()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>OrthogonalizeMap() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>ReadMRC( std::istream &ISTREAM, const size_t EXTENDED_HEADER = 0)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>StandardDeviation( const Map &DENSITY_MAP) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>SubMap( const size_t POSCOL, const size_t POSROW, const size_t POSLAYER, const size_t NCOL, const size_t NROW, const size_t NLAYER ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>WriteHeader( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>WriteMRC( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>operator ()( const linal::VectorND< size_t, 3> &INDEX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>operator ()( const linal::VectorND< size_t, 3> &INDEX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>operator ()( const size_t COL, const size_t ROW, const size_t LAYER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>operator ()( const size_t COL, const size_t ROW, const size_t LAYER) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>operator ()( const storage::VectorND< 3, size_t> &INDEX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>operator ()( const storage::VectorND< 3, size_t> &INDEX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>Map</td>
        <td>operator =( const Map &MAP_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>VoxelDensityGreater</td>
        <td>operator ()( const Voxel &VOXEL_LHS, const Voxel &VOXEL_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map.h</td>
        <td>VoxelOverlap</td>
        <td>VoxelOverlap( const double FEATURE_DISTANCE, const linal::Vector3D &CELL_WIDTH )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map.h</td>
        <td>VoxelOverlap</td>
        <td>operator ()( const Voxel &VOXEL_LHS, const Voxel &VOXEL_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>CalculateCylindricalMaps( const util::SiPtrList< const assemble::SSEGeometryInterface> &BODIES, const Map &DENSITY_MAP, const double &HEIGHT_RESOLUTION, const double &RADIUS_RESOLUTION, const size_t &NUMBER_WEDGES, const double &UPPER_RADIUS )
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>GetData() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>GetDimensions() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>GetMaximum() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>GetMean() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>GetMinimum() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>GetSize() const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>MapCylindrical( const assemble::SSEGeometryInterface &BODY, const Map &DENSITY_MAP, const double &HEIGHT_RESOLUTION, const double &RADIUS_RESOLUTION, const size_t &NUMBER_WEDGES, const double &UPPER_RADIUS )
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>MapCylindrical( const assemble::SSEGeometryInterface &BODY, math::TricubicSpline &SPLINE, const double &HEIGHT_RESOLUTION, const double &RADIUS_RESOLUTION, const size_t &NUMBER_WEDGES, const double &UPPER_RADIUS )
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>MapCylindrical()
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>OneDProfileAngle( const double &LOWER_RADIUS, const double &UPPER_RADIUS) const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>OneDProfileHeight( const double &LOWER_RADIUS, const double &UPPER_RADIUS) const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>OneDProfileRadius( const double &LOWER_RADIUS, const double &UPPER_RADIUS) const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>TwoDProfileHeightAngle( const double &LOWER_RADIUS, const double &UPPER_RADIUS) const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>TwoDProfileHeightRadius( const double &LOWER_RADIUS, const double &UPPER_RADIUS) const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>TwoDProfileRadiusAngle( const double &LOWER_RADIUS, const double &UPPER_RADIUS) const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>operator ()( const size_t LAYER, const size_t ROW, const size_t COL)
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>operator ()( const size_t LAYER, const size_t ROW, const size_t COL) const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>operator ()( const storage::VectorND< 3, size_t> &INDEX)
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_map_cylindrical.h</td>
        <td>MapCylindrical</td>
        <td>operator ()( const storage::VectorND< 3, size_t> &INDEX) const
</td>
        <td>linders, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>CalculateMeanSD( const Map &DENSITY_MAP) const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>CalculateMeanSDCommonRegion( const Map &DENSITY_MAP, const storage::VectorND< 2, storage::VectorND< 3, size_t> > &OVERLAP ) const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>CommonOverlap( const storage::VectorND< 2, storage::VectorND< 3, size_t> > &RANGE_ONE, const storage::VectorND< 2, storage::VectorND< 3, size_t> > &RANGE_TWO )
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>CrossCorrelationCoefficient( const Map &DENSITY_MAP_EXP, const Map &DENSITY_MAP_SIM ) const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>DetermineGridCorners( const util::SiPtrVector< const linal::Vector3D> &COORDS )
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>GetGridSpacing() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>GetIndex() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>GetMask() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>GetPosition() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>Mask3d( const util::SiPtrVector< const linal::Vector3D> &COORDS, const double MASKING_DISTANCE, const linal::Vector3D &GRID_SPACING, const linal::Vector3D &CELL_POSITION )
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_mask_3d.h</td>
        <td>Mask3d</td>
        <td>Mask3d()
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>CrossCorrelationCoefficient( const Map &EXPERIMENTAL_DENSITY_MAP, const Map &SIMULATED_DENSITY_MAP, const double CONTOUR_LEVEL_SIMULATED )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>GetDensity() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>GetSimulator() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>ProteinAgreementCCC( const bool ADD_SIDECHAIN_ATOMS, const bool MULTIPLY_WITH_NUMBER_AAS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>SetDensityMap( const util::SiPtr< const Map> &SP_DENSITY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>SetSimulator( const util::ShPtr< SimulateInterface> &SP_SIMULATOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreement_likelihood.h</td>
        <td>ProteinAgreementLikelihood</td>
        <td>GetDensity() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreement_likelihood.h</td>
        <td>ProteinAgreementLikelihood</td>
        <td>GetScheme() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreement_likelihood.h</td>
        <td>ProteinAgreementLikelihood</td>
        <td>GetSimulator() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreement_likelihood.h</td>
        <td>ProteinAgreementLikelihood</td>
        <td>ProteinAgreementLikelihood( const bool HIGH_RESOLUTION, const storage::Set< biol::AtomType> &ATOM_TYPES, const math::FunctionInterfaceSerializable< double, double> &MEAN_CCC_RESOLUTION_FUNCTION, const math::FunctionInterfaceSerializable< double, double> &SD_CCC_RESOLUTION_FUNCTION )
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreement_likelihood.h</td>
        <td>ProteinAgreementLikelihood</td>
        <td>ProteinAgreementLikelihood()
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreement_likelihood.h</td>
        <td>ProteinAgreementLikelihood</td>
        <td>SetDensityMap( const util::SiPtr< const Map> &SP_DENSITY)
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreement_likelihood.h</td>
        <td>ProteinAgreementLikelihood</td>
        <td>SetSimulator( const util::ShPtr< SimulateInterface> &SP_SIMULATOR)
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreement_likelihood.h</td>
        <td>ProteinAgreementLikelihood</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreements.h</td>
        <td>ProteinAgreements</td>
        <td>AddAgreement( const util::ShPtr< ProteinAgreementInterface> &SP_PROTEIN_AGREEMENT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_protein_agreements.h</td>
        <td>ProteinAgreements</td>
        <td>CreateProteinAgreement( const ProteinAgreement &PROTEIN_AGREEMENT, const Simulator &SIMULATOR, const util::SiPtr< const Map> &SP_DENSITY, const double RESOLUTION ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_protein_agreements.h</td>
        <td></td>
        <td>GetProteinAgreements()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_simulate_default.h</td>
        <td>SimulateDefault</td>
        <td>GetKernelDescriptor( const Kernel &KERNEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_simulate_default.h</td>
        <td>SimulateDefault</td>
        <td>GetResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_simulate_default.h</td>
        <td>SimulateDefault</td>
        <td>SetGridSpacing( const linal::Vector3D &GRID_SPACING)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_simulate_default.h</td>
        <td>SimulateDefault</td>
        <td>SetMargin( const size_t MARGIN)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_simulate_default.h</td>
        <td>SimulateDefault</td>
        <td>SetResolution( const double RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_simulate_default.h</td>
        <td>SimulateDefault</td>
        <td>SimulateDefault( const linal::Vector3D &GRID_SPACING, const double RESOLUTION, const Kernel SMOOTHING_KERNEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_simulate_default.h</td>
        <td>SimulateDefault</td>
        <td>operator ()( const util::SiPtrVector< const biol::Atom> &ATOMS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_simulate_gaussian_sphere.h</td>
        <td>SimulateGaussianSphere</td>
        <td>GetResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_simulate_gaussian_sphere.h</td>
        <td>SimulateGaussianSphere</td>
        <td>SetGridSpacing( const linal::Vector3D &GRID_SPACING)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_simulate_gaussian_sphere.h</td>
        <td>SimulateGaussianSphere</td>
        <td>SetMargin( const size_t MARGIN)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_simulate_gaussian_sphere.h</td>
        <td>SimulateGaussianSphere</td>
        <td>SetResolution( const double RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_simulate_gaussian_sphere.h</td>
        <td>SimulateGaussianSphere</td>
        <td>SimulateGaussianSphere( const linal::Vector3D &GRID_SPACING, const double RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_simulate_gaussian_sphere.h</td>
        <td>SimulateGaussianSphere</td>
        <td>operator ()( const util::SiPtrVector< const biol::Atom> &ATOMS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_simulate_interface.h</td>
        <td>SimulateInterface</td>
        <td>DetermineGridCorners( const util::SiPtrVector< const biol::Atom> &ATOMS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_simulators.h</td>
        <td>Simulators</td>
        <td>CreateSimulator( const Simulator &SIMULATOR, const linal::Vector3D &GRID_SPACING, const double RESOLUTION ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_simulators.h</td>
        <td>Simulators</td>
        <td>GetDefaultGridSpacing()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_density_simulators.h</td>
        <td>Simulators</td>
        <td>GetDefaultResolution()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_density_simulators.h</td>
        <td></td>
        <td>GetSimulators()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_atom_position.h</td>
        <td>AAAtomPosition</td>
        <td>AAAtomPosition()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_atom_property.h</td>
        <td>AAAtomProperty</td>
        <td>AAAtomProperty( const bool &CONSIDER_SIDE_CHAIN, const bool &CONSIDER_BACK_BONE, const bool &COMPUTE_MEAN, const CheminfoProperty &PROPERTY = CheminfoProperty() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_blast_profile.h</td>
        <td>AABlastProfile</td>
        <td>AABlastProfile( const Method &METHOD = e_Log10)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_blast_profile.h</td>
        <td>AABlastProfile</td>
        <td>GetMethodName( const Method &METHOD)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_blast_profile_entropy.h</td>
        <td>AABlastProfileEntropy</td>
        <td>AABlastProfileEntropy( const bool &INITIALIZE = true)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_blast_profile_entropy.h</td>
        <td>AABlastProfileEntropy</td>
        <td>ComputeBlastSSEntropy( const iterate::Generic< const biol::AABase> &ITR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_blast_weighted_property.h</td>
        <td>AABlastWeightedProperty</td>
        <td>AABlastWeightedProperty( const Method &METHOD = e_LogPOffset)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_blast_weighted_property.h</td>
        <td>AABlastWeightedProperty</td>
        <td>AABlastWeightedProperty( const biol::AATypeData::PropertyType &PROPERTY, const Method &METHOD = e_LogPOffset)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_blast_weighted_property.h</td>
        <td>AABlastWeightedProperty</td>
        <td>GetMethodName( const Method &METHOD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_blast_weighted_property.h</td>
        <td>AABlastWeightedProperty</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_distance_from_aa_type.h</td>
        <td>AADistanceFromAAType</td>
        <td>AADistanceFromAAType( const bool &USE_BLAST_PROBABILITY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_distance_to_tm_center.h</td>
        <td>AADistanceToTMCenter</td>
        <td>AADistanceToTMCenter( const bool &MEMBRANE_NORM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_dssp_info.h</td>
        <td>AADSSPInfo</td>
        <td>AADSSPInfo( const DSSPInfoTypeEnum &INFO_TYPE_ENUM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_dssp_info.h</td>
        <td>AADSSPInfo</td>
        <td>GetDSSPInfoTypeDescription( const DSSPInfoType &DSSP_INFO_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_dssp_info.h</td>
        <td>AADSSPInfo</td>
        <td>GetDSSPInfoTypeString( const DSSPInfoType &DSSP_INFO_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_hbond_neighbor.h</td>
        <td>AAHbondNeighbor</td>
        <td>AAHbondNeighbor( const util::Implementation< Base< biol::AABase, float> > &IMPL = ( util::Implementation< Base< biol::AABase, float> >()) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_identifier.h</td>
        <td>AAIdentifier</td>
        <td>AAIdentifier( const bool &SEQ_ID)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_identifier.h</td>
        <td>AAIdentifier</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_inside_outside_membrane.h</td>
        <td>AAInsideOutsideMembrane</td>
        <td>AAInsideOutsideMembrane()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_molecule_property.h</td>
        <td>AAMoleculeProperty</td>
        <td>AAMoleculeProperty( const bool &CONSIDER_SIDE_CHAIN, const bool &CONSIDER_BACK_BONE, const CheminfoProperty &PROPERTY = CheminfoProperty() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_pair_ss_probability.h</td>
        <td>AAPairSSProbability</td>
        <td>AAPairSSProbability()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_pair_ss_probability.h</td>
        <td>AAPairSSProbability</td>
        <td>GetAATypeId()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_pair_ss_probability.h</td>
        <td>AAPairSSProbability</td>
        <td>GetColumnOffset( const SSInfoType &SS_INFO_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_pair_ss_probability.h</td>
        <td>AAPairSSProbability</td>
        <td>GetDirectionality( const SSInfoType &SS_INFO_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_pair_ss_probability.h</td>
        <td>AAPairSSProbability</td>
        <td>GetSSInfoTypeString( const SSInfoType &SS_INFO_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_pair_type.h</td>
        <td>AAPairType</td>
        <td>AAPairType( const bool &SYMMETRIC = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_phi_psi.h</td>
        <td>AAPhiPsi</td>
        <td>AAPhiPsi( const bool &PHI, const float &ORIGIN)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_pore_orientation.h</td>
        <td>AAPoreOrientation</td>
        <td>AAPoreOrientation( const bool &USE_TM_ORIENTATION = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_position_in_tm.h</td>
        <td>AAPositionInTM</td>
        <td>AAPositionInTM()
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_property.h</td>
        <td>AAProperty</td>
        <td>AAProperty( const biol::AATypeData::PropertyType &PROPERTY)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_property.h</td>
        <td>AAProperty</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_sasa.h</td>
        <td>AASasa</td>
        <td>AASasa( const assemble::AAExposureInterface &EXPOSURE_MEASURE, const std::string &ALIAS, const std::string &DESCRIPTION )
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_sasa.h</td>
        <td>AASasa</td>
        <td>WriteNCNV( const size_t MINIMAL_SEQUENCE_SEPARATION, std::ostream &OSTREAM, const char &CHAIN_ID, const assemble::ProteinModel &MODEL )
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_seq_id.h</td>
        <td>AASeqID</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_ss_tm_prediction.h</td>
        <td>AASSTMPrediction</td>
        <td>AASSTMPrediction( const std::string &ALIAS, const bool CONSIDER_MEMBRANE, const bool CONSIDER_SS )
</td>
        <td>karakam, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_ss_tm_prediction.h</td>
        <td>AASSTMPrediction</td>
        <td>SetMethod( const sspred::Method &METHOD)
</td>
        <td>karakam, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_sse_info.h</td>
        <td>AASSEInfo</td>
        <td>AASSEInfo( const SSEInfoTypeEnum &SSE_INFO_TYPE_ENUM)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_sse_info.h</td>
        <td>AASSEInfo</td>
        <td>GetSSEInfoTypeString( const SSEInfoType &SSE_INFO_TYPE)
</td>
        <td>teixeipl, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_tm_direction.h</td>
        <td>AATMDirection</td>
        <td>AATMDirection( const sspred::CIPhiPsi::TMDirectionTypeEnum &DIRECTION, const std::string &ALIAS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_triplet_helix_location_type.h</td>
        <td>AATripletHelixLocationType</td>
        <td>AATripletHelixLocationType()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_aa_triplet_lookup.h</td>
        <td>AATripletLookup</td>
        <td>AATripletLookup()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_aa_triplet_type.h</td>
        <td>AATripletType</td>
        <td>AATripletType( const bool &SYMMETRIC = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_aromaticity_axes.h</td>
        <td>AtomAromaticityAxes</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_effective_polarizability.h</td>
        <td>AtomEffectivePolarizability</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_estimated_surface_area.h</td>
        <td>AtomEstimatedSurfaceArea</td>
        <td>AtomEstimatedSurfaceArea( const bool &COVALENT_RADIUS = true, const bool &USE_CSD_VDW = true)
</td>
        <td>geanesar, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_estimated_surface_area.h</td>
        <td>AtomEstimatedSurfaceArea</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_formal_charge.h</td>
        <td>AtomFormalCharge</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_hbond_info.h</td>
        <td>AtomHBondInfo</td>
        <td>AtomHBondInfo( const Method &METHOD)
</td>
        <td>geanesar, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_hbond_info.h</td>
        <td>AtomHBondInfo</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_is_sp3.h</td>
        <td>AtomIsSP3</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_lone_pair_en.h</td>
        <td>AtomLonePairEN</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_misc_property.h</td>
        <td>AtomMiscProperty</td>
        <td>AtomMiscProperty( const std::string &NAME, const size_t &PROPERTIES_PER_ATOM)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_misc_property.h</td>
        <td>AtomMiscProperty</td>
        <td>AtomMiscProperty()
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_misc_property.h</td>
        <td>AtomMiscProperty</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_neighbor_direction.h</td>
        <td>AtomNeighborDirection</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_number_valences.h</td>
        <td>AtomNumberValences</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_pi_charge.h</td>
        <td>AtomPiCharge</td>
        <td>AtomPiCharge( const bool &GET_CHARGE = true)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_pi_charge.h</td>
        <td>AtomPiCharge</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_planarity.h</td>
        <td>AtomPlanarity</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_polarizability.h</td>
        <td>AtomPolarizability</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_polarizability.h</td>
        <td>AtomPolarizability</td>
        <td>GetPolarizability( const chemistry::AtomConformationalInterface &ATOM)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_ring_size.h</td>
        <td>AtomRingSize</td>
        <td>AtomRingSize( const bool &LARGEST)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_ring_size.h</td>
        <td>AtomRingSize</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_sigma_charge.h</td>
        <td>AtomSigmaCharge</td>
        <td>AtomSigmaCharge( const bool &GET_CHARGE = true)
</td>
        <td>geanesa, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_sigma_charge.h</td>
        <td>AtomSigmaCharge</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesa, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_stereocenters.h</td>
        <td>AtomStereocenters</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_surface_area.h</td>
        <td>AtomSurfaceArea</td>
        <td>AtomSurfaceArea( const util::Implementation< Base< chemistry::AtomConformationalInterface, float> > &MAX_RADIUS, const util::Implementation< Base< chemistry::AtomConformationalInterface, float> > &MIN_RADIUS )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_surface_area.h</td>
        <td>AtomSurfaceArea</td>
        <td>AtomSurfaceArea()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_surface_area.h</td>
        <td>AtomSurfaceArea</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_topological_polar_surface_area.h</td>
        <td>AtomTopologicalPolarSurfaceArea</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_type_number.h</td>
        <td>AtomTypeNumber</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_type_property_retriever.h</td>
        <td>AtomTypePropertyRetriever</td>
        <td>AtomTypePropertyRetriever( const chemistry::AtomTypeData::Properties &PROPERTY)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_type_property_retriever.h</td>
        <td>AtomTypePropertyRetriever</td>
        <td>AtomTypePropertyRetriever()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_type_property_retriever.h</td>
        <td>AtomTypePropertyRetriever</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_vcharge.h</td>
        <td>AtomVcharge</td>
        <td>AtomVcharge( const size_t &VERSION)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_vcharge.h</td>
        <td>AtomVcharge</td>
        <td>AtomVcharge()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_vcharge.h</td>
        <td>AtomVcharge</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_volume.h</td>
        <td>AtomVolume</td>
        <td>AtomVolume( const util::Implementation< Base< chemistry::AtomConformationalInterface, float> > &MAX_RADIUS, const util::Implementation< Base< chemistry::AtomConformationalInterface, float> > &MIN_RADIUS )
</td>
        <td>loweew, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atom_volume.h</td>
        <td>AtomVolume</td>
        <td>AtomVolume()
</td>
        <td>loweew, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_atom_volume.h</td>
        <td>AtomVolume</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>loweew, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_atomic_number.h</td>
        <td>AtomicNumber</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_band_pass_filter.h</td>
        <td>BandPassFilter</td>
        <td>BandPassFilter( const bool &REFLECTING)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_band_pass_filter.h</td>
        <td>BandPassFilter</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>Base( const Base &BASE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>Base( const size_t &DIMENSION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>Base()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>CollectValuesOnEachElementOfObject( const SequenceInterface< t_DataType> &SEQ)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>CollectValuesOnEachElementOfObject( const SequenceInterface< t_DataType> &SEQ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>ConsiderRepeatedElements() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>DimensionIsWellDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>GetCacheLabel() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>GetCachePreference() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>GetEffectiveType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>GetSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>GetSymmetry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>GetType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>InjectDimensions() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>Recalculate( const Iterator< t_DataType> &ITR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>SetDimension( const size_t &NEW_DIMENSION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>SetObject( const SequenceInterface< t_DataType> &SEQUENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>SumOverObject( const SequenceInterface< t_DataType> &SEQ)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>SumOverObject( const SequenceInterface< t_DataType> &SEQ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>WriteInstancesHelp( io::FixedLineWidthWriter &STREAM, const storage::Map< std::string, util::OwnPtr< Base> > &INSTANCES, bool FULL_HELP )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base.h</td>
        <td>Base</td>
        <td>operator ()( const Iterator< t_DataType> &ITR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_base_sequence.h</td>
        <td>BaseSequence</td>
        <td>operator ()( const Iterator< t_DataType> &ITR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_base_sequence.h</td>
        <td>BaseSequence</td>
        <td>operator ()( const SequenceInterface< t_DataType> &SEQUENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_binary_operation.h</td>
        <td>BinaryOperation</td>
        <td>BinaryOperation( const util::Implementation< Base< t_DataType, float> > &LHS, const util::Implementation< math::AssignmentOperationInterface< float> > &OPERATION, const util::Implementation< Base< t_DataType, float> > &RHS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_binary_operation.h</td>
        <td>BinaryOperation</td>
        <td>BinaryOperation( const util::Implementation< math::AssignmentOperationInterface< float> > &OPERATION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_binary_operation.h</td>
        <td>BinaryOperation</td>
        <td>GetAssignmentOperation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_bond_type_count.h</td>
        <td>BondTypeCount</td>
        <td>BondTypeCount( const chemistry::ConfigurationalBondTypeData::Data &PROPERTY, const size_t &PARAMETER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_bond_type_count.h</td>
        <td>BondTypeCount</td>
        <td>BondTypeCount()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_bond_type_count.h</td>
        <td>BondTypeCount</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_buser_metric.h</td>
        <td>BuserMetric</td>
        <td>BuserMetric()
</td>
        <td>vuot</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_buser_metric.h</td>
        <td>BuserMetric</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>vuot</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>CacheMap( const CacheMap &PARENT, const storage::Map< std::string, std::string> &MAP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>CacheMap()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>ExtractRelatedProperties( const key_type &NAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>Find( const key_type &NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>Get( const key_type &NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>GetMap() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>Has( const key_type &NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>Insert( const key_type &NAME, const value_type &PROPERTY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>InsertIfNumerical( const std::string &KEY, const std::string &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>InsertNumericalMapItems( const storage::Map< std::string, std::string> &MAP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>Merge( const CacheMap &MAP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>Remove( const key_type &NAME, const bool &REMOVE_DEPENDENT = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_cache_map.h</td>
        <td>CacheMap</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_central_2da_sign.h</td>
        <td>Central2DASign</td>
        <td>Central2DASign( const CheminfoProperty &ATOM_PROPERTY, const size_t MAX_CENTER_BOND_DISTANCE, const size_t NUMBER_2DA_STEPS, const float &TEMPERATURE, const bool &SMOOTH )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_central_2da_sign.h</td>
        <td>Central2DASign</td>
        <td>Central2DASign()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_central_2da_sign.h</td>
        <td>Central2DASign</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_cheminfo_properties.h</td>
        <td>CheminfoProperties</td>
        <td>GetEnums()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_cheminfo_properties.h</td>
        <td></td>
        <td>GetCheminfoProperties()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>Begin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>Combine( const CachePreference &CACHE_PREF = e_IgnoreCache)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>End()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>GetLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>GetType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>PushBack( const util::Implementation< Base< t_DataType, t_ReturnType> > &PROPERTY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_combine.h</td>
        <td>Combine</td>
        <td>operator ==( const Combine &COMBINE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_constants.h</td>
        <td>Constants</td>
        <td>Constants( const linal::Vector< t_ReturnType> &DESCRIPTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_constants.h</td>
        <td>Constants</td>
        <td>Constants( const t_ReturnType &DESCRIPTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_constants.h</td>
        <td>Constants</td>
        <td>Constants()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_constants.h</td>
        <td>Constants</td>
        <td>Constants()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_constants.h</td>
        <td>Constants</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_coulombic_force.h</td>
        <td>CoulombicForce</td>
        <td>CoulombicForce( bool DIHEDRAL_INTERACTIONS_ONLY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_coulombic_force.h</td>
        <td>CoulombicForce</td>
        <td>CoulombicForce( const CheminfoProperty &ATOM_PROPERTY, const double &DISTANCE_CUTOFF = std::numeric_limits< double>::infinity() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_coulombic_force.h</td>
        <td>CoulombicForce</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_coulombic_force.h</td>
        <td>CoulombicForce</td>
        <td>GetIntermolecularForce( const chemistry::ConformationInterface &MOL_A, const chemistry::ConformationInterface &MOL_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_coulombic_force.h</td>
        <td>CoulombicForce</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_coulombic_force.h</td>
        <td>CoulombicForce</td>
        <td>GetSumAbsIntermolecularForce( const chemistry::ConformationInterface &MOL_A, const chemistry::ConformationInterface &MOL_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>AddData( const size_t &ROW, const linal::VectorConstInterface< float> &FEATURE, const linal::VectorConstInterface< float> &RESULT, const linal::VectorConstInterface< char> &ID )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>AddRows( const size_t &N_ROWS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>Append( const Dataset &DATASET)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>Dataset( const linal::MatrixConstInterface< float> &FEATURES, const linal::MatrixConstInterface< float> &RESULTS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>Dataset( const linal::MatrixConstInterface< float> &FEATURES, const linal::MatrixConstInterface< float> &RESULTS, const linal::MatrixConstInterface< char> &IDS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>Dataset( const size_t &NR_EXAMPLES, const model::FeatureLabelSet &FEATURE_LABELS, const model::FeatureLabelSet &RESULT_LABELS, const model::FeatureLabelSet &ID_LABELS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>Dataset( const size_t &NR_EXAMPLES, const size_t &FEATURE_SIZE, const size_t &RESULT_SIZE, const size_t &ID_SIZE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>Dataset( const storage::Vector< storage::VectorND< 2, linal::Vector< float> > > &DATA_SET )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>Dataset( const util::ShPtr< model::FeatureDataSet< float> > &FEATURES, const util::ShPtr< model::FeatureDataSet< float> > &RESULTS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>Dataset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetFeatureSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetFeatures()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetFeaturesPtr() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetFeaturesReference()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetFeaturesReference() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetIdSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetIds()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetIdsPtr() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetIdsReference()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetIdsReference() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetResultSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetResults()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetResultsPtr() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetResultsReference()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetResultsReference() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetRows( const storage::Vector< size_t> &KEEPERS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>HardCopy() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>IsEmpty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>KeepRows( const storage::Vector< size_t> &KEEPERS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>RemoveUndefinedExamples()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>SetFeatures( const util::ShPtr< model::FeatureDataSet< float> > &FEATURES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>SetIds( const util::ShPtr< model::FeatureDataSet< char> > &IDS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>SetResults( const util::ShPtr< model::FeatureDataSet< float> > &RESULTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>ShrinkRows( const size_t &NEW_SIZE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>Shuffle()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset.h</td>
        <td>Dataset</td>
        <td>YScramble()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>DatasetBuilder( const util::ObjectDataLabel &FEATURE, const util::ObjectDataLabel &RESULT, const util::ObjectDataLabel &ID )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>DatasetBuilder()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>GetFeatureCode() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>GetFeatureSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>GetIdCode() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>GetIdSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>GetResultCode() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>GetResultSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>GetType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>SetFeatureCode( const util::ObjectDataLabel &FEATURES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>SetIdCode( const util::ObjectDataLabel &IDS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>SetResultsCode( const util::ObjectDataLabel &RESULTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>SetType( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>operator ()( const SequenceInterface< t_DataType> &SEQUENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_dataset_builder.h</td>
        <td>DatasetBuilder</td>
        <td>operator ()( const iterate::Generic< const SequenceInterface< t_DataType> > &ITERATOR, const size_t &START = 0, const size_t &MAX_FEATURES = std::numeric_limits< size_t>::max() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_define.h</td>
        <td>Define</td>
        <td>Define( const util::ObjectDataLabel &LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_define.h</td>
        <td>Define</td>
        <td>Define()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_define.h</td>
        <td>Define</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_element_histogram_1d.h</td>
        <td>ElementHistogram1D</td>
        <td>ElementHistogram1D()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_element_histogram_1d.h</td>
        <td>ElementHistogram1D</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_element_histogram_1d.h</td>
        <td>ElementHistogram1D</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_element_histogram_1d.h</td>
        <td>ElementHistogram1D</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_element_histogram_2d.h</td>
        <td>ElementHistogram2D</td>
        <td>ElementHistogram2D()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_element_histogram_2d.h</td>
        <td>ElementHistogram2D</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_element_histogram_2d.h</td>
        <td>ElementHistogram2D</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_element_histogram_2d.h</td>
        <td>ElementHistogram2D</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_element_position.h</td>
        <td>ElementPosition</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_element_type_property_retriever.h</td>
        <td>ElementTypePropertyRetriever</td>
        <td>ElementTypePropertyRetriever( const chemistry::ElementTypeData::Properties &PROPERTY)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_element_type_property_retriever.h</td>
        <td>ElementTypePropertyRetriever</td>
        <td>ElementTypePropertyRetriever()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_element_type_property_retriever.h</td>
        <td>ElementTypePropertyRetriever</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_example_string_sequence.h</td>
        <td>StringSequence</td>
        <td>GetIterator() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_example_string_sequence.h</td>
        <td>StringSequence</td>
        <td>GetString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_example_string_sequence.h</td>
        <td>StringSequence</td>
        <td>StringSequence( const std::string &STRING = Ó)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_example_string_sequence.h</td>
        <td>StringSequence</td>
        <td>WriteIterations( const util::Implementation< Base< char, char> > &DESCRIPTOR, const std::string &STRING )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_example_string_sequence.h</td>
        <td>StringSequence</td>
        <td>WriteIterations( const util::Implementation< Base< char, float> > &DESCRIPTOR, const std::string &STRING, const size_t &PRECISION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_for_each.h</td>
        <td>ForEach</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_for_each.h</td>
        <td>ForEach</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_fourier_analysis_window_creator.h</td>
        <td>FourierAnalysisWindowCreator</td>
        <td>CreateWindowMatrix( const WindowAlignmentEnum &ALIGNMENT, const size_t &SIZE, const storage::Vector< float> &TARGET_PERIODS, const size_t &MAX_PERIODS, const util::Implementation< WindowWeightingInterface> &WEIGHTING, const float &MAX_OVERLAP = float( 1.0), const bool &CACHEABLE = true )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_fourier_analysis_window_creator.h</td>
        <td>FourierAnalysisWindowCreator</td>
        <td>GetUnweightedCosSinCoefficients( const WindowAlignmentEnum &ALIGNMENT, const size_t &SIZE, const float &PERIOD )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>Cache( const CacheMap::key_type &NAME, const CacheMap::value_type &PROPERTY) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>CacheNumeric( const storage::Map< std::string, std::string> &MAP) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>ExtractRelatedCacheEntries( const CacheMap::key_type &NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>FindInCache( const CacheMap::key_type &NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>GetCacheMap() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>GetFromCache( const CacheMap::key_type &NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>HasCache()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>IsCached( const CacheMap::key_type &NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>MergeCache( const CacheMap &MAP) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>RemoveFromCache( const CacheMap::key_type &NAME, const bool &REMOVE_DEPENDENT = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>ResetCache() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>ShareCache( const HasCache &CACHE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_has_cache.h</td>
        <td>HasCache</td>
        <td>Uncache( const util::ObjectDataLabel &NAME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterative_prediction.h</td>
        <td>IterativePrediction</td>
        <td>IterativePrediction( const bool &MEAN = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>GetPosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>GetType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>GotoPosition( const size_t &POSITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>Iterator( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>Iterator( const Type &TYPE, const SequenceInterface< t_DataType> &SEQUENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>Iterator( const Type &TYPE, const iterate::Generic< const t_DataType> &ITR_A, const iterate::Generic< const t_DataType> &ITR_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>Iterator( const Type &TYPE, const storage::Vector< iterate::Generic< const t_DataType> > &ITERATORS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>Iterator( const iterate::Generic< const t_DataType> &ITR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>Iterator( const iterate::Reflecting< const t_DataType> &ITR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>Iterator()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>NotAtEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>SetObject( const SequenceInterface< t_DataType> &SEQUENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>operator ()( const size_t &POS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>operator *() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>operator ++()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>operator --()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_iterator.h</td>
        <td>Iterator</td>
        <td>operator <( const Iterator &ITR) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_kohonen_map_info.h</td>
        <td>KohonenMapInfo</td>
        <td>GetType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_kohonen_map_info.h</td>
        <td>KohonenMapInfo</td>
        <td>KohonenMapInfo()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_limit.h</td>
        <td>Limit</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_limit.h</td>
        <td>Limit</td>
        <td>GetProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_limit.h</td>
        <td>Limit</td>
        <td>Limit()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_limit.h</td>
        <td>Limit</td>
        <td>SetProperty( const util::Implementation< Base< t_DataType, float> > &PROPERTY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_maccs.h</td>
        <td>MACCS</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar, perrye, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_maccs.h</td>
        <td>MACCS</td>
        <td>MACCS()
</td>
        <td>geanesar, perrye, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_mapped.h</td>
        <td>Mapped</td>
        <td>Mapped()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_mapped_sequence.h</td>
        <td>MappedSequence</td>
        <td>MappedSequence()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_min_max_index.h</td>
        <td>MinMaxIndex</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_min_max_index.h</td>
        <td>MinMaxIndex</td>
        <td>GetProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_min_max_index.h</td>
        <td>MinMaxIndex</td>
        <td>MinMaxIndex( const bool &COMPUTE_MAX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_min_max_index.h</td>
        <td>MinMaxIndex</td>
        <td>SetProperty( const util::Implementation< Base< t_DataType, float> > &PROPERTY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_mol_align_pharm_score.h</td>
        <td>MolAlignPharmScore</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_mol_align_pharm_score.h</td>
        <td>MolAlignPharmScore</td>
        <td>MolAlignPharmScore()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_code.h</td>
        <td>Molecule2DACode</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_code.h</td>
        <td>Molecule2DACode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_code.h</td>
        <td>Molecule2DACode</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_code.h</td>
        <td>Molecule2DACode</td>
        <td>Molecule2DACode( const size_t NUMBER_STEPS, const CheminfoProperty &ATOM_PROPERTY )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_code.h</td>
        <td>Molecule2DACode</td>
        <td>Molecule2DACode()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_max_min.h</td>
        <td>Molecule2DAMaxMin</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_max_min.h</td>
        <td>Molecule2DAMaxMin</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_max_min.h</td>
        <td>Molecule2DAMaxMin</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_max_min.h</td>
        <td>Molecule2DAMaxMin</td>
        <td>GetSubValue() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_max_min.h</td>
        <td>Molecule2DAMaxMin</td>
        <td>Molecule2DAMaxMin( const Method MAXMIN)
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_max_min.h</td>
        <td>Molecule2DAMaxMin</td>
        <td>Molecule2DAMaxMin( const size_t NUMBER_STEPS, const CheminfoProperty &ATOM_PROPERTY, const Method MAXMIN, const float SUBVALUE )
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_max_sign.h</td>
        <td>Molecule2DAMaxSign</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_max_sign.h</td>
        <td>Molecule2DAMaxSign</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_max_sign.h</td>
        <td>Molecule2DAMaxSign</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_max_sign.h</td>
        <td>Molecule2DAMaxSign</td>
        <td>Molecule2DAMaxSign( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS )
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_max_sign.h</td>
        <td>Molecule2DAMaxSign</td>
        <td>Molecule2DAMaxSign()
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_smooth_sign_code.h</td>
        <td>Molecule2DASmoothSignCode</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_smooth_sign_code.h</td>
        <td>Molecule2DASmoothSignCode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_smooth_sign_code.h</td>
        <td>Molecule2DASmoothSignCode</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_smooth_sign_code.h</td>
        <td>Molecule2DASmoothSignCode</td>
        <td>GetTemperature() const
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_2da_smooth_sign_code.h</td>
        <td>Molecule2DASmoothSignCode</td>
        <td>Molecule2DASmoothSignCode( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS, const float &TEMPERATURE, const Method SMOOTH )
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_2da_smooth_sign_code.h</td>
        <td>Molecule2DASmoothSignCode</td>
        <td>Molecule2DASmoothSignCode( const Method SMOOTH)
</td>
        <td>mendenjl, raftersa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3d_distribution.h</td>
        <td>Molecule3DDistribution</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3d_distribution.h</td>
        <td>Molecule3DDistribution</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3d_distribution.h</td>
        <td>Molecule3DDistribution</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3d_distribution.h</td>
        <td>Molecule3DDistribution</td>
        <td>GetSmoothingCoefficientVector( const size_t &NUMBER_STEPS, const float &TEMPERATURE, const float &STEP_SIZE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3d_distribution.h</td>
        <td>Molecule3DDistribution</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3d_distribution.h</td>
        <td>Molecule3DDistribution</td>
        <td>Molecule3DDistribution( const CheminfoProperty &ATOM_PROPERTY, const CheminfoProperty &CENTER_ATOM_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3d_distribution.h</td>
        <td>Molecule3DDistribution</td>
        <td>Molecule3DDistribution()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3d_sign_distribution.h</td>
        <td>Molecule3DSignDistribution</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3d_sign_distribution.h</td>
        <td>Molecule3DSignDistribution</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3d_sign_distribution.h</td>
        <td>Molecule3DSignDistribution</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3d_sign_distribution.h</td>
        <td>Molecule3DSignDistribution</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3d_sign_distribution.h</td>
        <td>Molecule3DSignDistribution</td>
        <td>Molecule3DSignDistribution( const CheminfoProperty &ATOM_PROPERTY, const CheminfoProperty &ATOM_CENTER_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3d_sign_distribution.h</td>
        <td>Molecule3DSignDistribution</td>
        <td>Molecule3DSignDistribution()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space.h</td>
        <td>Molecule3DAClosestPairRealSpace</td>
        <td>GetAtomProperty() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space.h</td>
        <td>Molecule3DAClosestPairRealSpace</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space.h</td>
        <td>Molecule3DAClosestPairRealSpace</td>
        <td>GetNumberSteps() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space.h</td>
        <td>Molecule3DAClosestPairRealSpace</td>
        <td>GetStepSize() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space.h</td>
        <td>Molecule3DAClosestPairRealSpace</td>
        <td>GetTemperature() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space.h</td>
        <td>Molecule3DAClosestPairRealSpace</td>
        <td>Molecule3DAClosestPairRealSpace( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 14, const float STEP_SIZE = 0.50, const float TEMPERATURE = 5.0, const bool SMOOTH = true, const bool INTERPOLATE = true )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space.h</td>
        <td>Molecule3DAClosestPairRealSpace</td>
        <td>Molecule3DAClosestPairRealSpace()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry</td>
        <td>GetAtomPropertyA() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry</td>
        <td>GetAtomPropertyB() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry</td>
        <td>GetTemperature() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry( const CheminfoProperty &ATOM_PROPERTY_A, const CheminfoProperty &ATOM_PROPERTY_B, const size_t NUMBER_STEPS = 14, const float STEP_SIZE = 0.50, const float TEMPERATURE = 5.0, const bool SMOOTH = true, const bool INTERPOLATE = true )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_closest_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry</td>
        <td>Molecule3DAClosestPairRealSpaceAsymmetry()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_code.h</td>
        <td>Molecule3DACode</td>
        <td>GetAtomProperty() const
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_code.h</td>
        <td>Molecule3DACode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_code.h</td>
        <td>Molecule3DACode</td>
        <td>GetNumberSteps() const
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_code.h</td>
        <td>Molecule3DACode</td>
        <td>GetStepSize() const
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_code.h</td>
        <td>Molecule3DACode</td>
        <td>Molecule3DACode( const size_t NUMBER_STEPS, const float STEP_SIZE, const CheminfoProperty &ATOM_PROPERTY )
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_code.h</td>
        <td>Molecule3DACode</td>
        <td>Molecule3DACode()
</td>
        <td>sliwosgr, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_convolution.h</td>
        <td>Molecule3DAPairConvolution</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_convolution.h</td>
        <td>Molecule3DAPairConvolution</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_convolution.h</td>
        <td>Molecule3DAPairConvolution</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_convolution.h</td>
        <td>Molecule3DAPairConvolution</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_convolution.h</td>
        <td>Molecule3DAPairConvolution</td>
        <td>Molecule3DAPairConvolution( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 20, const float STEP_SIZE = 0.50, const size_t WINDOW_SIZE = 4.0 )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_convolution.h</td>
        <td>Molecule3DAPairConvolution</td>
        <td>Molecule3DAPairConvolution()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_convolution_asymmetry.h</td>
        <td>Molecule3DAPairConvolutionAsymmetry</td>
        <td>GetAtomPropertyA() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_convolution_asymmetry.h</td>
        <td>Molecule3DAPairConvolutionAsymmetry</td>
        <td>GetAtomPropertyB() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_convolution_asymmetry.h</td>
        <td>Molecule3DAPairConvolutionAsymmetry</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_convolution_asymmetry.h</td>
        <td>Molecule3DAPairConvolutionAsymmetry</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_convolution_asymmetry.h</td>
        <td>Molecule3DAPairConvolutionAsymmetry</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_convolution_asymmetry.h</td>
        <td>Molecule3DAPairConvolutionAsymmetry</td>
        <td>Molecule3DAPairConvolutionAsymmetry( const CheminfoProperty &ATOM_PROPERTY_A, const CheminfoProperty &ATOM_PROPERTY_B, const size_t NUMBER_STEPS = 20, const float STEP_SIZE = 0.50, const size_t WINDOW_SIZE = 4.0 )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_convolution_asymmetry.h</td>
        <td>Molecule3DAPairConvolutionAsymmetry</td>
        <td>Molecule3DAPairConvolutionAsymmetry()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space.h</td>
        <td>Molecule3DAPairRealSpace</td>
        <td>GetAtomProperty() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_real_space.h</td>
        <td>Molecule3DAPairRealSpace</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space.h</td>
        <td>Molecule3DAPairRealSpace</td>
        <td>GetNumberSteps() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_real_space.h</td>
        <td>Molecule3DAPairRealSpace</td>
        <td>GetStepSize() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space.h</td>
        <td>Molecule3DAPairRealSpace</td>
        <td>GetTemperature() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_real_space.h</td>
        <td>Molecule3DAPairRealSpace</td>
        <td>Molecule3DAPairRealSpace( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 14, const float STEP_SIZE = 0.50, const float TEMPERATURE = 5.0, const bool SMOOTH = true, const bool INTERPOLATE = true )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space.h</td>
        <td>Molecule3DAPairRealSpace</td>
        <td>Molecule3DAPairRealSpace()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceAsymmetry</td>
        <td>GetAtomPropertyA() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceAsymmetry</td>
        <td>GetAtomPropertyB() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceAsymmetry</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceAsymmetry</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceAsymmetry</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceAsymmetry</td>
        <td>GetTemperature() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceAsymmetry</td>
        <td>Molecule3DAPairRealSpaceAsymmetry( const CheminfoProperty &ATOM_PROPERTY_A, const CheminfoProperty &ATOM_PROPERTY_B, const size_t NUMBER_STEPS = 14, const float STEP_SIZE = 0.50, const float TEMPERATURE = 5.0, const bool SMOOTH = true, const bool INTERPOLATE = true )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceAsymmetry</td>
        <td>Molecule3DAPairRealSpaceAsymmetry()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_real_space_convolution.h</td>
        <td>Molecule3DAPairRealSpaceConvolution</td>
        <td>Molecule3DAPairRealSpaceConvolution( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 20, const float STEP_SIZE = 0.50, const size_t WINDOW_SIZE = 4, const float CUTOFF = 7.0 )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space_convolution.h</td>
        <td>Molecule3DAPairRealSpaceConvolution</td>
        <td>Molecule3DAPairRealSpaceConvolution()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_pair_real_space_convolution_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceConvolutionAsymmetry</td>
        <td>Molecule3DAPairRealSpaceConvolutionAsymmetry( const CheminfoProperty &ATOM_PROPERTY_A, const CheminfoProperty &ATOM_PROPERTY_B, const size_t NUMBER_STEPS = 20, const float STEP_SIZE = 0.50, const size_t WINDOW_SIZE = 4, const float CUTOFF = 7.0 )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_pair_real_space_convolution_asymmetry.h</td>
        <td>Molecule3DAPairRealSpaceConvolutionAsymmetry</td>
        <td>Molecule3DAPairRealSpaceConvolutionAsymmetry()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth.h</td>
        <td>Molecule3DASmooth</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth.h</td>
        <td>Molecule3DASmooth</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth.h</td>
        <td>Molecule3DASmooth</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth.h</td>
        <td>Molecule3DASmooth</td>
        <td>GetSmoothingCoefficientVector( const size_t &NUMBER_STEPS, const float &TEMPERATURE, const float &STEP_SIZE )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth.h</td>
        <td>Molecule3DASmooth</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth.h</td>
        <td>Molecule3DASmooth</td>
        <td>GetTemperature() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth.h</td>
        <td>Molecule3DASmooth</td>
        <td>Molecule3DASmooth( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1, const float &TEMPERATURE = 100.0 )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth.h</td>
        <td>Molecule3DASmooth</td>
        <td>Molecule3DASmooth()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth_sign_code.h</td>
        <td>Molecule3DASmoothSignCode</td>
        <td>GetAtomProperty() const
</td>
        <td>kothiwsk, mendenjl, herrinca</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth_sign_code.h</td>
        <td>Molecule3DASmoothSignCode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>kothiwsk, mendenjl, herrinca</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth_sign_code.h</td>
        <td>Molecule3DASmoothSignCode</td>
        <td>GetNumberSteps() const
</td>
        <td>kothiwsk, mendenjl, herrinca</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth_sign_code.h</td>
        <td>Molecule3DASmoothSignCode</td>
        <td>GetStepSize() const
</td>
        <td>kothiwsk, mendenjl, herrinca</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth_sign_code.h</td>
        <td>Molecule3DASmoothSignCode</td>
        <td>GetTemperature() const
</td>
        <td>kothiwsk, mendenjl, herrinca</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth_sign_code.h</td>
        <td>Molecule3DASmoothSignCode</td>
        <td>Molecule3DASmoothSignCode( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1, const float &TEMPERATURE = 100.0, const bool &SMOOTH = true, const bool &SQRT = false )
</td>
        <td>kothiwsk, mendenjl, herrinca</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth_sign_code.h</td>
        <td>Molecule3DASmoothSignCode</td>
        <td>Molecule3DASmoothSignCode()
</td>
        <td>kothiwsk, mendenjl, herrinca</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth_sign_occlusion_code.h</td>
        <td>Molecule3DASmoothSignOcclusionCode</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth_sign_occlusion_code.h</td>
        <td>Molecule3DASmoothSignOcclusionCode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth_sign_occlusion_code.h</td>
        <td>Molecule3DASmoothSignOcclusionCode</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth_sign_occlusion_code.h</td>
        <td>Molecule3DASmoothSignOcclusionCode</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_smooth_sign_occlusion_code.h</td>
        <td>Molecule3DASmoothSignOcclusionCode</td>
        <td>Molecule3DASmoothSignOcclusionCode( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS, const float STEP_SIZE, const bool &SQRT = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_smooth_sign_occlusion_code.h</td>
        <td>Molecule3DASmoothSignOcclusionCode</td>
        <td>Molecule3DASmoothSignOcclusionCode()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_max.h</td>
        <td>Molecule3DASoftMax</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_max.h</td>
        <td>Molecule3DASoftMax</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_max.h</td>
        <td>Molecule3DASoftMax</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_max.h</td>
        <td>Molecule3DASoftMax</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_max.h</td>
        <td>Molecule3DASoftMax</td>
        <td>GetTemperature() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_max.h</td>
        <td>Molecule3DASoftMax</td>
        <td>Molecule3DASoftMax( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1, const float &TEMPERATURE = 100.0 )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_max.h</td>
        <td>Molecule3DASoftMax</td>
        <td>Molecule3DASoftMax()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_max_sign.h</td>
        <td>Molecule3DASoftMaxSign</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_max_sign.h</td>
        <td>Molecule3DASoftMaxSign</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_max_sign.h</td>
        <td>Molecule3DASoftMaxSign</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_max_sign.h</td>
        <td>Molecule3DASoftMaxSign</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_max_sign.h</td>
        <td>Molecule3DASoftMaxSign</td>
        <td>GetTemperature() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_max_sign.h</td>
        <td>Molecule3DASoftMaxSign</td>
        <td>Molecule3DASoftMaxSign( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1, const float &TEMPERATURE = 100.0 )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_max_sign.h</td>
        <td>Molecule3DASoftMaxSign</td>
        <td>Molecule3DASoftMaxSign()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_min.h</td>
        <td>Molecule3DASoftMin</td>
        <td>GetAtomProperty() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_min.h</td>
        <td>Molecule3DASoftMin</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_min.h</td>
        <td>Molecule3DASoftMin</td>
        <td>GetNumberSteps() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_min.h</td>
        <td>Molecule3DASoftMin</td>
        <td>GetStepSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_min.h</td>
        <td>Molecule3DASoftMin</td>
        <td>GetTemperature() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_3da_soft_min.h</td>
        <td>Molecule3DASoftMin</td>
        <td>Molecule3DASoftMin( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1, const float &TEMPERATURE = 100.0 )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_3da_soft_min.h</td>
        <td>Molecule3DASoftMin</td>
        <td>Molecule3DASoftMin()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_asymmetry.h</td>
        <td>MoleculeAsymmetry</td>
        <td>GetChemInfoProperty() const
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_asymmetry.h</td>
        <td>MoleculeAsymmetry</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_asymmetry.h</td>
        <td>MoleculeAsymmetry</td>
        <td>GetNumberSteps() const
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_asymmetry.h</td>
        <td>MoleculeAsymmetry</td>
        <td>GetStepSize() const
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_asymmetry.h</td>
        <td>MoleculeAsymmetry</td>
        <td>GetTemperature() const
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_asymmetry.h</td>
        <td>MoleculeAsymmetry</td>
        <td>MoleculeAsymmetry( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS, const float STEP_SIZE, const float &TEMPERATURE, const bool &SUM_PROPS )
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_asymmetry.h</td>
        <td>MoleculeAsymmetry</td>
        <td>MoleculeAsymmetry()
</td>
        <td>sliwosgr, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_atom_environment_map.h</td>
        <td>MoleculeAtomEnvironmentMap</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_atom_environment_map.h</td>
        <td>MoleculeAtomEnvironmentMap</td>
        <td>MoleculeAtomEnvironmentMap( std::string &ENVIRONMENT_FILE, bool &REMOVE_H, size_t &ENVIRONMENT_SIZE )
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_atom_environment_map.h</td>
        <td>MoleculeAtomEnvironmentMap</td>
        <td>MoleculeAtomEnvironmentMap()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_cached_string.h</td>
        <td>MoleculeCachedString</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_cached_string.h</td>
        <td>MoleculeCachedString</td>
        <td>MoleculeCachedString()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_complexity.h</td>
        <td>MoleculeComplexity</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_default.h</td>
        <td>MoleculeDefault</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_default.h</td>
        <td>MoleculeDefault</td>
        <td>MoleculeDefault( const std::string &ALIAS)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_default.h</td>
        <td>MoleculeDefault</td>
        <td>MoleculeDefault()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_druglike.h</td>
        <td>MoleculeDruglike</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_druglike.h</td>
        <td>MoleculeDruglike</td>
        <td>MoleculeDruglike( const bool &ENFORCE_HITLIKE = false )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_druglike.h</td>
        <td>MoleculeDruglike</td>
        <td>MoleculeDruglike( const float &MIN_WEIGHT, const float &MAX_WEIGHT, const size_t &MAX_RING_SIZE, const float &MIN_LOGP, const float &MAX_LOGP, const float &MAX_TPSA, const size_t &MAX_HBDA, const size_t &MAX_N_ROT_BONDS, const float &MAX_BOND_PROPENSITY, const size_t &MAX_N_F, const size_t &MAX_N_CL, const size_t &MAX_N_BR, const size_t &MAX_N_I, const size_t &MAX_TOTAL_HALOGENS, const size_t &MAX_RING_HALOGENS, const size_t &MAX_NON_AROMATIC_CLBRI, const float &MAX_COMPLEXITY, const bool &ENFORCE_HITLIKE, const bool &ENFORCE_DRUGLIKE_RINGS, const bool &ENFORCE_DRUGLIKE_ECFP )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_druglike.h</td>
        <td>MoleculeDruglike</td>
        <td>MoleculeDruglike()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_entropy_qha.h</td>
        <td>MoleculeEntropyQHA</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_entropy_qha.h</td>
        <td>MoleculeEntropyQHA</td>
        <td>MoleculeEntropyQHA( const chemistry::SampleConformations &SAMPLER )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_entropy_qha.h</td>
        <td>MoleculeEntropyQHA</td>
        <td>MoleculeEntropyQHA()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_fragment_rescale.h</td>
        <td>MoleculeFragmentRescale</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_fragment_rescale.h</td>
        <td>MoleculeFragmentRescale</td>
        <td>GetStatisticName( const Statistic &STAT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_fragment_rescale.h</td>
        <td>MoleculeFragmentRescale</td>
        <td>MoleculeFragmentRescale( const CheminfoProperty &DESCRIPTOR, const storage::Vector< StatisticEnum> &STATS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_fragment_rescale.h</td>
        <td>MoleculeFragmentRescale</td>
        <td>MoleculeFragmentRescale()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_fragment_statistics.h</td>
        <td>MoleculeFragmentStatistics</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_fragment_statistics.h</td>
        <td>MoleculeFragmentStatistics</td>
        <td>GetStatisticName( const Statistic &STAT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_fragment_statistics.h</td>
        <td>MoleculeFragmentStatistics</td>
        <td>MoleculeFragmentStatistics( const CheminfoProperty &DESCRIPTOR, const storage::Vector< StatisticEnum> &STATS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_fragment_statistics.h</td>
        <td>MoleculeFragmentStatistics</td>
        <td>MoleculeFragmentStatistics()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_girth.h</td>
        <td>MoleculeGirth</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>kothiwsk, mendenjl, herrinca</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_inter_hbond_code.h</td>
        <td>MoleculeInterHBondCode</td>
        <td>GetAngleSize() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_inter_hbond_code.h</td>
        <td>MoleculeInterHBondCode</td>
        <td>GetAtomProperty() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_inter_hbond_code.h</td>
        <td>MoleculeInterHBondCode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_inter_hbond_code.h</td>
        <td>MoleculeInterHBondCode</td>
        <td>GetNumberSteps() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_inter_hbond_code.h</td>
        <td>MoleculeInterHBondCode</td>
        <td>GetStepSize() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_inter_hbond_code.h</td>
        <td>MoleculeInterHBondCode</td>
        <td>GetTemperature() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_inter_hbond_code.h</td>
        <td>MoleculeInterHBondCode</td>
        <td>MoleculeInterHBondCode( const CheminfoProperty &ATOM_HBD, const CheminfoProperty &ATOM_HBA, const size_t NUMBER_STEPS = 8, const float STEP_SIZE = 0.50 )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_inter_hbond_code.h</td>
        <td>MoleculeInterHBondCode</td>
        <td>MoleculeInterHBondCode()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_lipinski_violations.h</td>
        <td>MoleculeLipinskiViolations</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_lipinski_violations.h</td>
        <td>MoleculeLipinskiViolations</td>
        <td>MoleculeLipinskiViolations( const LipinskiVariant &VARIANT = e_Original)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_log_p.h</td>
        <td>MoleculeLogP</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_log_p2008.h</td>
        <td>MoleculeLogP2008</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_maximum_fragment_statistics.h</td>
        <td>MoleculeMaximumFragmentStatistics</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_maximum_fragment_statistics.h</td>
        <td>MoleculeMaximumFragmentStatistics</td>
        <td>MoleculeMaximumFragmentStatistics( const CheminfoProperty &DESCRIPTOR )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_maximum_fragment_statistics.h</td>
        <td>MoleculeMaximumFragmentStatistics</td>
        <td>MoleculeMaximumFragmentStatistics()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_misc_property.h</td>
        <td>MoleculeMiscProperty</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_misc_property.h</td>
        <td>MoleculeMiscProperty</td>
        <td>MoleculeMiscProperty( const std::string &NAME, const size_t &PROPERTIES_PER_MOLECULE)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_misc_property.h</td>
        <td>MoleculeMiscProperty</td>
        <td>MoleculeMiscProperty()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_name.h</td>
        <td>MoleculeName</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_name.h</td>
        <td>MoleculeName</td>
        <td>MoleculeName()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_one_four_clash_score.h</td>
        <td>MoleculeOneFourClashScore</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_code.h</td>
        <td>MoleculeRDFCode</td>
        <td>GetAtomProperty() const
</td>
        <td>sliwosgr, mueller, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_code.h</td>
        <td>MoleculeRDFCode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>sliwosgr, mueller, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_code.h</td>
        <td>MoleculeRDFCode</td>
        <td>GetNumberSteps() const
</td>
        <td>sliwosgr, mueller, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_code.h</td>
        <td>MoleculeRDFCode</td>
        <td>GetStepSize() const
</td>
        <td>sliwosgr, mueller, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_code.h</td>
        <td>MoleculeRDFCode</td>
        <td>GetTemperature() const
</td>
        <td>sliwosgr, mueller, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_code.h</td>
        <td>MoleculeRDFCode</td>
        <td>MoleculeRDFCode( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1, const float &TEMPERATURE = 100.0 )
</td>
        <td>sliwosgr, mueller, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_code.h</td>
        <td>MoleculeRDFCode</td>
        <td>MoleculeRDFCode()
</td>
        <td>sliwosgr, mueller, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_grid_code.h</td>
        <td>MoleculeRDFGridCode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_grid_code.h</td>
        <td>MoleculeRDFGridCode</td>
        <td>MoleculeRDFGridCode( const CheminfoProperty &ATOM_PROPERTY, const CheminfoProperty &WEIGHT_PROPERTY, const size_t &DISTANCE_NUMBER_STEPS = 24, const size_t &PROPERTY_NUMBER_STEPS = 12, const float &DISTANCE_STEP_SIZE = 0.5, const float &PROPERTY_STEP_SIZE = 0.5, const float &DISTANCE_TEMPERATURE = 100.0, const float &PROPERTY_TEMPERATURE = 4.0 )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_grid_code.h</td>
        <td>MoleculeRDFGridCode</td>
        <td>MoleculeRDFGridCode()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_max_sign_code.h</td>
        <td>MoleculeRDFMaxSignCode</td>
        <td>GetAtomProperty() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_max_sign_code.h</td>
        <td>MoleculeRDFMaxSignCode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_max_sign_code.h</td>
        <td>MoleculeRDFMaxSignCode</td>
        <td>GetNumberSteps() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_max_sign_code.h</td>
        <td>MoleculeRDFMaxSignCode</td>
        <td>GetStepSize() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_max_sign_code.h</td>
        <td>MoleculeRDFMaxSignCode</td>
        <td>GetTemperature() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_max_sign_code.h</td>
        <td>MoleculeRDFMaxSignCode</td>
        <td>MoleculeRDFMaxSignCode( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1, const float &TEMPERATURE = 100.0 )
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_max_sign_code.h</td>
        <td>MoleculeRDFMaxSignCode</td>
        <td>MoleculeRDFMaxSignCode()
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_sign_code.h</td>
        <td>MoleculeRDFSignCode</td>
        <td>GetAtomProperty() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_sign_code.h</td>
        <td>MoleculeRDFSignCode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_sign_code.h</td>
        <td>MoleculeRDFSignCode</td>
        <td>GetNumberSteps() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_sign_code.h</td>
        <td>MoleculeRDFSignCode</td>
        <td>GetStepSize() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_sign_code.h</td>
        <td>MoleculeRDFSignCode</td>
        <td>GetTemperature() const
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rdf_sign_code.h</td>
        <td>MoleculeRDFSignCode</td>
        <td>MoleculeRDFSignCode( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS = 128, const float STEP_SIZE = 0.1, const float &TEMPERATURE = 100.0 )
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rdf_sign_code.h</td>
        <td>MoleculeRDFSignCode</td>
        <td>MoleculeRDFSignCode()
</td>
        <td>glickzl, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rings.h</td>
        <td>MoleculeRings</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rings.h</td>
        <td>MoleculeRings</td>
        <td>MoleculeRings( const chemistry::ConstitutionalBondTypeData::Conjugation &CONJUGATION = chemistry::ConstitutionalBondTypeData::e_Any, const bool &MACROCYCLES_ONLY = false )
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_rotatable_bonds.h</td>
        <td>MoleculeRotatableBonds</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_rotatable_bonds.h</td>
        <td>MoleculeRotatableBonds</td>
        <td>MoleculeRotatableBonds( const bool &SYMMETRY_AWARE = false)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_shape_moments.h</td>
        <td>MoleculeShapeMoments</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_shape_moments.h</td>
        <td>MoleculeShapeMoments</td>
        <td>MoleculeShapeMoments( const CheminfoProperty &ATOM_PROPERTY_CENTERING, const CheminfoProperty &ATOM_PROPERTY_WEIGHTING )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_shape_moments.h</td>
        <td>MoleculeShapeMoments</td>
        <td>MoleculeShapeMoments()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_similarity.h</td>
        <td>MoleculeSimilarity</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_similarity.h</td>
        <td>MoleculeSimilarity</td>
        <td>MoleculeSimilarity( const std::string &COMPARISON_TYPE, const chemistry::FragmentEnsemble &MOLECULES )
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_similarity.h</td>
        <td>MoleculeSimilarity</td>
        <td>MoleculeSimilarity()
</td>
        <td>geanesar, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_storage_id.h</td>
        <td>MoleculeStorageId</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_storage_id.h</td>
        <td>MoleculeStorageId</td>
        <td>MoleculeStorageId( io::StoreInterface< chemistry::ConformationInterface> *const STORAGE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_storage_id.h</td>
        <td>MoleculeStorageId</td>
        <td>MoleculeStorageId()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_total_bond_energy.h</td>
        <td>MoleculeTotalBondEnergy</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_total_bond_energy.h</td>
        <td>MoleculeTotalBondEnergy</td>
        <td>MoleculeTotalBondEnergy( const bool &DRUGLIKE = true)
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_triangulator_code.h</td>
        <td>MoleculeTriangulatorCode</td>
        <td>GetAtomProperty() const
</td>
        <td>mueller, houselm, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_triangulator_code.h</td>
        <td>MoleculeTriangulatorCode</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mueller, houselm, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_triangulator_code.h</td>
        <td>MoleculeTriangulatorCode</td>
        <td>GetNumberSteps() const
</td>
        <td>mueller, houselm, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_triangulator_code.h</td>
        <td>MoleculeTriangulatorCode</td>
        <td>GetStepSize() const
</td>
        <td>mueller, houselm, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_triangulator_code.h</td>
        <td>MoleculeTriangulatorCode</td>
        <td>GetTemperature() const
</td>
        <td>mueller, houselm, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_triangulator_code.h</td>
        <td>MoleculeTriangulatorCode</td>
        <td>MoleculeTriangulatorCode( const CheminfoProperty &ATOM_PROPERTY, const size_t NUMBER_STEPS, const float STEP_SIZE, const float &TEMPERATURE, const float &CUTOFF )
</td>
        <td>mueller, houselm, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_triangulator_code.h</td>
        <td>MoleculeTriangulatorCode</td>
        <td>MoleculeTriangulatorCode()
</td>
        <td>mueller, houselm, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_molecule_vdw_score.h</td>
        <td>MoleculeVdwScore</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_molecule_xlog_p.h</td>
        <td>MoleculeXLogP</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_mutation_aa_density.h</td>
        <td>MutationAADensity</td>
        <td>MutationAADensity()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_mutation_aa_property.h</td>
        <td>MutationAAProperty</td>
        <td>MutationAAProperty( const bool &NATIVE, const util::Implementation< Base< biol::AABase, float> > &PROPERTY = util::Implementation< Base< biol::AABase, float> >() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_mutation_density.h</td>
        <td>MutationDensity</td>
        <td>MutationDensity()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_mutation_id.h</td>
        <td>MutationId</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_mutation_nearest_in_sequence.h</td>
        <td>MutationNearestInSequence</td>
        <td>MutationNearestInSequence()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_mutation_nearest_spatially.h</td>
        <td>MutationNearestSpatially</td>
        <td>MutationNearestSpatially()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_named.h</td>
        <td>Named</td>
        <td>ConsiderRepeatedElements() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_named.h</td>
        <td>Named</td>
        <td>GetInternalDescriptor() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_named.h</td>
        <td>Named</td>
        <td>GetInternalDescriptors()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_named.h</td>
        <td>Named</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_named.h</td>
        <td>Named</td>
        <td>GetSymmetry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_named.h</td>
        <td>Named</td>
        <td>Named( const Base< t_DataType, t_ReturnType> &DESCRIPTOR, const std::string &ALIAS, const std::string &DESCRIPTION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_named.h</td>
        <td>Named</td>
        <td>Named()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_named_template.h</td>
        <td>NamedTemplate</td>
        <td>ConsiderRepeatedElements() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_named_template.h</td>
        <td>NamedTemplate</td>
        <td>GetInternalDescriptors()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_named_template.h</td>
        <td>NamedTemplate</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_named_template.h</td>
        <td>NamedTemplate</td>
        <td>GetSymmetry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_named_template.h</td>
        <td>NamedTemplate</td>
        <td>NamedTemplate( const util::ObjectDataLabel &DEFINITION, const std::string &ALIAS, const storage::Vector< std::string> &ARGUMENTS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_named_template.h</td>
        <td>NamedTemplate</td>
        <td>NamedTemplate()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_numeric.h</td>
        <td>Numeric</td>
        <td>Numeric()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_offset.h</td>
        <td>Offset</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_offset.h</td>
        <td>Offset</td>
        <td>Offset( const bool &REFLECTING = false, const int &OFFSET = 0)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_outer_product.h</td>
        <td>OuterProduct</td>
        <td>OuterProduct( const util::Implementation< Base< t_DataType, float> > &LHS, const util::Implementation< Base< t_DataType, float> > &RHS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_outer_product.h</td>
        <td>OuterProduct</td>
        <td>OuterProduct()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_pair_convolution_correlation_dnn.h</td>
        <td>PairConvolutionCorrelationDNN</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_pair_convolution_correlation_dnn.h</td>
        <td>PairConvolutionCorrelationDNN</td>
        <td>PairConvolutionCorrelationDNN( const bool &APPLICABILITY_WEIGHT = false )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_pair_convolution_correlation_dnn.h</td>
        <td>PairConvolutionCorrelationDNN</td>
        <td>PairConvolutionCorrelationDNN( const std::string &MDL_PROPERTY = std::string(), const std::string &POCKET_FILENAME = std::string(), const bool &APPLICABILITY_WEIGHT = false )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_pair_convolution_correlation_dnn.h</td>
        <td>PairConvolutionCorrelationDNN</td>
        <td>PairConvolutionCorrelationDNN()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_partial.h</td>
        <td>Partial</td>
        <td>ConsiderRepeatedElements() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_partial.h</td>
        <td>Partial</td>
        <td>GetSymmetry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_partial.h</td>
        <td>Partial</td>
        <td>Partial()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_periodogram.h</td>
        <td>Periodogram</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_periodogram.h</td>
        <td>Periodogram</td>
        <td>Periodogram( const bool &REFLECTING)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_positional.h</td>
        <td>Positional</td>
        <td>ConsiderRepeatedElements() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_positional.h</td>
        <td>Positional</td>
        <td>GetSymmetry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_positional.h</td>
        <td>Positional</td>
        <td>Positional( const size_t &POSITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_power_spectrum.h</td>
        <td>PowerSpectrum</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_power_spectrum.h</td>
        <td>PowerSpectrum</td>
        <td>PowerSpectrum( const bool &REFLECT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_power_spectrum_sequence_width.h</td>
        <td>PowerSpectrumSequenceWidth</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_power_spectrum_sequence_width.h</td>
        <td>PowerSpectrumSequenceWidth</td>
        <td>PowerSpectrumSequenceWidth()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_prediction.h</td>
        <td>Prediction</td>
        <td>GetType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_prediction.h</td>
        <td>Prediction</td>
        <td>Prediction( const bool &MEAN = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_prediction_info.h</td>
        <td>PredictionInfo</td>
        <td>GetStatisticName( const Statistic &STAT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_prediction_info.h</td>
        <td>PredictionInfo</td>
        <td>GetType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_protein_id.h</td>
        <td>ProteinId</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_protein_id.h</td>
        <td>ProteinId</td>
        <td>ProteinId( const size_t &N_CHAR = 5)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_protein_ligand_correlation_dnn.h</td>
        <td>ProteinLigandCorrelationDNN</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_protein_ligand_correlation_dnn.h</td>
        <td>ProteinLigandCorrelationDNN</td>
        <td>ProteinLigandCorrelationDNN( const bool &APPLICABILITY_WEIGHT = false, const bool &DOCK_ANN_SCORE = false )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_protein_ligand_correlation_dnn.h</td>
        <td>ProteinLigandCorrelationDNN</td>
        <td>ProteinLigandCorrelationDNN( const std::string &MDL_PROPERTY = std::string(), const std::string &POCKET_FILENAME = std::string(), const bool &APPLICABILITY_WEIGHT = false, const bool &DOCK_ANN_SCORE = false )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_protein_ligand_correlation_dnn.h</td>
        <td>ProteinLigandCorrelationDNN</td>
        <td>ProteinLigandCorrelationDNN( const std::string &MDL_PROPERTY = std::string(), const std::string &POCKET_FILENAME = std::string(), const bool &APPLICABILITY_WEIGHT = false, const bool &REPORT_DG_BIND = false, const bool &DOCK_ANN_SCORE = false, const float &TEMPERATURE = float( 298.75) )
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_protein_ligand_correlation_dnn.h</td>
        <td>ProteinLigandCorrelationDNN</td>
        <td>ProteinLigandCorrelationDNN()
</td>
        <td>brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_rank.h</td>
        <td>Rank</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_rank.h</td>
        <td>Rank</td>
        <td>GetProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_rank.h</td>
        <td>Rank</td>
        <td>Rank( const bool &ASCENDING)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_rank.h</td>
        <td>Rank</td>
        <td>SetProperty( const util::Implementation< Base< t_DataType, float> > &PROPERTY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_reaction_structure_search.h</td>
        <td>ReactionStructureSearch</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_reaction_structure_search.h</td>
        <td>ReactionStructureSearch</td>
        <td>ReactionStructureSearch()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_replace_undefined_values.h</td>
        <td>ReplaceUndefinedValues</td>
        <td>ConsiderRepeatedElements() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_replace_undefined_values.h</td>
        <td>ReplaceUndefinedValues</td>
        <td>GetInternalDescriptors()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_replace_undefined_values.h</td>
        <td>ReplaceUndefinedValues</td>
        <td>GetSymmetry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_replace_undefined_values.h</td>
        <td>ReplaceUndefinedValues</td>
        <td>ReplaceUndefinedValues( const bool &REPLACE_MEAN_WITH_NON_NAN_VALUE = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_replace_undefined_values.h</td>
        <td>ReplaceUndefinedValues</td>
        <td>ReplaceUndefinedValues( const util::Implementation< Base< t_DataType, float> > &SOURCE, const util::Implementation< Base< t_DataType, float> > &REPLACEMENT )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_rescale.h</td>
        <td>Rescale</td>
        <td>ConsiderRepeatedElements() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_rescale.h</td>
        <td>Rescale</td>
        <td>GetInternalDescriptors()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_rescale.h</td>
        <td>Rescale</td>
        <td>GetSymmetry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_rescale.h</td>
        <td>Rescale</td>
        <td>Rescale( const util::Implementation< Base< t_DataType, float> > &SOURCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_rescale.h</td>
        <td>Rescale</td>
        <td>Rescale()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sdf_file_id.h</td>
        <td>SdfFileId</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sdf_file_id.h</td>
        <td>SdfFileId</td>
        <td>SdfFileId( chemistry::MoleculeStorageFile::FindTypeEnum TYPE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>ConsiderNextElementOfSequence( const linal::VectorConstInterface< float> &CONDITION, const linal::VectorConstInterface< float> &DESCRIPTOR )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>CopyStatisticConsideringAllSegments( linal::VectorInterface< float> &REFERENCE, const Statistic &STATISTIC ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>CopyStatisticConsideringSegmentsWithCondition( linal::VectorInterface< float> &REFERENCE, const Statistic &STATISTIC, const linal::VectorConstInterface< float> &CONDITION ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>Finalize()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>GetIsStatisticOfCondition( const Statistic &STATISTIC)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>GetIsStatisticOfDescriptor( const Statistic &STATISTIC)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>GetNumberSegments() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>GetStatisticConsideringAllSegments( const Statistic &STATISTIC) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>GetStatisticConsideringSegmentsWithCondition( const Statistic &STATISTIC, const linal::VectorConstInterface< float> &CONDITION ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>GetStatisticSize( const Statistic &STATISTIC) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>GetStatisticString( const Statistic &STATISTIC)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>IsEmpty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>IsFinalized() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>SegmentBegin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>SegmentEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>SegmentFinder( const SegmentFinder &PARENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>SegmentFinder()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>SegmentForPosition( const size_t &POSITION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>SegmentFinder</td>
        <td>operator =( const SegmentFinder &RHS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>VectorLessThanRespectUndefined</td>
        <td>Equal( const linal::Vector< float> &A, const linal::Vector< float> &B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_finder.h</td>
        <td>VectorLessThanRespectUndefined</td>
        <td>operator ()( const linal::Vector< float> &A, const linal::Vector< float> &B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>CopyStatistic( linal::VectorInterface< float> &REFERENCE, const Statistic &STATISTIC, const size_t &POSITION = size_t( 0) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetCondition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetConditionalSegmentId() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetDescriptorAverageSD() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetDescriptorLimits() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetEndPosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetLength() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetSegmentId() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetStartPosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetStatistic( const Statistic &STATISTIC, const size_t &POSITION = size_t( 0) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetStatisticSize( const Statistic &STATISTIC) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>GetStatisticString( const Statistic &STATISTIC)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>PushBack( const linal::VectorConstInterface< float> &DESCRIPTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>SegmentInfo( const size_t &START_POS, const util::SiPtr< const size_t> &SEGMENT_COUNT_REF, const util::SiPtr< const size_t> &SEGMENT_CONDITION_COUNT_REF, const util::SiPtr< const linal::Vector< float> > &CONDITION_REF )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_segment_info.h</td>
        <td>SegmentInfo</td>
        <td>SegmentInfo()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sequence_histogram_1d.h</td>
        <td>SequenceHistogram1D</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sequence_histogram_1d.h</td>
        <td>SequenceHistogram1D</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sequence_histogram_1d.h</td>
        <td>SequenceHistogram1D</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sequence_histogram_1d.h</td>
        <td>SequenceHistogram1D</td>
        <td>SequenceHistogram1D()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sequence_interface.h</td>
        <td>SequenceInterface</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sequence_segment_statistics.h</td>
        <td>SequenceSegmentStatistics</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sequence_segment_statistics.h</td>
        <td>SequenceSegmentStatistics</td>
        <td>SequenceSegmentStatistics()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sequence_size.h</td>
        <td>SequenceSize</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sequence_sse_count.h</td>
        <td>SequenceSSECount</td>
        <td>SequenceSSECount( const bool &ONLY_MEMBRANE_COUNTS, const bool &ONLY_SOLUTION_COUNTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sequence_statistics.h</td>
        <td>SequenceStatistics</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sequence_statistics.h</td>
        <td>SequenceStatistics</td>
        <td>SequenceStatistics( const util::Implementation< Base< t_DataType, float> > &DESCRIPTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sequence_statistics.h</td>
        <td>SequenceStatistics</td>
        <td>SequenceStatistics()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sequence_weighted_statistics.h</td>
        <td>SequenceWeightedStatistics</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sequence_weighted_statistics.h</td>
        <td>SequenceWeightedStatistics</td>
        <td>SequenceWeightedStatistics( const util::Implementation< Base< t_DataType, float> > &DESCRIPTOR, const util::Implementation< Base< t_DataType, float> > &WEIGHT )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sequence_weighted_statistics.h</td>
        <td>SequenceWeightedStatistics</td>
        <td>SequenceWeightedStatistics()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sigmoid.h</td>
        <td>Sigmoid</td>
        <td>GetDescriptor() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sigmoid.h</td>
        <td>Sigmoid</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sigmoid.h</td>
        <td>Sigmoid</td>
        <td>SetDescriptor( const util::Implementation< Base< t_DataType, float> > &DESCRIPTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sigmoid.h</td>
        <td>Sigmoid</td>
        <td>Sigmoid( const float &AMPLITUDE, const float &X_OFFSET, const float &Y_OFFSET, const float &SLOPE_X, const float &SLOPE_Y )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sigmoid.h</td>
        <td>Sigmoid</td>
        <td>Sigmoid()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sort.h</td>
        <td>Sort</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>butkiem1, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sort.h</td>
        <td>Sort</td>
        <td>GetProperty() const
</td>
        <td>butkiem1, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_sort.h</td>
        <td>Sort</td>
        <td>SetProperty( const util::Implementation< Base< t_DataType, float> > &PROPERTY)
</td>
        <td>butkiem1, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_sort.h</td>
        <td>Sort</td>
        <td>Sort( const bool &ASCENDING)
</td>
        <td>butkiem1, mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_statistics.h</td>
        <td>Statistics</td>
        <td>DimensionIsWellDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_statistics.h</td>
        <td>Statistics</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_statistics.h</td>
        <td>Statistics</td>
        <td>InjectDimensions() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_structure_count.h</td>
        <td>StructureCount</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_structure_count.h</td>
        <td>StructureCount</td>
        <td>StructureCount()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_structure_search.h</td>
        <td>StructureSearch</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_structure_search.h</td>
        <td>StructureSearch</td>
        <td>StructureSearch()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_template.h</td>
        <td>Template</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_template.h</td>
        <td>Template</td>
        <td>Template( const util::ObjectDataLabel &NAME_LABEL, const util::ObjectDataLabel &LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_template.h</td>
        <td>Template</td>
        <td>Template()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>ConsiderRepeatedObjects() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>GeneralizeToHandle( const Type &OTHER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>GetDimension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>GetNumberFeatures( const size_t &SIZE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>GetPosition( const storage::Vector< size_t> &POSITIONS, const size_t &SIZE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>GetSymmetry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>Type( const size_t DIMENSION, const bool &REPEATS, const Symmetry &SYMMETRY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>Type()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>operator !=( const Type &OTHER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_type.h</td>
        <td>Type</td>
        <td>operator ==( const Type &OTHER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_umol2d.h</td>
        <td>UMol2D</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>vuot</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_umol2d.h</td>
        <td>UMol2D</td>
        <td>UMol2D()
</td>
        <td>vuot</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_unary_operation.h</td>
        <td>UnaryOperation</td>
        <td>GetAssignmentOperation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_unary_operation.h</td>
        <td>UnaryOperation</td>
        <td>UnaryOperation( const util::Implementation< math::AssignmentUnaryInterface> &OPERATION, const util::Implementation< Base< t_DataType, float> > &DESCRIPTOR = ( util::Implementation< Base< t_DataType, float> >()) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_uniform_random.h</td>
        <td>UniformRandom</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_uniform_random.h</td>
        <td>UniformRandom</td>
        <td>UniformRandom( const bool &SAME = false, const size_t &SIZE = 1)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>GetRelativeIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>IsReflective() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>SetAlignment( const WindowAlignmentType &ALIGNMENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>SetRadius( const size_t &RADIUS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>Window( const BaseElement< t_DataType, t_ReturnType> &DESCRIPTOR, const size_t &SIZE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>Window( const bool &REFLECTIVE, const util::Implementation< Base< t_DataType, t_ReturnType> > &DESCRIPTOR = ( util::Implementation< Base< t_DataType, t_ReturnType> >()) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window.h</td>
        <td>Window</td>
        <td>Window( const util::Implementation< Base< t_DataType, t_ReturnType> > &DESCRIPTOR, const size_t &SIZE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window_alignment_type.h</td>
        <td></td>
        <td>GetWindowAlignmentString( const WindowAlignmentType &ALIGNMENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window_average.h</td>
        <td>WindowAverage</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window_average.h</td>
        <td>WindowAverage</td>
        <td>WindowAverage( const bool &REFLECTIVE, const bool &CUMULATIVE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window_conditional_average.h</td>
        <td>WindowConditionalAverage</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window_conditional_average.h</td>
        <td>WindowConditionalAverage</td>
        <td>WindowConditionalAverage( const bool &AVERAGE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window_min_max.h</td>
        <td>WindowMinMax</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window_min_max.h</td>
        <td>WindowMinMax</td>
        <td>WindowMinMax( const bool &REFLECTIVE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window_pair_square.h</td>
        <td>WindowPairSquare</td>
        <td>ConsiderRepeatedElements() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window_pair_square.h</td>
        <td>WindowPairSquare</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window_pair_square.h</td>
        <td>WindowPairSquare</td>
        <td>GetSymmetry() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window_pair_square.h</td>
        <td>WindowPairSquare</td>
        <td>WindowPairSquare( const BasePair< t_DataType, t_ReturnType> &DESCRIPTOR, const size_t &SIZE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window_pair_square.h</td>
        <td>WindowPairSquare</td>
        <td>WindowPairSquare( const util::Implementation< Base< t_DataType, t_ReturnType> > &DESCRIPTOR, const size_t &SIZE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window_pair_square.h</td>
        <td>WindowPairSquare</td>
        <td>WindowPairSquare()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window_segment_statistics.h</td>
        <td>WindowSegmentStatistics</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window_segment_statistics.h</td>
        <td>WindowSegmentStatistics</td>
        <td>WindowSegmentStatistics()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window_weights.h</td>
        <td>WindowWeights</td>
        <td>GetMethodName( const Method &METHOD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_window_weights.h</td>
        <td>WindowWeights</td>
        <td>WindowWeights( const Method &METHOD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_window_weights.h</td>
        <td>WindowWeights</td>
        <td>operator ()( const size_t &HALF_WINDOW_SIZE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_within_range.h</td>
        <td>WithinRange</td>
        <td>GetDescriptor() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_within_range.h</td>
        <td>WithinRange</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_within_range.h</td>
        <td>WithinRange</td>
        <td>SetDescriptor( const util::Implementation< Base< t_DataType, float> > &DESCRIPTOR)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_within_range.h</td>
        <td>WithinRange</td>
        <td>WithinRange( const float &RANGE_BEGIN, const float &RANGE_END, const bool &INCLUSIVE = true )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_within_range.h</td>
        <td>WithinRange</td>
        <td>WithinRange()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_within_range_gaussian.h</td>
        <td>WithinRangeGaussian</td>
        <td>GetDescriptor() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_within_range_gaussian.h</td>
        <td>WithinRangeGaussian</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_within_range_gaussian.h</td>
        <td>WithinRangeGaussian</td>
        <td>SetDescriptor( const util::Implementation< Base< t_DataType, float> > &DESCRIPTOR)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_within_range_gaussian.h</td>
        <td>WithinRangeGaussian</td>
        <td>WithinRangeGaussian( const float &MEAN = 0, const float &STDEV = 1)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_within_range_smooth.h</td>
        <td>WithinRangeSmooth</td>
        <td>GetDescriptor() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_within_range_smooth.h</td>
        <td>WithinRangeSmooth</td>
        <td>GetNormalSizeOfFeatures() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_within_range_smooth.h</td>
        <td>WithinRangeSmooth</td>
        <td>SetDescriptor( const util::Implementation< Base< t_DataType, float> > &DESCRIPTOR)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_descriptor_within_range_smooth.h</td>
        <td>WithinRangeSmooth</td>
        <td>WithinRangeSmooth( const float &RANGE_BEGIN, const float &RANGE_END, const float &LEFT_WIDTH = 0.0, const float &RIGHT_WIDTH = 0.0, const bool &INCLUSIVE = true )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_descriptor_within_range_smooth.h</td>
        <td>WithinRangeSmooth</td>
        <td>WithinRangeSmooth()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_collector_criteria_combined.h</td>
        <td>CollectorCriteriaCombined</td>
        <td>Collect( const util::SiPtrList< const t_ArgumentType> &ARGUMENT_LIST, const t_ArgumentType &CRITERIA_ARGUMENT ) const
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_collector_criteria_combined.h</td>
        <td>CollectorCriteriaCombined</td>
        <td>CollectorCriteriaCombined( const util::ShPtr< util::BinaryFunctionInterfaceSerializable< t_ArgumentType, t_ArgumentType, bool> > &SP_CRITERIA )
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_collector_criteria_combined.h</td>
        <td>CollectorCriteriaCombined</td>
        <td>CollectorCriteriaCombined( const util::ShPtrList< util::BinaryFunctionInterfaceSerializable< t_ArgumentType, t_ArgumentType, bool> > &COMBINED_CRITERIA )
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_collector_criteria_combined.h</td>
        <td>CollectorCriteriaCombined</td>
        <td>CollectorCriteriaCombined()
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_collector_criteria_combined.h</td>
        <td>CollectorCriteriaCombined</td>
        <td>GetSerializer() const
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_collector_criteria_wrapper.h</td>
        <td>CollectorCriteriaWrapper</td>
        <td>Collect( const t_ArgumentType &ARGUMENT, const t_CriteriaType &CRITERIA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_collector_criteria_wrapper.h</td>
        <td>CollectorCriteriaWrapper</td>
        <td>CollectorCriteriaWrapper( const CollectorInterface< t_ReturnType, t_ArgumentType> &COLLECTOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_collector_criteria_wrapper.h</td>
        <td>CollectorCriteriaWrapper</td>
        <td>CollectorCriteriaWrapper( const util::ShPtr< CollectorInterface< t_ReturnType, t_ArgumentType> > &SP_COLLECTOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_collector_criteria_wrapper.h</td>
        <td>CollectorCriteriaWrapper</td>
        <td>CollectorCriteriaWrapper()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_collector_criteria_wrapper.h</td>
        <td>CollectorCriteriaWrapper</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator.h</td>
        <td>Locator</td>
        <td>Locate( const t_ArgumentType &ARGUMENT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator.h</td>
        <td>Locator</td>
        <td>Locator( const CollectorInterface< t_IntermediateResultType, t_ArgumentType> &COLLECTOR, const PickInterface< t_ReturnType, t_IntermediateResultType> &PICKER )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator.h</td>
        <td>Locator</td>
        <td>Locator( const util::ShPtr< CollectorInterface< t_IntermediateResultType, t_ArgumentType> > &SP_COLLECTOR, const util::ShPtr< PickInterface< t_ReturnType, t_IntermediateResultType> > &SP_PICKER )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator.h</td>
        <td>Locator</td>
        <td>Locator()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator.h</td>
        <td></td>
        <td>AddInstance( new Locator< t_ReturnType, t_ArgumentType, t_IntermediateResultType>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_coordinates_average.h</td>
        <td>LocatorCoordinatesAverage</td>
        <td>Locate( const t_Argument &ARGUMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_coordinates_average.h</td>
        <td>LocatorCoordinatesAverage</td>
        <td>LocatorCoordinatesAverage( const storage::List< util::Implementation< LocatorCoordinatesInterface< t_Argument> > > &LOCATORS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_coordinates_average.h</td>
        <td>LocatorCoordinatesAverage</td>
        <td>LocatorCoordinatesAverage()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_coordinates_known.h</td>
        <td>LocatorCoordinatesKnown</td>
        <td>Locate( const t_ArgumentType &ARGUMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_coordinates_known.h</td>
        <td>LocatorCoordinatesKnown</td>
        <td>LocatorCoordinatesKnown( const LocatorInterface< linal::Vector3D, t_ArgumentType> &LOCATOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_coordinates_known.h</td>
        <td>LocatorCoordinatesKnown</td>
        <td>LocatorCoordinatesKnown( const util::ShPtr< LocatorInterface< linal::Vector3D, t_ArgumentType> > &LOCATOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_coordinates_known.h</td>
        <td>LocatorCoordinatesKnown</td>
        <td>LocatorCoordinatesKnown()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_coordinates_known.h</td>
        <td></td>
        <td>AddInstance( new LocatorCoordinatesKnown< t_ArgumentType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_coordinates_tetrahedral.h</td>
        <td>LocatorCoordinatesTetrahedral</td>
        <td>Locate( const t_ArgumentType &ARGUMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_coordinates_tetrahedral.h</td>
        <td>LocatorCoordinatesTetrahedral</td>
        <td>LocatorCoordinatesTetrahedral( const LocatorInterface< linal::Vector3D, t_ArgumentType> &CENTER, const LocatorInterface< linal::Vector3D, t_ArgumentType> &VERTEX_A, const LocatorInterface< linal::Vector3D, t_ArgumentType> &VERTEX_B, const LocatorInterface< linal::Vector3D, t_ArgumentType> &VERTEX_C, const double DISTANCE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_coordinates_tetrahedral.h</td>
        <td>LocatorCoordinatesTetrahedral</td>
        <td>LocatorCoordinatesTetrahedral( const util::ShPtr< LocatorInterface< linal::Vector3D, t_ArgumentType> > &CENTER, const util::ShPtr< LocatorInterface< linal::Vector3D, t_ArgumentType> > &VERTEX_A, const util::ShPtr< LocatorInterface< linal::Vector3D, t_ArgumentType> > &VERTEX_B, const util::ShPtr< LocatorInterface< linal::Vector3D, t_ArgumentType> > &VERTEX_C, const double DISTANCE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_coordinates_tetrahedral.h</td>
        <td>LocatorCoordinatesTetrahedral</td>
        <td>LocatorCoordinatesTetrahedral()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_coordinates_tetrahedral.h</td>
        <td></td>
        <td>AddInstance( new LocatorCoordinatesTetrahedral< t_ArgumentType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_coordinates_trigonal.h</td>
        <td>LocatorCoordinatesTrigonal</td>
        <td>Locate( const t_ArgumentType &ARGUMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_coordinates_trigonal.h</td>
        <td>LocatorCoordinatesTrigonal</td>
        <td>LocatorCoordinatesTrigonal( const util::ShPtr< LocatorInterface< linal::Vector3D, t_ArgumentType> > &CENTER, const util::ShPtr< LocatorInterface< linal::Vector3D, t_ArgumentType> > &VERTEX_A, const util::ShPtr< LocatorInterface< linal::Vector3D, t_ArgumentType> > &VERTEX_B, const double DISTANCE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_coordinates_trigonal.h</td>
        <td>LocatorCoordinatesTrigonal</td>
        <td>LocatorCoordinatesTrigonal()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_coordinates_trigonal.h</td>
        <td></td>
        <td>AddInstance( new LocatorCoordinatesTrigonal< t_ArgumentType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_criteria.h</td>
        <td>LocatorCriteria</td>
        <td>GetCollector() const
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_criteria.h</td>
        <td>LocatorCriteria</td>
        <td>GetSerializer() const
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_criteria.h</td>
        <td>LocatorCriteria</td>
        <td>Locate( const t_ArgumentType &ARGUMENT, const t_CriteriaType &CRITERIA) const
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_criteria.h</td>
        <td>LocatorCriteria</td>
        <td>LocatorCriteria( const util::ShPtr< CollectorCriteriaInterface< t_IntermediateResultType, t_ArgumentType, t_CriteriaType> > &SP_COLLECTOR, const util::ShPtr< PickCriteriaInterface< t_ReturnType, t_IntermediateResultType, t_CriteriaType> > &SP_PICKER )
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_criteria.h</td>
        <td>LocatorCriteria</td>
        <td>LocatorCriteria()
</td>
        <td>linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_criteria_interface.h</td>
        <td>LocatorCriteriaInterface</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_criteria_wrapper.h</td>
        <td>LocatorCriteriaWrapper</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_criteria_wrapper.h</td>
        <td>LocatorCriteriaWrapper</td>
        <td>Locate( const t_ArgumentType &ARGUMENT, const t_CriteriaType &CRITERIA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_criteria_wrapper.h</td>
        <td>LocatorCriteriaWrapper</td>
        <td>LocatorCriteriaWrapper( const LocatorInterface< t_ReturnType, t_ArgumentType> &LOCATOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_criteria_wrapper.h</td>
        <td>LocatorCriteriaWrapper</td>
        <td>LocatorCriteriaWrapper( const util::ShPtr< LocatorInterface< t_ReturnType, t_ArgumentType> > &SP_LOCATOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_locator_criteria_wrapper.h</td>
        <td>LocatorCriteriaWrapper</td>
        <td>LocatorCriteriaWrapper()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_locator_interface.h</td>
        <td>LocatorInterface</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_pick_body_extent.h</td>
        <td>PickBodyExtent</td>
        <td>ExtentsWithinTolerance( const linal::Vector3D &BODY_EXTENTS, const linal::Vector3D &CRITERIA_EXTENTS) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_pick_body_extent.h</td>
        <td>PickBodyExtent</td>
        <td>Pick( const util::ShPtrVector< assemble::SSEGeometryInterface> &BODIES, const assemble::SSEGeometryInterface &CRITERIA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_pick_body_extent.h</td>
        <td>PickBodyExtent</td>
        <td>PickBodyExtent( const linal::Vector3D &UPPER_TOLERANCE, const linal::Vector3D &LOWER_TOLERANCE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_pick_body_extent.h</td>
        <td>PickBodyExtent</td>
        <td>PickBodyExtent()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_pick_body_random.h</td>
        <td>PickBodyRandom</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_pick_body_random.h</td>
        <td>PickBodyRandom</td>
        <td>Pick( const util::ShPtrVector< assemble::SSEGeometryInterface> &BODIES) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_pick_body_random.h</td>
        <td>PickBodyRandom</td>
        <td>PickBodyRandom()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_pick_criteria_interface.h</td>
        <td>PickCriteriaInterface</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_pick_criteria_wrapper.h</td>
        <td>PickCriteriaWrapper</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_pick_criteria_wrapper.h</td>
        <td>PickCriteriaWrapper</td>
        <td>Pick( const t_ArgumentType &ARGUMENT, const t_CriteriaType &CRITERIA) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_pick_criteria_wrapper.h</td>
        <td>PickCriteriaWrapper</td>
        <td>PickCriteriaWrapper( const PickInterface< t_ReturnType, t_ArgumentType> &PICKER )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_pick_criteria_wrapper.h</td>
        <td>PickCriteriaWrapper</td>
        <td>PickCriteriaWrapper( const util::ShPtr< PickInterface< t_ReturnType, t_ArgumentType> > &SP_PICKER )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_find_pick_criteria_wrapper.h</td>
        <td>PickCriteriaWrapper</td>
        <td>PickCriteriaWrapper()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_find_pick_interface.h</td>
        <td>PickInterface</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_add_parabolic_loops.h</td>
        <td>AddParabolicLoops</td>
        <td>AddParabolicLoops( const bool &ANALYTIC_NORM_FACTOR, const bool &APPROXIMATE_CB = false)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_add_parabolic_loops.h</td>
        <td>AddParabolicLoops</td>
        <td>GetLoopCoordinates( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_add_parabolic_loops.h</td>
        <td>AddParabolicLoops</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_collector_loop_domain.h</td>
        <td>CollectorLoopDomain</td>
        <td>Collect( const assemble::DomainInterface &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_collector_loop_domain.h</td>
        <td>CollectorLoopDomain</td>
        <td>CollectorLoopDomain( const bool COLLECT_UNCLOSED_ONLY, const double LOOP_CLOSURE_THRESHOLD )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_collector_loop_domain.h</td>
        <td>CollectorLoopDomain</td>
        <td>CollectorLoopDomain()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_collector_loop_domain.h</td>
        <td>CollectorLoopDomain</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_collector_loop_domain_all_non_rigid.h</td>
        <td>CollectorLoopDomainAllNonRigid</td>
        <td>Collect( const LoopDomain &LOOP_DOMAIN) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_collector_loop_domain_all_non_rigid.h</td>
        <td>CollectorLoopDomainAllNonRigid</td>
        <td>CollectorLoopDomainAllNonRigid()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_collector_loop_domain_all_non_rigid.h</td>
        <td>CollectorLoopDomainAllNonRigid</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_collector_loop_domain_random.h</td>
        <td>CollectorLoopDomainRandom</td>
        <td>Collect( const LoopDomain &LOOP_DOMAIN) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_collector_loop_domain_random.h</td>
        <td>CollectorLoopDomainRandom</td>
        <td>CollectorLoopDomainRandom( const size_t NUMBER_MUTATION_RESIDUES_TO_COLLECT, const random::DistributionInterface &RANDOM_NUMBER_GENERATOR = random::GetGlobalRandom() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_collector_loop_domain_random.h</td>
        <td>CollectorLoopDomainRandom</td>
        <td>CollectorLoopDomainRandom()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_collector_loop_domain_random.h</td>
        <td>CollectorLoopDomainRandom</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_collector_unconnected_sses.h</td>
        <td>CollectorUnconnectedSSE</td>
        <td>Collect( const assemble::DomainInterface &DOMAIN_INTERFACE) const
</td>
        <td>alexanns, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_collector_unconnected_sses.h</td>
        <td>CollectorUnconnectedSSE</td>
        <td>CollectorUnconnectedSSE( const biol::AASequenceFlexibility::SequenceDirection &DIRECTION, const bool TEST_BOND_CONNECTION, const storage::Set< biol::SSType> &SS_TYPES, const bool IGNORE_TERMINAL_SSE )
</td>
        <td>alexanns, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_collector_unconnected_sses.h</td>
        <td>CollectorUnconnectedSSE</td>
        <td>CollectorUnconnectedSSE()
</td>
        <td>alexanns, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_collector_unconnected_sses.h</td>
        <td>CollectorUnconnectedSSE</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_criterion_loop_closure.h</td>
        <td>CriterionLoopClosure</td>
        <td>CriteriaMet( const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_criterion_loop_closure.h</td>
        <td>CriterionLoopClosure</td>
        <td>CriterionLoopClosure( const double &RMSD_CLOSURE_THRESHOLD)
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_criterion_loop_closure.h</td>
        <td>CriterionLoopClosure</td>
        <td>CriterionLoopClosure()
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>DefaultFlags()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetAllFlags()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagChainIdRead()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagEnableSSEResize()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagFastaRead()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagFitSwappedSSEs()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagMCNumberIterations()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagMutateRead()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagMutateWeightSetRead()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagMutateWeightSetWrite()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagMutateWrite()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagNativeModel()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagNumberModels()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagPDBIDNumbering()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagPoolSeparate()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagPrefix()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagPrintMinimization()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagPrintStartModel()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagPrintStepCounts()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagPrintTrackerHistory()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagReadSequenceDataPath()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagScoreRead()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagScoreWeightSetRead()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagScoreWeightSetWrite()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagScoreWrite()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagStagesFileRead()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagStagesFileWrite()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagStagesNumberCycles()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagStartModel()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetFlagUseNativeSSEsAsPool()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_flags.h</td>
        <td>DefaultFlags</td>
        <td>GetParameterPrintTrackerHistoryPath()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_mutates.h</td>
        <td>DefaultMutates</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_mutates.h</td>
        <td>DefaultMutates</td>
        <td>InitializeMutateTree( MutateTree &TREE, const assemble::ProteinModel &MODEL = assemble::ProteinModel() ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_mutates.h</td>
        <td>DefaultMutates</td>
        <td>InitializeMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_mutates.h</td>
        <td>DefaultMutates</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_scores.h</td>
        <td>DefaultScores</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_scores.h</td>
        <td>DefaultScores</td>
        <td>GetProteinInverter() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_scores.h</td>
        <td>DefaultScores</td>
        <td>GetSSPredScores() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_default_scores.h</td>
        <td>DefaultScores</td>
        <td>InitializeScores()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_default_scores.h</td>
        <td>DefaultScores</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_handler_locator_loop_domain.h</td>
        <td>HandlerLocatorLoopDomain</td>
        <td>CreateBidirectionalLocatorsForInteriorCoil( const assemble::ProteinModel &MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_handler_locator_loop_domain.h</td>
        <td>HandlerLocatorLoopDomain</td>
        <td>CreateCToNLocator( const assemble::SSE &SSE, const assemble::ProteinModel &MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_handler_locator_loop_domain.h</td>
        <td>HandlerLocatorLoopDomain</td>
        <td>CreateLocatorLoopDomainsForInteriorCoil( const assemble::ProteinModel &MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_handler_locator_loop_domain.h</td>
        <td>HandlerLocatorLoopDomain</td>
        <td>CreateNToCLocator( const assemble::SSE &SSE, const assemble::ProteinModel &MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_handler_locator_loop_domain.h</td>
        <td>HandlerLocatorLoopDomain</td>
        <td>GetFormat() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_handler_locator_loop_domain.h</td>
        <td>HandlerLocatorLoopDomain</td>
        <td>HandleRead( std::istream &ISTREAM, const assemble::ProteinModel &MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_handler_locator_loop_domain.h</td>
        <td>HandlerLocatorLoopDomain</td>
        <td>HandleReadMultiple( std::istream &ISTREAM, const assemble::ProteinModel &MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_handler_locator_loop_domain.h</td>
        <td>HandlerLocatorLoopDomain</td>
        <td>HandlerLocatorLoopDomain( const bool RANDOMIZE_PHI_PSI = true)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_handler_locator_loop_segment.h</td>
        <td>HandlerLocatorLoopSegment</td>
        <td>GetFormat() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_handler_locator_loop_segment.h</td>
        <td>HandlerLocatorLoopSegment</td>
        <td>HandleRead( const std::string &STRING) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_handler_locator_loop_segment.h</td>
        <td>HandlerLocatorLoopSegment</td>
        <td>HandleRead( std::istream &ISTREAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop.h</td>
        <td>LocatorLoop</td>
        <td>Locate( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_loop.h</td>
        <td>LocatorLoop</td>
        <td>LocatorLoop( bool IGNORE_TERMS = true, bool LOCATE_UNDEFINED = true)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>CalculateRMS( const assemble::ProteinModel &PROTEIN_MODEL, const LocatorLoopDomain &LOCATOR_LOOP_DOMAIN )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>CalculateSquareDistanceSum( const assemble::ProteinModel &PROTEIN_MODEL, const LocatorLoopDomain &LOCATOR_LOOP_DOMAIN )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>CalculateSquareDistanceSum( const storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair> &TARGET_AND_MOVING_POINTS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>GetLocatorSSEs() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>GetLoopSegments() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>IsClosed( const LocatorLoopDomain &DOMAIN_LOCATOR, const assemble::ProteinModel &MODEL, const double RMSD_CLOSURE_THRESHOLD )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>IsNToCSequenceDirection() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>Locate( const assemble::DomainInterface &SSE_DOMAIN) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>LocatorLoopDomain( const storage::List< LocatorLoopSegment> &SEGMENT_LOCATORS, const bool N_TO_C = true )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop_domain.h</td>
        <td>LocatorLoopDomain</td>
        <td>LocatorLoopDomain()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_loop_segment.h</td>
        <td>LocatorLoopSegment</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop_segment.h</td>
        <td>LocatorLoopSegment</td>
        <td>GetLocatorSSE() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_loop_segment.h</td>
        <td>LocatorLoopSegment</td>
        <td>IsRigid() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop_segment.h</td>
        <td>LocatorLoopSegment</td>
        <td>Locate( const assemble::DomainInterface &SSE_DOMAIN) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_loop_segment.h</td>
        <td>LocatorLoopSegment</td>
        <td>LocatorLoopSegment( const assemble::LocatorSSE &SSE_LOCATOR, const bool IS_RIGID)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_loop_segment.h</td>
        <td>LocatorLoopSegment</td>
        <td>LocatorLoopSegment()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_missing_coordinates.h</td>
        <td>LocatorMissingCoordinates</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_missing_coordinates.h</td>
        <td>LocatorMissingCoordinates</td>
        <td>Locate( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_missing_coordinates.h</td>
        <td>LocatorMissingCoordinates</td>
        <td>LocatorMissingCoordinates( bool IGNORE_TERMS = true)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_locator_unconnected_segments.h</td>
        <td>LocatorUnconnectedSegments</td>
        <td>Locate( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_locator_unconnected_segments.h</td>
        <td>LocatorUnconnectedSegments</td>
        <td>LocatorUnconnectedSegments()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>FindFollowingResidue( const biol::AABase &AA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>FindPreviousResidue( const biol::AABase &AA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>FindResidue( const assemble::LocatorAA &LOCATOR_AA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>FindResidue( const assemble::SSE &SEGMENT_SSE, const char CHAIN_ID, const int SEQ_ID ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>FindResidue( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>FindResidueIterator( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>FindSegment( const biol::AABase &RESIDUE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>FindSegment( const char RESI_CHAIN_ID, const int RESI_SEQ_ID ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>GetChainID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>GetFlagLoopDomainFilename()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>GetMostDistalLoopSegment() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>GetMostProximalLoopSegmentAA() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>GetResidues() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>GetSegments() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>GetSequenceDirection() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>LoopDomain( const LoopDomain &OTHER)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>LoopDomain( const storage::List< LoopSegment> &SEGMENTS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>LoopDomain()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>ReplaceSegment( const LoopSegment &LOOP_SEGMENT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>ReplaceSegment( const storage::List< LoopSegment> &LOOP_SEGMENTS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>ResiduesMatch( const biol::AABase &RESI_A, const biol::AABase &RESI_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>SetPhi( const biol::AABase &AA, const double PHI)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>SetPsi( const biol::AABase &AA, const double PSI)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>SetPtrToResidue( const util::ShPtr< biol::AABase> &RESIDUE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>TargetAndMovingPointsForCCD( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain.h</td>
        <td>LoopDomain</td>
        <td>UpdateProteinModel( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain_c_to_n.h</td>
        <td>LoopDomainCToN</td>
        <td>GetMostDistalLoopSegment() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain_c_to_n.h</td>
        <td>LoopDomainCToN</td>
        <td>GetMostProximalLoopSegmentAA() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain_c_to_n.h</td>
        <td>LoopDomainCToN</td>
        <td>GetResidues() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain_c_to_n.h</td>
        <td>LoopDomainCToN</td>
        <td>GetSequenceDirection() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain_c_to_n.h</td>
        <td>LoopDomainCToN</td>
        <td>LoopDomainCToN( const storage::List< LoopSegment> &SEGMENTS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain_c_to_n.h</td>
        <td>LoopDomainCToN</td>
        <td>LoopDomainCToN()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_domain_c_to_n.h</td>
        <td>LoopDomainCToN</td>
        <td>SetPhi( const biol::AABase &AA, const double PHI)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_domain_c_to_n.h</td>
        <td>LoopDomainCToN</td>
        <td>SetPsi( const biol::AABase &AA, const double PSI)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>Combine( const LoopParameters &TEMPLATE_N, const LoopParameters &TEMPLATE_C )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>CreateLoopLibrary( const std::string &LIBRARY_FILE_NAME, double DISTANCE_BIN_WIDTH = GetDefaultDistanceBinWidth(), double ANGLE_BIN_WIDTH = GetDefaultAngleBinWidth() )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>EstimateTemplateRequirement( const util::ShPtrVector< assemble::ProteinModel> &MODELS )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>FindTemplates( const LoopParameters &LOOP_PARAMS) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>FindTemplates( size_t LENGTH) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>GenerateTemplates( size_t LENGTH, size_t COUNT) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>GetDefaultAngleBinWidth()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>GetDefaultDistanceBinWidth()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>GetTemplates() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>ReadLibrary( std::istream &ISTREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_library.h</td>
        <td>LoopLibrary</td>
        <td>RecombineTemplates( const storage::HashMap< size_t, size_t> &COUNTS)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>Create( const biol::AABase &FIRST_ANCHOR, const biol::AABase &SECOND_ANCHOR, const storage::Vector< double> &ANGLES = storage::Vector< double>() )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetAnchors() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetAngles() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetChainID() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetEulerAngles( const storage::VectorND< 3, linal::Vector3D> &FRAME_A, const storage::VectorND< 3, linal::Vector3D> &FRAME_B )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetLocalCoordinateSystem( const biol::AABase &AMINO_ACID)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetRotation() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetSequenceDirection() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetSequenceDistance() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>GetTranslation() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>LoopParameters( const linal::Vector3D &TRANSLATION, const linal::Vector3D &ROTATION, const storage::Vector< int> &ANCHORS, const char &CHAIN_ID, const storage::Vector< double> &ANGLES )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>LoopParameters( const storage::Vector< int> &ANCHORS, const char &CHAIN_ID)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_parameters.h</td>
        <td>LoopParameters</td>
        <td>LoopParameters()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_segment.h</td>
        <td>LoopSegment</td>
        <td>GetAAIterator( const biol::AABase &AA_BASE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_segment.h</td>
        <td>LoopSegment</td>
        <td>GetConstSSEReference() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_segment.h</td>
        <td>LoopSegment</td>
        <td>GetSSE()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_segment.h</td>
        <td>LoopSegment</td>
        <td>GetSSE() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_segment.h</td>
        <td>LoopSegment</td>
        <td>GetSSEReference()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_segment.h</td>
        <td>LoopSegment</td>
        <td>IsRigid() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_segment.h</td>
        <td>LoopSegment</td>
        <td>LoopSegment( const LoopSegment &OTHER)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_segment.h</td>
        <td>LoopSegment</td>
        <td>LoopSegment( const util::ShPtr< assemble::SSE> &SSE, const bool IS_RIGID)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_segment.h</td>
        <td>LoopSegment</td>
        <td>LoopSegment()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_loop_segment_sequence_order.h</td>
        <td>LoopSegmentSequenceOrder</td>
        <td>operator ()( const LocatorLoopSegment &SEGMENT_LOCATOR_A, const LocatorLoopSegment &SEGMENT_LOCATOR_B ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_loop_segment_sequence_order.h</td>
        <td>LoopSegmentSequenceOrder</td>
        <td>operator ()( const LoopSegment &SEGMENT_A, const LoopSegment &SEGMENT_B) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_phi.h</td>
        <td>MutateAAPhi</td>
        <td>GetTransformationMatrix( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_phi.h</td>
        <td>MutateAAPhi</td>
        <td>MutateAAPhi( const double ROTATION)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_phi.h</td>
        <td>MutateAAPhi</td>
        <td>MutateAAPhi()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_phi.h</td>
        <td>MutateAAPhi</td>
        <td>operator ()( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_psi.h</td>
        <td>MutateAAPsi</td>
        <td>GetTransformationMatrix( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_psi.h</td>
        <td>MutateAAPsi</td>
        <td>MutateAAPsi( const double ROTATION)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_psi.h</td>
        <td>MutateAAPsi</td>
        <td>MutateAAPsi()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_psi.h</td>
        <td>MutateAAPsi</td>
        <td>operator ()( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_rotate.h</td>
        <td>MutateAARotate</td>
        <td>GetRotation() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_rotate.h</td>
        <td>MutateAARotate</td>
        <td>GetRotationAxis() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_rotate.h</td>
        <td>MutateAARotate</td>
        <td>GetRotationOrigin() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_rotate.h</td>
        <td>MutateAARotate</td>
        <td>GetTransformationMatrix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_rotate.h</td>
        <td>MutateAARotate</td>
        <td>MutateAARotate( const coord::LineSegment3D &ROTATION_AXIS, const linal::Vector3D &ROTATION_ORIGIN, const double ROTATION )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_rotate.h</td>
        <td>MutateAARotate</td>
        <td>MutateAARotate()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_rotate.h</td>
        <td>MutateAARotate</td>
        <td>operator ()( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_sequence_grow.h</td>
        <td>MutateAASequenceGrow</td>
        <td>GrowTowardsNTerminus( const biol::AASequence &SEQUENCE_TO_GROW) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_sequence_grow.h</td>
        <td>MutateAASequenceGrow</td>
        <td>MutateAASequenceGrow( const util::ShPtr < math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GENERATOR, const util::SiPtr< const biol::AASequence> &N_TERMINAL_AA_SEQUENCE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_sequence_grow.h</td>
        <td>MutateAASequenceGrow</td>
        <td>MutateAASequenceGrow()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_sequence_grow.h</td>
        <td>MutateAASequenceGrow</td>
        <td>operator ()( const biol::AASequence &SEQUENCE_TO_GROW) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_set_phi.h</td>
        <td>MutateAASetPhi</td>
        <td>GetTransformationMatrix( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_set_phi.h</td>
        <td>MutateAASetPhi</td>
        <td>MutateAASetPhi( const biol::Atom &PREVIOUS_C, const double DESIRED_PHI)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_set_phi.h</td>
        <td>MutateAASetPhi</td>
        <td>MutateAASetPhi()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_set_phi.h</td>
        <td>MutateAASetPhi</td>
        <td>operator ()( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_set_psi.h</td>
        <td>MutateAASetPsi</td>
        <td>GetTransformationMatrix( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_set_psi.h</td>
        <td>MutateAASetPsi</td>
        <td>MutateAASetPsi( const biol::Atom &FOLLOWING_N, const double DESIRED_PSI)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_aa_set_psi.h</td>
        <td>MutateAASetPsi</td>
        <td>MutateAASetPsi()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_aa_set_psi.h</td>
        <td>MutateAASetPsi</td>
        <td>operator ()( const biol::AABase &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_flip.h</td>
        <td>MutateDomainFlip</td>
        <td>GetFlipAll() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_flip.h</td>
        <td>MutateDomainFlip</td>
        <td>GetFlipAxes() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_flip.h</td>
        <td>MutateDomainFlip</td>
        <td>GetFlipInternal() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_flip.h</td>
        <td>MutateDomainFlip</td>
        <td>GetUseDifferentFlipAxes() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_flip.h</td>
        <td>MutateDomainFlip</td>
        <td>MutateDomainFlip( const coord::Axis FLIP_AXIS = coord::GetAxes().e_Z, const bool FLIP_INTERNAL = true, const bool FLIP_ALL = true, const bool USE_DIFFERENT_FLIP_AXES = false )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_flip.h</td>
        <td>MutateDomainFlip</td>
        <td>MutateDomainFlip( const storage::Set< coord::Axis> &FLIP_AXES, const bool FLIP_INTERNAL = true, const bool FLIP_ALL = true, const bool USE_DIFFERENT_FLIP_AXES = false )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_flip.h</td>
        <td>MutateDomainFlip</td>
        <td>operator ()( const assemble::Domain &THIS_DOMAIN) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_merge_consecutive_ss_types.h</td>
        <td>MutateDomainMergeConsecutiveSSTypes</td>
        <td>GetScheme() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_merge_consecutive_ss_types.h</td>
        <td>MutateDomainMergeConsecutiveSSTypes</td>
        <td>MutateDomainMergeConsecutiveSSTypes( const biol::SSType &SSTYPE)
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_merge_consecutive_ss_types.h</td>
        <td>MutateDomainMergeConsecutiveSSTypes</td>
        <td>MutateDomainMergeConsecutiveSSTypes()
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_merge_consecutive_ss_types.h</td>
        <td>MutateDomainMergeConsecutiveSSTypes</td>
        <td>operator ()( const assemble::Domain &DOMAINS) const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_shuffle.h</td>
        <td>MutateDomainShuffle</td>
        <td>GetMaxNumberSwaps() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_shuffle.h</td>
        <td>MutateDomainShuffle</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_shuffle.h</td>
        <td>MutateDomainShuffle</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_shuffle.h</td>
        <td>MutateDomainShuffle</td>
        <td>MutateDomainShuffle( const size_t MAX_NUMBER_SWAPS = 2, const bool BEND = false, const std::string &SCHEME = GetStaticClassName< MutateDomainShuffle>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_shuffle.h</td>
        <td>MutateDomainShuffle</td>
        <td>operator ()( const assemble::Domain &THIS_DOMAIN) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_sse_pair_trim.h</td>
        <td>MutateDomainSSEPairTrim</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_sse_pair_trim.h</td>
        <td>MutateDomainSSEPairTrim</td>
        <td>MutateDomainSSEPairTrim( const size_t NUMBER_RESIS_TO_TRIM, const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES = pdb::Factory::GetCommandlineSSETypeMinSizes(), const std::string &SCHEME = GetStaticClassName< MutateDomainSSEPairTrim>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_sse_pair_trim.h</td>
        <td>MutateDomainSSEPairTrim</td>
        <td>MutateDomainSSEPairTrim()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_sse_pair_trim.h</td>
        <td>MutateDomainSSEPairTrim</td>
        <td>operator ()( const assemble::Domain &THIS_DOMAIN) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_sse_split.h</td>
        <td>MutateDomainSSESplit</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_sse_split.h</td>
        <td>MutateDomainSSESplit</td>
        <td>MutateDomainSSESplit( const std::string &SCHEME, const double STANDARD_DEVIATION, const random::DistributionInterface &RNG = random::GetGlobalRandom() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_sse_split.h</td>
        <td>MutateDomainSSESplit</td>
        <td>MutateDomainSSESplit()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_sse_split.h</td>
        <td>MutateDomainSSESplit</td>
        <td>operator ()( const assemble::Domain &THIS_DOMAIN) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_transformation.h</td>
        <td>MutateDomainTransformation</td>
        <td>MutateDomainTransformation( const util::ShPtr< math::MutateInterface< math::TransformationMatrix3D> > &TRANSFORMER)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_domain_transformation.h</td>
        <td>MutateDomainTransformation</td>
        <td>MutateDomainTransformation()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_domain_transformation.h</td>
        <td>MutateDomainTransformation</td>
        <td>operator ()( const assemble::Domain &MUTATE_DOMAIN) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_loop_domain_dihedral.h</td>
        <td>MutateLoopDomainDihedral</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_loop_domain_dihedral.h</td>
        <td>MutateLoopDomainDihedral</td>
        <td>MutateLoopDomainDihedral( const util::ShPtr < find::CollectorInterface< storage::List< MutationResidue>, LoopDomain> > &RESIDUES_TO_CHANGE_COLLECTOR, const util::ShPtr < math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &DIHEDRAL_GENERATOR )
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_loop_domain_dihedral.h</td>
        <td>MutateLoopDomainDihedral</td>
        <td>MutateLoopDomainDihedral()
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_loop_domain_dihedral.h</td>
        <td>MutateLoopDomainDihedral</td>
        <td>operator ()( const LoopDomain &LOOP_DOMAIN) const
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_membrane.h</td>
        <td>MutateMembrane</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_membrane.h</td>
        <td>MutateMembrane</td>
        <td>MutateMembrane( const coord::MoveInterface &MOVE, const std::string &SCHEME = GetStaticClassName< MutateMembrane>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_membrane.h</td>
        <td>MutateMembrane</td>
        <td>MutateMembrane()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_membrane.h</td>
        <td>MutateMembrane</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>GetLigandChainIDs() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>GetMaxPhi() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>GetMaxPsi() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>GetMaxTheta() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>GetMaxTranslationX() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>GetMaxTranslationY() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>GetMaxTranslationZ() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>GetReceptorChainIDs() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>GetSerializer() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>MutateMembraneChainMove( const std::string &RECEPTOR_CHAIN_IDS, const std::string &LIGAND_CHAIN_IDS, double MAX_TRANSLATION_X = 1.0, double MAX_TRANSLATION_Y = 1.0, double MAX_TRANSLATION_Z = 1.0, double MAX_PHI = 1.0, double MAX_THETA = 1.0, double MAX_PSI = 1.0 )
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>MutateMembraneChainMove()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>SetReceptorLigandChainIDs( const assemble::ProteinModel &MODEL) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_membrane_chain_move.h</td>
        <td>MutateMembraneChainMove</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_multimer.h</td>
        <td>MutateMultimer</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_multimer.h</td>
        <td>MutateMultimer</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_multimer.h</td>
        <td>MutateMultimer</td>
        <td>MutateMultimer( const bool IS_DIHEDRAL = false, const std::string &SCHEME = GetStaticClassName< MutateMultimer>())
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_multimer.h</td>
        <td>MutateMultimer</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_ensemble_add.h</td>
        <td>MutateProteinEnsembleAdd</td>
        <td>MutateProteinEnsembleAdd( const util::ShPtr< assemble::ProteinEnsemble> &POOL_ENSEMBLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_ensemble_add.h</td>
        <td>MutateProteinEnsembleAdd</td>
        <td>MutateProteinEnsembleAdd()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_ensemble_add.h</td>
        <td>MutateProteinEnsembleAdd</td>
        <td>operator ()( const assemble::ProteinEnsemble &PROTEIN_ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_ensemble_remove.h</td>
        <td>MutateProteinEnsembleRemove</td>
        <td>MutateProteinEnsembleRemove()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_ensemble_remove.h</td>
        <td>MutateProteinEnsembleRemove</td>
        <td>operator ()( const assemble::ProteinEnsemble &PROTEIN_ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model.h</td>
        <td>MutateProteinModel</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model.h</td>
        <td>MutateProteinModel</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model.h</td>
        <td>MutateProteinModel</td>
        <td>MutateProteinModel( const coord::MoveInterface &MOVE, const std::string &SCHEME = GetStaticClassName< MutateProteinModel>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model.h</td>
        <td>MutateProteinModel</td>
        <td>MutateProteinModel()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model.h</td>
        <td>MutateProteinModel</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model.h</td>
        <td>MutateProteinModel</td>
        <td>operator =( const MutateProteinModel &MUTATE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_add_sheet_from_template.h</td>
        <td>MutateProteinModelAddSheetFromTemplate</td>
        <td>GetScheme() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_add_sheet_from_template.h</td>
        <td>MutateProteinModelAddSheetFromTemplate</td>
        <td>MutateProteinModelAddSheetFromTemplate( const PlacementInterface< assemble::Domain, assemble::ProteinModel> &PLACER = PlacementDomain() )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_add_sheet_from_template.h</td>
        <td>MutateProteinModelAddSheetFromTemplate</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>ComputeReceptorLigandShortestDistance( const assemble::ProteinModel &RECEPTOR, const assemble::ProteinModel &LIGAND )
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>GetLigand( const assemble::ProteinModel &COMPLEX)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>GetLigandChainID( const assemble::ProteinModel &COMPLEX)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>GetReceptor( const assemble::ProteinModel &COMPLEX)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>GetSerializer() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>MutateProteinModelChainMove( const double MAX_TRANSLATION_XY, const double MAX_TRANSLATION_Z, const double MAX_ROTATION_ANGLE, const double MAX_INTERNAL_ROTATION_ANGLE )
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>MutateProteinModelChainMove()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>PlaceLigand( const assemble::Chain &LIGAND, const assemble::ProteinModel &COMPLEX ) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>PreDock( assemble::ProteinModel &COMPLEX, bool MEMBRANE = false)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_chain_move.h</td>
        <td>MutateProteinModelChainMove</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_compress.h</td>
        <td>MutateProteinModelCompress</td>
        <td>GetCompressionRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_compress.h</td>
        <td>MutateProteinModelCompress</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_compress.h</td>
        <td>MutateProteinModelCompress</td>
        <td>MutateProteinModelCompress( const double COMPRESSION_FACTOR, const std::string &SCHEME = GetStaticClassName< MutateProteinModelCompress>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_compress.h</td>
        <td>MutateProteinModelCompress</td>
        <td>MutateProteinModelCompress( const math::Range< double> &COMPRESSION_FACTOR_RANGE, const std::string &SCHEME = GetStaticClassName< MutateProteinModelCompress>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_compress.h</td>
        <td>MutateProteinModelCompress</td>
        <td>MutateProteinModelCompress()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_compress.h</td>
        <td>MutateProteinModelCompress</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_domain.h</td>
        <td>MutateProteinModelDomain</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_domain.h</td>
        <td>MutateProteinModelDomain</td>
        <td>MutateProteinModelDomain( const find::CollectorInterface< util::ShPtrVector< assemble::Domain>, assemble::ProteinModel> &COLLECTOR, const coord::MoveInterface &MOVE, const std::string &SCHEME = GetStaticClassName< MutateProteinModelDomain>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_domain.h</td>
        <td>MutateProteinModelDomain</td>
        <td>MutateProteinModelDomain( const find::CollectorInterface< util::ShPtrVector< assemble::Domain>, assemble::ProteinModel> &COLLECTOR, const math::MutateInterface< assemble::Domain> &MUTATE, const std::string &SCHEME = GetStaticClassName< MutateProteinModelDomain>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_domain.h</td>
        <td>MutateProteinModelDomain</td>
        <td>MutateProteinModelDomain( const find::LocatorInterface< util::ShPtr< assemble::Domain>, assemble::ProteinModel> &LOCATOR, const coord::MoveInterface &MOVE, const std::string &SCHEME = GetStaticClassName< MutateProteinModelDomain>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_domain.h</td>
        <td>MutateProteinModelDomain</td>
        <td>MutateProteinModelDomain( const find::LocatorInterface< util::ShPtr< assemble::Domain>, assemble::ProteinModel> &LOCATOR, const math::MutateInterface< assemble::Domain> &MUTATE, const std::string &SCHEME = GetStaticClassName< MutateProteinModelDomain>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_domain.h</td>
        <td>MutateProteinModelDomain</td>
        <td>MutateProteinModelDomain()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_domain.h</td>
        <td>MutateProteinModelDomain</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_domain_add.h</td>
        <td>MutateProteinModelDomainAdd</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_domain_add.h</td>
        <td>MutateProteinModelDomainAdd</td>
        <td>MutateProteinModelDomainAdd( const find::CollectorInterface< util::ShPtrVector< assemble::Domain>, assemble::DomainInterface> &DOMAIN_COLLECTOR, const bool FIT_TO_FOLD_TEMPLATE = false, const std::string &SCHEME = GetStaticClassName< MutateProteinModelDomainAdd>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_domain_add.h</td>
        <td>MutateProteinModelDomainAdd</td>
        <td>MutateProteinModelDomainAdd()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_domain_add.h</td>
        <td>MutateProteinModelDomainAdd</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_filter_conformations.h</td>
        <td>MutateProteinModelFilterConformations</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_filter_conformations.h</td>
        <td>MutateProteinModelFilterConformations</td>
        <td>MutateProteinModelFilterConformations( const util::ShPtr < find::CollectorInterface< util::SiPtrList< const assemble::ProteinModel>, assemble::ProteinModel> > &COLLECTOR, const std::string &SCHEME = GetStaticClassName< MutateProteinModelFilterConformations>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_filter_conformations.h</td>
        <td>MutateProteinModelFilterConformations</td>
        <td>MutateProteinModelFilterConformations()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_filter_conformations.h</td>
        <td>MutateProteinModelFilterConformations</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_fix_loop_closure_wrapper.h</td>
        <td>MutateProteinModelFixLoopClosureWrapper</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_fix_loop_closure_wrapper.h</td>
        <td>MutateProteinModelFixLoopClosureWrapper</td>
        <td>MutateProteinModelFixLoopClosureWrapper( const math::MutateInterface< assemble::ProteinModel> &MUTATE_A, const std::string &SCHEME )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_fix_loop_closure_wrapper.h</td>
        <td>MutateProteinModelFixLoopClosureWrapper</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_grow_sse.h</td>
        <td>MutateProteinModelGrowSSE</td>
        <td>GrowAllMissingCoilsBidirectional( const assemble::ProteinModel &PROTEIN_MODEL, const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GEN )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_grow_sse.h</td>
        <td>MutateProteinModelGrowSSE</td>
        <td>GrowSSE( const assemble::SSE &SSE, util::ShPtr< assemble::ProteinModel> &MODEL, const biol::AASequenceFlexibility::SequenceDirection &DIRECTION, const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GEN )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_grow_sse.h</td>
        <td>MutateProteinModelGrowSSE</td>
        <td>GrowSpecifiedCoilsBidirectional( const assemble::ProteinModel &START_MODEL, const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GEN, const util::SiPtrVector< const assemble::LocatorSSE> &LOCATOR_SSES )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_grow_sse.h</td>
        <td>MutateProteinModelGrowSSE</td>
        <td>GrowTowardsCTerminus( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_grow_sse.h</td>
        <td>MutateProteinModelGrowSSE</td>
        <td>GrowTowardsNTerminus( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_grow_sse.h</td>
        <td>MutateProteinModelGrowSSE</td>
        <td>MutateProteinModelGrowSSE( const util::ShPtr < find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &LOCATOR_SSE, const util::ShPtr < math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GEN, const util::ShPtr < find::LocatorInterface< util::SiPtr< const biol::AABase>, assemble::ProteinModel> > &ANCHOR_AA, const biol::AASequenceFlexibility::SequenceDirection GROWING_DIRECTION )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_grow_sse.h</td>
        <td>MutateProteinModelGrowSSE</td>
        <td>MutateProteinModelGrowSSE()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_grow_sse.h</td>
        <td>MutateProteinModelGrowSSE</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_loop_domain.h</td>
        <td>MutateProteinModelLoopDomain</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_loop_domain.h</td>
        <td>MutateProteinModelLoopDomain</td>
        <td>MutateProteinModelLoopDomain( const util::ShPtr< find::CollectorInterface< util::ShPtrList< LoopDomain>, assemble::DomainInterface> > &LOOP_DOMAIN_COLLECTOR, const util::ShPtr< math::MutateInterface< LoopDomain> > &DOMAIN_MUTATE )
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_loop_domain.h</td>
        <td>MutateProteinModelLoopDomain</td>
        <td>MutateProteinModelLoopDomain()
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_loop_domain.h</td>
        <td>MutateProteinModelLoopDomain</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_loop_domain_ccd.h</td>
        <td>MutateProteinModelLoopDomainCCD</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_loop_domain_ccd.h</td>
        <td>MutateProteinModelLoopDomainCCD</td>
        <td>MutateProteinModelLoopDomainCCD( const util::ShPtr< find::CollectorInterface< util::ShPtrList< LoopDomain>, assemble::DomainInterface> > &DOMAIN_COLLECTOR, const random::DistributionInterface &RANDOM_NUMBER_GENERATOR, const math::Range< double> &RANDOM_FRACTION_RANGE )
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_loop_domain_ccd.h</td>
        <td>MutateProteinModelLoopDomainCCD</td>
        <td>MutateProteinModelLoopDomainCCD( const util::ShPtr< find::LocatorInterface< util::ShPtr< LoopDomain>, assemble::DomainInterface> > &DOMAIN_LOCATOR, const random::DistributionInterface &RANDOM_NUMBER_GENERATOR, const math::Range< double> &RANDOM_FRACTION_RANGE )
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_loop_domain_ccd.h</td>
        <td>MutateProteinModelLoopDomainCCD</td>
        <td>MutateProteinModelLoopDomainCCD()
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_loop_domain_ccd.h</td>
        <td>MutateProteinModelLoopDomainCCD</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_loop_domain_ccd.h</td>
        <td>MutateProteinModelLoopDomainCCD</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_loop_domain_grow.h</td>
        <td>MutateProteinModelLoopDomainGrow</td>
        <td>MutateProteinModelLoopDomainGrow( const util::ShPtr< find::LocatorInterface< util::ShPtr< LoopDomain>, assemble::DomainInterface> > &LOOP_DOMAIN_LOCATOR, const util::ShPtr < math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GENERATOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_loop_domain_grow.h</td>
        <td>MutateProteinModelLoopDomainGrow</td>
        <td>MutateProteinModelLoopDomainGrow()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_loop_domain_grow.h</td>
        <td>MutateProteinModelLoopDomainGrow</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_loop_resize.h</td>
        <td>MutateProteinModelLoopResize</td>
        <td>MutateProteinModelLoopResize( const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &LOCATOR, const double &EXTEND_PROBABILITY, const math::Range< size_t> &LENGTH_CHANGE_RANGE, const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES, const storage::Map< biol::SSType, size_t> &MAX_SSE_SIZES, const biol::AASequenceFlexibility::SequenceDirection &GROWING_DIRECTION, const util::ShPtr< math::FunctionInterfaceSerializable< MutationResidue, storage::VectorND< 2, double> > > &PHI_PSI_GENERATOR, const bool DISALLOW_OVERLAP = true, const std::string &SCHEME = GetStaticClassName< MutateProteinModelLoopResize>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_loop_resize.h</td>
        <td>MutateProteinModelLoopResize</td>
        <td>MutateProteinModelLoopResize()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_loop_resize.h</td>
        <td>MutateProteinModelLoopResize</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_move_aa.h</td>
        <td>MutateProteinModelMoveAA</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_move_aa.h</td>
        <td>MutateProteinModelMoveAA</td>
        <td>MoveAAs( const assemble::SSE &SSE_LEFT, const assemble::SSE &SSE_RIGHT, const size_t NUMBER_AAS, const biol::AASequenceFlexibility::SequenceDirection &DIRECTION )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_move_aa.h</td>
        <td>MutateProteinModelMoveAA</td>
        <td>MutateProteinModelMoveAA( const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &SSE_LOCATOR, const math::Range< size_t> &RESIDUES_TO_MOVE_RANGE, const biol::AASequenceFlexibility::SequenceDirection &SEQUENCE_SIDE, const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZE, const util::ShPtr< math::MutateInterface< assemble::SSE> > &SP_MUTATE_LOCATED_SSE, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_move_aa.h</td>
        <td>MutateProteinModelMoveAA</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_multiple_geometries.h</td>
        <td>MutateProteinModelMultipleGeometries</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_multiple_geometries.h</td>
        <td>MutateProteinModelMultipleGeometries</td>
        <td>MutateProteinModelMultipleGeometries( const assemble::FoldTemplate &FOLD_TEMPLATE, const std::string &SCHEME = GetStaticClassName< MutateProteinModelMultipleGeometries>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_multiple_geometries.h</td>
        <td>MutateProteinModelMultipleGeometries</td>
        <td>MutateProteinModelMultipleGeometries( const storage::VectorND< 3, double> &PROBABILITIES, const std::string &SCHEME = GetStaticClassName< MutateProteinModelMultipleGeometries>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_multiple_geometries.h</td>
        <td>MutateProteinModelMultipleGeometries</td>
        <td>MutateProteinModelMultipleGeometries()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_multiple_geometries.h</td>
        <td>MutateProteinModelMultipleGeometries</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_pair_strands.h</td>
        <td>MutateProteinModelPairStrands</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_pair_strands.h</td>
        <td>MutateProteinModelPairStrands</td>
        <td>MutateProteinModelPairStrands( const std::string &SCHEME)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_pair_strands.h</td>
        <td>MutateProteinModelPairStrands</td>
        <td>MutateProteinModelPairStrands()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_pair_strands.h</td>
        <td>MutateProteinModelPairStrands</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_replicate_conformation.h</td>
        <td>MutateProteinModelReplicateConformation</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_replicate_conformation.h</td>
        <td>MutateProteinModelReplicateConformation</td>
        <td>MutateProteinModelReplicateConformation( const util::ShPtr < find::CollectorInterface< util::SiPtrList< const assemble::ProteinModel>, assemble::ProteinModel> > &CONFORMATION, int NUMBER_REPLICATIONS, const std::string &SCHEME = GetStaticClassName< MutateProteinModelReplicateConformation>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_replicate_conformation.h</td>
        <td>MutateProteinModelReplicateConformation</td>
        <td>MutateProteinModelReplicateConformation()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_replicate_conformation.h</td>
        <td>MutateProteinModelReplicateConformation</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse.h</td>
        <td>MutateProteinModelSSE</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse.h</td>
        <td>MutateProteinModelSSE</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse.h</td>
        <td>MutateProteinModelSSE</td>
        <td>MutateProteinModelSSE( const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &LOCATOR, const util::ShPtr< math::MutateInterface< assemble::SSE> > &MUTATE, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSE>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse.h</td>
        <td>MutateProteinModelSSE</td>
        <td>MutateProteinModelSSE()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse.h</td>
        <td>MutateProteinModelSSE</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_add.h</td>
        <td>MutateProteinModelSSEAdd</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_add.h</td>
        <td>MutateProteinModelSSEAdd</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_add.h</td>
        <td>MutateProteinModelSSEAdd</td>
        <td>MutateProteinModelSSEAdd( const find::PickCriteriaInterface < util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::DomainInterface > &PICKER, const PlacementInterface< assemble::SSE, assemble::ProteinModel> &PLACEMENT, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEAdd>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_add.h</td>
        <td>MutateProteinModelSSEAdd</td>
        <td>MutateProteinModelSSEAdd( const util::ShPtr < find::PickCriteriaInterface < util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::DomainInterface > > &SP_PICKER, const util::ShPtr< PlacementInterface< assemble::SSE, assemble::ProteinModel> > &SP_PLACEMENT, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEAdd>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_add.h</td>
        <td>MutateProteinModelSSEAdd</td>
        <td>MutateProteinModelSSEAdd()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_add.h</td>
        <td>MutateProteinModelSSEAdd</td>
        <td>SetPlacement( const util::ShPtr< PlacementInterface< assemble::SSE, assemble::ProteinModel> > &SP_PLACEMENT)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_add.h</td>
        <td>MutateProteinModelSSEAdd</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_add_multiple.h</td>
        <td>MutateProteinModelSSEAddMultiple</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_add_multiple.h</td>
        <td>MutateProteinModelSSEAddMultiple</td>
        <td>MutateProteinModelSSEAddMultiple( const util::ShPtr< assemble::SSEPool> &SSE_POOL, const PlacementDomainInterface &PLACEMENT, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEAddMultiple>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_add_multiple.h</td>
        <td>MutateProteinModelSSEAddMultiple</td>
        <td>MutateProteinModelSSEAddMultiple( const util::ShPtr< assemble::SSEPool> &SSE_POOL, const util::ShPtr< PlacementDomainInterface> &SP_PLACEMENT, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEAddMultiple>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_add_multiple.h</td>
        <td>MutateProteinModelSSEAddMultiple</td>
        <td>MutateProteinModelSSEAddMultiple()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_add_multiple.h</td>
        <td>MutateProteinModelSSEAddMultiple</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_move.h</td>
        <td>MutateProteinModelSSEMove</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_move.h</td>
        <td>MutateProteinModelSSEMove</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_move.h</td>
        <td>MutateProteinModelSSEMove</td>
        <td>MutateProteinModelSSEMove( const find::LocatorCriteriaInterface < util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface > &LOCATOR, const PlacementInterface< assemble::SSE, assemble::ProteinModel> &PLACEMENT, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEMove>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_move.h</td>
        <td>MutateProteinModelSSEMove</td>
        <td>MutateProteinModelSSEMove( const util::ShPtr < find::LocatorCriteriaInterface < util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::DomainInterface > > &SP_LOCATOR, const util::ShPtr< PlacementInterface< assemble::SSE, assemble::ProteinModel> > &SP_PLACEMENT, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEMove>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_move.h</td>
        <td>MutateProteinModelSSEMove</td>
        <td>MutateProteinModelSSEMove()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_move.h</td>
        <td>MutateProteinModelSSEMove</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair.h</td>
        <td>MutateProteinModelSSEPair</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair.h</td>
        <td>MutateProteinModelSSEPair</td>
        <td>MutateProteinModelSSEPair( const util::ShPtr < find::CollectorInterface < storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface > > &SP_COLLECTOR, const double MAX_TRANSLATION, const double MAX_ROTATION, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEPair>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair.h</td>
        <td>MutateProteinModelSSEPair</td>
        <td>MutateProteinModelSSEPair( const util::ShPtr < find::CollectorInterface < storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface > > &SP_COLLECTOR, const math::Range< double> &TRANSLATION_RANGE, const math::Range< double> &ROTATION_RANGE, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEPair>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair.h</td>
        <td>MutateProteinModelSSEPair</td>
        <td>MutateProteinModelSSEPair()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair.h</td>
        <td>MutateProteinModelSSEPair</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair_align_and_pull.h</td>
        <td>MutateProteinModelSSEPairAlignAndPull</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair_align_and_pull.h</td>
        <td>MutateProteinModelSSEPairAlignAndPull</td>
        <td>MutateProteinModelSSEPairAlignAndPull( const util::ShPtr < find::CollectorInterface < storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface > > &SP_COLLECTOR, const bool &PULL, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEPairAlignAndPull>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair_align_and_pull.h</td>
        <td>MutateProteinModelSSEPairAlignAndPull</td>
        <td>MutateProteinModelSSEPairAlignAndPull()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair_align_and_pull.h</td>
        <td>MutateProteinModelSSEPairAlignAndPull</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair_clash.h</td>
        <td>MutateProteinModelSSEPairClash</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair_clash.h</td>
        <td>MutateProteinModelSSEPairClash</td>
        <td>MutateProteinModelSSEPairClash( const size_t &MAX_SSES_TO_MOVE = util::GetUndefinedSize_t())
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair_clash.h</td>
        <td>MutateProteinModelSSEPairClash</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair_fix_loop_closure.h</td>
        <td>MutateProteinModelSSEPairFixLoopClosure</td>
        <td>GetMaxLoopLength( const size_t &N_RESIDUES) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair_fix_loop_closure.h</td>
        <td>MutateProteinModelSSEPairFixLoopClosure</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair_fix_loop_closure.h</td>
        <td>MutateProteinModelSSEPairFixLoopClosure</td>
        <td>GetTypicalLoopLength( const size_t &N_RESIDUES) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair_fix_loop_closure.h</td>
        <td>MutateProteinModelSSEPairFixLoopClosure</td>
        <td>MutateProteinModelSSEPairFixLoopClosure( const size_t &MAX_SSES_TO_MOVE = util::GetUndefinedSize_t())
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair_fix_loop_closure.h</td>
        <td>MutateProteinModelSSEPairFixLoopClosure</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair_hinge.h</td>
        <td>MutateProteinModelSSEPairHinge</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair_hinge.h</td>
        <td>MutateProteinModelSSEPairHinge</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair_hinge.h</td>
        <td>MutateProteinModelSSEPairHinge</td>
        <td>MutateProteinModelSSEPairHinge( const find::CollectorInterface< storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface> &COLLECTOR, const coord::MoveInterface &MOVE, const bool MOVE_HINGE = true, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEPairHinge>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair_hinge.h</td>
        <td>MutateProteinModelSSEPairHinge</td>
        <td>MutateProteinModelSSEPairHinge( const util::ShPtr< find::CollectorInterface< storage::List< storage::VectorND< 2, util::SiPtr< const assemble::SSE> > >, assemble::DomainInterface> > &SP_COLLECTOR, const util::ShPtr< coord::MoveInterface> &SP_MOVE, const bool MOVE_HINGE = true, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEPairHinge>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_pair_hinge.h</td>
        <td>MutateProteinModelSSEPairHinge</td>
        <td>MutateProteinModelSSEPairHinge()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_pair_hinge.h</td>
        <td>MutateProteinModelSSEPairHinge</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_remove.h</td>
        <td>MutateProteinModelSSERemove</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_remove.h</td>
        <td>MutateProteinModelSSERemove</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_remove.h</td>
        <td>MutateProteinModelSSERemove</td>
        <td>MutateProteinModelSSERemove( const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &LOCATOR, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSERemove>() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_remove.h</td>
        <td>MutateProteinModelSSERemove</td>
        <td>MutateProteinModelSSERemove()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_remove.h</td>
        <td>MutateProteinModelSSERemove</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_resize.h</td>
        <td>MutateProteinModelSSEResize</td>
        <td>GetExtendProbability() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_resize.h</td>
        <td>MutateProteinModelSSEResize</td>
        <td>GetLengthChangeRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_resize.h</td>
        <td>MutateProteinModelSSEResize</td>
        <td>GetMinSSESizes() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_resize.h</td>
        <td>MutateProteinModelSSEResize</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_resize.h</td>
        <td>MutateProteinModelSSEResize</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_resize.h</td>
        <td>MutateProteinModelSSEResize</td>
        <td>GetSide() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_resize.h</td>
        <td>MutateProteinModelSSEResize</td>
        <td>MutateProteinModelSSEResize( const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &SSE_LOCATOR, const double &EXTEND_PROBABILITY, const math::Range< size_t> &LENGTH_CHANGE_RANGE, const biol::AASequenceFlexibility::SequenceDirection &SEQUENCE_SIDE, const bool RECENTER_AFTER_RESIZE, const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSEResize>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_resize.h</td>
        <td>MutateProteinModelSSEResize</td>
        <td>MutateProteinModelSSEResize()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_resize.h</td>
        <td>MutateProteinModelSSEResize</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_seed.h</td>
        <td>MutateProteinModelSSESeed</td>
        <td>GetScheme() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_seed.h</td>
        <td>MutateProteinModelSSESeed</td>
        <td>MutateProteinModelSSESeed( const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &SSE_LOCATOR, const math::Range< size_t> &SEED_LENGTH_RANGE, const biol::AASequenceFlexibility::SequenceDirection &DIRECTION, const util::ShPtr< math::MutateInterface< assemble::SSE> > &SP_MUTATE_SEED, const math::Range< size_t> &CUT_IN_RANGE, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSESeed>() )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_seed.h</td>
        <td>MutateProteinModelSSESeed</td>
        <td>MutateProteinModelSSESeed()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_seed.h</td>
        <td>MutateProteinModelSSESeed</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_split.h</td>
        <td>MutateProteinModelSSESplit</td>
        <td>GetDefaultScheme()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_split.h</td>
        <td>MutateProteinModelSSESplit</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_split.h</td>
        <td>MutateProteinModelSSESplit</td>
        <td>MutateProteinModelSSESplit( const sspred::Method &SS_METHOD, const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &SP_LOCATE_SSE, const storage::Map< biol::SSType, size_t> &MIN_SSE_SIZES, const math::Range< size_t> &SPLIT_COIL_LENGTH_RANGE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_split.h</td>
        <td>MutateProteinModelSSESplit</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap.h</td>
        <td>MutateProteinModelSSESwap</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap.h</td>
        <td>MutateProteinModelSSESwap</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap.h</td>
        <td>MutateProteinModelSSESwap</td>
        <td>MutateProteinModelSSESwap( const find::LocatorCriteriaInterface < util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE > &LOCATOR, const bool BEND = false, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSESwap>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap.h</td>
        <td>MutateProteinModelSSESwap</td>
        <td>MutateProteinModelSSESwap( const util::ShPtr < find::LocatorCriteriaInterface < util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE > > &SP_LOCATOR, const bool BEND = false, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSESwap>() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap.h</td>
        <td>MutateProteinModelSSESwap</td>
        <td>MutateProteinModelSSESwap()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap.h</td>
        <td>MutateProteinModelSSESwap</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap_body.h</td>
        <td>MutateProteinModelSSESwapBody</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap_body.h</td>
        <td>MutateProteinModelSSESwapBody</td>
        <td>MutateProteinModelSSESwapBody( const util::ShPtr< restraint::Body> &BODY_RESTRAINT, const util::ShPtr < find::PickCriteriaInterface < util::ShPtr< assemble::SSEGeometryInterface>, util::ShPtrVector< assemble::SSEGeometryInterface>, assemble::SSEGeometryInterface > > &BODY_PICKER, const util::ShPtr< find::LocatorInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface> > &LOCATOR, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSESwapBody>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap_body.h</td>
        <td>MutateProteinModelSSESwapBody</td>
        <td>MutateProteinModelSSESwapBody()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap_body.h</td>
        <td>MutateProteinModelSSESwapBody</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap_multimer.h</td>
        <td>MutateProteinModelSSESwapMultimer</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap_multimer.h</td>
        <td>MutateProteinModelSSESwapMultimer</td>
        <td>MutateProteinModelSSESwapMultimer( const bool BEND = false, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSESwapMultimer>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap_multimer.h</td>
        <td>MutateProteinModelSSESwapMultimer</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool.h</td>
        <td>MutateProteinModelSSESwapWithPool</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool.h</td>
        <td>MutateProteinModelSSESwapWithPool</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool.h</td>
        <td>MutateProteinModelSSESwapWithPool</td>
        <td>MutateProteinModelSSESwapWithPool( const find::LocatorCriteriaInterface < util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE > &LOCATOR, const bool BEND = false, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSESwapWithPool>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool.h</td>
        <td>MutateProteinModelSSESwapWithPool</td>
        <td>MutateProteinModelSSESwapWithPool( const util::ShPtr < find::LocatorCriteriaInterface < util::SiPtr< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE > > &SP_LOCATOR, const bool BEND = false, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSESwapWithPool>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool.h</td>
        <td>MutateProteinModelSSESwapWithPool</td>
        <td>MutateProteinModelSSESwapWithPool()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool.h</td>
        <td>MutateProteinModelSSESwapWithPool</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool_overlap.h</td>
        <td>MutateProteinModelSSESwapWithPoolOverlap</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool_overlap.h</td>
        <td>MutateProteinModelSSESwapWithPoolOverlap</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool_overlap.h</td>
        <td>MutateProteinModelSSESwapWithPoolOverlap</td>
        <td>MutateProteinModelSSESwapWithPoolOverlap( const util::ShPtr < find::CollectorCriteriaInterface < util::SiPtrList< const assemble::SSE>, util::SiPtrList< const assemble::SSE>, assemble::SSE > > &COLLECTOR, const bool SINGLE_SWAPS_ONLY = false, const bool BEND = false, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSSESwapWithPoolOverlap>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool_overlap.h</td>
        <td>MutateProteinModelSSESwapWithPoolOverlap</td>
        <td>MutateProteinModelSSESwapWithPoolOverlap()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_sse_swap_with_pool_overlap.h</td>
        <td>MutateProteinModelSSESwapWithPoolOverlap</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_strand_switch_sheet.h</td>
        <td>MutateProteinModelStrandSwitchSheet</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_strand_switch_sheet.h</td>
        <td>MutateProteinModelStrandSwitchSheet</td>
        <td>MutateProteinModelStrandSwitchSheet( const PlacementStrandNextToSheet &PLACEMENT, const std::string &SCHEME )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_strand_switch_sheet.h</td>
        <td>MutateProteinModelStrandSwitchSheet</td>
        <td>MutateProteinModelStrandSwitchSheet()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_strand_switch_sheet.h</td>
        <td>MutateProteinModelStrandSwitchSheet</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_switch_conformation.h</td>
        <td>MutateProteinModelSwitchConformation</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_switch_conformation.h</td>
        <td>MutateProteinModelSwitchConformation</td>
        <td>MutateProteinModelSwitchConformation( const util::ShPtr < find::LocatorInterface< util::SiPtr< const assemble::ProteinModel>, assemble::ProteinModel> > &CONFORMATION, const std::string &SCHEME = GetStaticClassName< MutateProteinModelSwitchConformation>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_switch_conformation.h</td>
        <td>MutateProteinModelSwitchConformation</td>
        <td>MutateProteinModelSwitchConformation()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_switch_conformation.h</td>
        <td>MutateProteinModelSwitchConformation</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_thread_sequence.h</td>
        <td>MutateProteinModelThreadSequence</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_thread_sequence.h</td>
        <td>MutateProteinModelThreadSequence</td>
        <td>HasAnyDefinedCoordinates( const biol::AABase &RESI)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_thread_sequence.h</td>
        <td>MutateProteinModelThreadSequence</td>
        <td>MutateProteinModelThreadSequence( const storage::Map< char, util::ShPtr< align::AlignmentInterface< biol::AABase> > > &CHAIN_ALIGNMENT, const std::string &SCHEME = GetStaticClassName< MutateProteinModelThreadSequence>(), const bool PRINT_STRUCTURAL_PROBLEM_AAS = true )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_thread_sequence.h</td>
        <td>MutateProteinModelThreadSequence</td>
        <td>MutateProteinModelThreadSequence()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_thread_sequence.h</td>
        <td>MutateProteinModelThreadSequence</td>
        <td>OutputStructurallyProbematicSequenceRegions( const assemble::Chain &CHAIN, const align::AlignmentInterface< biol::AABase> &ALIGNMENT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_thread_sequence.h</td>
        <td>MutateProteinModelThreadSequence</td>
        <td>ThreadSequenceOntoChain( const assemble::Chain &CHAIN, const align::AlignmentInterface< biol::AABase> &ALIGNMENT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_protein_model_thread_sequence.h</td>
        <td>MutateProteinModelThreadSequence</td>
        <td>UpdateChainInModel( const assemble::ProteinModel &MODEL, const util::ShPtr< assemble::Chain> &CHAIN )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_protein_model_thread_sequence.h</td>
        <td>MutateProteinModelThreadSequence</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_cycle.h</td>
        <td>MutateSheetCycle</td>
        <td>GetNumberRotations() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_cycle.h</td>
        <td>MutateSheetCycle</td>
        <td>GetPreserveSheetGeometry() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_cycle.h</td>
        <td>MutateSheetCycle</td>
        <td>GetPreserveStrandOrientations() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_cycle.h</td>
        <td>MutateSheetCycle</td>
        <td>GetRotateSubset() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_cycle.h</td>
        <td>MutateSheetCycle</td>
        <td>GetSubsetSize() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_cycle.h</td>
        <td>MutateSheetCycle</td>
        <td>MutateSheetCycle( const bool PRESERVE_SHEET_GEOMETRY = true, const bool PRESERVE_STRAND_ORIENTATIONS = true, const bool ROTATE_SUBSET = false, const math::Range< size_t> &NUMBER_ROTATIONS = ( math::Range< size_t>( 1, 2)), const math::Range< size_t> &SUBSET_SIZE = ( math::Range< size_t>( 2, 3)) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_cycle.h</td>
        <td>MutateSheetCycle</td>
        <td>operator ()( const assemble::Domain &SHEET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_divide.h</td>
        <td>MutateSheetDivide</td>
        <td>GetFormBetaSandwich() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_divide.h</td>
        <td>MutateSheetDivide</td>
        <td>GetMaxTranslations()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_divide.h</td>
        <td>MutateSheetDivide</td>
        <td>GetMinDividedSheetSize() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_divide.h</td>
        <td>MutateSheetDivide</td>
        <td>GetMinSheetSize() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_divide.h</td>
        <td>MutateSheetDivide</td>
        <td>GetMinTranslations()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_divide.h</td>
        <td>MutateSheetDivide</td>
        <td>MutateSheetDivide( const size_t MIN_SHEET_SIZE, const size_t MIN_DIVIDED_SHEET_SIZE, const bool FORM_BETA_SANDWICH, const linal::Vector3D &MIN_TRANSLATIONS = linal::Vector3D( 0.0, 0.0, 0.0), const linal::Vector3D &MAX_TRANSLATIONS = linal::Vector3D( 4.0, 4.0, 2.0) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_divide.h</td>
        <td>MutateSheetDivide</td>
        <td>operator ()( const assemble::Domain &SHEET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_fit_to_template.h</td>
        <td>MutateSheetFitToTemplate</td>
        <td>operator ()( const assemble::Domain &SHEET) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_order.h</td>
        <td>MutateSheetOrder</td>
        <td>GetParallelProbability() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_order.h</td>
        <td>MutateSheetOrder</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_order.h</td>
        <td>MutateSheetOrder</td>
        <td>MutateSheetOrder( const double PARALLEL_PROBABILITY)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_order.h</td>
        <td>MutateSheetOrder</td>
        <td>MutateSheetOrder()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_order.h</td>
        <td>MutateSheetOrder</td>
        <td>operator ()( const assemble::Domain &SHEET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_register_fix.h</td>
        <td>MutateSheetRegisterFix</td>
        <td>operator ()( const assemble::Domain &SHEET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_register_shift.h</td>
        <td>MutateSheetRegisterShift</td>
        <td>GetCAShiftAlongZAxis()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_register_shift.h</td>
        <td>MutateSheetRegisterShift</td>
        <td>GetDefaultShiftProbabilities()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_register_shift.h</td>
        <td>MutateSheetRegisterShift</td>
        <td>GetShiftProbabilities() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_register_shift.h</td>
        <td>MutateSheetRegisterShift</td>
        <td>MutateSheetRegisterShift( const storage::VectorND< 2, double> &SHIFT_PROBABILITIES = GetDefaultShiftProbabilities() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_register_shift.h</td>
        <td>MutateSheetRegisterShift</td>
        <td>operator ()( const assemble::Domain &SHEET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_sort.h</td>
        <td>MutateSheetSort</td>
        <td>GetReverseSortProbability() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_sort.h</td>
        <td>MutateSheetSort</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_sort.h</td>
        <td>MutateSheetSort</td>
        <td>MutateSheetSort( const double REVERSE_SORT_PROBABILITY )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_sort.h</td>
        <td>MutateSheetSort</td>
        <td>MutateSheetSort()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_sort.h</td>
        <td>MutateSheetSort</td>
        <td>operator ()( const assemble::Domain &SHEET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_twist.h</td>
        <td>MutateSheetTwist</td>
        <td>GetAngleRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_twist.h</td>
        <td>MutateSheetTwist</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_twist.h</td>
        <td>MutateSheetTwist</td>
        <td>MutateSheetTwist( const math::Range< double> ANGLE_RANGE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sheet_twist.h</td>
        <td>MutateSheetTwist</td>
        <td>MutateSheetTwist()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sheet_twist.h</td>
        <td>MutateSheetTwist</td>
        <td>operator ()( const assemble::Domain &SHEET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_ramachandran.h</td>
        <td>MutateSSEBendRamachandran</td>
        <td>GetBendingDirection() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_ramachandran.h</td>
        <td>MutateSSEBendRamachandran</td>
        <td>GetNrResiduesChangeRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_ramachandran.h</td>
        <td>MutateSSEBendRamachandran</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_ramachandran.h</td>
        <td>MutateSSEBendRamachandran</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_ramachandran.h</td>
        <td>MutateSSEBendRamachandran</td>
        <td>MutateSSEBendRamachandran( const math::Range< size_t> &NR_RESIDUES_TO_CHANGE_RANGE, const biol::AASequenceFlexibility::SequenceDirection BENDING_DIRECTION = biol::AASequenceFlexibility::e_Bidirectional, const std::string &SCHEME = GetStaticClassName< MutateSSEBendRamachandran>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_ramachandran.h</td>
        <td>MutateSSEBendRamachandran</td>
        <td>MutateSSEBendRamachandran()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_ramachandran.h</td>
        <td>MutateSSEBendRamachandran</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_ramachandran.h</td>
        <td>MutateSSEBendRamachandran</td>
        <td>operator ()( const assemble::SSE &THIS_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_ramachandran.h</td>
        <td>MutateSSEBendRamachandran</td>
        <td>operator ()( const assemble::SSE &THIS_SSE, const util::SiPtr< const biol::Membrane> &MEMBRANE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_random.h</td>
        <td>MutateSSEBendRandom</td>
        <td>GetBendingDirection() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_random.h</td>
        <td>MutateSSEBendRandom</td>
        <td>GetPhiChangeRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_random.h</td>
        <td>MutateSSEBendRandom</td>
        <td>GetPsiChangeRange() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_random.h</td>
        <td>MutateSSEBendRandom</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_random.h</td>
        <td>MutateSSEBendRandom</td>
        <td>MutateSSEBendRandom( const math::Range< double> &PHI_CHANGE_RANGE, const math::Range< double> &PSI_CHANGE_RANGE, const biol::AASequenceFlexibility::SequenceDirection BENDING_DIRECTION = biol::AASequenceFlexibility::e_Bidirectional, const std::string &SCHEME = GetStaticClassName< MutateSSEBendRandom>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_random.h</td>
        <td>MutateSSEBendRandom</td>
        <td>MutateSSEBendRandom()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_random.h</td>
        <td>MutateSSEBendRandom</td>
        <td>operator ()( const assemble::SSE &THIS_SSE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_template.h</td>
        <td>MutateSSEBendTemplate</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_template.h</td>
        <td>MutateSSEBendTemplate</td>
        <td>MutateSSEBendTemplate( const math::BinaryFunctionInterface< assemble::SSE, assemble::SSEGeometryPhiPsi, bool> &SSE_GEOMETRY_COMPARE, const std::string &SCHEME = GetStaticClassName< MutateSSEBendTemplate>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_bend_template.h</td>
        <td>MutateSSEBendTemplate</td>
        <td>MutateSSEBendTemplate()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_bend_template.h</td>
        <td>MutateSSEBendTemplate</td>
        <td>operator ()( const assemble::SSE &THIS_SSE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_type.h</td>
        <td>MutateSSEType</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_type.h</td>
        <td>MutateSSEType</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_sse_type.h</td>
        <td>MutateSSEType</td>
        <td>MutateSSEType( const storage::Set< biol::SSType> &POSSIBLE_TYPES, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_sse_type.h</td>
        <td>MutateSSEType</td>
        <td>operator ()( const assemble::SSE &ELEMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>ConstructMutates() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>CreateTable() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetMutateProbabilities() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetMutateProbability( const Mutate &MUTATE_ENUM) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetMutateSet( const Mutate &MUTATE) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetMutateTypeName( const MutateTypes &MUTATE_TYPE)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetMutateTypeProbabilities() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetMutateTypeProbability( const MutateTypes &MUTATE_TYPE) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetMutateTypeSet( const MutateTypes &MUTATE_TYPE) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetMutateTypeZero( const MutateTypes &MUTATE_TYPE) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetMutateZero( const Mutate &MUTATE) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>GetSerializer() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>Merge( const MutateTree &MUTATE_TREE)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>MutateTree( const storage::Table< double> &WEIGHT_TABLE)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>MutateTree()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>ParseMutateType( const std::string &MUTATE_NAME)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>Reset()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>SetDefaultMutateProbability( const Mutate &MUTATE_ENUM, const double PROBABILITY)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>SetDefaultMutateTypeProbability( const MutateTypes &MUTATE_TYPE, const double PROBABILITY)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>SetMutateProbability( const Mutate &MUTATE_ENUM, const double PROBABILITY)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>SetMutateProbability( const std::string &MUTATE_NAME, const double PROBABILITY)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>SetMutateSet( const Mutate &MUTATE, const bool SET)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>SetMutateTypeProbability( const MutateTypes &MUTATE_TYPE, const double PROBABILITY)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutate_tree.h</td>
        <td>MutateTree</td>
        <td>SetMutateTypeSet( const MutateTypes &MUTATE_TYPE, const bool SET)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutates.h</td>
        <td>Mutates</td>
        <td>AddMutate( const math::MutateInterface< assemble::ProteinModel> &MUTATE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutates.h</td>
        <td>Mutates</td>
        <td>AddMutate( const util::ShPtr< math::MutateInterface< assemble::ProteinModel> > &SP_MUTATE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutates.h</td>
        <td></td>
        <td>GetMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutation_residue.h</td>
        <td>MutationResidue</td>
        <td>GetFollowingResidue() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutation_residue.h</td>
        <td>MutationResidue</td>
        <td>GetMutationResidue() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutation_residue.h</td>
        <td>MutationResidue</td>
        <td>GetPreviousResidue() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutation_residue.h</td>
        <td>MutationResidue</td>
        <td>MutationResidue( const storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> >::const_iterator RESIDUE_TO_MUTATE, const storage::List< storage::Pair< util::ShPtr< biol::AABase>, bool> > &ALL_RESIDUES )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_mutation_residue.h</td>
        <td>MutationResidue</td>
        <td>MutationResidue( const util::ShPtr< biol::AABase> &RESIDUE_TO_MUTATE, const util::ShPtr< biol::AABase> &RESIDUE_A, const util::ShPtr< biol::AABase> &RESIDUE_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_mutation_residue.h</td>
        <td>MutationResidue</td>
        <td>MutationResidue()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_phi_psi_generator_ccd.h</td>
        <td>PhiPsiGeneratorCCD</td>
        <td>PhiPsiGeneratorCCD( const storage::List< coord::CyclicCoordinateDescent::TargetAndMovingPointPair> &TARGET_AND_MOVING_POINTS, const random::DistributionInterface &RANDOM_NUMBER_GENERATOR, const biol::AASequenceFlexibility::SequenceDirection &DIRECTION, const math::Range< double> &RANDOM_FRACTION_RANGE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_phi_psi_generator_ccd.h</td>
        <td>PhiPsiGeneratorCCD</td>
        <td>PhiPsiGeneratorCCD()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_phi_psi_generator_ccd.h</td>
        <td>PhiPsiGeneratorCCD</td>
        <td>operator ()( const MutationResidue &MUTATION_RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_phi_psi_generator_ramachandran.h</td>
        <td>PhiPsiGeneratorRamachandran</td>
        <td>GetDefaultInstance()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_phi_psi_generator_ramachandran.h</td>
        <td>PhiPsiGeneratorRamachandran</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_phi_psi_generator_ramachandran.h</td>
        <td>PhiPsiGeneratorRamachandran</td>
        <td>PhiPsiGeneratorRamachandran( const biol::Ramachandran &RAMACHANDRAN)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_phi_psi_generator_ramachandran.h</td>
        <td>PhiPsiGeneratorRamachandran</td>
        <td>PhiPsiGeneratorRamachandran()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_phi_psi_generator_ramachandran.h</td>
        <td>PhiPsiGeneratorRamachandran</td>
        <td>operator ()( const MutationResidue &RESIDUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_domain.h</td>
        <td>PlacementDomain</td>
        <td>Place( const assemble::Domain &SELECTED_DOMAIN, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_domain.h</td>
        <td>PlacementDomain</td>
        <td>PlacementDomain()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_domain_using_fold_template.h</td>
        <td>PlacementDomainUsingFoldTemplate</td>
        <td>Place( const assemble::DomainInterface &DOMAIN_TO_PLACE ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_domain_using_fold_template.h</td>
        <td>PlacementDomainUsingFoldTemplate</td>
        <td>Place( const assemble::DomainInterface &DOMAIN_TO_PLACE, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_domain_using_fold_template.h</td>
        <td>PlacementDomainUsingFoldTemplate</td>
        <td>PlacementDomainUsingFoldTemplate( const int &BODY_DEVIATION = 0)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_interface.h</td>
        <td>PlacementInterface</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_interface.h</td>
        <td>PlacementInterface</td>
        <td>Place( const t_ObjectType &OBJECT ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_distance_restraint.h</td>
        <td>PlacementSSEDistanceRestraint</td>
        <td>ContainsRestraint( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B, const restraint::AtomDistance &RESTRAINT )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_distance_restraint.h</td>
        <td>PlacementSSEDistanceRestraint</td>
        <td>HasResidue( const assemble::SSE &SELECTED_SSE, const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_distance_restraint.h</td>
        <td>PlacementSSEDistanceRestraint</td>
        <td>Place( const assemble::SSE &SELECTED_SSE, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_distance_restraint.h</td>
        <td>PlacementSSEDistanceRestraint</td>
        <td>PlacementSSEDistanceRestraint( const util::ShPtr< util::ShPtrVector< restraint::AtomDistance> > &RESTRAINTS)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_distance_restraint.h</td>
        <td>PlacementSSEDistanceRestraint</td>
        <td>PlacementSSEDistanceRestraint()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_into_body.h</td>
        <td>PlacementSSEIntoBody</td>
        <td>DetermineTransformatinMatrix3DandBool( const util::ShPtr< assemble::SSEGeometryInterface> &RESTRAINT_BODY ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_into_body.h</td>
        <td>PlacementSSEIntoBody</td>
        <td>GetBodyRestraint() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_into_body.h</td>
        <td>PlacementSSEIntoBody</td>
        <td>Place( const assemble::SSE &SSE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_into_body.h</td>
        <td>PlacementSSEIntoBody</td>
        <td>Place( const assemble::SSE &SSE, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_into_body.h</td>
        <td>PlacementSSEIntoBody</td>
        <td>PlacementSSEIntoBody( const util::ShPtr< restraint::Body> &RESTRAINT, const util::ShPtr < find::PickCriteriaInterface < util::ShPtr< assemble::SSEGeometryInterface>, util::ShPtrVector< assemble::SSEGeometryInterface>, assemble::SSEGeometryInterface > > &BODY_PICKER, util::ShPtr< math::MutateInterface< math::TransformationMatrix3D> > &ORIENTATION )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_into_body.h</td>
        <td>PlacementSSEIntoBody</td>
        <td>PlacementSSEIntoBody()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_next_to_sse.h</td>
        <td>PlacementSSENextToSSE</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_next_to_sse.h</td>
        <td>PlacementSSENextToSSE</td>
        <td>Place( const assemble::SSE &SELECTED_SSE, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_next_to_sse.h</td>
        <td>PlacementSSENextToSSE</td>
        <td>Place( const assemble::SSE &SELECTED_SSE, const assemble::SSE &NEIGHBOR_SSE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_next_to_sse.h</td>
        <td>PlacementSSENextToSSE</td>
        <td>PlacementSSENextToSSE( const find::LocatorCriteriaInterface < util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::SSE > &LOCATOR_CRITERIA )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_next_to_sse.h</td>
        <td>PlacementSSENextToSSE</td>
        <td>PlacementSSENextToSSE( const util::ShPtr < find::LocatorCriteriaInterface< util::SiPtr< const assemble::SSE>, assemble::DomainInterface, assemble::SSE> > &SP_LOCATOR_CRITERIA )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_next_to_sse.h</td>
        <td>PlacementSSENextToSSE</td>
        <td>PlacementSSENextToSSE()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_short_loop.h</td>
        <td>PlacementSSEShortLoop</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_short_loop.h</td>
        <td>PlacementSSEShortLoop</td>
        <td>Place( const assemble::SSE &SELECTED_SSE, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_short_loop.h</td>
        <td>PlacementSSEShortLoop</td>
        <td>Place( const assemble::SSE &SELECTED_SSE, const assemble::SSE &NEIGHBOR_SSE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_sse_short_loop.h</td>
        <td>PlacementSSEShortLoop</td>
        <td>PlacementSSEShortLoop( const size_t MAX_SHORT_LOOP_LENGTH, const double ADD_TO_TOP_PROBABILITY = 0.25, const double MAX_HINGE_ANGLE_ADDING_TO_TOP = ( math::g_Pi / 3.0) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_sse_short_loop.h</td>
        <td>PlacementSSEShortLoop</td>
        <td>PlacementSSEShortLoop()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_strand_next_to_sheet.h</td>
        <td>PlacementStrandNextToSheet</td>
        <td>GetFlipProbability()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_strand_next_to_sheet.h</td>
        <td>PlacementStrandNextToSheet</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_strand_next_to_sheet.h</td>
        <td>PlacementStrandNextToSheet</td>
        <td>Place( const assemble::SSE &SELECTED_STRAND, const assemble::Domain &SHEET ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_placement_strand_next_to_sheet.h</td>
        <td>PlacementStrandNextToSheet</td>
        <td>Place( const assemble::SSE &SELECTED_STRAND, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_placement_strand_next_to_sheet.h</td>
        <td>PlacementStrandNextToSheet</td>
        <td>PlacementStrandNextToSheet( const double FLIP_PROBABILITY = 0.5)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protein_geometry.h</td>
        <td>ProteinGeometry</td>
        <td>CombineSequences( const biol::AASequence &SEQ_N, const biol::AASequence &SEQ_C, int MERGE_N, int MERGE_C )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protein_geometry.h</td>
        <td>ProteinGeometry</td>
        <td>FitToTemplate( const assemble::ProteinModel &PROTEIN_MODEL, const LoopParameters &LOOP, const LoopParameters &TEMPLATE )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protein_geometry.h</td>
        <td>ProteinGeometry</td>
        <td>GetLocalCoordinateSystem( const biol::AABase &AMINO_ACID)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protein_geometry.h</td>
        <td>ProteinGeometry</td>
        <td>ProteinGeometry()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>GetAllFlags() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>GetMutateTree() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>GetReadMe() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>InitializeMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>InitializeScores()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_assembly.h</td>
        <td>ProtocolAssembly</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>GetAllFlags() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>GetInstance()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>GetMutateTree() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>GetReadMe() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>InitializeMutates()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>InitializeScores()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_create.h</td>
        <td>ProtocolCreate</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>AddRandomSSEToStartModel( assemble::ProteinModel &START_MODEL)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>GetAllFlags() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>GetMutateTree() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>GetReadMe() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>InitializeMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>InitializeScores()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_default.h</td>
        <td>ProtocolDefault</td>
        <td>Reset()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>GetAllFlags() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>GetDescription() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>GetFlagDomainSpecification()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>GetFlagPrintDomainToPymolScript()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>GetInstance()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>GetMutateTree() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>InitializeMutates()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>InitializeScores()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_dock.h</td>
        <td>ProtocolDock</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetAllFlags() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetBodyRestraint()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetBodyRestraints()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetFlagBodyRestraint()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetFlagEMRefinement()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetFlagPrintBodyAssignment()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetFlagScoreDensityAgreement()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetFlagScoreDensityConnectivity()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetMutateTree() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetReadMe() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetScoreBodyConnectivityDensity()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetScoreBodyRestraint()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetScoresDensityAgreement()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>InitializeBodyAddMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>InitializeMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>InitializeScores()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_em.h</td>
        <td>ProtocolEM</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>GetAllFlags() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>GetDescription() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>GetFlagEnsembleSize()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>GetInstance()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>GetMutateTree() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>InitializeMutates()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>InitializeScores()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble.h</td>
        <td>ProtocolEnsemble</td>
        <td>ProtocolEnsemble()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>GetAllFlags() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>GetDescription() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>GetFlagFilterNumberToKeep()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>GetFlagFilterScoreFunctions()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>GetInstance()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>GetMutateTree() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>InitializeMutates()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>InitializeScores()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_filter.h</td>
        <td>ProtocolEnsembleFilter</td>
        <td>ProtocolEnsembleFilter()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>GetAllFlags() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>GetDescription() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>GetInstance()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>GetMutateTree() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>InitializeMutates()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>InitializeScores()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_replicate_conformation.h</td>
        <td>ProtocolEnsembleReplicateConformation</td>
        <td>ProtocolEnsembleReplicateConformation()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>GetAllFlags() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>GetDescription() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>GetInstance()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>GetMutateTree() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>GetReadMe() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>InitializeMutates()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>InitializeScores()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_ensemble_switch_conformation.h</td>
        <td>ProtocolEnsembleSwitchConformation</td>
        <td>ProtocolEnsembleSwitchConformation()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_interface.h</td>
        <td>ProtocolInterface</td>
        <td>Reset()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>AddLoopCoordinates( assemble::ProteinModel &MODEL)
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>AddNitrogenHydrogens( const assemble::ProteinModel &MODEL)
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>GetAllFlags() const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>GetDescription() const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>GetFlagRamachandranMutateProbability()
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>GetFlagUseFullFraction()
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>GetInstance()
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>GetMutateTree() const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>GetReadMe() const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>InitializeMutates()
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>InitializeScores()
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>SplitCoilsAtNonPetideBond( assemble::ProteinModel &MODEL)
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_close.h</td>
        <td>ProtocolLoopClose</td>
        <td>SplitSSEAtNonPetideBond( const assemble::SSE &SS_ELEMENT)
</td>
        <td>alexanns, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>GetAllFlags() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>GetDescription() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>GetFlagLoopDomainFilename()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>GetInstance()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>GetMutateTree() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>GetReadMe() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>InitializeMutates()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>InitializeScores()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_loop_coordinate_add.h</td>
        <td>ProtocolLoopCoordinateAdd</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>GetAllFlags() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>GetMutateTree() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>GetReadMe() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>InitializeMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>InitializeScores()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_membrane.h</td>
        <td>ProtocolMembrane</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>GetAllFlags() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>GetFlagMultimer()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>GetFlagNativeMultimer()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>GetMutateTree() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>GetNativeMultimer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>GetReadMe() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>InitializeMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>InitializeScores()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_multimer.h</td>
        <td>ProtocolMultimer</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>GetAllFlags() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>GetMutateTree() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>GetReadMe() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>InitializeMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>InitializeScores()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_refinement.h</td>
        <td>ProtocolRefinement</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>GetAllFlags() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>GetDescription() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>GetMutateTree() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>GetReadMe() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>InitializeMutates()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>InitializeScores()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_restraint.h</td>
        <td>ProtocolRestraint</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>GetAllFlags() const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>GetDescription() const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>GetInstance()
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>GetMutateTree() const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>GetReadMe() const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>GetSerializer() const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>InitializeMutates()
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>InitializeScores()
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>MergeAndModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>ModifyCriterion( opti::CriterionCombine< assemble::ProteinModel, double> &CRITERION, const mc::Stage &STAGE ) const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>ModifyFactory( util::ShPtr< pdb::Factory> &FACTORY, const mc::Stage &STAGE) const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>ModifyMutateTree( MutateTree &MUTATE_TREE) const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>ModifyPrinter( mc::PrinterCombined< assemble::ProteinModel, double> &PRINTER, const mc::Stage &STAGE) const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>ModifyScoreWeightSet( ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocol_template.h</td>
        <td>ProtocolTemplate</td>
        <td>ModifyStartModel( assemble::ProteinModel &START_MODEL) const
</td>
        <td>fischea, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocols.h</td>
        <td>Protocols</td>
        <td>GetCommandLineMutateProtocolList()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocols.h</td>
        <td>Protocols</td>
        <td>GetCommandLineProtocolList()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocols.h</td>
        <td>Protocols</td>
        <td>GetCommandLineScoreProtocolList()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocols.h</td>
        <td>Protocols</td>
        <td>GetFlagMutateProtocols()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocols.h</td>
        <td>Protocols</td>
        <td>GetFlagProtocols()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_protocols.h</td>
        <td>Protocols</td>
        <td>GetFlagScoreProtocols()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_protocols.h</td>
        <td></td>
        <td>GetProtocols()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_score_weight_set.h</td>
        <td>ScoreWeightSet</td>
        <td>ConstructScoreSum() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_score_weight_set.h</td>
        <td>ScoreWeightSet</td>
        <td>CreateTable() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_score_weight_set.h</td>
        <td>ScoreWeightSet</td>
        <td>GetWeight( const Score &SCORE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_score_weight_set.h</td>
        <td>ScoreWeightSet</td>
        <td>GetWeightMap() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_score_weight_set.h</td>
        <td>ScoreWeightSet</td>
        <td>Reset()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_score_weight_set.h</td>
        <td>ScoreWeightSet</td>
        <td>ScoreWeightSet( const storage::Table< double> &TABLE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_score_weight_set.h</td>
        <td>ScoreWeightSet</td>
        <td>ScoreWeightSet()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_score_weight_set.h</td>
        <td>ScoreWeightSet</td>
        <td>SetWeight( const Score &SCORE, const double WEIGHT )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_score_weight_set.h</td>
        <td>ScoreWeightSet</td>
        <td>SetWeight( const std::string &SCORE_NAME, const double WEIGHT )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_scores.h</td>
        <td>Scores</td>
        <td>AddScore( const util::ShPtr< score::ProteinModel> &SCORE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_scores.h</td>
        <td>Scores</td>
        <td>AddScoreVector( const util::ShPtrVector< score::ProteinModel> &SCORES)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_scores.h</td>
        <td>Scores</td>
        <td>WrapCacheProteinModelScore( const util::ShPtr< score::ProteinModel> &SP_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_scores.h</td>
        <td>Scores</td>
        <td>WrapCacheSSEPairScore( const util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> > &SP_FUNCTION, const bool SYMMETRIC )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_scores.h</td>
        <td>Scores</td>
        <td>WrapCacheSSEScore( const util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > > &SP_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_scores.h</td>
        <td></td>
        <td>GetScores()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetAllFlags()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetEmptyModel() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetNativeModel() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetNumberRounds() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetPrefix() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetQualityMeasures() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetReadme()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetStartModel() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetStaticInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetStepStatuses() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetStorage() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>GetSuperimposeMeasure() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_setup.h</td>
        <td>Setup</td>
        <td>InitializeStaticInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_setup.h</td>
        <td></td>
        <td>GetSetup()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_stage_factory.h</td>
        <td>StageFactory</td>
        <td>CreateStages()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_fold_stage_factory.h</td>
        <td>StageFactory</td>
        <td>LineTypeFromString( const std::string &LINE_NAME)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_fold_stage_factory.h</td>
        <td>StageFactory</td>
        <td>StageFactory()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_adapter.h</td>
        <td>BinaryAdapter</td>
        <td>BinaryAdapter( const util::ShPtr< BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_IntermediateTypeLeft> > &SP_FUNCTION_A1A2B, const util::ShPtr< UnaryInterface< t_IntermediateTypeRight, t_ResultType> > &SP_FUNCTION_BC )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_adapter.h</td>
        <td>BinaryAdapter</td>
        <td>BinaryAdapter( const util::ShPtr< BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_IntermediateTypeLeft> > &SP_FUNCTION_A1A2B, const util::ShPtr< UnaryInterface< t_IntermediateTypeRight, t_ResultType> > &SP_FUNCTION_BC, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_adapter.h</td>
        <td>BinaryAdapter</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_adapter.h</td>
        <td>BinaryAdapter</td>
        <td>operator ()( t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>AddSignalHandlerForArgument( SignalHandlerFunctionPtr SIGNAL_HANDLER1)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>AddSignalHandlerForArgument( SignalHandlerFunctionPtr1 SIGNAL_HANDLER1)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>AddSignalHandlerForArgument( SignalHandlerFunctionPtr2 SIGNAL_HANDLER2)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>BinaryCached( const BinaryCached< t_ArgumentType, t_ArgumentType, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>BinaryCached( const BinaryCached< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>BinaryCached( const util::ShPtr< BinaryInterface< t_ArgumentType, t_ArgumentType, t_ResultType> > &SP_FUNCTION, SignalHandlerFunctionPtr DESTRUCTOR_SIGNAL_HANDLER, const bool SYMMETRIC )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>BinaryCached( const util::ShPtr< BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> > &SP_FUNCTION, SignalHandlerFunctionPtr1 DESTRUCTOR_SIGNAL_1, SignalHandlerFunctionPtr2 DESTRUCTOR_SIGNAL_2 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>GetCacheSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>GetFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>GetFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>IsSymmetric() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType &ARGUMENT1, const t_ArgumentType &ARGUMENT2, std::ostream &OSTREAM, const util::Format &FORMAT = util::Format() ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType1 &ARGUMENT1, const t_ArgumentType2 &ARGUMENT2, std::ostream &OSTREAM, const util::Format &FORMAT = util::Format() ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>operator ()( t_ArgumentType &ARGUMENT1, t_ArgumentType &ARGUMENT2) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>operator ()( t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>operator =( const BinaryCached< t_ArgumentType, t_ArgumentType, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_cached.h</td>
        <td>BinaryCached</td>
        <td>operator =( const BinaryCached< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_cached.h</td>
        <td></td>
        <td>AddInstance( new BinaryCached< t_ArgumentType1, t_ArgumentType2, t_ResultType>( util::ShPtr< BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> >()))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_interface.h</td>
        <td>BinaryInterface</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_interface.h</td>
        <td>BinaryInterface</td>
        <td>WriteDetailedSchemeAndValues( t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2, std::ostream &OSTREAM ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>BinarySum( const t_ResultType &ABSOLUTE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>BinarySum( const util::ShPtr< FunctionType> &SP_FUNCTION, const double &COEFFICIENT = double( 1), const t_ResultType &ABSOLUTE = t_ResultType() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>BinarySum( const util::ShPtr< FunctionType> &SP_FUNCTION_A, const util::ShPtr< FunctionType> &SP_FUNCTION_B, const double &COEFFICIENT_A = double( 1), const double &COEFFICIENT_B = double( 1), const t_ResultType &ABSOLUTE = t_ResultType() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>BinarySum()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>GetFunction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>NewOperand( const util::ShPtr< FunctionType> &SP_FUNCTION, const double &COEFFICIENT = double( 1) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>WriteDetailedSchemeAndValues( t_ArgumentType1 &ARGUMENT_1, t_ArgumentType2 &ARGUMENT_2, std::ostream &OSTREAM ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator ()( t_ArgumentType1 &ARGUMENT_1, t_ArgumentType2 &ARGUMENT_2 ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator *=( const double &SCALAR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator +=( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator +=( const FunctionType &FUNCTION)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator +=( const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator -() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator -=( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator -=( const FunctionType &FUNCTION)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator -=( const t_ResultType &VALUE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator /=( const double &SCALAR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td>BinarySum</td>
        <td>operator =( const FunctionType &FUNCTION)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>AddInstance( new BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType>())
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator *( const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION, const double &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator *( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION, const double &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator *( const double &SCALAR, const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator *( const double &SCALAR, const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator +( const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION, const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator +( const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator +( const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator +( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator +( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION, const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator +( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION_A, const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator +( const t_ResultType &VALUE, const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator +( const t_ResultType &VALUE, const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator -( const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION, const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator -( const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator -( const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator -( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator -( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION, const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator -( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION_A, const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator -( const t_ResultType &VALUE, const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator -( const t_ResultType &VALUE, const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator /( const BinaryInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION, const double &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_binary_sum.h</td>
        <td></td>
        <td>operator /( const BinarySum< t_ArgumentType1, t_ArgumentType2, t_ResultType> &SUM_FUNCTION, const double &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_member.h</td>
        <td>Member</td>
        <td>Member( MemberFunctionPtr MEMBER_FUNCTION_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_member.h</td>
        <td>Member</td>
        <td>operator ()( t_ClassType &CLASS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_member_const.h</td>
        <td>MemberConst</td>
        <td>IsDefined() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_member_const.h</td>
        <td>MemberConst</td>
        <td>MemberConst( MemberConstFunctionPtr MEMBER_FUNCTION_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_member_const.h</td>
        <td>MemberConst</td>
        <td>operator ()( const t_ClassType &CLASS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_member_unary.h</td>
        <td>MemberUnary</td>
        <td>MemberUnary( MemberUnaryFunctionPtr MEMBER_FUNCTION_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_member_unary.h</td>
        <td>MemberUnary</td>
        <td>operator ()( t_ClassType &CLASS, t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_member_unary.h</td>
        <td>MemberUnary</td>
        <td>operator ()( t_ClassType &CLASS, t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_member_unary_const.h</td>
        <td>MemberUnaryConst</td>
        <td>MemberUnaryConst( MemberUnaryConstFunctionPtr MEMBER_FUNCTION_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_member_unary_const.h</td>
        <td>MemberUnaryConst</td>
        <td>operator ()( const t_ClassType &CLASS, t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_unary_adapter.h</td>
        <td>UnaryAdapter</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_unary_adapter.h</td>
        <td>UnaryAdapter</td>
        <td>UnaryAdapter( const util::ShPtr< UnaryInterface< t_ArgumentType , t_IntermediateType> > &SP_FUNCTION_AB, const util::ShPtr< UnaryInterface< t_IntermediateType, t_ResultType> > &SP_FUNCTION_BC )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_unary_adapter.h</td>
        <td>UnaryAdapter</td>
        <td>UnaryAdapter( const util::ShPtr< UnaryInterface< t_ArgumentType , t_IntermediateType> > &SP_FUNCTION_AB, const util::ShPtr< UnaryInterface< t_IntermediateType, t_ResultType> > &SP_FUNCTION_BC, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_unary_adapter.h</td>
        <td>UnaryAdapter</td>
        <td>operator ()( t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_unary_cached.h</td>
        <td>UnaryCached</td>
        <td>AddSignalHandlerForArgument( SignalHandlerFunctionPtr SIGNAL_HANDLER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_unary_cached.h</td>
        <td>UnaryCached</td>
        <td>GetCacheSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_unary_cached.h</td>
        <td>UnaryCached</td>
        <td>GetFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_unary_cached.h</td>
        <td>UnaryCached</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_unary_cached.h</td>
        <td>UnaryCached</td>
        <td>UnaryCached( const UnaryCached< t_ArgumentType, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_unary_cached.h</td>
        <td>UnaryCached</td>
        <td>UnaryCached( const util::ShPtr< UnaryInterface< t_ArgumentType, t_ResultType> > &SP_FUNCTION, SignalHandlerFunctionPtr DESTRUCTOR_SIGNAL_HANDLER )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_unary_cached.h</td>
        <td>UnaryCached</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType &ARGUMENT, std::ostream &OSTREAM, const util::Format &FORMAT = util::Format() ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_unary_cached.h</td>
        <td>UnaryCached</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_function_unary_cached.h</td>
        <td>UnaryCached</td>
        <td>operator =( const UnaryCached< t_ArgumentType, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_function_unary_interface.h</td>
        <td>UnaryInterface</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>CommonSubgraphIsomorphism( const CommonSubgraphIsomorphism &PARENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>CommonSubgraphIsomorphism( const SolutionType &SOLUTION_TYPE = CommonSubgraphIsomorphismBase::e_Connected, const util::ShPtr< util::BinaryFunctionInterface< t_VertexData, t_VertexData, bool> > &VERTEX_COMPARER = GetDefaultVertexComparison(), const util::ShPtr< util::BinaryFunctionInterface< t_EdgeData, t_EdgeData, bool> > &EDGE_COMPARER = GetDefaultEdgeComparison() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>EstimateUpperBounds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>FindIsomorphism( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_A, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_B, const size_t UPPER_BOUNDS, const size_t LOWER_BOUNDS = 1, const storage::Vector< storage::Vector< size_t> > &MATCHING_VERTICES = storage::Vector< storage::Vector< size_t> >(), const bool &FIND_ALL = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>FindIsomorphism( const size_t UPPER_BOUNDS, const size_t LOWER_BOUNDS = 1, const storage::Vector< storage::Vector< size_t> > &MATCHING_VERTICES = storage::Vector< storage::Vector< size_t> >(), const bool &FIND_ALL = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>GetDefaultEdgeComparison()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>GetDefaultVertexComparison()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>GetGraphA() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>GetGraphB() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>GetSubgraphIsomorphismsOfGraphA() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>GetSubgraphIsomorphismsOfGraphB() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>GetVertexIsomorphisms() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>SetGraphA( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>SetGraphA( const util::OwnPtr< const ConstGraph< t_VertexData, t_EdgeData> > &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>SetGraphB( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>SetGraphB( const util::OwnPtr< const ConstGraph< t_VertexData, t_EdgeData> > &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>SetGraphs( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_A, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>SetIsomorphism( const storage::Map< size_t, size_t> &ISOMORPHISM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>SetIsomorphisms( const storage::Vector< storage::Map< size_t, size_t> > &ISOMORPHISMS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>CommonSubgraphIsomorphism</td>
        <td>operator =( const CommonSubgraphIsomorphism &PARENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>IntermediateSolution</td>
        <td>FindAllIsomorphisms( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_A, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_B, const size_t MAX_SIZE_OF_ISOMORPHISM, const size_t MIN_SIZE_OF_ISOMORPHISM, const storage::Vector< storage::Vector< size_t> > &MATCHING_VERTICES )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>IntermediateSolution</td>
        <td>FindIsomorphism( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_A, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_B, const size_t MAX_SIZE_OF_ISOMORPHISM, const size_t MIN_SIZE_OF_ISOMORPHISM, const storage::Vector< storage::Vector< size_t> > &MATCHING_VERTICES )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>IntermediateSolution</td>
        <td>IntermediateSolution( const SolutionType &SOLUTION_TYPE, const t_EdgeComparison &EDGE_COMPARER )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism.h</td>
        <td>IntermediateSolution</td>
        <td>IntermediateSolution()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism_base.h</td>
        <td>CommonSubgraphIsomorphismBase</td>
        <td>CommonSubgraphIsomorphismBase( const SolutionType &SOLUTION_TYPE = e_Connected)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism_base.h</td>
        <td>CommonSubgraphIsomorphismBase</td>
        <td>EstimateUpperBounds( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_A, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism_base.h</td>
        <td>CommonSubgraphIsomorphismBase</td>
        <td>GetIsomorphism() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism_base.h</td>
        <td>CommonSubgraphIsomorphismBase</td>
        <td>GetIsomorphisms() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism_base.h</td>
        <td>CommonSubgraphIsomorphismBase</td>
        <td>GetSolutionType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_common_subgraph_isomorphism_base.h</td>
        <td>CommonSubgraphIsomorphismBase</td>
        <td>SetIsomorphism( const storage::Map< size_t, size_t> &ISOMORPHISM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_common_subgraph_isomorphism_base.h</td>
        <td>CommonSubgraphIsomorphismBase</td>
        <td>SetIsomorphisms( const storage::Vector< storage::Map< size_t, size_t> > &ISOMORPHISMS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>BreadthFirstSearchDirectedEdge( const t_Graph &GRAPH, const size_t &VERTEX, const size_t &VERTEX_TO_IGNORE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>DirectedDistancesToOtherVertices( const t_Graph &GRAPH, const size_t &VERTEX, const size_t &VERTEX_TO_IGNORE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>DistancesToOtherVertices( const t_Graph &GRAPH, const size_t &VERTEX, const size_t &MAX_DISTANCE_OF_INTEREST = util::GetUndefinedSize_t() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>FindMinimalPath( const t_Graph &GRAPH, const size_t &VERTEX_A, const size_t &VERTEX_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetComponents( const t_Graph &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetComponentsAsNewGraphs( const t_Graph &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetVerticesReachableFrom( const t_Graph &GRAPH, const size_t &VERTEX )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>GetVerticesReachableFromDirectedEdge( const t_Graph &GRAPH, const size_t &VERTEX, const size_t &VERTEX_TO_IGNORE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>IsConnected( const t_Graph &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>IsInThreeMemberedCycle( const t_Graph &GRAPH, const size_t &VERTEX )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>LengthOfSmallestCycleWithEdge( const t_Graph &GRAPH, const size_t &VERTEX_A, const size_t &VERTEX_B, const storage::Vector< size_t> CAN_VISIT = storage::Vector< size_t>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_connectivity.h</td>
        <td>Connectivity</td>
        <td>LengthOfSmallestCycleWithVertex( const t_Graph &GRAPH, const size_t &VERTEX, const storage::Vector< size_t> CAN_VISIT = storage::Vector< size_t>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>AdjacencyMatrixIterator</td>
        <td>AdjacencyMatrixIterator( const t_EdgeTargetsOfVertex &TARGETS, const t_EdgeDataOfVertex &DATA, const t_EdgeData &UNCONNECTED )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>AdjacencyMatrixIterator</td>
        <td>GetData() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>AdjacencyMatrixIterator</td>
        <td>GetTarget() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>AdjacencyMatrixIterator</td>
        <td>operator ++()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>AddEdge( const size_t &FROM, const size_t &TO, const t_EdgeData &EDGE_DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>AreConnected( const size_t &VERTEX_INDEX_A, const size_t &VERTEX_INDEX_B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>AreVerticesConnected( const t_VertexData &VERTEX_DATA_A, const t_VertexData &VERTEX_DATA_B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>CacheAdjacencyMatrix() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>ChangeEdge( const size_t &FROM, const size_t &TO, const t_EdgeData &EDGE_DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>ConstGraph( const storage::Vector< t_VertexData> &VERTEX_DATA, const linal::Matrix< t_EdgeData> &EDGE_DATA, const t_EdgeData &UNCONNECTED_EDGE_VALUE = t_EdgeData(), const bool DIRECTED = false, const bool MAKE_UNDIRECTED = true )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>ConstGraph( const storage::Vector< t_VertexData> &VERTEX_DATA, const storage::Vector< UndirectedEdge< t_EdgeData> > &EDGE_DATA, const t_EdgeData &UNCONNECTED_EDGE_VALUE = t_EdgeData() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>ConstGraph()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>EditEdge( const size_t &FROM, const size_t &TO, const t_EdgeData &EDGE_DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>EditVertex( const size_t &VERTEX, const t_VertexData &VERTEX_DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetAdjacencyMatrixIterator( const size_t &VERTEX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetBasicConnectivity() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetEdgeData( const size_t &VERTEX_A, const size_t &VERTEX_B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetEdgeDataMatrix() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetEdgeTypeCountMap() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetEdges() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetNeighborData( const size_t &VERTEX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetNeighborIndices( const size_t &VERTEX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetSubgraph( const storage::Vector< size_t> &SUBGRAPH_INDICES) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetSubgraph( const storage::Vector< size_t> &SUBGRAPH_INDICES, util::SiPtr< storage::Vector< size_t> > STORE_MAPPING ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetUnconnectedEdgeData() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetVertexData( const size_t &VERTEX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetVertexTypeCountMap() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>GetVertices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>IsDirected() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>IsUndirected() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>MakeRandomUndirectedGraph( const size_t GRAPH_SIZE, const storage::Vector< double> &EDGE_COLOR_RATIOS, const storage::Vector< double> &VERTEX_COLOR_RATIOS, const size_t &DIAGONAL_COLOR = 0 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>NumEdges() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>ReadBasicConnectivity( std::istream &STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>RemoveAllEdges( const size_t &FROM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>RemoveEdge( const size_t &FROM, const size_t &TO)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>SetDirected()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>Shuffle()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_const_graph.h</td>
        <td>ConstGraph</td>
        <td>UncacheAdjacencyMatrix() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_csi_substructure.h</td>
        <td>CSISubstructure</td>
        <td>GetOverlap( const storage::Vector< t_Data> &VECTOR_A, const storage::Vector< t_Data> &VECTOR_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_csi_substructure.h</td>
        <td>CSISubstructure</td>
        <td>GetVertexDistanceCounts( const ConstGraph< t_VertexType, t_EdgeType> &GRAPH, const size_t &VERTEX )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_csi_substructure.h</td>
        <td>CSISubstructure</td>
        <td>GetVertexEnvironment( const ConstGraph< t_VertexType, t_EdgeType> &GRAPH, const size_t &VERTEX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_csi_substructure.h</td>
        <td>CSISubstructure</td>
        <td>GetVertexEnvironments( const ConstGraph< t_VertexType, t_EdgeType> &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_csi_substructure.h</td>
        <td>CSISubstructure</td>
        <td>GetVertexMatchingMatrixForSubgraph( const ConstGraph< t_VertexType, t_EdgeType> &SUBGRAPH, const ConstGraph< t_VertexType, t_EdgeType> &GRAPH )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_csi_substructure.h</td>
        <td>CSISubstructure</td>
        <td>GetVertexType( const ConstGraph< t_VertexType, t_EdgeType> &GRAPH, const size_t &VERTEX )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_csi_substructure.h</td>
        <td>CSISubstructure</td>
        <td>IsContainedIn( const storage::Map< t_Data, size_t> &SUBSET, const storage::Map< t_Data, size_t> &FULLSET )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_csi_substructure.h</td>
        <td>CSISubstructure</td>
        <td>IsContainedIn( const storage::Vector< t_Data> &SUBSET, const storage::Vector< t_Data> &FULLSET )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_csi_substructure.h</td>
        <td>CSISubstructure</td>
        <td>RefineMatchingVerticesForIsomorphism( const t_ArgType &GRAPH_A, const t_ArgType &GRAPH_B, const storage::VectorND< 2, storage::Vector< size_t> > &MATCHING_VERTEX_GROUP, storage::List< storage::VectorND< 2, storage::Vector< size_t> > > &MATCHING_VERTICES, t_KeyType ( *FUNCTION)( const t_ArgType &, const size_t &) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_edge_cover_ring_perception.h</td>
        <td>EdgeCoverRingPerception</td>
        <td>EdgeCoverRingPerception( const t_GraphType &GRAPH )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_edge_cover_ring_perception.h</td>
        <td>EdgeCoverRingPerception</td>
        <td>EdgeCoverRingPerception()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_edge_cover_ring_perception.h</td>
        <td>EdgeCoverRingPerception</td>
        <td>GetRings() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_edge_cover_ring_perception.h</td>
        <td></td>
        <td>BinarySearchDistance( const size_t &INTEGER, const size_t &SIZE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_edge_with_data.h</td>
        <td>EdgeWithData</td>
        <td>EdgeWithData( const util::ShPtr< VertexWithData< t_VertexDataType, t_EdgeDataType> > &SP_VERTEX, const t_EdgeDataType &EDGE_DATA )
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_edge_with_data.h</td>
        <td>EdgeWithData</td>
        <td>EdgeWithData()
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_edge_with_data.h</td>
        <td>EdgeWithData</td>
        <td>GetData() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_edge_with_data.h</td>
        <td>EdgeWithData</td>
        <td>GetTarget() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_edge_with_data.h</td>
        <td>EdgeWithData</td>
        <td>GetUndefined()
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_edge_with_data.h</td>
        <td>EdgeWithData</td>
        <td>IsDefined() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_edge_with_data.h</td>
        <td></td>
        <td>AddInstance( new EdgeWithData< t_VertexDataType, t_EdgeDataType>())
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_exhaustive_ring_perception.h</td>
        <td>ExhaustiveRingPerception</td>
        <td>ExhaustiveRingPerception( const ConstGraph< size_t, size_t> &GRAPH)
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_exhaustive_ring_perception.h</td>
        <td>ExhaustiveRingPerception</td>
        <td>ExhaustiveRingPerception( const GraphWithData< size_t, size_t> &GRAPH)
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_exhaustive_ring_perception.h</td>
        <td>ExhaustiveRingPerception</td>
        <td>ExhaustiveRingPerception()
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_exhaustive_ring_perception.h</td>
        <td>ExhaustiveRingPerception</td>
        <td>GetPaths() const
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_exhaustive_ring_perception.h</td>
        <td>ExhaustiveRingPerception</td>
        <td>GetRings() const
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>AddEdge( const t_VertexDataType &VERTEX_DATA_A, const t_VertexDataType &VERTEX_DATA_B, const t_EdgeDataType &EDGE_DATA )
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>AddVertex( const t_VertexDataType &VERTEX_DATA)
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>AddVertex( const util::ShPtr< VertexType> &SP_VERTEX)
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>AreVerticesConnected( const t_VertexDataType &VERTEX_DATA_A, const t_VertexDataType &VERTEX_DATA_B) const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>DeleteEdge( const t_VertexDataType &VERTEX_DATA_A, const t_VertexDataType &VERTEX_DATA_B)
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>DeleteUnconnectedVertices()
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>DeleteVertex( const util::ShPtr< VertexType> &VERTEX)
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>FindEdge( const VertexType &VERTEX_A, const VertexType &VERTEX_B ) const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>FindVertex( const t_VertexDataType &VERTEX_DATA) const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GetAllVertexData() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GetEdgeVertices() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GetNumberEdges() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GetNumberVertices() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GetNumberVerticesWithNEdges( const size_t NUMBER_OF_EDGES) const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GetVertices()
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GetVertices() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GetVerticesWithNEdges( const size_t NUMBER_OF_EDGES) const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GraphWithData( const VertexContainerType &VERTICES, const bool DIRECTED = false )
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>GraphWithData( const bool DIRECTED = false)
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>HardCopy() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>HasVertex( const VertexType &VERTEX) const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>HasVertex( const t_VertexDataType &VERTEX_DATA) const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>IsConnected() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_graph_with_data.h</td>
        <td>GraphWithData</td>
        <td>IsDirected() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_graph_with_data.h</td>
        <td></td>
        <td>AddInstance( new GraphWithData< t_VertexDataType, t_EdgeDataType>())
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Connects( const Path &PATH) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Contains( const size_t &VERTEX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>CountOverlappingVertices( const Path &PATH) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>CountVertexRepetitions() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Covers( const Path &PATH) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Crosses( const Path &PATH) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>EndsAt( const size_t &VERTEX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>EndsWith( const Path &PATH) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>EquivalentTour( const Path &PATH) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>FirstElement() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>GetVertices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Identical( const Path &PATH) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>IsDirected() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>IsUndirected() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>LastElement() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Path( const Path &PATH_A, const Path &PATH_B, const Path &OVERLAP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Path( const size_t &GRAPH_SIZE, const storage::Vector< size_t> &VERTICES, const bool &UNDIRECTED )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Path()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>Reverse()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>ReverseBegin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>ReverseEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_path.h</td>
        <td>Path</td>
        <td>StartsWith( const Path &PATH) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>CircularIterator( const storage::Vector< size_t> &RING, const size_t &INDEX, const bool &IS_FORWARD = true)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>CircularIterator( const storage::Vector< size_t> &RING, const storage::Vector< size_t>::const_iterator &ITR)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>CircularIterator()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>IsDefined() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>operator !=( const CircularIterator &ITERATOR) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>operator *() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>operator ++()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>operator --()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>operator ==( const CircularIterator &ITERATOR) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>CircularIterator</td>
        <td>operator ==( const const_iterator &ITERATOR) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>Begin() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>Contains( const size_t &VERTEX) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>End() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>Find( const Path &PATH) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>FirstElement() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>FuseRings( const Ring &RING_A, const Ring &RING_B)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>GetNominalFusionSize( const Ring &RING_A, const Ring &RING_B)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>GetOverlap( const Ring &RING) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>GetSize() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>GetVertices() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>Identical( const Ring &Ring) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>LastElement() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>Remove( const Path &PATH) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>ReverseBegin() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>ReverseEnd() const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>Ring( const size_t &GRAPH_SIZE, const storage::Vector< size_t> &VERTICES)
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>Ring()
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_ring.h</td>
        <td>Ring</td>
        <td>operator <( const Ring &RING) const
</td>
        <td>mendenjl, kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>GetAdjacentEdgeIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>GetComplement() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>GetEdgeIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>GetIdsOfInteriorVertices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>GetOrderedAdjacentEdgeIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>GetParentGraphPtr() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>GetUndirectedEdges() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>GetVertexIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>SetVertexIndices( const storage::Vector< size_t> &VERTICES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>Subgraph( const util::OwnPtr< ConstGraph< t_VertexData, t_EdgeData> > &GRAPH, const storage::Vector< size_t> &VERTEX_IDS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>Subgraph( const util::OwnPtr< const ConstGraph< t_VertexData, t_EdgeData> > &GRAPH, const storage::Vector< size_t> &VERTEX_IDS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>Subgraph()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>ToGraph() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph.h</td>
        <td>Subgraph</td>
        <td>operator ConstGraph< t_VertexData, t_EdgeData>() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>IntermediateSolution</td>
        <td>Find( const ConstGraph< t_VertexData, t_EdgeData> &SUBGRAPH, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH, const storage::Vector< storage::Vector< size_t> > &MATCHING_VERTICES )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>IntermediateSolution</td>
        <td>FindAll( const ConstGraph< t_VertexData, t_EdgeData> &SUBGRAPH, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH, const storage::Vector< storage::Vector< size_t> > &MATCHING_VERTICES )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>IntermediateSolution</td>
        <td>FindDisparate( const ConstGraph< t_VertexData, t_EdgeData> &SUBGRAPH, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH, const storage::Vector< storage::Vector< size_t> > &MATCHING_VERTICES, const size_t &MAX )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>IntermediateSolution</td>
        <td>IntermediateSolution()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>FindAllIsomorphisms()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>FindDisparateIsomorphisms()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>FindIsomorphism( const ConstGraph< t_VertexData, t_EdgeData> &SUBGRAPH, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>FindIsomorphism()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>GetGraph() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>GetSubgraph() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>GetSubgraphIsomorphisms() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>GetVertexIsomorphisms() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>SetGraph( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>SetGraphExternalOwnership( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>SetGraphs( const ConstGraph< t_VertexData, t_EdgeData> &SUBGRAPH, const ConstGraph< t_VertexData, t_EdgeData> &GRAPH )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>SetIsomorphisms( const storage::Vector< storage::Vector< size_t> > &ISOMORPHISMS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>SetSubgraph( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>SetSubgraphExternalOwnership( const ConstGraph< t_VertexData, t_EdgeData> &GRAPH)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>SubgraphIsomorphism( const SubgraphIsomorphism &PARENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>SubgraphIsomorphism()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism.h</td>
        <td>SubgraphIsomorphism</td>
        <td>operator =( const SubgraphIsomorphism &PARENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism_base.h</td>
        <td>SubgraphIsomorphismBase</td>
        <td>GetInverseIsomorphism() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism_base.h</td>
        <td>SubgraphIsomorphismBase</td>
        <td>GetIsomorphism() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism_base.h</td>
        <td>SubgraphIsomorphismBase</td>
        <td>GetIsomorphisms() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism_base.h</td>
        <td>SubgraphIsomorphismBase</td>
        <td>PruneIsomorphismsToThoseUniqueInField( const storage::Vector< size_t> &VERTICES_THAT_SHOULD_DIFFER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_subgraph_isomorphism_base.h</td>
        <td>SubgraphIsomorphismBase</td>
        <td>SetIsomorphism( const storage::Vector< size_t> &ISOMORPHISM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_subgraph_isomorphism_base.h</td>
        <td>SubgraphIsomorphismBase</td>
        <td>SetIsomorphisms( const storage::Vector< storage::Vector< size_t> > &ISOMORPHISMS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>AddChild( util::SiPtr< TreeNode< t_VertexData, t_EdgeData> > NODE, const t_EdgeData &EDGE_DATA)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>GetData()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>GetData() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>GetDepth() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>GetHeight() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>GetInternalChildrenInfo() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>GetLeaves() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>GetParent() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>GetSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>HasChild( const util::SiPtr< TreeNode< t_VertexData, t_EdgeData> > &NODE) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>HasParent( const util::SiPtr< TreeNode< t_VertexData, t_EdgeData> > &NODE) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>IsIsolated() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>IsLeaf() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>IsRoot() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>RemoveChild( util::SiPtr< TreeNode< t_VertexData, t_EdgeData> > NODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>RemoveParent()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>SetData( const t_VertexData &DATA)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>SetParent( const util::SiPtr< TreeNode< t_VertexData, t_EdgeData> > &NODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>TreeNode( const t_VertexData &DATA)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_tree_node.h</td>
        <td>TreeNode</td>
        <td>TreeNode()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_undirected_edge.h</td>
        <td>UndirectedEdge</td>
        <td>GetEdgeData() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_undirected_edge.h</td>
        <td>UndirectedEdge</td>
        <td>GetIndexHigh() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_undirected_edge.h</td>
        <td>UndirectedEdge</td>
        <td>GetIndexLow() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_undirected_edge.h</td>
        <td>UndirectedEdge</td>
        <td>UndirectedEdge( const size_t &INDEX_A, const size_t &INDEX_B, const t_EdgeData &EDGE_TYPE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_undirected_edge.h</td>
        <td>UndirectedEdge</td>
        <td>UndirectedEdge()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_undirected_edge.h</td>
        <td>UndirectedEdge</td>
        <td>operator <( const UndirectedEdge &EDGE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_undirected_edge.h</td>
        <td>UndirectedEdge</td>
        <td>operator ==( const UndirectedEdge &EDGE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>AddEdge( util::ShPtr< VertexWithData< t_VertexDataType, t_EdgeDataType> > &VERTEX, const t_EdgeDataType &EDGE_DATA )
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>DeleteEdge( const t_VertexDataType &VERTEX_DATA)
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>DeleteEdge( const util::ShPtr< VertexWithData< t_VertexDataType, t_EdgeDataType> > &VERTEX)
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>FindEdge( const VertexWithData< t_VertexDataType, t_EdgeDataType> &VERTEX) const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>FindEdge( const t_VertexDataType &VERTEX_DATA) const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>GetData() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>GetDegree() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>GetEdges()
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>GetEdges() const
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>VertexWithData( const t_VertexDataType &DATA)
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_graph_vertex_with_data.h</td>
        <td>VertexWithData</td>
        <td>VertexWithData()
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_graph_vertex_with_data.h</td>
        <td></td>
        <td>AddInstance( new VertexWithData< t_VertexDataType, t_EdgeDataType>())
</td>
        <td>selicd, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_gzip.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>Close()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>GetDefaultFileExtension() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>GetStreamBufferClass() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>IsOpen()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>IsValidOpenMode( const std::ios_base::openmode OPEN_MODE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>Open( const char *NAME, const std::ios_base::openmode OPEN_MODE )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>StreamBuffer( const StreamBuffer &BUFFER)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>StreamBuffer()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>overflow( int CHARACTER = EOF)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>seekoff( std::streamoff OFF, std::ios_base::seekdir WAY, std::ios_base::openmode WHICH = std::ios_base::in</td>
        <td>std::ios_base::out )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>sync()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_gzip_stream_buffer.cpp</td>
        <td>StreamBuffer</td>
        <td>underflow()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( bool &BOOLEAN, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( char &CHAR, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( double &DOUBLE, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( float &FLOAT, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( int &INT, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( long int &LONG_INT, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( long unsigned int &U_LONG_INT, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( short &SHORT, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( std::string &STRING, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( unsigned char &CHAR, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( unsigned int &U_INT, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Read( unsigned short &U_SHORT, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>ReadVector( linal::Vector< char> &BUFFER, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>ReadVector( linal::Vector< float> &BUFFER, std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const bool &BOOLEAN, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const char &CHAR, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const double &DOUBLE, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const float &FLOAT, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const int &INT, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const long &LONG, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const short &SHORT, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const std::string &STRING, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const unsigned char &CHAR, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const unsigned int &SIZE_T, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const unsigned long &SIZE_T, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_binary_serialize.h</td>
        <td>BinarySerialize</td>
        <td>Write( const unsigned short &SIZE_T, std::ostream &OSTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>AppendFilename( const std::string &NAME) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>CleanPath()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>Clear( const bool RECURSIVE = false)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>Directory( const std::string &PATH)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>Directory()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>DoesExist() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>GetPath() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>ListEntries( const EntryType &TYPE, const std::string &PREFIX = std::string(), const std::string &SUFFIX = std::string() ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>ListEntries() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>ListFiles( const std::string &PREFIX = std::string(), const std::string &SUFFIX = std::string(), const bool &RECURSIVE = false ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>Make()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>MkDir( const std::string &DIRECTORY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory.h</td>
        <td>Directory</td>
        <td>Remove( const bool RECURSIVE = false)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>DirectoryEntry( const std::string &NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>DirectoryEntry( const util::ShPtr< Directory> &SP_DIR, const std::string &NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>DirectoryEntry( const util::ShPtr< Directory> &SP_DIR, const std::string &NAME, const Directory::EntryType &TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>DirectoryEntry()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>DoesExist() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>GetDirectory() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>GetFullName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>GetName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>GetType() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>IsType( const Directory::EntryType &TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>Remove()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>Rename( const DirectoryEntry &NEW, const bool &ALLOW_OVERWRITE = false)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_directory_entry.h</td>
        <td>DirectoryEntry</td>
        <td>SetAttributes()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>BinaryFilesMatch( const std::string &FILE_NAME_A, const std::string &FILE_NAME_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>BinaryStreamsMatch( std::istream &STREAM_A, std::istream &STREAM_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>CheckCompressedAlternatives()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>CleanFilename( const std::string &FILENAME, const std::string &POSTFIX)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>ClearStream( std::ios &STREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>CloseClearFStream( t_Fstream &FSTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>ConvertClassIdentifierToFilename( const std::string &CLASS_IDENTIFIER)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>CountSlashes( const std::string &PATH)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>FilesMatch( const std::string &FILE_NAME_A, const std::string &FILE_NAME_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>FilesMatchWithinAbsoluteTolerance( const std::string &FILE_NAME_A, const std::string &FILE_NAME_B, const double &ABSOLUTE_TOLERANCE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>GetExtensionDelimiter()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>GetFlagCheckCompressedAlternatives()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>GetFullExtension( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>GetLastExtension( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>GetPostFixes()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>IsAbsolutePath( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>ListCompressedAlternatives( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>MakeAbsolutePath( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>MustOpenIFStream( t_Fstream &IFSTREAM, const std::string &FILENAME, const std::ios_base::openmode OPEN_MODE = std::ios::in )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>MustOpenOFStream( t_Fstream &OFSTREAM, const std::string &FILENAME, const std::ios_base::openmode OPEN_MODE = std::ios::out )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>ObjectsMatchWithinAbsoluteTolerance( const util::ObjectInterface &OBJECT_A, const util::ObjectInterface &OBJECT_B, const double &ABSOLUTE_TOLERANCE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>OpenFstream( t_Fstream &FSTREAM, const std::string &FILENAME, const std::ios_base::openmode OPEN_MODE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>RemoveAfterFirstOfAnyPostfix( const std::string &FILENAME, const std::string &POSTFIX)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>RemoveCommonComponents( const std::string &QUERY, const std::string &TEMPLATE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>RemoveCompressionExtension( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>RemoveFullExtension( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>RemoveLastExtension( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>RemovePath( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>Size( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>SplitToPathAndFileName( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>StreamsMatch( std::istream &STREAM_A, std::istream &STREAM_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>StreamsMatchWithinAbsoluteTolerance( std::istream &STREAM_A, std::istream &STREAM_B, const double &ABSOLUTE_TOLERANCE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>TryOpenFstream( t_Fstream &FSTREAM, const std::string &FILENAME, const std::ios_base::openmode OPEN_MODE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>TryOpenIFStream( t_Fstream &IFSTREAM, const std::string &FILENAME, const std::ios_base::openmode OPEN_MODE = std::ios::in )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>TryOpenOFStream( t_Fstream &OFSTREAM, const std::string &FILENAME, const std::ios_base::openmode OPEN_MODE = std::ios::out )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file.h</td>
        <td>File</td>
        <td>TryOpenStreamBuf( t_StreamBufType &STREAM_BUF, const std::string &FILENAME, const std::ios_base::openmode OPEN_MODE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer.h</td>
        <td>FileStreamBuffer</td>
        <td>Close()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file_stream_buffer.h</td>
        <td>FileStreamBuffer</td>
        <td>FileStreamBuffer( const FileStreamBuffer &BUFFER)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer.h</td>
        <td>FileStreamBuffer</td>
        <td>FileStreamBuffer()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file_stream_buffer.h</td>
        <td>FileStreamBuffer</td>
        <td>GetDefaultFileExtension() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer.h</td>
        <td>FileStreamBuffer</td>
        <td>GetStreamBufferClass() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file_stream_buffer.h</td>
        <td>FileStreamBuffer</td>
        <td>IsOpen()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer.h</td>
        <td>FileStreamBuffer</td>
        <td>IsValidOpenMode( const std::ios_base::openmode OPEN_MODE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file_stream_buffer.h</td>
        <td>FileStreamBuffer</td>
        <td>Open( const char *NAME, const std::ios_base::openmode OPEN_MODE )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>Close()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>FileStreamBufferEncrypted( const FileStreamBufferEncrypted &BUFFER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>FileStreamBufferEncrypted()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>GetDefaultFileExtension() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>GetStreamBufferClass() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>IsOpen()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>IsValidOpenMode( const std::ios_base::openmode OPEN_MODE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>Open( const char *NAME, const std::ios_base::openmode OPEN_MODE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>overflow( traits_type::int_type c)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>uflow()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_file_stream_buffer_encrypted.cpp</td>
        <td>FileStreamBufferEncrypted</td>
        <td>underflow()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>AddIndent( const size_t &INDENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>ClearIndent( const size_t &INDENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>Endl()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>FixedLineWidthWriter( const size_t &AUTO_INDENT_EXTRA, const size_t &DESIRED_LINE_WIDTH )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>FixedLineWidthWriter()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>GetEffectiveLineWidth()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>GetExtraIndent() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>GetIndent() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>GetLinePosition()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>GetRemainingSpaceOnLine()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>NewLine()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>NewLineIndent()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>PopIndent()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>SetAutoIndentExtra( const size_t &AUTO_INDENT_EXTRA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>SetBclIndent( const size_t &INDENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>SetIndent( const size_t &INDENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>String()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>WriteHeading( const std::string &HEADING, const char &FILLER, const bool &BORDER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>WriteOnOneLine( const std::string &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>operator <<( const char &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>operator <<( const std::string &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_fixed_line_width_writer.h</td>
        <td>FixedLineWidthWriter</td>
        <td>operator <<( const t_DataType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_ifstream.h</td>
        <td>IFStream</td>
        <td>IFStream( const char *name, const std::ios_base::openmode open_mode = std::ios::in)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_ifstream.h</td>
        <td>IFStream</td>
        <td>IFStream()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_ifstream.h</td>
        <td>IFStream</td>
        <td>open( const char *name, const std::ios::openmode open_mode = std::ios::in)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_ifstream.h</td>
        <td>IFStream</td>
        <td>rdbuf() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_ofstream.h</td>
        <td>OFStream</td>
        <td>OFStream( const char *name, const std::ios_base::openmode open_mode = std::ios::out)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_ofstream.h</td>
        <td>OFStream</td>
        <td>OFStream()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_ofstream.h</td>
        <td>OFStream</td>
        <td>open( const char *name, const std::ios::openmode open_mode = std::ios::out)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_ofstream.h</td>
        <td>OFStream</td>
        <td>rdbuf() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgent( const SerializationInterface *OBJECT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgent( const std::string *VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgent( const t_DataType *CONTAINER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgent( const t_DataType *VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgent( const util::ObjectDataLabel *VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentContainerWithCheck( const t_DataType *CONTAINER, const util::OwnPtr< t_OtherType> &CHECK, const size_t &MIN_SIZE = size_t( 1), const size_t &MAX_SIZE = std::numeric_limits< size_t>::max() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentInputFilename( const std::string *VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentWithCheck( const t_DataType *VALUE, const command::ParameterCheckInterface &CHECK)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentWithMax( const t_DataType &MAX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentWithMax( const t_DataType *VALUE, const t_OtherDataType &MAX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentWithMin( const t_DataType &MIN)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentWithMin( const t_DataType *VALUE, const t_OtherDataType &MIN)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentWithRange( const t_DataType &MIN, const t_DataType &MAX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentWithRange( const t_DataType *VALUE, const t_OtherDataType &MIN, const t_OtherDataType &MAX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization.h</td>
        <td>Serialization</td>
        <td>GetAgentWithSizeLimits( const t_DataType *CONTAINER, const size_t &MIN_SIZE, const size_t &MAX_SIZE = std::numeric_limits< size_t>::max() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_base.h</td>
        <td>SerializationBase</td>
        <td>GetLabel( const bool &WITH_DATA = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_base.h</td>
        <td>SerializationBase</td>
        <td>InsertDataTypes( storage::Map< std::string, size_t> &TYPES, const bool &INCLUDE_OPTIONAL = true, const bool &INCLUDE_DATA = false, const size_t &MAX_DEPTH = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_base.h</td>
        <td>SerializationBase</td>
        <td>InsertDataTypesForObject( const t_DataType &OBJECT, storage::Map< std::string, size_t> &TYPES, const bool &INCLUDE_OPTIONAL, const bool &INCLUDE_DATA, const size_t &MAX_DEPTH ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_base.h</td>
        <td>SerializationBase</td>
        <td>SerializationBase( const t_DataType *DATA = NULL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_base.h</td>
        <td>SerializationBase</td>
        <td>TryRead( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_builtin.h</td>
        <td>SerializationBuiltin</td>
        <td>GetLabelForObject( const t_DataType &OBJECT, const bool &WITH_DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_builtin.h</td>
        <td>SerializationBuiltin</td>
        <td>GetSerializedType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_builtin.h</td>
        <td>SerializationBuiltin</td>
        <td>SerializationBuiltin( const t_DataType *DATA = NULL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_builtin.h</td>
        <td>SerializationBuiltin</td>
        <td>TryReadObject( t_DataType &OBJECT, const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_builtin.h</td>
        <td>SerializationBuiltin</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_container.h</td>
        <td>SerializationContainer</td>
        <td>GetLabelForObject( const t_ContainerType &OBJ, const bool &WITH_DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_container.h</td>
        <td>SerializationContainer</td>
        <td>GetSerializedType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_container.h</td>
        <td>SerializationContainer</td>
        <td>InsertDataTypesForObject( const t_ContainerType &OBJECT, storage::Map< std::string, size_t> &TYPES, const bool &INCLUDE_OPTIONAL, const bool &INCLUDE_DATA, const size_t &MAX_DEPTH ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_container.h</td>
        <td>SerializationContainer</td>
        <td>SerializationContainer( const SerializationBase< t_TypeContained> &MEMBER_SETTER, const t_ContainerType *CONTAINER = NULL, const size_t &MIN_SIZE = size_t( 1), const size_t &MAX_SIZE = std::numeric_limits< size_t>::max() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_container.h</td>
        <td>SerializationContainer</td>
        <td>SerializationContainer()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_container.h</td>
        <td>SerializationContainer</td>
        <td>TryReadObject( t_ContainerType &OBJECT, const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_container.h</td>
        <td>SerializationContainer</td>
        <td>WriteDescription( std::ostream &OSTREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_container.h</td>
        <td>SerializationContainer</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_interface.h</td>
        <td>SerializationInterface</td>
        <td>GetSerializationAddresses() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_interface.h</td>
        <td>SerializationInterface</td>
        <td>GetSerializedType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_interface.h</td>
        <td>SerializationInterface</td>
        <td>InsertDataTypes( storage::Map< std::string, size_t> &TYPES, const bool &INCLUDE_OPTIONAL = true, const bool &INCLUDE_DATA = false, const size_t &MAX_DEPTH = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_interface.h</td>
        <td>SerializationInterface</td>
        <td>ValidateRead( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_map.h</td>
        <td>SerializationMap</td>
        <td>GetLabelForObject( const t_ContainerType &OBJ, const bool &WITH_DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_map.h</td>
        <td>SerializationMap</td>
        <td>GetSerializedType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_map.h</td>
        <td>SerializationMap</td>
        <td>InsertDataTypesForObject( const t_ContainerType &OBJECT, storage::Map< std::string, size_t> &TYPES, const bool &INCLUDE_OPTIONAL, const bool &INCLUDE_DATA, const size_t &MAX_DEPTH ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_map.h</td>
        <td>SerializationMap</td>
        <td>SerializationMap( const SerializationBase< key_type> &KEY_SETTER, const SerializationBase< mapped_type> &MAPPED_TYPE_SETTER, const t_ContainerType *CONTAINER = NULL, const size_t &MIN_SIZE = size_t( 1), const size_t &MAX_SIZE = std::numeric_limits< size_t>::max() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_map.h</td>
        <td>SerializationMap</td>
        <td>TryReadObject( t_ContainerType &OBJECT, const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_map.h</td>
        <td>SerializationMap</td>
        <td>WriteDescription( std::ostream &OSTREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_map.h</td>
        <td>SerializationMap</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_via_static_functions.h</td>
        <td>SerializationViaStaticFunctions</td>
        <td>GetLabelForObject( const t_DataType &OBJECT, const bool &WITH_DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_via_static_functions.h</td>
        <td>SerializationViaStaticFunctions</td>
        <td>SerializationViaStaticFunctions( const command::ParameterCheckInterface &PARAMETER_CHECK, std::string ( *GETTER)( const t_DataType &), bool ( *SETTER)( t_DataType &, const std::string &, std::ostream &), const t_DataType *DATA = NULL )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_via_static_functions.h</td>
        <td>SerializationViaStaticFunctions</td>
        <td>SerializationViaStaticFunctions( std::string ( GETTER) const t_DataType &), bool ( *SETTER)( t_DataType &, const std::string &, std::ostream &), const t_DataType *DATA = NULL )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_via_static_functions.h</td>
        <td>SerializationViaStaticFunctions</td>
        <td>SerializationViaStaticFunctions()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_via_static_functions.h</td>
        <td>SerializationViaStaticFunctions</td>
        <td>TryReadObject( t_DataType &OBJECT, const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_via_static_functions.h</td>
        <td>SerializationViaStaticFunctions</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_with_check.h</td>
        <td>SerializationWithCheck</td>
        <td>SerializationWithCheck( const command::ParameterCheckInterface &PARAMETER_CHECK, const t_DataType *DATA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_with_check.h</td>
        <td>SerializationWithCheck</td>
        <td>TryReadObject( t_DataType &OBJECT, const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_with_check.h</td>
        <td>SerializationWithCheck</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_with_min_max.h</td>
        <td>SerializationWithMinMax</td>
        <td>SerializationWithMinMax( const t_DataType &MIN, const t_DataType &MAX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_with_min_max.h</td>
        <td>SerializationWithMinMax</td>
        <td>SerializationWithMinMax( const t_DataType *DATA, const t_DataType &MIN, const t_DataType &MAX )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_with_min_max.h</td>
        <td>SerializationWithMinMax</td>
        <td>TryReadObject( t_DataType &OBJECT, const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_with_min_max.h</td>
        <td>SerializationWithMinMax</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_wrapper.h</td>
        <td>SerializationWrapper</td>
        <td>GetLabelForObject( const t_DataType &OBJECT, const bool &WITH_DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_wrapper.h</td>
        <td>SerializationWrapper</td>
        <td>GetSerializedType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_wrapper.h</td>
        <td>SerializationWrapper</td>
        <td>InsertDataTypesForObject( const t_DataType &OBJECT, storage::Map< std::string, size_t> &TYPES, const bool &INCLUDE_OPTIONAL, const bool &INCLUDE_DATA, const size_t &MAX_DEPTH ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialization_wrapper.h</td>
        <td>SerializationWrapper</td>
        <td>TryReadObject( t_DataType &OBJECT, const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialization_wrapper.h</td>
        <td>SerializationWrapper</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>InsertIndent( std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( bool &BOOLEAN, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( char &CHAR, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( const t_DataType &DATA, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( double &DOUBLE, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( float &FLOAT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( int &INT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( long int &LONG_INT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( long long int &LONG_LONG_INT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( long long unsigned int &U_LONG_LONG_INT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( long unsigned int &U_LONG_INT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( short &SHORT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( std::pair< t_First, t_Second> &PAIR, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( std::string &STRING, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( t_DataType &DATA, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( unsigned char &CHAR, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( unsigned int &U_INT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( unsigned short &U_SHORT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( util::ObjectInterface &OBJECT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Read( util::SerializableInterface &OBJECT, std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const bool &BOOLEAN, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const char &CHAR, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const double &DOUBLE, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const float &FLOAT, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const int &INT, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const long &LONG, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const long long int &LONG, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const long long unsigned int &LONG, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const short &SHORT, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const std::pair< t_First, t_Second> &PAIR, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const std::string &STRING, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const t_DataType &DATA, std::ostream &OSTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const t_DataType &DATA, std::ostream &OSTREAM, const size_t INDENT, const util::Format &FORMAT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const unsigned char &CHAR, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const unsigned int &SIZE_T, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const unsigned long &SIZE_T, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const unsigned short &SIZE_T, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const util::ObjectInterface &OBJECT, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const util::SerializableInterface &OBJECT, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>Write( const util::Wrapper< std::string> &WRAPPER_STRING, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>WriteObject( const util::ObjectInterface &OBJECT, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serialize.h</td>
        <td>Serialize</td>
        <td>WriteSerializable( const util::SerializableInterface &OBJECT, std::ostream &OSTREAM, const size_t INDENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>Finalize( const std::string &NAME, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>GetDefault() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>GetDescription() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>GetHandler() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>GetHandlerPtr() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>GetLabel( const bool &DETAIL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>GetState() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>GetType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>MemberInfo( const util::OwnPtr< SerializationInterface> &HANDLER = util::OwnPtr< SerializationInterface>(), const Type &TYPE = e_Initializer, const std::string &DESCRIPTION = std::string() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>Set( const std::string &NAME, const util::ObjectDataLabel &TREE, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>SetAsOptional()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>SetDefault( const std::string &DEFAULT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>MemberInfo</td>
        <td>WriteHelp( FixedLineWidthWriter &OSTREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>AddDataMember( const std::string &NAME, const util::OwnPtr< SerializationInterface> &DATA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>AddDataMember( const std::string &NAME, const util::OwnPtr< SerializationInterface> &DATA, const std::string &DEFAULT )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>AddInitializer( const std::string &NAME, const std::string &DESCRIPTION, const util::OwnPtr< SerializationInterface> &INIT )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>AddInitializer( const std::string &NAME, const std::string &DESCRIPTION, const util::OwnPtr< SerializationInterface> &INIT, const std::string &DEFAULT )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>AddOptionalInitializer( const std::string &NAME, const std::string &DESCRIPTION, const util::OwnPtr< SerializationInterface> &INIT )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>GetClassDescription()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>GetCommandLineIdentifier() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>GetKeys( const std::map< std::string, Serializer::MemberInfo> &MAP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>GetLabel( const bool &WITH_DATA = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>GetSerializationAddresses() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>GetType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>GetWasDataRead() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>InsertDataTypes( storage::Map< std::string, size_t> &TYPES, const bool &INCLUDE_OPTIONAL = true, const bool &INCLUDE_DATA = false, const size_t &MAX_DEPTH = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>IsFinalized() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>Merge( const Serializer &SERIALIZER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>ReadArguments( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>Serializer( const Serializer &SERIALIZER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>Serializer()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>SetClassDescription( const std::string &DESCRIPTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>SetCommandLineIdentifier( const std::string &ID)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>SetDefault( const std::string &NAME, const std::string &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>SetTypeAndFinalize( const util::DataType::Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>WriteBriefHelp( FixedLineWidthWriter &OSTREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>WriteHelp( FixedLineWidthWriter &OSTREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_serializer.h</td>
        <td>Serializer</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t &INDENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_stream_buffer_classes.h</td>
        <td>StreamBufferClasses</td>
        <td>GetCompressionFromCommandLine() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_stream_buffer_classes.h</td>
        <td>StreamBufferClasses</td>
        <td>GetCompressionFromExtension( const std::string &FILE_EXTENSION) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_stream_buffer_classes.h</td>
        <td>StreamBufferClasses</td>
        <td>GetFlagFileCompression() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_stream_buffer_classes.h</td>
        <td>StreamBufferClasses</td>
        <td>Open( const char *NAME, const std::ios_base::openmode OPEN_MODE ) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_stream_buffer_classes.h</td>
        <td></td>
        <td>GetStreamBufferClasses()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_stream_buffer_interface.h</td>
        <td>StreamBufferInterface</td>
        <td>AddExtension( const std::string &FILENAME) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_stream_interface.h</td>
        <td>StreamInterface</td>
        <td>GetCompression() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_stream_interface.h</td>
        <td>StreamInterface</td>
        <td>StreamInterface( const char *name, const std::ios_base::openmode MODE)
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_stream_interface.h</td>
        <td>StreamInterface</td>
        <td>StreamInterface()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_stream_interface.h</td>
        <td>StreamInterface</td>
        <td>close()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_stream_interface.h</td>
        <td>StreamInterface</td>
        <td>is_open()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_stream_interface.h</td>
        <td>StreamInterface</td>
        <td>open( const char *NAME, const std::ios_base::openmode OPEN_MODE )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_stream_interface.h</td>
        <td>StreamInterface</td>
        <td>rdbuf() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>GetHelpString()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>IsAllowed() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>IsComplete() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>IsHelp() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>IsInvalid() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>ValidationResult( const ValidationResultType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>ValidationResult( const bool &VALID)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>operator !=( const ValidationResult &RESULT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>operator ==( const ValidationResult &RESULT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_io_validation_result.h</td>
        <td>ValidationResult</td>
        <td>operator bool() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>AssertNotAtEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>AtBegin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>CloneIterator() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>CountElementsThatSatisfy( t_Condition CONDITION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>Generic( Interface< t_Return> *const ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>Generic( const Generic &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>Generic( const t_OtherIteratorType &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>Generic( t_Iterator BEGIN, t_Iterator END)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>Generic( t_Iterator BEGIN, t_Iterator END, t_Iterator ITR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>Generic()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>GetPosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>GetReversePosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>GotoBegin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>GotoEnd()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>GotoNextElementThatSatisfies( t_Condition CONDITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>GotoPosition( const size_t &POSITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>GotoPrevElementThatSatisfies( t_Condition CONDITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>GotoRandomPosition()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>InsertElementsFromIteratorInto( t_Container CONTAINER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>InsertElementsThatSatisfyConditionInto( t_Condition CONDITION, t_Container &CONTAINER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>NotAtEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>RandomlyPickElementThatSatisfies( t_Condition CONDITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>Restart()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>operator !=( t_OtherIterator const &ITR) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>operator *() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>operator ++()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>operator --()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>operator ->() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>operator =( const Generic< t_Return> &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_generic.h</td>
        <td>Generic</td>
        <td>operator ==( t_OtherIterator const &ITR) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>AssertNotAtEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>CountElementsThatSatisfy( t_Condition CONDITION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>GotoNextElementThatSatisfies( t_Condition CONDITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>GotoPrevElementThatSatisfies( t_Condition CONDITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>GotoRandomPosition()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>InsertElementsFromIteratorInto( t_Container CONTAINER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>InsertElementsThatSatisfyConditionInto( t_Condition CONDITION, t_Container &CONTAINER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>RandomlyPickElementThatSatisfies( t_Condition CONDITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>operator !=( t_OtherIterator const &ITR) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_interface.h</td>
        <td>Interface</td>
        <td>operator ==( t_OtherIterator const &ITR) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>AssertNotAtEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>AtBegin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>CloneIterator() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>CountElementsThatSatisfy( t_Condition CONDITION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>GetPosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>GetReversePosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>GotoBegin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>GotoEnd()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>GotoNextElementThatSatisfies( t_Condition CONDITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>GotoPosition( const size_t &POSITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>GotoPrevElementThatSatisfies( t_Condition CONDITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>GotoRandomPosition()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>InsertElementsFromIteratorInto( t_Container CONTAINER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>NotAtEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>RandomlyPickElementThatSatisfies( t_Condition CONDITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>Reflecting( Interface< t_Return> *const ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>Reflecting( const Interface< t_Return> &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>Reflecting( const Reflecting &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>Reflecting( const t_OtherIteratorType &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>Reflecting( t_Iterator BEGIN, t_Iterator END)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>Reflecting( t_Iterator BEGIN, t_Iterator END, t_Iterator ITR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>Reflecting()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>Restart()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>operator !=( t_OtherIterator const &ITR) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>operator *() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>operator ++()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>operator --()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>operator ->() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>operator =( const Reflecting< t_Return> &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_reflecting.h</td>
        <td>Reflecting</td>
        <td>operator ==( t_OtherIterator const &ITR) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>AtBegin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>CloneIterator() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>GetBegin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>GetEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>GetNativeIterator() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>GetPosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>GetReversePosition() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>GotoBegin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>GotoEnd()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>GotoPosition( const size_t &POSITION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>NotAtEnd() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>Restart()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>SetRange( const t_Iterator &BEGIN, const t_Iterator &END)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>WithRange( t_Iterator const &BEGIN, t_Iterator const &END)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>WithRange( t_Iterator const &BEGIN, t_Iterator const &END, t_Iterator const &ITR )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>operator *() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>operator ++( int)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>operator ++()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>operator --( int)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>operator --()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>operator ->() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>operator =( const WithRange &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>operator =( const t_Iterator &ITR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_iterate_with_range.h</td>
        <td>WithRange</td>
        <td>operator t_Iterator const &() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_distance_geometry.h</td>
        <td>DistanceGeometry</td>
        <td>DistanceGeometry()
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_distance_geometry.h</td>
        <td>DistanceGeometry</td>
        <td>operator ()( const storage::SymmetricMatrix< double> &SYMMETRIC_MATRIX ) const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>AddNRows( const size_t &N_ROWS, const t_DataType &FILL_VALUE = t_DataType( 0))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Append( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Append( const storage::Vector< Matrix< t_DataType> > &MATRICES)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Begin()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Begin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>CreatePaddedMatrix( const size_t ROW_PADDING, const size_t COL_PADDING, const t_DataType &FILL_VALUE = t_DataType( 0) ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>CreateSubMatrix( const size_t NUMBER_ROWS, const size_t NUMBER_COLS, const size_t POS_ROW = 0, const size_t POS_COL = 0 ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>End()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>End() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>GetNumberCols() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>GetNumberOfElements() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>GetNumberRows() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>KeepRows( const storage::Vector< size_t> &ROWS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( Matrix< t_DataType> && MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const Matrix< t_DataType> &MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const MatrixConstInterface< t_DataType> &MATRIX_INTERFACE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const MatrixConstInterface< t_DataType> &MATRIX_INTERFACE, const size_t ROW_PADDING, const size_t COL_PADDING, const t_DataType &FILL_VALUE = t_DataType( 0) )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const MatrixConstInterface< t_OtherDataType> &MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const size_t &ROWS, const size_t &COLS, const storage::Vector< t_DataType> &STORAGEVECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const size_t NUMBER_ROWS, const size_t NUMBER_COLS, const t_DataType &FILL_VALUE = t_DataType( 0) )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const size_t NUMBER_ROWS, const size_t NUMBER_COLS, const t_DataType *DATA )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>RemoveCols( const storage::Vector< size_t> &COLS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>RemoveRows( const storage::Vector< size_t> &ROWS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>ReorderRows( const storage::Vector< size_t> &ROWS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>SetIdentity()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>SetSubMatrix( const MatrixConstInterface< t_DataType> &MATRIX_INTERFACE, const size_t POS_ROW = 0, const size_t POS_COL = 0 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>SetZero()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>ShrinkRows( const size_t NUMBER_ROWS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>Transpose()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>operator ()( const size_t ROW, const size_t COL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>operator ()( const size_t ROW, const size_t COL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>operator =( Matrix< t_DataType> && MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>operator =( const Matrix< t_DataType> &MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>operator =( const MatrixConstInterface< t_DataType> &MATRIX_INTERFACE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>operator =( const t_DataType &VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>operator []( const size_t ROW)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix.h</td>
        <td>Matrix</td>
        <td>operator []( const size_t ROW) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix.h</td>
        <td></td>
        <td>IdentityMatrix( const size_t &SIZE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Begin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Determinant() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>EigenValues() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>End()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>GetNumberCols() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>GetNumberOfElements() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>GetNumberRows() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>IsDiagonal() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>IsSquare() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>IsSymmetric() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>IsTriDiagonal() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Matrix2x2( const Matrix2x2< t_DataType> &MATRIX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Matrix2x2( const MatrixConstInterface< t_DataType> &MATRIX_INTERFACE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Matrix2x2( const t_DataType &FILL_VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Matrix2x2( const t_DataType *DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Matrix2x2()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>ReplaceRow( const size_t ROW, const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>SortRowsAndVector( VectorInterface< t_DataType> &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>SwapRows( const size_t ROW_A, const size_t ROW_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Trace() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>Transpose()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator ()( const size_t ROW, const size_t COL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator ()( const size_t ROW, const size_t COL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator *( const Matrix2x2< t_DataType> &MATRIX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator *=( const Matrix2x2< t_DataType> &MATRIX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator -( const Matrix2x2< t_DataType> &MATRIX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator -=( const Matrix2x2< t_DataType> &MATRIX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator =( const Matrix2x2< t_DataType> &MATRIX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator =( const MatrixConstInterface< t_DataType> &MATRIX_INTERFACE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator =( const t_DataType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator []( const size_t ROW)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix2x2.h</td>
        <td>Matrix2x2</td>
        <td>operator []( const size_t ROW) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Begin()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Begin() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>ComputeEulerAngles( const Matrix3x3< t_DataType> &FRAME_1, const Matrix3x3< t_DataType> &FRAME_2 )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>ComputeEulerAnglesXYZ( const Matrix3x3< double> &FRAME_1, const Matrix3x3< double> &FRAME_2 )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Determinant() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>EigenValues() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>EigenVectorsSymmetric( Matrix3x3< t_DataType> &EIGEN_VECTORS, Vector< t_DataType> &EIGEN_VALUES) const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>EigenVectorsSymmetricQL( Matrix3x3< t_DataType> &EIGEN_VECTORS, Vector< t_DataType> &EIGEN_VALUES) const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>End()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>End() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>GetNumberCols() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>GetNumberOfElements() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>GetNumberRows() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>IsDefined() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>IsDiagonal() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>IsSquare() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>IsSymmetric() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>IsTriDiagonal() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Matrix3x3( const Matrix3x3< t_DataType> &MATRIX)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Matrix3x3( const MatrixConstInterface< t_DataType> &MATRIX_INTERFACE)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Matrix3x3( const t_DataType &FILL_VALUE)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Matrix3x3( const t_DataType *DATA)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Matrix3x3()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>ReplaceRow( const size_t ROW, const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>SortRowsAndVector( VectorInterface< t_DataType> &VECTOR)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>SwapRows( const size_t ROW_A, const size_t ROW_B)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Trace() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Transpose()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator ()( const size_t ROW, const size_t COL)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator ()( const size_t ROW, const size_t COL) const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator *( const Matrix3x3< t_DataType> &MATRIX) const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator *=( const Matrix3x3< t_DataType> &MATRIX)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator -( const Matrix3x3< t_DataType> &MATRIX) const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator -=( const Matrix3x3< t_DataType> &MATRIX)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator =( const Matrix3x3< t_DataType> &MATRIX)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator =( const MatrixConstInterface< t_DataType> &MATRIX_INTERFACE)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator =( const t_DataType &VALUE)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator []( const size_t ROW)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator []( const size_t ROW) const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>AsVector() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>GetCol( const size_t &COL) const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>GetDiagonal() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>GetRow( const size_t &ROW) const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>Inverse() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>IsDefined() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>IsDiagonal() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>IsEmpty() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>IsSquare() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>IsSymmetric() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>IsTriDiagonal() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>Solve( const VectorConstInterface< FloatType> &B) const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>Sum() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>Trace() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>Transposed() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>operator !=( const MatrixConstInterface< t_DataType> &MATRIX_RHS) const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_interface.h</td>
        <td>MatrixConstInterface</td>
        <td>operator ==( const MatrixConstInterface< t_DataType> &MATRIX_RHS) const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>Begin() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>End() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>GetNumberCols() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>GetNumberOfElements() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>GetNumberRows() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>MatrixConstReference( const MatrixConstInterface< t_DataType> &MATRIX_INTERFACE)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>MatrixConstReference( const size_t NUMBER_ROWS, const size_t NUMBER_COLS, const t_DataType *DATA )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>MatrixConstReference()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>Reference( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>operator ()( const size_t ROW, const size_t COL) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_const_reference.h</td>
        <td>MatrixConstReference</td>
        <td>operator []( const size_t ROW) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>AsVector()
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>AsVector() const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>GetRow( const size_t &ROW)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>GetRow( const size_t &ROW) const
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>ReplaceCol( const size_t COL, const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>ReplaceRow( const size_t ROW, const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>SetCol( const size_t COL, const t_DataType &VALUE)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>SwapCols( const size_t COL_A, const size_t COL_B)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>SwapRows( const size_t ROW_A, const size_t ROW_B)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>Transpose()
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_interface.h</td>
        <td>MatrixInterface</td>
        <td>operator =( const t_DataType &SCALAR)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_cholesky.h</td>
        <td>MatrixInversionCholesky</td>
        <td>ComputeInverse()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_cholesky.h</td>
        <td>MatrixInversionCholesky</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_cholesky.h</td>
        <td>MatrixInversionCholesky</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_cholesky.h</td>
        <td>MatrixInversionCholesky</td>
        <td>MatrixInversionCholesky( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_cholesky.h</td>
        <td>MatrixInversionCholesky</td>
        <td>MatrixInversionCholesky( const t_DataType &SMOOTHING = 0.000)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_cholesky.h</td>
        <td>MatrixInversionCholesky</td>
        <td>SetMatrix( const MatrixConstInterface< t_DataType> &A)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_cholesky.h</td>
        <td>MatrixInversionCholesky</td>
        <td>Solve( const VectorConstInterface< t_DataType> &B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_gauss_jordan.h</td>
        <td>MatrixInversionGaussJordan</td>
        <td>ComputeInverse()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_gauss_jordan.h</td>
        <td>MatrixInversionGaussJordan</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_gauss_jordan.h</td>
        <td>MatrixInversionGaussJordan</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_gauss_jordan.h</td>
        <td>MatrixInversionGaussJordan</td>
        <td>MatrixInversionGaussJordan( const MatrixConstInterface< t_DataType> &MATRIX, const bool &PARTIAL_PIVOTING = true)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_gauss_jordan.h</td>
        <td>MatrixInversionGaussJordan</td>
        <td>MatrixInversionGaussJordan( const bool &PARTIAL_PIVOTING)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_gauss_jordan.h</td>
        <td>MatrixInversionGaussJordan</td>
        <td>SetMatrix( const MatrixConstInterface< t_DataType> &A)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_gauss_jordan.h</td>
        <td>MatrixInversionGaussJordan</td>
        <td>Solve( const VectorConstInterface< t_DataType> &B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_interface.h</td>
        <td>MatrixInversionInterface</td>
        <td>SolveDiagonalMatrix( const MatrixConstInterface< t_DataType> &A, const VectorConstInterface< t_DataType> &B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_interface.h</td>
        <td>MatrixInversionInterface</td>
        <td>SolveTridiagonalMatrix( const MatrixConstInterface< t_DataType> &A, const VectorConstInterface< t_DataType> &B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_interface.h</td>
        <td>MatrixInversionInterface</td>
        <td>TryInvertDiagonalMatrix( MatrixInterface< t_DataType> &INVERSE_STORAGE, const MatrixConstInterface< t_DataType> &MATRIX )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_interface.h</td>
        <td>MatrixInversionInterface</td>
        <td>TryInvertTridiagonalMatrix( MatrixInterface< t_DataType> &INVERSE_STORAGE, const MatrixConstInterface< t_DataType> &MATRIX )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_moore_penrose.h</td>
        <td>MatrixInversionMoorePenrose</td>
        <td>ComputeInverse()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_moore_penrose.h</td>
        <td>MatrixInversionMoorePenrose</td>
        <td>GetEigenvalues() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_moore_penrose.h</td>
        <td>MatrixInversionMoorePenrose</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_moore_penrose.h</td>
        <td>MatrixInversionMoorePenrose</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_moore_penrose.h</td>
        <td>MatrixInversionMoorePenrose</td>
        <td>MatrixInversionMoorePenrose( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_moore_penrose.h</td>
        <td>MatrixInversionMoorePenrose</td>
        <td>MatrixInversionMoorePenrose()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_inversion_moore_penrose.h</td>
        <td>MatrixInversionMoorePenrose</td>
        <td>SetMatrix( const MatrixConstInterface< t_DataType> &A)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_inversion_moore_penrose.h</td>
        <td>MatrixInversionMoorePenrose</td>
        <td>Solve( const VectorConstInterface< t_DataType> &B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>AddOuterProductToMatrix( MatrixInterface< t_DataType> &A, const VectorConstInterface< t_DataType> &VECTOR_U, const VectorConstInterface< t_DataType> &VECTOR_V )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>EqualIgnoringNans( const MatrixConstInterface< t_DataType> &A, const MatrixConstInterface< t_DataType> &B )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>FindCompletelyUndefinedRows( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>FindUndefinedRows( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>InverseDimensions( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>MatrixMultiplyPreferTransposition( const size_t &ROWS, const size_t &DIM, const size_t &COLS)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>MatrixTimesItselfTransposed( const MatrixConstInterface< t_DataType> &A)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>MatrixTimesMatrixTranspose( const MatrixConstInterface< t_DataType> &MATRIX_A, const MatrixConstInterface< t_DataType> &MATRIX_B )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>MatrixTransposeTimesMatrix( const MatrixConstInterface< t_DataType> &A)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>MatrixTransposeTimesMatrix( const MatrixConstInterface< t_DataType> &A, const MatrixConstInterface< t_DataType> &B )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>MultiplicationDimension( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>MultiplySmallDenseMatrices( MatrixInterface< t_DataType> &STORAGE, const MatrixConstInterface< t_DataType> &MATRIX_A, const MatrixConstInterface< t_DataType> &MATRIX_B )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>Norm( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>OuterProduct( const MatrixConstInterface< t_DataType> &VECTOR_U, const MatrixConstInterface< t_DataType> &VECTOR_V )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>ReplaceDiagonal( Matrix< t_DataType> &MATRIX, const Vector< t_DataType> &VECTOR )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>SameDimensions( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>SubtractOuterProductFromMatrix( MatrixInterface< t_DataType> &A, const VectorConstInterface< t_DataType> &VECTOR_U, const VectorConstInterface< t_DataType> &VECTOR_V )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>VectorEqualsVectorTimesMatrix( VectorInterface< t_DataType> &STORAGE, const VectorConstInterface< t_DataType> &FEATURE, const MatrixConstInterface< t_DataType> &MATRIX )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>VectorPlusEqualsMatrixTimesVector( VectorInterface< t_DataType> &STORAGE, const MatrixConstInterface< t_DataType> &MATRIX, const VectorConstInterface< t_DataType> &FEATURE )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator !=( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const t_DataType &VALUE_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator !=( const t_DataType &VALUE_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator *( const MatrixConstInterface< t_DataType> &MATRIX, const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator *( const MatrixConstInterface< t_DataType> &MATRIX_A, const MatrixConstInterface< t_DataType> &MATRIX_B )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator *( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const t_DataType &SCALAR_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator *( const VectorConstInterface< t_DataType> &VECTOR, const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator *( const t_DataType &SCALAR_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator *=( MatrixInterface< t_DataType> &MATRIX_LHS, const t_DataType &SCALAR )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator +( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator +( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const t_DataType &VALUE_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator +( const t_DataType &VALUE_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator +=( MatrixInterface< t_DataType> &MATRIX_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator +=( MatrixInterface< t_DataType> &MATRIX_LHS, const t_DataType &VALUE )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator -( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator -( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const t_DataType &VALUE_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator -( const t_DataType &VALUE_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator -=( MatrixInterface< t_DataType> &MATRIX_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator -=( MatrixInterface< t_DataType> &MATRIX_LHS, const t_DataType &VALUE )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator /( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const t_DataType &SCALAR_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator /( const t_DataType &SCALAR_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator /=( MatrixInterface< t_DataType> &MATRIX_LHS, const t_DataType &SCALAR )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator ==( const MatrixConstInterface< t_DataType> &MATRIX_LHS, const t_DataType &VALUE_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_operations.h</td>
        <td></td>
        <td>operator ==( const t_DataType &VALUE_LHS, const MatrixConstInterface< t_DataType> &MATRIX_RHS )
</td>
        <td>loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>Begin()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>Begin() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>CopyValues( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>End()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>End() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>GetNumberCols() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>GetNumberOfElements() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>GetNumberRows() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>MatrixReference( MatrixInterface< t_DataType> &MATRIX_INTERFACE)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>MatrixReference( const size_t NUMBER_ROWS, const size_t NUMBER_COLS, t_DataType *DATA )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>MatrixReference()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>Reference( MatrixInterface< t_DataType> &MATRIX)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>operator ()( const size_t ROW, const size_t COL)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>operator ()( const size_t ROW, const size_t COL) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>operator =( const t_DataType &VALUE)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>operator []( const size_t ROW)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_matrix_reference.h</td>
        <td>MatrixReference</td>
        <td>operator []( const size_t ROW) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations.h</td>
        <td>Operations</td>
        <td>GetDefaultOperations() const
</td>
        <td>vuot2, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_operations.h</td>
        <td>Operations</td>
        <td>SetDefaultOperationsType( const EnumType &DEFAULT)
</td>
        <td>vuot2, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations.h</td>
        <td></td>
        <td>GetDefaultOperations()
</td>
        <td>vuot2, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_operations.h</td>
        <td></td>
        <td>GetOperations()
</td>
        <td>vuot2, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations.h</td>
        <td></td>
        <td>GetOperationsNonConst()
</td>
        <td>vuot2, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>DistanceMatrix( const util::SiPtrVector< const VectorConstInterface< t_DataType> > &LIST_VECTORS ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>DistanceMatrix( const util::SiPtrVector< const VectorConstInterface< t_DataType> > &LIST_VECTORS_A, const util::SiPtrVector< const VectorConstInterface< t_DataType> > &LIST_VECTORS_B ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>DotProduct( const VectorConstInterface< t_DataType> &VECTOR_A, const VectorConstInterface< t_DataType> &VECTOR_B ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>Max( const VectorConstInterface< t_DataType> &VECTOR) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>Min( const VectorConstInterface< t_DataType> &VECTOR) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>MinMax( const MatrixConstInterface< t_DataType> &MATRIX) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>Multiply( const MatrixConstInterface< t_DataType> &MATRIX, const VectorConstInterface< t_DataType> &VECTOR ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>Multiply( const MatrixConstInterface< t_DataType> &MATRIX_A, const MatrixConstInterface< t_DataType> &MATRIX_B ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>Norm( const VectorConstInterface< t_DataType> &VECTOR) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>OuterProduct( const VectorConstInterface< t_DataType> &VECTOR_U, const VectorConstInterface< t_DataType> &VECTOR_V )
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>Sum( const VectorConstInterface< t_DataType> &VECTOR) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>VectorEqualsVectorTimesMatrix( VectorInterface< t_DataType> &STORAGE, const VectorConstInterface< t_DataType> &FEATURE, const MatrixConstInterface< t_DataType> &MATRIX ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_operations_cpu.h</td>
        <td>OperationsCPU</td>
        <td>VectorPlusEqualsMatrixTimesVector( VectorInterface< t_DataType> &STORAGE, const MatrixConstInterface< t_DataType> &MATRIX, const VectorConstInterface< t_DataType> &FEATURE ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_operations_interface.h</td>
        <td>OperationsInterface</td>
        <td>CopyListToMatrix( const util::SiPtrVector< const VectorConstInterface< t_DataType> > &LIST_VECTORS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_principal_component_analysis.h</td>
        <td>PrincipalComponentAnalysis</td>
        <td>GetSortedEigenVectorsValues( const Matrix< t_DataType> &INPUT)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_principal_component_analysis.h</td>
        <td>PrincipalComponentAnalysis</td>
        <td>ReduceEigenValues( storage::Vector< storage::Pair< t_DataType, size_t> > &EIGEN_VALUES, const float THRESHOLD )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_principal_component_analysis.h</td>
        <td>PrincipalComponentAnalysis</td>
        <td>ReduceEigenValuesToN( storage::Vector< storage::Pair< t_DataType, size_t> > &EIGEN_VALUES, const size_t N )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_principal_component_analysis.h</td>
        <td>PrincipalComponentAnalysis</td>
        <td>ReduceInputMatrix( const MatrixConstInterface< t_DataType> &INPUT, Matrix< t_DataType> &STORAGE, const Matrix< t_DataType> &EIGEN_VECTORS, const Vector< t_DataType> &EIGEN_VALUES, const t_DataType &THRESHOLD, const size_t &MAX_COMPONENTS )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_principal_component_analysis.h</td>
        <td>PrincipalComponentAnalysis</td>
        <td>SortEigenValues( const MatrixConstInterface< t_DataType> &EIGEN_VALUES, const MatrixConstInterface< t_DataType> &EIGEN_VECTORS_V )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_principal_component_analysis.h</td>
        <td>PrincipalComponentAnalysis</td>
        <td>SortEigenValuesAndReduce( const MatrixConstInterface< t_DataType> &EIGEN_VALUES, const MatrixConstInterface< t_DataType> &EIGEN_VECTORS_V, const t_DataType THRESHOLD )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_principal_component_analysis.h</td>
        <td>PrincipalComponentAnalysis</td>
        <td>operator ()( Matrix< t_DataType> &INPUT, const t_DataType &THRESHOLD)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td>SymmetricEigenSolver</td>
        <td>ComputeEigenvaluesAndVectors( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td>SymmetricEigenSolver</td>
        <td>ComputeEigenvaluesOnly( const MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td>SymmetricEigenSolver</td>
        <td>GetSortedEigenvalues() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td>SymmetricEigenSolver</td>
        <td>GetSortedEigenvectors() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td>SymmetricEigenSolver</td>
        <td>GetWereEigenvectorsRequested() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td>SymmetricEigenSolver</td>
        <td>Info() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td>SymmetricEigenSolver</td>
        <td>SymmetricEigenSolver( const MatrixConstInterface< t_DataType> &MATRIX, const bool &EIGENVECTORS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td>SymmetricEigenSolver</td>
        <td>SymmetricEigenSolver( const size_t &SIZE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td>SymmetricEigenSolver</td>
        <td>SymmetricEigenSolver()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td></td>
        <td>IsMuchSmallerThan( const double &A, const double &B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td></td>
        <td>IsMuchSmallerThan( const float &A, const float &B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td></td>
        <td>IsMuchSmallerThan( const t_DataType &A, const t_DataType &B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td></td>
        <td>MakeHouseholderInPlace( VectorInterface< t_DataType> &VECTOR, t_DataType &TAU, t_DataType &BETA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_symmetric_eigensolver.h</td>
        <td></td>
        <td>SingularValueDecomposition( const MatrixConstInterface< t_DataType> &MATRIX, Matrix< t_DataType> &EIGEN_VECTORS_V, Matrix< t_DataType> &EIGEN_VECTORS_U )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Begin()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Begin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>CreateSubVector( const size_t SIZE, const size_t POS = 0 ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>End()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>End() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>GetSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Shrink( const size_t SIZE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( Vector< t_DataType> && VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const Vector< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const Vector< t_OtherDataType> &BASE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const VectorConstInterface< t_DataType> &VECTOR_INTERFACE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const VectorConstInterface< t_DataType> &VECTOR_INTERFACE, const size_t PADDING, const t_DataType &FILL_VALUE = t_DataType( 0) )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const int &SIZE, const t_DataType &FILL_VALUE = t_DataType( 0))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const size_t SIZE, const t_DataType *DATA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const storage::Vector< t_DataType> &STORAGEVECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const t_InputIteratorType &BEGIN, const t_InputIteratorType &END)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const unsigned int &SIZE, const t_DataType &FILL_VALUE = t_DataType( 0))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector( const unsigned long &SIZE, const t_DataType &FILL_VALUE = t_DataType( 0))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Vector()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>Write( std::ostream &OSTREAM, const util::Format &FORMAT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>operator ()( const size_t POS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>operator =( Vector< t_DataType> && VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>operator =( const Vector< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>operator =( const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>operator =( const t_DataType &VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>operator []( const size_t POS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td>Vector</td>
        <td>operator []( const size_t POS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td></td>
        <td>FillVector( const size_t LENGTH, const t_DataType &START, const t_DataType &DELTA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td></td>
        <td>MakeVector( const t_DataType &A, const t_DataType &B, const t_DataType &C, const t_DataType &D, const t_DataType &E )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td></td>
        <td>MakeVector( const t_DataType &A, const t_DataType &B, const t_DataType &C, const t_DataType &D, const t_DataType &E, const t_DataType &F )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td></td>
        <td>MakeVector( const t_DataType &A, const t_DataType &B, const t_DataType &C, const t_DataType &D, const t_DataType &E, const t_DataType &F, const t_DataType &G, const t_DataType &H, const t_DataType &I, const t_DataType &J )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td></td>
        <td>MakeVector( const t_DataType &X)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td></td>
        <td>MakeVector( const t_DataType &X, const t_DataType &Y)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector.h</td>
        <td></td>
        <td>MakeVector( const t_DataType &X, const t_DataType &Y, const t_DataType &Z)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector.h</td>
        <td></td>
        <td>MakeVector( const t_DataType &X, const t_DataType &Y, const t_DataType &Z, const t_DataType &T )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Begin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>End()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Set( const double &X, const double &Y)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Vector2D( const VectorConstInterface< double> &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Vector2D( const double &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Vector2D( const double &X, const double &Y)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Vector2D( const double *PTR_DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Vector2D()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>X()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>X() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Y()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>Y() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>operator ()( const size_t POS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>operator =( const Vector2D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>operator =( const VectorConstInterface< double> &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>operator =( const double &SCALAR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>operator []( const size_t POS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d.h</td>
        <td>Vector2D</td>
        <td>operator []( const size_t POS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>AbsoluteDifference( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>CalculateDistancePointFromLine( const Vector2D &POINT, const Vector2D &ORIGIN, const Vector2D &LINE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>CalculateFootpoint( const Vector2D &POINT, const Vector2D &ORIGIN, const Vector2D &LINE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>CrossProduct( const Vector2D &A, const Vector2D &B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>CrossProduct( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B, const Vector2D &VECTOR_C )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>CrossProduct( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B, const Vector2D &VECTOR_C, const Vector2D &VECTOR_D )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>Distance( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>EqualWithinTolerance( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B, const double &RELATIVE_TOLERANCE = 0.001, const double &ABSOLUTE_TOLERANCE = std::numeric_limits< double>::epsilon() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>ProjAngle( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>ProjAngle( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B, const Vector2D &VECTOR_C)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>ProjAngle( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B, const Vector2D &VECTOR_C, const Vector2D &VECTOR_D )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>ProjAngleCosinus( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>ProjAngleCosinus( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B, const Vector2D &VECTOR_C)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>ProjAngleCosinus( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B, const Vector2D &VECTOR_C, const Vector2D &VECTOR_D )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>ScalarProduct( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>SquareDistance( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>UnitVector( const Vector2D &ORIGIN, const Vector2D &TARGET)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator !=( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator *( const Vector2D &VECTOR, const double &X)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator *( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator *( const double &X, const Vector2D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator +( const Vector2D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator +( const Vector2D &VECTOR, const double &X)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator +( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator +( const double &X, const Vector2D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator -( const Vector2D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator -( const Vector2D &VECTOR, const double &X)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator -( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator -( const double &X, const Vector2D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator /( const Vector2D &VECTOR, const double &X)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_2d_operations.h</td>
        <td></td>
        <td>operator ==( const Vector2D &VECTOR_A, const Vector2D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Begin()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Begin() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>End()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>End() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>GetSize() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>IsDefined() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Norm() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Normalize()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Normalized() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Rotate( const math::RotationMatrix3D &ROTATE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Set( const double &X, const double &Y, const double &Z)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>SetRandomTranslation( const Vector3D &RADII)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>SetRandomTranslation( const double &RADIUS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>SquareNorm() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Sum() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>ToString() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Transform( const math::TransformationMatrix3D &TRANSFORM)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Translate( const Vector3D &TRANSLATE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Translate( const double X, const double Y, const double Z)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Vector3D( const VectorConstInterface< double> &VECTOR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Vector3D( const double &VALUE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Vector3D( const double &X, const double &Y, const double &Z)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Vector3D( const double *PTR_DATA)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Vector3D( const t_InputIterator &FIRST, const t_InputIterator &LAST)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Vector3D()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>X()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>X() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Y()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Y() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Z()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>Z() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator ()( const size_t POS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator +=( const Vector3D &VECTOR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator +=( const double &SCALAR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator -=( const Vector3D &VECTOR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator -=( const double &SCALAR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator =( const Vector3D &VECTOR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator =( const VectorConstInterface< double> &VECTOR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator =( const double &SCALAR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator []( const size_t POS)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d.h</td>
        <td>Vector3D</td>
        <td>operator []( const size_t POS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>AbsoluteDifference( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CalculateDistancePointFromLine( const Vector3D &POINT, const Vector3D &ORIGIN, const Vector3D &LINE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CalculateFootpoint( const Vector3D &POINT, const Vector3D &ORIGIN, const Vector3D &LINE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CoordinatesAngle( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C, const double DISTANCE_XA, const double ANGLE_XAB, const double ANGLE_XAC, const bool SIDE = true, const Vector3D &VECTOR_SIDE = Vector3D( util::GetUndefined< double>()) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CoordinatesDihedral( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C, const double DISTANCE_XA, const double ANGLE_XAB, const double DIHEDRAL_XABC )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CoordinatesLinear( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const double DISTANCE_XA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CoordinatesTetrahedral( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C, const Vector3D &VECTOR_D, const double DISTANCE_XA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CoordinatesTrigonal( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C, const double DISTANCE_XA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CrossProduct( const Vector3D &A, const Vector3D &B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CrossProduct( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>CrossProduct( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C, const Vector3D &VECTOR_D )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>Dihedral( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C, const Vector3D &VECTOR_D )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>Distance( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>EqualWithinTolerance( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const double &RELATIVE_TOLERANCE = 0.001, const double &ABSOLUTE_TOLERANCE = std::numeric_limits< double>::epsilon() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>ProjAngle( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>ProjAngle( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>ProjAngle( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C, const Vector3D &VECTOR_D )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>ProjAngleCosinus( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>ProjAngleCosinus( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>ProjAngleCosinus( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B, const Vector3D &VECTOR_C, const Vector3D &VECTOR_D )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>ScalarProduct( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>SquareDistance( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>UnitVector( const Vector3D &ORIGIN, const Vector3D &TARGET)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator !=( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator *( const Vector3D &VECTOR, const double &X)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator *( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator *( const double &X, const Vector3D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator +( const Vector3D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator +( const Vector3D &VECTOR, const double &X)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator +( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator +( const double &X, const Vector3D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator -( const Vector3D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator -( const Vector3D &VECTOR, const double &X)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator -( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator -( const double &X, const Vector3D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator /( const Vector3D &VECTOR, const double &X)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_3d_operations.h</td>
        <td></td>
        <td>operator ==( const Vector3D &VECTOR_A, const Vector3D &VECTOR_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>First() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>IsDefined() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>IsEmpty() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>Last() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>Max() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>Min() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>Norm() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>Reference( const size_t POS_START, const size_t SIZE = size_t( -1)) const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>Slice( const size_t POS_START, const size_t POS_END = size_t( -1)) const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>SquareNorm() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>Sum() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>operator !=( const VectorConstInterface< t_DataType> &RHS) const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_interface.h</td>
        <td>VectorConstInterface</td>
        <td>operator ==( const VectorConstInterface< t_DataType> &RHS) const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>CreateSubVectorConstReference( const size_t SIZE, const size_t POS = 0 ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>VectorConstReference( const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>VectorConstReference( const size_t SIZE, const t_DataType *DATA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>VectorConstReference( const size_t SIZE, t_DataType *DATA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>VectorConstReference()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>Write( std::ostream &OSTREAM, const util::Format &FORMAT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>operator =( const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>operator =( const VectorConstReference< t_DataType> &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_const_reference.h</td>
        <td>VectorConstReference</td>
        <td>operator []( const size_t POS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_interface.h</td>
        <td>VectorInterface</td>
        <td>Normalize()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_interface.h</td>
        <td>VectorInterface</td>
        <td>Reference( const size_t POS_START, const size_t SIZE = size_t( -1))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_interface.h</td>
        <td>VectorInterface</td>
        <td>Reference( const size_t POS_START, const size_t SIZE = size_t( -1)) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_interface.h</td>
        <td>VectorInterface</td>
        <td>ReplaceElements( const size_t POS, const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_interface.h</td>
        <td>VectorInterface</td>
        <td>SetRand( const t_DataType MIN, const t_DataType MAX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_interface.h</td>
        <td>VectorInterface</td>
        <td>SetToSum( const t_DataType &SUM = t_DataType( 1.0))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_interface.h</td>
        <td>VectorInterface</td>
        <td>Slice( const size_t POS_START, const size_t POS_END = size_t( -1))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_interface.h</td>
        <td>VectorInterface</td>
        <td>Slice( const size_t POS_START, const size_t POS_END = size_t( -1)) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>Begin()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>Begin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>End()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>End() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>GetSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const VectorND< t_DataType, t_N> &VECTOR_ND)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const t_DataType &A, const t_DataType &B)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const t_DataType &A, const t_DataType &B, const t_DataType &C)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const t_DataType &ELEMENT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const t_InputIterator &FIRST, const t_InputIterator &LAST)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>Write( std::ostream &OSTREAM, const util::Format &FORMAT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator ()( const size_t POS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator =( const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator =( const VectorND< t_DataType, t_N> &VECTOR_ND)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator =( const t_DataType &SCALAR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator []( const size_t POS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator []( const size_t POS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td></td>
        <td>MakeVectorND( const t_DataType &A, const t_DataType &B)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_nd.h</td>
        <td></td>
        <td>MakeVectorND( const t_DataType &A, const t_DataType &B, const t_DataType &C)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_nd.h</td>
        <td></td>
        <td>MakeVectorND( const t_DataType &A, const t_DataType &B, const t_DataType &C, const t_DataType &D)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>AbsSum( const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>Distance( const VectorConstInterface< t_DataType> &VECTOR_A, const VectorConstInterface< t_DataType> &VECTOR_B )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>ElementwiseMultiply( VectorInterface< t_DataType> &VECTOR_A, const VectorConstInterface< t_DataType> &VECTOR_B)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>LogVector( const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>ProjAngle( const VectorConstInterface< t_DataType> &VECTOR_A, const VectorConstInterface< t_DataType> &VECTOR_B )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>ProjAngle( const VectorConstInterface< t_DataType> &VECTOR_A, const VectorConstInterface< t_DataType> &VECTOR_B, const VectorConstInterface< t_DataType> &VECTOR_C )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>ProjAngle( const VectorConstInterface< t_DataType> &VECTOR_A, const VectorConstInterface< t_DataType> &VECTOR_B, const VectorConstInterface< t_DataType> &VECTOR_C, const VectorConstInterface< t_DataType> &VECTOR_D )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>ScalarProduct( const VectorConstInterface< t_DataType> &VECTOR_A, const VectorConstInterface< t_DataType> &VECTOR_B )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>SqrVector( const VectorConstInterface< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>SquareDistance( const VectorConstInterface< t_DataType> &VECTOR_A, const VectorConstInterface< t_DataType> &VECTOR_B )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator !=( const VectorConstInterface< t_DataType> &VECTOR_LHS, const t_DataType &VALUE_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator !=( const VectorConstInterface< t_DataType>& VECTOR_LHS, const VectorConstInterface< t_DataType>& VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator !=( const t_DataType &VALUE_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator *( const VectorConstInterface< t_DataType> &VECTOR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator *( const VectorConstInterface< t_DataType> &VECTOR_LHS, const t_DataType &SCALAR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator *( const t_DataType &SCALAR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator *=( VectorInterface< t_DataType> &VECTOR_LHS, const t_ScalarDataType &SCALAR )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator +( const VectorConstInterface< t_DataType> &VECTOR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator +( const VectorConstInterface< t_DataType> &VECTOR_LHS, const t_DataType &VALUE_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator +( const t_DataType &VALUE_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator +=( VectorInterface< t_DataType> &VECTOR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator +=( VectorInterface< t_DataType> &VECTOR_LHS, const t_DataType &VALUE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator -( const VectorConstInterface< t_DataType> &VECTOR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator -( const VectorConstInterface< t_DataType> &VECTOR_LHS, const t_DataType &VALUE_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator -( const t_DataType &VALUE_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator -=( VectorInterface< t_DataType> &VECTOR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator -=( VectorInterface< t_DataType> &VECTOR_LHS, const t_DataType &VALUE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator /( const VectorConstInterface< t_DataType> &VECTOR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator /( const VectorConstInterface< t_DataType> &VECTOR_LHS, const t_DataType &SCALAR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator /( const t_DataType &SCALAR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator /=( VectorInterface< t_DataType> &VECTOR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator /=( VectorInterface< t_DataType> &VECTOR_LHS, const t_DataType &SCALAR )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator <( const VectorConstInterface< t_DataType> &VECTOR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator ==( const VectorConstInterface< t_DataType> &VECTOR_LHS, const t_DataType &VALUE_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator ==( const VectorConstInterface< t_DataType>& VECTOR_LHS, const VectorConstInterface< t_DataType>& VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator ==( const t_DataType &VALUE_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_operations.h</td>
        <td></td>
        <td>operator ^( const t_DataType &SCALAR_LHS, const VectorConstInterface< t_DataType> &VECTOR_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>Begin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>CopyValues( const VectorConstInterface< t_DataType> &VALUES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>CreateSubVectorReference( const size_t SIZE, const size_t POS = 0 ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>End()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>Reference( VectorInterface< t_DataType> &VALUES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>VectorReference( VectorInterface< t_DataType> &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>VectorReference( const VectorReference< t_DataType> &REFERENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>VectorReference( const size_t SIZE, t_DataType *DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>VectorReference()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>Write( std::ostream &OSTREAM, const util::Format &FORMAT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>operator ()( const size_t POS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>operator =( const t_DataType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>operator []( const size_t POS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_linal_vector_reference.h</td>
        <td>VectorReference</td>
        <td>operator []( const size_t POS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>Absolute( const double A)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>Absolute( const int A)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>Absolute( const size_t A)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>Absolute( const std::complex< double> &A)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>Absolute( const std::pair< t_DataType1, t_DataType2> &A)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>Absolute( t_Container &CONTAINER)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>BinomialCoefficient( const size_t &N, const size_t &K)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>ConvertBooleanToSign( const bool BOOLEAN)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>EqualWithinAbsoluteTolerance( const double &TARGET_VALUE, const double &TEST_VALUE, const double &ABSOLUTE_TOLERANCE = std::numeric_limits< double>::epsilon() )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>EqualWithinMachineTolerance( const t_ContainerType &TARGET_VECTOR, const t_ContainerTypeB &TEST_VECTOR )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>EqualWithinMachineTolerance( const t_DataType &TARGET_VALUE, const t_DataTypeB &TEST_VALUE )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>EqualWithinTolerance( const t_ContainerType &TARGET_VECTOR, const t_ContainerTypeB &TEST_VECTOR, const double &RELATIVE_TOLERANCE = 0.001, const double &ABSOLUTE_TOLERANCE = std::numeric_limits< double>::epsilon() )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>EqualWithinTolerance( const t_DataType &TARGET_VALUE, const t_DataTypeB &TEST_VALUE, const double &RELATIVE_TOLERANCE = 0.001, const double &ABSOLUTE_TOLERANCE = std::numeric_limits< double>::epsilon() )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>Erf( const double x)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>Erfc( const double x)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>Factorial( const size_t &N)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>FilterValuesSmallerEqualLimit( const t_DataType &VALUE, const t_DataType &LIMIT)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>IsPowerOfTwo( const size_t &ARGUMENT)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>Pow( const size_t &VALUE, const size_t &EXPONENT)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>Pow( const t_DataType &VALUE, const t_DataType &EXPONENT)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>Pythag( const t_DataType &A, const t_DataType &B)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>Sign( const t_DataType &A, const t_OtherDataType &B)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>Sqr( const t_DataType &A)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>Sqrt( const t_DataType &X)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>WeightBetweenZeroAndPi( const double &ANGLE_RAD)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>WeightBetweenZeroAndPi_ThreeSections( const double &ANGLE_RAD)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>operator <( const std::complex< t_DataType> &A, const std::complex< t_DataType> &B)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>operator <=( const std::complex< t_DataType> &A, const std::complex< t_DataType> &B)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math.h</td>
        <td></td>
        <td>operator >( const std::complex< t_DataType> &A, const std::complex< t_DataType> &B)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math.h</td>
        <td></td>
        <td>operator >=( const std::complex< t_DataType> &A, const std::complex< t_DataType> &B)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_angle.h</td>
        <td>Angle</td>
        <td>Degree( const t_DataType &RADIAN)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_angle.h</td>
        <td>Angle</td>
        <td>GetUnitName( const Unit &UNIT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_angle.h</td>
        <td>Angle</td>
        <td>Radian( const t_DataType &DEGREE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assign.h</td>
        <td>Assign</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_assign.h</td>
        <td>Assign</td>
        <td>GetVerb() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assign.h</td>
        <td>Assign</td>
        <td>operator ()( t_ArgumentType &LHS, const t_ArgumentType &RHS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_assignment_by_comparison.h</td>
        <td>AssignmentByComparison</td>
        <td>GetSerializer() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assignment_by_comparison.h</td>
        <td>AssignmentByComparison</td>
        <td>GetVerb() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_assignment_by_comparison.h</td>
        <td>AssignmentByComparison</td>
        <td>IsSymmetric() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assignment_by_comparison.h</td>
        <td>AssignmentByComparison</td>
        <td>operator ()( t_ArgumentType &LHS, const t_ArgumentType &RHS) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_assignment_operation_interface.h</td>
        <td>AssignmentOperationInterface</td>
        <td>HasZeroProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assignment_operation_interface.h</td>
        <td>AssignmentOperationInterface</td>
        <td>IsSymmetric() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_assignment_unary_interface.h</td>
        <td>AssignmentUnaryInterface</td>
        <td>AddUnaryInstances()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assignment_unary_interface.h</td>
        <td>AssignmentUnaryInterface</td>
        <td>GetUnaryAssignments()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_assignment_unary_interface.h</td>
        <td>AssignmentUnaryInterface</td>
        <td>PerformOnEach( t_Container &CONTAINER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assignment_unary_standard.h</td>
        <td>AssignmentUnaryStandard</td>
        <td>AssignmentUnaryStandard( FunctionType FUNC)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_assignment_unary_standard.h</td>
        <td>AssignmentUnaryStandard</td>
        <td>AssignmentUnaryStandard( double ( *FUNCTION)( double))
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assignment_unary_standard.h</td>
        <td>AssignmentUnaryStandard</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_assignment_unary_standard.h</td>
        <td>AssignmentUnaryStandard</td>
        <td>operator ()( double &VALUE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assignment_unary_standard.h</td>
        <td>AssignmentUnaryStandard</td>
        <td>operator ()( float &VALUE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_assignments.h</td>
        <td>Assignments</td>
        <td>AddInstances()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_assignments.h</td>
        <td>Assignments</td>
        <td>GetAssignments()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>BicubicSpline()
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>F( const linal::Vector< double> &ARGUMENTS) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>FdF( const linal::Vector< double> &ARGUMENTS) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>GetDeltaX() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>GetDeltaY() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>GetStartX() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>GetStartY() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>GetValues() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>Train( const SplineBorderType BORDER[ 2], const double START[ 2], const double DELTA[ 2], const linal::Matrix< double> &RESULTS, const bool LINCONT[ 2], const storage::Pair< double, double> FIRSTBE[ 2] )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>TrainWithPreprocessing( const SplineBorderType BORDER[ 2], const double START[ 2], const double DELTA[ 2], const linal::Matrix< double> &RESULTS, const bool LINCONT[ 2], const storage::Pair< double, double> FIRSTBE[ 2], const double PREPROC )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>dFdx( const linal::Vector< double> &ARGUMENTS) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>dFdy( const linal::Vector< double> &ARGUMENTS) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_bicubic_spline.h</td>
        <td>BicubicSpline</td>
        <td>operator ()( const double &X, const double &Y) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_bind_first.h</td>
        <td>BinaryFunctionBindFirst</td>
        <td>BinaryFunctionBindFirst( const util::BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &BINARY_FUNCTION, const t_ArgumentType1 &BOUND_ARGUMENT1 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_bind_first.h</td>
        <td>BinaryFunctionBindFirst</td>
        <td>BinaryFunctionBindFirst( const util::ShPtr< util::BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> > &SP_BINARY_FUNCTION, const t_ArgumentType1 &BOUND_ARGUMENT1 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_bind_first.h</td>
        <td>BinaryFunctionBindFirst</td>
        <td>BinaryFunctionBindFirst()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_bind_first.h</td>
        <td>BinaryFunctionBindFirst</td>
        <td>operator ()( const t_ArgumentType2 &ARGUMENT2) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_bind_first.h</td>
        <td></td>
        <td>AddInstance( new BinaryFunctionBindFirst< t_ArgumentType1, t_ArgumentType2, t_ResultType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_bind_second.h</td>
        <td>BinaryFunctionBindSecond</td>
        <td>BinaryFunctionBindSecond( const util::BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &BINARY_FUNCTION, const t_ArgumentType2 &BOUND_ARGUMENT2 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_bind_second.h</td>
        <td>BinaryFunctionBindSecond</td>
        <td>BinaryFunctionBindSecond( const util::ShPtr< util::BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> > &SP_BINARY_FUNCTION, const t_ArgumentType2 &BOUND_ARGUMENT2 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_bind_second.h</td>
        <td>BinaryFunctionBindSecond</td>
        <td>BinaryFunctionBindSecond()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_bind_second.h</td>
        <td>BinaryFunctionBindSecond</td>
        <td>operator ()( const t_ArgumentType1 &ARGUMENT1) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_bind_second.h</td>
        <td></td>
        <td>AddInstance( new BinaryFunctionBindSecond< t_ArgumentType1, t_ArgumentType2, t_ResultType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>AddSignalHandlerForArgument( SignalHandlerFunctionPtr SIGNAL_HANDLER1)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>AddSignalHandlerForArgument( SignalHandlerFunctionPtr1 SIGNAL_HANDLER1)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>AddSignalHandlerForArgument( SignalHandlerFunctionPtr2 SIGNAL_HANDLER2)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>BinaryFunctionCached( const BinaryFunctionCached< t_ArgumentType, t_ArgumentType, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>BinaryFunctionCached( const BinaryFunctionCached< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>BinaryFunctionCached( const util::ShPtr< BinaryFunctionInterface< t_ArgumentType, t_ArgumentType, t_ResultType> > &SP_FUNCTION, SignalHandlerFunctionPtr DESTRUCTOR_SIGNAL_HANDLER, const bool SYMMETRIC )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>BinaryFunctionCached( const util::ShPtr< BinaryFunctionInterfaceSerializable< t_ArgumentType1, t_ArgumentType2, t_ResultType> > &SP_FUNCTION, SignalHandlerFunctionPtr1 DESTRUCTOR_SIGNAL_1, SignalHandlerFunctionPtr2 DESTRUCTOR_SIGNAL_2 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>GetCacheSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>GetFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>GetFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>IsSymmetric() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType &ARGUMENT1, const t_ArgumentType &ARGUMENT2, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType1 &ARGUMENT1, const t_ArgumentType2 &ARGUMENT2, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT1, const t_ArgumentType &ARGUMENT2) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>operator ()( const t_ArgumentType1 &ARGUMENT1, const t_ArgumentType2 &ARGUMENT2) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>operator =( const BinaryFunctionCached< t_ArgumentType, t_ArgumentType, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_cached.h</td>
        <td>BinaryFunctionCached</td>
        <td>operator =( const BinaryFunctionCached< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_cached.h</td>
        <td></td>
        <td>AddInstance( new BinaryFunctionCached< t_ArgumentType1, t_ArgumentType2, t_ResultType>( util::ShPtr< BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> >()) )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_interface.h</td>
        <td>BinaryFunctionInterface</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_function_interface.h</td>
        <td>BinaryFunctionInterface</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType1 &ARGUMENT1, const t_ArgumentType2 &ARGUMENT2, std::ostream &OSTREAM ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_function_interface_serializable.h</td>
        <td>BinaryFunctionInterfaceSerializable</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>BinarySumFunction( )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>BinarySumFunction( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION, const t_Scalar &COEFFICIENT = t_Scalar( 1), const t_ResultType &ABS_CONST = t_ResultType() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>BinarySumFunction( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B, const t_Scalar &COEFFICIENT_A = t_Scalar( 1), const t_Scalar &COEFFICIENT_B = t_Scalar( 1), const t_ResultType &ABS_CONST = t_ResultType() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>BinarySumFunction( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>BinarySumFunction( const t_ResultType &ABS_CONST )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>BinarySumFunction( const util::ShPtr< BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> > &SP_FUNCTION, const t_Scalar &COEFFICIENT = t_Scalar( 1), const t_ResultType &ABS_CONST = t_ResultType() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>BinarySumFunction( const util::ShPtr< BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> > &SP_FUNCTION_A, const util::ShPtr< BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> > &SP_FUNCTION_B, const t_Scalar &COEFFICIENT_A = t_Scalar( 1), const t_Scalar &COEFFICIENT_B = t_Scalar( 1), const t_ResultType &ABS_CONST = t_ResultType() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>GetFunction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>NewOperand( const util::ShPtr< BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> > &SP_FUNCTION, const t_Scalar &COEFFICIENT = t_Scalar( 1) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType1 &ARGUMENT_1, const t_ArgumentType2 &ARGUMENT_2, std::ostream &OSTREAM ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator ()( const t_ArgumentType1 &ARGUMENT_1, const t_ArgumentType2 &ARGUMENT_2 ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator *=( const t_Scalar &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator +=( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator +=( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator +=( const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator -=( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator -=( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator -=( const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator /=( const t_Scalar &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator =( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td>BinarySumFunction</td>
        <td>operator =( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>AddInstance( new BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar>() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator *( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION, const t_Scalar &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator *( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION, const t_Scalar &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator *( const t_Scalar &SCALAR, const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator *( const t_Scalar &SCALAR, const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator +( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION, const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator +( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator +( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator +( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &FUNCTION_A, const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator +( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION, const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator +( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION_A, const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator +( const t_ResultType &VALUE, const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator +( const t_ResultType &VALUE, const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator -( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION, const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator -( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator -( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_A, const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator -( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &FUNCTION_A, const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator -( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator -( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION, const t_ResultType &VALUE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator -( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION_A, const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator -( const t_ResultType &VALUE, const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator -( const t_ResultType &VALUE, const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator /( const BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_ResultType> &FUNCTION, const t_Scalar &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_sum_function.h</td>
        <td></td>
        <td>operator /( const BinarySumFunction< t_ArgumentType1, t_ArgumentType2, t_ResultType, t_Scalar> &SUM_FUNCTION, const t_Scalar &SCALAR )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_binary_unary_function_adapter.h</td>
        <td>BinaryUnaryFunctionAdapter</td>
        <td>BinaryUnaryFunctionAdapter( const util::ShPtr< BinaryFunctionInterface< t_ArgumentType1, t_ArgumentType2, t_IntermediateType> > &SP_FUNCTION_ABC, const util::ShPtr< FunctionInterfaceSerializable< t_IntermediateType, t_ResultType> > &SP_FUNCTION_CD )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_binary_unary_function_adapter.h</td>
        <td>BinaryUnaryFunctionAdapter</td>
        <td>operator ()( const t_ArgumentType1 &ARGUMENT1, const t_ArgumentType2 &ARGUMENT2) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_combination.h</td>
        <td>Combination</td>
        <td>Combination( const storage::Set< t_KeyType, t_KeyCompare> &DATA, const size_t COMBINATION_SIZE )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_combination.h</td>
        <td>Combination</td>
        <td>Combination()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_combination.h</td>
        <td>Combination</td>
        <td>GetAllCombinations() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_combination.h</td>
        <td>Combination</td>
        <td>GetCombinationSize() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_combination.h</td>
        <td>Combination</td>
        <td>GetData() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_combination.h</td>
        <td>Combination</td>
        <td>GetNumberOfCombinations() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_combination.h</td>
        <td></td>
        <td>AddInstance( new Combination< t_KeyType, t_KeyCompare>())
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_comparisons.h</td>
        <td>Comparisons</td>
        <td>CreateUnaryPredicate( const Comparison &COMPARISON, const t_DataType &VALUE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_const_function.h</td>
        <td>ConstFunction</td>
        <td>ConstFunction( const t_ResultType &RESULT)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_const_function.h</td>
        <td>ConstFunction</td>
        <td>ConstFunction()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_const_function.h</td>
        <td>ConstFunction</td>
        <td>GetScheme() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_const_function.h</td>
        <td>ConstFunction</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_const_function.h</td>
        <td></td>
        <td>AddInstance( new ConstFunction< t_ArgumentType, t_ResultType>())
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>ContingencyMatrix( const size_t TRUE_POSITIVES, const size_t FALSE_POSITIVES, const size_t FALSE_NEGATIVES, const size_t TRUE_NEGATIVES )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>ContingencyMatrix()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetAccuracy() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetEnrichment() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetFalseDiscoveryRate() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetFalseNegativeRate() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetFalsePositiveRate() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetFractionPredictedPositives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetFractionPredictedPositivesNormalized() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetIdealPositivePredictiveValue() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetIdealPositivePredictiveValueConsideringFalsePositives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetInformationGainRatio() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetMatthewsCorrelationCoefficient() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetNegativePredictiveValue() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetNumberActualNegatives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetNumberActualPositives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetNumberFalseNegatives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetNumberFalsePositives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetNumberPredictedNegatives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetNumberPredictedPositives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetNumberTrueNegatives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetNumberTruePositives() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetOversampledEnrichment( const double &ENRICHMENT_FACTOR) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetPositivePredictiveValue() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetPrecision() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetPrecisionNormalized() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetRecall() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetSpecificity() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetTotal() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetTrueNegativeRate() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix.h</td>
        <td>ContingencyMatrix</td>
        <td>GetTruePositiveRate() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix_measures.h</td>
        <td>ContingencyMatrixMeasures</td>
        <td>ContingencyMatrixMeasures( const Measure &MEASURE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix_measures.h</td>
        <td>ContingencyMatrixMeasures</td>
        <td>ContingencyMatrixMeasures()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix_measures.h</td>
        <td>ContingencyMatrixMeasures</td>
        <td>GetMeasure() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix_measures.h</td>
        <td>ContingencyMatrixMeasures</td>
        <td>GetMeasureInfo( const Measure &MEASURE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix_measures.h</td>
        <td>ContingencyMatrixMeasures</td>
        <td>GetMeasureName( const Measure &MEASURE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_contingency_matrix_measures.h</td>
        <td>ContingencyMatrixMeasures</td>
        <td>GetOptimizationParity() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_contingency_matrix_measures.h</td>
        <td>ContingencyMatrixMeasures</td>
        <td>operator ()( const ContingencyMatrix &MATRIX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline.h</td>
        <td>CubicSpline</td>
        <td>CubicSpline()
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline.h</td>
        <td>CubicSpline</td>
        <td>FdF( const double &ARGUMENT) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline.h</td>
        <td>CubicSpline</td>
        <td>GetDelta() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline.h</td>
        <td>CubicSpline</td>
        <td>GetStart() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline.h</td>
        <td>CubicSpline</td>
        <td>GetValues() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline.h</td>
        <td>CubicSpline</td>
        <td>Train( const SplineBorderType BORDER, const double START, const double DELTA, const linal::VectorConstInterface< double> &RESULTS, const storage::Pair< double, double> &FIRSTBE )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline.h</td>
        <td>CubicSpline</td>
        <td>TrainWithPreprocessing( const SplineBorderType BORDER, const double START, const double DELTA, const linal::VectorConstInterface< double> &RESULTS, const storage::Pair< double, double> &FIRSTBE, const double PREPOC )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline.h</td>
        <td>CubicSpline</td>
        <td>dF( const double &ARGUMENT) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline.h</td>
        <td>CubicSpline</td>
        <td>operator ()( const double &ARGUMENT) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline_damped.h</td>
        <td>CubicSplineDamped</td>
        <td>FdF( const double &ARGUMENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline_damped.h</td>
        <td>CubicSplineDamped</td>
        <td>GetDelta() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline_damped.h</td>
        <td>CubicSplineDamped</td>
        <td>GetXValues() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline_damped.h</td>
        <td>CubicSplineDamped</td>
        <td>GetYValues() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline_damped.h</td>
        <td>CubicSplineDamped</td>
        <td>Train( const double &START, const double &DELTA, const linal::VectorConstInterface< double> &Y, const double &DY_START = std::numeric_limits< double>::quiet_NaN(), const double &DY_END = std::numeric_limits< double>::quiet_NaN() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline_damped.h</td>
        <td>CubicSplineDamped</td>
        <td>Train( const linal::VectorConstInterface< double> &X, const linal::VectorConstInterface< double> &Y, const double &DY_START = std::numeric_limits< double>::quiet_NaN(), const double &DY_END = std::numeric_limits< double>::quiet_NaN() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline_damped.h</td>
        <td>CubicSplineDamped</td>
        <td>dF( const double &ARGUMENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline_damped.h</td>
        <td>CubicSplineDamped</td>
        <td>operator ()( const double &ARGUMENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline_variable_delta.h</td>
        <td>CubicSplineVariableDelta</td>
        <td>FdF( const double &ARGUMENT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline_variable_delta.h</td>
        <td>CubicSplineVariableDelta</td>
        <td>GetSecondDerivativeValues() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline_variable_delta.h</td>
        <td>CubicSplineVariableDelta</td>
        <td>GetXValues() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline_variable_delta.h</td>
        <td>CubicSplineVariableDelta</td>
        <td>GetYValues() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline_variable_delta.h</td>
        <td>CubicSplineVariableDelta</td>
        <td>Train( const SplineBorderType BORDER, const double START, const double DELTA, const linal::Vector< double> &RESULTS, const storage::Pair< double, double> &FIRSTBE = ( storage::Pair< double, double>( 0.0, 0.0)) )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline_variable_delta.h</td>
        <td>CubicSplineVariableDelta</td>
        <td>Train( const SplineBorderType BORDER, const linal::VectorConstInterface< double> &X, const linal::VectorConstInterface< double> &Y, const storage::Pair< double, double> &FIRSTBE = ( storage::Pair< double, double>( 0.0, 0.0)) )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_cubic_spline_variable_delta.h</td>
        <td>CubicSplineVariableDelta</td>
        <td>dF( const double &ARGUMENT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_cubic_spline_variable_delta.h</td>
        <td>CubicSplineVariableDelta</td>
        <td>operator ()( const double &ARGUMENT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_discrete_set_selector.h</td>
        <td>DiscreteSetSelector</td>
        <td>DiscreteSetSelector( const DiscreteSetSelector &OTHER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_discrete_set_selector.h</td>
        <td>DiscreteSetSelector</td>
        <td>DiscreteSetSelector( const FunctionInterfaceSerializable< double, double> &PROBABILITY_FUNCTION, const linal::VectorConstInterface< double> &VALUES = linal::Vector< double>() )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_discrete_set_selector.h</td>
        <td>DiscreteSetSelector</td>
        <td>DiscreteSetSelector()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_discrete_set_selector.h</td>
        <td>DiscreteSetSelector</td>
        <td>GetWeights() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_discrete_set_selector.h</td>
        <td>DiscreteSetSelector</td>
        <td>Prepare( const linal::VectorConstInterface< double> &VALUES)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_discrete_set_selector.h</td>
        <td>DiscreteSetSelector</td>
        <td>Reset()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_discrete_set_selector.h</td>
        <td>DiscreteSetSelector</td>
        <td>operator ()( const double &ARGUMENT = util::GetUndefined< double>()) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_discrete_set_selector.h</td>
        <td>DiscreteSetSelector</td>
        <td>operator =( const DiscreteSetSelector &OTHER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_divide_equals.h</td>
        <td>DivideEquals</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_divide_equals.h</td>
        <td>DivideEquals</td>
        <td>GetVerb() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_divide_equals.h</td>
        <td>DivideEquals</td>
        <td>HasZeroProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_divide_equals.h</td>
        <td>DivideEquals</td>
        <td>operator ()( t_ArgumentType &LHS, const t_ArgumentType &RHS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_function_adapter.h</td>
        <td>FunctionAdapter</td>
        <td>FunctionAdapter( const util::ShPtr< FunctionInterfaceSerializable< t_ArgumentType, t_IntermediateType> > &SP_FUNCTION_AB, const util::ShPtr< FunctionInterfaceSerializable< t_IntermediateType, t_ResultType> > &SP_FUNCTION_BC )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_function_adapter.h</td>
        <td>FunctionAdapter</td>
        <td>FunctionAdapter( const util::ShPtr< FunctionInterfaceSerializable< t_ArgumentType, t_IntermediateType> > &SP_FUNCTION_AB, const util::ShPtr< FunctionInterfaceSerializable< t_IntermediateType, t_ResultType> > &SP_FUNCTION_BC, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_function_adapter.h</td>
        <td>FunctionAdapter</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_function_adapter.h</td>
        <td>FunctionAdapter</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>AddSignalHandlerForArgument( SignalHandlerFunctionPtr SIGNAL_HANDLER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>FunctionCached( const FunctionCached< t_ArgumentType, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>FunctionCached( const util::ShPtr< FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> > &SP_FUNCTION, SignalHandlerFunctionPtr DESTRUCTOR_SIGNAL_HANDLER, SignalHandlerFunctionPtr CHANGE_SIGNAL_HANDLER = NULL )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>GetCacheSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>GetFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType &ARGUMENT, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType &ARGUMENT, std::ostream &OSTREAM, const util::Format &FORMAT = util::Format() ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_function_cached.h</td>
        <td>FunctionCached</td>
        <td>operator =( const FunctionCached< t_ArgumentType, t_ResultType> &FUNCTION_CACHED_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_function_interface.h</td>
        <td>FunctionInterface</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_function_interface.h</td>
        <td>FunctionInterface</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType &ARGUMENT, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_function_interface_serializable.h</td>
        <td>FunctionInterfaceSerializable</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gaussian_function.h</td>
        <td>GaussianFunction</td>
        <td>GaussianFunction( const double MEAN, const double SIGMA )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gaussian_function.h</td>
        <td>GaussianFunction</td>
        <td>GaussianFunction()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gaussian_function.h</td>
        <td>GaussianFunction</td>
        <td>GetMean() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gaussian_function.h</td>
        <td>GaussianFunction</td>
        <td>GetNormalizationParameter() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gaussian_function.h</td>
        <td>GaussianFunction</td>
        <td>GetRange( const size_t MULTIPLE_SIGMA) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gaussian_function.h</td>
        <td>GaussianFunction</td>
        <td>GetSigma() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gaussian_function.h</td>
        <td>GaussianFunction</td>
        <td>operator ()( const double &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetAxisString( const coord::Axis &AXIS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagGnuplotOutputFilename()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagSeriesNames()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagSetKey()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagTableColumnsX()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagTableColumnsY()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagTableInputFilenames()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagTicIntervalX()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagTicIntervalY()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagTitle()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagXLabel()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagXMax()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagXMin()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagXPixels()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagYLabel()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagYMax()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagYMin()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>GetFlagYPixels()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot.h</td>
        <td>Gnuplot</td>
        <td>TicsFromBinning( const linal::Vector< double> &BINNING, const size_t BINS_PER_TIC, const util::Format &FORMAT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>GetData() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>GetPaletteString( const PaletteTypes &ENUM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>GetPaletteTypeString( const PaletteTypes &ENUM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>GnuplotHeatmap()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>Muliply( const double FACTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetBoxes( const storage::Vector< storage::VectorND< 2, storage::VectorND< 2, double> > > &BOX_COORDS, const double X_RANGE, const double Y_RANGE, const double X_MIN, const double Y_MIN )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetBoxesSpecifications( const storage::Vector< std::string> &SPECIFICATIONS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFilename( const std::string &FILENAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFont( const std::string &FONT, const size_t FONT_SIZE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromBicubicSpline( const BicubicSpline &BICUBIC_SPLINE, const bool CENTER_TICS_X, const bool CENTER_TICS_Y )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromBinaryFunction( const BinaryFunctionInterface< double, double, double> &BINARY_FUNCTION, const size_t NUMBER_FUNCTION_VALUES_X, const double START_X, const double DELTA_X, const size_t NUMBER_FUNCTION_VALUES_Y, const double START_Y, const double DELTA_Y, const bool CENTER_TICS_X, const bool CENTER_TICS_Y )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromCubicSpline( const CubicSpline &CUBIC_SPLINE, const bool VERTICAL, const bool CENTER_TICS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromCubicSpline( const CubicSplineDamped &CUBIC_SPLINE, const bool VERTICAL, const bool CENTER_TICS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromCubicSplines( const util::SiPtrVector< const CubicSpline> &CUBIC_SPLINES, const bool VERTICAL, const bool CENTER_TICS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromCubicSplines( const util::SiPtrVector< const CubicSplineDamped> &CUBIC_SPLINES, const bool VERTICAL, const bool CENTER_TICS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromFunction( const FunctionInterfaceSerializable< double, double> &FUNCTION, const size_t NUMBER_FUNCTION_VALUES, const double START, const double DELTA, const bool VERTICAL, const bool CENTER_TICS, const bool NORMALIZE_EACH_FUNCTION, const size_t TICS_PER_DELTA = 1 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromFunctions( const util::SiPtrVector< const FunctionInterfaceSerializable< double, double> > &FUNCTIONS, const size_t NUMBER_FUNCTION_VALUES, const double START, const double DELTA, const bool VERTICAL, const bool CENTER_TICS, const bool NORMALIZE_EACH_FUNCTION, const size_t TICS_PER_DELTA = 1 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromHistogram( const Histogram &HISTOGRAM, const bool VERTICAL, const bool CENTER_TICS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromHistogram( const Histogram2D &HISTOGRAM2D, const bool CENTER_TICS_X, const bool CENTER_TICS_Y )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromHistograms( const util::SiPtrVector< const Histogram> &HISTOGRAMS, const bool VERTICAL, const bool CENTER_TICS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetFromMatrix( const linal::Matrix< double> &MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetMargins( const double TOP, const double BOTTOM, const double RIGHT, const double LEFT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetMinMaxZ( const double MIN_Z, const double MAX_Z)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetNoMirrorTics( const bool SET)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetPalette( const PaletteTypes PALETTE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetPixelAndRatio( const size_t PIXEL_X, const size_t PIXEL_Y, const double RATIO)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetRotationXTics( const double DEGREE_ROTATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetShowColorBox( const bool SET_COLOR_BOX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetShowXTics( const bool SET)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetTicsX( const storage::Vector< std::string> &TICS_X, const bool CENTER_TICS, const size_t NTH_BIN)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetTicsY( const storage::Vector< std::string> &TICS_Y, const bool CENTER_TICS, const size_t NTH_BIN)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetTitleAndLabel( const std::string &TITLE, const std::string &LABEL_X, const std::string &LABEL_Y, const std::string &LABEL_Z )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetWriteBoxes( const bool SET)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetWriteData( const bool SET)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetWriteHeader( const bool SET)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetWritePalettes( const bool SET)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>SetWritePreHeader( const bool SET)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>WriteAxisInfo( std::ostream &OSTREAM, const coord::Axis &AXIS, const std::string &LABEL, const double MIN, const double MAX, const storage::Vector< std::string> &TICS, const bool CENTER_TICS, const size_t NTH_BIN ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>WriteBoxes( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>WriteData( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>WriteHeader( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>WritePalettes( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>WritePreHeader( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_heatmap.h</td>
        <td>GnuplotHeatmap</td>
        <td>WriteScript( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>GnuplotMultiplot()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>Insert( const util::ShPtr< Gnuplot> &PLOT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetFilename( const std::string &FILENAME)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetFont( const std::string &FONT, const size_t FONT_SIZE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetPixelAndRatio( const size_t PIXEL_X, const size_t PIXEL_Y, const double RATIO)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetRotationXTics( const double DEGREE_ROTATION)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetRowsCols( size_t ROWS, size_t COLS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetTicsX( const storage::Vector< std::string> &TICS_X, const bool CENTER_TICS, const size_t NTH_BIN)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetTicsY( const storage::Vector< std::string> &TICS_Y, const bool CENTER_TICS, const size_t NTH_BIN)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetWriteBoxes( const bool SET)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetWriteData( const bool SET)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetWriteHeader( const bool SET)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>SetWritePreHeader( const bool SET)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>WriteAxisInfo( std::ostream &OSTREAM, const coord::Axis &AXIS, const std::string &LABEL, const double MIN, const double MAX, const storage::Vector< std::string> &TICS, const bool CENTER_TICS, const size_t NTH_BIN ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>WriteData( std::ostream &OSTREAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>WriteHeader( std::ostream &OSTREAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>WritePreHeader( std::ostream &OSTREAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_gnuplot_multiplot.h</td>
        <td>GnuplotMultiplot</td>
        <td>WriteScript( std::ostream &OSTREAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>AddPseudoCount( const double VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>CalculateHistogram( const storage::Vector< double> &VALUES_VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>CalculateMean() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>CalculateSD() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>Combine( const Histogram &HISTOGRAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>ExtendBoundaries( const size_t NUM_BINS_LOWER, const double LOWER_BIN_VALUES, const double FLOOR, const size_t NUM_BINS_UPPER, const double UPPER_BIN_VALUES, const double CEILING )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetBinSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetBinning() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetBoundaries() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetBoundariesCounts() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetCountsInBetween( const double MIN, const double MAX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetFlagBinSize()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetFlagMin()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetFlagNumberOfBins()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetHistogram() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetIndexOfFirstInformationContainingBin( const double COUNT_THRESHOLD = 0.0) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetIndexOfLastInformationContainingBin( const double COUNT_THRESHOLD = 0.0) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetNumberOfBins() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>GetSumOfAllCounts() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>Histogram( const double MIN, const double BIN_SIZE, const size_t NUMBER_OF_BINS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>Histogram( const storage::Map< double, double> &DATA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>Histogram()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>IsDefined() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>IsEmpty() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>Normalize()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>PushBack( const double VALUE, const double WEIGHT = double( 1))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>ReadHorizontally( std::istream &ISTREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>RemoveBinsAfterIndex( const size_t LAST_INDEX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>RemoveBinsBeforeIndex( const size_t FIRST_INDEX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>Reset()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>ResetBinsAfterIndex( const size_t LAST_INDEX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>ResetBinsBeforeIndex( const size_t FIRST_INDEX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>SetCount( const size_t INDEX, const double COUNT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>WriteGnuPlotHeatMapFormatted( std::ostream &OSTREAM, const linal::Vector< double> &BINNING, const linal::Vector< double> &COUNTS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>WriteGnuPlotLinePlotFormatted( std::ostream &OSTREAM, const linal::Vector< double> &BINNING, const linal::Vector< double> &COUNTS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>WriteHorizontally( std::ostream &OSTREAM, const util::Format &FORMAT_BINNING = util::Format().W( 8).FFP( 3), const util::Format &FORMAT_VALUES = util::Format().W( 8).FFP( 3), const size_t INDENT = 0 ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>WriteLinearGnuplot( std::ostream &OSTREAM, const std::string &TITLE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram.h</td>
        <td>Histogram</td>
        <td>WriteVertically( std::ostream &OSTREAM, const util::Format &FORMAT_BINNING = util::Format().W( 8).FFP( 3), const util::Format &FORMAT_VALUES = util::Format().W( 8).FFP( 3) ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>CalculateHistogram( const storage::Vector< storage::VectorND< 2, double> > &VALUES_VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>Combine( const Histogram2D &HISTOGRAM_2D)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetBinSizeXY() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetBinningXY() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetBoundariesCountsX() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetBoundariesCountsY() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetBoundariesX() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetBoundariesY() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetHistogram() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetNumberOfBinsX() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetNumberOfBinsY() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>GetSumOfAllCounts() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>Histogram2D( const storage::VectorND< 2, double> &MIN_X_Y, const storage::VectorND< 2, double> &BINSIZE_X_Y, const storage::VectorND< 2, size_t> &NUMBER_OF_BINS_X_Y )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>Histogram2D()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>IsEmpty() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>Log()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>Normalize()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>NormalizeByBackground( const Histogram2D &HIST)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>NormalizeRows()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>NormalizeY()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>PushBack( const storage::VectorND< 2, double> &PAIR_OF_VALUES, const double &WEIGHT = double( 1.0))
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>Reset()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_2d.h</td>
        <td>Histogram2D</td>
        <td>Write( std::ostream &OSTREAM, const util::Format &FORMAT_BINNING, const util::Format &FORMAT_VALUES) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>Combine( const Histogram3D &HISTOGRAM_2D)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetBinSizeXYZ() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetBinningXYZ() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetBoundariesX() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetBoundariesY() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetBoundariesZ() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetChangeableHistogram()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetHistogram() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetNumberOfBinsX() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetNumberOfBinsY() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetNumberOfBinsZ() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>GetSumOfAllCounts() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>Histogram3D( const storage::VectorND< 3, double> &MIN_X_Y_Z, const storage::VectorND< 3, double> &BINSIZE_X_Y_Z, const storage::VectorND< 3, size_t> &NUMBER_OF_BINS_X_Y_Z, const double &INITIAL_VAL = 0.0 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>Histogram3D()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>Interpolate( const double &X, const double &Y, const double &Z) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>IsEmpty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>Normalize()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>NormalizeByBackground( const Histogram3D &HIST)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>PushBack( const double &X, const double &Y, const double &Z, const double &WEIGHT = double( 1.0))
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>Value( const double &X, const double &Y, const double &Z) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_histogram_3d.h</td>
        <td>Histogram3D</td>
        <td>Write( std::ostream &OSTREAM, const util::Format &FORMAT_BINNING, const util::Format &FORMAT_VALUES) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_identity.h</td>
        <td>Identity</td>
        <td>GetScheme() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_identity.h</td>
        <td>Identity</td>
        <td>operator ()( const t_DataType &ARGUMENT) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_identity.h</td>
        <td></td>
        <td>AddInstance( new Identity< t_DataType>())
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_kernel_function.h</td>
        <td>KernelFunction</td>
        <td>GetKernel() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_kernel_function.h</td>
        <td>KernelFunction</td>
        <td>KernelFunction( const Range< double> &KERNEL)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_kernel_function.h</td>
        <td>KernelFunction</td>
        <td>KernelFunction()
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_kernel_function.h</td>
        <td>KernelFunction</td>
        <td>SetKernel( const Range< double> &KERNEL)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_kernel_function.h</td>
        <td>KernelFunction</td>
        <td>operator ()( const double &ARGUMENT) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_limits.h</td>
        <td></td>
        <td>GetHighestBoundedValue()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_limits.h</td>
        <td></td>
        <td>GetHighestUnboundedValue()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_limits.h</td>
        <td></td>
        <td>GetLowestBoundedValue()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_limits.h</td>
        <td></td>
        <td>GetLowestUnboundedValue()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>AsString() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>GetOrdinateIntercept() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>GetSlope() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>LinearFunction( const Range< t_DataType> &FROM_RANGE, const Range< t_DataType> &TO_RANGE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>LinearFunction( const double &SLOPE, const double &ORDINATE_INTERCEPT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>LinearFunction( const double &X1, const double &Y1, const double &X2, const double &Y2)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>LinearFunction( const t_X_IteratorType X_ITR_BEGIN, const t_X_IteratorType X_ITR_END, const t_Y_IteratorType Y_ITR_BEGIN, const t_Y_IteratorType Y_ITR_END, const size_t DATA_SIZE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>LinearFunction()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>operator ()( const double &X_VALUE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_linear_function.h</td>
        <td>LinearFunction</td>
        <td>operator ==( const LinearFunction &FUNCTION) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_linear_least_squares.h</td>
        <td>LinearLeastSquares</td>
        <td>LinearLeastSquares()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_linear_least_squares.h</td>
        <td>LinearLeastSquares</td>
        <td>SolutionAndChiSquared( const linal::MatrixConstInterface< double> &X, const linal::VectorConstInterface< double> &Y )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_linear_least_squares.h</td>
        <td>LinearLeastSquares</td>
        <td>SolutionAndChiSquared( const linal::MatrixConstInterface< float> &X, const linal::VectorConstInterface< float> &Y )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_log_likelihood.h</td>
        <td>LogLikelihood</td>
        <td>GetMean() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_log_likelihood.h</td>
        <td>LogLikelihood</td>
        <td>GetScheme() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_log_likelihood.h</td>
        <td>LogLikelihood</td>
        <td>GetSigma() const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_log_likelihood.h</td>
        <td>LogLikelihood</td>
        <td>LogLikelihood( const double MEAN, const double SIGMA )
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_log_likelihood.h</td>
        <td>LogLikelihood</td>
        <td>LogLikelihood()
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_log_likelihood.h</td>
        <td>LogLikelihood</td>
        <td>operator ()( const double &ARGUMENT) const
</td>
        <td>bitterd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_minus_equals.h</td>
        <td>MinusEquals</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_minus_equals.h</td>
        <td>MinusEquals</td>
        <td>GetVerb() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_minus_equals.h</td>
        <td>MinusEquals</td>
        <td>operator ()( t_ArgumentType &LHS, const t_ArgumentType &RHS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mod_equals.h</td>
        <td>ModEquals</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mod_equals.h</td>
        <td>ModEquals</td>
        <td>GetVerb() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mod_equals.h</td>
        <td>ModEquals</td>
        <td>IsSymmetric() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mod_equals.h</td>
        <td>ModEquals</td>
        <td>operator ()( t_ArgumentType &LHS, const t_ArgumentType &RHS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>MutateCombine( const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_A, bool IGNORE_UNDEFINED_RESULT, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>MutateCombine( const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_A, const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_B, bool IGNORE_UNDEFINED_RESULT, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>MutateCombine( const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_A, const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_B, const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_C, bool IGNORE_UNDEFINED_RESULT, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>MutateCombine( const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_A, const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_B, const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_C, const FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > &MUTATE_D, bool IGNORE_UNDEFINED_RESULT, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>MutateCombine( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>MutateCombine( const util::ShPtrList< FunctionInterfaceSerializable< t_ArgumentType, MutateResult< t_ArgumentType> > > &MUTATES, bool IGNORE_UNDEFINED_RESULT, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>MutateCombine( const util::ShPtrList< MutateInterface< t_ArgumentType> > &MUTATES, bool IGNORE_UNDEFINED_RESULT, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_combine.h</td>
        <td>MutateCombine</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_combine.h</td>
        <td></td>
        <td>AddInstance( new MutateCombine< t_ArgumentType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_decision_node.h</td>
        <td>MutateDecisionNode</td>
        <td>AddMutate( const MutateInterface< t_DataType> &MUTATE, const double PROBABILITY)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_decision_node.h</td>
        <td>MutateDecisionNode</td>
        <td>GetObjectProbabilityDistribution() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_decision_node.h</td>
        <td>MutateDecisionNode</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_decision_node.h</td>
        <td>MutateDecisionNode</td>
        <td>MutateDecisionNode( const ObjectProbabilityDistribution< MutateInterface< t_DataType> > &DISTRIBUTION, const std::string &ALIAS = std::string( Ó) )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_decision_node.h</td>
        <td>MutateDecisionNode</td>
        <td>MutateDecisionNode()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_decision_node.h</td>
        <td>MutateDecisionNode</td>
        <td>operator ()( const t_DataType &ARGUMENT) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_interface.h</td>
        <td>MutateInterface</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_move_wrapper.h</td>
        <td>MutateMoveWrapper</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_move_wrapper.h</td>
        <td>MutateMoveWrapper</td>
        <td>MutateMoveWrapper( const coord::MoveInterface &MOVE, const bool DO_HARD_COPY = true )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_move_wrapper.h</td>
        <td>MutateMoveWrapper</td>
        <td>MutateMoveWrapper( const util::ShPtr< coord::MoveInterface> &SP_MOVE, const bool DO_HARD_COPY = true )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_move_wrapper.h</td>
        <td>MutateMoveWrapper</td>
        <td>MutateMoveWrapper()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_move_wrapper.h</td>
        <td>MutateMoveWrapper</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>MutatePerturbation</td>
        <td>GetCurrent() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>MutatePerturbation</td>
        <td>GetStartArgument() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>MutatePerturbation</td>
        <td>InsertPerturbation( const util::ShPtr< MutateInterface< t_ArgumentType> > &MUTATE, const size_t REPETITION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>MutatePerturbation</td>
        <td>IsFinished() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>MutatePerturbation</td>
        <td>MutatePerturbation( const t_ArgumentType &START)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>MutatePerturbation</td>
        <td>MutatePerturbation()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>MutatePerturbation</td>
        <td>Perturb()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>MutatePerturbation</td>
        <td>Reset()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>MutatePerturbation</td>
        <td>SetStartArgument( const t_ArgumentType &ARGUMENT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>SinglePerturbation</td>
        <td>SinglePerturbation( const util::ShPtr< MutateInterface< t_ArgumentType> > &SP_MUTATE, const size_t REPETITION, const t_ArgumentType &ARGUMENT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_perturbation.h</td>
        <td>SinglePerturbation</td>
        <td>SinglePerturbation()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_perturbation.h</td>
        <td></td>
        <td>AddInstance( new MutatePerturbation< t_ArgumentType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_repeat.h</td>
        <td>MutateRepeat</td>
        <td>MutateRepeat( const util::ShPtr< MutateInterface< t_ArgumentType> > &SP_MUTATE, const size_t MIN_NUMBER_REPEATS = 1, const size_t MAX_NUMBER_REPEATS = 0 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_repeat.h</td>
        <td>MutateRepeat</td>
        <td>MutateRepeat()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_repeat.h</td>
        <td>MutateRepeat</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_repeat.h</td>
        <td></td>
        <td>AddInstance( new MutateRepeat< t_ArgumentType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_result.h</td>
        <td>MutateResult</td>
        <td>AddNode( const MutateInterface< t_ArgumentType> &MUTATE_INTERFACE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_result.h</td>
        <td>MutateResult</td>
        <td>GetArgument() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_result.h</td>
        <td>MutateResult</td>
        <td>GetNodes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_result.h</td>
        <td>MutateResult</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_result.h</td>
        <td>MutateResult</td>
        <td>MutateResult( const util::ShPtr< t_ArgumentType> &ARGUMENT, const MutateInterface< t_ArgumentType> &NODE )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_result.h</td>
        <td>MutateResult</td>
        <td>MutateResult( const util::ShPtr< t_ArgumentType> &ARGUMENT, const util::SiPtrList< const MutateInterface< t_ArgumentType> > &MUTATE_LIST )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_result.h</td>
        <td>MutateResult</td>
        <td>MutateResult()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_result.h</td>
        <td>MutateResult</td>
        <td>operator +=( const MutateResult< t_ArgumentType> &MUTATE_RESULT)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_terminate_dependent.h</td>
        <td>MutateTerminateDependent</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_terminate_dependent.h</td>
        <td>MutateTerminateDependent</td>
        <td>MutateTerminateDependent( const storage::List < storage::Pair < util::ShPtr< opti::CriterionInterface< t_ArgumentType, t_ResultType> >, util::ShPtr< MutateInterface< t_ArgumentType> > > > &MUTATES, const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER, const std::string &SCHEME = ( GetStaticClassName< MutateTerminateDependent< t_ArgumentType, t_ResultType> >()), const random::DistributionInterface &RNG = random::GetGlobalRandom() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_terminate_dependent.h</td>
        <td>MutateTerminateDependent</td>
        <td>MutateTerminateDependent()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_terminate_dependent.h</td>
        <td>MutateTerminateDependent</td>
        <td>SetTracker( const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_terminate_dependent.h</td>
        <td>MutateTerminateDependent</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_terminate_dependent.h</td>
        <td></td>
        <td>AddInstance( new MutateTerminateDependent< t_DataType, t_ResultType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_transformation_matrix_3d.h</td>
        <td>MutateTransformationMatrix3D</td>
        <td>MutateTransformationMatrix3D( const double MAX_TRANSALTION, const double MAX_ROTATION_ANGLE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_transformation_matrix_3d.h</td>
        <td>MutateTransformationMatrix3D</td>
        <td>MutateTransformationMatrix3D()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_transformation_matrix_3d.h</td>
        <td>MutateTransformationMatrix3D</td>
        <td>operator ()( const TransformationMatrix3D &TRANSFORMATION_MATRIX3D ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_vector.h</td>
        <td>MutateVector</td>
        <td>MutateVector( const linal::Vector< double> &MUTATE_RANGES, const size_t NUMBER_PARAMS_MUTATED, const bool USE_PERCENTAGE, const bool KEEP_POSITIVE, const size_t &CONSTANT = util::GetUndefinedSize_t() )
</td>
        <td>woetzen, karakam, durhamea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_vector.h</td>
        <td>MutateVector</td>
        <td>MutateVector( const size_t NUMBER_PARAMS, const double MUTATE_RANGE, const size_t NUMBER_PARAMS_MUTATED, const bool USE_PERCENTAGE, const bool KEEP_POSITIVE, const size_t &CONSTANT = util::GetUndefinedSize_t() )
</td>
        <td>woetzen, karakam, durhamea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_mutate_vector.h</td>
        <td>MutateVector</td>
        <td>MutateVector()
</td>
        <td>woetzen, karakam, durhamea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_mutate_vector.h</td>
        <td>MutateVector</td>
        <td>operator ()( const linal::Vector< double> &VECTOR) const
</td>
        <td>woetzen, karakam, durhamea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>Assignment</td>
        <td>Assignment( const Assignment &PAIR)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>Assignment</td>
        <td>Assignment( const Base &PAIR)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>Assignment</td>
        <td>Assignment( const double &FIRST, const t_ObjectType &SECOND )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>Assignment</td>
        <td>Assignment()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>Assignment</td>
        <td>GetScheme() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>Assignment</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>CalculateSum() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>DetermineRandomCase() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>GetData() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>GetSerializer() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>ObjectProbabilityDistribution( const ObjectProbabilityDistribution< t_OtherData> &PROBABILITY_OBJECT )
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>ObjectProbabilityDistribution( const storage::Vector< Assignment> &PROBABILITY_OBJECT_LIST )
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>ObjectProbabilityDistribution()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>PushBack( const Assignment &PROBABILITY_OBJECT_PAIR)
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>PushBack( const double &PROBABILITY, const t_ObjectType &OBJECT)
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_probability_distribution.h</td>
        <td>ObjectProbabilityDistribution</td>
        <td>SetToSum( const double SUM = 1.0)
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>AddImplementation( const t_DataType &OBJECT, const double &PROBABILITY )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>AddImplementation( const util::Implementation< t_DataType> &OBJECT_IMPL, const double &PROBABILITY )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>AddImplementation( const util::ObjectDataLabel &OBJECT_LABEL, const double &PROBABILITY )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>GetMap() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>GetSerializer() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>GetSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>ObjectStochasticSelector( const storage::Map< util::Implementation< t_DataType>, double> &DISTRIBUTION )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>ObjectStochasticSelector()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_object_stochastic_selector.h</td>
        <td>ObjectStochasticSelector</td>
        <td>SelectRandomCase() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_piecewise_function.h</td>
        <td>PiecewiseFunction</td>
        <td>GetRangesFunctions() const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_piecewise_function.h</td>
        <td>PiecewiseFunction</td>
        <td>PiecewiseFunction( const storage::List < storage::Pair< Range< double>, util::ShPtr< FunctionInterfaceSerializable< double, double> > > > &RANGES_FUNCTIONS )
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_piecewise_function.h</td>
        <td>PiecewiseFunction</td>
        <td>PiecewiseFunction()
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_piecewise_function.h</td>
        <td>PiecewiseFunction</td>
        <td>RangesFunctionsValid( const storage::List < storage::Pair< Range< double>, util::ShPtr< FunctionInterfaceSerializable< double, double> > > > &RANGES_FUNCTIONS_VALID )
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_piecewise_function.h</td>
        <td>PiecewiseFunction</td>
        <td>operator ()( const double &X_VALUE) const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_plus_equals.h</td>
        <td>PlusEquals</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_plus_equals.h</td>
        <td>PlusEquals</td>
        <td>GetVerb() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_plus_equals.h</td>
        <td>PlusEquals</td>
        <td>IsSymmetric() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_plus_equals.h</td>
        <td>PlusEquals</td>
        <td>operator ()( t_ArgumentType &LHS, const t_ArgumentType &RHS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>Begin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>Derivative() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>End()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>GetCoefficients() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>GetDegree() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>MakeFromCoefficients( const linal::Vector< double> &COEFFICIENTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>MakeFromCoordinates( const linal::Vector< double> &X_COORDINATES, const linal::Vector< double> &Y_COORDINATES, const size_t &DEGREE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>Polynomial( const t_InputIterator &BEGIN, const t_InputIterator &END)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>Polynomial()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>SetCoefficients( const linal::Vector< double> &COEFFICIENTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_polynomial.h</td>
        <td>Polynomial</td>
        <td>operator ()( const double &ARGUMENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_power_equals.h</td>
        <td>PowerEquals</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_power_equals.h</td>
        <td>PowerEquals</td>
        <td>GetVerb() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_power_equals.h</td>
        <td>PowerEquals</td>
        <td>HasZeroProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_power_equals.h</td>
        <td>PowerEquals</td>
        <td>operator ()( t_ArgumentType &LHS, const t_ArgumentType &RHS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>AsString() const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>CompletingTheSquare( const double A_VALUE, const double B_VALUE, const double C_VALUE )
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>Distribution( const double X_COORD, const double Y_COORD, const double A_VARIABLE )
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>GetA() const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>GetDerivative() const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>GetRoot() const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>GetX() const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>GetY() const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>QuadraticFunction( const double A_VARIABLE_GEN_FORM, const double B_VARIABLE_GEN_FORM, const double C_VARIABLE_GEN_FORM )
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>QuadraticFunction( const storage::VectorND< 2, double> &XY_COORD, const double A_VARIABLE )
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>QuadraticFunction()
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quadratic_function.h</td>
        <td>QuadraticFunction</td>
        <td>operator ()( const double &ARGUMENT) const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>Equal( const double R, const double X, const double Y, const double Z)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>Equal( const double R, const linal::Vector3D &VECTOR3D)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>Norm() const
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>Normalize()
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>Normalized() const
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>Quaternion( const Quaternion &QUATERNION)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>Quaternion( const double &R, const double &i_X, const double &i_Y, const double &i_Z)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>Quaternion( const linal::Vector3D &AXIS, const double ANGLE)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>Quaternion()
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>SetRand()
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>VectorToQuaternion( const linal::Vector3D &)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>operator *=( const double T)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>operator /=( const double T)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>operator =( const Quaternion &QUATERNION)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>operator []( const size_t INDEX)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td>Quaternion</td>
        <td>operator []( const size_t INDEX) const
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td></td>
        <td>Conjugate( const Quaternion &QUATERNION)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td></td>
        <td>operator *( const Quaternion &QUATERNION, const double &T)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td></td>
        <td>operator *( const Quaternion &QUATERNION, const linal::Vector3D &VECTOR3D)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_quaternion.h</td>
        <td></td>
        <td>operator *( const Quaternion &QUAT_1, const Quaternion &QUAT_2)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_quaternion.h</td>
        <td></td>
        <td>operator *( const linal::Vector3D &VECTOR3D, const Quaternion &QUATERNION)
</td>
        <td>staritrd</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>CloseBorders() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>CombineRanges( const Range< t_DataType> &RANGE_1, const Range< t_DataType> &RANGE_2 )
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>Convert() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>DoesOverlap( const Range< t_DataType> &VALUE) const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>FromStream( std::istream &ISTREAM, std::ostream &ERROR_STREAM)
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>GetLabel( const bool &WITH_DATA = false) const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>GetLeftCondition() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>GetMax() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>GetMiddle() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>GetMin() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>GetRightCondition() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>GetString( const util::Format &FORMAT) const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>GetString() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>GetWidth() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>IsEmpty() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>IsWithin( const t_DataType &VALUE) const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>Range( const ConditionLeft LEFT_BORDER_CONDITION, const t_DataType &MIN, const t_DataType &MAX, const ConditionRight RIGHT_BORDER_CONDITION )
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>Range( const t_DataType &MIN, const t_DataType &MAX )
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>Range()
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>Rescale( const t_DataType &VALUE, const Range< t_DataType> &SOURCE_RANGE) const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>SetMax( const t_DataType &MAX)
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>SetMin( const t_DataType &MIN)
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>StandardizeRange() const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>TryRead( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>operator ()( const t_DataType &VALUE, const Range< t_DataType> &SOURCE_RANGE) const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>operator <( const Range< t_DataType> &RANGE_RHS) const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>Range</td>
        <td>operator ==( const Range< t_DataType> &RANGE_RHS) const
</td>
        <td>mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>GetConditionLeftChar() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>GetConditionLeftChars()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>GetConditionRightChar() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>GetConditionRightChars()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>GetLeftCondition() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>GetRightCondition() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>IsClosed() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>IsLeftBorderClosed() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>IsLeftBorderOpen() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>IsOpen() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>IsRightBorderClosed() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>IsRightBorderOpen() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>RangeBorders( const ConditionLeft LEFT_BORDER_CONDITION, const ConditionRight RIGHT_BORDER_CONDITION )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>RangeBorders()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>Set( const ConditionLeft &LEFT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>Set( const ConditionRight &RIGHT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range.h</td>
        <td>RangeBorders</td>
        <td>operator ==( const RangeBorders &OTHER) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>AsString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>FromString( const std::string &STRING, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>GetCompleteRange()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>GetLabel( const bool &WITH_DATA = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>GetMappedSubset( const Range< t_DataType> &SELECTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>GetMax() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>GetMin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>GetRanges() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>IsEmpty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>IsWithin( const t_DataType &VALUE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>RangeSet( const Range< t_DataType> &RANGE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>RangeSet( const t_InputIterator &BEGIN, const t_InputIterator &END)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>RangeSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>TryRead( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>operator +=( const Range< t_DataType> &RANGE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>operator -=( const Range< t_DataType> &RANGE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_range_set.h</td>
        <td>RangeSet</td>
        <td>operator ==( const RangeSet< t_DataType> &B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>Point</td>
        <td>GetContingencyMatrix( const Point &FINAL_POINT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>Point</td>
        <td>GetCutoff() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>Point</td>
        <td>GetNumberFalsePositives() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>Point</td>
        <td>GetNumberPredictedPositives() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>Point</td>
        <td>GetNumberTruePositives() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>Point</td>
        <td>Point( const size_t &FP = 0, const size_t &TP = 0, const double &CUTOFF = 0.0)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>Point</td>
        <td>Update( const bool &RESULT, const double &CUTOFF)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>ContingencyMatrixFraction( const double FRACTION) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>CutoffFraction( const double FRACTION) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>GetLocalPPVCurve() const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>GetMaxima( const util::FunctionInterfaceSerializable< ContingencyMatrix, double> &MEASURE ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>GetNumberActualNegatives() const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>GetNumberActualPositives() const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>GetNumberResults() const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>GetSortedCounts() const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>GetThinnedRocCurvePeriodicity( const size_t PERIODICITY) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>GetThinnedRocCurveTotal( const size_t TOTAL_NUMBER_ENTRIES) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Initialize( const storage::List< storage::Pair< double, bool> > &RESULTS_CLASSIFIED)
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Integral( const FunctionInterfaceSerializable< double, double> &WEIGHTING_FUNCTION, const bool ROC_X_AXIS_LOG10_SCALING = false ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Integral( const FunctionInterfaceSerializable< double, double> &WEIGHTING_FUNCTION, const function::MemberConst< ContingencyMatrix, double> &ROC_X_AXIS, const function::MemberConst< ContingencyMatrix, double> &ROC_Y_AXIS, const Range< double> &ROC_X_AXIS_FRACTION_CUTOFF = Range< double>( 0.0, 1.0), const bool ROC_X_AXIS_LOG10_SCALING = bool( false) ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Integral( const double FRACTION) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Integral( const double FRACTION, const FunctionInterfaceSerializable< double, double> &WEIGHTING_FUNCTION, const bool ROC_X_AXIS_LOG10_SCALING = false ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Integral( const double FRACTION, const FunctionInterfaceSerializable< double, double> &WEIGHTING_FUNCTION, const function::MemberConst< ContingencyMatrix, double> &ROC_X_AXIS, const function::MemberConst< ContingencyMatrix, double> &ROC_Y_AXIS, const bool ROC_X_AXIS_LOG10_SCALING = bool( false) ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Integral( const double FRACTION, const function::MemberConst< ContingencyMatrix, double> &ROC_X_AXIS, const function::MemberConst< ContingencyMatrix, double> &ROC_Y_AXIS, const bool ROC_X_AXIS_LOG10_SCALING = bool( false) ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Integral( const function::MemberConst< ContingencyMatrix, double> &ROC_X_AXIS, const function::MemberConst< ContingencyMatrix, double> &ROC_Y_AXIS, const Range< double> &ROC_X_AXIS_FRACTION_CUTOFF = Range< double>( 0.0, 1.0), const bool ROC_X_AXIS_LOG10_SCALING = bool( false) ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Integral( const function::MemberConst< ContingencyMatrix, double> &ROC_X_AXIS, const function::MemberConst< ContingencyMatrix, double> &ROC_Y_AXIS, const bool ROC_X_AXIS_LOG10_SCALING = bool( false) ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>Integral() const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>ROCCurve( const storage::List< storage::Pair< double, bool> > &TEST_RESULTS_CLASSIFIED)
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>ROCCurve( const storage::List< storage::Pair< double, double> > &TEST_RESULTS, const FunctionInterfaceSerializable< double, bool> &UNARY_CLASSIFIER )
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>ROCCurve( const storage::List< storage::Pair< double, double> > &TEST_RESULTS, const double THRESHOLD )
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>ROCCurve( storage::List< storage::Pair< double, double> > &TEST_RESULTS, const double THRESHOLD, bool POSITIVES_ABOVE_THRESHOLD )
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>ROCCurve()
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>ReadPlottingTable( std::istream &ISTREAM)
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>ToMap() const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>WritePlottingTable( std::ostream &OSTREAM) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>WriteRatePlottingTable( std::ostream &OSTREAM, const util::Format &FORMAT = util::Format().FFP( 3).W( 5).ForceW() ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>WriteRatePlottingTableComplete( const std::string &DATA_FILENAME, const storage::Vector< std::string> &MEASURES ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_roc_curve.h</td>
        <td>ROCCurve</td>
        <td>WriteRatePlottingTableGeneric( std::ostream &OSTREAM, const function::MemberConst< ContingencyMatrix, double> &ROC_X_AXIS, const function::MemberConst< ContingencyMatrix, double> &ROC_Y_AXIS, const Range< double> &ROC_X_AXIS_RANGE = Range< double>( 0.0, 1.0), const util::Format &FORMAT = util::Format().W( 5).ForceW(), const std::string &PLOTTING_TABLE_TITLE = std::string( Ó) ) const
</td>
        <td>butkiem1, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>GetAngle() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>GetMatrix() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>Invert()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>MakeGivens( const double &A, const double &B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>RotationMatrix2D( const double &ANGLE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>RotationMatrix2D( const linal::Matrix2x2< double> &ROTATION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>RotationMatrix2D()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>SetAngle( const double &THETA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>SetFromCosSin( const double &COS, const double &SIN)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>SetRand( const double MAX_ROTATIONANGLE = g_Pi)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT, const util::Format &FORMAT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_2d.h</td>
        <td>RotationMatrix2D</td>
        <td>operator *=( const RotationMatrix2D &MATRIX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>CreateZXZ( const double ALPHA, const double BETA, const double GAMMA)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>EffectiveRotationAngle() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>EulerAnglesXYZ() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>EulerAnglesZXZ() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>GetMatrix() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>GetRotationAxis() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>RotationMatrix3D( const coord::Axis &AXIS, const double &ANGLE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>RotationMatrix3D( const coord::Axis AXIS[ 3], const double ANGLE[ 3])
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>RotationMatrix3D( const double PHI, const double PSI, const double THETA)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>RotationMatrix3D( const linal::Matrix3x3< double> &ROTATION)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>RotationMatrix3D( const linal::Vector3D &AXIS, const double ANGLE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>RotationMatrix3D()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>SetRand( const double MAX_ROTATIONANGLE = g_Pi)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT, const util::Format &FORMAT) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_rotation_matrix_3d.h</td>
        <td>RotationMatrix3D</td>
        <td>operator *=( const RotationMatrix3D &MATRIX)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>AddWeightedObservation( const t_ArgumentType &VALUE, double WEIGHT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>FUNCTION() const const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>GetAverage() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>GetWeight() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>RunningAverage( const t_AverageType &INITIAL_AVERAGE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>RunningAverage()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>SetWeight( const double &WEIGHT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>Zero( t_DataType &SCALAR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>Zero( t_DataType &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>operator +=( const RunningAverage &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>operator +=( const t_ArgumentType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>operator -=( const t_ArgumentType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average.h</td>
        <td>RunningAverage</td>
        <td>operator const t_AverageType &() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average_sd.h</td>
        <td>LessThanAbsoluteMean</td>
        <td>operator ()( const RunningAverageSD< t_AverageType> &A, const RunningAverageSD< t_AverageType> &B) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average_sd.h</td>
        <td>LessThanCounts</td>
        <td>operator ()( const RunningAverageSD< t_AverageType> &A, const RunningAverageSD< t_AverageType> &B) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>AddEachElement( const t_ArgumentType &CONTAINER, double WEIGHT = 1.0)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>AddWeightedObservation( const t_ArgumentType &VALUE, double WEIGHT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>FUNCTION() const const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>GetAverage() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>GetSampleStandardDeviation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>GetStandardDeviation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>GetVariance() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>GetWeight() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>RunningAverageSD()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>operator +=( const t_ArgumentType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_average_sd.h</td>
        <td>RunningAverageSD</td>
        <td>operator -=( const t_ArgumentType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_min_max.h</td>
        <td>RunningMinMax</td>
        <td>FUNCTION() const const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_min_max.h</td>
        <td>RunningMinMax</td>
        <td>GetMax() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_min_max.h</td>
        <td>RunningMinMax</td>
        <td>GetMin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_min_max.h</td>
        <td>RunningMinMax</td>
        <td>GetRange() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_min_max.h</td>
        <td>RunningMinMax</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_min_max.h</td>
        <td>RunningMinMax</td>
        <td>RunningMinMax( const t_AverageType &INITIAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_min_max.h</td>
        <td>RunningMinMax</td>
        <td>RunningMinMax()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_min_max.h</td>
        <td>RunningMinMax</td>
        <td>operator +=( const t_ArgumentType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_statistics.h</td>
        <td>RunningStatistics</td>
        <td>AddInstances()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_statistics.h</td>
        <td>RunningStatistics</td>
        <td>AddWeightedInstances()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>Add( t_DataType &SCALAR_SUM, const t_OtherDataType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>Add( t_DataType &VECTOR_SUM, const t_OtherDataType &SEQUENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>AddProduct( t_DataType &SCALAR_SUM, const t_OtherDataType &VALUE, const double &WEIGHT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>AddProduct( t_DataType &VECTOR_SUM, const t_OtherDataType &SEQUENCE, const double &WEIGHT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>AddWeightedObservation( const t_ArgumentType &VALUE, double WEIGHT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>FUNCTION() const const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>GetSum() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>RunningSum( const t_SumType &AVERAGE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>RunningSum()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>Subtract( t_DataType &SCALAR_SUM, const t_OtherDataType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>Subtract( t_DataType &VECTOR_SUM, const t_OtherDataType &SEQUENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>operator +=( const t_ArgumentType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_running_sum.h</td>
        <td>RunningSum</td>
        <td>operator -=( const t_ArgumentType &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_smooth_data.h</td>
        <td>SmoothData</td>
        <td>SmoothMatrix( const linal::MatrixConstInterface< t_DataType> &DATA, const double FRACTION, const bool SMOOTH_BORDERS = false )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_smooth_data.h</td>
        <td>SmoothData</td>
        <td>SmoothVector( const linal::VectorConstInterface< t_DataType> &DATA, const double FRACTION, const bool SMOOTH_BORDERS = false)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>Correlation( t_InputIterator BEGIN_A, const t_InputIterator END_A, t_InputIterator BEGIN_B, const t_InputIterator END_B )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>CorrelationCoefficient( t_InputIterator BEGIN_A, const t_InputIterator END_A, t_InputIterator BEGIN_B, const t_InputIterator END_B )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>CorrelationSpearman( const t_InputIterator BEGIN_A, const t_InputIterator END_A, const t_InputIterator BEGIN_B, const t_InputIterator END_B )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>Covariance( t_InputIterator BEGIN_A, const t_InputIterator END_A, t_InputIterator BEGIN_B, const t_InputIterator END_B )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>CumulativeEuclidian( t_InputIterator BEGIN_A, const t_InputIterator END_A, t_InputIterator BEGIN_B, const t_InputIterator END_B )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>GetKolmogorovSmirnovCriticalValue( const double &ALPHA, const size_t &N1, const size_t &N2)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>IsDefined( t_InputIterator BEGIN, const t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>KolmogorovSmirnov( const t_InputIterator &BEGIN_A, const t_InputIterator &END_A, const t_InputIterator &BEGIN_B, const t_InputIterator &END_B, const double &ALPHA = 0.05 )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>MaximumIndex( t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>MaximumValue( t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>Mean( const t_InputIterator BEGIN, const t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>MinimumIndex( t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>MinimumValue( t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>Norm( t_InputIterator BEGIN, const t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>Normalize( t_InputIterator BEGIN, const t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>PointerToMaximumValue( t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>PointerToMinimumValue( t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>RSquared( t_InputIterator BEGIN_A, const t_InputIterator END_A, t_InputIterator BEGIN_B, const t_InputIterator END_B )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>ScalarProduct( t_InputIterator BEGIN_A, const t_InputIterator END_A, t_InputIterator BEGIN_B, const t_InputIterator END_B )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>SetRand( t_InputIterator BEGIN, const t_InputIterator END, const t_DataType MIN, const t_DataType MAX )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>SetToSum( t_InputIterator BEGIN, const t_InputIterator END, const t_DataType SUM = 1 )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>SquareNorm( t_InputIterator BEGIN, const t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>StandardDeviation( t_InputIterator BEGIN, const t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>Sum( const t_InputIterator BEGIN, const t_InputIterator END, const typename std::iterator_traits< t_InputIterator>::value_type &START_VALUE = ( typename std::iterator_traits< t_InputIterator>::value_type)( 0))
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_statistics.h</td>
        <td>Statistics</td>
        <td>Variance( t_InputIterator BEGIN, const t_InputIterator END)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>SumFunction( const Base &BASE)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>SumFunction( const std::string &SCHEME = Ó)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>SumFunction( const t_Interface &FUNCTION, const double &COEFFICIENT, const t_ResultType &ABS_CONST )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>SumFunction( const t_Interface &FUNCTION_A, const t_Interface &FUNCTION_B, const double &COEFFICIENT_A, const double &COEFFICIENT_B, const t_ResultType &ABS_CONST )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>SumFunction( const t_ResultType &ABS_CONST)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>SumFunction( const util::Implementation< t_Interface> &SP_FUNCTION, const double &COEFFICIENT, const t_ResultType &ABS_CONST )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>SumFunction( const util::Implementation< t_Interface> &SP_FUNCTION_A, const util::Implementation< t_Interface> &SP_FUNCTION_B, const double &COEFFICIENT_A, const double &COEFFICIENT_B, const t_ResultType &ABS_CONST )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator *=( const double &SCALAR )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator +=( const Base &SUM_FUNCTION )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator +=( const t_Interface &FUNCTION)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator +=( const t_ResultType &VALUE )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator -=( const Base &SUM_FUNCTION )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator -=( const t_Interface &FUNCTION)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator -=( const t_ResultType &VALUE )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator /=( const double &SCALAR )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator =( const Base &SUM_FUNCTION)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator =( const t_Interface &FUNCTION)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function.h</td>
        <td></td>
        <td>AddInstance( new SumFunction< t_ArgumentType, t_ResultType>())
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_interface.h</td>
        <td>SumFunctionInterface</td>
        <td>GetValueTableVerticalColumnNames()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_interface.h</td>
        <td>Term</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_interface.h</td>
        <td>Term</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_interface.h</td>
        <td>Term</td>
        <td>Term( const Base &PAIR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_interface.h</td>
        <td>Term</td>
        <td>Term( const Term &PAIR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_interface.h</td>
        <td>Term</td>
        <td>Term( const double &FIRST, const util::Implementation< t_Interface> &SECOND )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_interface.h</td>
        <td>Term</td>
        <td>Term()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>CreateValueTableHorizontal( const t_ArgumentType &ARGUMENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>CreateValueTableVertical( const t_ArgumentType &ARGUMENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>GetAbsolute() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>GetFunction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>GetFunctionSchemes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>GetTerm( const std::string &SCHEME) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>GetValueTableVerticalColumnNames()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>NewOperand( const t_Interface &FUNCTION, const double &COEFFICIENT = double( 1) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>NewOperand( const util::Implementation< t_Interface> &SP_FUNCTION, const double &COEFFICIENT = double( 1) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>SetCoefficient( const std::string &SCHEME, const double &COEFFICIENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>SumFunctionMixin( const std::string &SCHEME = Ó)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>SumFunctionMixin( const t_Interface &FUNCTION, const double &COEFFICIENT, const t_ResultType &ABS_CONST )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>SumFunctionMixin( const t_Interface &FUNCTION_A, const t_Interface &FUNCTION_B, const double &COEFFICIENT_A, const double &COEFFICIENT_B, const t_ResultType &ABS_CONST )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>SumFunctionMixin( const t_ResultType &ABS_CONST)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>SumFunctionMixin( const util::Implementation< t_Interface> &SP_FUNCTION, const double &COEFFICIENT, const t_ResultType &ABS_CONST )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>SumFunctionMixin( const util::Implementation< t_Interface> &SP_FUNCTION_A, const util::Implementation< t_Interface> &SP_FUNCTION_B, const double &COEFFICIENT_A, const double &COEFFICIENT_B, const t_ResultType &ABS_CONST )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>WriteDetailedSchemeAndValues( const t_ArgumentType &ARGUMENT, std::ostream &OSTREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator *=( const double &SCALAR )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator +=( const SumFunctionMixin &SUM_FUNCTION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator +=( const t_Interface &FUNCTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator +=( const t_ResultType &VALUE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator -() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator -=( const SumFunctionMixin &SUM_FUNCTION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator -=( const t_Interface &FUNCTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator -=( const t_ResultType &VALUE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator /=( const double &SCALAR )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator =( const SumFunctionMixin &SUM_FUNCTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td>SumFunctionMixin</td>
        <td>operator =( const t_Interface &FUNCTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator *( const SumFunctionMixin< t_Interface> &SUM_FUNCTION, const double &SCALAR )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator *( const double &SCALAR, const SumFunctionMixin< t_Interface> &SUM_FUNCTION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator +( const SumFunctionMixin< t_Interface> &FUNCTION_A, const SumFunctionMixin< t_Interface> &FUNCTION_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator +( const SumFunctionMixin< t_Interface> &SUM_FUNCTION, const typename SumFunctionMixin< t_Interface>::t_ResultType &VALUE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator +( const SumFunctionMixin< t_Interface> &SUM_FUNCTION_A, const t_Interface &FUNCTION_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator +( const t_Interface &FUNCTION_A, const SumFunctionMixin< t_Interface> &SUM_FUNCTION_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator +( const typename SumFunctionMixin< t_Interface>::t_ResultType &VALUE, const SumFunctionMixin< t_Interface> &SUM_FUNCTION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator -( const SumFunctionMixin< t_Interface> &FUNCTION_A, const SumFunctionMixin< t_Interface> &FUNCTION_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator -( const SumFunctionMixin< t_Interface> &SUM_FUNCTION, const typename SumFunctionMixin< t_Interface>::t_ResultType &VALUE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator -( const SumFunctionMixin< t_Interface> &SUM_FUNCTION_A, const t_Interface &FUNCTION_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator -( const t_Interface &FUNCTION_A, const SumFunctionMixin< t_Interface> &SUM_FUNCTION_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator -( const typename SumFunctionMixin< t_Interface>::t_ResultType &VALUE, const SumFunctionMixin< t_Interface> &SUM_FUNCTION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_sum_function_mixin.h</td>
        <td></td>
        <td>operator /( const SumFunctionMixin< t_Interface> &SUM_FUNCTION, const double &SCALAR )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>Begin()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>Begin() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>CreatePaddedTensor( const size_t LAYER_PADDING, const size_t ROW_PADDING, const size_t COL_PADDING, const t_DataType &FILL_VALUE = t_DataType( 0) ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>End()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>End() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>GetNumberCols() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>GetNumberRows() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>GetSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>GetValues()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>GetValues() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>IsEmpty() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>IsQubic() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>IsTensorND( const size_t N) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>Normalize()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>NumberLayers() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>ReplaceLayer( const size_t LAYER, const linal::MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>SetValue( const t_DataType &VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>SetZero()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>SubTensor( const size_t NUM_LAYER, const size_t NUM_ROW, const size_t NUM_COL, const size_t LAYER = 0, const size_t ROW = 0, const size_t COL = 0 ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>Tensor( const Tensor< t_DataType> &PARENT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>Tensor( const size_t LAYERS = 0, const size_t ROWS = 0, const size_t COLS = 0, const t_DataType &VALUE = t_DataType())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>Tensor( const size_t LAYERS, const size_t ROWS, const size_t COLS, const t_DataType *DATA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator ()( const size_t &LAYER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator ()( const size_t &LAYER) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator ()( const size_t LAYER, const size_t ROW, const size_t COL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator ()( const size_t LAYER, const size_t ROW, const size_t COL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator *=( const t_DataType &VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator +=( const t_DataType &VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator -=( const t_DataType &VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator /=( const t_DataType &VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator =( const Tensor< t_DataType> &TENSOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator =( const t_DataType &VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator ==( const Tensor< t_DataType> &TENSOR_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator []( const size_t LAYER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tensor.h</td>
        <td>Tensor</td>
        <td>operator []( const size_t LAYER) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tensor.h</td>
        <td></td>
        <td>AddInstance( new Tensor< t_DataType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_times_equals.h</td>
        <td>TimesEquals</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_times_equals.h</td>
        <td>TimesEquals</td>
        <td>GetVerb() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_times_equals.h</td>
        <td>TimesEquals</td>
        <td>HasZeroProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_times_equals.h</td>
        <td>TimesEquals</td>
        <td>IsSymmetric() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_times_equals.h</td>
        <td>TimesEquals</td>
        <td>TimesEquals()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_times_equals.h</td>
        <td>TimesEquals</td>
        <td>operator ()( t_ArgumentType &LHS, const t_ArgumentType &RHS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>GetAxis( const coord::Axis &AXIS) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>GetMatrix() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>GetOrigin() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>GetRotation() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>GetTranslation() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>Invert()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>IsDefined() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>SetAxis( const coord::Axis &AXIS, const linal::Vector3D &NEW_AXIS)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>SetMatrix( const linal::Matrix< double> &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>SetOrigin( const linal::Vector3D &ORIGIN)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>SetRotation( const RotationMatrix3D &ROTATION)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>SetTranslation( const linal::Vector3D &TRANSLATION)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>SetUnit()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( TransformationMatrix3D && MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const RotationMatrix3D &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const TransformationMatrix3D &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const coord::Axis &AXIS, const double &ANGLE)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const coord::Axis AXES[ 3], const double ANGLE[ 3])
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const coord::LineSegment3D &A, const coord::LineSegment3D &B)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const coord::LineSegment3D &ROTATION_AXIS, const linal::Vector3D &ROTATION_ORIGIN, const double ROTATION )
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const double &X, const double &Y, const double &Z)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const linal::Matrix< double> &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const linal::Vector3D &TRANSLATION)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const linal::Vector3D &XAXIS, const linal::Vector3D &YAXIS, const linal::Vector3D &ZAXIS, const linal::Vector3D &ORIGIN )
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const linal::Vector< double> &VECTOR)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D( const util::UndefinedObject DEFINITION_STATE)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>TransformationMatrix3D()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT, const util::Format &FORMAT) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator ()( const RotationMatrix3D &ROTATION)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator ()( const TransformationMatrix3D &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator ()( const coord::Axis &AXIS, const double &ANGLE)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator ()( const coord::Axis AXES[ 3], const double ANGLE[ 3])
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator ()( const double &X, const double &Y, const double &Z)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator ()( const linal::Vector3D &TRANSLATION)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator *=( const TransformationMatrix3D &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator *=( const double &SCALAR)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator +=( const TransformationMatrix3D &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator /=( const double &SCALAR)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator =( TransformationMatrix3D && MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td>TransformationMatrix3D</td>
        <td>operator =( const TransformationMatrix3D &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td></td>
        <td>Inverse( const TransformationMatrix3D &MATRIX)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td></td>
        <td>SimilarWithinTolerance( const TransformationMatrix3D &TRANSFORMATIONMATRIX3D_A, const TransformationMatrix3D &TRANSFORMATIONMATRIX3D_B, const double TRANSLATION_TOLERANCE, const double ROTATION_TOLERANCE_RAD )
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td></td>
        <td>operator !=( const TransformationMatrix3D &TRANSFORMATIONMATRIX3D_A, const TransformationMatrix3D &TRANSFORMATIONMATRIX3D_B )
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_transformation_matrix_3d.h</td>
        <td></td>
        <td>operator ==( const TransformationMatrix3D &TRANSFORMATIONMATRIX3D_A, const TransformationMatrix3D &TRANSFORMATIONMATRIX3D_B )
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tricubic_spline.h</td>
        <td>TricubicSpline</td>
        <td>F( const double x, const double y, const double z) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tricubic_spline.h</td>
        <td>TricubicSpline</td>
        <td>FdF( const double x, const double y, const double z) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tricubic_spline.h</td>
        <td>TricubicSpline</td>
        <td>Train( const SplineBorderType BORDER[ 3], const double START[ 3], const double DELTA[ 3], const Tensor< double> &RESULTS, const bool LINCONT[ 3], const storage::Pair< double, double> FIRSTBE[ 3] )
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tricubic_spline.h</td>
        <td>TricubicSpline</td>
        <td>dFdx( const double x, const double y, const double z) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_tricubic_spline.h</td>
        <td>TricubicSpline</td>
        <td>dFdy( const double x, const double y, const double z) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_tricubic_spline.h</td>
        <td>TricubicSpline</td>
        <td>dFdz( const double x, const double y, const double z) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_trigonometric_transition.h</td>
        <td>TrigonometricTransition</td>
        <td>AsString() const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_trigonometric_transition.h</td>
        <td>TrigonometricTransition</td>
        <td>GetTransitionBeginXAxis() const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_trigonometric_transition.h</td>
        <td>TrigonometricTransition</td>
        <td>GetTransitionBeginYAxis() const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_trigonometric_transition.h</td>
        <td>TrigonometricTransition</td>
        <td>GetTransitionEndXAxis() const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_trigonometric_transition.h</td>
        <td>TrigonometricTransition</td>
        <td>GetTransitionEndYAxis() const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_trigonometric_transition.h</td>
        <td>TrigonometricTransition</td>
        <td>TrigonometricTransition( const double X0, const double X1, const double Y0, const double Y1 )
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_trigonometric_transition.h</td>
        <td>TrigonometricTransition</td>
        <td>TrigonometricTransition()
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_trigonometric_transition.h</td>
        <td>TrigonometricTransition</td>
        <td>operator ()( const double &X) const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_z_score.h</td>
        <td>ZScore</td>
        <td>GetDefaultScheme()
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_z_score.h</td>
        <td>ZScore</td>
        <td>GetMean() const
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_z_score.h</td>
        <td>ZScore</td>
        <td>GetScheme() const
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_z_score.h</td>
        <td>ZScore</td>
        <td>GetSigma() const
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_z_score.h</td>
        <td>ZScore</td>
        <td>ZScore( const double MEAN, const double SIGMA, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_z_score.h</td>
        <td>ZScore</td>
        <td>ZScore()
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_math_z_score.h</td>
        <td>ZScore</td>
        <td>operator ()( const double &ARGUMENT) const
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_math_z_score.h</td>
        <td>ZScore</td>
        <td>operator *=( const double WEIGHT)
</td>
        <td>bitterd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_approximator.h</td>
        <td>Approximator</td>
        <td>ApproximateReturnCopy( const t_ArgumentType &INITIAL_ARGUMENT )
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_approximator.h</td>
        <td>Approximator</td>
        <td>Approximator( const math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> &OBJECTIVE, const math::MutateInterface< t_ArgumentType> &MUTATE, const Metropolis< t_ResultType> &METROPOLIS, const opti::CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION, const double &REJECTED_STEP_REVERTS_TO_BEST_PROB = 1.0 )
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_approximator.h</td>
        <td>Approximator</td>
        <td>Approximator( const math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> &OBJECTIVE, const math::MutateInterface< t_ArgumentType> &MUTATE, const Metropolis< t_ResultType> &METROPOLIS, const opti::CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION, const t_ArgumentType &INITIAL_ARGUMENT, const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER = opti::Tracker< t_ArgumentType, t_ResultType>( opti::e_SmallerIsBetter), const double &REJECTED_STEP_REVERTS_TO_BEST_PROB = 1.0 )
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_approximator.h</td>
        <td>Approximator</td>
        <td>Approximator( const util::ShPtr< math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> > &OBJECTIVE, const util::ShPtr< math::MutateInterface< t_ArgumentType> > &MUTATE, const Metropolis< t_ResultType> &METROPOLIS, const opti::CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION, const t_ArgumentType &INITIAL_ARGUMENT, const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER = opti::Tracker< t_ArgumentType, t_ResultType>( opti::e_SmallerIsBetter), const bool &REJECTED_STEP_REVERTS_TO_BEST_PROB = 1.0 )
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_approximator.h</td>
        <td>Approximator</td>
        <td>Approximator()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_approximator.h</td>
        <td>Approximator</td>
        <td>CanContinue() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_approximator.h</td>
        <td>Approximator</td>
        <td>GetMutator() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_approximator.h</td>
        <td>Approximator</td>
        <td>GetObjective() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_approximator.h</td>
        <td>Approximator</td>
        <td>Next()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_metropolis.h</td>
        <td>Metropolis</td>
        <td>Evaluate( const t_ResultType &PREVIOUS_RESULT, const t_ResultType &CURRENT_RESULT, const opti::TrackerBase &TRACKER )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_metropolis.h</td>
        <td>Metropolis</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_metropolis.h</td>
        <td>Metropolis</td>
        <td>GetTemperatureHistory() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_metropolis.h</td>
        <td>Metropolis</td>
        <td>Metropolis( const util::ShPtr< TemperatureInterface> &SP_TEMPERATURE_INTERFACE, const bool KEEP_HISTORY = false, const double MINIMAL_CHANGE = double( 0.0) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_metropolis.h</td>
        <td>Metropolis</td>
        <td>Metropolis()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_metropolis.h</td>
        <td>Metropolis</td>
        <td>Reset()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_metropolis.h</td>
        <td></td>
        <td>AddInstance( new Metropolis< t_ResultType>())
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>AddFinalFrame( const std::string &FILE_NAME, const storage::Table< double> &LABEL )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>AddFrame( const std::string &FILE_NAME, const opti::StepStatus &STEP_STATUS, const storage::Table< double> &LABEL )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>FFMpegCommandLine() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>GetScriptFileExtension() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>Initialize( const std::string &PREFIX, const storage::Vector< std::string> &COL_NAMES, const storage::Vector< std::string> &ROW_NAMES, const size_t WIDTH, const size_t HEIGHT, const bool ENABLE_RAY )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>MoviePrinterChimera()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>Reset( const std::string &PREFIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>SetStartFrame( const std::string &FILE_NAME, const bool KEEP_FRAME_UP )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>SetWaterMark( const std::string &WATERMARK)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_chimera.h</td>
        <td>MoviePrinterChimera</td>
        <td>WriteScript( std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_interface.h</td>
        <td>MoviePrinterInterface</td>
        <td>GetDefaultWatermark()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_interface.h</td>
        <td>MoviePrinterInterface</td>
        <td>GetFinalWaitTime()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_interface.h</td>
        <td>MoviePrinterInterface</td>
        <td>GetFlagMoviePrinter()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_interface.h</td>
        <td>MoviePrinterInterface</td>
        <td>GetParameterMovieHeight()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_interface.h</td>
        <td>MoviePrinterInterface</td>
        <td>GetParameterMoviePrefix()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_interface.h</td>
        <td>MoviePrinterInterface</td>
        <td>GetParameterMoviePrinterType()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_interface.h</td>
        <td>MoviePrinterInterface</td>
        <td>GetParameterMovieWidth()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_interface.h</td>
        <td>MoviePrinterInterface</td>
        <td>GetParameterRayTrace()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>AddFinalFrame( const std::string &FILE_NAME, const storage::Table< double> &LABEL )
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>AddFrame( const std::string &FILE_NAME, const opti::StepStatus &STEP_STATUS, const storage::Table< double> &LABEL )
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>FFMpegCommandLine() const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>GetScriptFileExtension() const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>Initialize( const std::string &PREFIX, const storage::Vector< std::string> &COL_NAMES, const storage::Vector< std::string> &ROW_NAMES, const size_t WIDTH, const size_t HEIGHT, const bool ENABLE_RAY )
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>MoviePrinterPymol()
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>Reset( const std::string &PREFIX)
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>SetStartFrame( const std::string &FILE_NAME, const bool KEEP_FRAME_UP )
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>SetWaterMark( const std::string &WATERMARK)
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_movie_printer_pymol.h</td>
        <td>MoviePrinterPymol</td>
        <td>WriteScript( std::ostream &OSTREAM ) const
</td>
        <td>woetzen, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_movie_printers.h</td>
        <td></td>
        <td>GetMoviePrinters()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_add.h</td>
        <td>MutateLoopAdd</td>
        <td>GetDefaultLibraryPath()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_add.h</td>
        <td>MutateLoopAdd</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_add.h</td>
        <td>MutateLoopAdd</td>
        <td>MutateLoopAdd( const std::string &LOOP_LIBRARY_FILENAME = GetDefaultLibraryPath())
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_add.h</td>
        <td>MutateLoopAdd</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_add.h</td>
        <td>MutateLoopAdd</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_add_resize.h</td>
        <td>MutateLoopAddResize</td>
        <td>GetDefaultLibraryPath()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_add_resize.h</td>
        <td>MutateLoopAddResize</td>
        <td>GetDefaultMinSizes()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_add_resize.h</td>
        <td>MutateLoopAddResize</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_add_resize.h</td>
        <td>MutateLoopAddResize</td>
        <td>MutateLoopAddResize( const std::string &LOOP_LIBRARY_FILENAME = GetDefaultLibraryPath(), const storage::VectorND< 2, size_t> MIN_SIZES = GetDefaultMinSizes() )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_add_resize.h</td>
        <td>MutateLoopAddResize</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_add_resize.h</td>
        <td>MutateLoopAddResize</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_fragment_add.h</td>
        <td>MutateLoopFragmentAdd</td>
        <td>GetDefaultLibraryPath()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_fragment_add.h</td>
        <td>MutateLoopFragmentAdd</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_fragment_add.h</td>
        <td>MutateLoopFragmentAdd</td>
        <td>MutateLoopFragmentAdd( const std::string &LOOP_LIBRARY_FILENAME = GetDefaultLibraryPath())
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_fragment_add.h</td>
        <td>MutateLoopFragmentAdd</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_fragment_add.h</td>
        <td>MutateLoopFragmentAdd</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_fragment_replace.h</td>
        <td>MutateLoopFragmentReplace</td>
        <td>GetDefaultLibraryPath()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_fragment_replace.h</td>
        <td>MutateLoopFragmentReplace</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_fragment_replace.h</td>
        <td>MutateLoopFragmentReplace</td>
        <td>MutateLoopFragmentReplace( const std::string &LOOP_LIBRARY_FILENAME = GetDefaultLibraryPath())
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_fragment_replace.h</td>
        <td>MutateLoopFragmentReplace</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_fragment_replace.h</td>
        <td>MutateLoopFragmentReplace</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_remove.h</td>
        <td>MutateLoopRemove</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_remove.h</td>
        <td>MutateLoopRemove</td>
        <td>MutateLoopRemove()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_remove.h</td>
        <td>MutateLoopRemove</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_remove.h</td>
        <td>MutateLoopRemove</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_replace.h</td>
        <td>MutateLoopReplace</td>
        <td>GetDefaultLibraryPath()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_replace.h</td>
        <td>MutateLoopReplace</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_replace.h</td>
        <td>MutateLoopReplace</td>
        <td>MutateLoopReplace( const std::string &LOOP_LIBRARY_FILENAME = GetDefaultLibraryPath())
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutate_loop_replace.h</td>
        <td>MutateLoopReplace</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutate_loop_replace.h</td>
        <td>MutateLoopReplace</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_mutates.h</td>
        <td>Mutates</td>
        <td>GetInstance()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_mutates.h</td>
        <td>Mutates</td>
        <td>Initialize()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_optimization_ccd.h</td>
        <td>OptimizationCCD</td>
        <td>OptimizationCCD( const score::ProteinModelScoreSum &SCORE_FUNCTION, const math::MutateInterface< assemble::ProteinModel> &MUTATES, const opti::CriterionInterface< assemble::ProteinModel, double> &CRITERION, const Metropolis< double> &METROPOLIS )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_optimization_ccd.h</td>
        <td>OptimizationCCD</td>
        <td>OptimizationCCD()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_optimization_docking.h</td>
        <td>OptimizationDocking</td>
        <td>GetQualityMeasures() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_optimization_docking.h</td>
        <td>OptimizationDocking</td>
        <td>GetScoreFunction() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_optimization_docking.h</td>
        <td>OptimizationDocking</td>
        <td>GetSerializer() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_optimization_docking.h</td>
        <td>OptimizationDocking</td>
        <td>OptimizationDocking( const score::ProteinModelScoreSum &SCORE_FUNCTION, const math::MutateInterface< assemble::ProteinModel> &MUTATES, const opti::CriterionInterface< assemble::ProteinModel, double> &CRITERION, const Metropolis< double> &METROPOLIS, const storage::Set< quality::Measure> &MEASURES )
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_optimization_docking.h</td>
        <td>OptimizationDocking</td>
        <td>OptimizationDocking()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_optimization_docking.h</td>
        <td>OptimizationDocking</td>
        <td>Optimize( assemble::ProteinModel &MODEL) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_optimization_mcm.h</td>
        <td>OptimizationMCM</td>
        <td>GetDefaultTemperature()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_optimization_mcm.h</td>
        <td>OptimizationMCM</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_optimization_mcm.h</td>
        <td>OptimizationMCM</td>
        <td>OptimizationMCM( const score::ProteinModelScoreSum &SCORE_FUNCTION, const math::MutateInterface< assemble::ProteinModel> &MUTATES, const opti::CriterionInterface< assemble::ProteinModel, double> &CRITERION, const Metropolis< double> &METROPOLIS )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_optimization_mcm.h</td>
        <td>OptimizationMCM</td>
        <td>OptimizationMCM()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_print_interface.h</td>
        <td>PrintInterface</td>
        <td>GetIterationNumberFormat()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_print_interface.h</td>
        <td>PrintInterface</td>
        <td>GetRoundNumberFormat()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_print_interface.h</td>
        <td>PrintInterface</td>
        <td>GetStageNumberFormat()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer.h</td>
        <td>Printer</td>
        <td>Print( const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer.h</td>
        <td>Printer</td>
        <td>Printer( const bool &PRINT_ARGUMENT = false, const bool &PRINT_RESULT = true, const util::Message::MessageLevel &STEP_STATUS_MESSAGE_LEVEL = util::Message::e_Verbose )
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer.h</td>
        <td>Printer</td>
        <td>Printer()
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_combined.h</td>
        <td>PrinterCombined</td>
        <td>GetPrefix() const
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_combined.h</td>
        <td>PrinterCombined</td>
        <td>GetPrinters() const
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_combined.h</td>
        <td>PrinterCombined</td>
        <td>Initialize( const size_t &ROUND_NUMBER)
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_combined.h</td>
        <td>PrinterCombined</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_combined.h</td>
        <td>PrinterCombined</td>
        <td>Insert( const util::ShPtr< PrintInterface< t_ArgumentType, t_ResultType> > &PRINTER)
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_combined.h</td>
        <td>PrinterCombined</td>
        <td>Print( const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_combined.h</td>
        <td>PrinterCombined</td>
        <td>PrinterCombined()
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_combined.h</td>
        <td>PrinterCombined</td>
        <td>Remove( const util::ShPtr< PrintInterface< t_ArgumentType, t_ResultType> > &PRINTER)
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_combined.h</td>
        <td>PrinterCombined</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_combined.h</td>
        <td></td>
        <td>AddInstance( new PrinterCombined< t_ArgumentType, t_ResultType>())
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>GetPrefix() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>Initialize( const size_t &ROUND_NUMBER)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>Print( const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>PrinterDefault()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_default.h</td>
        <td></td>
        <td>AddInstance( new PrinterDefault< t_ArgumentType, t_ResultType>())
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>CreateFilename( const std::string &PREFIX, const std::string &TAG) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>CreateFilename( const std::string &PREFIX, const std::string &TAG, const size_t ROUND_NUMBER, const size_t STAGE_NUMBER ) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>GetPrefix() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>GetStepStatusSet() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>Initialize( const size_t &ROUND_NUMBER)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>Print( const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>PrinterFile( const std::string &PREFIX, const storage::Set< opti::StepStatusEnum> &STEP_STATUS_SET )
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>PrinterFile()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_file.h</td>
        <td>PrinterFile</td>
        <td>WriteToFile( const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER, const std::string &FILENAME) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_file.h</td>
        <td></td>
        <td>AddInstance( new PrinterFile< t_ArgumentType, t_ResultType>())
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_with_criterion.h</td>
        <td>PrinterWithCriterion</td>
        <td>Initialize( const size_t &ROUND_NUMBER)
</td>
        <td>pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_with_criterion.h</td>
        <td>PrinterWithCriterion</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER)
</td>
        <td>pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_with_criterion.h</td>
        <td>PrinterWithCriterion</td>
        <td>Print( const opti::Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_with_criterion.h</td>
        <td>PrinterWithCriterion</td>
        <td>PrinterWithCriterion( const util::ShPtr< PrintInterface< t_ArgumentType, t_ResultType> > &PRINTER, const util::ShPtr< opti::CriterionInterface< t_ArgumentType, t_ResultType> > &PRINT_CRITERIA )
</td>
        <td>pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_printer_with_criterion.h</td>
        <td>PrinterWithCriterion</td>
        <td>PrinterWithCriterion()
</td>
        <td>pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_printer_with_criterion.h</td>
        <td>PrinterWithCriterion</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>Approximate( util::ShPtr< assemble::ProteinModel> &SP_PROTEIN_MODEL) const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetFoldProtocols() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetMaxNumberIterations() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetMaxNumberUnimprovedIterations() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetMutate() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetMutateProtocols() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetMutateTree() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetName() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetPoolPostfix() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetScoreFunction() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetScoreProtocols() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetScoreWeightSet() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>GetTemperature() const
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>Initialize( const size_t &ROUND_NUMBER, const size_t &STAGE_NUMBER, const bool &IS_LAST_STAGE)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>InitializeMutates()
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>InitializeScores()
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>Reset( const size_t ROUND_NUMBER, const size_t STAGE_NUMBER)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetFoldProtocols( const storage::List< fold::Protocol> &FOLD_PROTOCOLS)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetIsLastStage()
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetMaxNumberIterations( const size_t MAX_NUMBER_ITERATIONS)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetMaxNumberUnimprovedIterations( const size_t MAX_NUMBER_UNIMPROVED_ITERATIONS)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetModifyStartModel( const bool MODIFY_START_MODEL)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetMutate( const util::ShPtr< math::MutateInterface< assemble::ProteinModel> > &MUTATE)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetMutateProtocols( const storage::List< fold::Protocol> &MUTATE_PROTOCOLS)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetMutateTree( const util::ShPtr< fold::MutateTree> &MUTATE_TREE)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetName( const std::string &NAME)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetNumberScoresToDrop( const size_t &NUMBER_SCORES)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetPath( const std::string &PATH)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetPoolPostfix( const std::string &POOL_POSTFIX)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetPrefix( const std::string &PREFIX)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetPrintEndModel( const bool PRINT_END_MODEL)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetPrintIterationModels( const bool PRINT_MODEL)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetPrintStartModel( const bool PRINT_START_MODEL)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetPrintTrackerHistory( const bool &TRACKER_HISTORY)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetQualityMeasures( const storage::Set< quality::Measure>)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetRoundNumber( const size_t ROUND_NUMBER)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetScoreFunction( const util::ShPtr< score::ProteinModelScoreSum> &SCORE_FUNCTION)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetScoreProtocols( const storage::List< fold::Protocol> &SCORE_PROTOCOLS)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetScoreWeightSet( const util::ShPtr< fold::ScoreWeightSet> &SCORE_WEIGHT_SET)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetStageNumber( const size_t STAGE_NUMBER)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>SetTemperature( const util::ShPtr< TemperatureInterface> &SP_TEMPERATURE)
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>Stage( const storage::List< fold::Protocol> &FOLD_PROTOCOLS, const storage::List< fold::Protocol> &SCORE_PROTOCOLS, const storage::List< fold::Protocol> &MUTATE_PROTOCOLS )
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_stage.h</td>
        <td>Stage</td>
        <td>Stage()
</td>
        <td>karakam, pinojc, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>GetFlagTemperature()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>GetLastCalculatedTemperature() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>GetParameterEndFraction()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>GetParameterStartFraction()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>GetParameterStartTemperature()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>GetParameterUpdateInterval()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>GetSerializer() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>GetTemperature( const opti::TrackerBase &TRACKER) const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>Reset()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>TemperatureAccepted( const double START_FRACTION, const double END_FRACTION, const size_t NUMBER_OF_ITERATIONS, const double START_TEMPERATURE = double( 1.0), const size_t UPDATE_INTERVAL = 10 )
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>TemperatureAccepted( const size_t NUMBER_OF_ITERATIONS)
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>TemperatureAccepted()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_accepted.h</td>
        <td>TemperatureAccepted</td>
        <td>TrackDelta( const double &DELTA)
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_default.h</td>
        <td>TemperatureDefault</td>
        <td>GetLastCalculatedTemperature() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_default.h</td>
        <td>TemperatureDefault</td>
        <td>GetSerializer() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_default.h</td>
        <td>TemperatureDefault</td>
        <td>GetTemperature( const opti::TrackerBase &TRACKER) const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_default.h</td>
        <td>TemperatureDefault</td>
        <td>Reset()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_default.h</td>
        <td>TemperatureDefault</td>
        <td>TemperatureDefault( const double TEMPERATURE)
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_default.h</td>
        <td>TemperatureDefault</td>
        <td>TemperatureDefault()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_exponential.h</td>
        <td>TemperatureExponential</td>
        <td>GetLastCalculatedTemperature() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_exponential.h</td>
        <td>TemperatureExponential</td>
        <td>GetSerializer() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_exponential.h</td>
        <td>TemperatureExponential</td>
        <td>GetTemperature( const opti::TrackerBase &TRACKER) const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_exponential.h</td>
        <td>TemperatureExponential</td>
        <td>Reset()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_exponential.h</td>
        <td>TemperatureExponential</td>
        <td>TemperatureExponential( const double START_TEMPERATURE, const double END_TEMPERATURE, const size_t NUMBER_OF_ITERATIONS )
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_exponential.h</td>
        <td>TemperatureExponential</td>
        <td>TemperatureExponential()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_interface.h</td>
        <td>TemperatureInterface</td>
        <td>TrackDelta( const double &DELTA)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_linear.h</td>
        <td>TemperatureLinear</td>
        <td>GetLastCalculatedTemperature() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_linear.h</td>
        <td>TemperatureLinear</td>
        <td>GetSerializer() const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_linear.h</td>
        <td>TemperatureLinear</td>
        <td>GetTemperature( const opti::TrackerBase &TRACKER) const
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_linear.h</td>
        <td>TemperatureLinear</td>
        <td>Reset()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_mc_temperature_linear.h</td>
        <td>TemperatureLinear</td>
        <td>TemperatureLinear( const double START_TEMPERATURE, const double END_TEMPERATURE, const size_t NUMBER_OF_ITERATIONS )
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_mc_temperature_linear.h</td>
        <td>TemperatureLinear</td>
        <td>TemperatureLinear()
</td>
        <td>karakam, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model.h</td>
        <td>Model</td>
        <td>AddModelPath( const std::string &FILENAME)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model.h</td>
        <td>Model</td>
        <td>GetModelPathFlag()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>loweew, mendenjl, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_align_cutoff.h</td>
        <td>AlignCutoff</td>
        <td>AlignCutoff( const util::ShPtr< Interface> &MODEL, const util::ShPtr< RescaleFeatureDataSet> &RESCALE_INPUT, const util::ShPtr< RescaleFeatureDataSet> &RESCALE_OUTPUT, const float EXPERIMENTAL_CUTOFF, const float ADJUSTED_CUTOFF, const float SLOPE_ABOVE_CUTOFF, const float SLOPE_BELOW_CUTOFF )
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_align_cutoff.h</td>
        <td>AlignCutoff</td>
        <td>AlignCutoff()
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_align_cutoff.h</td>
        <td>AlignCutoff</td>
        <td>GetNumberOutputs() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_align_cutoff.h</td>
        <td>AlignCutoff</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE ) const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_align_cutoff.h</td>
        <td>AlignCutoff</td>
        <td>Rescale( FeatureDataSet< float> &FEATURE) const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_align_cutoff.h</td>
        <td>AlignCutoff</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_align_cutoff.h</td>
        <td>ApproximatorAlignCutoff</td>
        <td>ApproximatorAlignCutoff()
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_align_cutoff.h</td>
        <td>ApproximatorAlignCutoff</td>
        <td>GetCurrentApproximation() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_align_cutoff.h</td>
        <td>ApproximatorAlignCutoff</td>
        <td>GetCurrentModel() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_align_cutoff.h</td>
        <td>ApproximatorAlignCutoff</td>
        <td>Next()
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_align_cutoff.h</td>
        <td>ApproximatorAlignCutoff</td>
        <td>SetObjectiveFunction( const util::ShPtr< ObjectiveFunctionWrapper> &OBJ)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_align_cutoff.h</td>
        <td>ApproximatorAlignCutoff</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA )
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_applicability_domain_kohonen.h</td>
        <td>ApproximatorApplicabilityDomainKohonen</td>
        <td>ApproximatorApplicabilityDomainKohonen( const bool &USE_DISTANCE_METRIC = true)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_applicability_domain_kohonen.h</td>
        <td>ApproximatorApplicabilityDomainKohonen</td>
        <td>ApproximatorApplicabilityDomainKohonen( const linal::Vector< double> &MAP_DIMENSIONS, const size_t &INITIAL_LENGTH, const float &INITAL_RADIUS, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE_FUNCTION, const size_t &UPDATE_EVERY_NTH_FEATURE, const NeighborKernel &NEIGHBOR_KERNEL, const util::Implementation< RetrieveInterface> &RETREIVER = util::Implementation< RetrieveInterface>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_applicability_domain_kohonen.h</td>
        <td>ApproximatorApplicabilityDomainKohonen</td>
        <td>GetCurrentApproximation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_applicability_domain_kohonen.h</td>
        <td>ApproximatorApplicabilityDomainKohonen</td>
        <td>GetCurrentModel() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_applicability_domain_kohonen.h</td>
        <td>ApproximatorApplicabilityDomainKohonen</td>
        <td>Next()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_applicability_domain_kohonen.h</td>
        <td>ApproximatorApplicabilityDomainKohonen</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>ApproximatorBase( const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE_FUNCTION)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>ApproximatorBase()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>GetObjectiveFunction() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>GetRescaleFeatureDataSet() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>GetRescaleResultDataSet() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>GetTrainingData() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>IsTrainingContinued() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>SetObjectiveFunction( const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE_FUNCTION)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_base.h</td>
        <td>ApproximatorBase</td>
        <td>SetTrainingContinued( const bool &CONTINUED_TRAINING)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>ApproximatorDecisionTree( const util::Implementation< DtreeDataPartitionFunctionInterface> &DATA_PARTITIONER, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE_FUNCTION, const float ACTIVITY_CUTOFF, const util::ShPtr< descriptor::Dataset> &TRAINING_DATA )
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>ApproximatorDecisionTree()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>CreateDataSetReferences( const linal::MatrixConstInterface< float> &FEATURES, const linal::MatrixConstInterface< float> &RESULTS )
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>GetActivityCutoff() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>GetCurrentApproximation() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>GetCurrentModel() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>GetDataPartitionFunction() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>GetTrainingData() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>Next()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>Prune( DecisionTree &MODEL) const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_decision_tree.h</td>
        <td>ApproximatorDecisionTree</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_kappa_nearest_neighbor.h</td>
        <td>ApproximatorKappaNearestNeighbor</td>
        <td>ApproximatorKappaNearestNeighbor()
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_kappa_nearest_neighbor.h</td>
        <td>ApproximatorKappaNearestNeighbor</td>
        <td>GetCurrentApproximation() const
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_kappa_nearest_neighbor.h</td>
        <td>ApproximatorKappaNearestNeighbor</td>
        <td>GetCurrentModel() const
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_kappa_nearest_neighbor.h</td>
        <td>ApproximatorKappaNearestNeighbor</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>ApproximatorKohonenNetwork( const linal::Vector< double> &MAP_DIMENSIONS, const size_t &INITIAL_LENGTH, const float &INITAL_RADIUS, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE_FUNCTION, const size_t &UPDATE_EVERY_NTH_FEATURE, const NeighborKernel &NEIGHBOR_KERNEL )
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>ApproximatorKohonenNetwork()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>GetCurrentApproximation() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>GetCurrentModel() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>GetInitializationName( const Initialization &INITIALIZER)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>GetKernelName( const NeighborKernel &KERNEL)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>GetNeighborKernel() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>GetTrainingData() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>Next()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_kohonen_network.h</td>
        <td>ApproximatorKohonenNetwork</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA )
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_leverage_matrix.h</td>
        <td>ApproximatorLeverageMatrix</td>
        <td>ApproximatorLeverageMatrix()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_leverage_matrix.h</td>
        <td>ApproximatorLeverageMatrix</td>
        <td>GetCurrentApproximation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_leverage_matrix.h</td>
        <td>ApproximatorLeverageMatrix</td>
        <td>GetCurrentModel() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_leverage_matrix.h</td>
        <td>ApproximatorLeverageMatrix</td>
        <td>GetObjectiveFunction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_leverage_matrix.h</td>
        <td>ApproximatorLeverageMatrix</td>
        <td>Next()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_leverage_matrix.h</td>
        <td>ApproximatorLeverageMatrix</td>
        <td>SetObjectiveFunction( const util::ShPtr< ObjectiveFunctionWrapper> &OBJ)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_leverage_matrix.h</td>
        <td>ApproximatorLeverageMatrix</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_linear_regression.h</td>
        <td>ApproximatorLinearRegression</td>
        <td>ApproximatorLinearRegression()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_linear_regression.h</td>
        <td>ApproximatorLinearRegression</td>
        <td>GetCurrentApproximation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_linear_regression.h</td>
        <td>ApproximatorLinearRegression</td>
        <td>GetCurrentModel() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_linear_regression.h</td>
        <td>ApproximatorLinearRegression</td>
        <td>GetObjectiveFunction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_linear_regression.h</td>
        <td>ApproximatorLinearRegression</td>
        <td>Next()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_linear_regression.h</td>
        <td>ApproximatorLinearRegression</td>
        <td>SetObjectiveFunction( const util::ShPtr< ObjectiveFunctionWrapper> &OBJ)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_linear_regression.h</td>
        <td>ApproximatorLinearRegression</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>ApproximatorNeuralNetwork( const bool &PRETRAIN = false)
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>ApproximatorNeuralNetwork( util::ShPtr< descriptor::Dataset> &TRAINING_DATA, const size_t UPDATE_EVERY_NTH_FEATURE, const storage::Vector< size_t> &ARCHITECTURE, const util::Implementation< TransferFunctionInterface> &TRANSFER_FUNCTION, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE_FUNCTION, const util::Implementation< NeuralNetworkUpdateWeightsInterface> &WEIGHT_UPDATE_FUNCTION, const size_t &ITERATIONS_PER_RMSD_REPORT = 1, const RescaleFeatureDataSet::TypeEnum RESCALE_TYPE = RescaleFeatureDataSet::e_AveStd )
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>GetCurrentApproximation() const
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>GetCurrentModel() const
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>GetHiddenArchitecture() const
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>GetInputLayerDropoutTypeName( const InputLayerDropoutType &TYPE)
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>GetSerializer() const
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>GetTransferFunction() const
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>Next()
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>PretrainNetwork( util::ShPtr< descriptor::Dataset> &DATA, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE )
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>SetHiddenArchitecture( const storage::Vector< size_t> &HIDDEN)
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network.h</td>
        <td>ApproximatorNeuralNetwork</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>mueller, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>ApproximatorNeuralNetworkSelective( const bool &PRETRAIN = false)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>ApproximatorNeuralNetworkSelective( util::ShPtr< descriptor::Dataset> &TRAINING_DATA, const size_t UPDATE_EVERY_NTH_FEATURE, const storage::Vector< size_t> &ARCHITECTURE, const util::Implementation< TransferFunctionInterface> &TRANSFER_FUNCTION, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE_FUNCTION, const util::Implementation< NeuralNetworkUpdateWeightsInterface> &WEIGHT_UPDATE_FUNCTION, const size_t &ITERATIONS_PER_RMSD_REPORT = 1, const RescaleFeatureDataSet::TypeEnum m_RescaleType = RescaleFeatureDataSet::e_AveStd )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>GetCurrentApproximation() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>GetCurrentModel() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>GetHiddenArchitecture() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>GetInputLayerDropoutTypeName( const InputLayerDropoutType &TYPE)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>GetSerializer() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>GetTransferFunction() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>Next()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>PretrainNetwork( util::ShPtr< descriptor::Dataset> &DATA, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>SetHiddenArchitecture( const storage::Vector< size_t> &HIDDEN)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_neural_network_selective.h</td>
        <td>ApproximatorNeuralNetworkSelective</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_restricted_boltzmann_machine.h</td>
        <td>ApproximatorRestrictedBoltzmannMachine</td>
        <td>ApproximatorRestrictedBoltzmannMachine( const bool &PRETRAIN = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_restricted_boltzmann_machine.h</td>
        <td>ApproximatorRestrictedBoltzmannMachine</td>
        <td>ApproximatorRestrictedBoltzmannMachine( util::ShPtr< descriptor::Dataset> &TRAINING_DATA, const size_t UPDATE_EVERY_NTH_FEATURE, const storage::Vector< size_t> &ARCHITECTURE, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE_FUNCTION, const util::Implementation< NeuralNetworkUpdateWeightsInterface> &WEIGHT_UPDATE_FUNCTION, const util::Implementation< NeuralNetworkUpdateWeightsInterface> &BIAS_UPDATE_FUNCTION, const size_t &ITERATIONS_PER_RMSD_REPORT = 1, const RestrictedBoltzmannMachineLayer::Type &TYPE = RestrictedBoltzmannMachineLayer::e_StochasticSigmoid )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_restricted_boltzmann_machine.h</td>
        <td>ApproximatorRestrictedBoltzmannMachine</td>
        <td>GetCurrentApproximation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_restricted_boltzmann_machine.h</td>
        <td>ApproximatorRestrictedBoltzmannMachine</td>
        <td>GetCurrentModel() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_restricted_boltzmann_machine.h</td>
        <td>ApproximatorRestrictedBoltzmannMachine</td>
        <td>Next()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_restricted_boltzmann_machine.h</td>
        <td>ApproximatorRestrictedBoltzmannMachine</td>
        <td>PretrainNetwork( util::ShPtr< descriptor::Dataset> &DATA, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_restricted_boltzmann_machine.h</td>
        <td>ApproximatorRestrictedBoltzmannMachine</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_support_vector_machine.h</td>
        <td>ApproximatorSupportVectorMachine</td>
        <td>ApproximatorSupportVectorMachine( const float COST_PARAMETER_C, const util::ShPtr< SupportVectorMachine> &MODEL, util::ShPtr< descriptor::Dataset> &TRAINING_DATA, const size_t NUMBER_ITERATIONS )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_support_vector_machine.h</td>
        <td>ApproximatorSupportVectorMachine</td>
        <td>ApproximatorSupportVectorMachine()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_support_vector_machine.h</td>
        <td>ApproximatorSupportVectorMachine</td>
        <td>GetCostParameterC() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_support_vector_machine.h</td>
        <td>ApproximatorSupportVectorMachine</td>
        <td>GetCurrentApproximation() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_support_vector_machine.h</td>
        <td>ApproximatorSupportVectorMachine</td>
        <td>GetCurrentModel() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_support_vector_machine.h</td>
        <td>ApproximatorSupportVectorMachine</td>
        <td>Next()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_support_vector_machine.h</td>
        <td>ApproximatorSupportVectorMachine</td>
        <td>SetCostParameterC( const float COST_PARAMETER_C)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_support_vector_machine.h</td>
        <td>ApproximatorSupportVectorMachine</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_support_vector_machine_multi_output.h</td>
        <td>ApproximatorSupportVectorMachineMultiOutput</td>
        <td>ApproximatorSupportVectorMachineMultiOutput( const float COST_PARAMETER_C, const util::ShPtr< SupportVectorMachineMultiOutput> &MODEL, util::ShPtr< descriptor::Dataset> &TRAINING_DATA, const size_t NUMBER_ITERATIONS )
</td>
        <td>butkiem1, krauseg</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_support_vector_machine_multi_output.h</td>
        <td>ApproximatorSupportVectorMachineMultiOutput</td>
        <td>ApproximatorSupportVectorMachineMultiOutput()
</td>
        <td>butkiem1, krauseg</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_support_vector_machine_multi_output.h</td>
        <td>ApproximatorSupportVectorMachineMultiOutput</td>
        <td>GetCostParameterC() const
</td>
        <td>butkiem1, krauseg</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_support_vector_machine_multi_output.h</td>
        <td>ApproximatorSupportVectorMachineMultiOutput</td>
        <td>GetCurrentApproximation() const
</td>
        <td>butkiem1, krauseg</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_support_vector_machine_multi_output.h</td>
        <td>ApproximatorSupportVectorMachineMultiOutput</td>
        <td>GetCurrentModel() const
</td>
        <td>butkiem1, krauseg</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_support_vector_machine_multi_output.h</td>
        <td>ApproximatorSupportVectorMachineMultiOutput</td>
        <td>Next()
</td>
        <td>butkiem1, krauseg</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_approximator_support_vector_machine_multi_output.h</td>
        <td>ApproximatorSupportVectorMachineMultiOutput</td>
        <td>SetCostParameterC( const float COST_PARAMETER_C)
</td>
        <td>butkiem1, krauseg</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_approximator_support_vector_machine_multi_output.h</td>
        <td>ApproximatorSupportVectorMachineMultiOutput</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>butkiem1, krauseg</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_collect_features_above.h</td>
        <td>CollectFeaturesAbove</td>
        <td>Collect( const linal::Vector< float> &SCORES) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_collect_features_above.h</td>
        <td>CollectFeaturesAbove</td>
        <td>CollectFeaturesAbove( const float &THRESHOLD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_collect_features_top.h</td>
        <td>CollectFeaturesTop</td>
        <td>Collect( const linal::Vector< float> &SCORES) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_collect_features_top.h</td>
        <td>CollectFeaturesTop</td>
        <td>CollectFeaturesTop( const size_t &NUMBER_TO_KEEP)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>CrossValidationInfo( const float &RESULT, const opti::ImprovementTypeEnum &IMPROVEMENT_TYPE, const util::ObjectDataLabel &INDEPENDENT, const util::ObjectDataLabel &MONITORING, const util::ObjectDataLabel &TRAINING, const util::ObjectDataLabel &OBJECTIVE, const util::ObjectDataLabel &ITERATE, const std::string &INDEPENDENT_PREDICTIONS, const FeatureLabelSet &ID_LABELS, const size_t &NUMBER_OUTPUTS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>CrossValidationInfo( const std::string &FILENAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>CrossValidationInfo()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetIDsFeatureLabelSet() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetIndependentDatasetRetriever() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetIndependentPredictionsFilename() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetIterate() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetMonitoringDatasetRetriever() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetNumberOutputs() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetObjective() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetPredictionOutputFormatString( const PredictionOutputFormat &FORMAT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetResult() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>GetTrainingDatasetRetriever() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>KeepSharedInfo( const CrossValidationInfo &OTHER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>ReadIndependentPredictions()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>ReadPredictions( const std::string &FILENAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>SetIndependentDataset( const util::ObjectDataLabel &IND_DATASET)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>SetIndependentPredictionsFilename( const std::string &FILENAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>SetPredictionsFormat( const PredictionOutputFormat &FORMAT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>WritePredictions( FeatureDataSet< float> &EXPERIMENTAL, FeatureDataSet< float> &PREDICTIONS, const FeatureDataSetInterface< char> &IDS, const std::string &FILENAME, const PredictionOutputFormat &FORMAT = e_Delimited )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_cross_validation_info.h</td>
        <td>CrossValidationInfo</td>
        <td>WritePredictions( const linal::MatrixConstInterface< float> &EXPERIMENTAL, const linal::MatrixConstInterface< float> &PREDICTIONS, const linal::MatrixConstInterface< char> &IDS, const std::string &FILENAME, const PredictionOutputFormat &FORMAT = e_Delimited )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>DataSetLog( const std::string &ID_LABEL )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>DataSetLog()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>GenerateDataSet()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>RequiresResultLabels() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>operator ()( const descriptor::Dataset &DATA) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_log.h</td>
        <td>DataSetLog</td>
        <td>operator ()( util::ShPtr< descriptor::Dataset> DATA) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>DataSetMultiplied( const double &FEATURE_MULTIPLIER, const double &RESULT_MULTIPLIER, const std::string &ID_LABEL )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>DataSetMultiplied()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>GenerateDataSet()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>RequiresResultLabels() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>operator ()( const descriptor::Dataset &DATA) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_multiplied.h</td>
        <td>DataSetMultiplied</td>
        <td>operator ()( util::ShPtr< descriptor::Dataset> DATA) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>DataSetReducedToClusterCenters( const double &RMSD = 0.0, const math::Range< size_t> &RANGE = math::Range< size_t>( 1, std::numeric_limits< size_t>::max()), const size_t &MAX_STEPS_TO_REACH_CLUSTER_SIZE = 10, const bool &AUTOSCALE = false, const Selection &SELECTION = e_First )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>GetRMSDParameter() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>GetSelectionName( const Selection &SELECTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>RequiresResultLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>operator ()( const descriptor::Dataset &DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_cluster_centers.h</td>
        <td>DataSetReducedToClusterCenters</td>
        <td>operator ()( util::ShPtr< descriptor::Dataset> DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>DataSetReducedToKMeans( const size_t &NUMBER_CLUSTERS = 0, const size_t &MAX_RECLUSTER_ATTEMPTS = 20, const bool &AUTOSCALE = false )
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>GenerateDataSet()
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>GetNumberClusters() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>IdentifyClusterIndices( util::ShPtr< descriptor::Dataset> &REDUCED_MATRIX) const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>LimitedSquareDistance( const linal::VectorConstInterface< float> &VEC_A, const linal::VectorConstInterface< float> &VEC_B, const float &LIMIT )
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>RequiresResultLabels() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_k_means.h</td>
        <td>DataSetReducedToKMeans</td>
        <td>operator ()( const util::ShPtr< descriptor::Dataset> &DATA, const TrainingSchedule &BALANCING = TrainingSchedule() ) const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>DataSetReducedToPrincipalComponents( const double &FRACTION = 1.0, const size_t &MAX_COMPONENTS_TO_KEEP = util::GetUndefined< size_t>() )
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>GenerateDataSet()
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>RequiresResultLabels() const
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>SetFilename( const std::string &FILENAME)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_reduced_to_principal_components.h</td>
        <td>DataSetReducedToPrincipalComponents</td>
        <td>SetRetriever( const util::Implementation< RetrieveDataSetBase> &RETRIEVER)
</td>
        <td>loweew, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_score.h</td>
        <td>DataSetScore</td>
        <td>GetFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_score.h</td>
        <td>DataSetScore</td>
        <td>GetScores() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_score.h</td>
        <td>DataSetScore</td>
        <td>SetFeatures( const FeatureLabelSet &FEATURES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_score.h</td>
        <td>DataSetScore</td>
        <td>SetScores( const linal::Vector< float> &SCORES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_select_columns.h</td>
        <td>DataSetSelectColumns</td>
        <td>DataSetSelectColumns( const size_t &FEATURE_SIZE = 0, const storage::Vector< size_t> &INDICES = storage::Vector< size_t>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_select_columns.h</td>
        <td>DataSetSelectColumns</td>
        <td>GetColumnIndices() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_select_columns.h</td>
        <td>DataSetSelectColumns</td>
        <td>GetInputFeatureSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_select_columns.h</td>
        <td>DataSetSelectColumns</td>
        <td>GetOutputFeatureSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_select_columns.h</td>
        <td>DataSetSelectColumns</td>
        <td>operator ()( const linal::VectorConstInterface< char> &FEATURES, char *STORAGE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_select_columns.h</td>
        <td>DataSetSelectColumns</td>
        <td>operator ()( const linal::VectorConstInterface< float> &FEATURES, float *STORAGE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>DataSetSqrt( const std::string &ID_LABEL )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>DataSetSqrt()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>GenerateDataSet()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>RequiresResultLabels() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>operator ()( const descriptor::Dataset &DATA) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_sqrt.h</td>
        <td>DataSetSqrt</td>
        <td>operator ()( util::ShPtr< descriptor::Dataset> DATA) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_statistics.h</td>
        <td>DataSetStatistics</td>
        <td>AddDataSet( const descriptor::Dataset &DATASET)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_statistics.h</td>
        <td>DataSetStatistics</td>
        <td>AddDataSet( util::Implementation< RetrieveDataSetBase> DATASET)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_statistics.h</td>
        <td>DataSetStatistics</td>
        <td>AddDifference( const descriptor::Dataset &DATASET_A, const descriptor::Dataset &DATASET_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_statistics.h</td>
        <td>DataSetStatistics</td>
        <td>AddDifference( util::Implementation< RetrieveDataSetBase> DATASET_A, util::Implementation< RetrieveDataSetBase> DATASET_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_statistics.h</td>
        <td>DataSetStatistics</td>
        <td>GetAveStdFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_statistics.h</td>
        <td>DataSetStatistics</td>
        <td>GetAveStdResults() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_data_set_statistics.h</td>
        <td>DataSetStatistics</td>
        <td>GetMinMaxFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_data_set_statistics.h</td>
        <td>DataSetStatistics</td>
        <td>GetMinMaxResults() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>ConfigureBranch( const size_t &SPLIT_INDEX, const float &SPLIT_VALUE, const util::ShPtr< DecisionTree> &LEFT_CHILD, const util::ShPtr< DecisionTree> &RIGHT_CHILD )
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>DecisionTree( const linal::Vector< float> &AVERAGE_ACTIVITY)
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>DecisionTree()
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>DeepClone() const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>GetActivity() const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>GetNumberOutputs() const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>GetSplitIndex() const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>GetSplitValue() const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>GetSubtreeLevels() const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>GetTreeSize() const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>IsLeaf() const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>MakeLeaf()
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>Prune( const double &ACTIVITY_CUTOFF, const size_t &SIZE_CUTOFF = 0)
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>Rescale( FeatureDataSet< float> &FEATURE) const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>SetActivity( const storage::Vector< math::RunningAverage< float> > &AVERAGES)
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_decision_tree.h</td>
        <td>DecisionTree</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURES) const
</td>
        <td>teixeipl, butkiem1, mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_descriptor_selection_backward_elimination.h</td>
        <td>DescriptorSelectionBackwardElimination</td>
        <td>GetInitialDescriptorSet( const util::ObjectDataLabel &TOTAL) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_descriptor_selection_backward_elimination.h</td>
        <td>DescriptorSelectionBackwardElimination</td>
        <td>operator ()( const util::ObjectDataLabel &INITIAL, const util::ObjectDataLabel &TOTAL ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_descriptor_selection_exhaustive.h</td>
        <td>DescriptorSelectionExhaustive</td>
        <td>DescriptorSelectionExhaustive()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_descriptor_selection_exhaustive.h</td>
        <td>DescriptorSelectionExhaustive</td>
        <td>GetInitialDescriptorSet( const util::ObjectDataLabel &TOTAL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_descriptor_selection_exhaustive.h</td>
        <td>DescriptorSelectionExhaustive</td>
        <td>operator ()( const util::ObjectDataLabel &INITIAL, const util::ObjectDataLabel &TOTAL ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_descriptor_selection_feature_forward.h</td>
        <td>DescriptorSelectionFeatureForward</td>
        <td>GetInitialDescriptorSet( const util::ObjectDataLabel &TOTAL) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_descriptor_selection_feature_forward.h</td>
        <td>DescriptorSelectionFeatureForward</td>
        <td>operator ()( const util::ObjectDataLabel &INITIAL, const util::ObjectDataLabel &TOTAL ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>DetermineAccuracy( const storage::Vector< FeatureResultAndState> &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>DetermineInitialAccuracy( const size_t &DATA_SIZE, const linal::Vector< size_t> &STATE_COUNTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>DtreeBinaryPartition( const size_t &FEATURE_INDEX, const float &SPLIT_VALUE, const float &SPLIT_RATING, const size_t &SIZE = 0, const size_t &NUM_INCORRECT = 0 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>DtreeBinaryPartition()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>GetData( const Data &DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>GetDataName( const Data &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>GetFeatureIndex() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>GetFinalNumIncorrect() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>GetInitialNumIncorrect() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>GetSplitRating() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_binary_partition.h</td>
        <td>DtreeBinaryPartition</td>
        <td>GetSplitValue() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_data_partition_function_interface.h</td>
        <td>DtreeDataPartitionFunctionInterface</td>
        <td>ExtractAndSortDescriptorAtIndex( const size_t INDEX, const storage::Vector< FeatureResultAndState> &INPUTDATASET )
</td>
        <td>lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_data_partition_function_interface.h</td>
        <td>DtreeDataPartitionFunctionInterface</td>
        <td>GetAllPartitionRatings( const storage::Vector< FeatureResultAndState> &INPUTDATASET, const bool &SHOW_STATUS = false ) const
</td>
        <td>lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_gini_index_data_partition_function.h</td>
        <td>DtreeGiniIndexDataPartitionFunction</td>
        <td>operator ()( const storage::Vector< FeatureResultAndState> &DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_information_gain_data_partition_function.h</td>
        <td>DtreeInformationGainDataPartitionFunction</td>
        <td>operator ()( const storage::Vector< FeatureResultAndState> &DATA) const
</td>
        <td>lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_roc_data_partition_function.h</td>
        <td>DtreeRocDataPartitionFunction</td>
        <td>DtreeRocDataPartitionFunction( const float MAX, const float MIN)
</td>
        <td>teixeipl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_roc_data_partition_function.h</td>
        <td>DtreeRocDataPartitionFunction</td>
        <td>DtreeRocDataPartitionFunction()
</td>
        <td>teixeipl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_dtree_roc_data_partition_function.h</td>
        <td>DtreeRocDataPartitionFunction</td>
        <td>operator ()( const storage::Vector< FeatureResultAndState> &DATA) const
</td>
        <td>teixeipl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_dtree_sequence_data_partition_function.h</td>
        <td>DtreeSequenceDataPartitionFunction</td>
        <td>operator ()( const storage::Vector< FeatureResultAndState> &DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>FeatureDataReference( const linal::MatrixConstInterface< t_DataType> &MATRIX, const util::ShPtr< FeatureLabelSet> &FEATURE_LABEL_SET = util::ShPtr< FeatureLabelSet>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>FeatureDataReference()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>GetFeatureLabelSet() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>GetFeatureSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>GetMatrix( const size_t POS, const size_t LENGTH) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>GetMatrix() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>GetNumberFeatures() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>GetScaling() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>HasOwnership() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_reference.h</td>
        <td>FeatureDataReference</td>
        <td>operator []( const size_t POS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_reference.h</td>
        <td></td>
        <td>AddInstance( new FeatureDataReference< t_DataType>())
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>DeScale()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>FeatureDataSet( const FeatureDataSetInterface< t_DataType> &DATA_SET )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>FeatureDataSet( const linal::MatrixConstInterface< t_DataType> &MATRIX)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>FeatureDataSet( const linal::MatrixConstInterface< t_DataType> &MATRIX, const RescaleFeatureDataSet &RESCALING )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>FeatureDataSet( const linal::MatrixConstInterface< t_DataType> &MATRIX, const math::RangeSet< size_t> &COLS )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>FeatureDataSet( const size_t &EXAMPLES, const size_t &FEATURE_SIZE, const t_DataType &FILL_VALUE )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>FeatureDataSet()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>GetFeatureLabelSet() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>GetFeatureSize() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>GetMatrix( const size_t POS, const size_t LENGTH) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>GetMatrix()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>GetMatrix() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>GetNumberFeatures() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>GetRawMatrix()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>GetRawMatrix() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>GetScaling() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>HasOwnership() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>HasSameScaling( const FeatureDataSetInterface< t_DataType> &OTHER) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>IsRescaled() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>Rescale( const RescaleFeatureDataSet &TO_RANGE)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>Rescale( const math::Range< float> &TO_RANGE, const RescaleFeatureDataSet::Type &SCALING = RescaleFeatureDataSet::e_MinMax )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>SetFeatureLabelSet( const FeatureLabelSet &NEW_SET)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>SetFeatureLabelSet( const util::ShPtr< FeatureLabelSet> &NEW_SET)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_data_set.h</td>
        <td>FeatureDataSet</td>
        <td>operator []( const size_t POS) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_data_set_interface.h</td>
        <td>FeatureDataSetInterface</td>
        <td>IsRescaled() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>CreateSubFeatureLabelSet( const storage::Vector< size_t> &SUB_FEATURES) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>DecomposePartial( const util::ObjectDataLabel &LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>FeatureLabelSet( const std::string &NAME, const storage::Vector< util::ObjectDataLabel> &PROPERTIES, const storage::Vector< size_t> &PROPERTY_SIZES, const util::Implementation< util::ImplementationInterface> &IMPL = util::Implementation< util::ImplementationInterface>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>FeatureLabelSet( const std::string &NAME, const util::Implementation< util::ImplementationInterface> &IMPL )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>FeatureLabelSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>GetCommonFeatures( const FeatureLabelSet &COMPARE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>GetLabel() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>GetMemberLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>GetPropertyIndices( const util::ObjectDataLabel &LABEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>GetPropertySizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>GetString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>MergeConsideringPartials( const util::ObjectDataLabel &LABEL_A, const util::ObjectDataLabel &LABEL_B )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>PushBack( const util::ObjectDataLabel &PROPERTY_LABEL, const size_t &PROPERTY_SIZE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_label_set.h</td>
        <td>FeatureLabelSet</td>
        <td>SplitFeatureLabelSet( const bool &SKIP_ZERO_LENGTH_DESCRIPTORS = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_reference.h</td>
        <td>FeatureReference</td>
        <td>Begin() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_reference.h</td>
        <td>FeatureReference</td>
        <td>End() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_reference.h</td>
        <td>FeatureReference</td>
        <td>FeatureReference( const size_t SIZE, const t_DataType *DATA)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_reference.h</td>
        <td>FeatureReference</td>
        <td>FeatureReference()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_reference.h</td>
        <td>FeatureReference</td>
        <td>GetSize() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_reference.h</td>
        <td>FeatureReference</td>
        <td>HasOwnership() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_reference.h</td>
        <td>FeatureReference</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_reference.h</td>
        <td>FeatureReference</td>
        <td>operator <( const FeatureReference< t_DataType> &DATA) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_reference.h</td>
        <td></td>
        <td>AddInstance( new FeatureReference< t_DataType>())
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_result_and_state.h</td>
        <td>FeatureResultAndState</td>
        <td>FeatureResultAndState( const FeatureReference< float> &FEATURE, const FeatureReference< float> &RESULT, const FeatureReference< size_t> &RESULT_STATE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_result_and_state.h</td>
        <td>FeatureResultAndState</td>
        <td>FeatureResultAndState()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_result_and_state.h</td>
        <td>FeatureResultAndState</td>
        <td>GetFeature() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_feature_result_and_state.h</td>
        <td>FeatureResultAndState</td>
        <td>GetResult() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_feature_result_and_state.h</td>
        <td>FeatureResultAndState</td>
        <td>GetResultState() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_has_labels_base.h</td>
        <td>HasLabelsBase</td>
        <td>GetFeatureCode() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_has_labels_base.h</td>
        <td>HasLabelsBase</td>
        <td>GetIdCode() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_has_labels_base.h</td>
        <td>HasLabelsBase</td>
        <td>GetResultCode() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_has_labels_base.h</td>
        <td>HasLabelsBase</td>
        <td>SetFeatures( const FeatureLabelSet &CODE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_has_labels_base.h</td>
        <td>HasLabelsBase</td>
        <td>SetIds( const FeatureLabelSet &CODE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_has_labels_base.h</td>
        <td>HasLabelsBase</td>
        <td>SetResults( const FeatureLabelSet &CODE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>GetAllKeys() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>GetDirectory() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>GetKeys( const math::Range< size_t> &RANGE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>GetSize() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>InterfaceRetrieveFromFile( const std::string &DIRECTORY_NAME, const std::string &FILE_PREFIX )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>InterfaceRetrieveFromFile()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>Retrieve( const std::string &KEY) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>RetrieveCVInfo( const std::string &KEY) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>RetrieveDescriptorSet( const std::string &KEY) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>RetrieveEnsemble( const storage::Vector< std::string> &KEYS) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>RetrieveEnsemble() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>RetrieveEnsembleCVInfo() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>RetrieveEnsembleDescriptors() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>RetrieveResultDescriptor( const std::string &FILENAME)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_retrieve_from_file.h</td>
        <td>InterfaceRetrieveFromFile</td>
        <td>RetrieveResultDescriptor() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>CleanUp()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>GetAllKeys() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>GetDirectory() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>GetExtensionTypeDescriptor( const ExtensionType &TYPE)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>GetKeys( const math::Range< size_t> &RANGE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>GetSize() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>InterfaceStoreInFile( const std::string &DIRECTORY_NAME)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>InterfaceStoreInFile()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>Store( const util::ShPtr< Interface> &MODEL, const float RESULT, const util::ObjectDataLabel &DESCRIPTORS, const util::ObjectDataLabel &METHOD_NAME, const util::ObjectDataLabel &OBJ_FUNCTION, const CrossValidationInfo &CV_INFO )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>Store( const util::ShPtr< Interface> &MODEL, const float RESULT, const util::ObjectDataLabel &DESCRIPTORS, const util::ObjectDataLabel &METHOD_NAME, const util::ObjectDataLabel &OBJ_FUNCTION, const CrossValidationInfo &CV_INFO, const std::string &KEY )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>Store( const util::ShPtr< Interface> &MODEL, const util::ObjectDataLabel &DESCRIPTORS )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_interface_store_in_file.h</td>
        <td>InterfaceStoreInFile</td>
        <td>StoreResultDescriptor( const util::ObjectDataLabel &RESULT_DESCRIPTOR)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>FindWithoutRescaling( const FeatureDataSet< float> &QUERY_VECTORS, const size_t KAPPA, const FeatureDataSet< float> &TRAINING_FEATURES )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>FindWithoutRescaling( const FeatureReference< float> &QUERY_VECTOR, const size_t KAPPA, const FeatureDataSet< float> &TRAINING_FEATURES )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>GetKappa() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>GetNumberOutputs() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>GetTrainingData()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>KappaNearestNeighbor( const util::ShPtr< descriptor::Dataset> &TRAINING_DATA, const size_t KAPPA )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>KappaNearestNeighbor()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>Rescale( FeatureDataSet< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>SetKappa( size_t KAPPA)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &TRAINING_DATA )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_applicability_domain.h</td>
        <td>KohonenNetworkApplicabilityDomain</td>
        <td>GetSplines() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_applicability_domain.h</td>
        <td>KohonenNetworkApplicabilityDomain</td>
        <td>KohonenNetworkApplicabilityDomain( const KohonenNetworkAverage &NETWORK, const bool &SHARE_DISTANCE_METRIC = true, const util::Implementation< RetrieveInterface> &MODEL_RETRIEVER = util::Implementation< RetrieveInterface>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_applicability_domain.h</td>
        <td>KohonenNetworkApplicabilityDomain</td>
        <td>KohonenNetworkApplicabilityDomain()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_applicability_domain.h</td>
        <td>KohonenNetworkApplicabilityDomain</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_applicability_domain.h</td>
        <td>KohonenNetworkApplicabilityDomain</td>
        <td>SetupModels( const util::Implementation< RetrieveInterface> &MODEL_RETRIEVER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_applicability_domain.h</td>
        <td>KohonenNetworkApplicabilityDomain</td>
        <td>SetupSplines( const FeatureDataSetInterface< float> &NORMALIZED_DATA, const storage::Vector< size_t> &PREVIOUS_WINNERS, const bool &SHARE_DISTANCE_METRIC = true )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_applicability_domain.h</td>
        <td>KohonenNetworkApplicabilityDomain</td>
        <td>SetupSplines( const storage::Vector< storage::Vector< math::CubicSplineDamped> > &SPLINES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_applicability_domain.h</td>
        <td>KohonenNetworkApplicabilityDomain</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>AddNetworkWithWeight( const KohonenNetworkAverage &OTHER, const float &WEIGHT)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>FixEmptyNodes()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>GetCodeBook()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>GetCodeBook() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>GetIndexOfWinningNode( const linal::VectorConstInterface< float> &VECTOR, const size_t &HINT = size_t( 0) ) const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>GetMapDimensions() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>GetNumberOutputs() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>GetWinningNodeIndices( const FeatureDataSetInterface< float> &NORMALIZED_DATA, const math::Range< size_t> &RANGE, const storage::Vector< size_t> &ORDER, storage::Vector< size_t> &PREVIOUS_WINNERS, storage::Vector< sched::Mutex> &MUTECES ) const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>InitializeNodes( const descriptor::Dataset &NORMALIZED_DATA)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>KohonenNetworkAverage( const linal::Vector< double> &MAP_DIMENSIONS, const util::ShPtr< RescaleFeatureDataSet> &RESCALE = util::ShPtr< RescaleFeatureDataSet>() )
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>KohonenNetworkAverage()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE ) const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>Rescale( FeatureDataSet< float> &FEATURE) const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>Reset()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_network_average.h</td>
        <td>KohonenNetworkAverage</td>
        <td>operator +=( const KohonenNetworkAverage &OTHER)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>AddNodeWithWeight( const KohonenNode &OTHER, const float &WEIGHT)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>GetFeatureVector() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>GetPosition() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>GetResultVector() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>GetWeight() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>KohonenNode( const linal::Vector< float> &POSITION, const linal::Vector< float> &FEATURE_VECTOR, const linal::Vector< float> &RESULT_VECTOR )
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>KohonenNode()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>MapData( const linal::VectorConstInterface< float> &FEATURE, const linal::VectorConstInterface< float> &RESULT, const double &ALPHA = 1.0 )
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>Reset()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_kohonen_node.h</td>
        <td>KohonenNode</td>
        <td>operator +=( const KohonenNode &OTHER)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_leverage_matrix.h</td>
        <td>LeverageMatrix</td>
        <td>GetNumberOutputs() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_leverage_matrix.h</td>
        <td>LeverageMatrix</td>
        <td>GetWeights() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_leverage_matrix.h</td>
        <td>LeverageMatrix</td>
        <td>LeverageMatrix( const linal::MatrixConstInterface< float> &WEIGHTS, const util::ShPtr< RescaleFeatureDataSet> &RESCALE = util::ShPtr< RescaleFeatureDataSet>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_leverage_matrix.h</td>
        <td>LeverageMatrix</td>
        <td>LeverageMatrix()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_leverage_matrix.h</td>
        <td>LeverageMatrix</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_leverage_matrix.h</td>
        <td>LeverageMatrix</td>
        <td>Rescale( FeatureDataSet< float> &FEATURE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_leverage_matrix.h</td>
        <td>LeverageMatrix</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>GetAllKeys() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>GetDirectory() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>GetSize() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>Initialize()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>IsValidKey( const std::string &KEY)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>RetrieveAllDescriptors() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>RetrieveBestDescriptorSetByResult() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>RetrieveDescriptorSet( const std::string &KEY) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>Store( const float RESULT, const util::ObjectDataLabel &DESCRIPTORS, const util::ObjectDataLabel &METHOD_NAME, const util::ObjectDataLabel &OBJECTIVE_FUNCTION )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_meta_data_storage_file.h</td>
        <td>MetaDataStorageFile</td>
        <td>Store( const float RESULT, const util::ObjectDataLabel &DESCRIPTORS, const util::ObjectDataLabel &METHOD_NAME, const util::ObjectDataLabel &OBJECTIVE_FUNCTION, const std::string &KEY )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_multiple_linear_regression.h</td>
        <td>MultipleLinearRegression</td>
        <td>GetNumberOutputs() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_multiple_linear_regression.h</td>
        <td>MultipleLinearRegression</td>
        <td>GetWeights() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_multiple_linear_regression.h</td>
        <td>MultipleLinearRegression</td>
        <td>MultipleLinearRegression( const linal::MatrixConstInterface< float> &WEIGHTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_multiple_linear_regression.h</td>
        <td>MultipleLinearRegression</td>
        <td>MultipleLinearRegression()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_multiple_linear_regression.h</td>
        <td>MultipleLinearRegression</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_multiple_linear_regression.h</td>
        <td>MultipleLinearRegression</td>
        <td>Rescale( FeatureDataSet< float> &FEATURE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_multiple_linear_regression.h</td>
        <td>MultipleLinearRegression</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>Append( const util::ShPtr< NeuralNetwork> &NETWORK)
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>ComputeResultInputSensitivity( const linal::VectorConstInterface< float> &FEATURE) const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetArchitecture() const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetBias() const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetNumberInputs() const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetNumberLayers() const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetNumberOutputs() const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetRescaleInput() const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetTransferFunction() const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetWeight() const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>NeuralNetwork( const NeuralNetwork &NETWORK)
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>NeuralNetwork( const util::ShPtr< RescaleFeatureDataSet> &RESCALE_INPUT, const util::ShPtr< RescaleFeatureDataSet> &RESCALE_OUTPUT, const storage::Vector< linal::Vector< float> > &BIAS, const storage::Vector< linal::Matrix< float> > &WEIGHT, const util::Implementation< TransferFunctionInterface> &TRANSFER_FUNCTION )
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>NeuralNetwork()
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE ) const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>RemoveInputLayer()
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>RemoveOutputLayer()
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>Rescale( FeatureDataSet< float> &FEATURE) const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>SetArchitecture( const storage::Vector< size_t> &ARCHITECTURE)
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>SetBias( const storage::Vector< linal::Vector< float> > &BIAS)
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>SetRescaleOutput( const util::ShPtr< RescaleFeatureDataSet> &RESCALING)
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>SetWeight( const storage::Vector< linal::Matrix< float> > &WEIGHT)
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>TestWithDropout( const FeatureDataSetInterface< float> &FEATURE, const storage::Vector< double> &DROPOUT_RATIOS, const size_t &NREPEATS ) const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>mueller, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_perturb_attenuate.h</td>
        <td>NeuralNetworkPerturbAttenuate</td>
        <td>operator ()( linal::Matrix< float> &WEIGHTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_perturb_max_norm.h</td>
        <td>NeuralNetworkPerturbMaxNorm</td>
        <td>operator ()( linal::Matrix< float> &WEIGHTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_accuracy.h</td>
        <td>NeuralNetworkSelectiveBackpropagationAccuracy</td>
        <td>FinalizeRound()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_accuracy.h</td>
        <td>NeuralNetworkSelectiveBackpropagationAccuracy</td>
        <td>Initialize( const descriptor::Dataset &RESCALED_DATA, const ObjectiveFunctionInterface &OBJECTIVE, const size_t &NUMBER_THREADS = size_t( 1) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_accuracy.h</td>
        <td>NeuralNetworkSelectiveBackpropagationAccuracy</td>
        <td>NeuralNetworkSelectiveBackpropagationAccuracy()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_accuracy.h</td>
        <td>NeuralNetworkSelectiveBackpropagationAccuracy</td>
        <td>ShouldBackpropagate( const linal::VectorConstInterface< float> &PREDICTION, linal::VectorInterface< float> &ERROR, const size_t &FEATURE_ID, const size_t &THREAD_ID )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_adaptive_tolerance.h</td>
        <td>NeuralNetworkSelectiveBackpropagationAdaptiveTolerance</td>
        <td>FinalizeRound()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_adaptive_tolerance.h</td>
        <td>NeuralNetworkSelectiveBackpropagationAdaptiveTolerance</td>
        <td>Initialize( const descriptor::Dataset &RESCALED_DATA, const ObjectiveFunctionInterface &OBJECTIVE, const size_t &NUMBER_THREADS = size_t( 1) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_adaptive_tolerance.h</td>
        <td>NeuralNetworkSelectiveBackpropagationAdaptiveTolerance</td>
        <td>NeuralNetworkSelectiveBackpropagationAdaptiveTolerance()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_adaptive_tolerance.h</td>
        <td>NeuralNetworkSelectiveBackpropagationAdaptiveTolerance</td>
        <td>ShouldBackpropagate( const linal::VectorConstInterface< float> &PREDICTION, linal::VectorInterface< float> &ERROR, const size_t &FEATURE_ID, const size_t &THREAD_ID )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_balanced.h</td>
        <td>NeuralNetworkSelectiveBackpropagationBalanced</td>
        <td>FinalizeRound()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_balanced.h</td>
        <td>NeuralNetworkSelectiveBackpropagationBalanced</td>
        <td>Initialize( const descriptor::Dataset &RESCALED_DATA, const ObjectiveFunctionInterface &OBJECTIVE, const size_t &NUMBER_THREADS = size_t( 1) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_balanced.h</td>
        <td>NeuralNetworkSelectiveBackpropagationBalanced</td>
        <td>NeuralNetworkSelectiveBackpropagationBalanced()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_balanced.h</td>
        <td>NeuralNetworkSelectiveBackpropagationBalanced</td>
        <td>ShouldBackpropagate( const linal::VectorConstInterface< float> &PREDICTION, linal::VectorInterface< float> &ERROR, const size_t &FEATURE_ID, const size_t &THREAD_ID )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_default.h</td>
        <td>NeuralNetworkSelectiveBackpropagationDefault</td>
        <td>FinalizeRound()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_default.h</td>
        <td>NeuralNetworkSelectiveBackpropagationDefault</td>
        <td>Initialize( const descriptor::Dataset &RESCALED_DATA, const ObjectiveFunctionInterface &OBJECTIVE, const size_t &NUMBER_THREADS = size_t( 1) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_default.h</td>
        <td>NeuralNetworkSelectiveBackpropagationDefault</td>
        <td>ShouldBackpropagate( const linal::VectorConstInterface< float> &PREDICTION, linal::VectorInterface< float> &ERROR, const size_t &FEATURE_ID, const size_t &THREAD_ID )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_hybrid.h</td>
        <td>NeuralNetworkSelectiveBackpropagationHybrid</td>
        <td>FinalizeRound()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_hybrid.h</td>
        <td>NeuralNetworkSelectiveBackpropagationHybrid</td>
        <td>Initialize( const descriptor::Dataset &RESCALED_DATA, const ObjectiveFunctionInterface &OBJECTIVE, const size_t &NUMBER_THREADS = size_t( 1) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_hybrid.h</td>
        <td>NeuralNetworkSelectiveBackpropagationHybrid</td>
        <td>NeuralNetworkSelectiveBackpropagationHybrid()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_hybrid.h</td>
        <td>NeuralNetworkSelectiveBackpropagationHybrid</td>
        <td>ShouldBackpropagate( const linal::VectorConstInterface< float> &PREDICTION, linal::VectorInterface< float> &ERROR, const size_t &FEATURE_ID, const size_t &THREAD_ID )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_interface.h</td>
        <td>NeuralNetworkSelectiveBackpropagationInterface</td>
        <td>ConstitutionMapping( storage::Vector< size_t> &ORDER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_interface.h</td>
        <td>NeuralNetworkSelectiveBackpropagationInterface</td>
        <td>FinalizeConformation()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_leading_sequence.h</td>
        <td>NeuralNetworkSelectiveBackpropagationLeadingSequence</td>
        <td>ConstitutionMapping( storage::Vector< size_t> &ORDER )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_leading_sequence.h</td>
        <td>NeuralNetworkSelectiveBackpropagationLeadingSequence</td>
        <td>FinalizeConformation()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_leading_sequence.h</td>
        <td>NeuralNetworkSelectiveBackpropagationLeadingSequence</td>
        <td>FinalizeRound()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_leading_sequence.h</td>
        <td>NeuralNetworkSelectiveBackpropagationLeadingSequence</td>
        <td>Initialize( const descriptor::Dataset &RESCALED_DATA, const ObjectiveFunctionInterface &OBJECTIVE, const size_t &NUMBER_THREADS = size_t( 1) )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_leading_sequence.h</td>
        <td>NeuralNetworkSelectiveBackpropagationLeadingSequence</td>
        <td>NeuralNetworkSelectiveBackpropagationLeadingSequence()
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_leading_sequence.h</td>
        <td>NeuralNetworkSelectiveBackpropagationLeadingSequence</td>
        <td>ShouldBackpropagate( const linal::VectorConstInterface< float> &PREDICTION, linal::VectorInterface< float> &ERROR, const size_t &FEATURE_ID, const size_t &THREAD_ID )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_tolerance.h</td>
        <td>NeuralNetworkSelectiveBackpropagationTolerance</td>
        <td>FinalizeRound()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_tolerance.h</td>
        <td>NeuralNetworkSelectiveBackpropagationTolerance</td>
        <td>Initialize( const descriptor::Dataset &RESCALED_DATA, const ObjectiveFunctionInterface &OBJECTIVE, const size_t &NUMBER_THREADS = size_t( 1) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_selective_backpropagation_tolerance.h</td>
        <td>NeuralNetworkSelectiveBackpropagationTolerance</td>
        <td>NeuralNetworkSelectiveBackpropagationTolerance()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_selective_backpropagation_tolerance.h</td>
        <td>NeuralNetworkSelectiveBackpropagationTolerance</td>
        <td>ShouldBackpropagate( const linal::VectorConstInterface< float> &PREDICTION, linal::VectorInterface< float> &ERROR, const size_t &FEATURE_ID, const size_t &THREAD_ID )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_update_weights_bounded_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsBoundedSimplePropagation</td>
        <td>GetChanges() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_update_weights_bounded_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsBoundedSimplePropagation</td>
        <td>Initialize( const size_t &SIZE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_update_weights_bounded_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsBoundedSimplePropagation</td>
        <td>NeuralNetworkUpdateWeightsBoundedSimplePropagation()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_update_weights_bounded_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsBoundedSimplePropagation</td>
        <td>SetChanges( const linal::VectorConstInterface< float> &CHANGES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_update_weights_bounded_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsBoundedSimplePropagation</td>
        <td>operator ()( float *const &WEIGHTS, float *const &SLOPES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_update_weights_resilient_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsResilientPropagation</td>
        <td>GetChanges() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_update_weights_resilient_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsResilientPropagation</td>
        <td>Initialize( const size_t &SIZE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_update_weights_resilient_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsResilientPropagation</td>
        <td>NeuralNetworkUpdateWeightsResilientPropagation()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_update_weights_resilient_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsResilientPropagation</td>
        <td>SetChanges( const linal::VectorConstInterface< float> &CHANGES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_update_weights_resilient_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsResilientPropagation</td>
        <td>operator ()( float *const &WEIGHTS, float *const &SLOPES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_update_weights_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsSimplePropagation</td>
        <td>GetChanges() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_update_weights_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsSimplePropagation</td>
        <td>Initialize( const size_t &SIZE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_update_weights_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsSimplePropagation</td>
        <td>NeuralNetworkUpdateWeightsSimplePropagation()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_neural_network_update_weights_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsSimplePropagation</td>
        <td>SetChanges( const linal::VectorConstInterface< float> &CHANGES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_neural_network_update_weights_simple_propagation.h</td>
        <td>NeuralNetworkUpdateWeightsSimplePropagation</td>
        <td>operator ()( float *const &WEIGHTS, float *const &SLOPES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_accuracy.h</td>
        <td>ObjectiveFunctionAccuracy</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_accuracy.h</td>
        <td>ObjectiveFunctionAccuracy</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_accuracy.h</td>
        <td>ObjectiveFunctionAccuracy</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_accuracy.h</td>
        <td>ObjectiveFunctionAccuracy</td>
        <td>ObjectiveFunctionAccuracy( const float &ACTIVITY_CUTOFF)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_accuracy.h</td>
        <td>ObjectiveFunctionAccuracy</td>
        <td>ObjectiveFunctionAccuracy()
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_accuracy.h</td>
        <td>ObjectiveFunctionAccuracy</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_accuracy.h</td>
        <td>ObjectiveFunctionAccuracy</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl, lemmonwa</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_accuracy_with_excluded_range.h</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange</td>
        <td>GetFeaturePredictionClassifications( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_accuracy_with_excluded_range.h</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_accuracy_with_excluded_range.h</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_accuracy_with_excluded_range.h</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_accuracy_with_excluded_range.h</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange( const float &ACTIVITY_CUTOFF)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_accuracy_with_excluded_range.h</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_accuracy_with_excluded_range.h</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_accuracy_with_excluded_range.h</td>
        <td>ObjectiveFunctionAccuracyWithExcludedRange</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>GetDesiredHitRate() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>GetGoalType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>GetImprovementType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>GetRankingParity() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>GetThreshold() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>GetWeightingFunction() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>ObjectiveFunctionAucRocCurve( const float CUTOFF, const bool POSITIVES_ABOVE_THRESHOLD )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>ObjectiveFunctionAucRocCurve( const float CUTOFF, const math::Polynomial &WEIGHTING_FUNCTION, const bool POSITIVES_ABOVE_THRESHOLD )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>ObjectiveFunctionAucRocCurve()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>SetCutoff( const float &CUTOFF)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>SetWeightingFunction( const math::Polynomial &WEIGHTING_FUNCTION)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_auc_roc_curve.h</td>
        <td>ObjectiveFunctionAucRocCurve</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_binary_operation.h</td>
        <td>ObjectiveFunctionBinaryOperation</td>
        <td>GetDesiredHitRate() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_binary_operation.h</td>
        <td>ObjectiveFunctionBinaryOperation</td>
        <td>GetFeaturePredictionClassifications( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_binary_operation.h</td>
        <td>ObjectiveFunctionBinaryOperation</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_binary_operation.h</td>
        <td>ObjectiveFunctionBinaryOperation</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_binary_operation.h</td>
        <td>ObjectiveFunctionBinaryOperation</td>
        <td>GetRankingParity() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_binary_operation.h</td>
        <td>ObjectiveFunctionBinaryOperation</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_binary_operation.h</td>
        <td>ObjectiveFunctionBinaryOperation</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_binary_operation.h</td>
        <td>ObjectiveFunctionBinaryOperation</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_binary_operation.h</td>
        <td>ObjectiveFunctionBinaryOperation</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>GetDesiredHitRate() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>GetFeaturePredictionClassifications( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>GetRankingParity() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>ObjectiveFunctionBootstrap()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_bootstrap.h</td>
        <td>ObjectiveFunctionBootstrap</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_categorical_max.h</td>
        <td>ObjectiveFunctionCategoricalMax</td>
        <td>GetFeaturePredictionClassifications( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_categorical_max.h</td>
        <td>ObjectiveFunctionCategoricalMax</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_categorical_max.h</td>
        <td>ObjectiveFunctionCategoricalMax</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_categorical_max.h</td>
        <td>ObjectiveFunctionCategoricalMax</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_categorical_max.h</td>
        <td>ObjectiveFunctionCategoricalMax</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_categorical_max.h</td>
        <td>ObjectiveFunctionCategoricalMax</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_constant.h</td>
        <td>ObjectiveFunctionConstant</td>
        <td>GetGoalType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_constant.h</td>
        <td>ObjectiveFunctionConstant</td>
        <td>GetImprovementType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_constant.h</td>
        <td>ObjectiveFunctionConstant</td>
        <td>GetThreshold() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_constant.h</td>
        <td>ObjectiveFunctionConstant</td>
        <td>ObjectiveFunctionConstant( const float CONST_VALUE, opti::ImprovementType IMPROVE, GoalEnum GOAL = e_Other, const float &CUTOFF = util::GetUndefined< float>() )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_constant.h</td>
        <td>ObjectiveFunctionConstant</td>
        <td>ObjectiveFunctionConstant()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_constant.h</td>
        <td>ObjectiveFunctionConstant</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_constant.h</td>
        <td>ObjectiveFunctionConstant</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_contingency_matrix_measure.h</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_contingency_matrix_measure.h</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_contingency_matrix_measure.h</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure</td>
        <td>GetRankingParity() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_contingency_matrix_measure.h</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_contingency_matrix_measure.h</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure( const float &ACTIVITY_CUTOFF, const math::ContingencyMatrixMeasures &MEASURE, const bool &POSITIVES_ABOVE_THRESHOLD = false, const bool &OPTIMIZE_CUTOFF = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_contingency_matrix_measure.h</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_contingency_matrix_measure.h</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_contingency_matrix_measure.h</td>
        <td>ObjectiveFunctionContingencyMatrixMeasure</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>GetDesiredHitRate() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>GetFeaturePredictionClassifications( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>GetRankingParity() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>ObjectiveFunctionCutoffFromPercentile()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_cutoff_from_percentile.h</td>
        <td>ObjectiveFunctionCutoffFromPercentile</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>GetDesiredHitRate() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>GetGoalType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>GetImprovementType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>GetOverSamplingFactor() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>GetRankingParity() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>GetThreshold() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>ObjectiveFunctionEnrichment( const float CUTOFF, const float OVERSAMPLING_FACTOR, const bool POSITIVES_ABOVE_THRESHOLD )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>ObjectiveFunctionEnrichment()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>SetCutoff( const float &CUTOFF)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>SetOverSamplingFactor( const float &FACTOR)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment.h</td>
        <td>ObjectiveFunctionEnrichment</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>GetDesiredHitRate() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>GetGoalType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>GetImprovementType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>GetRankingParity() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>GetThreshold() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>ObjectiveFunctionEnrichmentAverage( const float CUTOFF, const float ENRICHMENT_CUTOFF_MAX, const float ENRICHMENT_CUTOFF_STEPSIZE, const bool POSITIVES_ABOVE_THRESHOLD )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>ObjectiveFunctionEnrichmentAverage()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>SetCutoff( const float &CUTOFF)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_enrichment_average.h</td>
        <td>ObjectiveFunctionEnrichmentAverage</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_information_gain_ratio.h</td>
        <td>ObjectiveFunctionInformationGainRatio</td>
        <td>GetGoalType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_information_gain_ratio.h</td>
        <td>ObjectiveFunctionInformationGainRatio</td>
        <td>GetImprovementType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_information_gain_ratio.h</td>
        <td>ObjectiveFunctionInformationGainRatio</td>
        <td>GetRankingParity() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_information_gain_ratio.h</td>
        <td>ObjectiveFunctionInformationGainRatio</td>
        <td>GetThreshold() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_information_gain_ratio.h</td>
        <td>ObjectiveFunctionInformationGainRatio</td>
        <td>ObjectiveFunctionInformationGainRatio( const float CUTOFF, const bool POSITIVES_ABOVE_THRESHOLD )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_information_gain_ratio.h</td>
        <td>ObjectiveFunctionInformationGainRatio</td>
        <td>ObjectiveFunctionInformationGainRatio()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_information_gain_ratio.h</td>
        <td>ObjectiveFunctionInformationGainRatio</td>
        <td>SetCutoff( const float &CUTOFF)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_information_gain_ratio.h</td>
        <td>ObjectiveFunctionInformationGainRatio</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_information_gain_ratio.h</td>
        <td>ObjectiveFunctionInformationGainRatio</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>GetDesiredHitRate() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>GetGoalType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>GetImprovementType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>GetRankingParity() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>GetThreshold() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted( const float CUTOFF, const math::Range< double> &FRACTION_PRED_POS_CUTOFF, const bool POSITIVES_ABOVE_THRESHOLD )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_integral_precision_fraction_predicted.h</td>
        <td>ObjectiveFunctionIntegralPrecisionFractionPredicted</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_tnr_tpr.h</td>
        <td>ObjectiveFunctionIntegralTnrTpr</td>
        <td>GetGoalType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_integral_tnr_tpr.h</td>
        <td>ObjectiveFunctionIntegralTnrTpr</td>
        <td>GetImprovementType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_tnr_tpr.h</td>
        <td>ObjectiveFunctionIntegralTnrTpr</td>
        <td>GetRankingParity() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_integral_tnr_tpr.h</td>
        <td>ObjectiveFunctionIntegralTnrTpr</td>
        <td>GetThreshold() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_tnr_tpr.h</td>
        <td>ObjectiveFunctionIntegralTnrTpr</td>
        <td>ObjectiveFunctionIntegralTnrTpr( const float CUTOFF, const bool POSITIVES_ABOVE_THRESHOLD )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_integral_tnr_tpr.h</td>
        <td>ObjectiveFunctionIntegralTnrTpr</td>
        <td>ObjectiveFunctionIntegralTnrTpr()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_tnr_tpr.h</td>
        <td>ObjectiveFunctionIntegralTnrTpr</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_integral_tnr_tpr.h</td>
        <td>ObjectiveFunctionIntegralTnrTpr</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_integral_tnr_tpr.h</td>
        <td>ObjectiveFunctionIntegralTnrTpr</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_interface.h</td>
        <td>ObjectiveFunctionInterface</td>
        <td>GetDesiredHitRate() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_interface.h</td>
        <td>ObjectiveFunctionInterface</td>
        <td>GetFeaturePredictionClassifications( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_interface.h</td>
        <td>ObjectiveFunctionInterface</td>
        <td>GetGoalName( const Goal &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_interface.h</td>
        <td>ObjectiveFunctionInterface</td>
        <td>GetRankingParity() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_interface.h</td>
        <td>ObjectiveFunctionInterface</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_interface.h</td>
        <td>ObjectiveFunctionInterface</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_interface.h</td>
        <td>ObjectiveFunctionInterface</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_mae.h</td>
        <td>ObjectiveFunctionMae</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_mae.h</td>
        <td>ObjectiveFunctionMae</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_mae.h</td>
        <td>ObjectiveFunctionMae</td>
        <td>ObjectiveFunctionMae( const Normalization &NORM = e_None)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_mae.h</td>
        <td>ObjectiveFunctionMae</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_mae.h</td>
        <td>ObjectiveFunctionMae</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_partial.h</td>
        <td>ObjectiveFunctionPartial</td>
        <td>GetDesiredHitRate() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_partial.h</td>
        <td>ObjectiveFunctionPartial</td>
        <td>GetFeaturePredictionClassifications( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_partial.h</td>
        <td>ObjectiveFunctionPartial</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_partial.h</td>
        <td>ObjectiveFunctionPartial</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_partial.h</td>
        <td>ObjectiveFunctionPartial</td>
        <td>GetRankingParity() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_partial.h</td>
        <td>ObjectiveFunctionPartial</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_partial.h</td>
        <td>ObjectiveFunctionPartial</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_partial.h</td>
        <td>ObjectiveFunctionPartial</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_partial.h</td>
        <td>ObjectiveFunctionPartial</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_rmsd.h</td>
        <td>ObjectiveFunctionRmsd</td>
        <td>GetGoalType() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_rmsd.h</td>
        <td>ObjectiveFunctionRmsd</td>
        <td>GetImprovementType() const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_rmsd.h</td>
        <td>ObjectiveFunctionRmsd</td>
        <td>ObjectiveFunctionRmsd( const Normalization &NORM = e_None)
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_rmsd.h</td>
        <td>ObjectiveFunctionRmsd</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_segment_overlap.h</td>
        <td>ObjectiveFunctionSegmentOverlap</td>
        <td>ObjectiveFunctionSegmentOverlap()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_segment_overlap.h</td>
        <td>ObjectiveFunctionSegmentOverlap</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_segment_overlap.h</td>
        <td>ObjectiveFunctionSegmentOverlap</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_selective.h</td>
        <td>ObjectiveFunctionSelective</td>
        <td>GetDesiredHitRate() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_selective.h</td>
        <td>ObjectiveFunctionSelective</td>
        <td>GetFeaturePredictionClassifications( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_selective.h</td>
        <td>ObjectiveFunctionSelective</td>
        <td>GetGoalType() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_selective.h</td>
        <td>ObjectiveFunctionSelective</td>
        <td>GetImprovementType() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_selective.h</td>
        <td>ObjectiveFunctionSelective</td>
        <td>GetRankingParity() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_selective.h</td>
        <td>ObjectiveFunctionSelective</td>
        <td>GetThreshold() const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_selective.h</td>
        <td>ObjectiveFunctionSelective</td>
        <td>SetData( const FeatureDataSet< float> &DATA, const FeatureDataSet< char> &IDS = FeatureDataSet< char>() )
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_selective.h</td>
        <td>ObjectiveFunctionSelective</td>
        <td>SetThreshold( const float &THRESHOLD)
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_selective.h</td>
        <td>ObjectiveFunctionSelective</td>
        <td>operator ()( const FeatureDataSetInterface< float> &EXPERIMENTAL, const FeatureDataSetInterface< float> &PREDICTED ) const
</td>
        <td>kothiwsk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>Evaluate( FeatureDataSet< float> &PREDICTIONS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>GetData() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>GetDesiredHitRate() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>GetGoalType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>GetImplementation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>GetRankingParity() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>GetThreshold() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>ObjectiveFunctionWrapper( const util::Implementation< ObjectiveFunctionInterface> &SPECIALIZATION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>ObjectiveFunctionWrapper( util::ShPtr< descriptor::Dataset> &DATA, const util::Implementation< ObjectiveFunctionInterface> &SPECIALIZATION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>ObjectiveFunctionWrapper()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>OptimizeRescalingFunction( const util::ShPtr< RescaleFeatureDataSet> &RESCALE, const FeatureDataSet< float> &PREDICTIONS ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>Predict( const util::PtrInterface< Interface> &MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>SetData( util::ShPtr< descriptor::Dataset> &DATA, const util::ShPtr< RescaleFeatureDataSet> &RESCALE_INPUT )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>TestWhetherResultsImproved( const float &NEW_RESULT, const float &OLD_RESULT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_objective_function_wrapper.h</td>
        <td>ObjectiveFunctionWrapper</td>
        <td>operator ()( const util::PtrInterface< Interface> &MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_pretrain_neural_network_from_file.h</td>
        <td>PretrainNeuralNetworkFromFile</td>
        <td>PretrainNetwork( util::ShPtr< descriptor::Dataset> &DATA, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_pretrain_stacked_auto_encoder.h</td>
        <td>PretrainStackedAutoEncoder</td>
        <td>GetCurrentModel() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_pretrain_stacked_auto_encoder.h</td>
        <td>PretrainStackedAutoEncoder</td>
        <td>PretrainNetwork( util::ShPtr< descriptor::Dataset> &DATA, const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE )
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_pretrain_stacked_auto_encoder.h</td>
        <td>PretrainStackedAutoEncoder</td>
        <td>PretrainStackedAutoEncoder( util::ShPtr< descriptor::Dataset> &TRAINING_DATA )
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_pretrain_stacked_auto_encoder.h</td>
        <td>PretrainStackedAutoEncoder</td>
        <td>PretrainStackedAutoEncoder()
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_pretrain_stacked_auto_encoder.h</td>
        <td>PretrainStackedAutoEncoder</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_pretrain_stacked_auto_encoder.h</td>
        <td>PretrainStackedAutoEncoder</td>
        <td>TrainNextLayer( const util::ShPtr< ObjectiveFunctionWrapper> &OBJECTIVE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>DeScale( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>DeScaleMatrix( linal::MatrixInterface< float> &MATRIX) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>DescaleValue( const size_t &COLUMN, const float &VALUE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>GetDefaultValueForEmptyRangedColumns()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>GetRange() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>GetRescaleRanges() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>GetSize() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>GetTypeName( const Type &TYPE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>RescaleFeatureDataSet( const FeatureDataSetInterface< float> &DATA, const math::Range< float> &RANGE, const Type &TYPE = e_MinMax )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>RescaleFeatureDataSet( const RescaleFeatureDataSet &RESCALING, const util::ShPtrVector< math::FunctionInterfaceSerializable< double, double> > &MODIFIERS )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>RescaleFeatureDataSet( const linal::MatrixConstInterface< float> &DATA, const math::Range< float> &RANGE, const Type &TYPE = e_MinMax )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>RescaleFeatureDataSet()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>RescaleMatrix( linal::MatrixInterface< float> &MATRIX) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>RescaleValue( const size_t &COLUMN, const float &VALUE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>operator !=( const RescaleFeatureDataSet &OTHER) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_rescale_feature_data_set.h</td>
        <td>RescaleFeatureDataSet</td>
        <td>operator ==( const RescaleFeatureDataSet &OTHER) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>BackPropagate( linal::VectorInterface< float> &INPUT, const linal::VectorInterface< float> &HIDDEN, const bool STOCHASTIC ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>ComputeReconstructionError( const FeatureDataSetInterface< float> &DATA) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>ComputeReconstructionError( const linal::VectorConstInterface< float> &INPUT, linal::VectorInterface< float> &HIDDEN, linal::VectorInterface< float> &INPUT_RECONSTRUCTED ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>ForwardPropagate( const linal::VectorConstInterface< float> &INPUT, linal::VectorInterface< float> &HIDDEN, const bool STOCHASTIC ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>GetHiddenBias() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>GetNumberHiddenNeurons() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>GetNumberInputNeurons() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>GetTypeName( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>GetVisibleBias() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>GetWeight() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>GibbsSample( const linal::VectorConstInterface< float> &INPUT, linal::VectorInterface< float> &HIDDEN, linal::VectorInterface< float> &INPUT_RECONSTRUCTED, linal::VectorInterface< float> &HIDDEN_RECONSTRUCTED, const size_t &STOCHASTIC_STEP_COUNT, linal::VectorInterface< float> &HIDDEN_SAMPLE, linal::VectorInterface< float> &VISIBLE_SAMPLE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>Invert()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>RestrictedBoltzmannMachineLayer( const linal::Vector< float> &BIAS_VISIBLE, const linal::Vector< float> &BIAS_HIDDEN, const linal::Matrix< float> &WEIGHT, const Type &NETWORK_TYPE = e_StochasticSigmoid )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>RestrictedBoltzmannMachineLayer( const size_t &NUMBER_VISIBLE, const size_t &NUMBER_HIDDEN, const Type &NETWORK_TYPE = e_StochasticSigmoid )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>RestrictedBoltzmannMachineLayer()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_restricted_boltzmann_machine_layer.h</td>
        <td>RestrictedBoltzmannMachineLayer</td>
        <td>SetArchitecture( const size_t &NUMBER_INPUTS, const size_t &NUMBER_OUTPUTS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>RequiresResultLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_balanced.h</td>
        <td>RetrieveDataSetBalanced</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>GenerateDataSubset( const math::Range< size_t> &SUBSET, linal::MatrixInterface< float> &FEATURES_STORAGE, linal::MatrixInterface< float> &RESULTS_STORAGE, linal::MatrixInterface< char> &IDS_STORAGE, const size_t &START_FEATURE_NUMBER )
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>GetFeatureCode() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>GetIdCode() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>GetResultCode() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>GetStartEndPositionOfRange( const math::Range< size_t> RANGE_OF_IDS, const size_t NUMBER_RANGES, const size_t TOTAL_SIZE_OF_DATASET )
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>RequiresResultLabels() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>SelectFeaturesGivenFilenameFlag( const command::FlagInterface &FLAG)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>SelectIdsGivenFilenameFlag( const command::FlagInterface &FLAG)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>SelectResultsGivenFilenameFlag( const command::FlagInterface &FLAG)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_base.h</td>
        <td>RetrieveDataSetBase</td>
        <td>SupportsEfficientSubsetLoading() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_bootstrap.h</td>
        <td>RetrieveDataSetBootstrap</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_bootstrap.h</td>
        <td>RetrieveDataSetBootstrap</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_bootstrap.h</td>
        <td>RetrieveDataSetBootstrap</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_bootstrap.h</td>
        <td>RetrieveDataSetBootstrap</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_bootstrap.h</td>
        <td>RetrieveDataSetBootstrap</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_bootstrap.h</td>
        <td>RetrieveDataSetBootstrap</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_bootstrap.h</td>
        <td>RetrieveDataSetBootstrap</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_bootstrap.h</td>
        <td>RetrieveDataSetBootstrap</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>GetFeatureRanges() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>RequiresResultLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>RetrieveDataSetByFeature( const bool &RETRIEVE_FEATURES = true, const bool &JUST_FILTER = false, const size_t &FEATURE_INDEX = util::GetUndefined< size_t>(), const math::RangeSet< float> &RANGES = math::RangeSet< float>::GetCompleteRange(), const util::Implementation< RetrieveDataSetBase> &RETRIEVER = util::Implementation< RetrieveDataSetBase>(), const std::string &DESCRIPTOR = std::string() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_feature.h</td>
        <td>RetrieveDataSetByFeature</td>
        <td>operator ()( const util::ShPtr< descriptor::Dataset> &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>GetSelectedIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>RequiresResultLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>RetrieveDataSetById( const storage::Set< std::string> &IDS = storage::Set< std::string>(), const util::Implementation< RetrieveDataSetBase> &RETRIEVER = util::Implementation< RetrieveDataSetBase>(), const bool &JUST_FILTER = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_id.h</td>
        <td>RetrieveDataSetById</td>
        <td>operator ()( const util::ShPtr< descriptor::Dataset> &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>GetResultRanges() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>RequiresResultLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>RetrieveDataSetByResult( const math::RangeSet< float> &RANGES = math::RangeSet< float>::GetCompleteRange(), const util::Implementation< RetrieveDataSetBase> &RETRIEVER = util::Implementation< RetrieveDataSetBase>(), const bool &FILTER_ONLY = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_by_result.h</td>
        <td>RetrieveDataSetByResult</td>
        <td>operator ()( const util::ShPtr< descriptor::Dataset> &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_chunk.h</td>
        <td>RetrieveDataSetChunk</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_chunk.h</td>
        <td>RetrieveDataSetChunk</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_chunk.h</td>
        <td>RetrieveDataSetChunk</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_chunk.h</td>
        <td>RetrieveDataSetChunk</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_chunk.h</td>
        <td>RetrieveDataSetChunk</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_chunk.h</td>
        <td>RetrieveDataSetChunk</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_chunk.h</td>
        <td>RetrieveDataSetChunk</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_chunk.h</td>
        <td>RetrieveDataSetChunk</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_combined.h</td>
        <td>RetrieveDataSetCombined</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_combined.h</td>
        <td>RetrieveDataSetCombined</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_combined.h</td>
        <td>RetrieveDataSetCombined</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_combined.h</td>
        <td>RetrieveDataSetCombined</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_combined.h</td>
        <td>RetrieveDataSetCombined</td>
        <td>RequiresFeatureLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_combined.h</td>
        <td>RetrieveDataSetCombined</td>
        <td>RequiresResultLabels() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_combined.h</td>
        <td>RetrieveDataSetCombined</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_combined.h</td>
        <td>RetrieveDataSetCombined</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_combined.h</td>
        <td>RetrieveDataSetCombined</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_encoded_by_model.h</td>
        <td>RetrieveDataSetEncodedByModel</td>
        <td>GenerateDataSet()
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_encoded_by_model.h</td>
        <td>RetrieveDataSetEncodedByModel</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_encoded_by_model.h</td>
        <td>RetrieveDataSetEncodedByModel</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_encoded_by_model.h</td>
        <td>RetrieveDataSetEncodedByModel</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_encoded_by_model.h</td>
        <td>RetrieveDataSetEncodedByModel</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_encoded_by_model.h</td>
        <td>RetrieveDataSetEncodedByModel</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_encoded_by_model.h</td>
        <td>RetrieveDataSetEncodedByModel</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_encoded_by_model.h</td>
        <td>RetrieveDataSetEncodedByModel</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_from_delimited_file.h</td>
        <td>RetrieveDataSetFromDelimitedFile</td>
        <td>GenerateDataSet()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_from_delimited_file.h</td>
        <td>RetrieveDataSetFromDelimitedFile</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_from_delimited_file.h</td>
        <td>RetrieveDataSetFromDelimitedFile</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_from_delimited_file.h</td>
        <td>RetrieveDataSetFromDelimitedFile</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_from_delimited_file.h</td>
        <td>RetrieveDataSetFromDelimitedFile</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_from_delimited_file.h</td>
        <td>RetrieveDataSetFromDelimitedFile</td>
        <td>RetrieveDataSetFromDelimitedFile( const std::string &FILENAME = std::string(), const size_t &NUMBER_RESULT_COLS = 1, const size_t &NUMBER_ID_CHARS = 0 )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_from_file.h</td>
        <td>RetrieveDataSetFromFile</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_from_file.h</td>
        <td>RetrieveDataSetFromFile</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_from_file.h</td>
        <td>RetrieveDataSetFromFile</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_from_file.h</td>
        <td>RetrieveDataSetFromFile</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_from_file.h</td>
        <td>RetrieveDataSetFromFile</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_from_file.h</td>
        <td>RetrieveDataSetFromFile</td>
        <td>RetrieveDataSetFromFile( const std::string &FILENAME = std::string(), const size_t &NUMBER_CHUNKS = 1, const math::RangeSet< size_t> &CHUNKS = math::RangeSet< size_t>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_from_file.h</td>
        <td>RetrieveDataSetFromFile</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_from_file.h</td>
        <td>RetrieveDataSetFromFile</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_join.h</td>
        <td>RetrieveDataSetJoin</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_join.h</td>
        <td>RetrieveDataSetJoin</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_join.h</td>
        <td>RetrieveDataSetJoin</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_join.h</td>
        <td>RetrieveDataSetJoin</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_join.h</td>
        <td>RetrieveDataSetJoin</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_join.h</td>
        <td>RetrieveDataSetJoin</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_join.h</td>
        <td>RetrieveDataSetJoin</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_join.h</td>
        <td>RetrieveDataSetJoin</td>
        <td>UpdateIDsIndex()
</td>
        <td>mendenjl, brownbp1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_randomized.h</td>
        <td>RetrieveDataSetRandomized</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_randomized.h</td>
        <td>RetrieveDataSetRandomized</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_randomized.h</td>
        <td>RetrieveDataSetRandomized</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_randomized.h</td>
        <td>RetrieveDataSetRandomized</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_randomized.h</td>
        <td>RetrieveDataSetRandomized</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_randomized.h</td>
        <td>RetrieveDataSetRandomized</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_randomized.h</td>
        <td>RetrieveDataSetRandomized</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_randomized.h</td>
        <td>RetrieveDataSetRandomized</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_rescaled.h</td>
        <td>RetrieveDataSetRescaled</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_rescaled.h</td>
        <td>RetrieveDataSetRescaled</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_rescaled.h</td>
        <td>RetrieveDataSetRescaled</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_rescaled.h</td>
        <td>RetrieveDataSetRescaled</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_rescaled.h</td>
        <td>RetrieveDataSetRescaled</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_rescaled.h</td>
        <td>RetrieveDataSetRescaled</td>
        <td>RetrieveDataSetRescaled()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_rescaled.h</td>
        <td>RetrieveDataSetRescaled</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_rescaled.h</td>
        <td>RetrieveDataSetRescaled</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_rescaled.h</td>
        <td>RetrieveDataSetRescaled</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_rows.h</td>
        <td>RetrieveDataSetRows</td>
        <td>GenerateDataSet()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_rows.h</td>
        <td>RetrieveDataSetRows</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_rows.h</td>
        <td>RetrieveDataSetRows</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_rows.h</td>
        <td>RetrieveDataSetRows</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_rows.h</td>
        <td>RetrieveDataSetRows</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_rows.h</td>
        <td>RetrieveDataSetRows</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_rows.h</td>
        <td>RetrieveDataSetRows</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_rows.h</td>
        <td>RetrieveDataSetRows</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_yscramble.h</td>
        <td>RetrieveDataSetYscramble</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_yscramble.h</td>
        <td>RetrieveDataSetYscramble</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_yscramble.h</td>
        <td>RetrieveDataSetYscramble</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_yscramble.h</td>
        <td>RetrieveDataSetYscramble</td>
        <td>GetNumberPartitionsAndIds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_yscramble.h</td>
        <td>RetrieveDataSetYscramble</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_yscramble.h</td>
        <td>RetrieveDataSetYscramble</td>
        <td>SelectFeatures( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_data_set_yscramble.h</td>
        <td>RetrieveDataSetYscramble</td>
        <td>SelectIds( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_data_set_yscramble.h</td>
        <td>RetrieveDataSetYscramble</td>
        <td>SelectResults( const util::ObjectDataLabel &CODE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_dataset_subset.h</td>
        <td>RetrieveDatasetSubset</td>
        <td>GenerateDataSet()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_dataset_subset.h</td>
        <td>RetrieveDatasetSubset</td>
        <td>GetFeatureLabelsWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_dataset_subset.h</td>
        <td>RetrieveDatasetSubset</td>
        <td>GetIdCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_dataset_subset.h</td>
        <td>RetrieveDatasetSubset</td>
        <td>GetResultCodeWithSizes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_dataset_subset.h</td>
        <td>RetrieveDatasetSubset</td>
        <td>RetrieveDatasetSubset( const std::string &FILENAME = std::string(), const size_t &NUMBER_CHUNKS = 1, const math::RangeSet< size_t> &CHUNKS = math::RangeSet< size_t>( math::Range< size_t>( 0, 0)) )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_dataset_subset.h</td>
        <td>RetrieveDatasetSubset</td>
        <td>StoreMasterDataset( const std::string &FILENAME, RetrieveDataSetBase &DATA_SET_RETRIEVER, const double &BLOCK_SIZE_MB = double( 32.0), const bool &ALLOW_INCOMPLETE_RECORDS = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_interface.h</td>
        <td>RetrieveInterface</td>
        <td>GetMergedIndependentROCCurves()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_interface.h</td>
        <td>RetrieveInterface</td>
        <td>IsValidKey( const std::string &KEY) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_interface.h</td>
        <td>RetrieveInterface</td>
        <td>ROCCurvesFromDataset( const linal::MatrixConstInterface< float> &EXP, const linal::MatrixConstInterface< float> &PRED, const float &THRESHOLD, const bool &POS_ABOVE_THRESH )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_interface.h</td>
        <td>RetrieveInterface</td>
        <td>ReadMergedIndependentPredictions()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_retrieve_interface.h</td>
        <td>RetrieveInterface</td>
        <td>RetrieveCommonCVInfo() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_retrieve_interface.h</td>
        <td>RetrieveInterface</td>
        <td>RetrieveUniqueDescriptor() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_dataset_binary_operation.h</td>
        <td>ScoreDatasetBinaryOperation</td>
        <td>Score( const descriptor::Dataset &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_dataset_binary_operation.h</td>
        <td>ScoreDatasetBinaryOperation</td>
        <td>ScoreDatasetBinaryOperation( const math::AssignmentOperationInterface< float> &OPERATION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_dataset_f_score.h</td>
        <td>ScoreDatasetFScore</td>
        <td>Score( const descriptor::Dataset &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_dataset_input_sensitivity.h</td>
        <td>ScoreDatasetInputSensitivity</td>
        <td>Score( const descriptor::Dataset &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_dataset_input_sensitivity_discrete.h</td>
        <td>ScoreDatasetInputSensitivityDiscrete</td>
        <td>GetDerivativeTypeInfo( const Derivative &DERIVATIVE)
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_dataset_input_sensitivity_discrete.h</td>
        <td>ScoreDatasetInputSensitivityDiscrete</td>
        <td>GetDerivativeTypeName( const Derivative &DERIVATIVE)
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_dataset_input_sensitivity_discrete.h</td>
        <td>ScoreDatasetInputSensitivityDiscrete</td>
        <td>Score( const descriptor::Dataset &DATASET) const
</td>
        <td>vuot2, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_dataset_neural_network_input_sensitivity.h</td>
        <td>ScoreDatasetNeuralNetworkInputSensitivity</td>
        <td>GetCutoffSides( const linal::VectorConstInterface< float> &ACTUAL, const float &CUTOFF )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_dataset_neural_network_input_sensitivity.h</td>
        <td>ScoreDatasetNeuralNetworkInputSensitivity</td>
        <td>PartitionModels( const storage::Vector< linal::Matrix< char> > &PREDICTION_CLASSIFICATIONS, const size_t &FEATURE_NR )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_dataset_neural_network_input_sensitivity.h</td>
        <td>ScoreDatasetNeuralNetworkInputSensitivity</td>
        <td>Score( const descriptor::Dataset &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_dataset_neural_network_weights.h</td>
        <td>ScoreDatasetNeuralNetworkWeights</td>
        <td>Score( const descriptor::Dataset &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_dataset_non_redundant.h</td>
        <td>ScoreDatasetNonRedundant</td>
        <td>Score( const descriptor::Dataset &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_dataset_non_redundant.h</td>
        <td>ScoreDatasetNonRedundant</td>
        <td>ScoreDatasetNonRedundant()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_dataset_partition.h</td>
        <td>ScoreDatasetPartition</td>
        <td>Score( const descriptor::Dataset &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_dataset_pearson_correlation.h</td>
        <td>ScoreDatasetPearsonCorrelation</td>
        <td>Score( const descriptor::Dataset &DATASET) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_dataset_pearson_correlation.h</td>
        <td>ScoreDatasetPearsonCorrelation</td>
        <td>ScoreDatasetPearsonCorrelation( const bool &AUTO_CORRELATION = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_derivative_ensemble.h</td>
        <td>ScoreDerivativeEnsemble</td>
        <td>AddUtilityScore( math::RunningAverage< linal::Vector< float> > &AVERAGES ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_derivative_ensemble.h</td>
        <td>ScoreDerivativeEnsemble</td>
        <td>GetDoesBalance() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_derivative_ensemble.h</td>
        <td>ScoreDerivativeEnsemble</td>
        <td>GetUsesModelScores() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_derivative_ensemble.h</td>
        <td>ScoreDerivativeEnsemble</td>
        <td>InitializeBalancing( const storage::Vector< linal::Matrix< char> > &MODEL_CLASSIFICATIONS, const size_t &NR_DESCRIPTORS ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_derivative_ensemble.h</td>
        <td>ScoreDerivativeEnsemble</td>
        <td>Score( const storage::Vector< linal::Matrix< float> > &MODEL_DESCRIPTOR_DERIVATIVES, const storage::Vector< std::string> &PREDICTION_CLASS ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_score_derivative_ensemble.h</td>
        <td>ScoreDerivativeEnsemble</td>
        <td>Score( const storage::Vector< linal::Matrix< float> > &MODEL_DESCRIPTOR_DERIVATIVES, const storage::Vector< std::string> &PREDICTION_CLASS, math::RunningAverage< linal::Vector< float> > &AVERAGES ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_score_derivative_ensemble.h</td>
        <td>ScoreDerivativeEnsemble</td>
        <td>ScoreDerivativeEnsemble()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_kernel_base.h</td>
        <td>SupportVectorKernelBase</td>
        <td>GetInputVectorIKernelMatrix( const FeatureDataSetInterface< float> &TRAINING_DATA, const size_t &INPUT_VECTOR_I, const storage::Vector< int> &SIGNS, const size_t &PROBLENGTH ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_kernel_base.h</td>
        <td>SupportVectorKernelBase</td>
        <td>GetInputVectorIKernelMatrixMultiOutput( const FeatureDataSetInterface< float> &TRAINING_DATA, const size_t &INPUT_VECTOR_I ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_kernel_polynomial.h</td>
        <td>SupportVectorKernelPolynomial</td>
        <td>GetDeviceKernelFunctionCallString() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_kernel_polynomial.h</td>
        <td>SupportVectorKernelPolynomial</td>
        <td>GetScheme() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_kernel_polynomial.h</td>
        <td>SupportVectorKernelPolynomial</td>
        <td>SupportVectorKernelPolynomial()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_kernel_polynomial.h</td>
        <td>SupportVectorKernelPolynomial</td>
        <td>operator ()( const FeatureReference< float> &VECTOR_A, const FeatureReference< float> &VECTOR_B ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_kernel_rbf.h</td>
        <td>SupportVectorKernelRBF</td>
        <td>GetDeviceKernelFunctionCallString() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_kernel_rbf.h</td>
        <td>SupportVectorKernelRBF</td>
        <td>GetGamma() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_kernel_rbf.h</td>
        <td>SupportVectorKernelRBF</td>
        <td>GetScheme() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_kernel_rbf.h</td>
        <td>SupportVectorKernelRBF</td>
        <td>SetGamma( const float &GAMMA)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_kernel_rbf.h</td>
        <td>SupportVectorKernelRBF</td>
        <td>SupportVectorKernelRBF( const float &GAMMA)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_kernel_rbf.h</td>
        <td>SupportVectorKernelRBF</td>
        <td>SupportVectorKernelRBF()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_kernel_rbf.h</td>
        <td>SupportVectorKernelRBF</td>
        <td>operator ()( const FeatureReference< float> &VECTOR_A, const FeatureReference< float> &VECTOR_B ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>GetBias() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>GetKernel() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>GetNumberBoundSupportVectors() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>GetNumberOutputs() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>GetNumberSupportVectors() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>GetSupportVectors() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>Rescale( FeatureDataSet< float> &FEATURE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetAlpha( const storage::Vector< float> &ALPHA)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetBias( const float BIAS)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetKernel( const util::Implementation< SupportVectorKernelBase> &KERNEL)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetNumberBoundSupportVectors( const size_t NUMBER_BOUND_SUPPORT_VECTORS)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetNumberSupportVectors( const size_t NUMBER_SUPPORT_VECTORS)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetSupportVectors( const FeatureDataSet< float> &SUPPORTVECTORS)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SupportVectorMachine( const util::Implementation< SupportVectorKernelBase> &KERNEL)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SupportVectorMachine( const util::Implementation< SupportVectorKernelBase> &KERNEL, const util::ShPtr< RescaleFeatureDataSet> &RESCALE_INPUT, const util::ShPtr< RescaleFeatureDataSet> &RESCALE_OUTPUT )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SupportVectorMachine()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>GetAlpha() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>GetBias() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>GetClassDescription() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>GetKernel() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>GetNumberBoundSupportVectors() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>GetNumberOutputs() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>GetNumberSupportVectors() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>GetSupportVectors() const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>PredictWithoutRescaling( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>Rescale( FeatureDataSet< float> &FEATURE) const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SetAlpha( const storage::Vector< float> &ALPHA)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SetBeta( const storage::Vector< linal::Vector< float> > &BETA)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SetBias( const float BIAS)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SetBias( const linal::Vector< float> BIAS)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SetKernel( const util::Implementation< SupportVectorKernelBase> &KERNEL)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SetNumberBoundSupportVectors( const size_t NUMBER_BOUND_SUPPORT_VECTORS)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SetNumberSupportVectors( const size_t NUMBER_SUPPORT_VECTORS)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SetSupportVectors( const FeatureDataSet< float> &SUPPORTVECTORS)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SupportVectorMachineMultiOutput( const util::Implementation< SupportVectorKernelBase> &KERNEL)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SupportVectorMachineMultiOutput( const util::Implementation< SupportVectorKernelBase> &KERNEL, const util::ShPtr< RescaleFeatureDataSet> &RESCALE_INPUT, const util::ShPtr< RescaleFeatureDataSet> &RESCALE_OUTPUT )
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>SupportVectorMachineMultiOutput()
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_support_vector_machine_multi_output.h</td>
        <td>SupportVectorMachineMultiOutput</td>
        <td>operator ()( const FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_train_restricted_boltzmann_machine_layer.h</td>
        <td>TrainRestrictedBoltzmannMachineLayer</td>
        <td>AccumulateChangesFrom( const TrainRestrictedBoltzmannMachineLayer &OTHER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_train_restricted_boltzmann_machine_layer.h</td>
        <td>TrainRestrictedBoltzmannMachineLayer</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_train_restricted_boltzmann_machine_layer.h</td>
        <td>TrainRestrictedBoltzmannMachineLayer</td>
        <td>Train( const linal::VectorConstInterface< float> &INPUT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_train_restricted_boltzmann_machine_layer.h</td>
        <td>TrainRestrictedBoltzmannMachineLayer</td>
        <td>Train( const linal::VectorConstInterface< float> &INPUT, const linal::VectorConstInterface< float> &OUTPUT )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_train_restricted_boltzmann_machine_layer.h</td>
        <td>TrainRestrictedBoltzmannMachineLayer</td>
        <td>TrainRestrictedBoltzmannMachineLayer( RestrictedBoltzmannMachineLayer &LAYER, const size_t &STOCHASTIC_STEP_COUNT = 3 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_train_restricted_boltzmann_machine_layer.h</td>
        <td>TrainRestrictedBoltzmannMachineLayer</td>
        <td>TrainRestrictedBoltzmannMachineLayer()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_train_restricted_boltzmann_machine_layer.h</td>
        <td>TrainRestrictedBoltzmannMachineLayer</td>
        <td>UpdateLayer( const float &WEIGHT_COST, NeuralNetworkUpdateWeightsInterface &WEIGHT_UPDATE, NeuralNetworkUpdateWeightsInterface &VISIBLE_BIAS_UPDATE, NeuralNetworkUpdateWeightsInterface &HIDDEN_BIAS_UPDATE, NeuralNetworkUpdateWeightsInterface &VISIBLE_NOISE_UPDATE, NeuralNetworkUpdateWeightsInterface &HIDDEN_NOISE_UPDATE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>GetClassMembers() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>GetClasses() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>GetMaxBalancingRate() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>GetMaxRepeats() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>GetNumberOfClasses() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>GetOrder() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>IsBalanced() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>IsShuffled() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>Next()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>Setup( const FeatureDataSetInterface< float> &RESULTS, const float &CUTOFF )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>TrainingSchedule( const bool &SHUFFLE = false, const bool &BALANCE = false, const size_t &MAX_REPEATS = std::numeric_limits< size_t>::max(), const float &TARGET_OVERSAMPLING = 1.0 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_training_schedule.h</td>
        <td>TrainingSchedule</td>
        <td>operator ()( const size_t &ORDER_INDEX) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_function_interface.h</td>
        <td>TransferFunctionInterface</td>
        <td>F( const linal::VectorConstInterface< float> &ARGUMENT_X) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_function_interface.h</td>
        <td>TransferFunctionInterface</td>
        <td>F( linal::VectorInterface< float> &STORAGE, const linal::VectorConstInterface< float> &ARGUMENT_X ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_gaussian.h</td>
        <td>TransferGaussian</td>
        <td>F( const float &ARGUMENT_X) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_gaussian.h</td>
        <td>TransferGaussian</td>
        <td>F( const linal::VectorConstInterface< float> &ARGUMENT_X) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_gaussian.h</td>
        <td>TransferGaussian</td>
        <td>F( linal::VectorInterface< float> &STORAGE, const linal::VectorConstInterface< float> &ARGUMENT_X ) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_gaussian.h</td>
        <td>TransferGaussian</td>
        <td>GetDynamicOutputRange() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_gaussian.h</td>
        <td>TransferGaussian</td>
        <td>GetOutputRange() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_gaussian.h</td>
        <td>TransferGaussian</td>
        <td>GetSerializer() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_gaussian.h</td>
        <td>TransferGaussian</td>
        <td>MultiplyBydF( linal::VectorInterface< float> &STORAGE, const linal::VectorConstInterface< float> &ARGUMENT_X, const linal::VectorConstInterface< float> &ARGUMENT_Y ) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_gaussian.h</td>
        <td>TransferGaussian</td>
        <td>TransferGaussian()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_gaussian.h</td>
        <td>TransferGaussian</td>
        <td>dF( const float &ARGUMENT_X, const float &ARGUMENT_Y) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_linear.h</td>
        <td>TransferLinear</td>
        <td>F( const float &ARGUMENT_X) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_linear.h</td>
        <td>TransferLinear</td>
        <td>F( const linal::VectorConstInterface< float> &ARGUMENT_X) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_linear.h</td>
        <td>TransferLinear</td>
        <td>F( linal::VectorInterface< float> &STORAGE, const linal::VectorConstInterface< float> &ARGUMENT_X ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_linear.h</td>
        <td>TransferLinear</td>
        <td>GetDynamicOutputRange() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_linear.h</td>
        <td>TransferLinear</td>
        <td>GetOutputRange() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_linear.h</td>
        <td>TransferLinear</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_linear.h</td>
        <td>TransferLinear</td>
        <td>MultiplyBydF( linal::VectorInterface< float> &STORAGE, const linal::VectorConstInterface< float> &ARGUMENT_X, const linal::VectorConstInterface< float> &ARGUMENT_Y ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_linear.h</td>
        <td>TransferLinear</td>
        <td>TransferLinear()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_linear.h</td>
        <td>TransferLinear</td>
        <td>dF( const float &ARGUMENT_X, const float &ARGUMENT_Y) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_rectifier.h</td>
        <td>TransferRectifier</td>
        <td>F( const float &ARGUMENT_X) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_rectifier.h</td>
        <td>TransferRectifier</td>
        <td>F( const linal::VectorConstInterface< float> &ARGUMENT_X) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_rectifier.h</td>
        <td>TransferRectifier</td>
        <td>F( linal::VectorInterface< float> &STORAGE, const linal::VectorConstInterface< float> &ARGUMENT_X ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_rectifier.h</td>
        <td>TransferRectifier</td>
        <td>GetDynamicOutputRange() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_rectifier.h</td>
        <td>TransferRectifier</td>
        <td>GetOutputRange() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_rectifier.h</td>
        <td>TransferRectifier</td>
        <td>MultiplyBydF( linal::VectorInterface< float> &STORAGE, const linal::VectorConstInterface< float> &ARGUMENT_X, const linal::VectorConstInterface< float> &ARGUMENT_Y ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_rectifier.h</td>
        <td>TransferRectifier</td>
        <td>TransferRectifier()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_rectifier.h</td>
        <td>TransferRectifier</td>
        <td>dF( const float &ARGUMENT_X, const float &ARGUMENT_Y) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_sigmoid.h</td>
        <td>TransferSigmoid</td>
        <td>F( const float &ARGUMENT_X) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_sigmoid.h</td>
        <td>TransferSigmoid</td>
        <td>F( const linal::VectorConstInterface< float> &ARGUMENT_X) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_sigmoid.h</td>
        <td>TransferSigmoid</td>
        <td>F( linal::VectorInterface< float> &STORAGE, const linal::VectorConstInterface< float> &ARGUMENT_X ) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_sigmoid.h</td>
        <td>TransferSigmoid</td>
        <td>GetDynamicOutputRange() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_sigmoid.h</td>
        <td>TransferSigmoid</td>
        <td>GetOutputRange() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_model_transfer_sigmoid.h</td>
        <td>TransferSigmoid</td>
        <td>MultiplyBydF( linal::VectorInterface< float> &STORAGE, const linal::VectorConstInterface< float> &ARGUMENT_X, const linal::VectorConstInterface< float> &ARGUMENT_Y ) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_model_transfer_sigmoid.h</td>
        <td>TransferSigmoid</td>
        <td>dF( const float &ARGUMENT_X, const float &ARGUMENT_Y) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_rdc_container.h</td>
        <td>RDCContainer</td>
        <td>GetCalculatedlValues() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_rdc_container.h</td>
        <td>RDCContainer</td>
        <td>GetExperimentalValues() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_rdc_container.h</td>
        <td>RDCContainer</td>
        <td>RDCContainer( const storage::Vector< double> &EXP_VALUES, const storage::Vector< double> &CALC_VALUES)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_rdc_container.h</td>
        <td>RDCContainer</td>
        <td>RDCContainer()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_residual_dipolar_coupling_least_square_deviation.h</td>
        <td>ResidualDipolarCouplingLeastSquareDeviation</td>
        <td>ResidualDipolarCouplingLeastSquareDeviation()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_residual_dipolar_coupling_least_square_deviation.h</td>
        <td>ResidualDipolarCouplingLeastSquareDeviation</td>
        <td>operator ()( const restraint::RDCAssignment &RESTRAINTS) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_rosetta_noe_handler.h</td>
        <td>RosettaNOEHandler</td>
        <td>ReadRestraints( std::istream &ISTREAM) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_rosetta_noe_handler.h</td>
        <td>RosettaNOEHandler</td>
        <td>RosettaNOEHandler( const size_t SEQUENCE_DISTANCE = 0, const size_t SEQUENCE_OFFSET = 0, const std::string PREFIX = Ó, const double &SCORE_WEIGHT = 1.0 )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_rosetta_noe_handler.h</td>
        <td>RosettaNOEHandler</td>
        <td>WriteRestraints( std::ostream &OSTREAM, const util::ShPtrVector< restraint::AtomDistance> &RESTRAINT ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_rosetta_rdc_handler.h</td>
        <td>RosettaRDCHandler</td>
        <td>ReadRestraints( std::istream &ISTREAM) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_rosetta_rdc_handler.h</td>
        <td>RosettaRDCHandler</td>
        <td>RosettaRDCHandler( const size_t SEQUENCE_OFFSET = 0)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_rosetta_rdc_handler.h</td>
        <td>RosettaRDCHandler</td>
        <td>WriteRestraints( std::ostream &OSTREAM, const restraint::RDC &RESTRAINT)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal.h</td>
        <td>Signal</td>
        <td>ContainsAtom( const chemistry::AtomConformationalInterface &ATOM) const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal.h</td>
        <td>Signal</td>
        <td>GetSignals1D() const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal.h</td>
        <td>Signal</td>
        <td>SetSignals1D( const util::ShPtrVector< Signal1D> &SIGNALS1D)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal.h</td>
        <td>Signal</td>
        <td>Signal( const Signal &SIGNAL)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal.h</td>
        <td>Signal</td>
        <td>Signal( const util::ShPtrVector< Signal1D> &SIGNALS1D)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal.h</td>
        <td>Signal</td>
        <td>Signal()
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>GetAtomInvolvedInSignal() const
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>GetChemicalShift() const
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>GetIntegral() const
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>GetPattern() const
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>GetPatternTypeDescriptor( const PatternType &PATTERN_TYPE)
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>GetPatternTypeSingleLetterCode( const PatternType &PATTERN_TYPE)
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>PatternTypeFromSingleLetterCode( const char SINGLE_LETTER_CODE)
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>SetAtomInvolvedInSignal( const chemistry::AtomConformationalInterface &ATOM)
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>SetChemicalShift( const double CHEMICAL_SHIFT)
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>SetIntegral( double const INTEGRAL)
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>SetPattern( const storage::Vector< storage::Pair< PatternTypeEnum, double> > &PATTERN)
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>Signal1D( const double CHEMICAL_SHIFT, const double INTEGRAL, const storage::Vector< storage::Pair< PatternTypeEnum, double> > &PATTERN, const chemistry::AtomConformationalInterface &ATOM )
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>Signal1D()
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_signal_1d.h</td>
        <td>Signal1D</td>
        <td>SignalFromString( const std::string &SIGNAL_STRING, iterate::Generic< const chemistry::AtomConformationalInterface> ATOMS )
</td>
        <td>butkiem1, mueller, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>AddSpectrum( chemistry::ConformationInterface &MOLECULE) const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>DetermineInvolvedSignals( const chemistry::AtomConformationalInterface &ATOM) const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>GenerateSpectra( const chemistry::ConformationInterface &MOLECULE )
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>GetAssignmentMethod() const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>GetFieldStrength() const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>GetSignals() const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>GetSolvent() const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>GetSpecType() const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>GetSpecTypeDescriptor( const SpecType &SPEC_TYPE)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>GetTemperature() const
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>ReadSignals( const chemistry::ConformationInterface &MOLECULE, const std::string &SPECTRUM_LINE )
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>SetAssignmentMethod( const std::string &METHOD)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>SetFieldStrength( const double &FIELDSTRENGTH)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>SetSignals( const util::ShPtrVector< Signal> &SIGNALS)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>SetSolvent( const std::string &SOLVENT)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>SetTemperature( const double &TEMPERATURE)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>SetType( const SpecTypeEnum &TYPE)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>Spectrum( const SpecTypeEnum &TYPE, const util::ShPtrVector< Signal> &SIGNALS)
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_spectrum.h</td>
        <td>Spectrum</td>
        <td>Spectrum()
</td>
        <td>butkiem1, mueller</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_noe_handler.h</td>
        <td>StarNOEHandler</td>
        <td>ReadRestraints( std::istream &ISTREAM) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_noe_handler.h</td>
        <td>StarNOEHandler</td>
        <td>StarNOEHandler( const std::string &DEFAULT_EXTENSION = Ó, const size_t SEQUENCE_DISTANCE = 0, const size_t SEQUENCE_OFFSET = 0)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_noe_handler.h</td>
        <td>StarNOEHandler</td>
        <td>WriteRestraints( std::ostream &OSTREAM, const util::ShPtrVector< restraint::AtomDistance> &RESTRAINT )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_rdc_handler.h</td>
        <td>StarRDCHandler</td>
        <td>ReadRestraints( std::istream &ISTREAM) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_rdc_handler.h</td>
        <td>StarRDCHandler</td>
        <td>StarRDCHandler( const std::string &DEFAULT_EXTENSION = Ó, const size_t SEQUENCE_OFFSET = 0, const bool &ADJUST_SIGNS = false, const bool &NORMALIZE = false )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_rdc_handler.h</td>
        <td>StarRDCHandler</td>
        <td>WriteRestraints( std::ostream &OSTREAM, const restraint::RDC &RESTRAINT)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_tag_categories.h</td>
        <td>StarTagCategories</td>
        <td>GetCategoryFromString( const std::string &DESCRIPTION)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_tag_categories.h</td>
        <td>StarTagCategories</td>
        <td>StarTagCategories()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_tag_categories.h</td>
        <td></td>
        <td>GetStarTagCategories()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_tag_category_data.h</td>
        <td>StarTagCategoryData</td>
        <td>GetDescription() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_tag_category_data.h</td>
        <td>StarTagCategoryData</td>
        <td>GetSaveFrame() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_tag_category_data.h</td>
        <td>StarTagCategoryData</td>
        <td>GetSaveFrameName( const SaveFrame &FRAME)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_tag_category_data.h</td>
        <td>StarTagCategoryData</td>
        <td>StarTagCategoryData( const SaveFrame &SAVE_FRAME = s_NumberSaveFrames, const std::string &DESCRIPTION = Ó )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_tag_data.h</td>
        <td>StarTagData</td>
        <td>GetDataType() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_tag_data.h</td>
        <td>StarTagData</td>
        <td>GetDescription() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_tag_data.h</td>
        <td>StarTagData</td>
        <td>GetTagCategory() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_tag_data.h</td>
        <td>StarTagData</td>
        <td>StarTagData( const StarTagCategory &CATEGORY = GetStarTagCategories().e_Undefined, const std::string &DESCRIPTION = Ó, const util::CPPDataTypes::Types DATA_TYPE = util::CPPDataTypes::e_Unknown )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_tags.h</td>
        <td>StarTags</td>
        <td>AddStarTag( const std::string &DESCRIPTOR, const StarTagData &TAG_DATA)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_tags.h</td>
        <td>StarTags</td>
        <td>GetChainID( const std::string &CURRENT_ID, storage::Map< std::string, char> &PREVIOUS_IDS)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_tags.h</td>
        <td>StarTags</td>
        <td>GetTagFromString( const StarTagCategory &CATEGORY, const std::string &DESCRIPTION)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_tags.h</td>
        <td>StarTags</td>
        <td>ReadStarFile( std::istream &ISTREAM)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_nmr_star_tags.h</td>
        <td>StarTags</td>
        <td>StarTags()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_nmr_star_tags.h</td>
        <td></td>
        <td>GetStarTags()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_openblas.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_openblas_operations.h</td>
        <td>Operations</td>
        <td>DotProduct( const linal::VectorInterface< t_DataType> &VECTOR_A, const linal::VectorInterface< t_DataType> &VECTOR_B ) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_openblas_operations.h</td>
        <td>Operations</td>
        <td>Multiply( const linal::MatrixConstInterface< t_DataType> &MATRIX, const linal::VectorInterface< t_DataType> &VECTOR ) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_openblas_operations.h</td>
        <td>Operations</td>
        <td>Multiply( const linal::MatrixConstInterface< t_DataType> &MATRIX_A, const linal::MatrixConstInterface< t_DataType> &MATRIX_B ) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_openblas_operations.h</td>
        <td>Operations</td>
        <td>Norm( const linal::VectorInterface< t_DataType> &VECTOR) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_openblas_operations.h</td>
        <td>Operations</td>
        <td>OuterProduct( const linal::VectorConstInterface< t_DataType> &VECTOR_U, const linal::VectorConstInterface< t_DataType> &VECTOR_V )
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_openblas_operations.h</td>
        <td>Operations</td>
        <td>VectorEqualsVectorTimesMatrix( linal::VectorInterface< t_DataType> &STORAGE, const linal::VectorConstInterface< t_DataType> &FEATURE, const linal::MatrixConstInterface< t_DataType> &MATRIX ) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_openblas_operations.h</td>
        <td>Operations</td>
        <td>VectorPlusEqualsMatrixTimesVector( linal::VectorInterface< t_DataType> &STORAGE, const linal::MatrixConstInterface< t_DataType> &MATRIX, const linal::VectorConstInterface< t_DataType> &FEATURE ) const
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_openblas_operations.h</td>
        <td></td>
        <td>GetFlagOpenblas()
</td>
        <td>vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_resilient_propagation.h</td>
        <td>ApproximatorResilientPropagation</td>
        <td>ApproximatorResilientPropagation( util::ShPtr< descriptor::Dataset> &TRAINING_DATA, const storage::Vector< size_t> &ARCHITECTURE, const size_t STEPS_PER_CALL, const CommandQueue &QUEUE )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_resilient_propagation.h</td>
        <td>ApproximatorResilientPropagation</td>
        <td>ApproximatorResilientPropagation()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_resilient_propagation.h</td>
        <td>ApproximatorResilientPropagation</td>
        <td>GetCurrentApproximation() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_resilient_propagation.h</td>
        <td>ApproximatorResilientPropagation</td>
        <td>GetCurrentGPUModel() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_resilient_propagation.h</td>
        <td>ApproximatorResilientPropagation</td>
        <td>GetCurrentModel() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_resilient_propagation.h</td>
        <td>ApproximatorResilientPropagation</td>
        <td>Next()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_resilient_propagation.h</td>
        <td>ApproximatorResilientPropagation</td>
        <td>SetObjectiveFunction( const util::ShPtr< model::ObjectiveFunctionWrapper> &OBJ )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_resilient_propagation.h</td>
        <td>ApproximatorResilientPropagation</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>ApproximatorSequentialMinimialOptimization( const float COST_PARAMETER_C, const util::ShPtr< SupportVectorMachine> &MODEL, util::ShPtr< descriptor::Dataset> &TRAINING_DATA, const size_t NUMBER_ITERATIONS, const CommandQueue &QUEUE )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>ApproximatorSequentialMinimialOptimization()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>FinalizeSupportVectorModel()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>GetCostParameterC() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>GetCurrentApproximation() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>GetCurrentModel() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>Next()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>SetCostParameterC( const float COST_PARAMETER_C)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>SetGamma( const float &GAMMA)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_sequential_minimial_optimization.h</td>
        <td>ApproximatorSequentialMinimialOptimization</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_simple_propagation.h</td>
        <td>ApproximatorSimplePropagation</td>
        <td>ApproximatorSimplePropagation( util::ShPtr< descriptor::Dataset> &TRAINING_DATA, const storage::Vector< size_t> &ARCHITECTURE, const float ALPHA, const float ETA, const size_t STEPS_PER_CALL, const CommandQueue &QUEUE )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_simple_propagation.h</td>
        <td>ApproximatorSimplePropagation</td>
        <td>ApproximatorSimplePropagation()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_simple_propagation.h</td>
        <td>ApproximatorSimplePropagation</td>
        <td>GetCurrentApproximation() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_simple_propagation.h</td>
        <td>ApproximatorSimplePropagation</td>
        <td>GetCurrentGPUModel() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_simple_propagation.h</td>
        <td>ApproximatorSimplePropagation</td>
        <td>GetCurrentModel() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_simple_propagation.h</td>
        <td>ApproximatorSimplePropagation</td>
        <td>Next()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_approximator_simple_propagation.h</td>
        <td>ApproximatorSimplePropagation</td>
        <td>SetObjectiveFunction( const util::ShPtr< model::ObjectiveFunctionWrapper> &OBJ )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_approximator_simple_propagation.h</td>
        <td>ApproximatorSimplePropagation</td>
        <td>SetTrainingData( util::ShPtr< descriptor::Dataset> &DATA )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_arg_max.h</td>
        <td>ArgMax</td>
        <td>ArgMax( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_arg_max.h</td>
        <td>ArgMax</td>
        <td>ArgMax()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_arg_max.h</td>
        <td>ArgMax</td>
        <td>operator ()( Vector< t_DataType> &DATA) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_arg_min.h</td>
        <td>ArgMin</td>
        <td>ArgMin( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_arg_min.h</td>
        <td>ArgMin</td>
        <td>ArgMin()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_arg_min.h</td>
        <td>ArgMin</td>
        <td>operator ()( Vector< t_DataType> &DATA) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_buffer.h</td>
        <td>Buffer</td>
        <td>AllocateBufferOfSize( const size_t SIZE, const CommandQueue &QUEUE)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_buffer.h</td>
        <td>Buffer</td>
        <td>Buffer( const cl::Buffer &BUFFER)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_buffer.h</td>
        <td>Buffer</td>
        <td>Buffer()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_buffer.h</td>
        <td>Buffer</td>
        <td>CreateBufferFromMatrix( const linal::MatrixConstInterface< t_DataType> &MATRIX, const CommandQueue &QUEUE, const bool READ_ONLY = false )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_buffer.h</td>
        <td>Buffer</td>
        <td>CreateBufferFromVector( const linal::VectorConstInterface< t_DataType> &VECTOR, const CommandQueue &QUEUE, bool READ_ONLY = false )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_buffer.h</td>
        <td>Buffer</td>
        <td>GetContext( cl_int *ERROR_PTR = NULL) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_buffer.h</td>
        <td>Buffer</td>
        <td>GetHostPtr( cl_int *ERROR_PTR = NULL) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_buffer.h</td>
        <td>Buffer</td>
        <td>GetSize( cl_int *ERROR_PTR = NULL) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_command_queue.h</td>
        <td>CommandQueue</td>
        <td>CommandQueue( const Context &CONTEXT, const Device &DEVICE, cl_int *ERROR_PTR = NULL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_command_queue.h</td>
        <td>CommandQueue</td>
        <td>CommandQueue( const cl::CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_command_queue.h</td>
        <td>CommandQueue</td>
        <td>CommandQueue()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_command_queue.h</td>
        <td>CommandQueue</td>
        <td>GetContext( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_command_queue.h</td>
        <td>CommandQueue</td>
        <td>GetDevice( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_command_queue.h</td>
        <td>CommandQueue</td>
        <td>operator <( const CommandQueue &RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_context.h</td>
        <td>Context</td>
        <td>Context( const cl::Context &CONTEXT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_context.h</td>
        <td>Context</td>
        <td>Context( const storage::Vector< Device> &DEVICES, cl_int *ERROR_PTR = NULL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_context.h</td>
        <td>Context</td>
        <td>Context()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_coordinates_transformer.h</td>
        <td>CoordinateTransformer</td>
        <td>CoordinateTransformer()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_coordinates_transformer.h</td>
        <td>CoordinateTransformer</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_coordinates_transformer.h</td>
        <td>CoordinateTransformer</td>
        <td>operator ()( const Matrix< t_DataType> &COORDINATES, const math::TransformationMatrix3D &TRANSFORMATION_MATRIX, const size_t NR_COORDINATES) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_coordinates_transformer.h</td>
        <td></td>
        <td>AddInstance( new CoordinateTransformer< t_DataType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_dataset_min_max.h</td>
        <td>DataSetMinMax</td>
        <td>DataSetMinMax( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_dataset_min_max.h</td>
        <td>DataSetMinMax</td>
        <td>DataSetMinMax()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_dataset_min_max.h</td>
        <td>DataSetMinMax</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_dataset_min_max.h</td>
        <td>DataSetMinMax</td>
        <td>IsCompatible( const CommandQueue &COMMAND_QUEUE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_dataset_min_max.h</td>
        <td>DataSetMinMax</td>
        <td>Max( const Matrix< t_DataType> &DEVICE_MATRIX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_dataset_min_max.h</td>
        <td>DataSetMinMax</td>
        <td>Min( const Matrix< t_DataType> &DEVICE_MATRIX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_dataset_min_max.h</td>
        <td>DataSetMinMax</td>
        <td>operator ()( const linal::MatrixConstInterface< t_DataType> &MATRIX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>DensityFitProteinMinimzerPowell</td>
        <td>DensityFitProteinMinimzerPowell()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>DensityFitProteinMinimzerPowell</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>DensityFitProteinMinimzerPowell</td>
        <td>IsCompatible( const CommandQueue &COMMAND_QUEUE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>DensityFitProteinMinimzerPowell</td>
        <td>SetMaxIterations( const size_t MAX_NUMBER_ITERATIONS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>DensityFitProteinMinimzerPowell</td>
        <td>SetMaxTranslationAndRotation( const double MAX_TRANSLATION, const double MAX_ROTATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>DensityFitProteinMinimzerPowell</td>
        <td>SetProteinAgreement( const density::ProteinAgreement &AGREEMENT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>DensityFitProteinMinimzerPowell</td>
        <td>SetResolution( const double RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>DensityFitProteinMinimzerPowell</td>
        <td>SetSimulator( const density::Simulator &DENSITY_SIMULATOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>DensityFitProteinMinimzerPowell</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL, const density::Map &DENSITY_MAP) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>IsCompatible( const CommandQueue &COMMAND_QUEUE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>PositionCorrelation()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>SetDensityMap( const util::SiPtr< const density::Map> &DENSITY_MAP)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>SetProtein( const assemble::ProteinModel &PROTEIN_MODEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>SetResolution( const double RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_fit_protein_minimizer_powell.h</td>
        <td>PositionCorrelation</td>
        <td>operator ()( const linal::Vector< double> &VECTOR) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>AtomsToDevice( const util::SiPtrVector< const biol::Atom> &ATOMS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>DensitySimulateGaussianSphere()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>GetResolution() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>IsCompatible( const CommandQueue &COMMAND_QUEUE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>RoundUpDimensions( const storage::VectorND< 3, size_t> &DIMENSIONS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>SetGridSpacing( const linal::Vector3D &GRID_SPACING)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>SetMargin( const size_t MARGIN)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>SetResolution( const double RESOLUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>Simulate( const Matrix< double> &ATOMS, const size_t NR_ATOMS, const storage::VectorND< 3, int> &INDEX, const storage::VectorND< 3, size_t> &DIMENSIONS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_density_simulate_gaussian_sphere.h</td>
        <td>DensitySimulateGaussianSphere</td>
        <td>operator ()( const util::SiPtrVector< const biol::Atom> &ATOMS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>AddressBits( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Available( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>CompilerAvailable( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>ComputeCapabilityMajorNV( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>ComputeCapabilityMinorNV( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>DataTypeToDeviceInfoNativeVectorWidth( const DataType &DATA_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>DataTypeToDeviceInfoPreferredVectorWidth( const DataType &DATA_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Device( const cl::Device &DEVICE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Device()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>DeviceType( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>DriverVersion( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>EndianLittle( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>ErrorCorrection( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>ExecKernel( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>ExecNativeKernel( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Extensions( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>FPDenorms( const DataType DATA_TYPE, cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>FPFusedMultiplyAdd( const DataType DATA_TYPE, cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>FPInfNan( const DataType DATA_TYPE, cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>FPRoundToInf( const DataType DATA_TYPE, cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>FPRoundToNearest( const DataType DATA_TYPE, cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>FPRoundToZero( const DataType DATA_TYPE, cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>GPUOverlapNV( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>GetDataTypeString( const DataType &DATA_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>GetDescription( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>GetPlatform( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>GlobalMemSize( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>HostUnifiedMemory( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Image2DMaxHeight( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Image2DMaxWidth( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Image3DMaxDepth( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Image3DMaxHeight( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Image3DMaxWidth( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>ImageSupport( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>IntegratedMemoryNV( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>KernelExecTimeoutNV( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>LocalMemSize( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>LocalMemType( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxClockFrequency( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxComputeUnits( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxConstantBufferSize( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxMemAllocSize( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxParameterSize( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxReadImageArgs( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxSamplers( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxWorkGroupSize( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxWorkItemDimension( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxWorkItemSize( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MaxWriteImageArgs( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MemBaseAddrAlign( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>MinDataTypeAlignSize( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>NVDevice( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Name( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>OpenclCVersion( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>PreferredNativeVectorWidth( const DataType DATA_TYPE, cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>ProfilingTimerResolution( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>QueueOutOfOrderExecution( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>QueueProfiling( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>RegistersPerBlockNV( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>TypeFromString( const std::string &TYPE_STRING)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>TypeToString( const cl_device_type TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Vendor( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>VendorID( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>Version( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_device.h</td>
        <td>Device</td>
        <td>WarpSizeNV( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_euclidean_distance.h</td>
        <td>EuclideanDistance</td>
        <td>EuclideanDistance( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_euclidean_distance.h</td>
        <td>EuclideanDistance</td>
        <td>EuclideanDistance()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_euclidean_distance.h</td>
        <td>EuclideanDistance</td>
        <td>operator ()( const Matrix< t_DataType> &INPUT_A, const Matrix< t_DataType> &INPUT_B ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_extension_data.h</td>
        <td>ExtensionData</td>
        <td>ExtensionData( const std::string &EXTENSION_STRING)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_extension_data.h</td>
        <td>ExtensionData</td>
        <td>ExtensionData()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_extension_data.h</td>
        <td>ExtensionData</td>
        <td>GetName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_extension_data.h</td>
        <td>ExtensionData</td>
        <td>GetPrefix()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_extension_data.h</td>
        <td>ExtensionData</td>
        <td>GetSeparator()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_extension_data.h</td>
        <td>ExtensionData</td>
        <td>GetString() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_extension_data.h</td>
        <td>ExtensionData</td>
        <td>GetVendor() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_extensions.h</td>
        <td>Extensions</td>
        <td>AddExtension( const std::string &EXTENSION_STRING)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_extensions.h</td>
        <td>Extensions</td>
        <td>ExtensionsFromString( const std::string &EXTENSIONS_STRING) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_extensions.h</td>
        <td>Extensions</td>
        <td>ExtensionsToString( const storage::Set< Extension> &EXTENSIONS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_extensions.h</td>
        <td></td>
        <td>GetExtensions()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_feature_similarity_measures.h</td>
        <td>FeatureSimilarityMeasures</td>
        <td>FeatureSimilarityMeasures( std::string &MEASURE, const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_feature_similarity_measures.h</td>
        <td>FeatureSimilarityMeasures</td>
        <td>FeatureSimilarityMeasures()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_feature_similarity_measures.h</td>
        <td>FeatureSimilarityMeasures</td>
        <td>operator ()( const linal::MatrixConstInterface< t_DataType> &INPUT_A ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_insertion_sort.h</td>
        <td>InsertionSort</td>
        <td>GetIndexMatrix() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_insertion_sort.h</td>
        <td>InsertionSort</td>
        <td>InsertionSort( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_insertion_sort.h</td>
        <td>InsertionSort</td>
        <td>InsertionSort()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_insertion_sort.h</td>
        <td>InsertionSort</td>
        <td>operator ()( Matrix< float> &DATA, const size_t &NR_TO_SORT ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>GetKappa() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>GetNumberOutputs() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>GetReferenceData()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>KappaNearestNeighbor( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>KappaNearestNeighbor( util::ShPtr< descriptor::Dataset> &REFERENCE_DATA, const size_t KAPPA, const CommandQueue &QUEUE )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>KappaNearestNeighbor()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>PredictWithoutRescaling( const model::FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>Rescale( model::FeatureDataSet< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>SetKappa( size_t KAPPA)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>SetReferenceData( util::ShPtr< descriptor::Dataset> &REFERENCE_DATA )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>operator ()( const Matrix< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kappa_nearest_neighbor.h</td>
        <td>KappaNearestNeighbor</td>
        <td>operator ()( const model::FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kernel_source_alternative.h</td>
        <td>KernelSourceAlternative</td>
        <td>GetIdentifier() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kernel_source_alternative.h</td>
        <td>KernelSourceAlternative</td>
        <td>GetSource( const util::CPPDataTypes::Types PRECISION, const storage::Set< Extension> &EXTENSIONS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kernel_source_alternative.h</td>
        <td>KernelSourceAlternative</td>
        <td>KernelSourceAlternative( const KernelSourceInterface &ALTERNATIVE_SOURCE_1, const KernelSourceInterface &ALTERNATIVE_SOURCE_2 )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kernel_source_file.h</td>
        <td>KernelSourceFile</td>
        <td>GetIdentifier() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kernel_source_file.h</td>
        <td>KernelSourceFile</td>
        <td>GetSource( const util::CPPDataTypes::Types PRECISION, const storage::Set< Extension> &EXTENSIONS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kernel_source_file.h</td>
        <td>KernelSourceFile</td>
        <td>KernelSourceFile( const std::string &FILE_NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kernel_source_interface.h</td>
        <td>KernelSourceInterface</td>
        <td>GetAdditionalCompilerOptions()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kernel_source_interface.h</td>
        <td>KernelSourceInterface</td>
        <td>GetPrecisionCompilerOptions( const util::CPPDataTypes::Types PRECISION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kernel_source_interface.h</td>
        <td>KernelSourceInterface</td>
        <td>PrecisionCompatibleWithExtensions( const util::CPPDataTypes::Types PRECISION, const storage::Set< Extension> &EXTENSIONS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kernel_source_string.h</td>
        <td>KernelSourceString</td>
        <td>GetIdentifier() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kernel_source_string.h</td>
        <td>KernelSourceString</td>
        <td>GetSource( const util::CPPDataTypes::Types PRECISION, const storage::Set< Extension> &EXTENSIONS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kernel_source_string.h</td>
        <td>KernelSourceString</td>
        <td>KernelSourceString( const std::string &SOURCE_STRING)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kernel_source_string.h</td>
        <td>KernelSourceString</td>
        <td>KernelSourceString()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kernel_sources.h</td>
        <td>KernelSources</td>
        <td>AddKernelPath( const std::string &FILE_NAME)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kernel_sources.h</td>
        <td>KernelSources</td>
        <td>Compile( const KernelSource &KERNEL, const util::CPPDataTypes::Types &PRECISION, const CommandQueue &QUEUE, const std::string &OPTIONS, cl_int *ERROR_PTR )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kernel_sources.h</td>
        <td>KernelSources</td>
        <td>GetKernelsBinaryPathFlag()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_kernel_sources.h</td>
        <td>KernelSources</td>
        <td>GetKernelsSourcePathFlag()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_kernel_sources.h</td>
        <td></td>
        <td>GetKernelSources()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>Fill( const t_DataType &VALUE, const size_t FIRST_ROW, const size_t NR_ROWS, const size_t FIRST_COL, const size_t NR_COLS )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>GetColPadding() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>GetData() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>GetHostMatrix( const size_t &ROW_PAD = 0, const size_t &COL_PAD = 0) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>GetHostMatrixUnpadded() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>GetNumberCols() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>GetNumberOfElements() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>GetNumberRows() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>GetQueue() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>GetRowPadding() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const Matrix< t_DataType> &DATA)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const linal::MatrixConstInterface< t_DataType> &MATRIX, const CommandQueue &QUEUE, const size_t &ROW_PADDING = 0, const size_t &COL_PADDING = 0 )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const size_t &ROWS, const size_t &COLS, const CommandQueue &QUEUE, const size_t &ROW_PADDING = 0, const size_t &COL_PADDING = 0 )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const size_t &ROWS, const size_t &COLS, const CommandQueue &QUEUE, const size_t &ROW_PADDING, const size_t &COL_PADDING, const t_DataType &ELEMENT )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix( const size_t &ROWS, const size_t &COLS, const t_DataType *DATA, const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>Matrix()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>Print( std::string &MESSAGE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>SetDiagonal( const t_DataType &VALUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>SetValue( const size_t ROW, const size_t COL, const t_DataType &VALUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>SubMatrix( const size_t ROW, const size_t NUMBER_ROWS) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>operator ()( const size_t ROW, const size_t COL) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix.h</td>
        <td>Matrix</td>
        <td>operator =( const Matrix< t_DataType> &MATRIX)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Determinant() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>EigenValues( const bool SQRT = false) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>EigenVectorsSymmetric( Matrix3x3< t_DataType> &EIGEN_VECTORS, Vector< t_DataType> &EIGEN_VALUES) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>GetData() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>GetHostMatrix() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>GetHostMatrixWithPadding() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>GetNumberCols() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>GetNumberRows() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>GetQueue() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>HardCopy() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>IsSquare() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Matrix3x3( const CommandQueue &QUEUE, const t_DataType &FILL_VALUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Matrix3x3( const Matrix3x3< t_DataType> &MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Matrix3x3( const linal::MatrixConstInterface< t_DataType> &MATRIX, const CommandQueue &QUEUE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Matrix3x3()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>MultiplyWithTransposed()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>NormalizeRows( const Vector< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Orthogonalize( const size_t ROW)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>ReplaceRow( const size_t ROW, const Vector< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>SortRowsAndVector( Vector< t_DataType> &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>SwapRows( const size_t ROW_A, const size_t ROW_B)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>Transpose()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator *=( const Matrix3x3< t_DataType> &MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix3x3.h</td>
        <td>Matrix3x3</td>
        <td>operator =( const Matrix3x3< t_DataType> &MATRIX)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix_add.h</td>
        <td>MatrixAdd</td>
        <td>MatrixAdd( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix_add.h</td>
        <td>MatrixAdd</td>
        <td>MatrixAdd()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix_add.h</td>
        <td>MatrixAdd</td>
        <td>operator ()( Matrix< t_DataType> &INPUT_A, const Matrix< t_DataType> &INPUT_B) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix_multiply.h</td>
        <td>MatrixMultiply</td>
        <td>GetPrograms() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix_multiply.h</td>
        <td>MatrixMultiply</td>
        <td>MatrixMultiply( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix_multiply.h</td>
        <td>MatrixMultiply</td>
        <td>MatrixMultiply()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix_multiply.h</td>
        <td>MatrixMultiply</td>
        <td>operator ()( const Matrix< t_DataType> &INPUT_A, const Matrix< t_DataType> &INPUT_B) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix_multiply.h</td>
        <td>MatrixMultiply</td>
        <td>operator ()( const Matrix< t_DataType> &INPUT_A, const Matrix< t_DataType> &INPUT_B, Matrix< t_DataType> &OUTPUT) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix_transpose.h</td>
        <td>MatrixTranspose</td>
        <td>MatrixTranspose( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix_transpose.h</td>
        <td>MatrixTranspose</td>
        <td>MatrixTranspose()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix_transpose.h</td>
        <td>MatrixTranspose</td>
        <td>operator ()( const Matrix< t_DataType> &INPUT) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_matrix_transpose.h</td>
        <td>MatrixTranspose</td>
        <td>operator ()( const Matrix< t_DataType> &INPUT, Matrix< t_DataType> &OUTPUT) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_matrix_transpose.h</td>
        <td>MatrixTranspose</td>
        <td>operator ()( const linal::Matrix< t_DataType> &INPUT) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetArchitecture() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetBias() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetNumberInputs() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetNumberLayers() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetNumberOutputs() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetTransferFunction() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>GetWeight() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>NeuralNetwork( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>NeuralNetwork( const util::ShPtr< model::RescaleFeatureDataSet> &RESCALE_INPUT, const util::ShPtr< model::RescaleFeatureDataSet> &RESCALE_OUTPUT, const storage::Vector< Vector< float> > &BIAS, const storage::Vector< Matrix< float> > &WEIGHT, const CommandQueue &QUEUE )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>NeuralNetwork( const util::ShPtr< model::RescaleFeatureDataSet> &RESCALE_INPUT, const util::ShPtr< model::RescaleFeatureDataSet> &RESCALE_OUTPUT, const storage::Vector< linal::Vector< float> > &BIAS, const storage::Vector< linal::Matrix< float> > &WEIGHT, const util::Implementation< model::TransferFunctionInterface> &TRANSFER_FUNCTION, const CommandQueue &QUEUE )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>NeuralNetwork()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>PredictWithoutRescaling( const model::FeatureDataSetInterface< float> &FEATURE ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>Rescale( model::FeatureDataSet< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>SetArchitecture( const storage::Vector< size_t> &ARCHITECTURE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>SetBias( const storage::Vector< linal::Vector< float> > &BIAS)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>SetWeight( const storage::Vector< linal::Matrix< float> > &WEIGHT)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>operator ()( const Matrix< float> &INPUT) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_neural_network.h</td>
        <td>NeuralNetwork</td>
        <td>operator ()( const model::FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>DistanceMatrix( const util::SiPtrVector< const linal::VectorConstInterface< t_DataType> > &LIST_VECTORS ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>DistanceMatrix( const util::SiPtrVector< const linal::VectorConstInterface< t_DataType> > &LIST_VECTORS_A, const util::SiPtrVector< const linal::VectorConstInterface< t_DataType> > &LIST_VECTORS_B ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>DotProduct( const linal::VectorConstInterface< t_DataType> &VECTOR_A, const linal::VectorConstInterface< t_DataType> &VECTOR_B ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>GetInstance()
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>GetProgram() const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>IsCompatible( const CommandQueue &COMMAND_QUEUE) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>Max( const linal::VectorConstInterface< t_DataType> &VECTOR) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>Min( const linal::VectorConstInterface< t_DataType> &VECTOR) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>MinMax( const linal::MatrixConstInterface< t_DataType> &MATRIX) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>Multiply( const linal::MatrixConstInterface< t_DataType> &MATRIX, const linal::VectorConstInterface< t_DataType> &VECTOR ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>Multiply( const linal::MatrixConstInterface< t_DataType> &MATRIX_A, const linal::MatrixConstInterface< t_DataType> &MATRIX_B ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>Norm( const linal::VectorConstInterface< t_DataType> &VECTOR) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>Operations()
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>Sum( const Vector< t_DataType> &VECTOR) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>Sum( const linal::VectorConstInterface< t_DataType> &VECTOR) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>VectorEqualsVectorTimesMatrix( linal::VectorInterface< t_DataType> &STORAGE, const linal::VectorConstInterface< t_DataType> &FEATURE, const linal::MatrixConstInterface< t_DataType> &MATRIX ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_operations.h</td>
        <td>Operations</td>
        <td>VectorPlusEqualsMatrixTimesVector( linal::VectorInterface< t_DataType> &STORAGE, const linal::MatrixConstInterface< t_DataType> &MATRIX, const linal::VectorConstInterface< t_DataType> &FEATURE ) const
</td>
        <td>loweew, woetzen, vuot2</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>CommandLineDeviceType()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Description( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Devices( cl_device_type DEVICE_TYPE, cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Extensions( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>FirstPlatformWithDeviceType( const cl_device_type DEVICE_TYPE, cl_int *ERROR_PTR = NULL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>GetIsOpenclDisabled()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>GetPlatformFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>ICDExtension( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>InitializeFromCommandLine( Platform &PLATFORM, storage::Vector< Device> &DEVICES, cl_int *ERROR_PTR = NULL )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Name( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Platform( const cl::Platform &PLATFORM, cl_int *ERROR_PTR = NULL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Platform( const std::string &NAME, cl_int *ERROR_PTR = NULL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Platform()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Profile( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>QueryPlatformNamesStandardized( cl_int *ERROR_PTR = NULL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>QueryPlatforms( cl_int *ERROR_PTR = NULL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>StandardizedName( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Vendor( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_platform.h</td>
        <td>Platform</td>
        <td>Version( cl_int *ERROR_PTR = NULL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>Convert( const math::Tensor< double> &TENSOR) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>CrossCorrelationCoefficient( const Vector< double> &EXPERIMENTAL_BUFFER, const Vector< double> &SIMULATED_BUFFER, const linal::Vector< int> &EXP_START, const storage::VectorND< 3, size_t> &EXP_DIMENSIONS, const linal::Vector< int> &SIM_START, const storage::VectorND< 3, size_t> &SIM_DIMENSIONS, const linal::Vector< int> &EXTENSION, const double CONTOUR_LEVEL_SIMULATED ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>CrossCorrelationCoefficient( const Vector< double> &EXPERIMENTAL_BUFFER, const Vector< double> &SIMULATED_BUFFER, const size_t GRID_SIZE, const double CONTOUR_LEVEL_SIMULATED ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>CrossCorrelationCoefficient( const density::Map &EXPERIMENTAL_DENSITY_MAP, const density::Map &SIMULATED_DENSITY_MAP, const double CONTOUR_LEVEL_SIMULATED ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>CrossCorrelationCoefficient( const math::Tensor< double> &EXPERIMENTAL_SUBDENSITY_MAP, const math::Tensor< double> &SIMULATED_SUBDENSITY_MAP, const double CONTOUR_LEVEL_SIMULATED ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>GetCCCKernel()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>GetDensity() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>GetSimulator() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>IsCompatible( const CommandQueue &COMMAND_QUEUE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>MapToDevice( const density::Map &DENSITY_MAP, const storage::VectorND< 3, size_t> &NEW_DIMENSIONS ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>ProteinAgreementCCC( const bool ADD_SIDECHAIN_ATOMS = false)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>SetDensityMap( const util::SiPtr< const density::Map> &SP_DENSITY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>SetSimulator( const util::ShPtr< density::SimulateInterface> &SP_SIMULATOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>TensorToDevice( const math::Tensor< double> &TENSOR) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_protein_agreement_ccc.h</td>
        <td>ProteinAgreementCCC</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>CalculateGDTAndSuperimposition( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>CalculateGDTAndSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>CalculateSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>GetComparisonFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>GetSeedLength() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>IsCompatible( const CommandQueue &COMMAND_QUEUE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>OptimalValue() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>QualityGDT( const CommandQueue &QUEUE, const double &DISTANCE_CUTOFF, const size_t SEED_LENGTH = quality::GDT::GetDefaultSeedLength() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_gdt.h</td>
        <td>QualityGDT</td>
        <td>QualityGDT( const double &DISTANCE_CUTOFF, const size_t SEED_LENGTH = quality::GDT::GetDefaultSeedLength() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>CalculateIndices( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>CalculateMeasure( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>CalculateRanges( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>CalculateSuperimposition( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>CalculateSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>ExtendRange( const math::Range< size_t> &RANGE, const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>GetComparisonFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>GetCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>GetQualityRMSD() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>GetSeedLength() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>IsCompatible( const CommandQueue &COMMAND_QUEUE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>IsGoodRange( const math::Range< size_t> &RANGE, const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>OptimalValue() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>QualityLCS( const CommandQueue &QUEUE, const double RMSD_CUTOFF = quality::LCS::GetDefaultRmsdCutoff(), const size_t SEED_LENGTH = quality::LCS::GetDefaultSeedLength() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>QualityLCS( const double RMSD_CUTOFF = quality::LCS::GetDefaultRmsdCutoff(), const size_t SEED_LENGTH = quality::LCS::GetDefaultSeedLength() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_lcs.h</td>
        <td>QualityLCS</td>
        <td>RMSDOfEachFragment( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES, const size_t FRAGMENT_LENGTH ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>CalculateMeasure( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>CalculateSuperimposition( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>CalculateSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>GetComparisonFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>GetProgram() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>GetSuperimposeCoordinates() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>Initialize( const CommandQueue &COMMAND_QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>IsCompatible( const CommandQueue &COMMAND_QUEUE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>MatrixFromCoordinates( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const size_t BLOCK_SIZE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>OptimalValue() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>QualityRMSD( const CommandQueue &QUEUE, const bool SUPERIMPOSE_COORDINATES = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>QualityRMSD( const bool SUPERIMPOSE_COORDINATES = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>RealSpaceRMSD( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>SuperimposeCoordinates( const Matrix< double> &REFERENCE_COORDINATES, const Matrix< double> &COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_quality_rmsd.h</td>
        <td>QualityRMSD</td>
        <td>SuperimposedRMSD( const Matrix< double> &COORDINATES, const Matrix< double> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_rmsd.h</td>
        <td>RMSD</td>
        <td>RMSD( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_rmsd.h</td>
        <td>RMSD</td>
        <td>RMSD()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_rmsd.h</td>
        <td>RMSD</td>
        <td>operator ()( const Matrix< float> &INPUT_A, const Matrix< float> &INPUT_B ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_saxs_debye.h</td>
        <td>SaxsDebye</td>
        <td>SaxsDebye( const CommandQueue &QUEUE, const bool LOOPS = false, const bool USE_REGULA_FALSI_APPROXIMATION = false, float EXCLUDED_VOLUME_PARAMETER = 1.0, float HYDRATION_SHELL_PARAMETER = 0.0, const bool SIDE_CHAIN_APPROXIMATION = true, util::ShPtr< storage::Vector< restraint::SasScatteringPoint> > REDUCED_EXP_DATA = util::ShPtr< storage::Vector< restraint::SasScatteringPoint> >() )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_saxs_debye.h</td>
        <td>SaxsDebye</td>
        <td>SaxsDebye()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_saxs_debye.h</td>
        <td>SaxsDebye</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_singular_value_decomposition.h</td>
        <td>SingularValueDecomposition</td>
        <td>GetEigenValues() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_singular_value_decomposition.h</td>
        <td>SingularValueDecomposition</td>
        <td>GetEigenVectorsU() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_singular_value_decomposition.h</td>
        <td>SingularValueDecomposition</td>
        <td>GetEigenVectorsV() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_singular_value_decomposition.h</td>
        <td>SingularValueDecomposition</td>
        <td>SingularValueDecomposition( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_singular_value_decomposition.h</td>
        <td>SingularValueDecomposition</td>
        <td>SingularValueDecomposition()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_singular_value_decomposition.h</td>
        <td>SingularValueDecomposition</td>
        <td>operator ()( const linal::Matrix< t_DataType> &MATRIX )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>GetKernel() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>GetNumberOutputs() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>GetNumberSupportVectors() const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>PredictWithoutRescaling( const model::FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>Rescale( model::FeatureDataSet< float> &FEATURE) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetAlpha( const linal::VectorConstInterface< float> &ALPHA)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetBias( const float &BIAS)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetNumberSupportVectors( const size_t &NR_SV)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SetSupportVectors( const model::FeatureDataSet< float> &SV)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SupportVectorMachine( const CommandQueue &QUEUE)
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SupportVectorMachine( const float BIAS, const linal::VectorConstInterface< float> &ALPHAS, const model::FeatureDataSetInterface< float> &SUPPORT_VECTORS, const util::Implementation< model::SupportVectorKernelBase> &KERNEL, const model::RescaleFeatureDataSet &RESCALE_IN, const model::RescaleFeatureDataSet &RESCALE_OUT, const CommandQueue &QUEUE )
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>SupportVectorMachine()
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>operator ()( const Matrix< float> &FEATURE) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_support_vector_machine.h</td>
        <td>SupportVectorMachine</td>
        <td>operator ()( const model::FeatureDataSetInterface< float> &FEATURE) const
</td>
        <td>loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>AssignError( cl_int *ERROR_PTR, const cl_int ACTUAL_ERROR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>CalcPadding( const size_t BLOCK_SIZE, const size_t CURRENT_DIMENSION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>CompilePrograms( const util::CPPDataTypes::Types &PRECISION, const CommandQueue &QUEUE, cl::Program &PROGRAM, const std::string &KERNEL_FILENAME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>ErrorString( cl_int error)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>GetBufferProgram( const util::CPPDataTypes::Types &DATA_TYPE, const CommandQueue &QUEUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>GetCommandQueues()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>GetContext()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>GetDevices()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>GetFirstCommandQueue()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>GetPlatform()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>GetQueueUpdateSignal() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>GetTools()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>HasCommandQueues()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>ListPlatformsWithDevices( const util::Message::MessageLevel &MESSAGE_LEVEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>LogPtx( const cl::Program &cpProgram, const std::string &cPtxFileName)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>RoundUp( const int GROUP_SIZE, const int GLOBAL_SIZE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_tools.h</td>
        <td>Tools</td>
        <td>UpdateCurrentPlatformDevicesQueuesFromCommandLineFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_tools.h</td>
        <td></td>
        <td>GetTools()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>CompilePrograms( const util::CPPDataTypes::Types &PRECISION)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>F( const linal::MatrixConstInterface< t_DataType> &MATRIX) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>F( const linal::Vector< t_DataType> &VECTOR) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>F( const t_DataType &ELEMENT) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>GaussianF( const linal::MatrixConstInterface< t_DataType> &MATRIX ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>GaussianF( const linal::Vector< t_DataType> &VECTOR ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>GaussiandF( const linal::MatrixConstInterface< t_DataType> &MATRIX_A, const linal::MatrixConstInterface< t_DataType> &MATRIX_B ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>GaussiandF( const linal::Vector< t_DataType> &VECTOR_A, const linal::Vector< t_DataType> &VECTOR_B ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>GetKernelF()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>GetKerneldF()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>GetOutputRange() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>TransferFunctionGaussian( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>TransferFunctionGaussian()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>UpdateQueue( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>dF( const linal::MatrixConstInterface< t_DataType> &MATRIX_X, const linal::MatrixConstInterface< t_DataType> &MATRIX_Y) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>dF( const linal::Vector< t_DataType> &VECTOR_X, const linal::Vector< t_DataType> &VECTOR_Y) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_gaussian.h</td>
        <td>TransferFunctionGaussian</td>
        <td>dF( const t_DataType &ELEMENT_X, const t_DataType &ELEMENT_Y) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>CompilePrograms( const util::CPPDataTypes::Types &PRECISION)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>F( const Matrix< t_DataType> &INPUT, Matrix< t_DataType> &OUTPUT) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>GetKernelF()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>GetKerneldF()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>GetOutputRange() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>SigmoidF( const Matrix< t_DataType> &INPUT, Matrix< t_DataType> &OUTPUT ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>SigmoiddF( const Matrix< t_DataType> &INPUT, Matrix< t_DataType> &OUTPUT ) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>TransferFunctionSigmoid( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>TransferFunctionSigmoid()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_transfer_function_sigmoid.h</td>
        <td>TransferFunctionSigmoid</td>
        <td>dF( const Matrix< t_DataType> &INPUT, Matrix< t_DataType> &OUTPUT) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>Fill( const t_DataType &VALUE, const size_t OFFSET, const size_t NUMBER_ELEMENTS)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>GetData() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>GetHostVector( const size_t &PADDING = 0) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>GetPadding() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>GetQueue() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>GetSize() const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>OverWriteContents( t_DataType *DATA)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>SetValue( const size_t POS, const t_DataType &VALUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>Vector( const Vector< t_DataType> &VECTOR)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>Vector( const linal::VectorConstInterface< t_DataType> &VECTOR, const CommandQueue &QUEUE, const size_t PADDING = 0 )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>Vector( const size_t SIZE, const CommandQueue &QUEUE, const size_t PADDING = 0 )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>Vector( const size_t SIZE, const CommandQueue &QUEUE, const size_t PADDING, const t_DataType &ELEMENT )
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>Vector( const size_t SIZE, const t_DataType *DATA, const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>Vector()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_vector.h</td>
        <td>Vector</td>
        <td>operator =( const Vector< t_DataType> &VECTOR)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector_matrix_add.h</td>
        <td>VectorMatrixAdd</td>
        <td>VectorMatrixAdd( const CommandQueue &QUEUE)
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opencl_vector_matrix_add.h</td>
        <td>VectorMatrixAdd</td>
        <td>VectorMatrixAdd()
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opencl_vector_matrix_add.h</td>
        <td>VectorMatrixAdd</td>
        <td>operator ()( const Vector< t_DataType> &VECTOR, Matrix< t_DataType> &MATRIX) const
</td>
        <td>loweew</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>ApproximatorEvolution( const ApproximatorEvolution< t_MemberType, t_FitnessType> &OTHER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>ApproximatorEvolution()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>GetEvolutionOperations() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>GetFitnessFunction() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>GetHistoryList() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>GetPopulationBuilder() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>GetPopulationFitnessFunction() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>GetSerializer() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>GetTrackerWithHistory()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>GetTrackerWithHistory() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>SetEvolutionOperations( const EvolutionOperationSelect< t_MemberType, t_FitnessType> &OPERATIONS )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>SetFitnessFunction( const t_MemberFitnessFunction &FUNCTION )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>SetInitialPopulation( const t_Population &POPULATION, const bool &RESCORE = true )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>SetPopulationBuilder( const EvolutionPopulationBuilder< t_MemberType, t_FitnessType> &BUILDER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>SetPopulationFitnessFunction( const math::FunctionInterfaceSerializable< t_Population, t_FitnessType> &FUNCTION )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_evolution.h</td>
        <td>ApproximatorEvolution</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_golden_section.h</td>
        <td>ApproximatorGoldenSection</td>
        <td>ApproximatorGoldenSection( const math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> &OBJECTIVE, const CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION, const t_ArgumentType &BORDER_LEFT, const t_ArgumentType &BORDER_RIGHT )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_golden_section.h</td>
        <td>ApproximatorGoldenSection</td>
        <td>ApproximatorGoldenSection()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_golden_section.h</td>
        <td>ApproximatorGoldenSection</td>
        <td>GetResPhi()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_interface.h</td>
        <td>ApproximatorInterface</td>
        <td>Approximate()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>Approximate()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>ApproximatorModularBase( const ImprovementType &IMPROVEMENT_TYPE)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>ApproximatorModularBase( const Tracker< t_ArgumentType, t_ResultType> &TRACKER)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>ApproximatorModularBase()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>GetCurrentApproximation() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>GetTracker()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>GetTracker() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>SetCriterion( const CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>SetPrinter( const PrintInterface< t_ArgumentType, t_ResultType> &PRINTER)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_modular_base.h</td>
        <td>ApproximatorModularBase</td>
        <td>ShouldContinue() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_modular_interface.h</td>
        <td>ApproximatorModularInterface</td>
        <td>Approximate()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_nelder_mead.h</td>
        <td>ApproximatorNelderMead</td>
        <td>ApproximatorNelderMead( const math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> &OBJECTIVE, const CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION, const storage::List< t_ArgumentType> &START_SIMPLEX, const t_ResultType MINIMUM_DIFFERENCE )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_nelder_mead.h</td>
        <td>ApproximatorNelderMead</td>
        <td>ApproximatorNelderMead()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_nelder_mead.h</td>
        <td>LessFunctionValue</td>
        <td>operator ()( const util::ShPtr< storage::Pair< t_ArgumentType, t_ResultType> > &RESULT_LHS, const util::ShPtr< storage::Pair< t_ArgumentType, t_ResultType> > &RESULT_RHS ) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_powell.h</td>
        <td>ApproximatorPowell</td>
        <td>ApproximatorPowell( const math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> &OBJECTIVE, const CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION, const storage::Vector< t_ArgumentType> &SEARCH_DIRECTIONS, const t_ArgumentType &ARGUMENT )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_powell.h</td>
        <td>ApproximatorPowell</td>
        <td>ApproximatorPowell()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_powell.h</td>
        <td>ApproximatorPowell</td>
        <td>GetCurrentApproximation() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_root_bisect.h</td>
        <td>ApproximatorRootBisect</td>
        <td>ApproximatorRootBisect( const math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> &OBJECTIVE, const CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION, const t_ArgumentType &LEFT_BORDER, const t_ArgumentType &RIGHT_BORDER )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_root_bisect.h</td>
        <td>ApproximatorRootBisect</td>
        <td>ApproximatorRootBisect()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_root_newton.h</td>
        <td>ApproximatorRootNewton</td>
        <td>ApproximatorRootNewton( const math::FunctionInterfaceSerializable< t_ArgumentResultType, t_ArgumentResultType> &OBJECTIVE, const math::FunctionInterfaceSerializable< t_ArgumentResultType, t_ArgumentResultType> &DERIVATIVE, const CriterionInterface< t_ArgumentResultType, t_ArgumentResultType> &CRITERION, const t_ArgumentResultType &GUESS )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_root_newton.h</td>
        <td>ApproximatorRootNewton</td>
        <td>ApproximatorRootNewton()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_root_regula_falsi.h</td>
        <td>ApproximatorRootRegulaFalsi</td>
        <td>ApproximatorRootRegulaFalsi( const math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> &OBJECTIVE_FUNCTION, const CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION, const t_ArgumentType &BORDER_LEFT, const t_ArgumentType &BORDER_RIGHT )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_root_regula_falsi.h</td>
        <td>ApproximatorRootRegulaFalsi</td>
        <td>ApproximatorRootRegulaFalsi()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_approximator_root_secant.h</td>
        <td>ApproximatorRootSecant</td>
        <td>ApproximatorRootSecant( const math::FunctionInterfaceSerializable< t_ArgumentResultType, t_ArgumentResultType> &OBJECTIVE, const CriterionInterface< t_ArgumentResultType, t_ArgumentResultType> &CRITERION, const t_ArgumentResultType &LEFT_BORDER, const t_ArgumentResultType &RIGHT_BORDER )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_approximator_root_secant.h</td>
        <td>ApproximatorRootSecant</td>
        <td>ApproximatorRootSecant()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_accepted.h</td>
        <td>CriterionAccepted</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>karakam, mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_accepted.h</td>
        <td>CriterionAccepted</td>
        <td>CriterionAccepted( const size_t &NUMBER_STEPS)
</td>
        <td>karakam, mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_accepted.h</td>
        <td>CriterionAccepted</td>
        <td>CriterionAccepted()
</td>
        <td>karakam, mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_all.h</td>
        <td>CriterionAll</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_all.h</td>
        <td>CriterionAll</td>
        <td>CriterionAll( const storage::List< util::Implementation< CriterionInterface< t_ArgumentType, t_ResultType> > > &CRITERIA_LIST )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_all.h</td>
        <td>CriterionAll</td>
        <td>CriterionAll()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_all.h</td>
        <td>CriterionAll</td>
        <td>InsertCriteria( const CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_combine.h</td>
        <td>CriterionCombine</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_combine.h</td>
        <td>CriterionCombine</td>
        <td>CriterionCombine( const storage::List< util::Implementation< CriterionInterface< t_ArgumentType, t_ResultType> > > &CRITERIA_LIST )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_combine.h</td>
        <td>CriterionCombine</td>
        <td>CriterionCombine()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_combine.h</td>
        <td>CriterionCombine</td>
        <td>InsertCriteria( const CriterionInterface< t_ArgumentType, t_ResultType> &CRITERION)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_convergence_argument.h</td>
        <td>CriterionConvergenceArgument</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_convergence_argument.h</td>
        <td>CriterionConvergenceArgument</td>
        <td>CriterionConvergenceArgument( const size_t &MAX_NUMBER_REPEATS, const t_ArgumentType &TOLERANCE)
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_convergence_argument.h</td>
        <td>CriterionConvergenceArgument</td>
        <td>CriterionConvergenceArgument()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_convergence_argument.h</td>
        <td>CriterionConvergenceArgument</td>
        <td>GetMaxNumberRepeats() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_convergence_argument.h</td>
        <td>CriterionConvergenceArgument</td>
        <td>GetNumberRepeats() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_convergence_argument.h</td>
        <td>CriterionConvergenceArgument</td>
        <td>GetTolerance() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_convergence_result.h</td>
        <td>CriterionConvergenceResult</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_convergence_result.h</td>
        <td>CriterionConvergenceResult</td>
        <td>CriterionConvergenceResult( const size_t &MAX_NUMBER_REPEATS, const t_ResultType &TOLERANCE )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_convergence_result.h</td>
        <td>CriterionConvergenceResult</td>
        <td>CriterionConvergenceResult()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_convergence_result.h</td>
        <td>CriterionConvergenceResult</td>
        <td>GetMaxNumberRepeats() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_convergence_result.h</td>
        <td>CriterionConvergenceResult</td>
        <td>GetNumberRepeats() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_convergence_result.h</td>
        <td>CriterionConvergenceResult</td>
        <td>GetTolerance() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_divergence_argument.h</td>
        <td>CriterionDivergenceArgument</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_divergence_argument.h</td>
        <td>CriterionDivergenceArgument</td>
        <td>CriterionDivergenceArgument( const size_t &MAX_NUMBER_REPEATS, const t_ArgumentType &INTERVAL_WIDTH )
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_divergence_argument.h</td>
        <td>CriterionDivergenceArgument</td>
        <td>CriterionDivergenceArgument()
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_divergence_argument.h</td>
        <td>CriterionDivergenceArgument</td>
        <td>GetIntervalWidth() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_divergence_argument.h</td>
        <td>CriterionDivergenceArgument</td>
        <td>GetMaxNumberRepeats() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_divergence_argument.h</td>
        <td>CriterionDivergenceArgument</td>
        <td>GetNumberRepeats() const
</td>
        <td>fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_elapsed_time.h</td>
        <td>CriterionElapsedTime</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>butkiem1, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_elapsed_time.h</td>
        <td>CriterionElapsedTime</td>
        <td>CriterionElapsedTime( const util::Time &DURATION_TIME)
</td>
        <td>butkiem1, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_elapsed_time.h</td>
        <td>CriterionElapsedTime</td>
        <td>CriterionElapsedTime()
</td>
        <td>butkiem1, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_function.h</td>
        <td>CriterionFunction</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_function.h</td>
        <td>CriterionFunction</td>
        <td>CriterionFunction( const util::FunctionInterfaceSerializable< t_ArgumentType, bool> &DECIIDER_FUNCTION)
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_function.h</td>
        <td>CriterionFunction</td>
        <td>CriterionFunction()
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_improvement_ratio.h</td>
        <td>CriterionImprovementRatio</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>karakam, mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_improvement_ratio.h</td>
        <td>CriterionImprovementRatio</td>
        <td>CriterionImprovementRatio( const double &RATIO, const size_t &NUMBER_STEPS)
</td>
        <td>karakam, mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_improvement_ratio.h</td>
        <td>CriterionImprovementRatio</td>
        <td>CriterionImprovementRatio()
</td>
        <td>karakam, mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_n_step.h</td>
        <td>CriterionNStep</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_n_step.h</td>
        <td>CriterionNStep</td>
        <td>CriterionNStep( const size_t &REPEAT_INTERVAL)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_n_step.h</td>
        <td>CriterionNStep</td>
        <td>CriterionNStep()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_n_step.h</td>
        <td>CriterionNStep</td>
        <td>GetRepeatInterval() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_number_iterations.h</td>
        <td>CriterionNumberIterations</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_number_iterations.h</td>
        <td>CriterionNumberIterations</td>
        <td>CriterionNumberIterations( const size_t &MAX_NUMBER_ITERATIONS)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_number_iterations.h</td>
        <td>CriterionNumberIterations</td>
        <td>CriterionNumberIterations()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_number_iterations.h</td>
        <td>CriterionNumberIterations</td>
        <td>GetMaxNumberIterations() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_number_iterations.h</td>
        <td>CriterionNumberIterations</td>
        <td>SetMaxNumberIterations( const size_t &MAX_NUMBER_ITERATIONS)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_phase.h</td>
        <td>CriterionPhase</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_phase.h</td>
        <td>CriterionPhase</td>
        <td>CriterionPhase( const storage::Set< PhaseEnum> &PHASES)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_phase.h</td>
        <td>CriterionPhase</td>
        <td>CriterionPhase()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_rejected.h</td>
        <td>CriterionRejected</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>karakam, mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_rejected.h</td>
        <td>CriterionRejected</td>
        <td>CriterionRejected( const size_t &NUMBER_STEPS)
</td>
        <td>karakam, mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_rejected.h</td>
        <td>CriterionRejected</td>
        <td>CriterionRejected()
</td>
        <td>karakam, mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_result_changed.h</td>
        <td>CriterionResultChanged</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_result_changed.h</td>
        <td>CriterionResultChanged</td>
        <td>CriterionResultChanged()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_result_threshold.h</td>
        <td>CriterionResultThreshold</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_result_threshold.h</td>
        <td>CriterionResultThreshold</td>
        <td>CriterionResultThreshold( const t_ResultType &THRESHOLD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_result_threshold.h</td>
        <td>CriterionResultThreshold</td>
        <td>CriterionResultThreshold()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_skipped_steps.h</td>
        <td>CriterionSkippedSteps</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_skipped_steps.h</td>
        <td>CriterionSkippedSteps</td>
        <td>CriterionSkippedSteps( const size_t &MAX_NUMBER_ITERATIONS)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_skipped_steps.h</td>
        <td>CriterionSkippedSteps</td>
        <td>CriterionSkippedSteps()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_skipped_steps.h</td>
        <td>CriterionSkippedSteps</td>
        <td>GetMaxSkippedSteps() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_skipped_steps.h</td>
        <td>CriterionSkippedSteps</td>
        <td>SetMaxSkippedSteps( const size_t &MAX_NUMBER_SKIPPED)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_unimproved.h</td>
        <td>CriterionUnimproved</td>
        <td>CriteriaMet( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_unimproved.h</td>
        <td>CriterionUnimproved</td>
        <td>CriterionUnimproved( const size_t &MAX_NUMBER_UNIMPROVED_STEPS)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_criterion_unimproved.h</td>
        <td>CriterionUnimproved</td>
        <td>CriterionUnimproved()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_criterion_unimproved.h</td>
        <td>CriterionUnimproved</td>
        <td>GetMaxNumberUnimprovedSteps() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_deterministic_tournament_selector.h</td>
        <td>DeterministicTournamentSelector</td>
        <td>DeterministicTournamentSelector( const size_t &SAMPLE = 1)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_deterministic_tournament_selector.h</td>
        <td>DeterministicTournamentSelector</td>
        <td>GetSerializer() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_deterministic_tournament_selector.h</td>
        <td>DeterministicTournamentSelector</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_deterministic_tournament_selector.h</td>
        <td>DeterministicTournamentSelector</td>
        <td>operator ()( const Population< t_MemberType, t_FitnessType> &POPULATION ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_ensemble_filter.h</td>
        <td>EnsembleFilter</td>
        <td>EnsembleFilter( const score::ProteinModel &SCORE_FUNCTION, double KEEP)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_ensemble_filter.h</td>
        <td>EnsembleFilter</td>
        <td>EnsembleFilter()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_ensemble_filter.h</td>
        <td>EnsembleFilter</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_ensemble_node.h</td>
        <td>EnsembleNode</td>
        <td>EnsembleNode( const OptimizationInterface< t_DataType> &OPTIMIZER, size_t NUMBER_TRAJECTORIES = 1)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_ensemble_node.h</td>
        <td>EnsembleNode</td>
        <td>EnsembleNode()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_ensemble_node.h</td>
        <td>EnsembleNode</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_operation_select.h</td>
        <td>EvolutionOperationSelect</td>
        <td>AddImplementation( const EvolutionOperationSerializable &OPERATION, const double &PROBABILITY)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_operation_select.h</td>
        <td>EvolutionOperationSelect</td>
        <td>EvolutionOperationSelect()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_operation_select.h</td>
        <td>EvolutionOperationSelect</td>
        <td>GetDecisionNode()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_operation_select.h</td>
        <td>EvolutionOperationSelect</td>
        <td>GetSerializer() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_operation_select.h</td>
        <td>EvolutionOperationSelect</td>
        <td>GetSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_operation_select.h</td>
        <td>EvolutionOperationSelect</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_operation_select.h</td>
        <td>EvolutionOperationSelect</td>
        <td>Select() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionMemberCompareLess</td>
        <td>operator ()( const EvolutionPopulationMember< t_MemberType, t_FitnessType> &LHS, const EvolutionPopulationMember< t_MemberType, t_FitnessType> &RHS ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionMemberCompareLess</td>
        <td>operator ()( const util::PtrInterface< EvolutionPopulationMember< t_MemberType, t_FitnessType> > &LHS, const util::PtrInterface< EvolutionPopulationMember< t_MemberType, t_FitnessType> > &RHS ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionMemberUniqueInterface</td>
        <td>operator ()( const EvolutionPopulationMember< t_MemberType, t_FitnessType> &MEMBER, const EvolutionPopulation< t_MemberType, t_FitnessType> &POPULATION ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>AddMember( const EvolutionPopulationMember< t_MemberType, t_FitnessType> &NEW_MEMBER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>AddMember( const t_MemberType &MEMBER, const t_FitnessType &FITNESS_SCORE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>AddMember( const util::ShPtr< EvolutionPopulationMember< t_MemberType, t_FitnessType> > &NEW_MEMBER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>AddMembers( const util::ShPtrVector< EvolutionPopulationMember< t_MemberType, t_FitnessType> > &MEMBERS)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>EvolutionPopulation( const EvolutionPopulation< t_MemberType, t_FitnessType> &OTHER )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>EvolutionPopulation( const size_t &POPULATION_SIZE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>EvolutionPopulation( const size_t &POPULATION_SIZE, util::ShPtrVector< EvolutionPopulationMember< t_MemberType, t_FitnessType> > &INITIAL_MEMBERS )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>EvolutionPopulation()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetCurrentSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetFitnessAverage() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetFitnessStdDev() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetFittestMembers( const size_t &NUMBER ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetFittestPercent( const float &PERCENTAGE ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetHighestFitness() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetLowestFitness() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetMembers() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetMembersIterator()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetMembersIterator() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetMembersWithMinimumFitness( const t_FitnessType &FITNESS ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetNormalSize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetRandomMember() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetRandomMemberFromDistribution( const math::DiscreteSetSelector &SELECTOR ) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetUniquenessImplementation() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>GetUniquenessMeasure() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>HasMember( const EvolutionPopulationMember< t_MemberType, t_FitnessType> &MEMBER) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>Prune()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>Reset()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>SetNormalSize( const size_t &SIZE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>SetUniquenessMeasure( const EvolutionMemberUniqueInterface< t_MemberType, t_FitnessType> &MEASURE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population.h</td>
        <td>EvolutionPopulation</td>
        <td>operator =( const EvolutionPopulation< t_MemberType, t_FitnessType> &OTHER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population_member.h</td>
        <td>EvolutionPopulationMember</td>
        <td>EvolutionPopulationMember( const t_MemberType &MEMBER, const t_FitnessType &FITNESS )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population_member.h</td>
        <td>EvolutionPopulationMember</td>
        <td>EvolutionPopulationMember( const t_MemberType &MEMBER, const t_FitnessType &FITNESS, const util::ObjectDataLabel &HISTORY )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population_member.h</td>
        <td>EvolutionPopulationMember</td>
        <td>EvolutionPopulationMember()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population_member.h</td>
        <td>EvolutionPopulationMember</td>
        <td>GetFitness() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population_member.h</td>
        <td>EvolutionPopulationMember</td>
        <td>GetHistory() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population_member.h</td>
        <td>EvolutionPopulationMember</td>
        <td>GetMember() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population_member.h</td>
        <td>EvolutionPopulationMember</td>
        <td>SetFitness( const t_FitnessType &FITNESS)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_evolution_population_member.h</td>
        <td>EvolutionPopulationMember</td>
        <td>SetHistory( const util::ObjectDataLabel &HISTORY)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_evolution_population_member.h</td>
        <td>EvolutionPopulationMember</td>
        <td>SetMember( const t_MemberType &MEMBER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_improvement_type.h</td>
        <td></td>
        <td>DoesImprove( const double &TEST, const double &PRIOR, const ImprovementType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_improvement_type.h</td>
        <td></td>
        <td>DoesImprove( const float &TEST, const float &PRIOR, const ImprovementType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_improvement_type.h</td>
        <td></td>
        <td>DoesImprove( const int &TEST, const int &PRIOR, const ImprovementType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_improvement_type.h</td>
        <td></td>
        <td>GetImprovementTypeName( const ImprovementType &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_optimization_identity.h</td>
        <td>OptimizationIdentity</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_optimization_identity.h</td>
        <td>OptimizationIdentity</td>
        <td>OptimizationIdentity()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_optimization_interface.h</td>
        <td>OptimizationInterface</td>
        <td>AddPostProcessor( const ProcessorInterface< t_ArgumentType> &PROCESSOR)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_optimization_interface.h</td>
        <td>OptimizationInterface</td>
        <td>AddPreProcessor( const ProcessorInterface< t_ArgumentType> &PROCESSOR)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_optimization_interface.h</td>
        <td>OptimizationInterface</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_optimization_interface.h</td>
        <td>OptimizationInterface</td>
        <td>operator ()( t_ArgumentType &ARGUMENT) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_phase.h</td>
        <td></td>
        <td>GetPhaseName( const Phase &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_phase.h</td>
        <td></td>
        <td>PhasesEqual( const Phase &A, const Phase &B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_pipeline.h</td>
        <td>Pipeline</td>
        <td>AppendModule( const OptimizationInterface< t_ArgumentType> &MODULE)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_pipeline.h</td>
        <td>Pipeline</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_pipeline.h</td>
        <td>Pipeline</td>
        <td>Pipeline( const storage::Vector< PipelineModule> &PIPELINE)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_pipeline.h</td>
        <td>Pipeline</td>
        <td>Pipeline()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_print_interface.h</td>
        <td>PrintInterface</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>GetFilenameExtension() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>GetFilenamePrefix() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>GetPrintInterval() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>Print( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>Print( const t_ArgumentType &ARGUMENT, const size_t ITERATION ) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>PrinterArgumentToFile( const std::string &OUTPUT_FILE_NAME, const size_t &INTERVAL, const bool OVERWRITE = false, const bool &WRITE_RESULT_TO_SCREEN = false )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>PrinterArgumentToFile()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>SetFilenameExtension( const std::string &EXTENSION)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>SetFilenamePrefix( const std::string &PREFIX)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_printer_argument_to_file.h</td>
        <td>PrinterArgumentToFile</td>
        <td>SetPrintInterval( const size_t &INTERVAL)
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>GetDisplayResult() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>Print( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>PrinterDefault( const bool &PRINT_ARGUMENT, const bool &PRINT_RESULT )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_printer_default.h</td>
        <td>PrinterDefault</td>
        <td>PrinterDefault()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_printer_with_criterion.h</td>
        <td>PrinterWithCriterion</td>
        <td>Print( const Tracker< t_ArgumentType, t_ResultType> &TRACKER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_printer_with_criterion.h</td>
        <td>PrinterWithCriterion</td>
        <td>PrinterWithCriterion( const util::Implementation< PrintInterface< t_ArgumentType, t_ResultType> > &PRINTER, const util::Implementation< CriterionInterface< t_ArgumentType, t_ResultType> > &PRINT_CRITERIA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_printer_with_criterion.h</td>
        <td>PrinterWithCriterion</td>
        <td>PrinterWithCriterion()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_probabilistic_selection.h</td>
        <td>ProbabilisticSelection</td>
        <td>GetSerializer() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_probabilistic_selection.h</td>
        <td>ProbabilisticSelection</td>
        <td>ProbabilisticSelection( const size_t &FINAL_SIZE = 0 )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_probabilistic_selection.h</td>
        <td>ProbabilisticSelection</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_probabilistic_selection.h</td>
        <td>ProbabilisticSelection</td>
        <td>operator ()( Population< t_MemberType, t_FitnessType> &POPULATION) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_step_status.h</td>
        <td></td>
        <td>GetStepStatusName( const StepStatus &STEP_STATUS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>GetAveragingWindowSize() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>GetBest() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>GetCurrent() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>GetLast() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>GetStepScheme() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>GetTag() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>IncrementSkippedSteps()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>RemoveTrackerTag( const std::string &KEY)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>Reset()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>SetAveragingWindowSize( const size_t &AVERAGING_WINDOW)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>SetCurrent( const util::ShPtr< storage::Pair< t_ArgumentType, t_ResultType> > &CURRENT)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>SetStepScheme( const std::string &STEP_SCHEME)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>Track( const util::ShPtr< storage::Pair< t_ArgumentType, t_ResultType> > &SP_MODEL, StepStatus STEP_STATUS = s_NumberStepStatus )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>Tracker( const ImprovementType &IMPROVEMENT_TYPE, const size_t &AVERAGING_WINDOW_SIZE = 1)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker.h</td>
        <td>Tracker</td>
        <td>Tracker()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>GetBestIteration() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>GetCounts() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>GetImprovementType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>GetIteration() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>GetIterationsSinceLastImprovement() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>GetNumberStepsInARow( const StepStatus STEP_STATUS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>GetPhase() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>GetStatusOfLastStep() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>SetPhase( const Phase &PHASE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>TrackerBase( const ImprovementType &IMPROVEMENT_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>TrackerBase()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_base.h</td>
        <td>TrackerBase</td>
        <td>Update( const StepStatus STEP_STATUS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_with_history.h</td>
        <td>TrackerWithHistory</td>
        <td>GetHistory() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_with_history.h</td>
        <td>TrackerWithHistory</td>
        <td>GetInitial() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_with_history.h</td>
        <td>TrackerWithHistory</td>
        <td>GetMaxHistorySize() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_with_history.h</td>
        <td>TrackerWithHistory</td>
        <td>Reset()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_with_history.h</td>
        <td>TrackerWithHistory</td>
        <td>SetMaxHistorySize( const size_t &NUMBER)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_with_history.h</td>
        <td>TrackerWithHistory</td>
        <td>Track( const util::ShPtr< storage::Pair< t_ArgumentType, t_ResultType> > &SP_MODEL, StepStatus STEP_STATUS = s_NumberStepStatus )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_opti_tracker_with_history.h</td>
        <td>TrackerWithHistory</td>
        <td>TrackerWithHistory( const ImprovementType &IMPROVEMENT_TYPE, const size_t &AVERAGING_WINDOW_SIZE = 1, const size_t &STEPS_TO_KEEP = 1)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_opti_tracker_with_history.h</td>
        <td>TrackerWithHistory</td>
        <td>TrackerWithHistory( const size_t STEPS_TO_KEEP = 1)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb.h</td>
        <td></td>
        <td>GetDefaultFileExtension()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_entry_type_data.h</td>
        <td>EntryTypeData</td>
        <td>EntryTypeData( const LineType &LINE_TYPE, const size_t START, const size_t LENGTH, const size_t PRECISION, const bool RIGHT_ALIGNED, const util::CPPDataTypes::Types DATA_TYPE )
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_entry_type_data.h</td>
        <td>EntryTypeData</td>
        <td>EntryTypeData()
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_entry_type_data.h</td>
        <td>EntryTypeData</td>
        <td>GetDataType() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_entry_type_data.h</td>
        <td>EntryTypeData</td>
        <td>GetFormat() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_entry_type_data.h</td>
        <td>EntryTypeData</td>
        <td>GetLength() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_entry_type_data.h</td>
        <td>EntryTypeData</td>
        <td>GetLineType() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_entry_type_data.h</td>
        <td>EntryTypeData</td>
        <td>GetStart() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_entry_type_data.h</td>
        <td>EntryTypeData</td>
        <td>IsNumeric() const
</td>
        <td>staritrd, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_entry_types.h</td>
        <td>EntryTypes</td>
        <td>AddEntryType( const std::string &DESCRIPTOR, const EntryTypeData &ENTRY_DATA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_entry_types.h</td>
        <td></td>
        <td>GetEntryTypes()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>AASequencesFromPDB( const Handler &HANDLER, const std::string &PDB_ID = Ó) const
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>AddLoops( const storage::Set< util::ShPtr< assemble::SSE>, assemble::SSELessThanNoOverlap> &SECONDARY_STRUCTURE_ELEMENTS, const biol::AASequence &SEQUENCE )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>AppendPrinter( const util::ShPtr< util::FunctionInterface< assemble::ProteinModel, util::ShPtrList< Line> > > &SP_PRINTER )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>AtomFromLine( const Line &LINE)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>AtomFromLine( const biol::AtomType &ATOM_TYPE, const Line &LINE )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>ChainFromFastaStream( const char CHAIN_ID, std::istream &ISTREAM) const
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>ChainFromPDBSSElementsAndSequence( const char CHAIN_ID, const storage::List< storage::Triplet< biol::SSType, ResidueSimple, ResidueSimple> > &SSE_RESIDUES, const storage::List< Residue> &SEQUENCE_RESIDUES, const storage::Map< biol::SSType, size_t> &SSE_TYPE_MINSIZE, const std::string &PDB_ID ) const
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>Factory( const biol::AAClass &AA_CLASS)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>Factory()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetAllFlags()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetCommandlineSSETypeMinSizes( const command::FlagInterface &FLAG = *GetFlagMinSSESize())
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagAAClass()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagBiomolecule()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagConvertToNaturalAAType()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagDSSP()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagMinSSESize()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagPDBAtomName()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagSSEsFromBackBone()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagWriteHydrogens()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagWritePDBAtomID()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagWritePDBResID()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetFlagWriteZeroCoordinatesForUndefinedAminoAcids()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetPrinters() const
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>GetSSETypeMinSizes( const size_t &MIN_HELIX_SIZE, const size_t &MIN_STRAND_SIZE, const size_t &MIN_COIL_SIZE)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>MergeOverlappingSequences( const biol::AASequence &SEQUENCE_A, const biol::AASequence &SEQUENCE_B )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>ProcessOverlappingSSEs( const util::ShPtrVector< assemble::SSE> &SECONDARY_STRUCTURE_ELEMENTS, const bool MERGE_OVERLAPPING )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>ProteinEnsembleFromPDB( const Handler &HANDLER, const storage::Map< biol::SSType, size_t> &SSE_TYPE_MINSIZE = GetCommandlineSSETypeMinSizes() ) const
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>ProteinModelFromPDB( const Handler &HANDLER, const storage::Map< biol::SSType, size_t> &SSE_TYPE_MINSIZE = GetCommandlineSSETypeMinSizes() ) const
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>ProteinModelFromPDBFilename( const std::string &PDB_FILENAME, const storage::Map< biol::SSType, size_t> &SSE_TYPE_MINSIZE = GetCommandlineSSETypeMinSizes(), const bool IGNORE_CLASH = false ) const
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>RemoveOverlappingAAs( const util::ShPtr< assemble::SSE> &SSE_A, const util::ShPtr< assemble::SSE> &SSE_B )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>ResetFlagDefaults()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>ResetPrinters()
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>SecondaryStructureElementFromSequence( const biol::AASequence &SEQUENCE, const storage::Triplet< biol::SSType, ResidueSimple, ResidueSimple> &SSE_RESIDUE )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>SecondaryStructureElementsFromSequence( const biol::AASequence &SEQUENCE, const storage::List< storage::Triplet< biol::SSType, ResidueSimple, ResidueSimple> > &SSE_RESIDUES )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteAASequenceToLines( const biol::AASequence &AA_SEQUENCE, size_t &SERIAL)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteAtomToLine( const biol::Atom &ATOM, const biol::AABase &AMINO_ACID, const char CHAIN_ID, const size_t SERIAL )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteBodyInformationToLines( const assemble::ProteinModel &PROTEIN_MODEL)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteBodyInformationToLines( const assemble::SSE &THIS_SSE)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteChainToLines( const assemble::Chain &CHAIN, size_t &SERIAL)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteChainToPDB( const assemble::Chain &CHAIN, std::ostream &OSTREAM)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteCompleteModelToPDBLines( const assemble::ProteinModel &PROTEIN_MODEL, const bool WRITE_BODY_INFORMATION = false, const std::string &CLASSIFICATION = Ó, const util::Time &TIME = util::Time::GetCurrent() ) const
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteHeaderToLine( const std::string &CLASSIFICATION, const util::Time &TIME)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteHelixDefinitionToLine( const assemble::SSE &THIS_SSE, const size_t HELIX_SERIAL )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteHelixDefinitionsToLines( const util::SiPtrVector< const assemble::SSE> &SSE_VECTOR, size_t &HELIX_SERIAL )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteModelToPDB( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM, const bool WRITE_BODY_INFORMATION = false, const std::string &CLASSIFICATION = Ó, const util::Time &TIME = util::Time::GetCurrent() ) const
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteProteinModelToLines( const assemble::ProteinModel &PROTEIN_MODEL, size_t &SERIAL )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteResiduesToLines( const biol::AABase &AMINO_ACID, const char CHAIN_ID, size_t &SERIAL )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteSSEDefinitionToLine( const assemble::SSE &THIS_SSE, const size_t &SERIAL )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteSSEDefinitionsToLines( const util::ShPtrVector< assemble::ProteinModel> &PROTEIN_MODELS )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteSeqResToLines( const assemble::Chain &CHAIN)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteSeqResToLines( const assemble::ProteinModel &PROTEIN_MODEL)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteSeqResToLines( const biol::AASequence &SEQUENCE)
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteStrandDefinitionToLine( const assemble::SSE &THIS_SSE, const size_t STRAND_SERIAL )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_factory.h</td>
        <td>Factory</td>
        <td>WriteStrandDefinitionsToLines( const util::SiPtrVector< const assemble::SSE> &SSE_VECTOR, size_t &STRAND_SERIAL )
</td>
        <td>staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>AppendLines( const util::ShPtrList< Line> &PDBLINES)
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>ChainIDs() const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>CollectLines( const util::FunctionInterface< Line, bool> &CRITERIUM) const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>ExtractPathAndPDBTag( const std::string &FULL_PATH)
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetFlagHelixClasses()
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetFlagMergeOverlappingSSEs()
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetHead() const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetHelixClassesFromCommandLine()
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetLigands() const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetLines( const LineType &LINE_TYPE) const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetModels() const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetProteinChains() const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetSSEStructure() const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetSequence( const char CHAINID) const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetSites() const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>GetTypesOfLines() const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>Handler( const Handler &PDBREADER, const bool IGNORE_CLASH = false)
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>Handler( const bool IGNORE_CLASH = false)
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>Handler( std::istream &ISTREAM, const bool IGNORE_CLASH = false)
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>IsInChain( const ResidueInterface &RESIDUE) const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>PushBack( const util::ShPtr< Line> &LINE)
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>Reset()
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_handler.h</td>
        <td>Handler</td>
        <td>WriteLines( std::ostream &OSTREAM) const
</td>
        <td>staritrd, karakam, haenigc, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>CollectLines( const util::FunctionInterface< Line, bool> &CRITERIUM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>CollectLines( const util::FunctionInterface< Line, bool> &CRITERIUM, const LineType &LINE_TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>Count( const LineType &LINE_TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetBCLPdbID()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetBioTransformationMatrices( const std::string &CHAIN_IDS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetHetFormula() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetHetFullname() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetLines( const LineType &LINE_TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetMembrane() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetMissingResidues( const size_t MODEL_NUMBER) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetPDBID() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetSEQRESProteinChains() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetTransformationMatrices() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>GetTypesOfLines() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>Head()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>PushBack( const util::ShPtr< Line> &LINE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>Reset()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>SSEDefinitionFromPDBLine( const Line &PDB_LINE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>SSEDefinitions( const storage::Set< biol::SSType> &HELIX_CLASSES, const bool MERGE_OVERLAPPING) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>SSEDefinitionsMergeOverlap( const storage::Map< char, storage::List< storage::Triplet< biol::SSType, ResidueSimple, ResidueSimple> > > &SSE_DEFINITIONS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>SSEInformationCompare( const storage::Triplet< biol::SSType, ResidueSimple, ResidueSimple> &SSE_INFO_LHS, const storage::Triplet< biol::SSType, ResidueSimple, ResidueSimple> &SSE_INFO_RHS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_head.h</td>
        <td>Head</td>
        <td>WriteLines( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_head.h</td>
        <td>RemarkLineLessThan</td>
        <td>operator ()( const util::ShPtr< Line> &LINE_LHS, const util::ShPtr< Line> &LINE_RHS) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>AddConnections( const storage::Map< size_t, storage::Set< size_t> > &CONNECTIONS)
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>AtomSerials() const
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>ChangeLines()
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>GetChainID() const
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>GetFormula() const
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>GetFullname() const
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>GetICode() const
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>GetPDBID() const
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>GetResidueName() const
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>Ligand( const util::ShPtrList< Line> &LINES)
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>Ligand()
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>SetChainID( const char CHAINID)
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>SetFormula( const std::string &FORMULA)
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>SetFullname( const std::string &FULL_NAME)
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>SetICode( const char ICODE)
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>SetPDBID( const int PDBID)
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_ligand.h</td>
        <td>Ligand</td>
        <td>SetResidueName( const std::string &RESIDUENAME)
</td>
        <td>alexanns, loweew, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>Clear()
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>CopyHetatmToAtomLine( const Line &HETATM_LINE)
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>GetChar( const EntryType &ENTRY) const
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>GetNumericalValue( const EntryType &ENTRY) const
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>GetString( const EntryType &ENTRY) const
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>GetString() const
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>GetType() const
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>Line( const LineType &LINE_TYPE)
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>Line( const std::string &STRING)
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>Line()
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>MatchesCriteria( const storage::Pair< EntryType, std::string> &CRITERIUM) const
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>Put( const EntryType &ENTRY, const t_DataType &DATA)
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>PutCoordinates( const linal::Vector3D &COORDINATES)
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>RetrieveCoordinates() const
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line.h</td>
        <td>Line</td>
        <td>operator =( const Line &LINE)
</td>
        <td>staritrd, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_criterium.h</td>
        <td>LineCriterium</td>
        <td>AddCriterium( const EntryType &ENTRY_TYPE, const t_DataType &DATA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line_criterium.h</td>
        <td>LineCriterium</td>
        <td>AddCriterium( const LineType &LINE_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_criterium.h</td>
        <td>LineCriterium</td>
        <td>Filter( const util::ShPtrList< Line> &LINES, const util::FunctionInterface< Line, bool> &CRITERIUM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line_criterium.h</td>
        <td>LineCriterium</td>
        <td>LineCriterium()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_criterium.h</td>
        <td>LineCriterium</td>
        <td>Reset()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line_criterium.h</td>
        <td>LineCriterium</td>
        <td>SetMeetAllCriteria( const bool MEET_ALL_CRITERIA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_criterium.h</td>
        <td>LineCriterium</td>
        <td>operator ()( const Line &LINE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line_type_data.h</td>
        <td>LineTypeData</td>
        <td>ConsiderNewEntryType( const EntryType &ENTRY_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_type_data.h</td>
        <td>LineTypeData</td>
        <td>GetFirstEntryType() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line_type_data.h</td>
        <td>LineTypeData</td>
        <td>GetLastEntryType() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_type_data.h</td>
        <td>LineTypeData</td>
        <td>GetNumberOfEntryTypes() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line_type_data.h</td>
        <td>LineTypeData</td>
        <td>LineTypeData( const bool MULTIPLE_TIMES, const bool MULTIPLE_LINES)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_type_data.h</td>
        <td>LineTypeData</td>
        <td>LineTypeData()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line_types.h</td>
        <td>LineTypes</td>
        <td>AddLineType( const std::string &RECORD_NAME, const LineTypeData &LINE_TYPE_DATA )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_types.h</td>
        <td>LineTypes</td>
        <td>ConsiderEntryType( const LineType &LINE_TYPE, const EntryType &ENTRY_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line_types.h</td>
        <td>LineTypes</td>
        <td>GetGroupingTypes() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_types.h</td>
        <td>LineTypes</td>
        <td>GetOutOfOrderTypes() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_line_types.h</td>
        <td>LineTypes</td>
        <td>LineTypeFromPDBLine( const std::string &PDB_LINE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_line_types.h</td>
        <td></td>
        <td>GetLineTypes()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>CollectLines( const util::FunctionInterface< Line, bool> &CRITERIUM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>CollectLines( const util::FunctionInterface< Line, bool> &CRITERIUM, const char CHAIN_ID) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>Count( const LineType &LINE_TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>GetChains() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>GetHETATMLines() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>GetLines( const LineType &LINE_TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>GetStructuredChains() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>GetTypesOfLines() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>InitializeStructuredChain( const char CHAIN_ID, const storage::List< ResidueSimple> &SEQRES, const storage::List< ResidueSimple> &MISSING_RESIDUES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>Model()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>PushBack( const util::ShPtr< Line> &LINE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>Reset()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_model.h</td>
        <td>Model</td>
        <td>WriteLines( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_biomatrix.h</td>
        <td>PrinterBiomatrix</td>
        <td>PrinterBiomatrix()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_biomatrix.h</td>
        <td>PrinterBiomatrix</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_body_assignment.h</td>
        <td>PrinterBodyAssignment</td>
        <td>PrinterBodyAssignment( const util::ShPtr < util::ShPtrVector< restraint::Body> > &RESTRAINTS )
</td>
        <td>alexanns, linders, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_body_assignment.h</td>
        <td>PrinterBodyAssignment</td>
        <td>PrinterBodyAssignment()
</td>
        <td>alexanns, linders, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_body_assignment.h</td>
        <td>PrinterBodyAssignment</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns, linders, karakam, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_loop_closure.h</td>
        <td>PrinterLoopClosure</td>
        <td>PrinterLoopClosure( const double CLOSURE_THRESHOLD)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_loop_closure.h</td>
        <td>PrinterLoopClosure</td>
        <td>PrinterLoopClosure()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_loop_closure.h</td>
        <td>PrinterLoopClosure</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_membrane.h</td>
        <td>PrinterMembrane</td>
        <td>PrinterMembrane()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_membrane.h</td>
        <td>PrinterMembrane</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_quality_docking.h</td>
        <td>PrinterQualityDocking</td>
        <td>GetChainIDs() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_quality_docking.h</td>
        <td>PrinterQualityDocking</td>
        <td>GetQualityMeasures() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_quality_docking.h</td>
        <td>PrinterQualityDocking</td>
        <td>PrinterQualityDocking( const storage::Set< quality::Measure> &QUALITY_MEASURES, const std::string &CHAIN_IDS )
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_quality_docking.h</td>
        <td>PrinterQualityDocking</td>
        <td>PrinterQualityDocking()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_quality_docking.h</td>
        <td>PrinterQualityDocking</td>
        <td>SetChainIDs( const std::string &CHAIN_IDS)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_quality_docking.h</td>
        <td>PrinterQualityDocking</td>
        <td>SetQualityMeasures( const storage::Set< quality::Measure> &QUALITY_MEASURES)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_quality_docking.h</td>
        <td>PrinterQualityDocking</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_quality_membrane.h</td>
        <td>PrinterQualityMembrane</td>
        <td>PrinterQualityMembrane( const storage::Set< quality::Measure> &QUALITIES, const storage::Set< biol::EnvironmentType> &ENVIRONMENTS, const util::ShPtr< assemble::ProteinModel> &NATIVE )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_quality_membrane.h</td>
        <td>PrinterQualityMembrane</td>
        <td>PrinterQualityMembrane()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_quality_membrane.h</td>
        <td>PrinterQualityMembrane</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_quality_multimer.h</td>
        <td>PrinterQualityMultimer</td>
        <td>PrinterQualityMultimer( const storage::Set< quality::Measure> &QUALITIES, const util::ShPtr< assemble::ProteinModel> &NATIVE )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_quality_multimer.h</td>
        <td>PrinterQualityMultimer</td>
        <td>PrinterQualityMultimer()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_quality_multimer.h</td>
        <td>PrinterQualityMultimer</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_score.h</td>
        <td>PrinterScore</td>
        <td>GetTableColumnFormat()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_score.h</td>
        <td>PrinterScore</td>
        <td>PrinterScore( const util::ShPtr< score::ProteinModelScoreSum> &SP_SCORE, const storage::Set< quality::Measure> &QUALITY_MEASURES = storage::Set< quality::Measure>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_score.h</td>
        <td>PrinterScore</td>
        <td>PrinterScore()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_printer_score.h</td>
        <td>PrinterScore</td>
        <td>WriteTableToLines( const storage::Table< double> &TABLE, const bool WRITE_EMPTY_REMARK_LINE = true )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_printer_score.h</td>
        <td>PrinterScore</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>AtomSerials() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>ChangeLines()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>GetChainID() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>GetCriterium( const LineType &LINE_TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>GetICode() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>GetPDBID() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>GetResidueName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>Residue( const Residue &RESIDUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>Residue( const ResidueInterface &RESIDUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>Residue( const std::string &RESIDUENAME, const char &CHAINID )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>Residue( const std::string &RESIDUENAME, const char &CHAINID, const int &PDBID, const char &ICODE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>Residue( const std::string &RESIDUENAME, const char &CHAINID, const int &PDBID, const char &ICODE, const util::ShPtrList< Line> &LINES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>Residue()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>SetChainID( const char CHAIN_ID)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>SetICode( const char I_CODE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>SetPDBID( const int PDB_ID)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>SetResidueName( const std::string &RESIDUE_NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>operator !=( const Residue &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>operator !=( const ResidueInterface &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>operator <( const Residue &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>operator <( const ResidueInterface &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>operator ==( const Residue &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue.h</td>
        <td>Residue</td>
        <td>operator ==( const ResidueInterface &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_interface.h</td>
        <td>ResidueInterface</td>
        <td>GetIdentification() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>AtomSerials() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>GetChainID() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>GetCriterium( const LineType &LINE_TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>GetICode() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>GetPDBID() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>GetResidueName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>ResidueSimple( const ResidueSimple &RESIDUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>ResidueSimple( const std::string &RESIDUE_NAME, const char CHAIN_ID )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>ResidueSimple( const std::string &RESIDUE_NAME, const char CHAIN_ID, const int PDB_ID, const char I_CODE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>ResidueSimple()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>SetChainID( const char CHAIN_ID)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>SetICode( const char I_CODE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>SetPDBID( const int PDB_ID)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>SetResidueName( const std::string &RESIDUE_NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>operator !=( const ResidueInterface &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>operator !=( const ResidueSimple &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>operator !=( const biol::AABase &AMINO_ACID) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>operator <( const ResidueInterface &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>operator <( const ResidueSimple &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>operator ==( const ResidueInterface &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>operator ==( const ResidueSimple &RESIDUE_RHS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_residue_simple.h</td>
        <td>ResidueSimple</td>
        <td>operator ==( const biol::AABase &AMINO_ACID) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>AALocators() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>AddChainResidue( const ResidueSimple &RESIDUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>AddHetatmResidue( const ResidueSimple &RESIDUE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>FindLigand( const util::ShPtrList< Ligand> &LIGANDS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>GetChainResidues() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>GetDescription() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>GetEvidenceCode() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>GetEvidenceCodeDescriptor( const EvidenceCode &EVIDENCE_CODE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>GetLigand() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>GetName() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>Site( const std::string &NAME, const EvidenceCodeEnum &EVIDENCE_CODE, const std::string &DESCRIPTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_site.h</td>
        <td>Site</td>
        <td>Site()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>CollectLines( const util::FunctionInterface< Line, bool> &CRITERIUM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>GetConnections() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>GetLines( const LineType &LINE_TYPE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>GetTypesOfLines() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>PushBack( const util::ShPtr< Line> &LINE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>Reset()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>Tail()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>UpdateMasterRecord( const Head &HEAD) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>UpdateMasterRecord( const Model &FIRST_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pdb_tail.h</td>
        <td>Tail</td>
        <td>WriteLines( std::ostream &OSTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pthread.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>Scheduler</td>
        <td>GetNumberUnusedCPUS() const
</td>
        <td>riddeljs, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>Scheduler</td>
        <td>Join( util::ShPtr< sched::JobInterface> &SP_JOB) const
</td>
        <td>riddeljs, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>Scheduler</td>
        <td>ReleaseReservedCPUs( const size_t &NR_TO_RELEASE)
</td>
        <td>riddeljs, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>Scheduler</td>
        <td>ReserveAvailableCPUs( const size_t &MAX)
</td>
        <td>riddeljs, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>Scheduler</td>
        <td>RunJob( util::ShPtr< sched::JobInterface> &SP_JOB) const
</td>
        <td>riddeljs, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>Scheduler</td>
        <td>SubmitJob( util::ShPtr< sched::JobInterface> &SP_JOB) const
</td>
        <td>riddeljs, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>ThreadQueue</td>
        <td>EnqueueJob( util::ShPtr< sched::JobInterface> &JOB, const bool &LOCKED_THREADS = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>ThreadQueue</td>
        <td>GetNumberThreadsAvailable()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>ThreadQueue</td>
        <td>Join( const util::ShPtr< sched::JobInterface> &JOB)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>ThreadQueue</td>
        <td>ReleaseReservedCPUs( const size_t &NR_TO_RELEASE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>ThreadQueue</td>
        <td>ReserveAvailableCPUs( const size_t &MAX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_pthread_scheduler.cpp</td>
        <td>ThreadQueue</td>
        <td>RunJob( util::ShPtr< sched::JobInterface> &JOB)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_average.h</td>
        <td>Average</td>
        <td>Average( const util::ShPtrVector< SuperimposeInterface> &SUPERIMPOSE_MEASURES)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_average.h</td>
        <td>Average</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_average.h</td>
        <td>Average</td>
        <td>CalculateMeasures( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_average.h</td>
        <td>Average</td>
        <td>CalculateSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_average.h</td>
        <td>Average</td>
        <td>GetComparisonFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_average.h</td>
        <td>Average</td>
        <td>OptimalValue() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>CalculateSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>ConstMeasure( const double VALUE, const math::TransformationMatrix3D &TRANSFORMATION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>ConstMeasure()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>GetComparisonFunction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>GetDefaultTransformation()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>GetDefaultValue()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>GetTransformation() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>GetValue() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_const_measure.h</td>
        <td>ConstMeasure</td>
        <td>OptimalValue() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_dme.h</td>
        <td>DME</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_dme.h</td>
        <td>DME</td>
        <td>DME()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_dme.h</td>
        <td>DME</td>
        <td>GetComparisonFunction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_dme.h</td>
        <td>DME</td>
        <td>OptimalValue() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_dmf.h</td>
        <td>DMF</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_dmf.h</td>
        <td>DMF</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES, const double DISTANCE_CUTOFF )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_dmf.h</td>
        <td>DMF</td>
        <td>CalculateMeasureMatrixCutoff( const linal::Matrix< double> &DIFFERENCE_MATRIX, const double DISTANCE_CUTOFF )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_dmf.h</td>
        <td>DMF</td>
        <td>DMF( const storage::Set< double> &DISTANCE_CUTOFFS)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_dmf.h</td>
        <td>DMF</td>
        <td>GetComparisonFunction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_dmf.h</td>
        <td>DMF</td>
        <td>GetDistanceCutoffs() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_dmf.h</td>
        <td>DMF</td>
        <td>OptimalValue() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>CalculateGDTAndSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>CalculateSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>CreateAverageGDT( const storage::Set< double> &DISTANCE_CUTOFFS, const size_t SEED_LENGTH = GetDefaultSeedLength() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>GDT( const double &DISTANCE_CUTOFF, const size_t SEED_LENGTH = GetDefaultSeedLength() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>GetComparisonFunction() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>GetDefaultSeedLength()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>GetDistanceCutoff() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>GetSeedLength() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_gdt.h</td>
        <td>GDT</td>
        <td>OptimalValue() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>CalculateIndices( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>CalculateRanges( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>CalculateSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>ConvertRangeToIndices( const math::Range< size_t> &RANGE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>ConvertRangesToLists( const storage::List< math::Range< size_t> > &RANGES )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>ExtendRange( const math::Range< size_t> &RANGE, const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>GetComparisonFunction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>GetCutoff() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>GetDefaultRmsdCutoff()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>GetDefaultSeedLength()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>GetSeedLength() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>IsGoodRange( const math::Range< size_t> &RANGE, const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>LCS( const double RMSD_CUTOFF = GetDefaultRmsdCutoff(), const size_t SEED_LENGTH = GetDefaultSeedLength() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_lcs.h</td>
        <td>LCS</td>
        <td>OptimalValue() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>CalculateMaxSubAndSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>CalculateSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>GetComparisonFunction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>GetDefaultNumberIterations()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>GetDefaultRMSDCutoff()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>GetDefaultSeedLength()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>GetNumberIterations() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>GetRMSDCutoff() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>GetSeedLength() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>MaxSub( const double RMSD_CUTOFF = GetDefaultRMSDCutoff(), const size_t SEED_LENGTH = GetDefaultSeedLength(), const size_t NUMBER_ITERATIONS = GetDefaultNumberIterations() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_maxsub.h</td>
        <td>MaxSub</td>
        <td>OptimalValue() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_measures.h</td>
        <td>Measures</td>
        <td>GetCommandLineQualityMeasures()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_measures.h</td>
        <td>Measures</td>
        <td>GetDistanceCutoffsHA()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_measures.h</td>
        <td>Measures</td>
        <td>GetDistanceCutoffsTS()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_measures.h</td>
        <td>Measures</td>
        <td>GetFlagQualityMeasures()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_measures.h</td>
        <td></td>
        <td>GetMeasures()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>CalculateMeasure( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>CalculateSuperimposition( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::SiPtrVector< const linal::Vector3D> &REFERENCE_COORDINATES ) const
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>CovarianceToTransformationMatrix( const linal::Matrix3x3< double> &MOMENT, const linal::Vector3D &CENTER_COORDINATES, const linal::Vector3D &CENTER_REFERENCE_COORDINATES )
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>GetComparisonFunction() const
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>GetIgnoreZCoordinates() const
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>GetSuperimposeCoordinates() const
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>OptimalValue() const
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>RMSD( const bool SUPERIMPOSE_COORDINATES = true, const bool IGNORE_Z_COORDINATES = false )
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>RealSpaceRMSD( const util::SiPtrVector< const linal::Vector3D> &COORDINATES_A, const util::SiPtrVector< const linal::Vector3D> &COORDINATES_B )
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>RealSpaceRMSDPairwise( const util::SiPtrVector< const linal::Vector3D> &COORDINATES )
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>RemoveZCoordinates( const util::SiPtrVector< const linal::Vector3D> &COORDINATES ) const
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>SuperimposeCoordinates( const util::SiPtrVector< const linal::Vector3D> &COORDINATES_A, const util::SiPtrVector< const linal::Vector3D> &COORDINATES_B )
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd.h</td>
        <td>RMSD</td>
        <td>SuperimposedRMSD( const util::SiPtrVector< const linal::Vector3D> &COORDINATES_A, const util::SiPtrVector< const linal::Vector3D> &COORDINATES_B )
</td>
        <td>alexanns, staritrd, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_rmsd_preprocessor.h</td>
        <td>RMSDPreprocessor</td>
        <td>GetSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd_preprocessor.h</td>
        <td>RMSDPreprocessor</td>
        <td>RMSD( const RMSDPreprocessor &COORDINATES_B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_rmsd_preprocessor.h</td>
        <td>RMSDPreprocessor</td>
        <td>RMSDPreprocessor( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const bool &RECENTER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd_preprocessor.h</td>
        <td>RMSDPreprocessor</td>
        <td>RMSDPreprocessor()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_rmsd_preprocessor.h</td>
        <td>RMSDPreprocessor</td>
        <td>SuperimposeCoordinates( const RMSDPreprocessor &COORDINATES_B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_rmsd_preprocessor.h</td>
        <td>RMSDPreprocessor</td>
        <td>SuperimposedRMSD( const RMSDPreprocessor &COORDINATES_B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_quality_superimpose_measures.h</td>
        <td>SuperimposeMeasures</td>
        <td>GetFlagSuperimposeMeasure()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_quality_superimpose_measures.h</td>
        <td></td>
        <td>GetSuperimposeMeasures()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Boolean() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>DistributionInterface()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Double( const math::Range< double> &RANGE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Double() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Float( const math::Range< float> &RANGE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Float() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetBooleanRange()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetCharRange()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetDefaultDoubleRange()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetDefaultSeed()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetFlagRandomSeed()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetFloatRange()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetIntegerRange()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetRange() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetUnsignedIntRange()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetUnsignedLongLongRange()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>GetUnsignedLongRange()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Integer( const math::Range< int> &RANGE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Iterator( const t_IteratorType &BEGIN_ITERATOR, const t_IteratorType &END_ITERATOR, const size_t SIZE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Random( const math::Range< t_DataType> &RANGE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Random( const t_DataType &MAX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Random( const t_DataType &MIN, const t_DataType &MAX) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>RandomGaussian( const double MEAN, const double STANDARD_DEVIATION ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>RandomPoisson( const int LAMBDA) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>RandomizeSeed()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>SetGlobalSeedFromCommandlineFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>SetSeed( const uint64_t SEED)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>SetSeedFromCommandlineFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>Sign() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>SizeT( const math::Range< unsigned int> &RANGE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>SizeT( const math::Range< unsigned long long> &RANGE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_distribution_interface.h</td>
        <td>DistributionInterface</td>
        <td>SizeT( const math::Range< unsigned long> &RANGE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_histogram_1d_distribution.h</td>
        <td>Histogram1DDistribution</td>
        <td>DetermineMostLikelyCase() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_histogram_1d_distribution.h</td>
        <td>Histogram1DDistribution</td>
        <td>DetermineRandomCase( const double &LOWER_BOUNDARY, const double &BIN_SIZE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_histogram_1d_distribution.h</td>
        <td>Histogram1DDistribution</td>
        <td>DetermineRandomCase() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_histogram_1d_distribution.h</td>
        <td>Histogram1DDistribution</td>
        <td>GetDistributionSum() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_histogram_1d_distribution.h</td>
        <td>Histogram1DDistribution</td>
        <td>GetDistributionVector() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_histogram_1d_distribution.h</td>
        <td>Histogram1DDistribution</td>
        <td>Histogram1DDistribution( const math::Histogram &HISTOGRAM, const DistributionInterface &RNG = GetGlobalRandom())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_histogram_1d_distribution.h</td>
        <td>Histogram1DDistribution</td>
        <td>Histogram1DDistribution()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_histogram_1d_distribution.h</td>
        <td>Histogram1DDistribution</td>
        <td>SetProbabilityOfEvent( const size_t &EVENT, const double &PROB)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_histogram_1d_distribution.h</td>
        <td>Histogram1DDistribution</td>
        <td>operator =( const Histogram1DDistribution &HISTOGRAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_histogram_2d_distribution.h</td>
        <td>Histogram2DDistribution</td>
        <td>DetermineRandomCase2D( const double &X_BOUNDARY, const double &Y_BOUNDARY, const double &X_BINSIZE, const double &Y_BINSIZE ) const
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_histogram_2d_distribution.h</td>
        <td>Histogram2DDistribution</td>
        <td>DetermineRandomCase2D() const
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_histogram_2d_distribution.h</td>
        <td>Histogram2DDistribution</td>
        <td>GetMatrix() const
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_histogram_2d_distribution.h</td>
        <td>Histogram2DDistribution</td>
        <td>Histogram2DDistribution( const math::Histogram2D &HISTOGRAM)
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_histogram_2d_distribution.h</td>
        <td>Histogram2DDistribution</td>
        <td>Histogram2DDistribution()
</td>
        <td>rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_uniform_distribution.h</td>
        <td>UniformDistribution</td>
        <td>GetDoubleRange() const
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_uniform_distribution.h</td>
        <td>UniformDistribution</td>
        <td>GetSeed() const
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_uniform_distribution.h</td>
        <td>UniformDistribution</td>
        <td>SetSeed( const uint64_t SEED)
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_uniform_distribution.h</td>
        <td>UniformDistribution</td>
        <td>UniformDistribution( const UniformDistribution &UNIFORM_DISTRIBUTION)
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_uniform_distribution.h</td>
        <td>UniformDistribution</td>
        <td>UniformDistribution( const uint64_t SEED)
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_uniform_distribution.h</td>
        <td>UniformDistribution</td>
        <td>UniformDistribution()
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_uniform_distribution.h</td>
        <td>UniformDistribution</td>
        <td>Unsigned64BitInt() const
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_uniform_distribution.h</td>
        <td>UniformDistribution</td>
        <td>operator =( const UniformDistribution &UNIFORM_DISTRIBUTION)
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_uniform_distribution.h</td>
        <td></td>
        <td>GetGlobalRandom()
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_random_uniform_distribution.h</td>
        <td></td>
        <td>GetRandomSizeT( const std::iterator_traits< std::vector< size_t>::const_iterator>::difference_type &MAX )
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_random_uniform_distribution.h</td>
        <td></td>
        <td>RandomShuffle( t_DataType FIRST, t_DataType LAST)
</td>
        <td>mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint.h</td>
        <td></td>
        <td>GetFlagRestraintsFilePrefix()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint.h</td>
        <td></td>
        <td>GetFlagRestraintsTypes()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_aa.h</td>
        <td>AccessibilityAA</td>
        <td>AccessibilityAA( const storage::Map< EnvironmentEnum, double> &ACCESSIBILITY, const util::ShPtr< assemble::LocatorAA> &AMINO_ACID, const util::ShPtr< assemble::AAExposureInterface> &EXPOSURE_CALCULATOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_aa.h</td>
        <td>AccessibilityAA</td>
        <td>AccessibilityAA()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_aa.h</td>
        <td>AccessibilityAA</td>
        <td>GenerateAssignment( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_aa.h</td>
        <td>AccessibilityAA</td>
        <td>GenerateNeighborList( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_aa.h</td>
        <td>AccessibilityAA</td>
        <td>GetAA() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_aa.h</td>
        <td>AccessibilityAA</td>
        <td>GetAccessibilityAAs() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_aa.h</td>
        <td>AccessibilityAA</td>
        <td>GetAccessibilityByEnvironment( const AccessibilityAA::EnvironmentType &ENVIRONMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_aa.h</td>
        <td>AccessibilityAA</td>
        <td>GetEnvironmentName( const EnvironmentType &TYPE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_aa_assignment.h</td>
        <td>AccessibilityAAAssignment</td>
        <td>AccessibilityAAAssignment( const util::SiPtr< const biol::AABase> AMINO_ACID, const double EXPOSURE_VALUE, const storage::Map< AccessibilityAA::EnvironmentEnum, double> &ACCESSIBILITY )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_aa_assignment.h</td>
        <td>AccessibilityAAAssignment</td>
        <td>AccessibilityAAAssignment()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_aa_assignment.h</td>
        <td>AccessibilityAAAssignment</td>
        <td>GetAABase() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_aa_assignment.h</td>
        <td>AccessibilityAAAssignment</td>
        <td>GetAccessibility() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_aa_assignment.h</td>
        <td>AccessibilityAAAssignment</td>
        <td>GetAccessibilityByEnvironment( const AccessibilityAA::EnvironmentType &ENVIRONMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_aa_assignment.h</td>
        <td>AccessibilityAAAssignment</td>
        <td>GetExposureValue() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_profile.h</td>
        <td>AccessibilityProfile</td>
        <td>AccessibilityProfile( const storage::List< AccessibilityAA> &ACCESSIBILITIES)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_profile.h</td>
        <td>AccessibilityProfile</td>
        <td>AccessibilityProfile()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_profile.h</td>
        <td>AccessibilityProfile</td>
        <td>GenerateAssignment( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_profile.h</td>
        <td>AccessibilityProfile</td>
        <td>GetAccessibilities() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_profile_assignment.h</td>
        <td>AccessibilityProfileAssignment</td>
        <td>AccessibilityProfileAssignment( const storage::Map < util::SiPtr< const assemble::SSE>, storage::List< AccessibilityAAAssignment>, assemble::SSELessThanNoOverlap > &SSE_ASSIGNMENTS, const storage::List< AccessibilityAAAssignment> &NON_SSE_ASSIGNMENTS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_profile_assignment.h</td>
        <td>AccessibilityProfileAssignment</td>
        <td>AccessibilityProfileAssignment()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_profile_assignment.h</td>
        <td>AccessibilityProfileAssignment</td>
        <td>GetNonSSEAssignments() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_profile_assignment.h</td>
        <td>AccessibilityProfileAssignment</td>
        <td>GetNumberResiduesInSSEsWithEnvironmentType( const AccessibilityAA::EnvironmentType &ENVIRONMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_accessibility_profile_assignment.h</td>
        <td>AccessibilityProfileAssignment</td>
        <td>GetSSEAssignments() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_accessibility_profile_assignment.h</td>
        <td>AccessibilityProfileAssignment</td>
        <td>GetTotalNumberOfSSEAssignments() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_accessibility_change.h</td>
        <td>AnalyzeAccessibilityChange</td>
        <td>AnalyzeAccessibilityChange()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_accessibility_change.h</td>
        <td>AnalyzeAccessibilityChange</td>
        <td>EnsembleAsFilename( const assemble::ProteinEnsemble &ENSEMBLE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_accessibility_change.h</td>
        <td>AnalyzeAccessibilityChange</td>
        <td>EnsembleFromFilename( assemble::ProteinEnsemble &ENSEMBLE, const std::string &NAME, std::ostream &ERR_STREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_accessibility_change.h</td>
        <td>AnalyzeAccessibilityChange</td>
        <td>ExposureDataAsFilename( const storage::List< AccessibilityProfile> &DATA )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_accessibility_change.h</td>
        <td>AnalyzeAccessibilityChange</td>
        <td>ExposureDataFromFilename( storage::List< AccessibilityProfile> &PROFILES, const std::string &NAME, std::ostream &ERR_STREAM )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_accessibility_change.h</td>
        <td>AnalyzeAccessibilityChange</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_accessibility_change.h</td>
        <td>AnalyzeAccessibilityChange</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_heatmap.h</td>
        <td>AnalyzeAtomDistanceHeatmap</td>
        <td>AnalyzeAtomDistanceHeatmap()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_heatmap.h</td>
        <td>AnalyzeAtomDistanceHeatmap</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_heatmap.h</td>
        <td>AnalyzeAtomDistanceHeatmap</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_mean_sd.h</td>
        <td>AnalyzeAtomDistanceMeanSD</td>
        <td>AnalyzeAtomDistanceMeanSD()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_mean_sd.h</td>
        <td>AnalyzeAtomDistanceMeanSD</td>
        <td>GetMeanSDAnalysis( const util::ShPtrVector< AtomDistance> &DATA, const assemble::ProteinEnsemble &ENSEMBLE, const util::Format &FORMAT, const bool PRINT_ALL_MODEL_DISTANCES )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_mean_sd.h</td>
        <td>AnalyzeAtomDistanceMeanSD</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_mean_sd.h</td>
        <td>AnalyzeAtomDistanceMeanSD</td>
        <td>GetRestraintHeader( const util::ShPtrVector< AtomDistance> &DATA, const util::Format &LINE_NAME_FORMAT, const util::Format &FORMAT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_mean_sd.h</td>
        <td>AnalyzeAtomDistanceMeanSD</td>
        <td>GetRestraintInformation( const util::ShPtrVector< AtomDistance> &DATA, const util::Format &LINE_NAME_FORMAT, const util::Format &FORMAT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_mean_sd.h</td>
        <td>AnalyzeAtomDistanceMeanSD</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_pymol.h</td>
        <td>AnalyzeAtomDistancePymol</td>
        <td>AnalyzeAtomDistancePymol()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_pymol.h</td>
        <td>AnalyzeAtomDistancePymol</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_pymol.h</td>
        <td>AnalyzeAtomDistancePymol</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_score.h</td>
        <td>AnalyzeAtomDistanceScore</td>
        <td>AnalyzeAtomDistanceScore()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_score.h</td>
        <td>AnalyzeAtomDistanceScore</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_score.h</td>
        <td>AnalyzeAtomDistanceScore</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_score_heatmap.h</td>
        <td>AnalyzeAtomDistanceScoreHeatmap</td>
        <td>AnalyzeAtomDistanceScoreHeatmap()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_score_heatmap.h</td>
        <td>AnalyzeAtomDistanceScoreHeatmap</td>
        <td>GetHeatMap( const storage::Vector< math::Histogram> &SCORE_HISTOGRAMS, const storage::Vector< std::string> &TICS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_score_heatmap.h</td>
        <td>AnalyzeAtomDistanceScoreHeatmap</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_atom_distance_score_heatmap.h</td>
        <td>AnalyzeAtomDistanceScoreHeatmap</td>
        <td>GetRestraintNameTics( const util::ShPtrVector< AtomDistance> &DATA)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_atom_distance_score_heatmap.h</td>
        <td>AnalyzeAtomDistanceScoreHeatmap</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_coordinate_distance_distribution.h</td>
        <td>AnalyzeCoordinateDistanceDistribution</td>
        <td>AnalyzeCoordinateDistanceDistribution()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_coordinate_distance_distribution.h</td>
        <td>AnalyzeCoordinateDistanceDistribution</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_coordinate_distance_distribution.h</td>
        <td>AnalyzeCoordinateDistanceDistribution</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_per_residue_rmsd.h</td>
        <td>AnalyzePerResidueRMSD</td>
        <td>AnalyzePerResidueRMSD()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_per_residue_rmsd.h</td>
        <td>AnalyzePerResidueRMSD</td>
        <td>GetAtomCoordinates( const assemble::ProteinEnsemble &ENSEMBLE, const quality::SuperimposeMeasure &SUPERIMPOSE_MEASURE, const assemble::ProteinModel &TEMPLATE_MODEL )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_per_residue_rmsd.h</td>
        <td>AnalyzePerResidueRMSD</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_per_residue_rmsd.h</td>
        <td>AnalyzePerResidueRMSD</td>
        <td>ProteinModelAsString( const assemble::ProteinModel &MODEL)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_per_residue_rmsd.h</td>
        <td>AnalyzePerResidueRMSD</td>
        <td>ProteinModelFromString( assemble::ProteinModel &MODEL, const std::string &NAME, std::ostream &ERR_STREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_per_residue_rmsd.h</td>
        <td>AnalyzePerResidueRMSD</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_per_residue_rmsd_between_ensembles.h</td>
        <td>AnalyzePerResidueRMSDBetweenEnsembles</td>
        <td>AnalyzePerResidueRMSDBetweenEnsembles()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_per_residue_rmsd_between_ensembles.h</td>
        <td>AnalyzePerResidueRMSDBetweenEnsembles</td>
        <td>GetOutFilePostfix() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_per_residue_rmsd_between_ensembles.h</td>
        <td>AnalyzePerResidueRMSDBetweenEnsembles</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>AnalyzeSas()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetC1Max() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetC1Min() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetC1StepSize() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetC2Max() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetC2Min() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetC2StepSize() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetComputedDataFileName() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetDeuteriumExchangeParameter() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetExcludedVolumeParameter() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetExperimentalDataFileName() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetHydrationShellParameter() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetMaximumDimension() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetOutFilePostfix() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetSasaDataFileName() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>GetScoreTypeName() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_analyze_sas.h</td>
        <td>AnalyzeSas</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const GroupCollection< t_GroupIdentifier, t_GroupMember, t_GroupIdentifierCompare> &COLLECTION)
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const util::ShPtr< t_Restraint> &RESTRAINT)
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const util::ShPtr< t_Restraint> &RESTRAINT, const GroupCollection< t_GroupIdentifier, t_GroupMember, t_GroupIdentifierCompare> &GROUP_COLLECTION )
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment()
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_assignment.h</td>
        <td>Assignment</td>
        <td>GetGroupCollection() const
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_assignment.h</td>
        <td>Assignment</td>
        <td>SetGroupCollection( const GroupCollection< t_GroupIdentifier, t_GroupMember, t_GroupIdentifierCompare> &GROUP_COLLECTION )
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_assignment.h</td>
        <td>Assignment</td>
        <td>SetRestraint( const util::ShPtr< t_Restraint> &RESTRAINT)
</td>
        <td>alexanns, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>AtomDistance( const DataPairwise &DATA_PAIR, const util::ShPtr< Distance> &DISTANCE, const double &CONFIDENCE = 1.0 )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>AtomDistance( const assemble::LocatorAtom &LOCATOR_A, const assemble::LocatorAtom &LOCATOR_B, const util::ShPtr< Distance> &DISTANCE, const double &CONFIDENCE = 1.0 )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>AtomDistance( const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR_A, const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR_B, const util::ShPtr< Distance> &DISTANCE, const double &CONFIDENCE = 1.0 )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>AtomDistance()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>GenerateAssignment( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>GetConfidence() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>GetData() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>GetDistance() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>GetIdentification() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>GetLowerBound() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>GetLowerError() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>GetUpperBound() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>GetUpperError() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance.h</td>
        <td>AtomDistance</td>
        <td>IsDefined() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance_assignment.h</td>
        <td>AtomDistanceAssignment</td>
        <td>AtomDistanceAssignment( const biol::Atom &ATOM_A, const biol::Atom &ATOM_B, const util::ShPtr< Distance> &DISTANCE )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance_assignment.h</td>
        <td>AtomDistanceAssignment</td>
        <td>AtomDistanceAssignment()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance_assignment.h</td>
        <td>AtomDistanceAssignment</td>
        <td>CalculateAtomDistance() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance_assignment.h</td>
        <td>AtomDistanceAssignment</td>
        <td>GetAtomA() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance_assignment.h</td>
        <td>AtomDistanceAssignment</td>
        <td>GetAtomB() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance_assignment.h</td>
        <td>AtomDistanceAssignment</td>
        <td>GetDistance() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance_assignment.h</td>
        <td>AtomDistanceAssignment</td>
        <td>GetDistanceObject() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_atom_distance_assignment.h</td>
        <td>AtomDistanceAssignment</td>
        <td>GetLowerBound() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_atom_distance_assignment.h</td>
        <td>AtomDistanceAssignment</td>
        <td>GetUpperBound() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_body.h</td>
        <td>Body</td>
        <td>Body( const util::ShPtr< util::ShPtrVector< assemble::SSEGeometryInterface> > &BODIES, const util::ShPtr< util::BinaryFunctionInterface< assemble::SSEGeometryInterface, assemble::SSE, bool> > &DETERMINE_OCCUPANCY )
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_body.h</td>
        <td>Body</td>
        <td>Body()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_body.h</td>
        <td>Body</td>
        <td>GenerateAssignment( const util::SiPtrVector< const assemble::SSE> &SSES) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_body.h</td>
        <td>Body</td>
        <td>GetBody() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_body.h</td>
        <td>Body</td>
        <td>GetOccupiedBody( const assemble::SSE &SSE) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_body.h</td>
        <td>Body</td>
        <td>GetUnoccupied( const util::SiPtrVector< const assemble::SSE> &SSES) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_body.h</td>
        <td>Body</td>
        <td>SetBody( const util::ShPtr< util::ShPtrVector< assemble::SSEGeometryInterface> > &BODIES)
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_cone_model.h</td>
        <td>ConeModel</td>
        <td>ConeModel()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_cone_model.h</td>
        <td>ConeModel</td>
        <td>GetSpinLabelResidue( const assemble::ProteinModel &MODEL )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_cone_model.h</td>
        <td>ConeModel</td>
        <td>GetUnpairedElectronCoordinates( const biol::AABase &RESIDUE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_cone_model.h</td>
        <td>ConeModel</td>
        <td>SLCBSLMaxAngle( const assemble::ProteinEnsemble &ENSEMBLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_cone_model.h</td>
        <td>ConeModel</td>
        <td>SLeffectiveCBCAAngle( const assemble::ProteinEnsemble &ENSEMBLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_cone_model.h</td>
        <td>ConeModel</td>
        <td>SLeffectiveCBDistance( const assemble::ProteinEnsemble &ENSEMBLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_contact_data.h</td>
        <td>ContactData</td>
        <td>ContactData()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_contact_data.h</td>
        <td>ContactData</td>
        <td>GetAtomDistanceRestraints() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_contact_data.h</td>
        <td>ContactData</td>
        <td>GetDefaultExtension() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_contact_data.h</td>
        <td>ContactData</td>
        <td>GetMutateTree() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_contact_data.h</td>
        <td>ContactData</td>
        <td>InitializeScores()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_contact_data.h</td>
        <td>ContactData</td>
        <td>MergeAndModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_contact_data.h</td>
        <td>ContactData</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_contact_data.h</td>
        <td>ContactData</td>
        <td>ReadRestraints( std::istream &ISTREAM)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_contains_body_origin.h</td>
        <td>ContainsBodyOrigin</td>
        <td>ContainsBodyOrigin()
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_contains_body_origin.h</td>
        <td>ContainsBodyOrigin</td>
        <td>operator ()( const assemble::SSEGeometryInterface &BODY, const assemble::SSE &SSE) const
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>CalculateSequenceSeparation( const char CHAIN_ID_A, const int SEQ_ID_A, const char CHAIN_ID_B, const int SEQ_ID_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>DataPairwise( const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR_A, const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>DataPairwise()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>EuclidianDistance( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>EuclidianDistance( const assemble::ProteinModel &MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>First() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>IsSet() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>ReadIdentification( std::istream &ISTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>ReadIdentification( std::istream &ISTREAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>Second() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>SequenceSeparation() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_pairwise.h</td>
        <td>DataPairwise</td>
        <td>Set( const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &ATOM_A, const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &ATOM_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_pairwise.h</td>
        <td></td>
        <td>ShowDistancesInPymol( std::ostream &OSTREAM, const storage::List< storage::Triplet< DataPairwise, double, linal::Vector3D> > &DISTANCES )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_pairwise.h</td>
        <td></td>
        <td>operator <( const DataPairwise &LHS, const DataPairwise &RHS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>Begin()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>Begin() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>DataSetPairwise( t_Iterator FIRST, t_Iterator LAST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>DataSetPairwise()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>End()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>End() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>Erase( const DataPairwise &DATA_PAIR)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>Erase( t_Iterator ITR)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>Find( const DataPairwise &KEY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>Find( const DataPairwise &KEY) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>GetCompleteDataSet( const util::ShPtrVector< biol::AABase> &SEQUENCE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>GetDataPoints() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>GetIntersection( const storage::List< DataSetPairwise> &DATA_SETS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>GetSize() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>GetUniqueDataPoints() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>Insert( const DataPairwise &DATA )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>Insert( const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR_A, const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>InsertElements( t_Iterator ITR_A, t_Iterator ITR_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>IsEmpty() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>ReverseBegin()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>ReverseBegin() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>ReverseEnd()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td>DataSetPairwise</td>
        <td>ReverseEnd() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td></td>
        <td>operator *( const double &SCALAR, const math::MutateResult< DataSetPairwise> &MUTATE_RESULT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td></td>
        <td>operator *( const math::MutateResult< DataSetPairwise> &MUTATE_RESULT, const double &SCALAR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_data_set_pairwise.h</td>
        <td></td>
        <td>operator +( const math::MutateResult< DataSetPairwise> &LHS, const math::MutateResult< DataSetPairwise> &RHS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_distance.h</td>
        <td>Distance</td>
        <td>Distance( const double &DISTANCE, const double &UPPER_BOUND, const double &LOWER_BOUND)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_distance.h</td>
        <td>Distance</td>
        <td>Distance()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_distance.h</td>
        <td>Distance</td>
        <td>GetDistance() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_distance.h</td>
        <td>Distance</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_distance.h</td>
        <td>Distance</td>
        <td>GetLowerError() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_distance.h</td>
        <td>Distance</td>
        <td>GetUpperError() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_distance.h</td>
        <td>Distance</td>
        <td>IsDefined() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_distance.h</td>
        <td>Distance</td>
        <td>LowerBound() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_distance.h</td>
        <td>Distance</td>
        <td>UpperBound() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_accessibility_data.h</td>
        <td>EPRAccessibilityData</td>
        <td>EPRAccessibilityData( const HandlerAccessibilityAA &HANDLER = GetDefaultHandler() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_accessibility_data.h</td>
        <td>EPRAccessibilityData</td>
        <td>GetDefaultExtension() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_accessibility_data.h</td>
        <td>EPRAccessibilityData</td>
        <td>GetDefaultHandler()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_accessibility_data.h</td>
        <td>EPRAccessibilityData</td>
        <td>GetMutateTree() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_accessibility_data.h</td>
        <td>EPRAccessibilityData</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_accessibility_data.h</td>
        <td>EPRAccessibilityData</td>
        <td>InitializeScores()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_accessibility_data.h</td>
        <td>EPRAccessibilityData</td>
        <td>MergeAndModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_accessibility_data.h</td>
        <td>EPRAccessibilityData</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_decay.h</td>
        <td>EPRDecay</td>
        <td>AddMeasurement( double TIME, double DECAY)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_decay.h</td>
        <td>EPRDecay</td>
        <td>EPRDecay( const char CHAIN_1, int SEQ_1, char CHAIN_2, int SEQ_2)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_decay.h</td>
        <td>EPRDecay</td>
        <td>EPRDecay( const std::string &MEASUREMENT_FILE_PATH)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_decay.h</td>
        <td>EPRDecay</td>
        <td>EPRDecay()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_decay.h</td>
        <td>EPRDecay</td>
        <td>GetMeasurements() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_decay.h</td>
        <td>EPRDecay</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_decay.h</td>
        <td>EPRDecay</td>
        <td>GetSpinLabelingSites() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_decay.h</td>
        <td>EPRDecay</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_decay_simulation.h</td>
        <td>EPRDecaySimulation</td>
        <td>CalculateDecay( double DISTANCE, double TIME)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_decay_simulation.h</td>
        <td>EPRDecaySimulation</td>
        <td>EPRDecaySimulation( const storage::Vector< SLPair> &SL_PAIRS)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_decay_simulation.h</td>
        <td>EPRDecaySimulation</td>
        <td>EPRDecaySimulation()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_decay_simulation.h</td>
        <td>EPRDecaySimulation</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>EPRDistanceData()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>GetAtomDistanceRestraints() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>GetDefaultExtension()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>GetDefaultHandler()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>GetMutateTree() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>GetScores() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>InitializeScores()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>MergeAndModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_epr_distance_data.h</td>
        <td>EPRDistanceData</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_group.h</td>
        <td>Group</td>
        <td>Group( const Group< t_DataType> &GROUP)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_group.h</td>
        <td>Group</td>
        <td>Group( const Group< t_DataType> &GROUP, const size_t SIZE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_group.h</td>
        <td>Group</td>
        <td>Group( const Group< t_DataType> &GROUP_A, const Group< t_DataType> &GROUP_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_group.h</td>
        <td>Group</td>
        <td>Group( const size_t SIZE = 0, const util::SiPtr< const t_DataType> &DATA = util::SiPtr< const t_DataType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_group.h</td>
        <td>Group</td>
        <td>Group( const size_t SIZE, const Group< t_DataType> &GROUP)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_group.h</td>
        <td>Group</td>
        <td>Group( const size_t SIZE, t_DataType *const DATA)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_group.h</td>
        <td>Group</td>
        <td>Group( const t_Iterator &FIRST, const t_Iterator &LAST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_group.h</td>
        <td>Group</td>
        <td>Group( const util::SiPtrList< const t_DataType> &LIST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_group_collection.h</td>
        <td>GroupCollection</td>
        <td>CollectAllGroupMembers() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_group_collection.h</td>
        <td>GroupCollection</td>
        <td>GetOverallNthGroupMember( size_t NTH_GROUP_MEMBER) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_group_collection.h</td>
        <td>GroupCollection</td>
        <td>GroupCollection( const t_GroupIdentifier &GROUP_IDENTIFIER, const Group< t_GroupMember> &GROUP )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_group_collection.h</td>
        <td>GroupCollection</td>
        <td>GroupCollection()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_group_collection.h</td>
        <td>GroupCollection</td>
        <td>Insert( const t_GroupIdentifier &GROUP_IDENTIFIER, const Group< t_GroupMember> &GROUP)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_group_collection.h</td>
        <td>GroupCollection</td>
        <td>SingleGroupDepth( const const_iterator ITERATOR ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_group_collection.h</td>
        <td>GroupCollection</td>
        <td>TotalDepth() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_accessibility_aa.h</td>
        <td>HandlerAccessibilityAA</td>
        <td>HandlerAccessibilityAA( const util::ShPtr< assemble::AAExposureInterface> &EXPOSURE_CALCULATOR)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_accessibility_aa.h</td>
        <td>HandlerAccessibilityAA</td>
        <td>HandlerAccessibilityAA()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_accessibility_aa.h</td>
        <td>HandlerAccessibilityAA</td>
        <td>ReadRestraints( std::istream &ISTREAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_accessibility_aa.h</td>
        <td>HandlerAccessibilityAA</td>
        <td>WriteRestraints( std::ostream &OSTREAM, const AccessibilityProfile &PROFILE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_atom_distance_assigned.h</td>
        <td>HandlerAtomDistanceAssigned</td>
        <td>CreateRestraints( const assemble::ProteinEnsemble &ENSEMBLE, const DataSetPairwise &DATA_PAIRS )
</td>
        <td>alexanns, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_atom_distance_assigned.h</td>
        <td>HandlerAtomDistanceAssigned</td>
        <td>GetFileHeader()
</td>
        <td>alexanns, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_atom_distance_assigned.h</td>
        <td>HandlerAtomDistanceAssigned</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_atom_distance_assigned.h</td>
        <td>HandlerAtomDistanceAssigned</td>
        <td>HandlerAtomDistanceAssigned( const std::string &DEFAULT_EXTENSION = Ó, const std::string &DEFAULT_FORMAT = Ó, const double &LOWER_BOUND = 0.0, const double &UPPER_BOUND = 10.0, const double &DISTANCE = 8.0 )
</td>
        <td>alexanns, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_atom_distance_assigned.h</td>
        <td>HandlerAtomDistanceAssigned</td>
        <td>ReadRestraints( std::istream &ISTREAM) const
</td>
        <td>alexanns, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_atom_distance_assigned.h</td>
        <td>HandlerAtomDistanceAssigned</td>
        <td>WriteDistanceRestraintsRosettaFormat( std::ostream &OSTREAM, const util::ShPtrVector< AtomDistance> &RESTRAINT_LIST )
</td>
        <td>alexanns, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_atom_distance_assigned.h</td>
        <td>HandlerAtomDistanceAssigned</td>
        <td>WriteRestraints( std::ostream &OSTREAM, const storage::Vector < storage::Pair < storage::VectorND< 2, storage::Triplet< char, int, biol::Atom> >, storage::VectorND< 3, double> > > &RESTRAINT_LIST ) const
</td>
        <td>alexanns, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_atom_distance_assigned.h</td>
        <td>HandlerAtomDistanceAssigned</td>
        <td>WriteRestraints( std::ostream &OSTREAM, const util::ShPtrVector< AtomDistance> &RESTRAINT_LIST, const bool &INCLUDE_ATOM_TYPE = true, const bool &INCLUDE_AA_TYPE = false )
</td>
        <td>alexanns, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_base.h</td>
        <td>HandlerBase</td>
        <td>HandlerBase( const std::string &DEFAULT_EXT = Ó)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_base.h</td>
        <td>HandlerBase</td>
        <td>ReadRestraintsFromFile() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_body.h</td>
        <td>HandlerBody</td>
        <td>CreateRestraintsBody( std::istream &ISTREAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_body.h</td>
        <td>HandlerBody</td>
        <td>GenerateDensityRods( std::istream &ISTREAM) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_body.h</td>
        <td>HandlerBody</td>
        <td>HandlerBody( const util::ShPtr< util::BinaryFunctionInterface< assemble::SSEGeometryInterface, assemble::SSE, bool> > &OCCUPANCY )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_body.h</td>
        <td>HandlerBody</td>
        <td>HandlerBody()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_data_set_pairwise_identifiers.h</td>
        <td>HandlerDataSetPairwiseIdentifiers</td>
        <td>GetDataSetPairwise() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_data_set_pairwise_identifiers.h</td>
        <td>HandlerDataSetPairwiseIdentifiers</td>
        <td>GetScore() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_data_set_pairwise_identifiers.h</td>
        <td>HandlerDataSetPairwiseIdentifiers</td>
        <td>HandlerDataSetPairwiseIdentifiers( const double SCORE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_data_set_pairwise_identifiers.h</td>
        <td>HandlerDataSetPairwiseIdentifiers</td>
        <td>HandlerDataSetPairwiseIdentifiers()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_data_set_pairwise_identifiers.h</td>
        <td>HandlerDataSetPairwiseIdentifiers</td>
        <td>ReadDataSetPairwise( std::istream &ISTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_data_set_pairwise_identifiers.h</td>
        <td>HandlerDataSetPairwiseIdentifiers</td>
        <td>WriteDataSetPairwise( std::ostream &OSTREAM, const DataSetPairwise &DATA_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_epr_decay.h</td>
        <td>HandlerEPRDecay</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_epr_decay.h</td>
        <td>HandlerEPRDecay</td>
        <td>HandlerEPRDecay()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_epr_decay.h</td>
        <td>HandlerEPRDecay</td>
        <td>ReadRestraints( std::istream &ISTREAM) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_interface.h</td>
        <td>HandlerInterface</td>
        <td>Exists() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_interface.h</td>
        <td>HandlerInterface</td>
        <td>GetFilename() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_interface.h</td>
        <td>HandlerInterface</td>
        <td>GetFilenameExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_handler_interface.h</td>
        <td>HandlerInterface</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_handler_interface.h</td>
        <td>HandlerInterface</td>
        <td>HandlerInterface( const std::string &DEFAULT_EXT = Ó)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_interface.h</td>
        <td>Interface</td>
        <td>InitializeMutates()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_interface.h</td>
        <td>Interface</td>
        <td>InitializeScores()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_interface.h</td>
        <td>Interface</td>
        <td>ModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_interface.h</td>
        <td>Interface</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>GetAAType() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>GetAtomType() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>GetChainID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>GetSeqID() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>Locate( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>LocateAtom( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>LocateAtomCopy( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>LocatorCoordinatesFirstSideChainAtom( const char CHAIN_ID, const int SEQ_ID, const biol::AAType &AA_TYPE, const bool USE_PDB_ID = false)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>LocatorCoordinatesFirstSideChainAtom( const char CHAIN_ID, const int SEQ_ID, const biol::AtomType &ATOM_TYPE, const biol::AAType &AA_TYPE, const bool USE_PDB_ID = false )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>LocatorCoordinatesFirstSideChainAtom( const char CHAIN_ID, const int SEQ_ID, const biol::AtomType &ATOM_TYPE, const bool USE_PDB_ID = false)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>LocatorCoordinatesFirstSideChainAtom( const char CHAIN_ID, const int SEQ_ID, const bool USE_PDB_ID = false)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>LocatorCoordinatesFirstSideChainAtom()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_first_side_chain_atom.h</td>
        <td>LocatorCoordinatesFirstSideChainAtom</td>
        <td>ReadIdentification( std::istream &ISTREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>GetAAType() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>GetAtomType() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>GetAtomTypeFromString( const biol::AAType &AA_TYPE = biol::GetAATypes().e_Undefined) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>GetAtomTypeString() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>GetChainID() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>GetIdentification() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>GetSeqID() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>Locate( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>LocateAtomCopy( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>LocatorCoordinatesHydrogen( const char CHAIN_ID, const int SEQ_ID, const std::string &ATOM_TYPE)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>LocatorCoordinatesHydrogen()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_locator_coordinates_hydrogen.h</td>
        <td>LocatorCoordinatesHydrogen</td>
        <td>ReadIdentification( std::istream &ISTREAM)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_add.h</td>
        <td>MutateDataSetPairwiseAdd</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_add.h</td>
        <td>MutateDataSetPairwiseAdd</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_add.h</td>
        <td>MutateDataSetPairwiseAdd</td>
        <td>MutateDataSetPairwiseAdd( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_add.h</td>
        <td>MutateDataSetPairwiseAdd</td>
        <td>MutateDataSetPairwiseAdd( const util::ShPtr< DataSetPairwise> &POOL_DATA_SET, const size_t MIN, const size_t MAX, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_add.h</td>
        <td>MutateDataSetPairwiseAdd</td>
        <td>MutateDataSetPairwiseAdd( const util::ShPtr< DataSetPairwise> &POOL_DATA_SET, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_add.h</td>
        <td>MutateDataSetPairwiseAdd</td>
        <td>operator ()( const DataSetPairwise &DATA_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_aa_type.h</td>
        <td>MutateDataSetPairwiseFilterAAType</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_aa_type.h</td>
        <td>MutateDataSetPairwiseFilterAAType</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_aa_type.h</td>
        <td>MutateDataSetPairwiseFilterAAType</td>
        <td>MutateDataSetPairwiseFilterAAType( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_aa_type.h</td>
        <td>MutateDataSetPairwiseFilterAAType</td>
        <td>MutateDataSetPairwiseFilterAAType( const storage::Set< biol::AAType> AA_TYPES, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_aa_type.h</td>
        <td>MutateDataSetPairwiseFilterAAType</td>
        <td>operator ()( const DataSetPairwise &SEQUENCE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_coordinate_exclusion.h</td>
        <td>MutateDataSetPairwiseFilterCoordinateExclusion</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_coordinate_exclusion.h</td>
        <td>MutateDataSetPairwiseFilterCoordinateExclusion</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_coordinate_exclusion.h</td>
        <td>MutateDataSetPairwiseFilterCoordinateExclusion</td>
        <td>MutateDataSetPairwiseFilterCoordinateExclusion( const double &EXCLUSION_RADIUS, std::istream &READ, const size_t X_COORD_COLUMN, const size_t Y_COORD_COLUMN, const size_t Z_COORD_COLUMN, const storage::Set < util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, assemble::LocatorAtomCoordinatesInterface::PtrLessThan > &ALL_POSSIBLE_DATA_POINTS, const assemble::ProteinEnsemble &ENSEMBLE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_coordinate_exclusion.h</td>
        <td>MutateDataSetPairwiseFilterCoordinateExclusion</td>
        <td>MutateDataSetPairwiseFilterCoordinateExclusion( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_coordinate_exclusion.h</td>
        <td>MutateDataSetPairwiseFilterCoordinateExclusion</td>
        <td>operator ()( const DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_euclidian_distance.h</td>
        <td>MutateDataSetPairwiseFilterEuclidianDistance</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_euclidian_distance.h</td>
        <td>MutateDataSetPairwiseFilterEuclidianDistance</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_euclidian_distance.h</td>
        <td>MutateDataSetPairwiseFilterEuclidianDistance</td>
        <td>MutateDataSetPairwiseFilterEuclidianDistance( const math::Range< double> &RANGE, const util::ShPtr< assemble::ProteinEnsemble> &ENSEMBLE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_euclidian_distance.h</td>
        <td>MutateDataSetPairwiseFilterEuclidianDistance</td>
        <td>MutateDataSetPairwiseFilterEuclidianDistance( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_euclidian_distance.h</td>
        <td>MutateDataSetPairwiseFilterEuclidianDistance</td>
        <td>operator ()( const DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_exposure.h</td>
        <td>MutateDataSetPairwiseFilterExposure</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_exposure.h</td>
        <td>MutateDataSetPairwiseFilterExposure</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_exposure.h</td>
        <td>MutateDataSetPairwiseFilterExposure</td>
        <td>MutateDataSetPairwiseFilterExposure( const double &EXPOSURE_CUTOFF, const assemble::ProteinEnsemble &ENSEMBLE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_exposure.h</td>
        <td>MutateDataSetPairwiseFilterExposure</td>
        <td>MutateDataSetPairwiseFilterExposure( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_exposure.h</td>
        <td>MutateDataSetPairwiseFilterExposure</td>
        <td>operator ()( const DataSetPairwise &DATA_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_sse_size.h</td>
        <td>MutateDataSetPairwiseFilterSSESize</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_sse_size.h</td>
        <td>MutateDataSetPairwiseFilterSSESize</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_sse_size.h</td>
        <td>MutateDataSetPairwiseFilterSSESize</td>
        <td>MutateDataSetPairwiseFilterSSESize( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_sse_size.h</td>
        <td>MutateDataSetPairwiseFilterSSESize</td>
        <td>MutateDataSetPairwiseFilterSSESize( const util::ShPtr< assemble::SSEPool> &SSE_POOL, const storage::Map< biol::SSType, size_t> &MIN_SSE_LENGTHS, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_sse_size.h</td>
        <td>MutateDataSetPairwiseFilterSSESize</td>
        <td>operator ()( const DataSetPairwise &DATA_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_triangulation.h</td>
        <td>MutateDataSetPairwiseFilterTriangulation</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_triangulation.h</td>
        <td>MutateDataSetPairwiseFilterTriangulation</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_triangulation.h</td>
        <td>MutateDataSetPairwiseFilterTriangulation</td>
        <td>MutateDataSetPairwiseFilterTriangulation( const double &RADIUS_CUTOFF, const util::ShPtr< assemble::ProteinEnsemble> &ENSEMBLE, const storage::List< DataPairwise> &SORTED_DATA, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_triangulation.h</td>
        <td>MutateDataSetPairwiseFilterTriangulation</td>
        <td>MutateDataSetPairwiseFilterTriangulation( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_filter_triangulation.h</td>
        <td>MutateDataSetPairwiseFilterTriangulation</td>
        <td>operator ()( const DataSetPairwise &DATA_SET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_remove.h</td>
        <td>MutateDataSetPairwiseRemove</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_remove.h</td>
        <td>MutateDataSetPairwiseRemove</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_remove.h</td>
        <td>MutateDataSetPairwiseRemove</td>
        <td>MutateDataSetPairwiseRemove( const size_t MIN, const size_t MAX, const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_data_set_pairwise_remove.h</td>
        <td>MutateDataSetPairwiseRemove</td>
        <td>MutateDataSetPairwiseRemove( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_data_set_pairwise_remove.h</td>
        <td>MutateDataSetPairwiseRemove</td>
        <td>operator ()( const DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_transformation_matrix_3d_null.h</td>
        <td>MutateTransformationMatrix3DNull</td>
        <td>MutateTransformationMatrix3DNull()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_transformation_matrix_3d_null.h</td>
        <td>MutateTransformationMatrix3DNull</td>
        <td>operator ()( const math::TransformationMatrix3D &MATRIX ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_transformation_matrix_3d_rotate.h</td>
        <td>MutateTransformationMatrix3DRotate</td>
        <td>MutateTransformationMatrix3DRotate( const coord::Axis &AXIS, const double MAX_ROTATION, const double MIN_ROTATION)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_mutate_transformation_matrix_3d_rotate.h</td>
        <td>MutateTransformationMatrix3DRotate</td>
        <td>MutateTransformationMatrix3DRotate()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_mutate_transformation_matrix_3d_rotate.h</td>
        <td>MutateTransformationMatrix3DRotate</td>
        <td>operator ()( const math::TransformationMatrix3D &MATRIX ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>GetAtomDistanceRestraints() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>GetDefaultExtension() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>GetDefaultHandler()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>GetMutateTree() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>InitializeMutates()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>InitializeScores()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>MergeAndModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>ModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>NOEData( const HandlerBase< util::ShPtrVector< AtomDistance> > &HANDLER)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>NOEData()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_noe_data.h</td>
        <td>NOEData</td>
        <td>ReadRestraints( std::istream &ISTREAM)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_piesa.h</td>
        <td>Piesa</td>
        <td>Create( const assemble::SSE &SSE, const linal::Vector3D &B0 = linal::Vector3D( 0.0, 0.0, 1.0) )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_piesa.h</td>
        <td>Piesa</td>
        <td>GetCSTensor( const biol::AAType &AA_TYPE)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_piesa.h</td>
        <td>Piesa</td>
        <td>Piesa()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>GetDefaultExtension() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>GetDensityData() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>GetMutateTree() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>GetSerializer() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>InitializeScores()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>MergeAndModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>ModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>PofrData()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pofr_data.h</td>
        <td>PofrData</td>
        <td>ReadRestraints( std::istream &ISTREAM)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>GetAtomDistanceRestraints() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>GetDefaultExtension() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>GetDefaultHandler()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>GetMutateTree() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>InitializeScores()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>MergeAndModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>PREData( const HandlerBase< util::ShPtrVector< AtomDistance> > &HANDLER)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_pre_data.h</td>
        <td>PREData</td>
        <td>PREData()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc.h</td>
        <td>RDC</td>
        <td>AdjustSigns()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc.h</td>
        <td>RDC</td>
        <td>CalculateValue( const linal::Vector3D &COORDINATES_A, const linal::Vector3D &COORDINATES_B, const linal::Matrix3x3< double> &TENSOR )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc.h</td>
        <td>RDC</td>
        <td>GenerateAssignment( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc.h</td>
        <td>RDC</td>
        <td>GetData() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc.h</td>
        <td>RDC</td>
        <td>NormalizetoNH()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc.h</td>
        <td>RDC</td>
        <td>PushBack( const assemble::LocatorAtomCoordinatesInterface &LOCATOR_A, const assemble::LocatorAtomCoordinatesInterface &LOCATOR_B, const double INTERNUCLEAR_DISTANCE, const double VALUE )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc.h</td>
        <td>RDC</td>
        <td>RDC()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc.h</td>
        <td>RDC</td>
        <td>Shuffle()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc_assignment.h</td>
        <td>RDCAssignment</td>
        <td>GetData() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc_assignment.h</td>
        <td>RDCAssignment</td>
        <td>PushBack( const linal::Vector3D &FIRST_COORD, const linal::Vector3D &SECOND_COORD, const double VALUE )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc_assignment.h</td>
        <td>RDCAssignment</td>
        <td>RDCAssignment()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>GetDefaultExtension() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>GetDefaultHandler()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>GetMutateTree() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>GetRDC() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>InitializeScores()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>MergeAndModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>RDCData( const HandlerBase< RDC> &HANDLER)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_rdc_data.h</td>
        <td>RDCData</td>
        <td>RDCData()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>AddErrors( const SasScatteringData &SIMULATED_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>CalculatePofRExcessIntegralScore( const SasExperimentalAndCalculatedDensity &SAS_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>CalculatePofRIntegralScore( const SasExperimentalAndCalculatedDensity &SAS_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>CalculatePofROscillationScore( const SasDensityData &DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>CalculateScalingWeight( const SasExperimentalAndCalculatedData &SAXS_DATA, const bool &USE_ERRORS)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>CalculateStovgaardScalingWeight( const SasExperimentalAndCalculatedData &SAXS_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>ComputeCourseIntegral( const SasDensityData &DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>ComputeDmax( const SasDensityData &EXPERIMENTAL_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>ComputeError( const double &Q, const double &INTENSITY)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>ComputeQmax( const SasScatteringData &EXPERIMENTAL_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>ConvertDensityDataToList( const SasDensityData &POFR_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>ConvertIntensityDataToList( const SasScatteringData &SAXS_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>Derivative( const SasScatteringData &EXPERIMENTAL_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>FindDensitymax( const SasDensityData &EXPERIMENTAL_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>FindxDensitymax( const SasDensityData &EXPERIMENTAL_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>Log10( const SasScatteringData &EXPERIMENTAL_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>LogtoAbsolute( const SasScatteringData &DATA_OBJECT)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>MaxIntensity( const SasScatteringData &SAXS_DATA_OBJECT)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>MinIntensity( const SasScatteringData &SAXS_DATA_OBJECT)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>NormalizeData( const SasScatteringData &SAXS_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>PofrDerivative( const SasDensityData &DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>ScaleData( const SasScatteringData &EXPERIMENTAL_DATA, const double &SCALING_FACTOR )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>ScaleDensityData( const SasDensityData &EXPERIMENTAL_DATA, const double &SCALING_FACTOR)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>SetDebyeImplementation( const bool &APPROXIMATE_LOOPS, const bool &APPROXIMATE_SIDE_CHAINS, const double &C1, const double &C2, const bool &USE_CPU, const bool &USE_SANS, const double &DEUTERIUM_EXCHANGE_PARAMETER )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>SetErrors( const SasScatteringData &SIMULATED_DATA, const double &ERROR_VALUE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>ShiftDensity( const SasDensityData &CALCULATED_DATA, const double &SHIFT)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_analysis.h</td>
        <td>SasAnalysis</td>
        <td>SlideData( const SasScatteringData &SAXS_DATA_OBJECT, const double &MIN_VALUE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_data_parameters.h</td>
        <td>SasDataParameters</td>
        <td>GetDeuteriumExchangeRate() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_data_parameters.h</td>
        <td>SasDataParameters</td>
        <td>GetExcludedVolume() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_data_parameters.h</td>
        <td>SasDataParameters</td>
        <td>GetHydrationShell() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_data_parameters.h</td>
        <td>SasDataParameters</td>
        <td>GetQValue() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_data_parameters.h</td>
        <td>SasDataParameters</td>
        <td>GetSansImplementation() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_data_parameters.h</td>
        <td>SasDataParameters</td>
        <td>GetSasaValue() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_data_parameters.h</td>
        <td>SasDataParameters</td>
        <td>SasDataParameters( const bool &USE_SANS, const double &Q_VALUE, const double &SASA_VALUE, const double &EXCLUDED_VOLUME, const double &HYDRATION_SHELL, const double &DEUTERIUM_EXCHANGE_RATE )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_data_parameters.h</td>
        <td>SasDataParameters</td>
        <td>SasDataParameters( const double &Q_VALUE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_data_parameters.h</td>
        <td>SasDataParameters</td>
        <td>SasDataParameters()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_debye.h</td>
        <td>SasDebye</td>
        <td>GetAtomGroups()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_debye.h</td>
        <td>SasDebye</td>
        <td>GetAtomsAndFormFactors( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_debye.h</td>
        <td>SasDebye</td>
        <td>GetCompleteAllAtoms() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_debye.h</td>
        <td>SasDebye</td>
        <td>GetCoordinates()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_debye.h</td>
        <td>SasDebye</td>
        <td>GetSASAPoint()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_debye.h</td>
        <td>SasDebye</td>
        <td>SasDebye( const bool LOOPS = false, const bool USE_REGULA_FALSI_APPROXIMATION = false, double EXCLUDED_VOLUME_PARAMETER = 1.0, double HYDRATION_SHELL_PARAMETER = 0.0, const bool SIDE_CHAIN_APPROXIMATION = false, const bool USE_SANS = false, double DEUTERIUM_EXCHANGE_PARAMETER = 0.0, util::ShPtr< storage::Vector< SasScatteringPoint> > REDUCED_EXP_DATA = util::ShPtr< storage::Vector< SasScatteringPoint> >() )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_debye.h</td>
        <td>SasDebye</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_debye_interface.h</td>
        <td>SasDebyeInterface</td>
        <td>GetExperimentalData() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_debye_interface.h</td>
        <td>SasDebyeInterface</td>
        <td>GetReducedExperimentalData() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_debye_interface.h</td>
        <td>SasDebyeInterface</td>
        <td>SetExperimentalData( const util::ShPtr< SasScatteringData> &EXPERIMENTAL_DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_debye_interface.h</td>
        <td>SasDebyeInterface</td>
        <td>SetReducedExperimentalData( const util::ShPtr< storage::Vector< SasScatteringPoint> > &REDUCED_EXPERIMENTAL_DATA )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>AllocateDensityMemory( const size_t &SIZE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>Begin()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>Begin() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>ComputeHmax() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>ComputeHxmax() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>End()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>End() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>GetBinNumber() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>GetBinSize() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>GetDensityData() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>GetDensityLocation( int LOCATION) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>GetDensitySize() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>GetDmax() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>GetHmax() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>GetHxmax() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>PushBackDensity( const SasDistanceDensityPoint &DATAPOINT_OBJECT)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>ReadBCLModel( std::istream &ISTREAM)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>ReadFromDataFile( std::istream &ISTREAM )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>ReadRestraints( std::istream &ISTREAM) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>SasDensityData( const math::Histogram &DENSITY_HISTOGRAM, const double &DMAX )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>SasDensityData( const std::string &EXTENSION = Ó)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>SasDensityData( const storage::Vector< SasDistanceDensityPoint> &DENSITY_DATA )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>SetBinNumber( const size_t &BIN_NUMBER)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>SetBinSize( const double &BIN_SIZE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>SetDmax( const double &DMAX)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>SetHmax( const double &HMAX)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>SetHxmax( const double &HXMAX)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_density_data.h</td>
        <td>SasDensityData</td>
        <td>WriteToDataFile( std::ostream &OSTREAM) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_distance_density_point.h</td>
        <td>SasDistanceDensityPoint</td>
        <td>GetDensity() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_distance_density_point.h</td>
        <td>SasDistanceDensityPoint</td>
        <td>GetError() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_distance_density_point.h</td>
        <td>SasDistanceDensityPoint</td>
        <td>GetRvalue() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_distance_density_point.h</td>
        <td>SasDistanceDensityPoint</td>
        <td>SasDistanceDensityPoint( const double RVALUE, const double DENSITY, const double MEASUREMENT_ERROR )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_distance_density_point.h</td>
        <td>SasDistanceDensityPoint</td>
        <td>SasDistanceDensityPoint()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_distance_density_point.h</td>
        <td>SasDistanceDensityPoint</td>
        <td>SetDensity( const double &DENSITY)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_distance_density_point.h</td>
        <td>SasDistanceDensityPoint</td>
        <td>SetError( const double &ERROR_VALUE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_distance_density_point.h</td>
        <td>SasDistanceDensityPoint</td>
        <td>SetRvalue( const double &RVALUE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_distance_density_point.h</td>
        <td>SasDistanceDensityPoint</td>
        <td>operator ==( const SasDistanceDensityPoint &POINT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>ComputeScoringFunction( bool USE_ERRORS) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>Derivative()
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>GetCalculatedData()
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>GetCalculatedData() const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>GetExperimentalData() const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>Log10()
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>LogtoAbsolute()
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>NormalizeData()
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>ReadFromCrysolFitFile( std::istream &ISTREAM, const double &FIRST_EXPERIMENTAL_POINT)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>ReadFromDataFile( std::istream &ISTREAM)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>ReadFromFoxsFile( std::istream &ISTREAM)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>SasExperimentalAndCalculatedData( const SasScatteringData &EXPERIMENTAL, const SasScatteringData &CALCULATED )
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>SasExperimentalAndCalculatedData()
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>ScaleCalculatedData( const double &SCALING_FACTOR)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>ScaleData( const double &SCALING_FACTOR)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>SetExperimentalData( const SasScatteringData &DATA_OBJECT)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>SetYScale( const double &Y_MAX)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>SlideData( const double &Y_MIN)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>WriteToGnomeFileName( const std::string &FILENAME) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>WriteToGnomeFormat( std::ostream &OSTREAM) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>WriteToGnuplot( std::ostream &OSTREAM) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_data.h</td>
        <td>SasExperimentalAndCalculatedData</td>
        <td>WriteToGnuplotFileName( const std::string &FILENAME) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>GetCalculatedDensity()
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>GetCalculatedDensity() const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>GetExperimentalDensity() const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>SasExperimentalAndCalculatedDensity( const SasDensityData &EXPERIMENTAL, const SasDensityData &CALCULATED )
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>SasExperimentalAndCalculatedDensity( const SasExperimentalAndCalculatedDensity &rhs)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>SasExperimentalAndCalculatedDensity()
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>ScaleCalculatedDensity( const double &CAL_SCALING_FACTOR)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>ScaleExperimentalDensity( const double &EXP_SCALING_FACTOR)
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>ShiftDensity()
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>WriteToFileName( const std::string &FILENAME) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>WriteToGnuplotFileName( const std::string &FILENAME) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_experimental_and_calculated_density.h</td>
        <td>SasExperimentalAndCalculatedDensity</td>
        <td>WriteToOstream( std::ostream &OSTREAM) const
</td>
        <td>mendenjl, putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>GoldenSection( float MIN_C1, float MAX_C1, float C2_VALUE, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>GridWalk( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>HookJeeves( linal::VectorND< float, 2> INITIAL_POINT, float RADIUS, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>QuadraticInterpolation( float MIN_C1, float MAX_C1, float C2_VALUE, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SasOptimization( const float &C1_MIN, const float &C1_MAX, const float &C2_MIN, const float &C2_MAX, const float &C1_STEPSIZE, const float &C2_STEPSIZE, const score::SasType::ScoreFunctionEnum &SCORE_FUNCTION, const bool &USE_ERRORS, const SasTransformation &TRANSFORMATION_TYPES, const bool &APPROXIMATE_SIDE_CHAINS, const bool &HARDWARE_TYPE, const bool &SAS_TYPE, const float &DEUTERIUM_EXCHANGE_PARAMETER )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SasOptimization()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetApproximateSideChainsFlag( const bool &APPROXIMATE_SIDE_CHAINS)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetC1Max( const float &C1_MAX)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetC1Min( const float &C1_MIN)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetC1StepSize( const float &C1_STEPSIZE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetC2Max( const float &C2_MAX)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetC2Min( const float &C2_MIN)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetC2StepSize( const float &C2_STEPSIZE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetDeuteriumExchangeParameter( const float &DEUTERIUM_EXCHANGE_PARAMETER)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetErrorFlag( const bool &USE_ERRORS)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetExperimentalData( const util::ShPtr< SasScatteringData> &EXPERIMENTAL_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetHardwareType( const bool &HARDWARE_TYPE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetSasType( const bool &SAS_TYPE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetScoreFunction( const score::SasType::ScoreFunctionEnum &SCORE_FUNCTION)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SetTransformationTypes( const SasTransformation &TRANSFORMATION_TYPES)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>SmartGridSearch( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_optimization.h</td>
        <td>SasOptimization</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_pofr.h</td>
        <td>SasPofR</td>
        <td>GetAtoms( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_pofr.h</td>
        <td>SasPofR</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_pofr_interface.h</td>
        <td>SasPofRInterface</td>
        <td>GetExperimentalDensity() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_pofr_interface.h</td>
        <td>SasPofRInterface</td>
        <td>SetExperimentalDensity( const util::Implementation< SasDensityData> &EXPERIMENTAL_DENSITY)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>AllocateScatteringMemory( const size_t &SIZE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>Begin()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>Begin() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>End()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>End() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>GetScatteringData() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>GetScatteringLocation( int LOCATION) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>GetScatteringSize() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>IsErrorDefined() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>PushBackScattering( const SasScatteringPoint &DATAPOINT_OBJECT)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>ReadFitFromGnom( std::istream &ISTREAM)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>ReadFromDataFile( std::istream &ISTREAM)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>ReadRestraints( std::istream &ISTREAM) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>SasScatteringData( const std::string &EXTENSION = Ó)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>SasScatteringData( const storage::Vector< SasScatteringPoint> &INIT_DATA )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>WriteToDataFile( std::ostream &OSTREAM, bool HEADER = true) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_data.h</td>
        <td>SasScatteringData</td>
        <td>WriteToDataFileName( const std::string &FILENAME, const bool &HEADER) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_point.h</td>
        <td>SasScatteringPoint</td>
        <td>GetError() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_point.h</td>
        <td>SasScatteringPoint</td>
        <td>GetIntensity() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_point.h</td>
        <td>SasScatteringPoint</td>
        <td>GetQvalue() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_point.h</td>
        <td>SasScatteringPoint</td>
        <td>IsErrorDefined() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_point.h</td>
        <td>SasScatteringPoint</td>
        <td>SasScatteringPoint( const double QVALUE, const double INTENSITY, const double MEASUREMENT_ERROR )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_point.h</td>
        <td>SasScatteringPoint</td>
        <td>SasScatteringPoint()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_point.h</td>
        <td>SasScatteringPoint</td>
        <td>SetError( const double &ERROR_VALUE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_scattering_point.h</td>
        <td>SasScatteringPoint</td>
        <td>SetIntensity( const double &INTENSITY)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_scattering_point.h</td>
        <td>SasScatteringPoint</td>
        <td>operator ==( const SasScatteringPoint &POINT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>DerivativeProfile( SasExperimentalAndCalculatedData &DATA_OBJECT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>GetFunctionDescriptor( const TransformationType &TRANSFORMATION_TYPE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>GetSerializer() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>GetTransformationTypes() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>GetUseErrors() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>LogProfile( SasExperimentalAndCalculatedData &DATA_OBJECT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>LogtoAbsolute( SasExperimentalAndCalculatedData &DATA_OBJECT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>NormalizeData( SasExperimentalAndCalculatedData &DATA_OBJECT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>SasTransformation( const storage::Vector< TransformationTypeEnum> &TRANSFORMATION_TYPES, const bool &OUTPUT_TRANSFORMATIONS, const bool &USE_ERRORS, const double &Y_MAX )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>SasTransformation()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>ScaleCalculatedProfile( SasExperimentalAndCalculatedData &DATA_OBJECT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>SetYScale( SasExperimentalAndCalculatedData &DATA_OBJECT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_sas_transformation.h</td>
        <td>SasTransformation</td>
        <td>operator ()( const SasExperimentalAndCalculatedData &ORIGINAL_DATA) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>GetDefaultExtension() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>GetMutateTree() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>GetScatteringData() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>InitializeScores()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>MergeAndModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>ModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>ReadRestraints( std::istream &ISTREAM)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_data.h</td>
        <td>SaxsData</td>
        <td>SaxsData()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_data_reduction.h</td>
        <td>SaxsDataReduction</td>
        <td>ComputeShannonNumber( const double &DMAX, const double &QMAX)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_data_reduction.h</td>
        <td>SaxsDataReduction</td>
        <td>SasSignalRecovery( assemble::ProteinModel &PROTEIN_MODEL, size_t NUMBER_OF_ITERATIONS, const util::ShPtr< SasScatteringData> ORIGINAL_DATA, const double DMAX )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_data_reduction.h</td>
        <td>SaxsDataReduction</td>
        <td>SasSignalRecoveryEstimate( const util::ShPtr< SasScatteringData> ORIGINAL_DATA, const double DMAX )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_data_reduction.h</td>
        <td>SaxsDataReduction</td>
        <td>SelectIndex( int LEFT, int RIGHT)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_data_reduction.h</td>
        <td>SaxsDataReduction</td>
        <td>SelectIndexMinError( const util::ShPtr< SasScatteringData> ORIGINAL_DATA, int LEFT, int RIGHT)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_opti_result.h</td>
        <td>SaxsOptiResult</td>
        <td>GetC1() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_opti_result.h</td>
        <td>SaxsOptiResult</td>
        <td>GetC2() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_opti_result.h</td>
        <td>SaxsOptiResult</td>
        <td>GetChi() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_opti_result.h</td>
        <td>SaxsOptiResult</td>
        <td>SaxsOptiResult( const float C1, const float C2, const float CHI )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_opti_result.h</td>
        <td>SaxsOptiResult</td>
        <td>SaxsOptiResult()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_opti_result.h</td>
        <td>SaxsOptiResult</td>
        <td>SetC1( const float &C1)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_opti_result.h</td>
        <td>SaxsOptiResult</td>
        <td>SetC2( const float &C2)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_opti_result.h</td>
        <td>SaxsOptiResult</td>
        <td>SetChi( const float &CHI)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_opti_result.h</td>
        <td>SaxsOptiResult</td>
        <td>operator ==( const SaxsOptiResult &POINT) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>GetC1Max() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>GetC1Min() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>GetC1StepSize() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>GetC2Max() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>GetC2Min() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>GetC2StepSize() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>GoldenSection( float MIN_C1, float MAX_C1, float C2_VALUE, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>GridWalk( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>HookJeeves( linal::VectorND< float, 2> INITIAL_POINT, float RADIUS, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>QuadraticInterpolation( float MIN_C1, float MAX_C1, float C2_VALUE, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SaxsOptimization( const float &C1_MIN, const float &C1_MAX, const float &C2_MIN, const float &C2_MAX, const float &C1_STEPSIZE, const float &C2_STEPSIZE, const score::SaxsType::ScoreFunctionEnum &SCORE_FUNCTION, const bool &USE_ERRORS, const SaxsTransformation &TRANSFORMATION_TYPES, const bool &APPROXIMATE_SIDE_CHAINS, const bool &HARDWARE_TYPE )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SaxsOptimization()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetApproximateSideChainsFlag( const bool &APPROXIMATE_SIDE_CHAINS)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetC1Max( const float &C1_MAX)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetC1Min( const float &C1_MIN)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetC1StepSize( const float &C1_STEPSIZE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetC2Max( const float &C2_MAX)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetC2Min( const float &C2_MIN)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetC2StepSize( const float &C2_STEPSIZE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetErrorFlag( const bool &USE_ERRORS)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetExperimentalData( const util::ShPtr< SaxsScatteringData> &EXPERIMENTAL_DATA)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetHardwareType( const bool &HARDWARE_TYPE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetScoreFunction( const score::SaxsType::ScoreFunctionEnum &SCORE_FUNCTION)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SetTransformationTypes( const SaxsTransformation &TRANSFORMATION_TYPES)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>SmartGridSearch( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_saxs_optimization.h</td>
        <td>SaxsOptimization</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_xlink_data.h</td>
        <td>XlinkData</td>
        <td>GetAtomDistanceRestraints() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_xlink_data.h</td>
        <td>XlinkData</td>
        <td>GetDefaultExtension() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_xlink_data.h</td>
        <td>XlinkData</td>
        <td>GetMutateTree() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_xlink_data.h</td>
        <td>XlinkData</td>
        <td>InitializeScores()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_xlink_data.h</td>
        <td>XlinkData</td>
        <td>MergeAndModifyMutateTree( fold::MutateTree &MUTATE_TREE) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_restraint_xlink_data.h</td>
        <td>XlinkData</td>
        <td>ModifyScoreWeightSet( fold::ScoreWeightSet &SCORE_WEIGHT_SET) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_restraint_xlink_data.h</td>
        <td>XlinkData</td>
        <td>XlinkData()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_binary_function_job_with_data.h</td>
        <td>BinaryFunctionJobWithData</td>
        <td>BinaryFunctionJobWithData( const size_t &GROUPID, const t_FunctionClass &CLASS, PtrToConstMemberFunction QUERY_TO_SUBMIT, t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_binary_function_job_with_data.h</td>
        <td>BinaryFunctionJobWithData</td>
        <td>BinaryFunctionJobWithData( const size_t &GROUPID, t_FunctionClass &CLASS, PtrToMemberFunction FUNCTION_TO_SUBMIT, t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_binary_function_job_with_data.h</td>
        <td>BinaryFunctionJobWithData</td>
        <td>BinaryFunctionJobWithData( const size_t &GROUPID, t_FunctionClass &CLASS, t_ResultType ( *FUNCTION_TO_SUBMIT)( t_ArgumentType1 &, t_ArgumentType2 &), t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_binary_function_job_with_data.h</td>
        <td>BinaryFunctionJobWithData</td>
        <td>BinaryFunctionJobWithData()
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_binary_function_job_with_data.h</td>
        <td>BinaryFunctionJobWithData</td>
        <td>GetFirstArgument() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_binary_function_job_with_data.h</td>
        <td>BinaryFunctionJobWithData</td>
        <td>GetGroupID() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_binary_function_job_with_data.h</td>
        <td>BinaryFunctionJobWithData</td>
        <td>GetJobStatus() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_binary_function_job_with_data.h</td>
        <td>BinaryFunctionJobWithData</td>
        <td>GetSecondArgument() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_binary_function_job_with_data.h</td>
        <td>BinaryFunctionJobWithData</td>
        <td>SetJobStatus( const JobInterface::JobStatus &JOBSTATUS)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_function_job_with_data.h</td>
        <td>FunctionJobWithData</td>
        <td>FunctionJobWithData( const size_t &GROUPID, const util::SiPtr< const util::FunctionInterface< t_ArgumentType, t_ResultType> > &SP_FUNCTION_TO_SUBMIT, const t_ArgumentType &ARGUMENT, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_function_job_with_data.h</td>
        <td>FunctionJobWithData</td>
        <td>FunctionJobWithData()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_function_job_with_data.h</td>
        <td>FunctionJobWithData</td>
        <td>GetGroupID() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_function_job_with_data.h</td>
        <td>FunctionJobWithData</td>
        <td>GetJobStatus() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_function_job_with_data.h</td>
        <td>FunctionJobWithData</td>
        <td>SetJobStatus( const JobInterface::JobStatus &JOBSTATUS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_job_interface.h</td>
        <td>JobInterface</td>
        <td>JobInterface()
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_job_with_result_base.h</td>
        <td>JobWithResultBase</td>
        <td>JobWithResultBase( t_Result *DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_job_with_result_base.h</td>
        <td>JobWithResultBase</td>
        <td>JobWithResultBase( void *)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_job_with_result_base.h</td>
        <td>JobWithResultBase</td>
        <td>Run()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_mutex.h</td>
        <td>Mutex</td>
        <td>Lock()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_mutex.h</td>
        <td>Mutex</td>
        <td>Mutex( const Mutex &MUTEX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_mutex.h</td>
        <td>Mutex</td>
        <td>Mutex()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_mutex.h</td>
        <td>Mutex</td>
        <td>TestLock() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_mutex.h</td>
        <td>Mutex</td>
        <td>TryLock()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_mutex.h</td>
        <td>Mutex</td>
        <td>Unlock()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_mutex.h</td>
        <td>Mutex</td>
        <td>operator =( const Mutex &MUTEX)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_scheduler_interface.h</td>
        <td>SchedulerInterface</td>
        <td>GetParameterNumberCPUs()
</td>
        <td>riddeljs, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_scheduler_interface.h</td>
        <td></td>
        <td>GetNumberCPUs()
</td>
        <td>riddeljs, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_scheduler_interface.h</td>
        <td></td>
        <td>GetScheduler()
</td>
        <td>riddeljs, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_schedulers.h</td>
        <td>Schedulers</td>
        <td>GetCurrentScheduler()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_schedulers.h</td>
        <td>Schedulers</td>
        <td>GetFlagSchedulerCPUS()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_schedulers.h</td>
        <td>Schedulers</td>
        <td>UpdateCurrentSchedulerFromCommandLineFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_schedulers.h</td>
        <td></td>
        <td>GetSchedulers()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_scope_lock.h</td>
        <td>ScopeLock</td>
        <td>ScopeLock()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_serial_scheduler.h</td>
        <td>SerialScheduler</td>
        <td>GetNumberUnusedCPUS() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_serial_scheduler.h</td>
        <td>SerialScheduler</td>
        <td>Join( util::ShPtr< JobInterface> &SP_JOB) const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_serial_scheduler.h</td>
        <td>SerialScheduler</td>
        <td>ReleaseReservedCPUs( const size_t &NR_TO_RELEASE)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_serial_scheduler.h</td>
        <td>SerialScheduler</td>
        <td>ReserveAvailableCPUs( const size_t &MAX)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_serial_scheduler.h</td>
        <td>SerialScheduler</td>
        <td>RunJob( util::ShPtr< JobInterface> &SP_JOB) const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_serial_scheduler.h</td>
        <td>SerialScheduler</td>
        <td>SerialScheduler()
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_serial_scheduler.h</td>
        <td>SerialScheduler</td>
        <td>SubmitJob( util::ShPtr< JobInterface> &SP_JOB) const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_sum_function.h</td>
        <td>SumFunction</td>
        <td>SumFunction( const std::string &SCHEME = Ó)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_sum_function.h</td>
        <td>SumFunction</td>
        <td>SumFunction( const t_ResultType &ABSOLUTE, const double &COEFFICIENT, const util::Implementation< math::FunctionInterfaceSerializable< t_ArgumentType, t_ResultType> > &SP_FUNCTION, const std::string &SCHEME = Ó )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_sum_function.h</td>
        <td>SumFunction</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_tertiary_function_job_with_data.h</td>
        <td>TertiaryFunctionJobWithData</td>
        <td>GetGroupID() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_tertiary_function_job_with_data.h</td>
        <td>TertiaryFunctionJobWithData</td>
        <td>GetJobStatus() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_tertiary_function_job_with_data.h</td>
        <td>TertiaryFunctionJobWithData</td>
        <td>SetJobStatus( const JobInterface::JobStatus &JOBSTATUS)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_tertiary_function_job_with_data.h</td>
        <td>TertiaryFunctionJobWithData</td>
        <td>TertiaryFunctionJobWithData( const size_t &GROUPID, const t_FunctionClass &CLASS, PtrToConstMemberFunction QUERY_TO_SUBMIT, t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2, t_ArgumentType3 &ARGUMENT3, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_tertiary_function_job_with_data.h</td>
        <td>TertiaryFunctionJobWithData</td>
        <td>TertiaryFunctionJobWithData( const size_t &GROUPID, t_FunctionClass &CLASS, PtrToMemberFunction FUNCTION_TO_SUBMIT, t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2, t_ArgumentType3 &ARGUMENT3, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_tertiary_function_job_with_data.h</td>
        <td>TertiaryFunctionJobWithData</td>
        <td>TertiaryFunctionJobWithData( const size_t &GROUPID, t_FunctionClass &CLASS, t_ResultType ( *FUNCTION_TO_SUBMIT)( t_ArgumentType1 &, t_ArgumentType2 &, t_ArgumentType3 &), t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2, t_ArgumentType3 &ARGUMENT3, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_tertiary_function_job_with_data.h</td>
        <td>TertiaryFunctionJobWithData</td>
        <td>TertiaryFunctionJobWithData()
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_thunk_job.h</td>
        <td>ThunkJob</td>
        <td>GetGroupID() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_thunk_job.h</td>
        <td>ThunkJob</td>
        <td>GetJobStatus() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_thunk_job.h</td>
        <td>ThunkJob</td>
        <td>SetJobStatus( const JobInterface::JobStatus &JOBSTATUS)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_thunk_job.h</td>
        <td>ThunkJob</td>
        <td>ThunkJob( const size_t GROUPID, const t_FunctionClass &CLASS, PtrToConstMemberFunction QUERY_TO_SUBMIT, const JobInterface::JobStatus &JOBSTATUS = JobInterface::e_READY, t_ResultType *RESULT = NULL )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_thunk_job.h</td>
        <td>ThunkJob</td>
        <td>ThunkJob( const size_t GROUPID, t_FunctionClass &CLASS, PtrToMemberFunction FUNCTION_TO_SUBMIT, const JobInterface::JobStatus &JOBSTATUS = JobInterface::e_READY, t_ResultType *RESULT = NULL )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_thunk_job.h</td>
        <td>ThunkJob</td>
        <td>ThunkJob( const size_t GROUPID, t_FunctionClass &CLASS, t_ResultType ( *FUNCTION_TO_SUBMIT)(), const JobInterface::JobStatus &JOBSTATUS = JobInterface::e_READY, t_ResultType *RESULT = NULL )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_thunk_job.h</td>
        <td>ThunkJob</td>
        <td>ThunkJob()
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_unary_function_job_with_data.h</td>
        <td>UnaryFunctionJobWithData</td>
        <td>GetGroupID() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_unary_function_job_with_data.h</td>
        <td>UnaryFunctionJobWithData</td>
        <td>GetJobStatus() const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_unary_function_job_with_data.h</td>
        <td>UnaryFunctionJobWithData</td>
        <td>SetJobStatus( const JobInterface::JobStatus &JOBSTATUS)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_unary_function_job_with_data.h</td>
        <td>UnaryFunctionJobWithData</td>
        <td>UnaryFunctionJobWithData( const size_t &GROUPID, const t_FunctionClass &CLASS, PtrToConstMemberFunction QUERY_TO_SUBMIT, t_ArgumentType1 &ARGUMENT1, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_unary_function_job_with_data.h</td>
        <td>UnaryFunctionJobWithData</td>
        <td>UnaryFunctionJobWithData( const size_t &GROUPID, t_FunctionClass &CLASS, PtrToMemberFunction FUNCTION_TO_SUBMIT, t_ArgumentType1 &ARGUMENT1, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sched_unary_function_job_with_data.h</td>
        <td>UnaryFunctionJobWithData</td>
        <td>UnaryFunctionJobWithData( const size_t &GROUPID, t_FunctionClass &CLASS, t_ResultType ( *FUNCTION_TO_SUBMIT)( t_ArgumentType1 &), t_ArgumentType1 &ARGUMENT1, const JobInterface::JobStatus &JOBSTATUS, t_ResultType *RESULT )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sched_unary_function_job_with_data.h</td>
        <td>UnaryFunctionJobWithData</td>
        <td>UnaryFunctionJobWithData()
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score.h</td>
        <td>Score</td>
        <td>AddHistogramPath( const std::string &FILENAME)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score.h</td>
        <td>Score</td>
        <td>GetDefaultHistogramPath()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_blast_profile.h</td>
        <td>AAAssignmentBlastProfile</td>
        <td>AAAssignmentBlastProfile()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_blast_profile.h</td>
        <td>AAAssignmentBlastProfile</td>
        <td>operator ()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_blosum.h</td>
        <td>AAAssignmentBLOSUM</td>
        <td>AAAssignmentBLOSUM( const TableType &BLOSUM_TABLE = e_BLOSUM_62)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_blosum.h</td>
        <td>AAAssignmentBLOSUM</td>
        <td>GetBLOSUMMatrix( const TableType &BLOSUM_TABLE)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_blosum.h</td>
        <td>AAAssignmentBLOSUM</td>
        <td>GetBLOSUMRow( const TableType &BLOSUM_TABLE, const biol::AAType &AATYPE )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_blosum.h</td>
        <td>AAAssignmentBLOSUM</td>
        <td>GetTableDescriptor( const TableType &TABLE_TYPE)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_blosum.h</td>
        <td>AAAssignmentBLOSUM</td>
        <td>GetTableType() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_blosum.h</td>
        <td>AAAssignmentBLOSUM</td>
        <td>Probability( const TableType BLOSUM_TABLE, const biol::AAType &AA_TYPE_A, const biol::AAType &AA_TYPE_B )
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_blosum.h</td>
        <td>AAAssignmentBLOSUM</td>
        <td>operator ()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_identity.h</td>
        <td>AAAssignmentIdentity</td>
        <td>AAAssignmentIdentity()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_identity.h</td>
        <td>AAAssignmentIdentity</td>
        <td>operator ()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_mean_similarity_matrix.h</td>
        <td>AAAssignmentMeanSimilarityMatrix</td>
        <td>AAAssignmentMeanSimilarityMatrix()
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_pam.h</td>
        <td>AAAssignmentPAM</td>
        <td>AAAssignmentPAM( const TableType PAM_TABLE = e_PAM_250)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_pam.h</td>
        <td>AAAssignmentPAM</td>
        <td>GetPAMMatrix( const TableType PAM_TABLE)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_pam.h</td>
        <td>AAAssignmentPAM</td>
        <td>GetTableDescriptor( const TableType &TABLE_TYPE)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_pam.h</td>
        <td>AAAssignmentPAM</td>
        <td>Probability( const TableType PAM_TABLE, const biol::AAType &AA_TYPE_A, const biol::AAType &AA_TYPE_B)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_pam.h</td>
        <td>AAAssignmentPAM</td>
        <td>operator ()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_phat.h</td>
        <td>AAAssignmentPHAT</td>
        <td>AAAssignmentPHAT( const TableType &PHAT_TABLE = e_PHAT_70)
</td>
        <td>dongen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_phat.h</td>
        <td>AAAssignmentPHAT</td>
        <td>GetPHATMatrix( const TableType &PHAT_TABLE)
</td>
        <td>dongen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_phat.h</td>
        <td>AAAssignmentPHAT</td>
        <td>GetTableType() const
</td>
        <td>dongen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_phat.h</td>
        <td>AAAssignmentPHAT</td>
        <td>GetTableTypeString( const TableType &PHAT_TABLE)
</td>
        <td>dongen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_phat.h</td>
        <td>AAAssignmentPHAT</td>
        <td>Probability( const TableType &PHAT_TABLE, const biol::AAType &AA_TYPE_A, const biol::AAType &AA_TYPE_B )
</td>
        <td>dongen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_phat.h</td>
        <td>AAAssignmentPHAT</td>
        <td>operator ()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
</td>
        <td>dongen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_property.h</td>
        <td>AAAssignmentProperty</td>
        <td>AAAssignmentProperty( const biol::AATypeData::PropertyType PROPERTY = biol::AATypeData::e_StericalParameter)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_property.h</td>
        <td>AAAssignmentProperty</td>
        <td>operator ()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_ss_prediction.h</td>
        <td>AAAssignmentSSPrediction</td>
        <td>AAAssignmentSSPrediction( const sspred::Method SS_METHOD)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignment_ss_prediction.h</td>
        <td>AAAssignmentSSPrediction</td>
        <td>AAAssignmentSSPrediction()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignment_ss_prediction.h</td>
        <td>AAAssignmentSSPrediction</td>
        <td>operator ()( const biol::AABase &MEMBER_A, const biol::AABase &MEMBER_B) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignments.h</td>
        <td>AAAssignments</td>
        <td>GetFileExtension( const AAAssignment &ASSIGNMENT_ENUM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_assignments.h</td>
        <td>AAAssignments</td>
        <td>GetZScore( const AAAssignment &ASSIGNMENT_ENUM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_assignments.h</td>
        <td></td>
        <td>GetAAAssignments()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_distances.h</td>
        <td>AANeighborhoodDistances</td>
        <td>AANeighborhoodDistances( const AAPairDistanceInterface &SP_AA_PAIR_DISTANCE_SCORE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_distances.h</td>
        <td>AANeighborhoodDistances</td>
        <td>AANeighborhoodDistances()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_distances.h</td>
        <td>AANeighborhoodDistances</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_distances.h</td>
        <td>AANeighborhoodDistances</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_distances.h</td>
        <td>AANeighborhoodDistances</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_distances.h</td>
        <td>AANeighborhoodDistances</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_distances.h</td>
        <td>AANeighborhoodDistances</td>
        <td>WriteDetailedSchemeAndValues( const assemble::AANeighborList &AA_NEIGHBOR_LIST, const util::SiPtr< const biol::Membrane> &MEMBRANE, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_distances.h</td>
        <td>AANeighborhoodDistances</td>
        <td>operator ()( const assemble::AANeighborList &AA_NEIGHBOR_LIST, const util::SiPtr< const biol::Membrane> &MEMBRANE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>AANeighborhoodExposure( const assemble::AAExposureInterface &SP_AA_EXPOSURE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>AANeighborhoodExposure()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>GetMembranePotentials( const biol::EnvironmentType &ENVIRONMENT ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>GetSolublePotentials() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>WriteDetailedSchemeAndValues( const assemble::AANeighborList &AA_NEIGHBOR_LIST, const util::SiPtr< const biol::Membrane> &MEMBRANE, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_exposure.h</td>
        <td>AANeighborhoodExposure</td>
        <td>operator ()( const assemble::AANeighborList &AA_NEIGHBOR_LIST, const util::SiPtr< const biol::Membrane> &MEMBRANE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_exposure_prediction.h</td>
        <td>AANeighborhoodExposurePrediction</td>
        <td>AANeighborhoodExposurePrediction()
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_exposure_prediction.h</td>
        <td>AANeighborhoodExposurePrediction</td>
        <td>GetDistanceCutoff() const
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_exposure_prediction.h</td>
        <td>AANeighborhoodExposurePrediction</td>
        <td>GetFlagScoreExposure()
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_exposure_prediction.h</td>
        <td>AANeighborhoodExposurePrediction</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_exposure_prediction.h</td>
        <td>AANeighborhoodExposurePrediction</td>
        <td>GetScheme() const
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_exposure_prediction.h</td>
        <td>AANeighborhoodExposurePrediction</td>
        <td>GetSerializer() const
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_neighborhood_exposure_prediction.h</td>
        <td>AANeighborhoodExposurePrediction</td>
        <td>WriteDetailedSchemeAndValues( const assemble::AANeighborList &NEIGHBOR_LIST, const util::SiPtr< const biol::Membrane> &MEMBRANE, std::ostream &OSTREAM ) const
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_neighborhood_exposure_prediction.h</td>
        <td>AANeighborhoodExposurePrediction</td>
        <td>operator ()( const assemble::AANeighborList &NEIGHBOR_LIST, const util::SiPtr< const biol::Membrane> &MEMBRANE ) const
</td>
        <td>lib14, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>AAPairAtomClash( const double SIGMOID_WIDTH, const size_t MINIMAL_SEQUENCE_SEPARATION, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>AAPairAtomClash()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>GetConsiderDifferentChain() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>GetDistanceCutoff() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>GetScheme() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>GetSigmoidWidth() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>WriteDetailedSchemeAndValues( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, std::ostream &OSTREAM ) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B ) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, double DISTANCE ) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_atom_clash.h</td>
        <td>AAPairAtomClash</td>
        <td>operator ()( const biol::Atom &ATOM_A, const biol::Atom &ATOM_B ) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>AAPairClash( const double SIGMOID_WIDTH = 1.0, const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>AAPairClash( const double SIGMOID_WIDTH, const size_t MINIMAL_SEQUENCE_SEPARATION, const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>CalculateRepulsiveTerm( const double DISTANCE, const double SHORTEST_OBSERVED_DISTANCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetClosestDistance( const biol::AAType &A, const biol::AAType &B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetConsiderDifferentChain() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetDefaultScheme()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetDistanceCutoff() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetHistogramFilename() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetInstance()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>GetShortestObservedDistanceMatrix() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>WriteDetailedSchemeAndValues( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, std::ostream &OSTREAM ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_clash.h</td>
        <td>AAPairClash</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const double DISTANCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_contact.h</td>
        <td>AAPairContact</td>
        <td>AAPairContact( const contact::Type &CONTACT_TYPE, const util::ShPtr< contact::PredictionMap> &SP_PREDICTION_MAP )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_contact.h</td>
        <td>AAPairContact</td>
        <td>AAPairContact()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_contact.h</td>
        <td>AAPairContact</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_contact.h</td>
        <td>AAPairContact</td>
        <td>WriteDetailedSchemeAndValues( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, std::ostream &OSTREAM ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_contact.h</td>
        <td>AAPairContact</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>AAPairContactEnergy()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>GetConsiderDifferentChain() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>GetDistanceCutoff() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>GetHistogramFilename() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &MODEL, std::ostream &OSTREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>WriteDetailedSchemeAndValues( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const biol::SSType &TYPE_A, const biol::SSType &TYPE_B, std::ostream &OSTREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_contact_energy.h</td>
        <td>AAPairContactEnergy</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const double DISTANCE, const biol::SSType &TYPE_A, const biol::SSType &TYPE_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>AAPairDistance( const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>GetConsiderDifferentChain() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>GetEnergyFunctionMap() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>GetHistogramFilename() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>WriteDetailedSchemeAndValues( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance.h</td>
        <td>AAPairDistance</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const double DISTANCE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance_fitted_function.h</td>
        <td>AAPairDistanceFittedFunction</td>
        <td>AAPairDistanceFittedFunction( const linal::Vector< double> &BINNING, const linal::Vector< double> &ENERGY_DISTRIBUTION )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance_fitted_function.h</td>
        <td>AAPairDistanceFittedFunction</td>
        <td>AAPairDistanceFittedFunction( const math::Histogram &AA_PAIR_DISTANCE_DISTRIBUTION )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance_fitted_function.h</td>
        <td>AAPairDistanceFittedFunction</td>
        <td>AAPairDistanceFittedFunction()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance_fitted_function.h</td>
        <td>AAPairDistanceFittedFunction</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance_fitted_function.h</td>
        <td>AAPairDistanceFittedFunction</td>
        <td>operator ()( const double &DISTANCE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>AAPairDistanceSmooth( const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>GetConsiderDifferentChain() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>WriteDetailedSchemeAndValues( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_distance_smooth.h</td>
        <td>AAPairDistanceSmooth</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const double DISTANCE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>AAPairHiResClash()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>GetConsiderDifferentChain() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>GetContactProbability( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const double DISTANCE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>GetDistanceCutoff() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>GetHistogramFilename() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>GetHistograms() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &MODEL, std::ostream &OSTREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>WriteDetailedSchemeAndValues( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, std::ostream &OSTREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>operator ()( const assemble::ProteinModel &MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_hi_res_clash.h</td>
        <td>AAPairHiResClash</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const double DISTANCE ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>AAPairSidechainInteraction( )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>AAPairSidechainInteraction( const std::string &HISTOGRAM_FILENAME, const std::string &SCHEME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>GetConsiderDifferentChain() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>GetDistanceCutoff() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>GetMinimalSequenceSeparation() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>Weight90To45Transition( const double ANGLE_RAD)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>WeightOfInteraction( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>WriteDetailedSchemeAndValues( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_pair_sidechain_interaction.h</td>
        <td>AAPairSidechainInteraction</td>
        <td>operator ()( const biol::AABase &AMINO_ACID_A, const biol::AABase &AMINO_ACID_B, const double DISTANCE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_sequence.h</td>
        <td>AASequence</td>
        <td>AASequence( const util::ShPtr< AAPairDistanceInterface> &SP_AA_PAIR_POTETNIAL, const bool NORMALIZE )
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_sequence.h</td>
        <td>AASequence</td>
        <td>AASequence()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_sequence.h</td>
        <td>AASequence</td>
        <td>GetScheme() const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_sequence.h</td>
        <td>AASequence</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &THIS_SSE, std::ostream &OSTREAM ) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_sequence.h</td>
        <td>AASequence</td>
        <td>operator ()( const assemble::SSE &THIS_SSE, const biol::Membrane &MEMBRANE ) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_sequence_pair.h</td>
        <td>AASequencePair</td>
        <td>AASequencePair( const AAPairDistanceInterface &AA_PAIR_POTENTIAL, const bool NORMALIZE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_sequence_pair.h</td>
        <td>AASequencePair</td>
        <td>AASequencePair()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_sequence_pair.h</td>
        <td>AASequencePair</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_sequence_pair.h</td>
        <td>AASequencePair</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_sequence_pair.h</td>
        <td>AASequencePair</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_aa_sequence_pair.h</td>
        <td>AASequencePair</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_aa_sequence_pair.h</td>
        <td>AASequencePair</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility.h</td>
        <td>Accessibility</td>
        <td>Accessibility( const util::ShPtr< math::FunctionInterfaceSerializable< restraint::AccessibilityProfileAssignment, double> > &SCORING_FUNCTION, const util::ShPtr< restraint::AccessibilityProfile> RESTRAINTS, const std::string SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility.h</td>
        <td>Accessibility</td>
        <td>Accessibility()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility.h</td>
        <td>Accessibility</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility.h</td>
        <td>Accessibility</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility.h</td>
        <td>Accessibility</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility.h</td>
        <td>Accessibility</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>AccessibilityHydrophobicMoment( const restraint::AccessibilityAA::EnvironmentEnum &ENVIRONMENT, const storage::Map< biol::SSType, size_t> WINDOW_SIZES )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>AccessibilityHydrophobicMoment()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>CalculateHydrophobicMomentWindow( storage::List< restraint::AccessibilityAAAssignment>::const_iterator ITR, storage::List< restraint::AccessibilityAAAssignment>::const_iterator ITR_END, const size_t WINDOW_SIZE, const restraint::AccessibilityAA::EnvironmentEnum &ENVIRONMENT_TYPE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>CalculateHydrophobicMomentWindows( const storage::List< restraint::AccessibilityAAAssignment> &ASSIGNMENTS, const size_t WINDOW_SIZE, const restraint::AccessibilityAA::EnvironmentEnum &ENVIRONMENT_TYPE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>CalculateMomentAgreement( const AccessibilityHydrophobicMoment::Window &WINDOW, const assemble::SSE &SSE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>CalculateMomentInXYPlane( const linal::Vector3D &MOMENT, const assemble::SSE &SSE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>CalculateMomentMagnitudeAgreement( const restraint::AccessibilityProfileAssignment &ASSIGNMENT ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>CalculateSingleHydrophobicMoment( const biol::AABase &AA_BASE, const double HYDROPHOBICITY )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>ScoreAngle( const double CALC_CENTER_EXP_ANGLE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>ShowHydrophobicMomentWindow( const AccessibilityHydrophobicMoment::Window &WINDOW, std::ostream &OSTREAM, const assemble::SSE &SSE, const std::string &TAG, const util::Color &COLOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>ShowHydrophobicMomentWindows( const storage::List< AccessibilityHydrophobicMoment::Window> &WINDOW_LIST, std::ostream &OSTREAM, const assemble::SSE &SSE, const std::string &TAG, const util::Color &COLOR )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>WriteDetailedSchemeAndValues( const restraint::AccessibilityProfileAssignment &ASSIGNMENT, std::ostream &OSTREAM ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>AccessibilityHydrophobicMoment</td>
        <td>operator ()( const restraint::AccessibilityProfileAssignment &ASSIGNMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>Window</td>
        <td>GetAccessibilities() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>Window</td>
        <td>GetCalculatedMoment() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>Window</td>
        <td>GetExperimentMoment() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>Window</td>
        <td>GetIdentification() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>Window</td>
        <td>GetIdentificationInLine() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>Window</td>
        <td>Window( const linal::Vector3D &CALCULATED_MOMENT, const linal::Vector3D &EXPERIMENTAL_MOMENT, const storage::List< restraint::AccessibilityAAAssignment> &ACCESSIBILITY_ASSIGNMENTS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment.h</td>
        <td>Window</td>
        <td>Window()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment_magnitude.h</td>
        <td>AccessibilityHydrophobicMomentMagnitude</td>
        <td>AccessibilityHydrophobicMomentMagnitude( const restraint::AccessibilityAA::EnvironmentType &ENVIRONMENT, const storage::Map< biol::SSType, size_t> WINDOW_SIZES )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment_magnitude.h</td>
        <td>AccessibilityHydrophobicMomentMagnitude</td>
        <td>AccessibilityHydrophobicMomentMagnitude()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_accessibility_hydrophobic_moment_magnitude.h</td>
        <td>AccessibilityHydrophobicMomentMagnitude</td>
        <td>WriteDetailedSchemeAndValues( const restraint::AccessibilityProfileAssignment &ASSIGNMENT, std::ostream &OSTREAM ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_accessibility_hydrophobic_moment_magnitude.h</td>
        <td>AccessibilityHydrophobicMomentMagnitude</td>
        <td>operator ()( const restraint::AccessibilityProfileAssignment &ASSIGNMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_alignment_assignment.h</td>
        <td>AlignmentAssignment</td>
        <td>AlignmentAssignment( const util::ShPtr< function::UnaryInterface< const align::Assignment< t_Member>, double> > &SP_ASSIGNMENT_SCORE )
</td>
        <td>heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_alignment_assignment.h</td>
        <td>AlignmentAssignment</td>
        <td>operator ()( const align::AlignmentInterface< t_Member> &ALIGNMENT) const
</td>
        <td>heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_alignment_assignment.h</td>
        <td></td>
        <td>AddInstance( new AlignmentAssignment< t_Member>())
</td>
        <td>heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_alignment_gap.h</td>
        <td>AlignmentGap</td>
        <td>AlignmentGap( const double GAP_PENALTY = 0.0)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_alignment_gap.h</td>
        <td>AlignmentGap</td>
        <td>operator ()( const align::AlignmentInterface< t_Member> &ALIGNMENT) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_alignment_quality.h</td>
        <td>AlignmentQuality</td>
        <td>AlignmentQuality()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_alignment_quality.h</td>
        <td>AlignmentQuality</td>
        <td>SetAtoms( const storage::Set< biol::AtomType> &ATOM_TYPES)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_alignment_quality.h</td>
        <td>AlignmentQuality</td>
        <td>SetMeasure( const util::ShPtr< quality::MeasureInterface> &SP_MEASURE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_alignment_quality.h</td>
        <td>AlignmentQuality</td>
        <td>operator ()( const align::AlignmentInterface< biol::AABase> &ALIGNMENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment( const util::ShPtr< MemberPairScore> &SCORE_PAIR)
</td>
        <td>heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_assignment.h</td>
        <td>Assignment</td>
        <td>Assignment()
</td>
        <td>heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_assignment.h</td>
        <td>Assignment</td>
        <td>operator ()( const align::Assignment< t_Member> &ASSIGNMENT) const
</td>
        <td>heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_assignment_gap_simple.h</td>
        <td>AssignmentGapSimple</td>
        <td>AssignmentGapSimple( const double GAP_PENALTY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_assignment_gap_simple.h</td>
        <td>AssignmentGapSimple</td>
        <td>GetPenalty() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_assignment_gap_simple.h</td>
        <td>AssignmentGapSimple</td>
        <td>SetPenalty( const double &PENALTY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_assignment_gap_simple.h</td>
        <td>AssignmentGapSimple</td>
        <td>operator ()( const size_t &SIZE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_assignment_with_gap.h</td>
        <td>AssignmentWithGap</td>
        <td>AssignmentWithGap( const util::ShPtr< function::BinaryInterface< const t_Member, const t_Member, double> > &SCORE_PAIR, const double ENCLOSED_SINGLE_GAP = 0.0, const double ENCLOSED_MULTIPLE_GAP = 0.0, const double BOUNDARY_SINGLE_GAP = 0.0, const double BOUNDARY_MULTIPLE_GAP = 0.0 )
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_assignment_with_gap.h</td>
        <td>AssignmentWithGap</td>
        <td>AssignmentWithGap()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_assignment_with_gap.h</td>
        <td>AssignmentWithGap</td>
        <td>ScoreGapBoundaryExtend( const size_t SIZE = 1) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_assignment_with_gap.h</td>
        <td>AssignmentWithGap</td>
        <td>ScoreGapBoundaryOpen( const size_t SIZE = 1) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_assignment_with_gap.h</td>
        <td>AssignmentWithGap</td>
        <td>ScoreGapEnclosedExtend( const size_t SIZE = 1) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_assignment_with_gap.h</td>
        <td>AssignmentWithGap</td>
        <td>ScoreGapEnclosedOpen( const size_t SIZE = 1) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_assignment_with_gap.h</td>
        <td>AssignmentWithGap</td>
        <td>operator ()( const align::Assignment< t_Member> &ASSIGNMENT) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_assignment_with_gap.h</td>
        <td>AssignmentWithGap</td>
        <td>operator ()( const align::Assignment< t_Member> &ASSIGNMENT_A, const align::Assignment< t_Member> &ASSIGNMENT_B ) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_assignment_with_gap.h</td>
        <td>AssignmentWithGap</td>
        <td>operator ()( const util::SiPtr< const t_Member> &MEMBER_A, const util::SiPtr< const t_Member> &MEMBER_B ) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_assignment.h</td>
        <td>BodyAssignment</td>
        <td>BodyAssignment( const math::BinaryFunctionInterfaceSerializable< assemble::SSEGeometryInterface, assemble::SSE, double> &BODY_AGREEMENT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_assignment.h</td>
        <td>BodyAssignment</td>
        <td>BodyAssignment( const util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSEGeometryInterface, assemble::SSE, double> > &BODY_AGREEMENT )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_assignment.h</td>
        <td>BodyAssignment</td>
        <td>BodyAssignment()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_assignment.h</td>
        <td>BodyAssignment</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_assignment.h</td>
        <td>BodyAssignment</td>
        <td>operator ()( const restraint::SSEAssignment &ASSIGNMENT ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_connectivity_density.h</td>
        <td>BodyConnectivityDensity</td>
        <td>BodyConnectivityDensity( const storage::Map< density::Connectivity, double, density::Connectivity::LessThan> &CONNECTIVITY_SCORES, const util::ShPtr< restraint::Body> &BODY_RESTRAINT, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_connectivity_density.h</td>
        <td>BodyConnectivityDensity</td>
        <td>BodyConnectivityDensity( const util::ShPtr< restraint::Body> &BODY_RESTRAINT, const util::ShPtr< density::Map> &DENSITY_MAP, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_connectivity_density.h</td>
        <td>BodyConnectivityDensity</td>
        <td>BodyConnectivityDensity()
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_connectivity_density.h</td>
        <td>BodyConnectivityDensity</td>
        <td>GetBodyRestraint() const
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_connectivity_density.h</td>
        <td>BodyConnectivityDensity</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_connectivity_density.h</td>
        <td>BodyConnectivityDensity</td>
        <td>GetScheme() const
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_connectivity_density.h</td>
        <td>BodyConnectivityDensity</td>
        <td>GetScores() const
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_connectivity_density.h</td>
        <td>BodyConnectivityDensity</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns, linders</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_extent_agreement.h</td>
        <td>BodyExtentAgreement</td>
        <td>BodyExtentAgreement( const double LOWER_TOLERANCE, const double LOWER_TRANSITION_WIDTH, const double UPPER_TOLERANCE, const double UPPER_TRANSITION_WIDTH, const double ENERGY_WELL_DEPTH, const coord::Axis &AXIS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_extent_agreement.h</td>
        <td>BodyExtentAgreement</td>
        <td>BodyExtentAgreement()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_extent_agreement.h</td>
        <td>BodyExtentAgreement</td>
        <td>GetExtentDeviation( const coord::GeometryInterface &BODY_A, const coord::GeometryInterface &BODY_B ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_extent_agreement.h</td>
        <td>BodyExtentAgreement</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_extent_agreement.h</td>
        <td>BodyExtentAgreement</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_extent_agreement.h</td>
        <td>BodyExtentAgreement</td>
        <td>operator ()( const assemble::SSEGeometryInterface &BODY, const assemble::SSE &SSE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_extent_position_agreement.h</td>
        <td>BodyExtentPositionAgreement</td>
        <td>BodyExtentPositionAgreement()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_extent_position_agreement.h</td>
        <td>BodyExtentPositionAgreement</td>
        <td>GetAbsoluteExtentDeviation( const coord::GeometryInterface &BODY_A, const coord::GeometryInterface &BODY_B, const coord::Axis &AXIS ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_extent_position_agreement.h</td>
        <td>BodyExtentPositionAgreement</td>
        <td>GetExtentPosition( const coord::GeometryInterface &BODY, const coord::Axis &AXIS) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_body_extent_position_agreement.h</td>
        <td>BodyExtentPositionAgreement</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_body_extent_position_agreement.h</td>
        <td>BodyExtentPositionAgreement</td>
        <td>operator ()( const assemble::SSEGeometryInterface &BODY, const assemble::SSE &SSE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_consensus_enrichment.h</td>
        <td>ConsensusEnrichment</td>
        <td>ConsensusEnrichment( const storage::Table< double> &SCORES_RMSD_TABLE, const std::string &ENRICHMENT_COL, const ROCProperty &ROC_PROPERTY, const util::ShPtr< math::FunctionInterfaceSerializable< double, bool> > &SP_UNARY_PREDICATE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_consensus_enrichment.h</td>
        <td>ConsensusEnrichment</td>
        <td>ConsensusEnrichment()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_consensus_enrichment.h</td>
        <td>ConsensusEnrichment</td>
        <td>operator ()( const linal::Vector< double> &WEIGHTS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>ContactOrder( const contact::Order::NormalizationType NORMALIZATION_TYPE, const bool NORMALIZE = false, const std::string &SCHEME = GetDefaultScheme(), const bool CACHE = false )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>ContactOrder()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetContactOrderFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetDefaultHistogramFilename( const contact::Order::NormalizationType &NORMALIZATION_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetEnergyFunction() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetHistogramFilename() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetReadableScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetType() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>HistogramsFromColumns( const storage::Table< double> &TABLE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_contact_order.h</td>
        <td>ContactOrder</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_bipolar.h</td>
        <td>DataSetPairwiseBipolar</td>
        <td>CalculateResiduePositionWeight( const assemble::SSEPool &SSE_POOL)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_bipolar.h</td>
        <td>DataSetPairwiseBipolar</td>
        <td>CalculateWeight( const assemble::SSE &SSE, const biol::AABase &AA_BASE, const bool N_TERMINUS)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_bipolar.h</td>
        <td>DataSetPairwiseBipolar</td>
        <td>DataSetPairwiseBipolar( const assemble::SSEPool &SSE_POOL, const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_bipolar.h</td>
        <td>DataSetPairwiseBipolar</td>
        <td>DataSetPairwiseBipolar( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_bipolar.h</td>
        <td>DataSetPairwiseBipolar</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_bipolar.h</td>
        <td>DataSetPairwiseBipolar</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_bipolar.h</td>
        <td>DataSetPairwiseBipolar</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>CalculateAverageDistanceToExcludedCoordinates( const storage::Map < util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, storage::Vector< linal::Vector3D>, assemble::LocatorAtomCoordinatesInterface::PtrLessThan > &COORDINATE_MAP, const storage::List< linal::Vector3D> &EXCLUSION_COORDINATES )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>CalculateExclusionScore( const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR, const DistanceMap &DISTANCE_MAP, const double RADIUS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>DataSetPairwiseCoordinateExclusion( const double &EXCLUSION_RADIUS, std::istream &READ, const size_t X_COORD_COLUMN, const size_t Y_COORD_COLUMN, const size_t Z_COORD_COLUMN, const storage::Set < util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, assemble::LocatorAtomCoordinatesInterface::PtrLessThan > &ALL_POSSIBLE_DATA_POINTS, const assemble::ProteinEnsemble &ENSEMBLE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>DataSetPairwiseCoordinateExclusion( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>FillDistanceMap( std::istream &READ, const size_t X_COORD_COLUMN, const size_t Y_COORD_COLUMN, const size_t Z_COORD_COLUMN, const storage::Set < util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, assemble::LocatorAtomCoordinatesInterface::PtrLessThan > &ALL_POSSIBLE_DATA_POINTS, const assemble::ProteinEnsemble &ENSEMBLE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>LocateCoordinates( const storage::Set < util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, assemble::LocatorAtomCoordinatesInterface::PtrLessThan > &ALL_POSSIBLE_DATA_POINTS, const assemble::ProteinEnsemble &ENSEMBLE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>ReadCoordinates( std::istream &READ, const size_t X_COORD_COLUMN, const size_t Y_COORD_COLUMN, const size_t Z_COORD_COLUMN )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_coordinate_exclusion.h</td>
        <td>DataSetPairwiseCoordinateExclusion</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_coordinate_triangulation.h</td>
        <td>DataSetPairwiseCoordinateTriangulation</td>
        <td>DataSetPairwiseCoordinateTriangulation( const double &RADIUS_CUTOFF, const util::ShPtr< assemble::ProteinEnsemble> &ENSEMBLE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_coordinate_triangulation.h</td>
        <td>DataSetPairwiseCoordinateTriangulation</td>
        <td>DataSetPairwiseCoordinateTriangulation( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_coordinate_triangulation.h</td>
        <td>DataSetPairwiseCoordinateTriangulation</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_coordinate_triangulation.h</td>
        <td>DataSetPairwiseCoordinateTriangulation</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_coordinate_triangulation.h</td>
        <td>DataSetPairwiseCoordinateTriangulation</td>
        <td>UsableLocator( storage::Set < util::ShPtr< assemble::LocatorAtomCoordinatesInterface>, assemble::LocatorAtomCoordinatesInterface::PtrLessThan > &USED_LOCATORS, const assemble::ProteinEnsemble &ENSEMBLE, const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR, const double DISTANCE_THRESHOLD )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_coordinate_triangulation.h</td>
        <td>DataSetPairwiseCoordinateTriangulation</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_data_density.h</td>
        <td>DataSetPairwiseDataDensity</td>
        <td>CalculateDensityScore( const util::ShPtrList< assemble::LocatorAtomCoordinatesInterface> &DATA_POINTS, const size_t INTERVAL, const size_t NUM_INTERVALS ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_data_density.h</td>
        <td>DataSetPairwiseDataDensity</td>
        <td>DataSetPairwiseDataDensity( const size_t SEQUENCE_SIZE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_data_density.h</td>
        <td>DataSetPairwiseDataDensity</td>
        <td>DataSetPairwiseDataDensity( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_data_density.h</td>
        <td>DataSetPairwiseDataDensity</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_data_density.h</td>
        <td>DataSetPairwiseDataDensity</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_data_density.h</td>
        <td>DataSetPairwiseDataDensity</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_distance_change_magnitude.h</td>
        <td>DataSetPairwiseDistanceChangeMagnitude</td>
        <td>DataSetPairwiseDistanceChangeMagnitude( const assemble::ProteinEnsemble &ENSEMBLE_A, const assemble::ProteinEnsemble &ENSEMBLE_B, const restraint::DataSetPairwise &FULL_DATA_SET, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_distance_change_magnitude.h</td>
        <td>DataSetPairwiseDistanceChangeMagnitude</td>
        <td>DataSetPairwiseDistanceChangeMagnitude( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_distance_change_magnitude.h</td>
        <td>DataSetPairwiseDistanceChangeMagnitude</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_distance_change_magnitude.h</td>
        <td>DataSetPairwiseDistanceChangeMagnitude</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_distance_change_magnitude.h</td>
        <td>DataSetPairwiseDistanceChangeMagnitude</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_euclidian_distance.h</td>
        <td>DataSetPairwiseEuclidianDistance</td>
        <td>DataSetPairwiseEuclidianDistance( const math::Range< double> &RANGE, const assemble::ProteinModel &MODEL, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_euclidian_distance.h</td>
        <td>DataSetPairwiseEuclidianDistance</td>
        <td>DataSetPairwiseEuclidianDistance( const math::Range< double> &RANGE, const util::ShPtr< assemble::ProteinEnsemble> &ENSEMBLE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_euclidian_distance.h</td>
        <td>DataSetPairwiseEuclidianDistance</td>
        <td>DataSetPairwiseEuclidianDistance( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_euclidian_distance.h</td>
        <td>DataSetPairwiseEuclidianDistance</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_euclidian_distance.h</td>
        <td>DataSetPairwiseEuclidianDistance</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_euclidian_distance.h</td>
        <td>DataSetPairwiseEuclidianDistance</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_residue_type_exclusion.h</td>
        <td>DataSetPairwiseResidueTypeExclusion</td>
        <td>DataSetPairwiseResidueTypeExclusion( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_residue_type_exclusion.h</td>
        <td>DataSetPairwiseResidueTypeExclusion</td>
        <td>DataSetPairwiseResidueTypeExclusion( const storage::Set< biol::AAType> AA_TYPES, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_residue_type_exclusion.h</td>
        <td>DataSetPairwiseResidueTypeExclusion</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_residue_type_exclusion.h</td>
        <td>DataSetPairwiseResidueTypeExclusion</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_residue_type_exclusion.h</td>
        <td>DataSetPairwiseResidueTypeExclusion</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sequence_separation.h</td>
        <td>DataSetPairwiseSequenceSeparation</td>
        <td>CalculateSequenceSeparation( const char CHAIN_ID_A, const int SEQ_ID_A, const char CHAIN_ID_B, const int SEQ_ID_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sequence_separation.h</td>
        <td>DataSetPairwiseSequenceSeparation</td>
        <td>DataSetPairwiseSequenceSeparation( const size_t SEQUENCE_SIZE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sequence_separation.h</td>
        <td>DataSetPairwiseSequenceSeparation</td>
        <td>DataSetPairwiseSequenceSeparation( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sequence_separation.h</td>
        <td>DataSetPairwiseSequenceSeparation</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sequence_separation.h</td>
        <td>DataSetPairwiseSequenceSeparation</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sequence_separation.h</td>
        <td>DataSetPairwiseSequenceSeparation</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_size.h</td>
        <td>DataSetPairwiseSize</td>
        <td>DataSetPairwiseSize( const size_t &SIZE_RANGE_MIN, const size_t &SIZE_RANGE_MAX, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_size.h</td>
        <td>DataSetPairwiseSize</td>
        <td>DataSetPairwiseSize( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_size.h</td>
        <td>DataSetPairwiseSize</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_size.h</td>
        <td>DataSetPairwiseSize</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_size.h</td>
        <td>DataSetPairwiseSize</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_center.h</td>
        <td>DataSetPairwiseSSECenter</td>
        <td>CalculateResiduePositionWeight( const assemble::SSEPool &SSE_POOL)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_center.h</td>
        <td>DataSetPairwiseSSECenter</td>
        <td>CalculateWeight( const assemble::SSE &SSE, const biol::AABase &AA_BASE)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_center.h</td>
        <td>DataSetPairwiseSSECenter</td>
        <td>DataSetPairwiseSSECenter( const assemble::SSEPool &SSE_POOL, const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_center.h</td>
        <td>DataSetPairwiseSSECenter</td>
        <td>DataSetPairwiseSSECenter( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_center.h</td>
        <td>DataSetPairwiseSSECenter</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_center.h</td>
        <td>DataSetPairwiseSSECenter</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_center.h</td>
        <td>DataSetPairwiseSSECenter</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_connection.h</td>
        <td>DataSetPairwiseSSEConnection</td>
        <td>CalculateSSEConnectionScoreComponentC( const storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t> &SSE_PAIRS_COUNTS, const size_t C_PRIME, const size_t C_PRIME_PRIME, const size_t NUM_SSE_PAIRS, const size_t REMAINDER )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_connection.h</td>
        <td>DataSetPairwiseSSEConnection</td>
        <td>CalculateSSEConnectionScoreComponentR( const storage::Map< storage::VectorND< 2, util::SiPtr< const assemble::SSE> >, size_t> &SSE_PAIRS_COUNTS, const size_t C_PRIME_PRIME, const size_t NUMBER_RESTRAINTS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_connection.h</td>
        <td>DataSetPairwiseSSEConnection</td>
        <td>DataSetPairwiseSSEConnection( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_connection.h</td>
        <td>DataSetPairwiseSSEConnection</td>
        <td>DataSetPairwiseSSEConnection( const util::ShPtr< assemble::SSEPool> &SSE_POOL, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_connection.h</td>
        <td>DataSetPairwiseSSEConnection</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_connection.h</td>
        <td>DataSetPairwiseSSEConnection</td>
        <td>GetSSEPairCounts( const storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> &SSES, const restraint::DataSetPairwise &DATA )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_connection.h</td>
        <td>DataSetPairwiseSSEConnection</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_connection.h</td>
        <td>DataSetPairwiseSSEConnection</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_size.h</td>
        <td>DataSetPairwiseSSESize</td>
        <td>DataSetPairwiseSSESize( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_size.h</td>
        <td>DataSetPairwiseSSESize</td>
        <td>DataSetPairwiseSSESize( const util::ShPtr< assemble::SSEPool> &SSE_POOL, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_size.h</td>
        <td>DataSetPairwiseSSESize</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_size.h</td>
        <td>DataSetPairwiseSSESize</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_size.h</td>
        <td>DataSetPairwiseSSESize</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_term.h</td>
        <td>DataSetPairwiseSSETerm</td>
        <td>CalculateSSEScoreComponentL( const storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap> &SSE_COUNT, const size_t Q_PRIME_PRIME, const size_t NUMBER_OF_POINTS )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_term.h</td>
        <td>DataSetPairwiseSSETerm</td>
        <td>CalculateSSEScoreComponentS( const storage::Map< util::SiPtr< const assemble::SSE>, size_t, assemble::SSELessThanNoOverlap> &SSE_COUNT, const size_t Q_PRIME, const size_t Q_PRIME_PRIME, const size_t REMAINDER, const size_t NUMBER_SSES )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_term.h</td>
        <td>DataSetPairwiseSSETerm</td>
        <td>DataSetPairwiseSSETerm( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_term.h</td>
        <td>DataSetPairwiseSSETerm</td>
        <td>DataSetPairwiseSSETerm( const util::ShPtr< assemble::SSEPool> &SSE_POOL, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_term.h</td>
        <td>DataSetPairwiseSSETerm</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_term.h</td>
        <td>DataSetPairwiseSSETerm</td>
        <td>GetSSECounts( const storage::Set< util::SiPtr< const assemble::SSE>, assemble::SSELessThanNoOverlap> &SSES, const restraint::DataSetPairwise &DATA )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_sse_term.h</td>
        <td>DataSetPairwiseSSETerm</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_sse_term.h</td>
        <td>DataSetPairwiseSSETerm</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_structural_exposure.h</td>
        <td>DataSetPairwiseStructuralExposure</td>
        <td>CalculateExposureScore( const util::ShPtr< assemble::LocatorAtomCoordinatesInterface> &LOCATOR, const ExposureMap &EXPOSURE_MAP, const double EXPOSURE_CUTOFF )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_structural_exposure.h</td>
        <td>DataSetPairwiseStructuralExposure</td>
        <td>DataSetPairwiseStructuralExposure( const double &EXPOSURE_CUTOFF, const assemble::ProteinEnsemble &ENSEMBLE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_structural_exposure.h</td>
        <td>DataSetPairwiseStructuralExposure</td>
        <td>DataSetPairwiseStructuralExposure( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_structural_exposure.h</td>
        <td>DataSetPairwiseStructuralExposure</td>
        <td>FillExposureMap( const assemble::ProteinEnsemble &ENSEMBLE, ExposureMap &EXPOSURE_MAP)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_structural_exposure.h</td>
        <td>DataSetPairwiseStructuralExposure</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_data_set_pairwise_structural_exposure.h</td>
        <td>DataSetPairwiseStructuralExposure</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_data_set_pairwise_structural_exposure.h</td>
        <td>DataSetPairwiseStructuralExposure</td>
        <td>operator ()( const restraint::DataSetPairwise &DATA) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_density_profile_sse_agreement.h</td>
        <td>DensityProfileSSEAgreement</td>
        <td>DensityProfileSSEAgreement( const util::ShPtr< density::SimulateInterface> &SP_SIMULATOR, const density::Map &DENSITY_MAP, const restraint::Body &BODY_RESTRAINT, const Profile1DType PROFILE_TYPE )
</td>
        <td>pereirkn, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_density_profile_sse_agreement.h</td>
        <td>DensityProfileSSEAgreement</td>
        <td>DensityProfileSSEAgreement()
</td>
        <td>pereirkn, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_density_profile_sse_agreement.h</td>
        <td>DensityProfileSSEAgreement</td>
        <td>GetProfile1DTypeString( const Profile1DType &PROFILE_1D_TYPE)
</td>
        <td>pereirkn, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_density_profile_sse_agreement.h</td>
        <td>DensityProfileSSEAgreement</td>
        <td>GetScheme() const
</td>
        <td>pereirkn, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_density_profile_sse_agreement.h</td>
        <td>DensityProfileSSEAgreement</td>
        <td>operator ()( const assemble::SSEGeometryInterface &BODY, const assemble::SSE &SECONDAY_STRUCTURE_ELEMENT ) const
</td>
        <td>pereirkn, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>AAEnvironmentPotential( const math::Histogram &AA_ENV_DISTRIBUTION, const math::Histogram &BACKGROUND_DISTRIBUTION, const bool NORMALIZE_BY_BACKGROUND = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>AAEnvironmentPotential( const storage::Vector< math::Histogram> &HISTOGRMAS_AA )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>AAMembraneEnvironmentPotential( const storage::Vector< storage::Vector< math::Histogram> > &HISTOGRMAS_MEMBRANE_AA )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>AAPairPotential( const math::Histogram &AA_PAIR_DISTANCE_DISTRIBUTION, const math::Histogram &BACKGROUND_DISTRIBUTION, const bool NORMALIZE_BY_BACKGROUND )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>AngleAlignmentPotential( const math::Histogram &HISTOGRAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>DistanceAngleContactEnergy( const math::Histogram3D &HISTOGRAM, const double &ENERGY )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>EPRDistance( const math::Histogram2D &HISTOGRAM, const math::Range< double> &DISTANCE_RANGE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>EnergyfunctionFromHistogram( const math::Histogram &HISTOGRAM, const double PSEUDOCOUNT = double( s_PseudoCount) )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>GeneratePotentialFromHistogram( const math::Histogram &HISTOGRAM, const double PSEUDOCOUNT, const math::SplineBorderType BORDER_FLAG, const storage::Pair< double, double> &FIRST_DERIVATIVE = GetDefaultFirstDerivative(), const bool NORMALIZE_ENERGIES = false, const bool BONUS_ONLY = false )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>GetDefaultFirstDerivative()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>LoopLengthDistancePotential( const math::Histogram &LOOPLENGTHDISTRIBUTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>LoopLengthDistancePotential( const math::Histogram2D &LOOPLENGTHDISTRIBUTION, const size_t MAX_RESIDUES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>LoopLengthDistancePotential( const storage::Vector< math::Histogram> &LOOPLENGTH_DISTRIBUTIONS )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>PhiPsiAnglePotential( const math::Histogram2D &PHI_PSI_ANGLE_DISTRIBUTION, const math::Histogram2D &BACKGROUND, const bool NORMALIZE_BY_BACKGROUND = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>ProbabilityOfAAPairTOBeWithinDistance( const double &DISTANCE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>ReadAAPairDistanceHistogram( const double DISTANCE_CUTOFF)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>RemoveAdditionalEmptyBinsExceptOne( util::SiPtrVector< math::Histogram> &HISTOGRAMS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>SSEPacking2D( const math::Histogram2D &ANGLE_DISTANCE_DISTRIBUTION, const math::Range< double> &DISTANCE_RANGE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_energy_distribution.h</td>
        <td>EnergyDistribution</td>
        <td>SSEPackingSymmetrize( const math::Histogram2D &ANGLE_DISTANCE_DISTRIBUTION, const math::Range< double> &DISTANCE_RANGE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_environment_predictions.h</td>
        <td>EnvironmentPredictions</td>
        <td>EnvironmentPredictions( const sspred::Method &SS_METHOD, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_environment_predictions.h</td>
        <td>EnvironmentPredictions</td>
        <td>EnvironmentPredictions()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_environment_predictions.h</td>
        <td>EnvironmentPredictions</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_environment_predictions.h</td>
        <td>EnvironmentPredictions</td>
        <td>GetDefaultScheme()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_environment_predictions.h</td>
        <td>EnvironmentPredictions</td>
        <td>GetMethod() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_environment_predictions.h</td>
        <td>EnvironmentPredictions</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_environment_predictions.h</td>
        <td>EnvironmentPredictions</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &THIS_SSE, const biol::Membrane &MEMBRANE, std::ostream &OSTREAM ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_environment_predictions.h</td>
        <td>EnvironmentPredictions</td>
        <td>operator ()( const assemble::SSE &SSE, const biol::Membrane &MEMBRANE ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_epr_accessibility.h</td>
        <td>EPRAccessibility</td>
        <td>EPRAccessibility( const std::string &SCHEME = GetDefaultScheme(), const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename() )
</td>
        <td>alexanns, karakam, rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_epr_accessibility.h</td>
        <td>EPRAccessibility</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>alexanns, karakam, rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_epr_accessibility.h</td>
        <td>EPRAccessibility</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, karakam, rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_epr_accessibility.h</td>
        <td>EPRAccessibility</td>
        <td>GetEnergyFunction() const
</td>
        <td>alexanns, karakam, rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_epr_accessibility.h</td>
        <td>EPRAccessibility</td>
        <td>GetHistogramFilename() const
</td>
        <td>alexanns, karakam, rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_epr_accessibility.h</td>
        <td>EPRAccessibility</td>
        <td>GetScheme() const
</td>
        <td>alexanns, karakam, rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_epr_accessibility.h</td>
        <td>EPRAccessibility</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, karakam, rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_epr_accessibility.h</td>
        <td>EPRAccessibility</td>
        <td>operator ()( const restraint::Assignment < storage::Map< restraint::AccessibilityAA::EnvironmentEnum, double>, double, biol::AABase > &ASSIGNMENT ) const
</td>
        <td>alexanns, karakam, rouvelgh, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_fuzzy_logic_filter.h</td>
        <td>FuzzyLogicFilter</td>
        <td>FuzzyLogicFilter( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_fuzzy_logic_filter.h</td>
        <td>FuzzyLogicFilter</td>
        <td>GetDefaultScheme()
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_fuzzy_logic_filter.h</td>
        <td>FuzzyLogicFilter</td>
        <td>GetScheme() const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_fuzzy_logic_filter.h</td>
        <td>FuzzyLogicFilter</td>
        <td>operator ()( const restraint::AtomDistanceAssignment &RESTRAINT) const
</td>
        <td>akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_log_normal_distribution.h</td>
        <td>LogNormalDistribution</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_log_normal_distribution.h</td>
        <td>LogNormalDistribution</td>
        <td>GetScheme() const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_log_normal_distribution.h</td>
        <td>LogNormalDistribution</td>
        <td>LogNormalDistribution( const double &KVARIABLE)
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_log_normal_distribution.h</td>
        <td>LogNormalDistribution</td>
        <td>LogNormalDistribution()
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_log_normal_distribution.h</td>
        <td>LogNormalDistribution</td>
        <td>operator ()( const restraint::AtomDistanceAssignment &RESTRAINT) const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>CalculateMaximumObservedDistances( const std::string &HISTOGRAM_FILENAME, const size_t MAX_NR_LOOP_RESIDUES, const double FRACTION )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>GetDefaultMaxLoopLength()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>GetDefaultTableFilename()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>GetEnergyFunctionAboveMaxLoopLength() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>GetEnergyFunctions() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>GetMaxLoopLength() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>Loop( const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const std::string &SCHEME = GetDefaultScheme(), const size_t MAX_LOOP_LENGTH = GetDefaultMaxLoopLength() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>NormalizeDistance( const storage::Pair< size_t, double> &SEQ_EUC_DISTANCE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>Score( const storage::Pair< size_t, double> &SEQ_EUC_DISTANCE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>SequenceAndEuclideanDistance( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop.h</td>
        <td>Loop</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>CalculateCosAngle( const assemble::SSE &SSE_FIRST, const assemble::SSE &SSE_SECOND, const linal::Vector3D &CENTER_OF_MASS ) const
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetDefaultMaxmimumSequenceDistance()
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetDefaultScheme()
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetDefaultTableFilename()
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetEnergyFunctions() const
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetHistogramFileName() const
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetMaxSequenceDistance() const
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetScheme() const
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetSerializer() const
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetType() const
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>LoopAngle( const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const size_t &MAX_SEQ_DISTANCE = GetDefaultMaxmimumSequenceDistance(), const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &MODEL, std::ostream &OSTREAM) const
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>heinzes1, putnamdk, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetNrExcludedResidues() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetSigmoidWidth() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>LoopClosure( const size_t NR_EXCLUDED_RESIDUES, const double SIGMOID_WIDTH, const double FRACTION_ALLOWED_DISTANCE, const bool EXCLUDE_COIL = true )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>LoopClosure()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>ScoreLoop( const storage::Pair< size_t, double> &SEQ_EUC_DISTANCE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>SequenceAndEuclideanDistanceWithExclusion( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B, const size_t NR_EXCLUDED_RESIDUES )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B, std::ostream &OSTREAM ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>operator ()( const assemble::Chain &CHAIN) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>GetAATypeEnergyFunctions() const
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>GetEnergyFunctions() const
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>GetEnergyFunctionsMembrane() const
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>GetHistogramFilename() const
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>GetSSTypes() const
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>GetScheme() const
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>PhiPsi( const std::string &SCHEME, const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const storage::Set< biol::SSType> &SSTYPE_SET = storage::Set< biol::SSType>() )
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>PhiPsi()
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>ReadEnergyVector()
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>ScoreAAPhiPsi( const math::BicubicSpline &AATYPE_ENERGY, const biol::AABase &AA_BASE, const biol::AABase &AA_PREVIOUS, const biol::AABase &AA_NEXT )
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>ScorePhiPsiSSTypeIndependent( const assemble::SSE &THIS_SSE) const
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>ScoreSequencePhiPsi( const biol::AASequence &AA_SEQUENCE, const storage::Map< biol::AAType, math::BicubicSpline> &AATYPE_ENERGY_MAP_SOLUBLE, const storage::Map< biol::AAType, math::BicubicSpline> &AATYPE_ENERGY_MAP_MEMBRANE, const biol::Membrane &MEMBRANE )
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>SetSSTypes( const storage::Set< biol::SSType> &SS_TYPES)
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi.h</td>
        <td>PhiPsi</td>
        <td>operator ()( const assemble::SSE &THIS_SSE, const biol::Membrane &MEMBRANE ) const
</td>
        <td>alexanns, karakam, rouvelgh, fischea, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>GetEnergyMap() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>GetHistogramFilename() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>GetSSMethods() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>PhiPsiWithSSPred( const storage::Set< sspred::Method> &SS_METHODS, const std::string &SCHEME = GetDefaultScheme(), const std::string &HISTOGRAM_FILENAME = PhiPsi::GetDefaultHistogramFilename() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>PhiPsiWithSSPred()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_phi_psi_with_sspred.h</td>
        <td>PhiPsiWithSSPred</td>
        <td>operator ()( const assemble::SSE &SSE, const biol::Membrane &MEMBRANE ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_pofr.h</td>
        <td>PofR</td>
        <td>PofR()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_pofr.h</td>
        <td>PofR</td>
        <td>operator ()( const restraint::SasExperimentalAndCalculatedDensity &SAS_DATA) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_porf.cpp</td>
        <td></td>
        <td>AddInstance( new PofR())
</td>
        <td></td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_atom_density.h</td>
        <td>ProteinAtomDensity</td>
        <td>CalculateAverageAtomDensity( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_atom_density.h</td>
        <td>ProteinAtomDensity</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_atom_density.h</td>
        <td>ProteinAtomDensity</td>
        <td>ProteinAtomDensity( const storage::Set< biol::SSType> &SSE_TYPES, const storage::Set< biol::AtomType> &ATOM_TYPES, const linal::Vector3D &RESOLUTION )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_atom_density.h</td>
        <td>ProteinAtomDensity</td>
        <td>ProteinAtomDensity()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_atom_density.h</td>
        <td>ProteinAtomDensity</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetReadableScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetType() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model.h</td>
        <td>ProteinModel</td>
        <td>GetTypeName( const Type &TYPE)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model.h</td>
        <td>ProteinModel</td>
        <td>IsQualityScore() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model.h</td>
        <td>ProteinModelLessThan</td>
        <td>operator ()( const ProteinModel &PROTEIN_MODEL_LHS, const ProteinModel &PROTEIN_MODEL_RHS) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model.h</td>
        <td>ProteinModelLessThan</td>
        <td>operator ()( const util::PtrInterface< ProteinModel> &PROTEIN_MODEL_LHS, const util::PtrInterface< ProteinModel> &PROTEIN_MODEL_RHS ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model.h</td>
        <td>ProteinModelLessThan</td>
        <td>operator ()( const util::PtrInterface< const ProteinModel> &PROTEIN_MODEL_LHS, const util::PtrInterface< const ProteinModel> &PROTEIN_MODEL_RHS ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_aa_neighborhood.h</td>
        <td>ProteinModelAANeighborhood</td>
        <td>GetReadableScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_aa_neighborhood.h</td>
        <td>ProteinModelAANeighborhood</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_aa_neighborhood.h</td>
        <td>ProteinModelAANeighborhood</td>
        <td>GetType() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_aa_neighborhood.h</td>
        <td>ProteinModelAANeighborhood</td>
        <td>GetTypeName( const NormalizationType &TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_aa_neighborhood.h</td>
        <td>ProteinModelAANeighborhood</td>
        <td>GetTypeSuffix( const NormalizationType &TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_aa_neighborhood.h</td>
        <td>ProteinModelAANeighborhood</td>
        <td>ProteinModelAANeighborhood( const util::ShPtr< AANeighborhoodInterface> &SP_SCORE_AA_NEIGHBORHOOD, const TypeEnum &TYPE = e_None, const bool CONSIDER_DIFFERENT_CHAIN = true, const ProteinModel::Type &SCORE_TYPE = ProteinModel::e_Undefined, const std::string &READABLE_SCHEME = Ó )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_aa_neighborhood.h</td>
        <td>ProteinModelAANeighborhood</td>
        <td>ProteinModelAANeighborhood()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_aa_neighborhood.h</td>
        <td>ProteinModelAANeighborhood</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_aa_neighborhood.h</td>
        <td>ProteinModelAANeighborhood</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_aa_neighborhood_docking.h</td>
        <td>ProteinModelAANeighborhoodDocking</td>
        <td>GetScheme() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_aa_neighborhood_docking.h</td>
        <td>ProteinModelAANeighborhoodDocking</td>
        <td>GetSerializer() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_aa_neighborhood_docking.h</td>
        <td>ProteinModelAANeighborhoodDocking</td>
        <td>ProteinModelAANeighborhoodDocking( const AANeighborhoodInterface &SCORE_AA_NEIGHBORHOOD, const std::string &SCHEME )
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_aa_neighborhood_docking.h</td>
        <td>ProteinModelAANeighborhoodDocking</td>
        <td>ProteinModelAANeighborhoodDocking()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_aa_neighborhood_docking.h</td>
        <td>ProteinModelAANeighborhoodDocking</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_aa_neighborhood_docking.h</td>
        <td>ProteinModelAANeighborhoodDocking</td>
        <td>ReadPredictions( const storage::Vector< storage::Pair< int, std::string> > &CHAIN_EXPOSURE, biol::AASequence &SEQUENCE )
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_aa_neighborhood_docking.h</td>
        <td>ProteinModelAANeighborhoodDocking</td>
        <td>ReadPredictions( std::istream &ISTREAM, assemble::ProteinModel &PROTEIN_MODEL)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_aa_neighborhood_docking.h</td>
        <td>ProteinModelAANeighborhoodDocking</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_completeness.h</td>
        <td>ProteinModelCompleteness</td>
        <td>GetDefaultScheme()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_completeness.h</td>
        <td>ProteinModelCompleteness</td>
        <td>GetScheme() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_completeness.h</td>
        <td>ProteinModelCompleteness</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_completeness.h</td>
        <td>ProteinModelCompleteness</td>
        <td>ProteinModelCompleteness( bool IGNORE_TERM_LOOPS = false, const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_completeness.h</td>
        <td>ProteinModelCompleteness</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_defined_loops.h</td>
        <td>ProteinModelDefinedLoops</td>
        <td>GetDefaultScheme()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_defined_loops.h</td>
        <td>ProteinModelDefinedLoops</td>
        <td>GetScheme() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_defined_loops.h</td>
        <td>ProteinModelDefinedLoops</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_defined_loops.h</td>
        <td>ProteinModelDefinedLoops</td>
        <td>ProteinModelDefinedLoops( bool IGNORE_TERM_LOOPS = false, const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_defined_loops.h</td>
        <td>ProteinModelDefinedLoops</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_fragment_topology.h</td>
        <td>ProteinModelFragmentTopology</td>
        <td>operator ()( const assemble::ProteinModel &TEMPLATE, const assemble::ProteinModel &MODEL) const
</td>
        <td>mendenjl, fooksams</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_gap.h</td>
        <td>ProteinModelGap</td>
        <td>GetDefaultScheme()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_gap.h</td>
        <td>ProteinModelGap</td>
        <td>GetScheme() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_gap.h</td>
        <td>ProteinModelGap</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_gap.h</td>
        <td>ProteinModelGap</td>
        <td>ProteinModelGap( const std::string &SCHEME = GetDefaultScheme())
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_gap.h</td>
        <td>ProteinModelGap</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_inverted.h</td>
        <td>ProteinModelInverted</td>
        <td>GetReadableScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_inverted.h</td>
        <td>ProteinModelInverted</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_inverted.h</td>
        <td>ProteinModelInverted</td>
        <td>GetType() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_inverted.h</td>
        <td>ProteinModelInverted</td>
        <td>ProteinModelInverted( const util::ShPtr< ProteinModel> &SP_SCORE, const util::ShPtr< assemble::ProteinModelInverter> &SP_INVERTER, const std::string &SCHEME, const ProteinModel::Type &SCORE_TYPE = ProteinModel::e_Undefined, const std::string &READABLE_SCHEME = Ó )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_inverted.h</td>
        <td>ProteinModelInverted</td>
        <td>ProteinModelInverted()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_inverted.h</td>
        <td>ProteinModelInverted</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_loop_domain_closure.h</td>
        <td>ProteinModelLoopDomainClosure</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_loop_domain_closure.h</td>
        <td>ProteinModelLoopDomainClosure</td>
        <td>ProteinModelLoopDomainClosure()
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_loop_domain_closure.h</td>
        <td>ProteinModelLoopDomainClosure</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_membrane_topology.h</td>
        <td>ProteinModelMembraneTopology</td>
        <td>GetFlagExpectedTransmembraneHelicesPoolFile()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_membrane_topology.h</td>
        <td>ProteinModelMembraneTopology</td>
        <td>GetReadableScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_membrane_topology.h</td>
        <td>ProteinModelMembraneTopology</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_membrane_topology.h</td>
        <td>ProteinModelMembraneTopology</td>
        <td>GetType() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_membrane_topology.h</td>
        <td>ProteinModelMembraneTopology</td>
        <td>InitializeFromFlag()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_membrane_topology.h</td>
        <td>ProteinModelMembraneTopology</td>
        <td>ProteinModelMembraneTopology( const util::ShPtr< find::LocatorInterface< util::ShPtr< assemble::Domain>, assemble::ProteinModel> > &LOCATOR, const assemble::SSEPool &POOL, const std::string &SCHEME = GetStaticClassName< ProteinModelMembraneTopology>() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_membrane_topology.h</td>
        <td>ProteinModelMembraneTopology</td>
        <td>ProteinModelMembraneTopology()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_membrane_topology.h</td>
        <td>ProteinModelMembraneTopology</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>CreateSortedReadableTable( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>CreateValueTableHorizontal( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>CreateValueTableVertical( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>GetReadableFunctionSchemes() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>ProteinModelScoreSum( const std::string &SCHEME = Ó)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>ProteinModelScoreSum( const storage::Map< fold::Score, double> &SCORE_WEIGHT_MAP )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>ProteinModelScoreSum( const storage::Map< std::string, util::ShPtr< ProteinModel> > &SCORE_MAP, const storage::Map< std::string, double> &WEIGHT_SET )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>ProteinModelScoreSum( const storage::Map< util::ShPtr< ProteinModel>, double> &SCORE_WEIGHT_MAP )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_score_sum.h</td>
        <td>ProteinModelScoreSum</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse.h</td>
        <td>ProteinModelSSE</td>
        <td>GetReadableScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse.h</td>
        <td>ProteinModelSSE</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse.h</td>
        <td>ProteinModelSSE</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse.h</td>
        <td>ProteinModelSSE</td>
        <td>GetType() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse.h</td>
        <td>ProteinModelSSE</td>
        <td>ProteinModelSSE( const util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > > &SP_SINGLE_FUNCTION, const bool NORMALIZE, const ProteinModel::Type &SCORE_TYPE = ProteinModel::e_Undefined, const std::string &READABLE_SCHEME = Ó )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse.h</td>
        <td>ProteinModelSSE</td>
        <td>ProteinModelSSE()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse.h</td>
        <td>ProteinModelSSE</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse.h</td>
        <td>ProteinModelSSE</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_chirality.h</td>
        <td>ProteinModelSSEChirality</td>
        <td>GetPropensities() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_chirality.h</td>
        <td>ProteinModelSSEChirality</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_chirality.h</td>
        <td>ProteinModelSSEChirality</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_chirality.h</td>
        <td>ProteinModelSSEChirality</td>
        <td>ProteinModelSSEChirality( const double &PSEUDOCOUNT = 20.0, const bool &CONTACT_SPECIFIC = false, const bool &SCALE_BY_AAS = true )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_chirality.h</td>
        <td>ProteinModelSSEChirality</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_chirality.h</td>
        <td>ProteinModelSSEChirality</td>
        <td>operator ()( const assemble::Chain &CHAIN, const assemble::SSEPool &MISSING_SSES ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_chirality.h</td>
        <td>ProteinModelSSEChirality</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_completeness.h</td>
        <td>ProteinModelSSECompleteness</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_completeness.h</td>
        <td>ProteinModelSSECompleteness</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_completeness.h</td>
        <td>ProteinModelSSECompleteness</td>
        <td>ProteinModelSSECompleteness( const bool &COUNT_AAS = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_completeness.h</td>
        <td>ProteinModelSSECompleteness</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_linear_loop_proximity.h</td>
        <td>ProteinModelSSELinearLoopProximity</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_linear_loop_proximity.h</td>
        <td>ProteinModelSSELinearLoopProximity</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_linear_loop_proximity.h</td>
        <td>ProteinModelSSELinearLoopProximity</td>
        <td>ProteinModelSSELinearLoopProximity( const bool NORMALIZE = false, const bool CONSIDER_DISTANCE_ALONG_SSE = true, const double &FOOTPOINT_OFFSET = 0.125, const bool &CONSIDER_VIRTUAL_LOOP_CLASHES = true, const size_t &MAXIMUM_LINEAR_LOOP_RESIDUES = 40 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_linear_loop_proximity.h</td>
        <td>ProteinModelSSELinearLoopProximity</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_linear_loop_proximity.h</td>
        <td>ProteinModelSSELinearLoopProximity</td>
        <td>operator ()( const assemble::Chain &CHAIN, const assemble::SSEPool &MISSING_SSES ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_linear_loop_proximity.h</td>
        <td>ProteinModelSSELinearLoopProximity</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_neighbors.h</td>
        <td>ProteinModelSSENeighbors</td>
        <td>GetScheme() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_neighbors.h</td>
        <td>ProteinModelSSENeighbors</td>
        <td>ProteinModelSSENeighbors( const util::ShPtr< math::BinaryFunctionInterface< assemble::SSE, assemble::SSE, double> > &SP_PAIR_FUNCTION, const bool NORMALIZE )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_neighbors.h</td>
        <td>ProteinModelSSENeighbors</td>
        <td>ProteinModelSSENeighbors()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_neighbors.h</td>
        <td>ProteinModelSSENeighbors</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_neighbors.h</td>
        <td>ProteinModelSSENeighbors</td>
        <td>operator ()( const assemble::Chain &CHAIN) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_neighbors.h</td>
        <td>ProteinModelSSENeighbors</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_packing.h</td>
        <td>ProteinModelSSEPacking</td>
        <td>GetScheme() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_packing.h</td>
        <td>ProteinModelSSEPacking</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_packing.h</td>
        <td>ProteinModelSSEPacking</td>
        <td>ProteinModelSSEPacking( const Type &TYPE = e_ContactType)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_packing.h</td>
        <td>ProteinModelSSEPacking</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_packing.h</td>
        <td>ProteinModelSSEPacking</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_pairs.h</td>
        <td>ProteinModelSSEPairs</td>
        <td>GetReadableScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_pairs.h</td>
        <td>ProteinModelSSEPairs</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_pairs.h</td>
        <td>ProteinModelSSEPairs</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_pairs.h</td>
        <td>ProteinModelSSEPairs</td>
        <td>GetType() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_pairs.h</td>
        <td>ProteinModelSSEPairs</td>
        <td>ProteinModelSSEPairs( const util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSE, assemble::SSE, double> > &SP_PAIR_FUNCTION, const bool NORMALIZE, const ProteinModel::Type &SCORE_TYPE = ProteinModel::e_Undefined, const std::string &READABLE_SCHEME = Ó )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_pairs.h</td>
        <td>ProteinModelSSEPairs</td>
        <td>ProteinModelSSEPairs()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_sse_pairs.h</td>
        <td>ProteinModelSSEPairs</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_sse_pairs.h</td>
        <td>ProteinModelSSEPairs</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_topology.h</td>
        <td>ProteinModelTopology</td>
        <td>ProteinModelTopology( score_result RESULT = score_f)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_topology.h</td>
        <td>ProteinModelTopology</td>
        <td>operator ()( const assemble::ProteinModel &TEMPLATE, const assemble::ProteinModel &MODEL) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_wrapper.h</td>
        <td>ProteinModelWrapper</td>
        <td>GetReadableScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_wrapper.h</td>
        <td>ProteinModelWrapper</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_wrapper.h</td>
        <td>ProteinModelWrapper</td>
        <td>GetType() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_wrapper.h</td>
        <td>ProteinModelWrapper</td>
        <td>ProteinModelWrapper( const util::ShPtr< math::FunctionInterfaceSerializable< assemble::ProteinModel, double> > &SP_FUNCTION, const Type &TYPE = e_Undefined, const std::string &READABLE_SCHEME = Ó, const std::string &SCHEME = Ó )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_wrapper.h</td>
        <td>ProteinModelWrapper</td>
        <td>ProteinModelWrapper()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_protein_model_wrapper.h</td>
        <td>ProteinModelWrapper</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &ARGUMENT, std::ostream &OSTREAM ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_protein_model_wrapper.h</td>
        <td>ProteinModelWrapper</td>
        <td>operator ()( const assemble::ProteinModel &ARGUMENT) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetDefaultHistogramFilenameMembrane()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetEnergyFunctionMembrane() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetEnergyFunctionSoluble() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetHistogramFilenameMembrane() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetHistogramFilenameSoluble() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetReadableScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetType() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>HistogramsFromTable( const storage::Table< double> &TABLE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>RadiusOfGyration( const bool NORMALIZE = false, const bool RAW = false, const std::string &SCHEME = Ó, const std::string &SOLUBLE_FILENAME = GetDefaultHistogramFilename(), const std::string &MEMBRANE_FILENAME = GetDefaultHistogramFilenameMembrane() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>SquareRadiusOfGyration( const assemble::ProteinModel &PROTEIN_MODEL)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>SquareRadiusOfGyrationCollapsed( const assemble::ProteinModel &PROTEIN_MODEL, const storage::Set< biol::AtomType> &ATOM_TYPES )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>SquareRadiusOfGyrationCollapsed( const util::SiPtrVector< const linal::Vector3D> &COORDINATES, const util::ShPtr< biol::Membrane> &MEMBRANE )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_read_histograms.h</td>
        <td>ReadHistograms</td>
        <td>ReadEnvironmentHistograms( std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_read_histograms.h</td>
        <td>ReadHistograms</td>
        <td>ReadMembraneDependentEnvironmentHistograms( std::istream &ISTREAM )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_residual_dipolar_coupling_histogram.h</td>
        <td>ResidualDipolarCouplingHistogram</td>
        <td>GetDefaultScheme()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_residual_dipolar_coupling_histogram.h</td>
        <td>ResidualDipolarCouplingHistogram</td>
        <td>GetScheme() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_residual_dipolar_coupling_histogram.h</td>
        <td>ResidualDipolarCouplingHistogram</td>
        <td>operator ()( const nmr::RDCContainer &RDC_CONTAINER) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_residual_dipolar_coupling_q_value.h</td>
        <td>ResidualDipolarCouplingQValue</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_residual_dipolar_coupling_q_value.h</td>
        <td>ResidualDipolarCouplingQValue</td>
        <td>GetScheme() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_residual_dipolar_coupling_q_value.h</td>
        <td>ResidualDipolarCouplingQValue</td>
        <td>WriteDetailedSchemeAndValues( const nmr::RDCContainer &RDC_RESTRAINTS, std::ostream &OSTREAM ) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_residual_dipolar_coupling_q_value.h</td>
        <td>ResidualDipolarCouplingQValue</td>
        <td>operator ()( const nmr::RDCContainer &RDC_RESTRAINTS) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>GetDefaultDepthRange()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>GetDefaultLeftEndWell( const math::Histogram &HISTOGRAM)
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>GetDefaultRightEndWell( const math::Histogram &HISTOGRAM)
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>GetDefaultScheme()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>GetDefaultScoreOffset()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>GetDefaultTransitionWidth()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>GetFunction() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>GetScheme() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>RestraintAtomAttraction( const math::Range< double> &WELL_DEPTH, const double END_OF_WELL, const double WIDTH, const bool MAX_TO_MIN, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>RestraintAtomAttraction()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_attraction.h</td>
        <td>RestraintAtomAttraction</td>
        <td>operator ()( const restraint::AtomDistanceAssignment &RESTRAINT) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>GetDefaultScheme()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>GetRestraints() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>GetScheme() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>GetScore() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>GetSerializer() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>RestraintAtomDistance( const RestraintAtomDistanceAssignment &SCORING_FUNCTION, const double &FRACTION = 1.0, const std::string SCHEME = GetDefaultScheme(), const util::ShPtr< Container> &RESTRAINTS = util::ShPtr< Container>() )
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>RestraintAtomDistance()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>SetRestraints( const util::ShPtr< Container> &RESTRAINTS)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_atom_distance.h</td>
        <td>RestraintAtomDistance</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_body_protein_model.h</td>
        <td>RestraintBodyProteinModel</td>
        <td>GetRestraints() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_body_protein_model.h</td>
        <td>RestraintBodyProteinModel</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_body_protein_model.h</td>
        <td>RestraintBodyProteinModel</td>
        <td>GetSerializer() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_body_protein_model.h</td>
        <td>RestraintBodyProteinModel</td>
        <td>RestraintBodyProteinModel( const util::ShPtr< util::ShPtrVector< restraint::Body> > &RESTRAINT, const BodyAssignment &SCORE )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_body_protein_model.h</td>
        <td>RestraintBodyProteinModel</td>
        <td>RestraintBodyProteinModel()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_body_protein_model.h</td>
        <td>RestraintBodyProteinModel</td>
        <td>ScoreCurrent( const restraint::Body &RESTRAINT, const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_body_protein_model.h</td>
        <td>RestraintBodyProteinModel</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_distance_epr.h</td>
        <td>RestraintDistanceEPR</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_distance_epr.h</td>
        <td>RestraintDistanceEPR</td>
        <td>GetDefaultScheme()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_distance_epr.h</td>
        <td>RestraintDistanceEPR</td>
        <td>GetScheme() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_distance_epr.h</td>
        <td>RestraintDistanceEPR</td>
        <td>RestraintDistanceEPR( const util::ShPtrVector< restraint::AtomDistance> &RESTRAINTS, const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_distance_epr.h</td>
        <td>RestraintDistanceEPR</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_distance_spin_label.h</td>
        <td>RestraintDistanceSpinLabel</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_distance_spin_label.h</td>
        <td>RestraintDistanceSpinLabel</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_distance_spin_label.h</td>
        <td>RestraintDistanceSpinLabel</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_distance_spin_label.h</td>
        <td>RestraintDistanceSpinLabel</td>
        <td>ScoreDistance( const double &DISTANCE, const double &RESTRAINT_DISTANCE) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_distance_spin_label.h</td>
        <td>RestraintDistanceSpinLabel</td>
        <td>operator ()( const restraint::AtomDistanceAssignment &ASSIGNMENT ) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_energy_well.h</td>
        <td>RestraintEnergyWell</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_energy_well.h</td>
        <td>RestraintEnergyWell</td>
        <td>GetScheme() const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_energy_well.h</td>
        <td>RestraintEnergyWell</td>
        <td>GetTypeName( const Type &TYPE)
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_energy_well.h</td>
        <td>RestraintEnergyWell</td>
        <td>RestraintEnergyWell( const TypeEnum &WELL_TYPE)
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_energy_well.h</td>
        <td>RestraintEnergyWell</td>
        <td>RestraintEnergyWell( const double K_TWO_VALUE, const double K_THREE_VALUE, const TypeEnum &WELL_TYPE = e_NOE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_energy_well.h</td>
        <td>RestraintEnergyWell</td>
        <td>RestraintEnergyWell()
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_energy_well.h</td>
        <td>RestraintEnergyWell</td>
        <td>operator ()( const restraint::AtomDistanceAssignment &RESTRAINT) const
</td>
        <td>alexanns, akinlr</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_nmr_distance_interface.h</td>
        <td>RestraintNMRDistanceInterface</td>
        <td>GetBondsFromCB( const biol::AtomType &ATOM_TYPE)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_nmr_distance_interface.h</td>
        <td>RestraintNMRDistanceInterface</td>
        <td>GetSpinLabelLength()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_nmr_distance_interface.h</td>
        <td>RestraintNMRDistanceInterface</td>
        <td>GetTotalBondsFromCB( const restraint::AtomDistanceAssignment &ASSIGNMENT)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_noe_attraction.h</td>
        <td>RestraintNoeAttraction</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_noe_attraction.h</td>
        <td>RestraintNoeAttraction</td>
        <td>GetDefaultScheme()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_noe_attraction.h</td>
        <td>RestraintNoeAttraction</td>
        <td>GetNOEHistogram()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_noe_attraction.h</td>
        <td>RestraintNoeAttraction</td>
        <td>GetScheme() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_noe_attraction.h</td>
        <td>RestraintNoeAttraction</td>
        <td>operator ()( const restraint::AtomDistanceAssignment &RESTRAINT) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_noe_knowledge_based.h</td>
        <td>RestraintNoeKnowledgeBased</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_noe_knowledge_based.h</td>
        <td>RestraintNoeKnowledgeBased</td>
        <td>GetDefaultScheme()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_noe_knowledge_based.h</td>
        <td>RestraintNoeKnowledgeBased</td>
        <td>GetNOEHistogram()
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_noe_knowledge_based.h</td>
        <td>RestraintNoeKnowledgeBased</td>
        <td>GetScheme() const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_noe_knowledge_based.h</td>
        <td>RestraintNoeKnowledgeBased</td>
        <td>operator ()( const restraint::AtomDistanceAssignment &RESTRAINT) const
</td>
        <td>akinlr, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>GetDefaultScheme()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>GetScheme() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>GetSerializer() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>RestraintPofr( const util::Implementation< restraint::SasPofRInterface> &POFR_IMPLEMENTATION, const PofR &SCORE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>RestraintPofr()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_pofr.h</td>
        <td>RestraintPofr</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_residual_dipolar_coupling.h</td>
        <td>RestraintResidualDipolarCoupling</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_residual_dipolar_coupling.h</td>
        <td>RestraintResidualDipolarCoupling</td>
        <td>GetScheme() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_residual_dipolar_coupling.h</td>
        <td>RestraintResidualDipolarCoupling</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_residual_dipolar_coupling.h</td>
        <td>RestraintResidualDipolarCoupling</td>
        <td>RestraintResidualDipolarCoupling( const util::ShPtr< restraint::RDC> &RDCS, const math::FunctionInterfaceSerializable< restraint::RDCAssignment, nmr::RDCContainer> &RDC_FROM_STRUCTURE_CALCULATOR, const math::FunctionInterfaceSerializable< nmr::RDCContainer, double> &RDC_AGREEMENT_CALCULATOR, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_residual_dipolar_coupling.h</td>
        <td>RestraintResidualDipolarCoupling</td>
        <td>RestraintResidualDipolarCoupling()
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_residual_dipolar_coupling.h</td>
        <td>RestraintResidualDipolarCoupling</td>
        <td>WriteDetailedSchemeAndValues( const assemble::ProteinModel &PROTEIN_MODEL, std::ostream &OSTREAM ) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_residual_dipolar_coupling.h</td>
        <td>RestraintResidualDipolarCoupling</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>alexanns, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>GetDefaultScheme()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>GetScheme() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>GetSerializer() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>RestraintSaxs( const util::Implementation< restraint::SasDebyeInterface> &DEBYE_IMPLEMENTATION, const SasType &SCORE, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>RestraintSaxs()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_saxs.h</td>
        <td>RestraintSaxs</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_xlink.h</td>
        <td>RestraintXlink</td>
        <td>GetDefaultScheme()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_xlink.h</td>
        <td>RestraintXlink</td>
        <td>GetScheme() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_xlink.h</td>
        <td>RestraintXlink</td>
        <td>GetSerializer() const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_xlink.h</td>
        <td>RestraintXlink</td>
        <td>RestraintXlink( const util::ShPtr< util::ShPtrVector< restraint::AtomDistance> > &SP_RESTRAINTS, double TRANSITION_LENGTH = 5.0, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_xlink.h</td>
        <td>RestraintXlink</td>
        <td>RestraintXlink()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_restraint_xlink.h</td>
        <td>RestraintXlink</td>
        <td>SetRestraints( const util::ShPtr< util::ShPtrVector< restraint::AtomDistance> > &RESTRAINTS)
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_restraint_xlink.h</td>
        <td>RestraintXlink</td>
        <td>operator ()( const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>CalculateChiScore( const restraint::SasExperimentalAndCalculatedData &SAXS_DATA) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>CalculateCumulativeIntegralScore( const restraint::SasExperimentalAndCalculatedData &SAXS_DATA) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>CalculateStovgaardScore( const restraint::SasExperimentalAndCalculatedData &SAXS_DATA) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>GetFunctionDescriptor( const ScoreFunction &SCORE_FUNCTION)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>GetScoreFunction() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>GetSerializer() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>GetUseErrors() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>SasType( const bool &USE_ERRORS, const ScoreFunctionEnum &SCORE_TYPE)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>SasType()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sas_type.h</td>
        <td>SasType</td>
        <td>operator ()( const restraint::SasExperimentalAndCalculatedData &SAXS_DATA) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_scores.h</td>
        <td>Scores</td>
        <td>GetInstance()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_scores.h</td>
        <td>Scores</td>
        <td>Initialize()
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>AngleToMembranePlane( const assemble::SSEGeometryInterface &SSE_GEOMETRY, const coord::Axis &AXIS, const biol::Membrane &MEMBRANE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetEnergyFunctions() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>ReadInitializerSuccessHook( const util::ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>SSEMembraneAlignment( const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>WeightXAxis( const assemble::SSEGeometryInterface &STRAND, const biol::Membrane &MEMBRANE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &SSE, const biol::Membrane &MEMBRANE, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>operator ()( const assemble::SSE &SSE, const biol::Membrane &MEMBRANE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_angle_distance.h</td>
        <td>SSEPairAngleDistance</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_angle_distance.h</td>
        <td>SSEPairAngleDistance</td>
        <td>SSEPairAngleDistance( const SSEPackInterface &SSE_PACK_INTERFACE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_angle_distance.h</td>
        <td>SSEPairAngleDistance</td>
        <td>SSEPairAngleDistance()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_angle_distance.h</td>
        <td>SSEPairAngleDistance</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B, std::ostream &OSTREAM ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_angle_distance.h</td>
        <td>SSEPairAngleDistance</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_clash.h</td>
        <td>SSEPairClash</td>
        <td>AreValidSSEs( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_clash.h</td>
        <td>SSEPairClash</td>
        <td>GetDefaultScheme()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_clash.h</td>
        <td>SSEPairClash</td>
        <td>GetMinimalInterfaceLength() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_clash.h</td>
        <td>SSEPairClash</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_clash.h</td>
        <td>SSEPairClash</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_clash.h</td>
        <td>SSEPairClash</td>
        <td>GetSigmoidWidth() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_clash.h</td>
        <td>SSEPairClash</td>
        <td>SSEPairClash( const double SIGMOID_WIDTH = 1.0, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_clash.h</td>
        <td>SSEPairClash</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSEGeometryPacking &SSE_PACK, std::ostream &OSTREAM ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_clash.h</td>
        <td>SSEPairClash</td>
        <td>operator ()( const assemble::SSEGeometryPacking &SSE_PACK) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_connectivity.h</td>
        <td>SSEPairConnectivity</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_connectivity.h</td>
        <td>SSEPairConnectivity</td>
        <td>GetExtendedResidueLength()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_connectivity.h</td>
        <td>SSEPairConnectivity</td>
        <td>GetScheme() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_connectivity.h</td>
        <td>SSEPairConnectivity</td>
        <td>SSEPairConnectivity( const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_connectivity.h</td>
        <td>SSEPairConnectivity</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B, std::ostream &OSTREAM ) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_connectivity.h</td>
        <td>SSEPairConnectivity</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_contact.h</td>
        <td>SSEPairContact</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_contact.h</td>
        <td>SSEPairContact</td>
        <td>SSEPairContact( const util::ShPtr< contact::PredictionMap> &SP_PREDICTION_MAP)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_contact.h</td>
        <td>SSEPairContact</td>
        <td>SSEPairContact()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_contact.h</td>
        <td>SSEPairContact</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B, std::ostream &OSTREAM ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_contact.h</td>
        <td>SSEPairContact</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_gap.h</td>
        <td>SSEPairGap</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_gap.h</td>
        <td>SSEPairGap</td>
        <td>GetScheme() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_gap.h</td>
        <td>SSEPairGap</td>
        <td>GetSerializer() const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_gap.h</td>
        <td>SSEPairGap</td>
        <td>SSEPairGap( const double NON_COIL_PENALTY, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_gap.h</td>
        <td>SSEPairGap</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>alexanns, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>AreValidSSEs( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>GetDefaultScheme()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>GetDistanceRangeMap() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>GetEnergyFunctions() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>GetHistogramFilename() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>GetMinimalInterfaceLength() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>SSEPairPacking( const std::string &SCHEME = GetDefaultScheme(), const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const storage::Map< contact::Type, math::Range< double> > &DISTANCE_RANGE_MAP = contact::GetTypes().GetValidDistanceRanges() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSEGeometryPacking &SSE_PACK, std::ostream &OSTREAM ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pair_packing.h</td>
        <td>SSEPairPacking</td>
        <td>operator ()( const assemble::SSEGeometryPacking &SSE_PACK) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pairs_fragments.h</td>
        <td>SSEPairsFragments</td>
        <td>AreValidSSEs( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pairs_fragments.h</td>
        <td>SSEPairsFragments</td>
        <td>GetScheme() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pairs_fragments.h</td>
        <td>SSEPairsFragments</td>
        <td>GetSerializer() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pairs_fragments.h</td>
        <td>SSEPairsFragments</td>
        <td>SSEPairsFragments( const assemble::SSEGeometryPackingListPicker &PACKING_PICKER, const SSEPackInterface &PACKING_FUNCTION, const bool NORMALIZE_OVER_NUMBER_OF_PAIRS )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pairs_fragments.h</td>
        <td>SSEPairsFragments</td>
        <td>SSEPairsFragments()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pairs_fragments.h</td>
        <td>SSEPairsFragments</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B, std::ostream &OSTREAM ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pairs_fragments.h</td>
        <td>SSEPairsFragments</td>
        <td>operator ()( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pool_sses.h</td>
        <td>SSEPoolSSEs</td>
        <td>GetSSEScore() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pool_sses.h</td>
        <td>SSEPoolSSEs</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pool_sses.h</td>
        <td>SSEPoolSSEs</td>
        <td>SSEPoolSSEs( const util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > > &SP_SCORE_SSE, const bool NORMALIZE_SSE, const bool NORMALIZE_NUMBER_SSES )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pool_sses.h</td>
        <td>SSEPoolSSEs</td>
        <td>SetSSEScore( const util::ShPtr< math::BinaryFunctionInterfaceSerializable< assemble::SSE, biol::Membrane, storage::Pair< double, size_t> > > &SP_SSE_FUNCTION )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_pool_sses.h</td>
        <td>SSEPoolSSEs</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSEPool &POOL, const biol::Membrane &MEMBRANE, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_pool_sses.h</td>
        <td>SSEPoolSSEs</td>
        <td>operator ()( const assemble::SSEPool &POOL, const biol::Membrane &MEMBRANE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>GetConfidenceThreshold() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>GetDefaultScheme()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>GetEnergyFunctions() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>GetMethod() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>GetScheme() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>SSEPredictions( const sspred::Method &SS_METHOD, const double CONFIDENCE_THRESHOLD = s_DefaultConfidenceThreshold, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>SSEPredictions()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>SetConfidenceThreshold( const double THRESHOLD)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>SetMethod( const sspred::Method &METHOD)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSE &SSE, const biol::Membrane &MEMBRANE, std::ostream &OSTREAM ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>operator ()( const assemble::SSE &SSE, const biol::Membrane &MEMBRANE ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_sse_predictions.h</td>
        <td>SSEPredictions</td>
        <td>operator ()( const assemble::SSE &SSE, const sspred::Method &SS_METHOD ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>AreValidSSEs( const assemble::SSE &SSE_A, const assemble::SSE &SSE_B) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>GetDefaultHistogramFilename()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>GetDefaultScheme()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>GetDistanceRange() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>GetEnergyFunction() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>GetHistogramFilename() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>GetMinimalInterfaceLength() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>GetScheme() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>GetSerializer() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>StrandPairing( const std::string &SCHEME = GetDefaultScheme(), const std::string &HISTOGRAM_FILENAME = GetDefaultHistogramFilename(), const math::Range< double> &DISTANCE_RANGE = contact::GetTypes().STRAND_STRAND->GetDistanceRange() )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>WriteDetailedSchemeAndValues( const assemble::SSEGeometryPacking &SSE_PACK, std::ostream &OSTREAM ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_strand_pairing.h</td>
        <td>StrandPairing</td>
        <td>operator ()( const assemble::SSEGeometryPacking &SSE_PACK) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_symmetry.h</td>
        <td>Symmetry</td>
        <td>GetDefaultScheme()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_symmetry.h</td>
        <td>Symmetry</td>
        <td>GetFlagScoreSymmetry()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_symmetry.h</td>
        <td>Symmetry</td>
        <td>GetScheme() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_symmetry.h</td>
        <td>Symmetry</td>
        <td>Symmetry( const std::string &FILENAME, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_symmetry.h</td>
        <td>Symmetry</td>
        <td>Symmetry( const storage::Vector < util::ShPtrVector< find::LocatorInterface< linal::Vector3D, t_ArgumentType> > > &MOVABLE_LOCATORS, const std::string &SCHEME = GetDefaultScheme() )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_score_symmetry.h</td>
        <td>Symmetry</td>
        <td>operator ()( const t_ArgumentType &ARGUMENT) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_score_symmetry.h</td>
        <td></td>
        <td>AddInstance( new Symmetry< t_ArgumentType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_count.h</td>
        <td>AACount</td>
        <td>AACount()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_count.h</td>
        <td>AACount</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_count.h</td>
        <td>AACount</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_count.h</td>
        <td>AACount</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_count.h</td>
        <td>AACount</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_count.h</td>
        <td>AACount</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance.h</td>
        <td>AADistance</td>
        <td>AADistance()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_distance.h</td>
        <td>AADistance</td>
        <td>GetBinSize() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance.h</td>
        <td>AADistance</td>
        <td>GetCategoryFileName( const AADistanceCategoryOption &CATEGORY_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_distance.h</td>
        <td>AADistance</td>
        <td>GetCategoryOptionName( const AADistanceCategoryOption &CATEGORY_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance.h</td>
        <td>AADistance</td>
        <td>GetChainId() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_distance.h</td>
        <td>AADistance</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance.h</td>
        <td>AADistance</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_distance_angle_contacts.h</td>
        <td>AADistanceAngleContacts</td>
        <td>AADistanceAngleContacts()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance_angle_contacts.h</td>
        <td>AADistanceAngleContacts</td>
        <td>GetBinSize() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_distance_angle_contacts.h</td>
        <td>AADistanceAngleContacts</td>
        <td>GetChainId() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance_angle_contacts.h</td>
        <td>AADistanceAngleContacts</td>
        <td>GetOutFilePostfix() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_distance_angle_contacts.h</td>
        <td>AADistanceAngleContacts</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance_matrix.h</td>
        <td>AADistanceMatrix</td>
        <td>AADistanceMatrix()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_distance_matrix.h</td>
        <td>AADistanceMatrix</td>
        <td>GetColumnChainId() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance_matrix.h</td>
        <td>AADistanceMatrix</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_distance_matrix.h</td>
        <td>AADistanceMatrix</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance_matrix.h</td>
        <td>AADistanceMatrix</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_aa_distance_matrix.h</td>
        <td>AADistanceMatrix</td>
        <td>GetRowChainId() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_aa_distance_matrix.h</td>
        <td>AADistanceMatrix</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_contact_order.h</td>
        <td>ContactOrder</td>
        <td>ContactOrder()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_contact_order.h</td>
        <td>ContactOrder</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_contact_order.h</td>
        <td>ContactOrder</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>FoldTemplate()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_fold_template.h</td>
        <td>FoldTemplate</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetOutFilePostfix() const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>LoopAngle()
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_angle.h</td>
        <td>LoopAngle</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>putnamdk</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetChainId() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetDistanceBinSize() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetMaxDistance() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetNumResidues() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>LoopClosure()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_closure.h</td>
        <td>LoopClosure</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_distance.h</td>
        <td>LoopDistance</td>
        <td>GetBinSize() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_distance.h</td>
        <td>LoopDistance</td>
        <td>GetChainId() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_distance.h</td>
        <td>LoopDistance</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_distance.h</td>
        <td>LoopDistance</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_distance.h</td>
        <td>LoopDistance</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_loop_distance.h</td>
        <td>LoopDistance</td>
        <td>LoopDistance()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_loop_distance.h</td>
        <td>LoopDistance</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>GetChainOptionName( const ChainOption &CHAIN_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>GetNCLowerBound() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>GetNCUpperBound() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>GetOutputFileName( const ChainOption &CHAIN_OPTION, const bool SPLIT_ENVIRONMENT)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>GetSequenceExclusion() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>NeighborCount( const bool SPLIT_ENVIRONMENT)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>NeighborCount()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_count.h</td>
        <td>NeighborCount</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>GetChainOptionName( const ChainOption &CHAIN_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>GetNVLowerBound() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>GetNVUpperBound() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>GetOutputFileName( const ChainOption &CHAIN_OPTION, const bool SPLIT_ENVIRONMENT)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>GetSequenceExclusion() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>NeighborVector( const bool SPLIT_ENVIRONMENT)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>NeighborVector()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_neighbor_vector.h</td>
        <td>NeighborVector</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_ols.h</td>
        <td>OLS</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_ols.h</td>
        <td>OLS</td>
        <td>GetChainOptionName( const ChainOption &CHAIN_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_ols.h</td>
        <td>OLS</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_ols.h</td>
        <td>OLS</td>
        <td>GetOutputFileName( const ChainOption &CHAIN_OPTION, const bool SPLIT_ENVIRONMENT)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_ols.h</td>
        <td>OLS</td>
        <td>GetRadius() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_ols.h</td>
        <td>OLS</td>
        <td>GetSequenceExclusion() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_ols.h</td>
        <td>OLS</td>
        <td>OLS( const bool SPLIT_ENVIRONMENT)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_ols.h</td>
        <td>OLS</td>
        <td>OLS()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_ols.h</td>
        <td>OLS</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_phipsi.h</td>
        <td>PhiPsi</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_phipsi.h</td>
        <td>PhiPsi</td>
        <td>GetNumberOfBins() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_phipsi.h</td>
        <td>PhiPsi</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_phipsi.h</td>
        <td>PhiPsi</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_phipsi.h</td>
        <td>PhiPsi</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_phipsi.h</td>
        <td>PhiPsi</td>
        <td>PhiPsi()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_phipsi.h</td>
        <td>PhiPsi</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_packing.h</td>
        <td>ProteinModelPacking</td>
        <td>AddPackingType( const assemble::SSEGeometryPacking &PACKING, const bool &IS_IN_CONTACT, const size_t &N_SSES_APART, const bool &IS_BACKGROUND, const bool &ORIENTATION_COULD_BE_OPPOSITE, linal::VectorInterface< size_t> &COUNTS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_packing.h</td>
        <td>ProteinModelPacking</td>
        <td>GetCategoryName( const Category &CATEGORY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_packing.h</td>
        <td>ProteinModelPacking</td>
        <td>GetMinAtomsInContact() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_packing.h</td>
        <td>ProteinModelPacking</td>
        <td>GetMinInteractionDistance() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_packing.h</td>
        <td>ProteinModelPacking</td>
        <td>GetOutFilePostfix() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_packing.h</td>
        <td>ProteinModelPacking</td>
        <td>ProteinModelPacking( const double &MIN_INTERACTION_DISTANCE = 4.8, const size_t &MIN_ATOMS_IN_CONTACT = 4 )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_packing.h</td>
        <td>ProteinModelPacking</td>
        <td>ReadContactTypeEntropies( std::istream &STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_packing.h</td>
        <td>ProteinModelPacking</td>
        <td>ReadSSPairToContactEntropies( std::istream &STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_packing.h</td>
        <td>ProteinModelPacking</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>GetCacheOrientation( storage::Vector< storage::Vector< assemble::SSEGeometryPacking::OrientationEnum> > &CACHE, const size_t &SSE_A_ID, const size_t &SSE_B_ID, const assemble::SSE &SSE_A, const assemble::SSE &SSE_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>GetInteractionDistance() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>GetMinAtomsInContactHelix() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>GetMinAtomsInContactStrand() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>GetNumberHashes() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>GetOutFilePostfix() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>GetPackingTripletHash( const biol::SSType &TYPE_A, const biol::SSType &TYPE_B, const biol::SSType &TYPE_C, const assemble::SSEGeometryPacking::OrientationEnum &PACKING_AB, const assemble::SSEGeometryPacking::OrientationEnum &PACKING_BC, const assemble::SSEGeometryPacking::OrientationEnum &PACKING_AC, const size_t &COUNTS_PACK_A, const size_t &COUNTS_PACK_B, const size_t &COUNTS_PACK_C, const bool &ADJACENT, const bool &RHS ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>GetPackingTripletNumber( const biol::SSType &TYPE_A, const biol::SSType &TYPE_B, const biol::SSType &TYPE_C, const assemble::SSEGeometryPacking::OrientationEnum &PACKING_AB, const assemble::SSEGeometryPacking::OrientationEnum &PACKING_BC, const assemble::SSEGeometryPacking::OrientationEnum &PACKING_AC, const size_t &COUNTS_PACK_A, const size_t &COUNTS_PACK_B, const size_t &COUNTS_PACK_C, const bool &ADJACENT, const bool &RHS ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>GetPackingTripletString( const size_t &HASH_NUMBER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>ProteinModelSSETripletChirality( const bool CONSIDER_WHICH_SSES_IN_CONTACT = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_protein_model_sse_triplet_chirality.h</td>
        <td>ProteinModelSSETripletChirality</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>RadiusOfGyration()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_radius_of_gyration.h</td>
        <td>RadiusOfGyration</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sheet_template.h</td>
        <td>SheetTemplate</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sheet_template.h</td>
        <td>SheetTemplate</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sheet_template.h</td>
        <td>SheetTemplate</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sheet_template.h</td>
        <td>SheetTemplate</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sheet_template.h</td>
        <td>SheetTemplate</td>
        <td>SheetTemplate()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sheet_template.h</td>
        <td>SheetTemplate</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_side_chain_distance.h</td>
        <td>SideChainDistance</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_side_chain_distance.h</td>
        <td>SideChainDistance</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_side_chain_distance.h</td>
        <td>SideChainDistance</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_side_chain_distance.h</td>
        <td>SideChainDistance</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_side_chain_distance.h</td>
        <td>SideChainDistance</td>
        <td>SideChainDistance()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_side_chain_distance.h</td>
        <td>SideChainDistance</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_count.h</td>
        <td>SSECount</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_count.h</td>
        <td>SSECount</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_count.h</td>
        <td>SSECount</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_count.h</td>
        <td>SSECount</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_count.h</td>
        <td>SSECount</td>
        <td>SSECount()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_count.h</td>
        <td>SSECount</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetNumberOfBins() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>SSEMembraneAlignment()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_membrane_alignment.h</td>
        <td>SSEMembraneAlignment</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>GetFragmentMinInterfaceLength() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>GetSSEAngleNumberBins() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>GetSSEDistanceBinSize() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>GetStrandAngleNumberBins() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>GetStrandDistanceBinSize() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>SSEPacking()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sse_packing.h</td>
        <td>SSEPacking</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sspred_agreement.h</td>
        <td>SSPredAgreement</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sspred_agreement.h</td>
        <td>SSPredAgreement</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_sspred_agreement.h</td>
        <td>SSPredAgreement</td>
        <td>SSPredAgreement()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_sspred_agreement.h</td>
        <td>SSPredAgreement</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_strand_alignment.h</td>
        <td>StrandAlignment</td>
        <td>GetChainIds() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_strand_alignment.h</td>
        <td>StrandAlignment</td>
        <td>GetHydrogenBondOHCutoff() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_strand_alignment.h</td>
        <td>StrandAlignment</td>
        <td>GetOutFilePostfix() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_strand_alignment.h</td>
        <td>StrandAlignment</td>
        <td>GetOutputFileName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_strand_alignment.h</td>
        <td>StrandAlignment</td>
        <td>GetOutputOptionName( const OutputOption &OUTPUT_OPTION)
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_strand_alignment.h</td>
        <td>StrandAlignment</td>
        <td>GetVisualizationOutputPath() const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_scorestat_strand_alignment.h</td>
        <td>StrandAlignment</td>
        <td>StrandAlignment()
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_scorestat_strand_alignment.h</td>
        <td>StrandAlignment</td>
        <td>operator ()( const assemble::ProteinEnsemble &ENSEMBLE) const
</td>
        <td>lib14</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>AtomInfo( const chemistry::AtomType &ATOM_TYPE, const chemistry::Chirality &CHIRALITY, const linal::Vector3D &COORDINATES = linal::Vector3D(), const bool &CAN_ADD_H = true )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>AtomInfo()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>CanAddH() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>ExtractMdlAtomLineInfo( const std::string &LINE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>FormattedAsMdlAtomLine( const std::string &LINE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>GetAtomType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>GetChirality() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>GetCoordinates() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>SetAtomType( const chemistry::AtomType &ATOM_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>SetCharge( const short &CHARGE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>SetChirality( const chemistry::Chirality &CHIRALITY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>SetCoordinates( const linal::Vector3D &COORDINATES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>ToMdlAtomLine() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_atom_info.h</td>
        <td>AtomInfo</td>
        <td>operator ==( const AtomInfo &ATOM_INFO) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>BondInfo( const size_t &ATOM_INDEX_A, const size_t &ATOM_INDEX_B, const chemistry::ConfigurationalBondType &BOND_TYPE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>BondInfo( const size_t &ATOM_INDEX_A, const size_t &ATOM_INDEX_B, const chemistry::ConstitutionalBondType &BOND_TYPE )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>BondInfo()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>ExtractMdlBondLineInfo( const std::string &LINE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>FormattedAsMdlBondLine( const std::string &LINE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>GetAtomIndexHigh() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>GetAtomIndexLow() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>GetConfigurationalBondType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>GetConstitutionalBondType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>IsValid() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>SetIsometry( const chemistry::BondIsometry &ISOMETRY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>ToMdlBondLine() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>operator <( const BondInfo &BOND_INFO) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_bond_info.h</td>
        <td>BondInfo</td>
        <td>operator ==( const BondInfo &BOND_INFO) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>CTabHandler( const storage::List< std::string> &LINES)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>CTabHandler( const storage::Vector< AtomInfo> &ATOM_INFOS, const storage::Vector< BondInfo> &BOND_INFOS )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>CTabHandler( std::istream &ISTREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>CTabHandler()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>GetAtomInfo() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>GetAtomMapping() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>GetBondInfo() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>GetCachedProperties() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>IsTerminalLine( const std::string &LINE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>IsValid() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>ReadCTab( const storage::List< std::string>::const_iterator &LINE_BEGIN, const storage::List< std::string>::const_iterator &LINE_END )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>ReadCTab( std::istream &ISTREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>Reset()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>SetAtomMapping( const size_t &ATOM_NO, const size_t &VALUE)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>WasChiralityRead() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>WasDoubleBondIsometryRead() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>WereAtomTypesRead() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>WereBondTypesRead() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_ctab_handler.h</td>
        <td>CTabHandler</td>
        <td>WriteCTab( std::ostream &OSTREAM, const bool &FORCE_WRITE_ATOM_TYPES = false) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_factory.h</td>
        <td>Factory</td>
        <td>MakeConfiguration( const MdlHandler &HANDLER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_factory.h</td>
        <td>Factory</td>
        <td>MakeConformation( const MdlHandler &HANDLER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_factory.h</td>
        <td>Factory</td>
        <td>MakeConstitution( const MdlHandler &HANDLER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_factory.h</td>
        <td>Factory</td>
        <td>MakeMolecule( const MdlHandler &HANDLER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_fragment_factory.h</td>
        <td>FragmentFactory</td>
        <td>MakeConfiguration( const MdlHandler &HANDLER, const HydrogenHandlingPref &H_PREF = e_Maintain)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_fragment_factory.h</td>
        <td>FragmentFactory</td>
        <td>MakeConformation( const MdlHandler &HANDLER, const HydrogenHandlingPref &H_PREF = e_Maintain)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_fragment_factory.h</td>
        <td>FragmentFactory</td>
        <td>MakeConstitution( const MdlHandler &HANDLER, const HydrogenHandlingPref &H_PREF = e_Maintain)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_fragment_factory.h</td>
        <td>FragmentFactory</td>
        <td>MakeFragment( const CTabHandler &HANDLER, const HydrogenHandlingPref &H_PREF = e_Maintain, const NeutralizationPref &NEUTRALIZATION_PREF = e_None, const std::string &MOLECULE_ID = std::string() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_fragment_factory.h</td>
        <td>FragmentFactory</td>
        <td>MakeFragment( const MdlHandler &HANDLER, const HydrogenHandlingPref &H_PREF = e_Maintain, const NeutralizationPref &NEUTRALIZATION_PREF = e_None, const std::string &MOLECULE_ID = std::string() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_fragment_factory.h</td>
        <td>FragmentFactory</td>
        <td>MakeFragment( const MolfileHandler &HANDLER, const HydrogenHandlingPref &H_PREF = e_Maintain, const NeutralizationPref &NEUTRALIZATION_PREF = e_None, const std::string &MOLECULE_ID = std::string() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>GetDataType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>GetDefault() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>GetDouble( const std::string &LINE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>GetFormat() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>GetLength() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>GetMdlLineType() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>GetStart() const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>GetTrimmedString( const std::string &LINE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>GetUnsignedInt( const std::string &LINE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>IsDouble( const std::string &LINE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>IsUnsignedInt( const std::string &LINE) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>MdlEntryTypeData( const MdlLineType LINE_TYPE, const size_t START, const size_t LENGTH, const std::string &DEFAULT, const util::Format &FORMAT, const util::CPPDataTypes::Types DATA_TYPE )
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>MdlEntryTypeData()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_entry_type_data.h</td>
        <td>MdlEntryTypeData</td>
        <td>Set( std::string &STRING, const t_DataType &DATA) const
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_entry_types.h</td>
        <td></td>
        <td>GetMdlEntryTypes()
</td>
        <td>butkiem1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>AddAtomMdlLineFlag( command::Command &CMD)
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>CreateConfigurationalHashString( const storage::Vector< AtomInfo> &ATOM_INFO, const storage::Vector< BondInfo> &BOND_INFO, chemistry::ConfigurationalBondTypeData::Data BOND_TYPE = chemistry::ConfigurationalBondTypeData::e_BondOrderAmideWithIsometryOrAromaticWithRingness )
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>CreateConformationalHashString( const storage::Vector< AtomInfo> &ATOM_INFO, const storage::Vector< BondInfo> &BOND_INFO )
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>CreateConstitutionalHashString( const storage::Vector< AtomInfo> &ATOM_INFO, const storage::Vector< BondInfo> &BOND_INFO, chemistry::ConfigurationalBondTypeData::Data BOND_TYPE = chemistry::ConfigurationalBondTypeData::e_BondOrderAmideOrAromaticWithRingness )
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>FinalizeParsing() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>GetAddAtomMdlLineFlag()
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>GetAtomInfo() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>GetAtomMapping() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>GetBondInfo() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>GetCachedProperties() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>GetDescription() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>GetMDLDataLabel( const std::string &LINE)
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>GetMiscProperties() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>GetMolfile() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>IsTerminalLine( const std::string &LINE)
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>IsValid() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>MdlHandler( const storage::List< std::string> &LINES)
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>MdlHandler( std::istream &ISTREAM)
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>MdlHandler()
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>ReadFromSDF( std::istream &ISTREAM)
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>Reset()
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>WasChiralityRead() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>WasDoubleBondIsometryRead() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>WereAtomTypesRead() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>WereBondTypesRead() const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>WriteMiscProperties( std::ostream &OSTREAM, const storage::Map< std::string, std::string> &MISC_PROPERTIES )
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>WriteToSDF( std::ostream &OSTREAM) const
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>WriteToSDF( std::ostream &OSTREAM, const MolfileHandler &MOLFILE, const storage::Map< std::string, std::string> &MISC_PROPERTIES )
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_handler.h</td>
        <td>MdlHandler</td>
        <td>WriteToSDF( std::ostream &OSTREAM, const std::string &DESCRIPTION, const storage::Vector< AtomInfo> &ATOM_INFO, const storage::Vector< BondInfo> &BOND_INFO, const storage::Map< std::string, std::string> &MISC_PROPERTIES )
</td>
        <td>butkiem1, loweew, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_header.h</td>
        <td>MdlHeader</td>
        <td>GetNumberAtoms() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_header.h</td>
        <td>MdlHeader</td>
        <td>GetNumberBonds() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_header.h</td>
        <td>MdlHeader</td>
        <td>IsValid() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_header.h</td>
        <td>MdlHeader</td>
        <td>MdlHeader( const size_t &NUMBER_ATOMS, const size_t &NUMBER_BONDS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_header.h</td>
        <td>MdlHeader</td>
        <td>MdlHeader()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_header.h</td>
        <td>MdlHeader</td>
        <td>SetFromMdlLine( const std::string &MDL_HEADER, const size_t NUMBER_DESC_LINES)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_header.h</td>
        <td>MdlHeader</td>
        <td>ToMdlLine() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_line_types.h</td>
        <td></td>
        <td>GetDefaultLine( const MdlLineType &LINE_TYPE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_line_types.h</td>
        <td></td>
        <td>GetLineTypeName( const MdlLineType &LINE_TYPE)
</td>
        <td>butkiem1, mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>ApplyProperty( storage::Vector< AtomInfo> &ATOM_LINES, storage::Vector< BondInfo> &BOND_LINES) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>GetLabel() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>GetProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>GetPropertyName( const Property &PROPERTY)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>GetPropertyStrings() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>GetString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>IsBCLProperty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>IsBCLPropertyLine( const std::string &LINE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>IsMDLPropertyLine( const std::string &LINE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>IsValid() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>MdlProperty( const PropertyEnum &PROPERTY = PropertyEnum( s_NumberProperties))
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>MdlProperty( const PropertyEnum &PROPERTY, const storage::Vector< AtomInfo> &ATOM_LINES, const storage::Vector< BondInfo> &BOND_LINES )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>MdlProperty( const std::string &STRING)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_mdl_property.h</td>
        <td>MdlProperty</td>
        <td>ShouldCache() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>AddMoleculeReadingPrefFlags( command::Command &CMD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetAddHydrogensFlag()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetCommandLineHydrogensPref()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetCommandLineNeutralizationPref()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetHydrogensPrefName( const HydrogenHandlingPref &PREF)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetNeutralizationPrefAllowsAromaticityChange( const NeutralizationPref &PREF)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetNeutralizationPrefAllowsBondOrderChange( const NeutralizationPref &PREF)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetNeutralizationPrefAllowspHChange( const NeutralizationPref &PREF)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetNeutralizationPrefName( const NeutralizationPref &PREF)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetNeutralizeChargesFlag()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molecule_reading_pref.h</td>
        <td></td>
        <td>GetRemoveHydrogensFlag()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>GetDescription() const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>MolfileHandler( const std::string &DESCRIPTION, const storage::Vector< AtomInfo> &ATOM_INFOS, const storage::Vector< BondInfo> &BOND_INFOS )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>MolfileHandler( const storage::List< std::string> &LINES)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>MolfileHandler( std::istream &ISTREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>MolfileHandler()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>ReadMolfile( const storage::List< std::string>::const_iterator &LINE_BEGIN, const storage::List< std::string>::const_iterator &LINE_END )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>ReadMolfile( std::istream &ISTREAM)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>Reset()
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>StandardizeDescription( const std::string &DESCRIPTION)
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>WriteMolfile( std::ostream &OSTREAM, const bool &FORCE_WRITE_ATOM_TYPES = false) const
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>WriteMolfile( std::ostream &OSTREAM, const std::string &DESCRIPTION, const CTabHandler &CTAB, const bool &FORCE_WRITE_ATOM_TYPES = false )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_molfile_handler.h</td>
        <td>MolfileHandler</td>
        <td>WriteMolfile( std::ostream &OSTREAM, const std::string &DESCRIPTION, const storage::Vector< AtomInfo> &ATOM_INFO, const storage::Vector< BondInfo> &BOND_INFO )
</td>
        <td>geanesar</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_factory.h</td>
        <td>RXNFactory</td>
        <td>MakeReactionComplete( const RXNHandler &HANDLER)
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_factory.h</td>
        <td>RXNFactory</td>
        <td>MakeReactionStructure( const CTabHandler &HANDLER)
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>GetDescription() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>GetNumberProducts() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>GetNumberReactants() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>GetProductHandlers() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>GetProductMdlHandlers() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>GetReactantHandlers() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>GetReactantMdlHandlers() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>GetReactiveAtomsInProducts() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>GetReactiveAtomsInReactants() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>IsRXNDelimiter( const std::string &LINE)
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>IsRXNMolDelimiter( const std::string &LINE)
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>IsValid() const
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>RXNHandler( std::istream &ISTREAM)
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>RXNHandler()
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>ReadFromRXN( const storage::List< std::string>::const_iterator &LINE_BEGIN, const storage::List< std::string>::const_iterator &LINE_END )
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>ReadFromRXN( std::istream &ISTREAM)
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>WriteToRXN( std::ostream &OSTREAM, const std::string &DESCRIPTION, const storage::Vector< MolfileHandler> &REACTANT_MOLFILES, const storage::Vector< MolfileHandler> &PRODUCT_MOLFILES )
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>WriteToRXN( std::ostream &OSTREAM, const std::string &DESCRIPTION, const storage::Vector< chemistry::FragmentComplete> &REACTANTS, const storage::Vector< chemistry::FragmentComplete> &PRODUCTS, const storage::Map< size_t, storage::Pair< size_t, size_t> > &REACTANT_ATOM_MAP, const storage::Map< size_t, storage::Pair< size_t, size_t> > &PRODUCT_ATOM_MAP )
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sdf_rxn_handler.h</td>
        <td>RXNHandler</td>
        <td>WriteToRXN( std::ostream &OSTREAM, const std::string &DESCRIPTION, const storage::Vector< storage::Vector< AtomInfo> > &REACTANT_ATOM_INFO, const storage::Vector< storage::Vector< BondInfo> > &REACTANT_BOND_INFO, const storage::Vector< storage::Vector< AtomInfo> > &PRODUCT_ATOM_INFO, const storage::Vector< storage::Vector< BondInfo> > &PRODUCT_BOND_INFO, const storage::Map< size_t, storage::Pair< size_t, size_t> > &REACTANT_ATOM_MAP, const storage::Map< size_t, storage::Pair< size_t, size_t> > &PRODUCT_ATOM_MAP, const storage::Vector< std::string> &REACTANT_DESCRIPTIONS = storage::Vector< std::string>(), const storage::Vector< std::string> &PRODUCT_DESCRIPTIONS = storage::Vector< std::string>() )
</td>
        <td>geanesar, mendenjl, combss</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection0</td>
        <td>CanBeCopied() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection0</td>
        <td>Clone()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection0</td>
        <td>Connection0( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)(), const bool COPY_CONNECTION = false)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection0</td>
        <td>Connection0()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection0</td>
        <td>Duplicate( Slots *NEW_DESTINATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection0</td>
        <td>Emit()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection0</td>
        <td>GetDestination() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection1</td>
        <td>CanBeCopied() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection1</td>
        <td>Clone()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection1</td>
        <td>Connection1( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)( t_ArgType1), const bool COPY_CONNECTION = false)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection1</td>
        <td>Connection1()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection1</td>
        <td>Duplicate( Slots *NEW_DESTINATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection1</td>
        <td>Emit( t_ArgType1 ARGUMENT1)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection1</td>
        <td>GetDestination() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection2</td>
        <td>CanBeCopied() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection2</td>
        <td>Clone()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection2</td>
        <td>Connection2( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)( t_ArgType1, t_ArgType2), const bool COPY_CONNECTION = false)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection2</td>
        <td>Connection2()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection2</td>
        <td>Duplicate( Slots *NEW_DESTINATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection2</td>
        <td>Emit( t_ArgType1 ARGUMENT1, t_ArgType2 ARGUMENT2)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection2</td>
        <td>GetDestination() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection3</td>
        <td>CanBeCopied() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection3</td>
        <td>Clone()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection3</td>
        <td>Connection3( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)( t_ArgType1, t_ArgType2, t_ArgType3), const bool COPY_CONNECTION = false)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection3</td>
        <td>Connection3()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection3</td>
        <td>Duplicate( Slots *NEW_DESTINATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection3</td>
        <td>Emit( t_ArgType1 ARGUMENT1, t_ArgType2 ARGUMENT2, t_ArgType3 ARGUMENT3)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection3</td>
        <td>GetDestination() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection4</td>
        <td>CanBeCopied() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection4</td>
        <td>Clone()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection4</td>
        <td>Connection4( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)( t_ArgType1, t_ArgType2, t_ArgType3, t_ArgType4), const bool COPY_CONNECTION = false)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection4</td>
        <td>Connection4()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection4</td>
        <td>Duplicate( Slots *NEW_DESTINATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_connection.h</td>
        <td>Connection4</td>
        <td>Emit( t_ArgType1 ARGUMENT1, t_ArgType2 ARGUMENT2, t_ArgType3 ARGUMENT3, t_ArgType4 ARGUMENT4)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_connection.h</td>
        <td>Connection4</td>
        <td>GetDestination() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal0</td>
        <td>Connect( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)(), const bool COPY_CONNECTION = false, const bool PUSH_FRONT = false )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal0</td>
        <td>Emit()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal0</td>
        <td>Signal0( const Signal0 &SIGNAL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal0</td>
        <td>Signal0()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal0</td>
        <td>operator ()()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal1</td>
        <td>Connect( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)( t_ArgType1), const bool COPY_CONNECTION = false, const bool PUSH_FRONT = false )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal1</td>
        <td>Emit( t_ArgType1 A1)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal1</td>
        <td>Signal1( const Signal1< t_ArgType1> &SIGNAL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal1</td>
        <td>Signal1()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal1</td>
        <td>operator ()( t_ArgType1 A1)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal2</td>
        <td>Connect( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)( t_ArgType1, t_ArgType2), const bool COPY_CONNECTION = false, const bool PUSH_FRONT = false )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal2</td>
        <td>Emit( t_ArgType1 A1, t_ArgType2 A2)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal2</td>
        <td>Signal2( const Signal2< t_ArgType1, t_ArgType2> &SIGNAL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal2</td>
        <td>Signal2()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal2</td>
        <td>operator ()( t_ArgType1 A1, t_ArgType2 A2)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal3</td>
        <td>Connect( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)( t_ArgType1, t_ArgType2, t_ArgType3), const bool COPY_CONNECTION = false, const bool PUSH_FRONT = false )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal3</td>
        <td>Emit( t_ArgType1 A1, t_ArgType2 A2, t_ArgType3 A3)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal3</td>
        <td>Signal3( const Signal3< t_ArgType1, t_ArgType2, t_ArgType3> &SIGNAL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal3</td>
        <td>Signal3()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal3</td>
        <td>operator ()( t_ArgType1 A1, t_ArgType2 A2, t_ArgType3 A3)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal4</td>
        <td>Connect( t_DestinationType *DESTINATION, void ( t_DestinationType::*MEMBER_FUNCTION_PTR)( t_ArgType1, t_ArgType2, t_ArgType3, t_ArgType4), const bool COPY_CONNECTION = false, const bool PUSH_FRONT = false )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal4</td>
        <td>Emit( t_ArgType1 A1, t_ArgType2 A2, t_ArgType3 A3, t_ArgType4 A4)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal4</td>
        <td>Signal4( const Signal4< t_ArgType1, t_ArgType2, t_ArgType3, t_ArgType4> &SIGNAL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal.h</td>
        <td>Signal4</td>
        <td>Signal4()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal.h</td>
        <td>Signal4</td>
        <td>operator ()( t_ArgType1 A1, t_ArgType2 A2, t_ArgType3 A3, t_ArgType4 A4)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase</td>
        <td>SignalBase()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase0</td>
        <td>Disconnect( Slots *SLOTS_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase0</td>
        <td>DisconnectAll()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase0</td>
        <td>SignalBase0( const SignalBase0 &SIGNAL_BASE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase0</td>
        <td>SignalBase0()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase0</td>
        <td>SlotDisconnect( Slots *SLOTS_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase0</td>
        <td>SlotDuplicate( const Slots *OLD_SLOT_PTR, Slots *NEW_SLOT_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase1</td>
        <td>Disconnect( Slots *SLOTS_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase1</td>
        <td>DisconnectAll()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase1</td>
        <td>SignalBase1( const SignalBase1< t_ArgType1> &SIGNAL_BASE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase1</td>
        <td>SignalBase1()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase1</td>
        <td>SlotDisconnect( Slots *SLOT_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase1</td>
        <td>SlotDuplicate( const Slots *OLD_SLOT_PTR, Slots *NEW_SLOT_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase2</td>
        <td>Disconnect( Slots *SLOTS_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase2</td>
        <td>DisconnectAll()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase2</td>
        <td>SignalBase2( const SignalBase2< t_ArgType1, t_ArgType2> &SIGNAL_BASE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase2</td>
        <td>SignalBase2()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase2</td>
        <td>SlotDisconnect( Slots *SLOT_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase2</td>
        <td>SlotDuplicate( const Slots *OLD_SLOT_PTR, Slots *NEW_SLOT_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase3</td>
        <td>Disconnect( Slots *SLOTS_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase3</td>
        <td>DisconnectAll()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase3</td>
        <td>SignalBase3( const SignalBase3< t_ArgType1, t_ArgType2, t_ArgType3> &SIGNAL_BASE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase3</td>
        <td>SignalBase3()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase3</td>
        <td>SlotDisconnect( Slots *SLOT_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase3</td>
        <td>SlotDuplicate( const Slots *OLD_SLOT_PTR, Slots *NEW_SLOT_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase4</td>
        <td>Disconnect( Slots *SLOTS_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase4</td>
        <td>DisconnectAll()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase4</td>
        <td>SignalBase4( const SignalBase4< t_ArgType1, t_ArgType2, t_ArgType3, t_ArgType4> &SIGNAL_BASE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase4</td>
        <td>SignalBase4()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase4</td>
        <td>SlotDisconnect( Slots *SLOT_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_signal_base.h</td>
        <td>SignalBase4</td>
        <td>SlotDuplicate( const Slots *OLD_SLOT_PTR, Slots *NEW_SLOT_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_slots.h</td>
        <td>Slots</td>
        <td>DisconnectAll()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_slots.h</td>
        <td>Slots</td>
        <td>SignalConnect( SignalBase *SENDER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_slots.h</td>
        <td>Slots</td>
        <td>SignalDisconnect( SignalBase *SENDER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_signal_slots.h</td>
        <td>Slots</td>
        <td>Slots( const Slots &SLOTS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_signal_slots.h</td>
        <td>Slots</td>
        <td>Slots()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_b2tmpred.h</td>
        <td>B2TMPRED</td>
        <td>B2TMPRED( const linal::Vector3D &VECTOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_b2tmpred.h</td>
        <td>B2TMPRED</td>
        <td>B2TMPRED()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_b2tmpred.h</td>
        <td>B2TMPRED</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_b2tmpred.h</td>
        <td>B2TMPRED</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_b2tmpred.h</td>
        <td>B2TMPRED</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_b2tmpred.h</td>
        <td>B2TMPRED</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_b2tmpred.h</td>
        <td>B2TMPRED</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_boctopus.h</td>
        <td>BOCTOPUS</td>
        <td>BOCTOPUS( const char &PREDICTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_boctopus.h</td>
        <td>BOCTOPUS</td>
        <td>BOCTOPUS()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_boctopus.h</td>
        <td>BOCTOPUS</td>
        <td>GetFileExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_boctopus.h</td>
        <td>BOCTOPUS</td>
        <td>GetNineStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_boctopus.h</td>
        <td>BOCTOPUS</td>
        <td>GetOneStateTMPrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_boctopus.h</td>
        <td>BOCTOPUS</td>
        <td>GetPrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_boctopus.h</td>
        <td>BOCTOPUS</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_boctopus.h</td>
        <td>BOCTOPUS</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_boctopus.h</td>
        <td>BOCTOPUS</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>CIPhiPsi( const biol::SSType &SS_TYPE, const biol::EnvironmentType &ENVIRONMENT, const bool &FACES_PORE, const TMDirection &DIRECTION = e_NonMembrane )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>CIPhiPsi()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>Calculate( assemble::ProteinModel &PROTEIN_MODEL, const bool &USE_PDBTM_MEMBRANE_THICKNESS) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>Calculate( biol::AASequence &SEQUENCE, const util::SiPtr< const biol::Membrane> &MEMBRANE_PTR) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>DoesBetaBarrelResidueFacePore() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>GetFileExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>GetNineStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>GetSSENumber() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>GetTMDirection() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>GetTMDirectionType( const TMDirection &DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>SetSSENumbers( biol::AASequence &AA_SEQUENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>WriteAnalysis( std::ostream &STREAM, const assemble::ProteinModel &PROTEIN_MODEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_ci_phi_psi.h</td>
        <td>CIPhiPsi</td>
        <td>WriteAnalysis( std::ostream &STREAM, const biol::AASequence &SEQUENCE, const char &CHAIN_ID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_conpred.h</td>
        <td>CONPRED</td>
        <td>CONPRED( const linal::Vector3D &VECTOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_conpred.h</td>
        <td>CONPRED</td>
        <td>CONPRED()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_conpred.h</td>
        <td>CONPRED</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_conpred.h</td>
        <td>CONPRED</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_conpred.h</td>
        <td>CONPRED</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_conpred.h</td>
        <td>CONPRED</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_conpred.h</td>
        <td>CONPRED</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_dssp.h</td>
        <td>Dssp</td>
        <td>Dssp( const biol::SSType &SS_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_dssp.h</td>
        <td>Dssp</td>
        <td>Dssp()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_dssp.h</td>
        <td>Dssp</td>
        <td>GetFileExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_dssp.h</td>
        <td>Dssp</td>
        <td>GetIsDeterminedFromSturcture() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_dssp.h</td>
        <td>Dssp</td>
        <td>GetNineStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_dssp.h</td>
        <td>Dssp</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_dssp.h</td>
        <td>Dssp</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_dssp.h</td>
        <td>Dssp</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_dssp_stride.h</td>
        <td>DsspStride</td>
        <td>DsspStride( const biol::SSType &SS_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_dssp_stride.h</td>
        <td>DsspStride</td>
        <td>DsspStride()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_dssp_stride.h</td>
        <td>DsspStride</td>
        <td>GetFileExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_dssp_stride.h</td>
        <td>DsspStride</td>
        <td>GetIsDeterminedFromSturcture() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_dssp_stride.h</td>
        <td>DsspStride</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo.h</td>
        <td>JUFO</td>
        <td>Calculate( assemble::ProteinModel &PROTEIN_MODEL)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo.h</td>
        <td>JUFO</td>
        <td>Calculate( biol::AASequence &SEQUENCE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo.h</td>
        <td>JUFO</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo.h</td>
        <td>JUFO</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo.h</td>
        <td>JUFO</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo.h</td>
        <td>JUFO</td>
        <td>JUFO( const linal::Vector3D &VECTOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo.h</td>
        <td>JUFO</td>
        <td>JUFO()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo.h</td>
        <td>JUFO</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo.h</td>
        <td>JUFO</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>Calculate( assemble::ProteinModel &MODEL, const bool MULTIMER = false)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>Calculate( assemble::ProteinModelWithCache &MODEL, const bool MULTIMER = false)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>GetJufo9DANNDescriptors( const bool &MULTIMER)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>JUFO9D( const linal::Matrix< double> &MATRIX)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>JUFO9D( const linal::Vector< double> &VECTOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>JUFO9D()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>TMTypeProbability( const biol::SSType &SS_TYPE) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>WriteThreeStateTMPredictions( std::ostream &OSTREAM, const biol::AASequence &AA_SEQUENCE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>WriteTwoStateTMPredictions( std::ostream &OSTREAM, const biol::AASequence &AA_SEQUENCE, const biol::SSType &SS_TYPE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_jufo9d.h</td>
        <td>JUFO9D</td>
        <td>operator =( const JUFO9D &JUFO_RHS)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_jufo_ann.h</td>
        <td>JUFOANN</td>
        <td>F( const linal::Vector< double> &INPUT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_kaksi.h</td>
        <td>Kaksi</td>
        <td>GetFileExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_kaksi.h</td>
        <td>Kaksi</td>
        <td>GetIsDeterminedFromSturcture() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_kaksi.h</td>
        <td>Kaksi</td>
        <td>GetNineStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_kaksi.h</td>
        <td>Kaksi</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_kaksi.h</td>
        <td>Kaksi</td>
        <td>Kaksi( const linal::Vector3D &VECTOR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_kaksi.h</td>
        <td>Kaksi</td>
        <td>Kaksi()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_kaksi.h</td>
        <td>Kaksi</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_kaksi.h</td>
        <td>Kaksi</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>Calculate( assemble::ProteinModel &PROTEIN_MODEL, const bool &USE_PDBTM_MEMBRANE_THICKNESS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>Calculate( biol::AASequence &SEQUENCE, const util::SiPtr< const biol::Membrane> &MEMBRANE_PTR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>ComputeCytosolicTMOrientation( biol::AASequence &AA_SEQUENCE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>DoesBetaBarrelResidueFacePore() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>GetFileExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>GetIsDeterminedFromSturcture() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>GetNineStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>Mahssmi( const biol::SSType &SS_TYPE, const biol::EnvironmentType &ENVIRONMENT, const bool &FACES_PORE, const bool &ORIGINATES_CYTOSOL = false )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>Mahssmi()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>OriginatesInCytosol() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>WriteAnalysis( std::ostream &STREAM, const assemble::ProteinModel &PROTEIN_MODEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_mahssmi.h</td>
        <td>Mahssmi</td>
        <td>WriteAnalysis( std::ostream &STREAM, const biol::AASequence &SEQUENCE, const char &CHAIN_ID)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_masp.h</td>
        <td>MASP</td>
        <td>GetFileExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_masp.h</td>
        <td>MASP</td>
        <td>GetNineStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_masp.h</td>
        <td>MASP</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_masp.h</td>
        <td>MASP</td>
        <td>MASP( const linal::Vector3D &MEMBRANE_SS_PREDICTION, const linal::Vector3D &SOLUBLE_SS_PREDICTION )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_masp.h</td>
        <td>MASP</td>
        <td>MASP()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_masp.h</td>
        <td>MASP</td>
        <td>PredictBetaBarrelEnvironmentSS( assemble::ProteinModel &MODEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_masp.h</td>
        <td>MASP</td>
        <td>PredictBetaBarrelEnvironmentSS( assemble::ProteinModelWithCache &MODEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_masp.h</td>
        <td>MASP</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_masp.h</td>
        <td>MASP</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>AvailablePredictionFiles( const storage::Set< Method> &SS_METHODS, const char CHAIN_ID, const std::string &PREFIX, const std::string &PATH = Ó )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>InitializePredictionsForAASequence( const Method &SS_METHOD, biol::AASequence &AA_SEQUENCE, const MethodInterface &PREDICTION )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>MethodHandler()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>PossibleFileEntries( const Method &SS_METHOD, const char CHAIN_ID, const std::string &PREFIX, const std::string &PATH = Ó )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>PossibleFileEntries( const std::string &EXTENSION, const char CHAIN_ID, const std::string &PREFIX, const std::string &PATH )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>ReadAllPredictionsForProteinModel( assemble::ProteinModel &PROTEIN_MODEL, const std::string &PREFIX, const std::string &PATH = Ó )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID, const Method &SS_METHOD )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>ReadPredictionsForAASequence( const storage::Set< Method> &SS_METHODS, biol::AASequence &AA_SEQUENCE, const std::string &PREFIX, const std::string &PATH = Ó )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE, const Method &SS_METHOD )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>ReadPredictionsForProteinModel( const storage::Set< Method> &SS_METHODS, assemble::ProteinModel &PROTEIN_MODEL, const std::string &PREFIX, const std::string &PATH = Ó )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>SetPredictionsForSubSequence( const Method &SS_METHOD, biol::AASequence &AA_SEQUENCE, const MethodInterface &PREDICTION, const size_t FIRST, const size_t LAST )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>WritePredictionsForAASequence( const storage::Set< Method> &SS_METHODS, const biol::AASequence &AA_SEQUENCE, const std::string &PREFIX, const bool &WRITE_TO_STD_COUT, const std::string &PATH = Ó, const OutputTypes OUTPUT_TYPE = e_ThreeState )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>WritePredictionsForAASequence( std::ostream &OSTREAM, const biol::AASequence &AA_SEQUENCE, const Method &SS_METHOD, const OutputTypes OUTPUT_TYPE = e_ThreeState )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_handler.h</td>
        <td>MethodHandler</td>
        <td>WritePredictionsForProteinModel( const storage::Set< Method> &SS_METHODS, const assemble::ProteinModel &PROTEIN_MODEL, const std::string &PREFIX, const bool &WRITE_TO_STD_COUT, const std::string &PATH = Ó, const OutputTypes OUTPUT_TYPE = e_ThreeState )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>ConvertNineStateToThreeState( const linal::Matrix< double> &NINE_STATE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>ConvertThreeStateToNineState( const linal::Vector3D &THREE_STATE, const biol::EnvironmentType &TM_TYPE )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>GetDefaultPredictionMatrix()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>GetDefaultPredictionVector()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>GetIsDeterminedFromSturcture() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>GetOneStateSSPrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>GetOneStateSSTMPrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>GetOneStateTMPrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>GetThreeStateTMPrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>WriteNineStatePredictions( std::ostream &OSTREAM) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>WritePredictions( std::ostream &OSTREAM) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_method_interface.h</td>
        <td>MethodInterface</td>
        <td>WriteThreeStatePredictions( std::ostream &OSTREAM) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_methods.h</td>
        <td>Methods</td>
        <td>GetCommandLineMethods()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_methods.h</td>
        <td>Methods</td>
        <td>GetFlagReadSSPredictions()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_methods.h</td>
        <td></td>
        <td>GetMethods()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_octopus.h</td>
        <td>OCTOPUS</td>
        <td>GetFileExtension() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_octopus.h</td>
        <td>OCTOPUS</td>
        <td>GetNineStatePrediction() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_octopus.h</td>
        <td>OCTOPUS</td>
        <td>GetOneStateTMPrediction() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_octopus.h</td>
        <td>OCTOPUS</td>
        <td>GetPrediction() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_octopus.h</td>
        <td>OCTOPUS</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_octopus.h</td>
        <td>OCTOPUS</td>
        <td>OCTOPUS( const char &PREDICTION)
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_octopus.h</td>
        <td>OCTOPUS</td>
        <td>OCTOPUS()
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_octopus.h</td>
        <td>OCTOPUS</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_octopus.h</td>
        <td>OCTOPUS</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_palsse.h</td>
        <td>Palsse</td>
        <td>GetFileExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_palsse.h</td>
        <td>Palsse</td>
        <td>GetIsDeterminedFromSturcture() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_palsse.h</td>
        <td>Palsse</td>
        <td>GetNineStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_palsse.h</td>
        <td>Palsse</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_palsse.h</td>
        <td>Palsse</td>
        <td>Palsse( const biol::SSType &SS_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_palsse.h</td>
        <td>Palsse</td>
        <td>Palsse()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_palsse.h</td>
        <td>Palsse</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_palsse.h</td>
        <td>Palsse</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_partifold.h</td>
        <td>PARTIFOLD</td>
        <td>GetFileExtension() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_partifold.h</td>
        <td>PARTIFOLD</td>
        <td>GetNineStatePrediction() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_partifold.h</td>
        <td>PARTIFOLD</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_partifold.h</td>
        <td>PARTIFOLD</td>
        <td>PARTIFOLD( const linal::Vector3D &VECTOR)
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_partifold.h</td>
        <td>PARTIFOLD</td>
        <td>PARTIFOLD()
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_partifold.h</td>
        <td>PARTIFOLD</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_partifold.h</td>
        <td>PARTIFOLD</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>GetIsDeterminedFromSturcture() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>GetOneStateSSPrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>GetOneStateSSTMPrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>GetOneStateTMPrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>PDB( const biol::SSType &SS_TYPE, const biol::EnvironmentType &ENVIRONMENT_TYPE)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>PDB()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_pdb.h</td>
        <td>PDB</td>
        <td>SetEnvironmentTypes( assemble::ProteinModel &PROTEIN_MODEL, const bool &USE_PDBTM_MEMBRANE_THICKNESS = false )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_profphd.h</td>
        <td>PROFphd</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_profphd.h</td>
        <td>PROFphd</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_profphd.h</td>
        <td>PROFphd</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_profphd.h</td>
        <td>PROFphd</td>
        <td>PROFphd( const linal::Vector3D &VECTOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_profphd.h</td>
        <td>PROFphd</td>
        <td>PROFphd()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_profphd.h</td>
        <td>PROFphd</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_profphd.h</td>
        <td>PROFphd</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_proftmb.h</td>
        <td>PROFTMB</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_proftmb.h</td>
        <td>PROFTMB</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_proftmb.h</td>
        <td>PROFTMB</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_proftmb.h</td>
        <td>PROFTMB</td>
        <td>PROFTMB( const linal::Matrix< double> &MATRIX)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_proftmb.h</td>
        <td>PROFTMB</td>
        <td>PROFTMB()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_proftmb.h</td>
        <td>PROFTMB</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_proftmb.h</td>
        <td>PROFTMB</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_psipred.h</td>
        <td>PSIPRED</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_psipred.h</td>
        <td>PSIPRED</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_psipred.h</td>
        <td>PSIPRED</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_psipred.h</td>
        <td>PSIPRED</td>
        <td>PSIPRED( const linal::Vector3D &VECTOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_psipred.h</td>
        <td>PSIPRED</td>
        <td>PSIPRED()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_psipred.h</td>
        <td>PSIPRED</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_psipred.h</td>
        <td>PSIPRED</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sam.h</td>
        <td>SAM</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sam.h</td>
        <td>SAM</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sam.h</td>
        <td>SAM</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sam.h</td>
        <td>SAM</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sam.h</td>
        <td>SAM</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sam.h</td>
        <td>SAM</td>
        <td>SAM( const linal::Vector3D &VECTOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sam.h</td>
        <td>SAM</td>
        <td>SAM()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sse_factory_highest.h</td>
        <td>SSEFactoryHighest</td>
        <td>SSEFactoryHighest( const Method &SSMETHOD )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sse_factory_highest.h</td>
        <td>SSEFactoryHighest</td>
        <td>SetMethod( const Method &SS_METHOD)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sse_factory_highest.h</td>
        <td>SSEFactoryHighest</td>
        <td>SetThresholds( const storage::Map< biol::SSType, double> &SSTYPE_THRESHOLDS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sse_factory_highest.h</td>
        <td>SSEFactoryHighest</td>
        <td>operator ()( const biol::AASequence &SEQUENCE) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sse_factory_threshold.h</td>
        <td>SSEFactoryThreshold</td>
        <td>GetDefaultThresholdsMap()
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sse_factory_threshold.h</td>
        <td>SSEFactoryThreshold</td>
        <td>GetMethod() const
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sse_factory_threshold.h</td>
        <td>SSEFactoryThreshold</td>
        <td>SSEFactoryThreshold( const Method &SS_METHOD, const storage::Map< biol::SSType, double> &SSE_THRESHOLDS = GetDefaultThresholdsMap(), const bool EXTEND_SSES = false )
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sse_factory_threshold.h</td>
        <td>SSEFactoryThreshold</td>
        <td>SSEFactoryThreshold()
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sse_factory_threshold.h</td>
        <td>SSEFactoryThreshold</td>
        <td>SSEGetThresholds() const
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sse_factory_threshold.h</td>
        <td>SSEFactoryThreshold</td>
        <td>SetExtendSSEs( const bool EXTEND_SSES)
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sse_factory_threshold.h</td>
        <td>SSEFactoryThreshold</td>
        <td>SetMethod( const Method &SS_METHOD)
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_sse_factory_threshold.h</td>
        <td>SSEFactoryThreshold</td>
        <td>SetThresholds( const storage::Map< biol::SSType, double> &SSTYPE_THRESHOLDS)
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_sse_factory_threshold.h</td>
        <td>SSEFactoryThreshold</td>
        <td>operator ()( const biol::AASequence &SEQUENCE) const
</td>
        <td>linders, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_stride.h</td>
        <td>Stride</td>
        <td>GetFileExtension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_stride.h</td>
        <td>Stride</td>
        <td>GetIsDeterminedFromSturcture() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_stride.h</td>
        <td>Stride</td>
        <td>GetNineStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_stride.h</td>
        <td>Stride</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_stride.h</td>
        <td>Stride</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_stride.h</td>
        <td>Stride</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_stride.h</td>
        <td>Stride</td>
        <td>Stride( const biol::SSType &SS_TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_stride.h</td>
        <td>Stride</td>
        <td>Stride()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_talos.h</td>
        <td>TALOS</td>
        <td>GetFileExtension() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_talos.h</td>
        <td>TALOS</td>
        <td>GetNineStatePrediction() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_talos.h</td>
        <td>TALOS</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_talos.h</td>
        <td>TALOS</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_talos.h</td>
        <td>TALOS</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE) const
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_talos.h</td>
        <td>TALOS</td>
        <td>TALOS( const linal::Vector3D &VECTOR)
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_talos.h</td>
        <td>TALOS</td>
        <td>TALOS()
</td>
        <td>weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmbetanet.h</td>
        <td>TMBETANET</td>
        <td>GetFileExtension() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmbetanet.h</td>
        <td>TMBETANET</td>
        <td>GetNineStatePrediction() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmbetanet.h</td>
        <td>TMBETANET</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmbetanet.h</td>
        <td>TMBETANET</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmbetanet.h</td>
        <td>TMBETANET</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmbetanet.h</td>
        <td>TMBETANET</td>
        <td>TMBETANET( const linal::Vector3D &VECTOR)
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmbetanet.h</td>
        <td>TMBETANET</td>
        <td>TMBETANET()
</td>
        <td>koehlej, weinerbe</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmhmm.h</td>
        <td>TMHMM</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmhmm.h</td>
        <td>TMHMM</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmhmm.h</td>
        <td>TMHMM</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmhmm.h</td>
        <td>TMHMM</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmhmm.h</td>
        <td>TMHMM</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmhmm.h</td>
        <td>TMHMM</td>
        <td>TMHMM( const linal::Vector3D &VECTOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmhmm.h</td>
        <td>TMHMM</td>
        <td>TMHMM()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmmod.h</td>
        <td>TMMOD</td>
        <td>GetFileExtension() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmmod.h</td>
        <td>TMMOD</td>
        <td>GetNineStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmmod.h</td>
        <td>TMMOD</td>
        <td>GetThreeStatePrediction() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmmod.h</td>
        <td>TMMOD</td>
        <td>ReadPredictionsForAA( std::istream &ISTREAM, biol::AABase &AMINO_ACID ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmmod.h</td>
        <td>TMMOD</td>
        <td>ReadPredictionsForAASequence( std::istream &ISTREAM, biol::AASequence &AA_SEQUENCE ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_sspred_tmmod.h</td>
        <td>TMMOD</td>
        <td>TMMOD( const linal::Vector3D &VECTOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_sspred_tmmod.h</td>
        <td>TMMOD</td>
        <td>TMMOD()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage.h</td>
        <td></td>
        <td>AdvanceIterator( t_IteratorType &ITERATOR, const t_IteratorType &END_ITERATOR, const size_t N )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Begin()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Begin() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Count( const t_KeyType &KEY) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>End()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>End() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>EqualRange( const t_KeyType &KEY)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Erase( const t_KeyType &KEY)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Erase( iterator ITR_A, iterator ITR_B)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Find( const t_KeyType &KEY)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Find( const t_KeyType &KEY) const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>GetSize() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>HashMap( const HashMap< t_KeyType, t_DataType> &HASH_MAP )
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>HashMap( t_InputIterator ITR_BEGIN, t_InputIterator ITR_END)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>HashMap()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Insert( const Pair< t_KeyType, t_DataType> &BCL_PAIR)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Insert( const std::pair< t_KeyType, t_DataType> &STD_PAIR)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>InsertElement( const Pair< t_KeyType, t_DataType> &BCL_PAIR)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>InsertElement( const std::pair< t_KeyType, t_DataType> &STD_PAIR)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>InsertElement( iterator ITR, const Pair< t_KeyType, t_DataType> &BCL_PAIR)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>InsertElement( iterator ITR, const std::pair< t_KeyType, t_DataType> &STD_PAIR)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>InsertElements( const HashMap< t_KeyType, t_DataType> &MAP)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>InsertElements( const t_Iterator ITR_A, const t_Iterator ITR_B)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>InternalData()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>InternalData() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>IsEmpty() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>MaxSize() const
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>RemoveElement( iterator ITR)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Reset()
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>Swap( HashMap< t_KeyType, t_DataType> &SWAPPER)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>HashMap</td>
        <td>operator []( const t_KeyType &KEY)
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td>hash</td>
        <td>operator ()( const std::string &ARG) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td>hash</td>
        <td>operator ()( size_t __x) const
</td>
        <td>fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_hash_map.h</td>
        <td></td>
        <td>AddInstance( new HashMap< t_KeyType, t_DataType>())
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_hash_map.h</td>
        <td></td>
        <td>operator ==( const HashMap< t_KeyType, t_DataType> &HASHMAP_A, const HashMap< t_KeyType, t_DataType> &HASHMAP_B )
</td>
        <td>karakam, fischea</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Append( const List< t_DataType> &LIST)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Append( const t_DataType &ELEMENT)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Append( t_DataType && ELEMENT)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Append( t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Begin()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Begin() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>End()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>End() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>ExtractElement( size_t POS)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>ExtractElements( size_t POS, size_t NUMBER = 1)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>FirstElement()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>FirstElement() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>GetSize() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>InsertElement( const t_DataType &ELEMENT)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>InsertElement( const t_InputIterator ITR, const t_DataType &ELEMENT)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>InsertElements( iterator ITR_POS, const List< t_DataType> &LIST)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>InsertElements( iterator ITR_POS, t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>InternalData()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>IsEmpty() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Last()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Last() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>LastElement()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>LastElement() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>List( List< t_DataType> && LIST)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>List( const List< t_DataType> &LIST)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>List( const size_t SIZE, const t_DataType &VALUE = t_DataType())
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>List( const size_t SIZE, const t_DataType *DATA)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>List( const t_Iterator &BEGIN, const t_Iterator &END)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>List()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>MaxSize() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Merge( List< t_DataType> &X, t_BinaryPredicate COMPARABLE)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>PopBack()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>PopFront()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Prepend( const List< t_DataType> &LIST)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Prepend( const t_DataType &ELEMENT)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Prepend( t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>PushBack( const t_DataType &ELEMENT = t_DataType())
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>PushBack( t_DataType && ELEMENT)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>PushFront( const t_DataType &ELEMENT = t_DataType())
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Remove( iterator ITR)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Remove( iterator ITR_FIRST, iterator ITR_LAST)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>RemoveElement( iterator ITR)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Reset()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Resize( const size_t NUMBER_ELEMENTS, const t_DataType &ELEMENT = t_DataType())
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Reverse()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>ReverseBegin()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>ReverseBegin() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>ReverseEnd()
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>ReverseEnd() const
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>SetAllElements( const t_DataType &ELEMENT = t_DataType())
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Sort( t_BinaryPredicate COMPARABLE)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Splice( t_Iterator ITR, List< t_DataType> &X)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>Unique( t_BinaryPredicate COMPARABLE)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>operator =( List< t_DataType> && LIST)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td>List</td>
        <td>operator =( const List< t_DataType> &LIST)
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_list.h</td>
        <td></td>
        <td>AddInstance( new List< t_DataType>())
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_list.h</td>
        <td></td>
        <td>operator ==( const List< t_DataType> &LIST_A, const List< t_DataType> &LIST_B )
</td>
        <td>heinzes1, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Begin()
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Begin() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Count( const t_KeyType &KEY) const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Create( const std::pair< t_KeyType, t_DataType> &DATA_A )
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Create( const std::pair< t_KeyType, t_DataType> &DATA_A, const std::pair< t_KeyType, t_DataType> &DATA_B )
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Create( const std::pair< t_KeyType, t_DataType> &DATA_A, const std::pair< t_KeyType, t_DataType> &DATA_B, const std::pair< t_KeyType, t_DataType> &DATA_C )
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Create( const std::pair< t_KeyType, t_DataType> &DATA_A, const std::pair< t_KeyType, t_DataType> &DATA_B, const std::pair< t_KeyType, t_DataType> &DATA_C, const std::pair< t_KeyType, t_DataType> &DATA_D )
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Create( const std::pair< t_KeyType, t_DataType> &DATA_A, const std::pair< t_KeyType, t_DataType> &DATA_B, const std::pair< t_KeyType, t_DataType> &DATA_C, const std::pair< t_KeyType, t_DataType> &DATA_D, const std::pair< t_KeyType, t_DataType> &DATA_E )
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>End()
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>End() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>EqualRange( const t_KeyType &KEY)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Erase( const t_KeyType &KEY)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Erase( iterator ITR_A, iterator ITR_B)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Find( const t_KeyType &KEY)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Find( const t_KeyType &KEY) const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>GetKeys() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>GetKeysAsVector() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>GetMappedValues() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>GetSize() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>GetValue( const t_KeyType &KEY) const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Has( const t_KeyType &KEY) const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Insert( const Pair< t_KeyType, t_DataType> &BCL_PAIR)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Insert( const std::pair< t_KeyType, t_DataType> &STD_PAIR)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>InsertElement( const Pair< t_KeyType, t_DataType> &BCL_PAIR)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>InsertElement( const std::pair< t_KeyType, t_DataType> &STD_PAIR)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>InsertElement( iterator ITR, const Pair< t_KeyType, t_DataType> &BCL_PAIR)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>InsertElement( iterator ITR, const std::pair< t_KeyType, t_DataType> &STD_PAIR)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>InsertElements( const Map< t_KeyType, t_DataType, t_KeyCompare> &MAP)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>InsertElements( const t_Iterator ITR_A, const t_Iterator ITR_B)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>InternalData()
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>IsEmpty() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>LowerBound( const t_KeyType &KEY)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>LowerBound( const t_KeyType &KEY) const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Map( Map && MAP)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Map( const Map &MAP)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Map( const t_Iterator &FIRST, const t_Iterator &LAST )
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Map()
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>MaxSize() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>RemoveElement( iterator ITR)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Reset()
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>ReverseBegin()
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>ReverseBegin() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>ReverseEnd()
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>ReverseEnd() const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>Swap( Map< t_KeyType, t_DataType, t_KeyCompare> &SWAPPER)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>UpperBound( const t_KeyType &KEY)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>UpperBound( const t_KeyType &KEY) const
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>operator =( Map && MAP)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>operator =( const Map &MAP)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td>Map</td>
        <td>operator []( const t_KeyType &KEY)
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td></td>
        <td>AddInstance( new Map< t_KeyType, t_DataType, t_KeyCompare>())
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td></td>
        <td>operator !=( const Map< t_KeyType, t_DataType, t_CompareType> &MAP_A, const Map< t_KeyType, t_DataType, t_CompareType> &MAP_B )
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_map.h</td>
        <td></td>
        <td>operator <( const Map< t_KeyType, t_DataType, t_CompareType> &MAP_A, const Map< t_KeyType, t_DataType, t_CompareType> &MAP_B )
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_map.h</td>
        <td></td>
        <td>operator ==( const Map< t_KeyType, t_DataType, t_CompareType> &MAP_A, const Map< t_KeyType, t_DataType, t_CompareType> &MAP_B )
</td>
        <td>alexanns, jsmith</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>Find( const VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>Find( const VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>Find( const VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS, const size_t &INFO)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>Find( const VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS, const size_t &INFO) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>HashKey( const VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>HashKey( const VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS, const size_t &INFO)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>HashKeyAndOrderObjects( VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>HashKeyAndOrderObjects( VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS, const size_t &INFO )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>Insert( const VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS, const size_t &INFO, const t_DataType &DATA )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>Insert( const VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS, const t_DataType &DATA)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>InsertAndOrderObjects( VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS, const size_t &INFO, const t_DataType &DATA )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>InsertAndOrderObjects( VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS, const t_DataType &DATA )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>ObjectNDHashMap()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td>ObjectNDHashMap</td>
        <td>operator []( const VectorND< t_NumberOfObjects, util::SiPtr< const t_ObjectType> > &OBJECTS)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td></td>
        <td>AddInstance( new ObjectNDHashMap< t_NumberOfObjects, t_ObjectType, t_DataType>())
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td></td>
        <td>operator <<( std::ostream &OSTREAM, const ObjectNDHashMap< t_NumberOfObjects, t_ObjectType, t_DataType> &OBJECT_ND_HASHMAP )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_object_nd_hash_map.h</td>
        <td></td>
        <td>operator >>( std::istream &ISTREAM, const ObjectNDHashMap< t_NumberOfObjects, t_ObjectType, t_DataType> &OBJECTNDHASHMAP )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>First()
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>First() const
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>Pair( Pair && PAIR)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>Pair( const Pair &PAIR)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>Pair( const std::pair< t_First, t_Second> &PAIR)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>Pair( const t_First &FIRST, const t_Second &SECOND)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>Pair()
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>Second()
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>Second() const
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>operator <( const Pair< t_First, t_Second> &PAIR_B) const
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>operator =( Pair && PAIR)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>operator =( const Pair &PAIR)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>operator =( const std::pair< t_First, t_Second> &PAIR)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>Pair</td>
        <td>operator >( const Pair< t_First, t_Second> &PAIR_B) const
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>PairBinaryPredicateFirst</td>
        <td>PairBinaryPredicateFirst( const util::BinaryFunctionInterface< t_First, t_First, bool> &BINARY_PREDICATE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>PairBinaryPredicateFirst</td>
        <td>operator ()( const Pair< t_First, t_Second> &PAIR_A, const Pair< t_First, t_Second> &PAIR_B) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>PairBinaryPredicateSecond</td>
        <td>PairBinaryPredicateSecond( const util::BinaryFunctionInterface< t_Second, t_Second, bool> &BINARY_PREDICATE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>PairBinaryPredicateSecond</td>
        <td>operator ()( const Pair< t_First, t_Second> &PAIR_A, const Pair< t_First, t_Second> &PAIR_B) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>PairBinaryPredicateSecond</td>
        <td>operator ()( const std::pair< t_First, t_Second> &PAIR_A, const std::pair< t_First, t_Second> &PAIR_B) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td>PairEqualFirst</td>
        <td>PairEqualFirst( const t_First &FIRST)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td>PairEqualFirst</td>
        <td>operator ()( const Pair< t_First, t_Second> &PAIR) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td></td>
        <td>AddInstance( new Pair< t_First, t_Second>())
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_pair.h</td>
        <td></td>
        <td>operator !=( const Pair< t_First, t_Second> &PAIR_A, const Pair< t_First, t_Second> &PAIR_B)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_pair.h</td>
        <td></td>
        <td>operator ==( const Pair< t_First, t_Second> &PAIR_A, const Pair< t_First, t_Second> &PAIR_B)
</td>
        <td>haenigc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>Begin()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>Begin() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>ConvertToMap() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>ConvertToPairList() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>End()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>End() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>FirstElement()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>FirstElement() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>GetData() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>GetHeader() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>GetSize() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>InternalData() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>Last()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>Last() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>LastElement()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>LastElement() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>ReverseBegin()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>ReverseBegin() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>ReverseEnd()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>ReverseEnd() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>Row( const Row< t_DataType> &ROW)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>Row()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>SetAllElements( const t_DataType &ELEMENT = t_DataType())
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>WriteFormatted( std::ostream &OSTREAM, const std::vector< util::Format> &COLUMN_FORMATS ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>WriteFormatted( std::ostream &OSTREAM, const util::Format &FORMAT_COLS = util::Format().W( 10) ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>operator ()( const size_t POS)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>operator []( const std::string &COLUMN_NAME)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>Row</td>
        <td>operator []( const std::string &COLUMN_NAME) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td>RowComparison</td>
        <td>RowComparison( const size_t COLUMN_INDEX, const util::BinaryFunctionInterface< t_DataType, t_DataType, bool> &BINARY_PREDICATE = ( **math::Comparisons< t_DataType>::GetEnums().e_Less) )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td>RowComparison</td>
        <td>operator ()( const Row< t_DataType> &ROW_A, const Row< t_DataType> &ROW_B) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_row.h</td>
        <td></td>
        <td>AddInstance( new Row< t_DataType>())
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_row.h</td>
        <td></td>
        <td>operator ==( const Row< t_DataType> &ROW_A, const Row< t_DataType> &ROW_B )
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Begin()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Begin() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Contains( const t_KeyType &KEY) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Count( const t_KeyType &KEY) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N, const t_KeyType &DATA_O )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N, const t_KeyType &DATA_O, const t_KeyType &DATA_P )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N, const t_KeyType &DATA_O, const t_KeyType &DATA_P, const t_KeyType &DATA_Q )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N, const t_KeyType &DATA_O, const t_KeyType &DATA_P, const t_KeyType &DATA_Q, const t_KeyType &DATA_R )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N, const t_KeyType &DATA_O, const t_KeyType &DATA_P, const t_KeyType &DATA_Q, const t_KeyType &DATA_R, const t_KeyType &DATA_S )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N, const t_KeyType &DATA_O, const t_KeyType &DATA_P, const t_KeyType &DATA_Q, const t_KeyType &DATA_R, const t_KeyType &DATA_S, const t_KeyType &DATA_T )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N, const t_KeyType &DATA_O, const t_KeyType &DATA_P, const t_KeyType &DATA_Q, const t_KeyType &DATA_R, const t_KeyType &DATA_S, const t_KeyType &DATA_T, const t_KeyType &DATA_U )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N, const t_KeyType &DATA_O, const t_KeyType &DATA_P, const t_KeyType &DATA_Q, const t_KeyType &DATA_R, const t_KeyType &DATA_S, const t_KeyType &DATA_T, const t_KeyType &DATA_U, const t_KeyType &DATA_V )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Create( const t_KeyType &DATA_A, const t_KeyType &DATA_B, const t_KeyType &DATA_C, const t_KeyType &DATA_D, const t_KeyType &DATA_E, const t_KeyType &DATA_F, const t_KeyType &DATA_G, const t_KeyType &DATA_H, const t_KeyType &DATA_I, const t_KeyType &DATA_J, const t_KeyType &DATA_K, const t_KeyType &DATA_L, const t_KeyType &DATA_M, const t_KeyType &DATA_N, const t_KeyType &DATA_O, const t_KeyType &DATA_P, const t_KeyType &DATA_Q, const t_KeyType &DATA_R, const t_KeyType &DATA_S, const t_KeyType &DATA_T, const t_KeyType &DATA_U, const t_KeyType &DATA_V, const t_KeyType &DATA_W, const t_KeyType &DATA_X )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>End()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>End() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>EqualRange( const t_KeyType &KEY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Erase( const t_KeyType &KEY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Erase( iterator ITR_A, iterator ITR_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>EraseKeys( t_Iterator ITR, t_Iterator ITR_END)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Find( const t_KeyType &KEY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Find( const t_KeyType &KEY) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>GetSize() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Insert( const t_KeyType &KEY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Insert( iterator ITR, const t_KeyType &KEY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>InsertElement( const t_KeyType &ELEMENT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>InsertElements( const Set< t_KeyType, t_KeyCompare> &SET)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>InsertElements( t_Iterator ITR_A, t_Iterator ITR_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>InternalData()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>IsEmpty() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>IsSubsetOf( const Set< t_KeyType, t_KeyCompare> &SUPERSET) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>LowerBound( const t_KeyType &KEY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>LowerBound( const t_KeyType &KEY) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>MaxSize() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>RemoveElement( iterator ITR)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Reset()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>ReverseBegin()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>ReverseBegin() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>ReverseEnd()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>ReverseEnd() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Set( Set< t_KeyType, t_KeyCompare> && SET)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Set( const Set< t_KeyType, t_KeyCompare> &SET )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Set( const t_KeyType &OBJECT)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Set( const t_KeyType &OBJECT_A, const t_KeyType &OBJECT_B)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Set( const t_KeyType &OBJECT_A, const t_KeyType &OBJECT_B, const t_KeyType &OBJECT_C)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Set( const t_KeyType &OBJECT_A, const t_KeyType &OBJECT_B, const t_KeyType &OBJECT_C, const t_KeyType &OBJECT_D )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Set( t_Iterator FIRST, t_Iterator LAST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Set()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>Swap( Set< t_KeyType, t_KeyCompare> &SWAP_SET)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>UpperBound( const t_KeyType &KEY)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>UpperBound( const t_KeyType &KEY) const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>operator =( Set && SET)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td>Set</td>
        <td>operator =( const Set &SET)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td></td>
        <td>AddInstance( new Set< t_KeyType, t_KeyCompare>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td></td>
        <td>operator +( const Set< t_DataType> &A, const Set< t_DataType> &B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td></td>
        <td>operator -( const Set< t_DataType> &A, const Set< t_DataType> &B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td></td>
        <td>operator <( const Set< t_DataType> &SET_A, const Set< t_DataType> &SET_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_set.h</td>
        <td></td>
        <td>operator ==( const Set< t_DataType> &SET_A, const Set< t_DataType> &SET_B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_set.h</td>
        <td></td>
        <td>operator ^( const Set< t_DataType> &A, const Set< t_DataType> &B )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_symmetric_matrix.h</td>
        <td>SymmetricMatrix</td>
        <td>Fill( const t_DataType FILL_VALUE)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_symmetric_matrix.h</td>
        <td>SymmetricMatrix</td>
        <td>GetSize() const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_symmetric_matrix.h</td>
        <td>SymmetricMatrix</td>
        <td>Reset()
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_symmetric_matrix.h</td>
        <td>SymmetricMatrix</td>
        <td>Resize( const size_t NEW_SIZE, const t_DataType FILL_VALUE = t_DataType())
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_symmetric_matrix.h</td>
        <td>SymmetricMatrix</td>
        <td>SymmetricMatrix( const size_t N)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_symmetric_matrix.h</td>
        <td>SymmetricMatrix</td>
        <td>SymmetricMatrix()
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_symmetric_matrix.h</td>
        <td>SymmetricMatrix</td>
        <td>operator ()( const size_t I_POS, const size_t J_POS)
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_symmetric_matrix.h</td>
        <td>SymmetricMatrix</td>
        <td>operator ()( const size_t I_POS, const size_t J_POS) const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_symmetric_matrix.h</td>
        <td>SymmetricMatrix</td>
        <td>operator ==( const SymmetricMatrix< t_DataType> &MATRIX_A) const
</td>
        <td>teixeipl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Append( const Table< t_DataType> &TABLE, const bool INCLUDE_SIMILAR_ROW_NAMES = false)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Begin()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Begin() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>CreateDifferentSubTables( const size_t NUMBER_TABLES, const size_t NUMBER_ROWS) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>End()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>End() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>ExtractDataPairs( const std::string &COL_NAME_A, const std::string &COL_NAME_B ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>ExtractSubTableFromColumns( const TableHeader &SUB_TABLE_HEADER) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>GetHeader() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>GetLongestRowName() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>GetNumberColumns() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>GetNumberRows() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>GetRowNames()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>GetSize() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>GetTransposedTable() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>GetWidestRowName() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>HasRow( const std::string &ROW_NAME) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>InsertRow( const std::string &ROW_NAME, const Vector< t_DataType> &DATA, const bool INCLUDE_SIMILAR_ROW_NAMES = false )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>InsertRow( const std::string &ROW_NAME, const bool INCLUDE_SIMILAR_ROW_NAMES = false )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>InsertRows( const Vector< std::string> &ROW_NAMES)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>InternalData() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>IsEmpty() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>MaxSize() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>PushBack( const Pair< std::string, Row< t_DataType> > &NAME_ROW)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>ReadFormatted( std::istream &ISTREAM, const bool INCLUDE_SIMILAR_ROW_NAMES = false )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Remove( iterator ITR)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Remove( iterator ITR_FIRST, iterator ITR_LAST)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>RemoveRow( const std::string &ROW_NAME)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Reset()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>ReverseBegin()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>ReverseBegin() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>ReverseEnd()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>ReverseEnd() const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>RowIndex( const std::string &ROW_NAME) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>SortByColumn( const std::string &COLUMN_NAME, const util::BinaryFunctionInterface< t_DataType, t_DataType, bool> &BINARY_PREDICATE = ( **math::Comparisons< t_DataType>::GetEnums().e_Less) )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>SortByRowName( const t_BinaryPredicate &BINARY_PREDICATE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Table( const Table< t_DataType> &TABLE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Table( const TableHeader &TABLE_HEADER)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Table( const const_iterator &ITR_BEGIN, const const_iterator &ITR_END)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Table( const util::ShPtr< TableHeader> &SP_TABLE_HEADER)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>Table()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>WriteFormatted( std::ostream &OSTREAM, const util::Format &FORMAT_COLS = util::Format().W( 10).R(), const std::string &TITLE = GetStaticClassName< Table< t_DataType> >() ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>WriteFormattedWithoutNames( std::ostream &OSTREAM, const util::Format &FORMAT_COLS = util::Format().W( 10) ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>WriteSubTable( std::ostream &OSTREAM, const Vector< std::string> &COL_NAMES, const Vector< std::string> &ROW_NAMES, const std::vector< util::Format> &FORMATS, const bool WRITE_HEADER ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>WriteSubTable( std::ostream &OSTREAM, const Vector< std::string> &COL_NAMES, const Vector< std::string> &ROW_NAMES, const util::Format &FORMAT = util::Format().W( 10), const bool WRITE_HEADER = false ) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>operator []( const std::string &ROW_NAME)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table.h</td>
        <td>Table</td>
        <td>operator []( const std::string &ROW_NAME) const
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table.h</td>
        <td></td>
        <td>operator ==( const Table< t_DataType> &TABLE_A, const Table< t_DataType> &TABLE_B )
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>GetColumnFormats( const util::Format &TEMPLATE_FORMAT) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>HasColumn( const std::string &COLUMN_NAME) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>HasColumns( const Vector< std::string> &COLUMN_NAME_VECTOR) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>TableHeader( const TableHeader &TABLE_HEADER)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>TableHeader( const Vector< std::string> &TABLE_HEADER)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>TableHeader()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>WriteFormatted( std::ostream &OSTREAM, const std::vector< util::Format> &COLUMN_FORMATS ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>WriteFormatted( std::ostream &OSTREAM, const util::Format &FORMAT_COLS = util::Format().W( 10) ) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>operator =( const TableHeader &TABLE_HEADER)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_table_header.h</td>
        <td>TableHeader</td>
        <td>operator []( const std::string &COLUMN_NAME) const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_triplet.h</td>
        <td>GreaterThanThird</td>
        <td>operator ()( const Triplet< t_First, t_Second, t_Third> &TRIPLET_A, const Triplet< t_First, t_Second, t_Third> &TRIPLET_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_triplet.h</td>
        <td>LessThanFirst</td>
        <td>operator ()( const Triplet< t_First, t_Second, t_Third> &TRIPLET_A, const Triplet< t_First, t_Second, t_Third> &TRIPLET_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_triplet.h</td>
        <td>LessThanSecond</td>
        <td>operator ()( const Triplet< t_First, t_Second, t_Third> &TRIPLET_A, const Triplet< t_First, t_Second, t_Third> &TRIPLET_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_triplet.h</td>
        <td>LessThanThird</td>
        <td>operator ()( const Triplet< t_First, t_Second, t_Third> &TRIPLET_A, const Triplet< t_First, t_Second, t_Third> &TRIPLET_B ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_triplet.h</td>
        <td>Triplet</td>
        <td>First()
</td>
        <td>staritrd, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_triplet.h</td>
        <td>Triplet</td>
        <td>First() const
</td>
        <td>staritrd, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_triplet.h</td>
        <td>Triplet</td>
        <td>Second()
</td>
        <td>staritrd, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_triplet.h</td>
        <td>Triplet</td>
        <td>Second() const
</td>
        <td>staritrd, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_triplet.h</td>
        <td>Triplet</td>
        <td>Third()
</td>
        <td>staritrd, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_triplet.h</td>
        <td>Triplet</td>
        <td>Third() const
</td>
        <td>staritrd, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_triplet.h</td>
        <td>Triplet</td>
        <td>Triplet( const Triplet &TRIPLET)
</td>
        <td>staritrd, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_triplet.h</td>
        <td>Triplet</td>
        <td>Triplet( const t_First &FIRST, const t_Second &SECOND, const t_Third &THIRD)
</td>
        <td>staritrd, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_triplet.h</td>
        <td>Triplet</td>
        <td>Triplet()
</td>
        <td>staritrd, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_triplet.h</td>
        <td></td>
        <td>AddInstance( new Triplet< t_First, t_Second, t_Third>())
</td>
        <td>staritrd, mendenjl, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_triplet.h</td>
        <td></td>
        <td>operator <( const Triplet< t_First, t_Second, t_Third> &TRIPLET_A, const Triplet< t_First, t_Second, t_Third> &TRIPLET_B )
</td>
        <td>staritrd, mendenjl, meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_triplet.h</td>
        <td></td>
        <td>operator ==( const Triplet< t_First, t_Second, t_Third> &TRIPLET_A, const Triplet< t_First, t_Second, t_Third> &TRIPLET_B )
</td>
        <td>staritrd, mendenjl, meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>AllocateMemory( const size_t NUMBER_ELEMENTS)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Append( const Vector< t_DataType> &CONTAINER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Append( const t_DataType &ELEMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>AssertValidIteratorPosition( const size_t POS) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>AssertValidPosition( const size_t POS) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Begin()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Begin() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F, const t_DataType &DATA_G )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F, const t_DataType &DATA_G, const t_DataType &DATA_H )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F, const t_DataType &DATA_G, const t_DataType &DATA_H, const t_DataType &DATA_I )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F, const t_DataType &DATA_G, const t_DataType &DATA_H, const t_DataType &DATA_I, const t_DataType &DATA_J )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F, const t_DataType &DATA_G, const t_DataType &DATA_H, const t_DataType &DATA_I, const t_DataType &DATA_J, const t_DataType &DATA_K )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F, const t_DataType &DATA_G, const t_DataType &DATA_H, const t_DataType &DATA_I, const t_DataType &DATA_J, const t_DataType &DATA_K, const t_DataType &DATA_L )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F, const t_DataType &DATA_G, const t_DataType &DATA_H, const t_DataType &DATA_I, const t_DataType &DATA_J, const t_DataType &DATA_K, const t_DataType &DATA_L, const t_DataType &DATA_M, const t_DataType &DATA_N, const t_DataType &DATA_O )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F, const t_DataType &DATA_G, const t_DataType &DATA_H, const t_DataType &DATA_I, const t_DataType &DATA_J, const t_DataType &DATA_K, const t_DataType &DATA_L, const t_DataType &DATA_M, const t_DataType &DATA_N, const t_DataType &DATA_O, const t_DataType &DATA_P )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Create( const t_DataType &DATA_A, const t_DataType &DATA_B, const t_DataType &DATA_C, const t_DataType &DATA_D, const t_DataType &DATA_E, const t_DataType &DATA_F, const t_DataType &DATA_G, const t_DataType &DATA_H, const t_DataType &DATA_I, const t_DataType &DATA_J, const t_DataType &DATA_K, const t_DataType &DATA_L, const t_DataType &DATA_M, const t_DataType &DATA_N, const t_DataType &DATA_O, const t_DataType &DATA_P, const t_DataType &DATA_Q, const t_DataType &DATA_R, const t_DataType &DATA_S, const t_DataType &DATA_T, const t_DataType &DATA_U, const t_DataType &DATA_V )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>End()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>End() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Find( const t_OtherDataType &ELEMENT, const size_t START_POSITION = 0) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>FirstElement()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>FirstElement() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>GetSize() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>InsertElement( const t_DataType &ELEMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>InsertElement( const t_InputIterator ITR, const t_DataType &ELEMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>InsertElements( const size_t POS, const Vector< t_DataType> &VECTOR)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>InsertElements( const size_t POS, const t_DataType &ELEMENT, const size_t NUMBER_ELEMENTS = 1)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>InsertElements( iterator ITR_POS, const Vector< t_DataType> &CONTAINER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>InsertElements( iterator ITR_POS, t_InputIterator BEGIN, t_InputIterator END)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>InternalData()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>InternalData() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>IsEmpty() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Last()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Last() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>LastElement()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>LastElement() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>MaxSize() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>PopBack()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>PushBack( const t_DataType &ELEMENT = t_DataType())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>PushBack( t_DataType && ELEMENT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Remove( iterator ITR)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>RemoveElement( iterator ITR)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>RemoveElements( const size_t POS, const size_t NUMBER_ELEMENTS = 1)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>RemoveRandomElement()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Reorder( const Vector< size_t> &NEW_ORDER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Reset()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Resize( const size_t NUMBER_ELEMENTS, const t_DataType &ELEMENT = t_DataType())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>ReverseBegin()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>ReverseBegin() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>ReverseEnd()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>ReverseEnd() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>SetAllElements( const t_DataType &ELEMENT = t_DataType())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Shuffle()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Sort( t_BinaryPredicate COMPARABLE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Vector( Vector< t_DataType> && VECTOR)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Vector( const Vector< t_DataType> &VECTOR)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Vector( const Vector< t_DataType> &VECTOR, const size_t POS, const size_t LENGTH = std::numeric_limits< size_t>::max() )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Vector( const Vector< t_OtherDataType> &VECTOR)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Vector( const size_t SIZE, const t_DataType &VALUE = t_DataType())
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Vector( const size_t SIZE, const t_DataType *DATA)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Vector( const std::vector< t_DataType> &VECTOR)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Vector( const t_InputIterator &FIRST, const t_InputIterator &LAST)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>Vector()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>operator ()( const size_t POS)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>operator =( Vector< t_DataType> && VECTOR)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>operator =( const Vector< t_DataType> &VECTOR)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>operator []( const size_t POS)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td>Vector</td>
        <td>operator []( const size_t POS) const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td></td>
        <td>CreateIndexVector( const size_t &MIN, const size_t &MAX)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td></td>
        <td>CreateIndexVector( const size_t &N)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td></td>
        <td>operator !=( const Vector< t_DataType> &VECTOR_A, const Vector< t_DataType> &VECTOR_B )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector.h</td>
        <td></td>
        <td>operator <( const Vector< t_DataType> &VECTOR_LHS, const Vector< t_DataType> &VECTOR_RHS)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector.h</td>
        <td></td>
        <td>operator ==( const Vector< t_DataType> &VECTOR_A, const Vector< t_DataType> &VECTOR_B )
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>First()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>First() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>Fourth()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>Fourth() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>Second()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>Second() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>Third()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>Third() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( VectorND && A)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const VectorND &A)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const t_DataType &ELEMENT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const t_DataType &FIRST)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const t_DataType &FIRST, const t_DataType &SECOND)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const t_DataType &FIRST, const t_DataType &SECOND, const t_DataType &THIRD)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND( const t_DataType &FIRST, const t_DataType &SECOND, const t_DataType &THIRD, const t_DataType &FOURTH)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>VectorND()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator ()( const size_t POS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator ()( const size_t POS) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator =( VectorND && VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td>VectorND</td>
        <td>operator =( const VectorND &VECTOR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>AddInstance( new VectorND< 1, t_DataType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>AddInstance( new VectorND< 2, t_DataType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>AddInstance( new VectorND< 3, t_DataType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>AddInstance( new VectorND< 4, t_DataType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>AddInstance( new VectorND< t_Size, t_DataType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>operator !=( const VectorND< N, t_DataType> &VECTOR_ND_LHS, const VectorND< N, t_DataType> &VECTOR_ND_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>operator *( const T1 &VALUE, const VectorND< N, t_DataType> &VECTOR_ND)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>operator +=( const VectorND< N, t_DataType> &VECTOR_ND_A, const VectorND< N, t_DataType> &VECTOR_ND_B)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>operator <( const VectorND< N, t_DataType> &VECTOR_ND_LHS, const VectorND< N, t_DataType> &VECTOR_ND_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_storage_vector_nd.h</td>
        <td></td>
        <td>operator ==( const VectorND< N, t_DataType> &VECTOR_ND_LHS, const VectorND< N, t_DataType> &VECTOR_ND_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_type.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_type_is_derived_from.h</td>
        <td>IsDerived</td>
        <td>Test( t_Base *, int)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_type_is_derived_from.h</td>
        <td>IsDerived</td>
        <td>Test( t_Derived *, t_ArbitraryType)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_type_is_derived_from.h</td>
        <td>Tester</td>
        <td>operator t_Base*() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_type_is_derived_from.h</td>
        <td>Tester</td>
        <td>operator t_Derived*()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util.h</td>
        <td></td>
        <td>GetNamespaceIdentifier()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_assert.h</td>
        <td>Assert</td>
        <td>Exit( const std::string &ERRORMSG, const int ERROR_CODE, const char *FILE_NAME, const int LINE_NUMBER, const char *FUNCTION_NAME, const bool &DISPLAY_CALLSTACK )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_binary_function_stl_wrapper.h</td>
        <td>BinaryFunctionSTLWrapper</td>
        <td>BinaryFunctionSTLWrapper( const t_BinaryFunction &BINARY_FUNCTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_binary_function_stl_wrapper.h</td>
        <td>BinaryFunctionSTLWrapper</td>
        <td>BinaryFunctionSTLWrapper()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_binary_function_stl_wrapper.h</td>
        <td>BinaryFunctionSTLWrapper</td>
        <td>GetSerializer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_binary_function_stl_wrapper.h</td>
        <td>BinaryFunctionSTLWrapper</td>
        <td>operator ()( const typename t_BinaryFunction::first_argument_type &ARGUMENT1, const typename t_BinaryFunction::second_argument_type &ARGUMENT2 ) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_binary_function_stl_wrapper.h</td>
        <td></td>
        <td>AddInstance( new BinaryFunctionSTLWrapper< t_BinaryFunction>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_binary_function_wrapper.h</td>
        <td>BinaryFunctionWrapper</td>
        <td>BinaryFunctionWrapper( t_ResultType ( FUNCTION_TO_SUBMIT) t_ArgumentType1 &, t_ArgumentType2 &) )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_binary_function_wrapper.h</td>
        <td>BinaryFunctionWrapper</td>
        <td>operator ()( t_FunctionClass &OBJECT, t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_call_stack.h</td>
        <td>CallStack</td>
        <td>CallStack( const size_t DISCARD = 0)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_call_stack.h</td>
        <td>CallStack</td>
        <td>String() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_call_stack.h</td>
        <td>Entry</td>
        <td>Entry( const std::string &FILE_NAME, const size_t LINE_NUMBER, const std::string &FUNCTION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_call_stack.h</td>
        <td>Entry</td>
        <td>String() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_class_descriptor.h</td>
        <td></td>
        <td>ClassNameViaTemplatedFunction( const std::string &PRETTY_FUNCTION_NAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_class_descriptor.h</td>
        <td></td>
        <td>ExtractNamespaceIdentifier( const std::string &IDENTIFIER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_class_descriptor.h</td>
        <td></td>
        <td>GetStaticClassName( t_ClassType const &)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_class_descriptor.h</td>
        <td></td>
        <td>GetStaticClassName()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_class_descriptor.h</td>
        <td></td>
        <td>StandardizeClassName( const std::string &PRETTY_FUNCTION_NAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_class_name_standardizer.h</td>
        <td>ClassNameStandardizer</td>
        <td>Standardize( const std::string &NAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_class_name_standardizer.h</td>
        <td>ClassNameStandardizer</td>
        <td>StandardizeTemplateFunctionParameter( const std::string &NAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_cleanable_interface.h</td>
        <td>Cleanables</td>
        <td>GetCleanables()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_cleanable_interface.h</td>
        <td>Cleanables</td>
        <td>Register( CleanableInterface *CLEANABLE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_cleanable_interface.h</td>
        <td>Cleanables</td>
        <td>UnRegister( CleanableInterface *CLEANABLE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_color_gradient.h</td>
        <td>ColorGradient</td>
        <td>ColorGradient( const math::Range< double> &RANGE, const storage::Vector< Color> &GRADIENT_POINTS )
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_color_gradient.h</td>
        <td>ColorGradient</td>
        <td>ColorGradient()
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_color_gradient.h</td>
        <td>ColorGradient</td>
        <td>operator ()( const double &VALUE) const
</td>
        <td>alexanns, karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_colors.h</td>
        <td>Colors</td>
        <td>ConvertRGBToHSV( const linal::Vector3D &RGB_COLOR)
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_colors.h</td>
        <td>Colors</td>
        <td>GetRainbow() const
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_colors.h</td>
        <td></td>
        <td>GetColors()
</td>
        <td>karakam</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_cpp_data_types.h</td>
        <td>CPPDataTypes</td>
        <td>DataTypeFromTemplate()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_cpp_data_types.h</td>
        <td>CPPDataTypes</td>
        <td>GetCPPDatatypeName( const Types &DATA_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_cpp_data_types.h</td>
        <td>CPPDataTypes</td>
        <td>GetCPPString( const Types &DATA_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_cpu_benchmark_whetstone.h</td>
        <td>CPUBenchmarkWhetstone</td>
        <td>CPUBenchmarkWhetstone( const storage::Table< t_DataType> &RESULT_TABLE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_cpu_benchmark_whetstone.h</td>
        <td>CPUBenchmarkWhetstone</td>
        <td>CPUBenchmarkWhetstone()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_cpu_benchmark_whetstone.h</td>
        <td>CPUBenchmarkWhetstone</td>
        <td>GetAverageOperationsPerSecond() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_cpu_benchmark_whetstone.h</td>
        <td>CPUBenchmarkWhetstone</td>
        <td>GetResultTable() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_cpu_benchmark_whetstone.h</td>
        <td>CPUBenchmarkWhetstone</td>
        <td>RunBenchmark( const Time &DURATION)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_data_type.h</td>
        <td>DataType</td>
        <td>GetTypeName( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_data_type.h</td>
        <td>DataType</td>
        <td>IsUnderlyingTypeKnown( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_data_type.h</td>
        <td>DataType</td>
        <td>TestMustBeScalar( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_data_type.h</td>
        <td>DataType</td>
        <td>WriteSizeRequirements( std::ostream &OSTREAM, const size_t &MIN_SIZE, const size_t &MAX_SIZE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>Enum( EnumData< t_DataType> &ENUM_DATA)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>Enum( const Enum &ENUM)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>Enum( const UndefinedObject UNDEFINED)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>Enum( const char *NAME)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>Enum( const size_t &INDEX)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>Enum( const std::string &NAME)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>Enum()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>GetIndex() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>GetIterator()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>GetIterator() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>GetLabel( const bool &WITH_DATA = false) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>GetName() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>IsDefined() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>TryRead( const ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator !=( const Enum &RHS) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator *()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator *() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator ->()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator ->() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator <( const Enum &RHS) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator ==( const Enum &RHS) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator EnumData< t_DataType>()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator const EnumData< t_DataType>() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator size_t() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td>Enum</td>
        <td>operator std::string() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td></td>
        <td>IsDefined( const Enum< t_DataType, t_Derived> &ENUMERATOR)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum.h</td>
        <td></td>
        <td>IsDefined( const util::Enum< t_DataType, t_Derived> &ENUMERATOR)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum.h</td>
        <td></td>
        <td>operator <( const util::Enum< t_DataType, t_Derived> &ENUMERATOR_L, const util::Enum< t_DataType, t_Derived> &ENUMERATOR_R )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum_data.h</td>
        <td>EnumData</td>
        <td>EnumData( const size_t INDEX, const std::string &NAME, const t_DataType &OBJECT )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum_data.h</td>
        <td>EnumData</td>
        <td>EnumData()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum_data.h</td>
        <td>EnumData</td>
        <td>GetIndex() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum_data.h</td>
        <td>EnumData</td>
        <td>GetName() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum_data.h</td>
        <td>EnumData</td>
        <td>GetUndefinedData()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enum_data.h</td>
        <td>EnumData</td>
        <td>GetUndefinedEnumName()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enum_data.h</td>
        <td>EnumData</td>
        <td>operator =( const EnumData< t_DataType> &ENUM_DATA_RHS)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>AddEnum( const std::string &NAME, const t_DataType &OBJECT )
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>Begin()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>Begin() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>End()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>End() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumCount() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumFromIndex( const size_t INDEX)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumFromIndex( const size_t INDEX) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumFromName( const std::string &NAME)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumFromName( const std::string &NAME) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumIteratorFromEnum( const EnumType &ENUM)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumIteratorFromEnum( const EnumType &ENUM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumIteratorFromIndex( const size_t INDEX)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumIteratorFromIndex( const size_t INDEX) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumIteratorFromName( const std::string &NAME)
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumIteratorFromName( const std::string &NAME) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnumStrings() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetEnums()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetUndefined() const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>GetUndefinedData()
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>HaveEnumWithIndex( const size_t INDEX) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>HaveEnumWithName( const std::string &NAME) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>SetEnumFromName( EnumType &ENUM, const std::string &NAME, std::ostream &ERR_STREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerate.h</td>
        <td>Enumerate</td>
        <td>WriteList( std::ostream &OSTREAM) const
</td>
        <td>karakam, heinzes1, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerated.h</td>
        <td>Enumerated</td>
        <td>AddInstance( t_Interface *INSTANCE, const std::string &ALIAS = std::string())
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerated.h</td>
        <td>Enumerated</td>
        <td>Begin()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerated.h</td>
        <td>Enumerated</td>
        <td>End()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerated.h</td>
        <td>Enumerated</td>
        <td>Find( const std::string &ALIAS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerated.h</td>
        <td>Enumerated</td>
        <td>GetDefaultImplementation()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enumerated.h</td>
        <td>Enumerated</td>
        <td>GetSize()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enumerated.h</td>
        <td>Enumerated</td>
        <td>HaveImplementationWithAlias( const std::string &ALIAS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enums_instances.h</td>
        <td>EnumsInstances</td>
        <td>AddEnumsFromCommandline()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enums_instances.h</td>
        <td>EnumsInstances</td>
        <td>GetEnumsInstances()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_enums_instances.h</td>
        <td>EnumsInstances</td>
        <td>GetFlagEnumsFiles()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_enums_instances.h</td>
        <td>EnumsInstances</td>
        <td>GetSize() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>FFP( const size_t PREC)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>Fill( const char FILL = Ã)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>ForceW()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>Format()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>GetWidth() const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>L()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>R()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>S()
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>SFP( const size_t PREC)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>SetFlags( std::ios &IOSTREAM) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>UnsetFlags( std::ios &IOSTREAM) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>W( const size_t WIDTH)
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>operator ()( const double &VALUE) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>operator ()( const float &VALUE) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_format.h</td>
        <td>Format</td>
        <td>operator ()( const t_DataType &VALUE) const
</td>
        <td>meilerj</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_function_wrapper.h</td>
        <td>FunctionWrapper</td>
        <td>FunctionWrapper( t_ResultType ( FUNCTION_TO_SUBMIT) t_ArgumentType &) )
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_function_wrapper.h</td>
        <td>FunctionWrapper</td>
        <td>operator ()( t_FunctionClass &OBJECT, t_ArgumentType &ARGUMENT) const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_functional_type.h</td>
        <td>FunctionalType</td>
        <td>GetType( const size_t &N_WRAPPERS, const bool &OTHER_PARAMS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_functional_type.h</td>
        <td>FunctionalType</td>
        <td>GetTypeName( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_functional_type.h</td>
        <td>FunctionalType</td>
        <td>GetWrapperSize( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_functional_type.h</td>
        <td>FunctionalType</td>
        <td>TestIsParameterized( const Type &TYPE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>ConvertToShPtr( Implementation< t_Iface> &IMPL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>CreateIfPossible( const ObjectDataLabel &SERIALIZER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>Empty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>GetLabel( const bool &WITH_DATA = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>GetSerializedType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>GetSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>GetUndefinedInstanceName()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>HardCopy() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>Implementation( const Implementation &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>Implementation( const ObjectDataLabel &DATA_LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>Implementation( const ObjectDataLabel &DATA_LABEL, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>Implementation( const std::string &DATA_LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>Implementation( const t_Interface &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>Implementation( t_Interface *const &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>Implementation()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>InsertDataTypes( storage::Map< std::string, size_t> &TYPES, const bool &INCLUDE_OPTIONAL = true, const bool &INCLUDE_DATA = false, const size_t &MAX_DEPTH = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>PreReadHook( const ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>ReadDataSuccessHook( const ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>ReadInitializerSuccessHook( const ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>Reset()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>ResetHaveDisplayedHelp()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>SetHaveDisplayedHelp()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>SetHelpWriter( HelpWriterFunctionPtr FUNCTION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>SetUndefinedInstanceName( const std::string &NAME)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>WriteHelp( io::FixedLineWidthWriter &STREAM) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>WriteHelp( std::ostream &STREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>WriteInstancesHelp( io::FixedLineWidthWriter &STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>operator *()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>operator *() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>operator ->()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>operator ->() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>operator =( const Implementation &ORIGINAL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>operator =( const ObjectDataLabel &DATA_LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation.h</td>
        <td>Implementation</td>
        <td>operator =( const std::string &DATA_LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation.h</td>
        <td></td>
        <td>ConvertToShPtr( Implementation< t_Iface> &IMPL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation_interface.h</td>
        <td>ImplementationInterface</td>
        <td>GetSerializedType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation_interface.h</td>
        <td>ImplementationInterface</td>
        <td>operator =( const ObjectDataLabel &DATA_LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation_interface.h</td>
        <td>ImplementationInterface</td>
        <td>operator =( const std::string &DATA_LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation_interface.h</td>
        <td></td>
        <td>operator !=( const ImplementationInterface &NAME_A, const ImplementationInterface &NAME_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation_interface.h</td>
        <td></td>
        <td>operator <( const ImplementationInterface &NAME_A, const ImplementationInterface &NAME_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_implementation_interface.h</td>
        <td></td>
        <td>operator ==( const ImplementationInterface &NAME_A, const ImplementationInterface &NAME_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_implementation_interface.h</td>
        <td></td>
        <td>operator >( const ImplementationInterface &NAME_A, const ImplementationInterface &NAME_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_default.h</td>
        <td>LoggerDefault</td>
        <td>GetLogIdentifier() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_default.h</td>
        <td>LoggerDefault</td>
        <td>GetMaxLineWidth() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_default.h</td>
        <td>LoggerDefault</td>
        <td>LogError( const std::string &ERR_STRING)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_default.h</td>
        <td>LoggerDefault</td>
        <td>LogMessage( const std::string &MESSAGE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_default.h</td>
        <td>LoggerDefault</td>
        <td>LogStatus( const std::string &STATUS)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_default.h</td>
        <td>LoggerDefault</td>
        <td>LoggerDefault( const LoggerDefault &LOGGER_DEFAULT)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_default.h</td>
        <td>LoggerDefault</td>
        <td>LoggerDefault()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_default.h</td>
        <td>LoggerDefault</td>
        <td>SetLogIdentifier( const std::string &IDENTIFIER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_file.cpp</td>
        <td>LoggerFile</td>
        <td>CleanUp()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_file.cpp</td>
        <td>LoggerFile</td>
        <td>GetLogIdentifier() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_file.cpp</td>
        <td>LoggerFile</td>
        <td>GetMaxLineWidth() const
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_file.cpp</td>
        <td>LoggerFile</td>
        <td>LogMessage( const std::string &MESSAGE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_file.cpp</td>
        <td>LoggerFile</td>
        <td>LogStatus( const std::string &STATUS)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_file.cpp</td>
        <td>LoggerFile</td>
        <td>LoggerFile( const LoggerFile &LOGGER_FILE)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_file.cpp</td>
        <td>LoggerFile</td>
        <td>LoggerFile()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_file.cpp</td>
        <td>LoggerFile</td>
        <td>SetLogIdentifier( const std::string &IDENTIFIER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_interface.h</td>
        <td>LoggerInterface</td>
        <td>GetDefaultMaxLineWidth()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_interface.h</td>
        <td>LoggerInterface</td>
        <td>GetTerminalLineWidth()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_interface.h</td>
        <td>LoggerInterface</td>
        <td>LogError( const std::string &ERR_STRING)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_interface.h</td>
        <td>LoggerInterface</td>
        <td>LogStatus( const std::string &STATUS)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_interface.h</td>
        <td>LoggerInterface</td>
        <td>LoggerInterface( std::streambuf *STREAM_BUFFER)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_interface.h</td>
        <td>LoggerInterface</td>
        <td>LoggerInterface()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_logger_interface.h</td>
        <td>LoggerInterface</td>
        <td>SetIgnoreTerminalLineWidth( const bool &IGNORE_TERMINAL_LINE_WIDTH)
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_logger_interface.h</td>
        <td></td>
        <td>GetLogger()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_loggers.h</td>
        <td>Loggers</td>
        <td>GetCurrentLogger()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_loggers.h</td>
        <td>Loggers</td>
        <td>GetFlagLogger()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_loggers.h</td>
        <td>Loggers</td>
        <td>UpdateCurrentLoggerFromCommandLineFlag()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_loggers.h</td>
        <td></td>
        <td>GetLoggers()
</td>
        <td>heinzes1</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_memory_usage.h</td>
        <td>MemoryUsage</td>
        <td>GetPeakRAMUsed() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_memory_usage.h</td>
        <td>MemoryUsage</td>
        <td>GetPeakVirtualMemoryUsed() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_memory_usage.h</td>
        <td>MemoryUsage</td>
        <td>GetRAMInUse() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_memory_usage.h</td>
        <td>MemoryUsage</td>
        <td>GetVirtualMemoryInUse() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_memory_usage.h</td>
        <td>MemoryUsage</td>
        <td>MemoryUsage()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_memory_usage.h</td>
        <td>MemoryUsage</td>
        <td>WriteCurrentMemoryUsageInfo( std::ostream &STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_memory_usage.h</td>
        <td>MemoryUsage</td>
        <td>WritePeakMemoryUsageInfo( std::ostream &STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetCurrentMessageLevel() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetEnumDescriptor( const MessageLevel &LEVEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetEnumDescriptor( const MessageVerbosity &LEVEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetLevelString( const MessageLevel &MESSAGE_LEVEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetMessageLevelFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetMessageLevelParam()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetMessageVerbosity() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetMessageVerbosityParam()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetMessenger()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>GetVerbosityString( const MessageVerbosity &MESSAGE_VERBOSITY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>IsSmallerEqualCurrentMessageLevel( const MessageLevel MESSAGE_LEVEL) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>SendToUser( const MessageLevel &MESSAGE_LEVEL, const std::string &NAMESPACE, const std::string &MESSAGE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>SendToUser( const MessageLevel &MESSAGE_LEVEL, const std::string &NAMESPACE, const std::string &MESSAGE, const char *FILE_NAME, const int LINE_NUMBER, const char *FUNCTION_NAME )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>SendToUser( const std::string &NAMESPACE, const std::string &MESSAGE )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>SetMessageLevel( const MessageLevel MESSAGE_LEVEL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>SetMessageLevelFromCommandLineFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>SetMessageVerbosity( const MessageVerbosity MESSAGE_VERBOSITY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>SetMessageVerbosityFromCommandLineFlag()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_message.h</td>
        <td>Message</td>
        <td>UpdateMessengerFromCommandLine()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_message.h</td>
        <td></td>
        <td>GetMessenger()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ArgumentsToString( const bool &INCLUDE_PARENS = true, const char &ARGUMENT_DELIMITER = GetArgumentDelimiter() ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>Begin() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>Difference( const ObjectDataLabel &OTHER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>End() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>Find( const ObjectDataLabel &LABEL, const bool &RECURSIVE = true, const bool &CONSIDER_NAME = true ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>FindName( const std::string &NAME, const bool &RECURSIVE = true) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>FindValue( const std::string &VALUE, const bool &RECURSIVE = true) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>GetAllDelimiters()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>GetArgument( const size_t &POSITION) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>GetArgumentDelimiter()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>GetArguments() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>GetInlineFileDelimiter()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>GetName() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>GetNameValueDelimiter()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>GetNumberArguments() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>GetValue() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>IsEmpty() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>IsScalar() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( const ObjectDataLabel &PARENT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( const std::string &NAME, const ObjectDataLabel &OBJECT_LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( const std::string &NAME, const std::string &OBJECT_NAME, const ObjectDataLabel &ARG )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( const std::string &NAME, const std::string &OBJECT_NAME, const storage::Vector< ObjectDataLabel> &ARGS )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( const std::string &NAME, const std::string &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( const std::string &OBJECT_NAME, const std::vector< ObjectDataLabel> &ARGS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( const std::string &OBJECT_NAME, const storage::Vector< ObjectDataLabel> &ARGS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( const std::string &STR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( const storage::Vector< ObjectDataLabel> &ARGS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel( std::istream &STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ObjectDataLabel()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ReplaceValue( const std::string &VALUE, const std::string &REPLACEMENT, const size_t &MAX_DEPTH = size_t( -1))
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>SetName( const std::string &NEW_NAME, const bool &ALLOW_CHANGE = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>SetValue( const std::string &VALUE, const bool &ALLOW_CHANGE = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>TernaryCompare( const ObjectDataLabel &LABEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>TernaryCompareWithoutName( const ObjectDataLabel &LABEL) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ToNamedString( const size_t &LINE_LENGTH, const size_t &INDENT = 0, const size_t &MAX_DEPTH_FOR_SPLIT = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ToNamedString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ToNamedStringDefaultWidth( const size_t &INDENT = 0, const size_t &MAX_DEPTH_FOR_SPLIT = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ToNamedStringForLogger( const size_t &INDENT = 0, const size_t &MAX_DEPTH_FOR_SPLIT = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ToString( const size_t &LINE_LENGTH, const size_t &INDENT = 0, const size_t &MAX_DEPTH_FOR_SPLIT = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ToString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ToStringDefaultWidth( const size_t &INDENT = 0, const size_t &MAX_DEPTH_FOR_SPLIT = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>ToStringForLogger( const size_t &INDENT = 0, const size_t &MAX_DEPTH_FOR_SPLIT = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>TryAssign( const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>operator =( const ObjectDataLabel &LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>operator =( const std::string &LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td>ObjectDataLabel</td>
        <td>operator std::string() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td></td>
        <td>operator !=( const ObjectDataLabel &LABEL_A, const ObjectDataLabel &LABEL_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td></td>
        <td>operator <( const ObjectDataLabel &LABEL_A, const ObjectDataLabel &LABEL_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label.h</td>
        <td></td>
        <td>operator ==( const ObjectDataLabel &LABEL_A, const ObjectDataLabel &LABEL_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label.h</td>
        <td></td>
        <td>operator >( const ObjectDataLabel &LABEL_A, const ObjectDataLabel &LABEL_B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label_tokenizer.h</td>
        <td>ObjectDataLabelTokenizer</td>
        <td>FindEndQuote( const std::string &STR, const size_t &START_QUOTE_POS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label_tokenizer.h</td>
        <td>ObjectDataLabelTokenizer</td>
        <td>GetLastTokenType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label_tokenizer.h</td>
        <td>ObjectDataLabelTokenizer</td>
        <td>GetNextTokenType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label_tokenizer.h</td>
        <td>ObjectDataLabelTokenizer</td>
        <td>GetScopeDepth() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label_tokenizer.h</td>
        <td>ObjectDataLabelTokenizer</td>
        <td>GetString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label_tokenizer.h</td>
        <td>ObjectDataLabelTokenizer</td>
        <td>ObjectDataLabelTokenizer( const std::string &STR, const size_t &POSITION = 0)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_data_label_tokenizer.h</td>
        <td>ObjectDataLabelTokenizer</td>
        <td>Pop()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_data_label_tokenizer.h</td>
        <td>ObjectDataLabelTokenizer</td>
        <td>Validate( const std::string &STR, std::ostream &ERR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_instances.h</td>
        <td>ObjectInstances</td>
        <td>AddInstance( const ObjectInterface *INTERFACE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_instances.h</td>
        <td>ObjectInstances</td>
        <td>AddInstanceWithName( const ObjectInterface *INTERFACE, const std::string &NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_instances.h</td>
        <td>ObjectInstances</td>
        <td>GetKnownObjectNames() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_instances.h</td>
        <td>ObjectInstances</td>
        <td>GetPtrToObjectFromIdentifier( const std::string &DESCRIPTOR) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_instances.h</td>
        <td>ObjectInstances</td>
        <td>TryAddInstance( ObjectInterface *INTERFACE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_interface.h</td>
        <td>ObjectInterface</td>
        <td>ExtractIdentifier( std::istream &ISTREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_interface.h</td>
        <td>ObjectInterface</td>
        <td>ExtractNamespaceName( const std::string &PRETTY_FUNCTION_NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_interface.h</td>
        <td>ObjectInterface</td>
        <td>ReadIdentifier( std::istream &ISTREAM) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_interface.h</td>
        <td>ObjectInterface</td>
        <td>ReadObject( std::istream &ISTREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_interface.h</td>
        <td>ObjectInterface</td>
        <td>WriteIdentifier( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_interface.h</td>
        <td>ObjectInterface</td>
        <td>WriteObject( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_interface.h</td>
        <td></td>
        <td>operator <<( std::ostream &OSTREAM, const ObjectInterface &OBJECT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_object_interface.h</td>
        <td></td>
        <td>operator >>( std::istream &ISTREAM, ObjectInterface &OBJECT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_object_interface.h</td>
        <td></td>
        <td>operator >>( std::istream &ISTREAM, const ObjectInterface &OBJECT)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>GetPointer()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>GetPointer() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>IsDefined() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>IsOwner() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>OwnPtr( const OwnPtr< t_DataType> &OWN_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>OwnPtr( const OwnPtr< t_OtherDataType> &OWN_PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>OwnPtr( t_DataType *const OBJECT_PTR, const bool OWNERSHIP = true)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>OwnPtr( t_OtherDataType *const OBJECT_PTR, const bool OWNERSHIP = true)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>OwnPtr()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>operator *()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>operator *() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>operator ->()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>operator ->() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_own_ptr.h</td>
        <td>OwnPtr</td>
        <td>operator =( const OwnPtr< t_DataType> &ORIGINAL)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_ptr_interface.h</td>
        <td>PtrInterface</td>
        <td>AssertIsDefined() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_ptr_interface.h</td>
        <td>PtrInterface</td>
        <td>CheckValidPointerConversion( t_OtherDataType *const PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_ptr_interface.h</td>
        <td>PtrInterface</td>
        <td>CheckValidSmartPointerConversion( const t_PtrType< t_OtherDataType> &PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_ptr_interface.h</td>
        <td></td>
        <td>GetNullDescriptor()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_ptr_interface.h</td>
        <td></td>
        <td>IsDefined( const PtrInterface< t_DataType> &PTR)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_ptr_interface.h</td>
        <td></td>
        <td>NotifyUserBadPointerCast( const std::string &PTR_TYPE, const std::string &CAST_TYPE)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_ptr_interface.h</td>
        <td></td>
        <td>operator !=( const PtrInterface< t_DataTypeRight> &POINTER_LEFT, const PtrInterface< t_DataTypeLeft> &POINTER_RIGHT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_ptr_interface.h</td>
        <td></td>
        <td>operator <( const PtrInterface< t_DataTypeRight> &POINTER_LEFT, const PtrInterface< t_DataTypeLeft> &POINTER_RIGHT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_ptr_interface.h</td>
        <td></td>
        <td>operator <=( const PtrInterface< t_DataTypeRight> &POINTER_LEFT, const PtrInterface< t_DataTypeLeft> &POINTER_RIGHT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_ptr_interface.h</td>
        <td></td>
        <td>operator ==( const PtrInterface< t_DataTypeRight> &POINTER_LEFT, const PtrInterface< t_DataTypeLeft> &POINTER_RIGHT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_ptr_interface.h</td>
        <td></td>
        <td>operator >( const PtrInterface< t_DataTypeRight> &POINTER_LEFT, const PtrInterface< t_DataTypeLeft> &POINTER_RIGHT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_ptr_interface.h</td>
        <td></td>
        <td>operator >=( const PtrInterface< t_DataTypeRight> &POINTER_LEFT, const PtrInterface< t_DataTypeLeft> &POINTER_RIGHT )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_runtime_environment_default.h</td>
        <td>RuntimeEnvironmentDefault</td>
        <td>Finalize( const int STATUS) const
</td>
        <td>whitebc</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_runtime_environment_default.h</td>
        <td>RuntimeEnvironmentDefault</td>
        <td>GetProcessNumber() const
</td>
        <td>whitebc</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_runtime_environment_default.h</td>
        <td>RuntimeEnvironmentDefault</td>
        <td>Initialize() const
</td>
        <td>whitebc</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_runtime_environment_default.h</td>
        <td>RuntimeEnvironmentDefault</td>
        <td>IsStandAlone() const
</td>
        <td>whitebc</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_runtime_environment_default.h</td>
        <td>RuntimeEnvironmentDefault</td>
        <td>ResolveFileName( const std::string &FILE_NAME) const
</td>
        <td>whitebc</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_runtime_environment_default.h</td>
        <td>RuntimeEnvironmentDefault</td>
        <td>RuntimeEnvironmentDefault()
</td>
        <td>whitebc</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_runtime_environment_interface.h</td>
        <td>RuntimeEnvironmentInterface</td>
        <td>AddProcessNumberToName( const std::string &NAME) const
</td>
        <td>whitebc, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_runtime_environment_interface.h</td>
        <td>RuntimeEnvironmentInterface</td>
        <td>GetPathSeperator() const
</td>
        <td>whitebc, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_runtime_environment_interface.h</td>
        <td>RuntimeEnvironmentInterface</td>
        <td>ReportProgress( const double FRACTION_PROGRESS) const
</td>
        <td>whitebc, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_runtime_environment_interface.h</td>
        <td>RuntimeEnvironmentInterface</td>
        <td>RuntimeEnvironmentInterface()
</td>
        <td>whitebc, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_runtime_environment_interface.h</td>
        <td></td>
        <td>GetRuntimeEnvironment()
</td>
        <td>whitebc, karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_runtime_environments.h</td>
        <td>RuntimeEnvironments</td>
        <td>GetCurrentEnvironment() const
</td>
        <td>whitebc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_runtime_environments.h</td>
        <td>RuntimeEnvironments</td>
        <td>GetFlagRuntimeEnvironment()
</td>
        <td>whitebc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_runtime_environments.h</td>
        <td>RuntimeEnvironments</td>
        <td>UpdateCurrentRuntimeEnvironmentFromCommandLineFlag()
</td>
        <td>whitebc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_runtime_environments.h</td>
        <td></td>
        <td>GetRuntimeEnvironment()
</td>
        <td>whitebc, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_runtime_environments.h</td>
        <td></td>
        <td>GetRuntimeEnvironments()
</td>
        <td>whitebc, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>AssertRead( const ObjectDataLabel &LABEL)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>GetCompleteSerializer() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>GetLabel( const bool &INCLUDE_DATA = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>GetSerializationAddresses() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>GetSerializedType() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>GetString( const bool &INCLUDE_DATA = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>InferFunctionalType( const std::string &INTERFACE_STR = Ó) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>InsertDataTypes( storage::Map< std::string, size_t> &TYPES, const bool &INCLUDE_OPTIONAL = true, const bool &INCLUDE_DATA = false, const size_t &MAX_DEPTH = size_t( -1) ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>PreReadHook( const ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>ReadDataSuccessHook( const ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>ReadInitializerSuccessHook( const ObjectDataLabel &SERIALIZER, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>TryRead( const ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>ValidateRead( const ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>WriteHelp( io::FixedLineWidthWriter &WRITER) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td>SerializableInterface</td>
        <td>WriteHelp( std::ostream &STREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td></td>
        <td>operator <<( std::ostream &OSTREAM, const SerializableInterface &OBJECT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_serializable_interface.h</td>
        <td></td>
        <td>operator >>( std::istream &ISTREAM, SerializableInterface &OBJECT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_serializable_interface.h</td>
        <td></td>
        <td>operator >>( std::istream &ISTREAM, const SerializableInterface &OBJECT)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>GetConstPointer() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>GetPointer()
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>GetPointer() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>GetShPtrToNewObjectFromStream( std::istream &ISTREAM)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>GetSharedCommunitySize() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>HardCopy() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>IsDefined() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>Reset()
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>ShPtr( const ShPtr< t_DataType> &SH_PTR)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>ShPtr( const ShPtr< t_OtherDataType> &SH_PTR)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>ShPtr( t_DataType *const POINTER)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>ShPtr( t_OtherDataType *const POINTER)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>ShPtr()
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>operator *()
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>operator *() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>operator ->()
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>operator ->() const
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>operator =( const ShPtr< t_DataType> &SH_PTR)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td>ShPtr</td>
        <td>operator =( const ShPtr< t_OtherDataType> &SH_PTR)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr.h</td>
        <td></td>
        <td>CloneToShPtr( const t_DataType &OBJECT)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr.h</td>
        <td></td>
        <td>PtrHardCopy( const t_DataType *const &PTR)
</td>
        <td>mendenjl, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>HardCopy() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>IsDefined() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>ShPtrList( ShPtrList && A)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>ShPtrList( const ShPtrList &A)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>ShPtrList( const size_t SIZE = 0, const ShPtr< t_DataType> &DATA = ShPtr< t_DataType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>ShPtrList( const size_t SIZE, t_DataType *const DATA)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>ShPtrList( const t_Iterator &FIRST, const t_Iterator &LAST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>operator =( ShPtrList && LIST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>operator =( const ShPtrList &LIST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_list.h</td>
        <td>ShPtrList</td>
        <td>operator SiPtrList< t_DataType>()
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>GetIndex( const ShPtr< t_DataType> &ELEMENT) const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>GetIndex( const t_DataType *ELEMENT) const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>HardCopy() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>Initialize( const t_DataType &ELEMENT = t_DataType())
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>InsertElement( const size_t POS, const ShPtr< t_DataType> &SHAREDPOINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>InsertElement( const size_t POS, const t_DataType &ELEMENT = t_DataType())
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>IsDefined() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector( ShPtrVector< t_DataType> && SHAREDPOINTERVECTOR)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector( const ShPtrVector< t_DataType> &SHAREDPOINTERVECTOR)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector( const ShPtrVector< t_DerivedDataType> &SHAREDPOINTERVECTOR)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector( const size_t LENGTH)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector( const size_t LENGTH, const ShPtr< t_DataType> &SP_ELEMENT)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector( const size_t LENGTH, const t_DataType &ELEMENT)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector( const size_t SIZE, t_DataType *const DATA)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector( const storage::Vector< ShPtr< t_DataType> > &STORAGEVECTORSHAREDPOINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector( const t_Iterator &FIRST, const t_Iterator &LAST)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>ShPtrVector()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>SubShPtrVector( const size_t POS, const size_t LENGTH) const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>SubShPtrVector( const std::pair< size_t, size_t> POS) const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>operator =( ShPtrVector && VECTOR)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>operator =( const ShPtrVector< t_DataType> &SH_PTR_VECTOR)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>operator SiPtrVector< const t_DataType>() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>operator SiPtrVector< const t_OtherDataType>() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>operator SiPtrVector< t_DataType>()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td>ShPtrVector</td>
        <td>operator SiPtrVector< t_OtherDataType>()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_sh_ptr_vector.h</td>
        <td></td>
        <td>AddInstance( new ShPtrVector< t_DataType>())
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>GetPointer()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>GetPointer() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>IsDefined() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>Reset()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr( PtrInterface< t_DataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr( PtrInterface< t_OtherDataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr( const PtrInterface< t_DataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr( const PtrInterface< t_OtherDataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr( const SiPtr< t_DataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr( const SiPtr< t_OtherDataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr( t_DataType &OBJECT)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr( t_DataType *const POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr( t_OtherDataType *const POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>SiPtr()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator *()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator *() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator ->()
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator ->() const
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator =( const PtrInterface< t_DataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator =( const PtrInterface< t_OtherDataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator =( const SiPtr< t_DataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator =( const SiPtr< t_OtherDataType> &POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator =( t_DataType *const POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td>SiPtr</td>
        <td>operator =( t_OtherDataType *const POINTER)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td></td>
        <td>ToSiPtr( const ShPtr< const t_DataType> &OBJECT)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td></td>
        <td>ToSiPtr( const t_DataType &OBJECT)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td></td>
        <td>ToSiPtrNonConst( t_DataType &OBJECT)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr.h</td>
        <td></td>
        <td>operator >>( std::istream &ISTREAM, SiPtr< const t_DataType> &)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr.h</td>
        <td></td>
        <td>operator >>( std::istream &ISTREAM, const SiPtr< const t_DataType> &)
</td>
        <td>meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>IsDefined() const
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>PushBack( t_DataType *const POINTER)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>PushFront( t_DataType *const POINTER)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>SiPtrList( SiPtrList< t_DataType> && SI_PTR_LIST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>SiPtrList( const SiPtrList< t_DataType> &SI_PTR_LIST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>SiPtrList( const size_t SIZE = 0, const SiPtr< t_DataType> &DATA = SiPtr< t_DataType>())
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>SiPtrList( const size_t SIZE, t_DataType *const DATA)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>SiPtrList( const t_Iterator &FIRST, const t_Iterator &LAST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>operator =( SiPtrList && SI_PTR_LIST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_list.h</td>
        <td>SiPtrList</td>
        <td>operator =( const SiPtrList &SI_PTR_LIST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_list.h</td>
        <td></td>
        <td>ConvertToConstSiPtrList( t_Iterator FIRST, t_Iterator LAST )
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_list.h</td>
        <td></td>
        <td>ConvertToSiPtrList( t_Iterator FIRST, t_Iterator LAST)
</td>
        <td>alexanns</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>Create( t_DataType &DATA_A, t_DataType &DATA_B )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>Create( t_DataType &DATA_A, t_DataType &DATA_B, t_DataType &DATA_C )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>Create( t_DataType &DATA_A, t_DataType &DATA_B, t_DataType &DATA_C, t_DataType &DATA_D )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>Create( t_DataType &DATA_A, t_DataType &DATA_B, t_DataType &DATA_C, t_DataType &DATA_D, t_DataType &DATA_E )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>Create( t_DataType &DATA_A, t_DataType &DATA_B, t_DataType &DATA_C, t_DataType &DATA_D, t_DataType &DATA_E, t_DataType &DATA_F )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>GetIndex( const SiPtr< t_DataType> &ELEMENT )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>GetIndex( const t_DataType *ELEMENT) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>InsertElement( const size_t POS, const SiPtr< t_DataType> SIMPLE_POINTER)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>InsertElement( const size_t POS, t_DataType *const POINTER)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>IsDefined() const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>PushBack( const SiPtr< t_DataType> &SIMPLE_POINTER)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>PushBack( t_DataType *const POINTER)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SiPtrVector( SiPtrVector< t_DataType> && SI_PTR_VECTOR_RHS)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SiPtrVector( SiPtrVector< t_OtherDataType> &SI_PTR_VECTOR_RHS)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SiPtrVector( const II &FIRST, const II &LAST)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SiPtrVector( const SiPtr< t_DataType> &SIMPLE_POINTER)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SiPtrVector( const SiPtr< t_DataType> &SIMPLE_POINTER_A, const SiPtr< t_DataType> &SIMPLE_POINTER_B)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SiPtrVector( const SiPtrVector< t_DataType> &SI_PTR_VECTOR_RHS)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SiPtrVector( const SiPtrVector< t_OtherDataType> &SI_PTR_VECTOR_RHS)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SiPtrVector( const size_t SIZE = 0)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SiPtrVector( const size_t SIZE, t_DataType *const DATA)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SubSiPtrVector( const size_t POS, const size_t LENGTH) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>SubSiPtrVector( const std::pair< size_t, size_t> &POS) const
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>operator =( SiPtrVector< t_DataType> && SI_PTR_VECTOR)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td>SiPtrVector</td>
        <td>operator =( const SiPtrVector< t_DataType> &SI_PTR_VECTOR)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td></td>
        <td>ConvertToConstSiPtrVector( const storage::Vector< t_DataType> &STORAGE_VECTOR )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td></td>
        <td>ConvertToSiPtrVector( storage::Vector< t_DataType> &STORAGE_VECTOR )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td></td>
        <td>ConvertToStorageVector( const SiPtrVector< t_OtherDataType> &SIMPLE_POINTER_VECTOR )
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_si_ptr_vector.h</td>
        <td></td>
        <td>operator *( const T2 &VALUE, const SiPtrVector< t_DataType> &SIMPLEPOINTERVECTOR)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_si_ptr_vector.h</td>
        <td></td>
        <td>operator +=( const SiPtrVector< t_DataType> &SIMPLEPOINTERVECTOR_A, const SiPtrVector< t_DataType> &SIMPLEPOINTERVECTOR_B)
</td>
        <td>karakam, meilerj, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_static_initialization_fiasco_finder.h</td>
        <td></td>
        <td>WriteFiasco( const std::string &FILE_NAME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>GetDescription() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>GetLastStartTime() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>GetProcessDuration() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>GetTotalTime() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>IsRunning() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>Reset()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>Start()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>Stop()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>Stopwatch( const bool PRINT_ON_DESTRUCTION = true)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>Stopwatch( const std::string &DESCRIPTION, const Message::MessageLevel &MESSAGE_LEVEL, const bool PRINT_ON_DESTRUCTION, const bool AUTO_START = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>Stopwatch( const std::string &DESCRIPTION, const Time &NOTIFICATION_INTERVAL = Time( std::numeric_limits< size_t>::max(), 0), const Message::MessageLevel &MESSAGE_LEVEL = Message::e_Verbose, const bool PRINT_ON_DESTRUCTION = true, const bool AUTO_START = true )
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_stopwatch.h</td>
        <td>Stopwatch</td>
        <td>WriteMessage() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>ChopHeader( std::istream &ISTREAM)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>ConvertStringToBoolean( const std::string &STRING)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>ConvertStringToNumericalValue( const std::string &STRING)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>EndsWith( const std::string &STRING, const std::string &TEST_SUFFIX)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>IsNumerical( const std::string &STRING)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>Join( const std::string &JOINER, const storage::Vector< std::string> &STRINGS)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>LStrip( const std::string &STRING, const std::string &CHARS_TO_STRIP)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>LengthOfFloatingPointType( const std::string &STRING, const size_t &START = 0)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>LengthOfIntegerType( const std::string &STRING, const size_t &START = 0)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>LengthOfUnsignedIntegerType( const std::string &STRING, const size_t &START = 0)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>MaximumMatchingSubstring( const std::string &STRING_A, const std::string &STRING_B, const size_t &MINIMUM_SIZE = 5)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>RFindMatchingBracket( const std::string &STRING, const size_t POSITION, const char BRACKET_OPEN, const char BRACKET_CLOSE )
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>RStrip( const std::string &STRING, const std::string &CHARS_TO_STRIP)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>ReadNumberFromStream( std::istream &ISTREAM)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>RemoveSpacesFromString( const std::string &STRING)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>Repeat( const std::string &STRING, const size_t &REPETITIONS)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>ReplaceString( const std::string &ORIGINAL, const std::string &REPLACE, const std::string &REPLACEMENT)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>SplitString( const std::string &STRING, const std::string &SPLITTER = Ó)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>SplitStringToNumerical( const std::string &STRING, const std::string &SPLITTER = Ó)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>SplittedStringLineListFromIStream( std::istream &ISTREAM, const std::string &SPLITTER = Ó )
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>StartsWith( const std::string &STRING, const std::string &TEST_PREFIX)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>StringLineListFromIStream( std::istream &ISTREAM)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>StringListFromCharacterArray( const int NUMBER_ARGUMENTS, const char *ARGUMENTS[])
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>StringListFromIStream( std::istream &ISTREAM)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>Strip( const std::string &STRING, const std::string &CHARS_TO_STRIP)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>ToLower( const std::string &STRING)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>ToUpper( const std::string &STRING)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>TrimString( const std::string &STRING)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_functions.h</td>
        <td></td>
        <td>WrapString( const std::string &STRING, const size_t LINE_LENGTH, const std::string &WRAPPER_CHARS = Ó)
</td>
        <td>karakam, mendenjl, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( bool &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( char &TYPE, const char &MIN, const char &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( char &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( double &TYPE, const double &MIN, const double &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( double &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( float &TYPE, const float &MIN, const float &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( float &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( int &TYPE, const int &MIN, const int &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( int &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( long &TYPE, const long &MIN, const long &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( long &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( long long &TYPE, const long long &MIN, const long long &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( long long &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( short &TYPE, const short &MIN, const short &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( short &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( signed char &TYPE, const signed char &MIN, const signed char &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( signed char &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned char &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned char &TYPE, const unsigned char &MIN, const unsigned char &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned int &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned int &TYPE, const unsigned int &MIN, const unsigned int &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned long &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned long &TYPE, const unsigned long &MIN, const unsigned long &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned long long &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned long long &TYPE, const unsigned long long &MIN, const unsigned long long &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned short &TYPE, const std::string &STR, std::ostream &ERR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_numeric_conversion.h</td>
        <td></td>
        <td>TryConvertFromString( unsigned short &TYPE, const unsigned short &MIN, const unsigned short &MAX, const std::string &STR, std::ostream &ERR_STREAM )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>FindAllMatches( const std::string &STRING_TO_SEARCH ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>FindNextMatch( const std::string &STRING_TO_SEARCH, const size_t &START_POSITION ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>GetMatch() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>GetMatchContext() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>GetMatchContextDescription( const MatchContext &ENUM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>IsNonVariableCharacter( const char &CHAR)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>ReplaceAllIn( std::string &STRING) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>ReplaceEachIn( std::string &STRING) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>ReplaceEachWithExclusions( std::string &STRING, const storage::List< StringReplacement> &EXCLUSIONS ) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>SafeReplaceAt( const std::string &STRING, const size_t &POSITION, const size_t &FOUND_STRING_SIZE, const std::string &REPLACE_STRING )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>SafeSubstr( const std::string &STRING, const size_t &POSITION, const size_t &SIZE = std::string::npos )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>StringReplacement( const MatchContext &CONTEXT, const std::string &MATCH, const std::string &REPLACE = std::string() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>StringReplacement()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_string_replacement.h</td>
        <td>StringReplacement</td>
        <td>operator <( const StringReplacement &A, const StringReplacement &B)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_tertiary_function_wrapper.h</td>
        <td>TertiaryFunctionWrapper</td>
        <td>TertiaryFunctionWrapper( t_ResultType ( FUNCTION_TO_SUBMIT) t_ArgumentType1 &, t_ArgumentType2 &, t_ArgumentType3 &))
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_tertiary_function_wrapper.h</td>
        <td>TertiaryFunctionWrapper</td>
        <td>operator ()( t_FunctionClass &OBJECT, t_ArgumentType1 &ARGUMENT1, t_ArgumentType2 &ARGUMENT2, t_ArgumentType3 &ARGUMENT3)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_thunk_wrapper.h</td>
        <td>ThunkWrapper</td>
        <td>ThunkWrapper( PtrToConstMemberFunction QUERY_TO_SUBMIT)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_thunk_wrapper.h</td>
        <td>ThunkWrapper</td>
        <td>ThunkWrapper( PtrToMemberFunction FUNCTION_TO_SUBMIT)
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_thunk_wrapper.h</td>
        <td>ThunkWrapper</td>
        <td>ThunkWrapper( t_ResultType ( FUNCTION_TO_SUBMIT)))
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_thunk_wrapper.h</td>
        <td>ThunkWrapper</td>
        <td>operator ()( const t_FunctionClass &OBJECT) const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_thunk_wrapper.h</td>
        <td>ThunkWrapper</td>
        <td>operator ()( t_FunctionClass &OBJECT) const
</td>
        <td>riddeljs</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>ConvertTimeToMinutesString( const Time &TIME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>CreateTimeFromCompilerMacro( const std::string &DATE, const std::string &TIME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>CreateTimeFromHours( const size_t HOURS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>CreateTimeFromMinutesString( Time &TIME, const std::string &INIT, std::ostream &ERR_STREAM)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>Delay( const Time &DELAY)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetCurrent()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetMicroSeconds() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetSeconds() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetSecondsFractional() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetTimeAsDate() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetTimeAsDayHourMinuteSecond() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetTimeAsHourMinuteSecond() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetTimeAsHourMinuteSecondMilliSeconds() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetTotalMicroseconds() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>GetTotalMilliseconds() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>IsZero() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>SetToCurrentTime()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>SetZero()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>Time( const size_t &SECONDS, const size_t &MICROSECONDS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>Time()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>operator +=( const Time &TIME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td>Time</td>
        <td>operator -=( const Time &TIME)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td></td>
        <td>operator !=( const Time &TIME_LHS, const Time &TIME_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td></td>
        <td>operator +( const Time &TIME_LHS, const Time &TIME_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td></td>
        <td>operator -( const Time &TIME_LHS, const Time &TIME_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td></td>
        <td>operator <( const Time &TIME_LHS, const Time &TIME_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td></td>
        <td>operator <=( const Time &TIME_LHS, const Time &TIME_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td></td>
        <td>operator ==( const Time &TIME_LHS, const Time &TIME_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_time.h</td>
        <td></td>
        <td>operator >( const Time &TIME_LHS, const Time &TIME_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_time.h</td>
        <td></td>
        <td>operator >=( const Time &TIME_LHS, const Time &TIME_RHS)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>GetUndefined()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>GetUndefinedDouble()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>GetUndefinedSize_t()
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const UndefinedObject &OBJECT)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const double DOUBLE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const float FLOAT)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const int INT)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const long LONG)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const long long LONG)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const short SHORT)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const unsigned int SIZE_T)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const unsigned long SIZE_T)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const unsigned long long SIZE_T)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsDefined( const unsigned short SIZE_T)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsNaN( const double &DOUBLE)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsNaN( const float &FLOAT)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_undefined.h</td>
        <td></td>
        <td>IsNaN( const t_DataType &INTEGER)
</td>
        <td>karakam, woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>ObjReference</td>
        <td>IsDefined() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_voxel_grid.h</td>
        <td>ObjReference</td>
        <td>ObjReference( const SiPtr< const t_DataType> &OBJ = SiPtr< const t_DataType>(), const SiPtr< const linal::Vector3D> &COORD = SiPtr< const linal::Vector3D>() )
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>ObjReference</td>
        <td>Read( std::istream &ISTREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_voxel_grid.h</td>
        <td>ObjReference</td>
        <td>Write( std::ostream &OSTREAM, const size_t INDENT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>Clear()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>ExtractPositions( const SiPtr< const t_DataType> &INPUT) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>GetDimension() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>GetNeighbors( const double &NEIGHBORHOOD) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>GetNeighbors( const linal::Vector3D &INPUT, const double &NEIGHBORHOOD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>GetNeighbors( const t_DataType &INPUT, const double &NEIGHBORHOOD)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>GetNeighborsIn( const VoxelGrid &GRID, const double &NEIGHBORHOOD) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>GetNumberItems() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>InsertObject( const t_DataType &NEW_ITEM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>InsertObjects( const SiPtrVector< const t_DataType> NEW_ITEMS)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>RemoveObject( const t_DataType &ITEM_TO_REMOVE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>RemoveObjects( const SiPtrVector< const t_DataType> &ITEMS_TO_REMOVE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>SetObjects( const SiPtrVector< const t_DataType> &NEW_DATA)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>Translate( const linal::Vector3D &TRANSLATION)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_voxel_grid.h</td>
        <td>VoxelGrid</td>
        <td>VoxelGrid( const double &RESOLUTION = 4.0, const bool &CACHE_EDGES = false)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper.h</td>
        <td>Wrapper</td>
        <td>GetData()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper.h</td>
        <td>Wrapper</td>
        <td>GetData() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper.h</td>
        <td>Wrapper</td>
        <td>Wrapper( const Wrapper< t_DataType> &WRAPPER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper.h</td>
        <td>Wrapper</td>
        <td>Wrapper( const t_DataType &DATA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper.h</td>
        <td>Wrapper</td>
        <td>Wrapper()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper.h</td>
        <td></td>
        <td>AddInstance( new Wrapper< t_ArgumentType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_base.h</td>
        <td>WrapperBase</td>
        <td>WrapperBase( const WrapperBase< t_BaseType> &WRAPPER)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_base.h</td>
        <td>WrapperBase</td>
        <td>WrapperBase( const t_BaseType &DATA)
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_base.h</td>
        <td>WrapperBase</td>
        <td>WrapperBase()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_base.h</td>
        <td>WrapperBase</td>
        <td>operator const t_BaseType() const
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_base.h</td>
        <td>WrapperBase</td>
        <td>operator t_BaseType()
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_base.h</td>
        <td></td>
        <td>AddInstance( new WrapperBase< t_ArgumentType>())
</td>
        <td>woetzen</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>GetEnum() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>GetEnumVector()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>GetLabel( const bool &WITH_DATA = false) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>GetString() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>GetStringVector()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>TryRead( const ObjectDataLabel &LABEL, std::ostream &ERROR_STREAM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>WrapperEnum( const WrapperEnum &WRAPPER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>WrapperEnum( const std::string &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>WrapperEnum( const t_Enum &VALUE)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>WrapperEnum()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>WriteHelp( std::ostream &OSTREAM, const size_t INDENT = 0) const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator !=( const WrapperEnum &WRAPPER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator !=( const t_Enum &ENUM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator ++()
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator =( const WrapperEnum &ENUM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator =( const std::string &STRING)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator =( const t_Enum &ENUM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator ==( const WrapperEnum &WRAPPER)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator ==( const t_Enum &ENUM)
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#FAF0D4">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator const std::string &() const
</td>
        <td>mendenjl</td>
      </tr>
      <tr bgcolor="#F3DFA8">
        <td>bcl_util_wrapper_enum.h</td>
        <td>WrapperEnum</td>
        <td>operator const t_Enum &() const
</td>
        <td>mendenjl</td>
      </tr>
  </tbody>
</table>
</html>
